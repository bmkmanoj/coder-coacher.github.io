<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The (Awesome) Future of Web Apps | Coder Coacher - Coaching Coders</title><meta content="The (Awesome) Future of Web Apps - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The (Awesome) Future of Web Apps</b></h2><h5 class="post__date">2018-03-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UuphWMnnlqo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so the future of web apps today we're
gonna I'm gonna give you a PW a
refresher so just like a five-minute
intro to progressive Web Apps because I
know there was another session for
progressive web apps also workshop and
then I'm gonna give you some best
practices that go well with pwace and
even if you're not using pwace so the
best practices for the modern web and
also we're gonna see some modern web
api's and finally I'm gonna show you how
all of this converged towards the future
so let's start to the PWA refresher and
the way I like to think of a PWA
is to say this is an ongoing solution
for the problems of the mobile web so
the web is slow and the mobile web is
even slower and progressive web apps aim
to solve this so this is an ongoing
solution because it's not something
fixed is still in development so this is
how your users can add a PWA to the
homescreen
so once they have this icon on the home
screen the browser UI doesn't show any
more and this gives the user an
immersive host an immersive experience
and all of this can be configured
through a manifest file a manifest
adjacent file which gives you some key
value pairs where you can specify the
short name name theme color background
color all of them are fairly standard I
mean simple except for the display stand
alone this is the most important one
this is the one that hides the browser
of your eye and then you also have
serviceworkers and traditionally this is
your page and this is the Internet and
you have a network request which goes to
the Internet
and then you get back to the you get the
response back but once you install a
serviceworker you'll be able to
intercept those requests so the
serviceworker acts like a proxy which
intercepts network requests when they're
going to the network and when you get
the response back and this is very
powerful because it lets us do a lot of
cool things first of all we can make our
apps work offline you can also receive
push notifications and we can also do
background sync so how do you register a
serviceworker
first of all it's not supported on all
browsers so let's make sure there's
support for it on this browser and then
we register a serviceworker
using the register register method and
this file normally has to be on the root
level if you put it inside like the
scripts folder you'll only be able to
intercept requests going out of the
scripts folder so this is like security
feature and this is a regular promise so
you can resolve it or you can catch if
there is an error but how do we write
serviceworker code you can research on
the internet and see that you can
actually write it yourself but it's not
really recommended you can use a library
such as Google Chrome sw-precache so
this is a node module that lets you
configure it and say I want to have the
index of HTML and I want to have all the
images inside the images folder to be
part of the pre cache which means as
soon as the user register the
serviceworker I need to have these in
the cache so for the next time the user
opens this page I can reliably serve
so then you run this the node module
passing the configuration file and you
will get the Service Worker JavaScript
file so here's how it looks like so now
we have the cache and we can decide to
completely bypass the internet because
we have the stuff in the cache and we'll
return this these information reliably
and consistently to the user so
regardless of the internet to slow if
we're offline and this is the power that
serviceworkers gives us so before to
ship the index.html and those images we
have to go to the Internet which is okay
for the first time but on subsequent
requests we might not have good internet
connectivity or we might be offline but
now we can actually ship those reliably
from serviceworker so this is the thing
that you achieve by using a subtree
cache and that's only half of the way
because after your app has loaded you
want to talk with some api eyes and you
also want to manage the card for these
so that's why you can use sw-toolbox
which gives us dynamic caching
strategies so the three most popular
ones are cache first which is if you
know something's in the cache let's read
it from the cache network first means go
to the network but in case something
wrong happens just fall back to the
cache and this is a powerful thing
because previously if something failed
and it's the end of the world but now we
can have fallback strategies so network
first but if it fails go to the cache
and fastest which races both the network
and the cache and returns the first
response to the browser and in the
background if you have the natural
requests taking more time it will
actually update the cache for the next
time you use it so we call its tail
while revalidate because you're showing
content from the couch and at the same
time in the background keeping and
keeping an updated version for the next
time so and you use sw-toolbox with a
sublet Prakash at the same time in the
same configuration file
and this is on a road basis so you can
say I want the API countries this is a
regular expression to to use the cache
first strategy and you can say I want
anything that starts with API if you
want to use for example the fastest
strategy and if you've been following
around along the work of service workers
there's a newer library called work box
but it's almost exactly the same
sw-precache and a sub new toolbox it's
just more modular so if you already have
work on sw-precache or toolbox that's ok
you can keep it but if you're starting
from scratch this would probably be a
bit easier and more modular so no big
deal and for browser support which I
know it's probably the most interesting
thing everything works on Chrome
progress web apps work on Firefox as
well
Oprah they also work on samsung internet
which is quite interesting so on my
Nexus device I have Samsung internet and
Chrome and I added the same progressive
web app using those two browsers and you
cannot tell the difference that's a nice
thing about standards for edge service
of Service Worker support is right now
behind the flag that's because they're
working on it so we should expect it
soon and for Safari there isn't any
public information except a brief
positive signal in the next five years
so what you can do for iOS at the moment
is just a couple of things you can add
like a fallback meta tag or a vendor
specific meta tag which is the Apple
mobile web app title and this allows you
to have the same effect as the manifest
title and you can also do the fullscreen
experience which surprisingly I think
was supported for the last four years
but I would say proceed with caution
with this because some users have
reported that their app was slowed down
and another important your x-factor is
that if you don't test on it there's no
hardware back button so your users might
get stuck there forever
and you can also change the status bar
style so but if you're gonna do these
two make sure to test on
so that was the PWA refresher now let me
show you some best practices and just
like I told you PW is between
parentheses because even if you're not
doing PWA these things make a lot of
sense for the modern web so the first
thing we're gonna see is the theme color
and the theme color is different than
the manifest theme color because we're
not a PWA yet we're still in the browser
and this lets you theme the URL status
bar here the you are the URL bar and the
android starts bar so to do this you
will have to use the matter theme color
and give it a value now this value will
be the same as the one you would have in
the manifest but you still need to have
this kind of thing because at this stage
will not progressive web app so the
manifesto jason doesn't actually work
then the next step is to optimize the
first paint which means to get pixels on
the screen as fast as possible because
that's a common pattern we see on native
apps you open facebook you have
something that shows up on the screen
almost immediately but for websites we
are typically used to see a wide screen
for a second two second three seconds so
it's important to optimize for to
optimize the first paint and one way to
do that I mean one recommendation is to
use two n line the most important pieces
of your CSS in the head so you can do
this manually or you could use critical
CSS node module but make sure to keep it
up to a certain limit say 200 kilobytes
at moves and for the rest of your CSS
you want to load them in a matter that
in a manner that doesn't block rendering
because you don't want to have this
whites widescreen and to do that and the
latest technique is to use the link rel
preload has anybody used link rel
preload yeah great so this allows you to
load the CSS in the background without
blocking and you have to say that this
is a style and once it loads you
basically change the relationship from
preload to stylesheet this works on
Chrome there's no support for other
browsers yet so meanwhile you can use
the load CSS script and polyfill which
can be inline because it's really
you and for JavaScript if you want to
unblock JavaScript for the same reason
you can use the async attribute which is
going to let you reach document ready as
fast as possible without having to block
on those scripts and if we take this
concept a bit further we can talk about
the app shell architecture has anybody
used it before so the app shell
architecture is the minimal HTML CSS and
possibly JavaScript that powers your
user interface so here's an example the
options on the left you can see we have
like the container of our app without
the content it's like when you open
Facebook and the first 300 milliseconds
you see the header you might see the
sidebar but then you don't have any
content and then once the content has
loaded it just populates the view the
reason why this button is important
because we have it on native apps so
same thing for native Twitter or native
what's up as soon as you click you get
something on the screen and this is for
example an example of what part of an
app shell it doesn't need more than 30
lines of CSS of code it's only the CSS
code is not important was to show you
that this actually works well within
learning styles in the head and the last
important bit of the app shell is don't
forget that this is about critical code
prioritization so you decided that this
HTML and the CSS is important it's
critical so I'm gonna put it in the head
or I'm gonna inline it but you should
sometimes do the same for JavaScript if
I go back to this example there's
there's a functionality here so a free
don't prioritize this javascript and so
your users gonna click on this for the
first three seconds without having any
response back so in this scenario it
makes sense to have the part of
JavaScript that opens this side menu as
part of the options were
now here's the tricky thing we're
talking about performance and modern web
apps but at the same time we want to
load web fonts and it's probably tricky
how can we have like a decent font on on
our app or web app without actually
having a problem with performance and
the trick here is to actually use device
fonts and this is similar to system
fonts but with a tiny difference so
first of all you know that two up phones
are really heavy even if you use Google
web fonts even if you inline them in the
head they're going to be heavy so and
system fonts are weightless because
they're available on the system so if
you use Arial I'm not saying you should
use Arial or Comic Sans or system
they're gonna be almost free to use and
this is what actually medium does here's
medium and is they're using San
Francisco which is the device font on
iOS and on Android they're using Roboto
so first benefit is that their wait list
second benefit as an Android user I'm
used to see Roboto everywhere so this
feels more like a native app and for iOS
I'm also used to see San Francisco so
how can we do that so it's it's actually
this kind of font family that you can
use so you can start by looking do I
have for example San Francisco on Safari
and on Safari and Firefox if this
doesn't work then we're gonna revert or
fall back to this one which looks for
San Francisco on Chrome if it doesn't
work then we're gonna look for Segoe UI
for Windows so for example if you're on
you're on Ubuntu you're going to end up
having the Ubuntu font font because it's
gonna try one after the other so this is
a nice trick and we saw that was also
used in medium but still sometimes you
still want to use web fonts
so for example you can decide to use
device phones and also web fonts and
when you when you want to use web fonts
you actually have to preload them so let
me show you what the problem is
typically you have your without preload
when you start loading the end the the
index of the HTML and the CSS even
though the browser reads that you have
an ad font face declaration it's not
going to load the font that's because
browsers are afraid that the user the
developer ends up loading 10 fonts and
not using them so the browser will only
start loading them when it's confident
that you're going to use it but this
ends up having a flash of unstyled
content because we have the content here
but we don't have the fonts so we
actually want to shift those two to the
left as soon as possible so how can you
do that once again with link rel preload
so you preload those font files you say
I'm 100% sure I'm gonna need those fonts
but make sure there are some gotchas
here make sure to specify the type of
the font so you don't want for example
Safari to preload woof - if they if they
don't support woof - for example and
make sure to add the cross origin
attribute if you don't you're going to
end up pre loading it and then loading
it again which which makes it worse and
a typical pattern you see on the
Internet is - like the typical code you
see for registration of serviceworker is
just the one I showed you before but I'm
going to show you that this is
problematic a bit and it's better to
delay it so first of all the first time
your users are loading your page you
don't have a serviceworker because it's
not installed yet so you can only rely
on optimizing the first pin to have a
fast experience and on the app shell
pattern but you can probably not do a
lot more on subsequent requests you may
have serviceworker if it's supported on
the browser which is great and this
means that here we should be really
focusing on shipping something as fast
as possible because we're relying on the
network to get all of these resources so
let me show you what happens if you're
doing early registration so if you're
registering serviceworker as soon as
possible
the problem here is that you have this
is the index of the HTML this is the CSS
and these gear icons these are
interleaved serviceworker requests so
instead of letting the browser and the
network focus on having a fast
first-time experience you're actually
degrading it because you're registering
the serviceworker internals first load
so it would be best to actually delay
all of these until the first page has
loaded and to do that you can simply
just drop it in a and a load event so
make sure I mean the window has loaded
so after the window has loaded after
you've loaded all of these things you
can actually register the serviceworker
and this basically compares to this
graph where in the first few seconds
we're just completely focusing on
shipping those critical resources and
afterwards we can set up the
serviceworker but if you're using a
framework and you're mostly if you using
a front-end framer if you do this it
means you're racing your own framework
because the framework is probably
running things on load so it makes sense
to actually defer this until your
framework has completely booted so you
probably have a callback which means
react has finally done or angular as
well now for the next trick do you so
there's there's a Web API that lets you
know when the user goes online or goes
offline so who thinks it works
everywhere Wow nobody
it actually works on IE 8 so if you open
browser support you have it has support
like on all all browsers back to I 8 so
this is a really good and old web api
and it makes so much sense use it right
now with progressive web apps so let me
show you why you can actually do this
kind of experience where as soon as you
go offline we dim the entire UI even the
theme color here to show the user that
you're offline but you can still use the
app but it's kind of a conservative mode
you may not be able to do everything
so how can we do this this kind of thing
it's fairly easy you just want to listen
for the online and offline events on the
window object and you can call through
your own custom methods for example
online mode and offline mode one
consideration though is since you may be
building a PWA your users can open your
web app while they're offline originally
and this is not gonna fire the offline
mode so that's why you have to manually
check for it this is a capital L here
and see if we are already online offline
I'm gonna call the offline mode so what
can you do inside of this offline mode
you can find the theme color the meta
theme color that I talked about and you
can actually change the color for it to
gray and you can add this class offline
to the entire body is anybody using CSS
variables okay so let me show you a cool
trick you can do a few using CSS
variables with this one assuming you
have a CSS variable primary which is
like your brand color assuming it's red
here and you have the offline color
which is gray so once the offline class
gets added to the body you can actually
flip those two and that's a nice way to
do the video that I showed you so you
can dim the entire UI to show the user
that you're in offline mode right now
all right and the next step to know
about is debugging so debugging is
critical when building modern web apps
or progressive web apps and the first
part of it is that you can inspect the
manifest in chrome dev tools so you can
right click inspect and open the
application tab then manifest so this is
the manifest for Twitter light it's good
because you can inspect it without
having to use your phone every single
time you make a change you'll know if
the icons working you'll know if you're
missing any fields you can also inspect
service workers so you can stop them
update them you can also send a push
notification like a test push
notification which is very convenient
I'm not even sure if this is possible on
native apps you'd have to set up all the
certificates and send a real push you
can also emulate background sync which
is really handy as well is anybody using
lighthouse yeah this is one of the best
this is the best Chrome extension or any
piece of software that you have to get
progressive web app metrics and even if
you're not building progressive web app
matrix you get metrics for performance
accessibility and best practices so this
is a must use no matter what kind of web
app you're building so it guides you it
will show you things that you probably
we've never seen before and it's a good
let's like a checklist that you can
always keep it's also available as an
old module so if you wanna integrate it
out as part of your continuous
integration it lets you get performance
regressions automatically and as of
chrome 60 so the next stable version of
chrome is going to be available in dev
tools so I think we it'll be easier for
us to use it as well
so let's talk a bit about getting an
icon on the home screen so assuming
you've made it to the home screen that's
a big big step for you and your users
don't really know that there's a term
called progressive Web Apps at least
most of them if they have something on
the home screen they expect it to be
fast so you have to meet their user
expect their expectations of performance
and there's a typical question that I
always get can I make my website as a
PWA so it's kind of a generator so
technically you can make any website on
earth as a PWA but that's probably not
gonna be a good idea because if the
performance suffers then you're gonna
have an icon that opens a wide screen
for six seconds and the apps gonna be
slow scrolling is going to be slow so
what you can do in case you have like a
legacy app for example like Twitter Hut
you can I know nobody likes this term
but you can start from scratch and do
the basics Twitter has done it and even
uber has done it I think like five days
ago they released an awesome web app you
can go check it out at a mobile comm so
you can take progressive approach and
only add the critical features step by
step as you get more feedback the reason
why I'm saying this is because even if
you're able to ship the apps are really
fast after the app shell the option
itself is not really useful it's just
like an indicator that the page is
loading after the app shell the users
are waiting for the first meaningful
paint for the first time they can
actually see something useful on the
screen like the products but even when
they see them they cannot interact to
them do you know why even if they're
online why
javascript so on most websites on mobile
you have javascript blocking the main
thread for up to eight seconds this is a
real trace that I took from this MacBook
Pro i7 with five times CPU throttling so
emulating mobile device and 3G
throttling from nasa.gov and it takes
eight point twenty five seconds to just
parse JavaScript so the reason behind it
is because they're probably shipping
like a one megabyte javascript file so
shipping less javascript is a trend is a
good thing to do if you're building
performant mobile web apps regardless of
their pwace or not and i know this is
one of the hardest things so I practice
some tools that will actually help you
some recommendations so has anybody used
source map Explorer so this is a node
module that actually reads your vendor
JavaScript map the map file and tells
you how much I mean the percentage of
every library inside of it so this has
helped many teams understand why they're
shipping the same library twice with
different versions or if you're shipping
for example lodash which is taking up
20% we're out but you only need two
methods out of it
then you can maybe just include those
two methods so this is real this is a
good idea to know if you're shipping
more than you actually need code
splitting is also one oops code
splitting is also one of the best
strategies to go about this because even
if you're not using a framework like at
all assuming you're using web components
no polyfills nothing once your app grows
large enough you're gonna have end up
with a one megabyte javascript file and
there's no way you're gonna make this
fast so the only way to make this fast
is to actually code split it so I really
like the way Oberth did this I just read
it yesterday they only ship initially
the JavaScript file that lets you order
a write if you want to edit your
information payment information they
would actually lazy load this only when
they're needed so there's no need to
ship the entire JavaScript bundle when
you only want to let the user request a
write or log
and this this has become easier with
webpack - if you wanna do a code
splitting anybody use code coverage not
like fhv code coverage this one so this
is a new tool that landed in chrome dev
tools as well
it lets you record a trace so you record
and you go to a website scroll down
interact to the menu and it lets you
know how much of your javascript is not
being used how much of your CSS is not
being used so this is extremely helpful
when you want to optimize for the first
experience and the common thing I see
when when we're using modern web api's
is that we always load polyfills so for
example if you have a polyfill for fetch
which is like 8 kilobytes
we're always loading this polyfill but
90% of the browser's already have that
so I was doing some kind of
experimentation and you can find it here
on premier file on my github profile
which basically lets you define your own
polyfill so you can load to whatever
polyfill you want and you can run it to
the test this is the sales promoter so
you give it the test is fetch supported
and this browser if this is going to
return true then this promise is going
to resolve immediately and it lets you
use fetch directly but if fetch was not
supported on this browser then this
promise is gonna block until it's
actually loaded the polyfill and
executed it and then it lets you run
this fetch and this makes a lot of sense
to use with fetch itself because fetch
is like jQuery AJAX but it's native in
the browser and all browsers have it
right now except maybe the late the
older version of Safari so 90% few users
have it there's no need to always ship
polyfill so here's how it works
so for browsers with fetch support you
will have the index.html which loads the
JavaScript file which then executes
fetch and loads the users to JSON
without blocking without having taking
any hit but for browsers without fetch
support you can see between the
javascript file and the fetch request
there's this blocking here it's a bit
slower because I'm using throttling and
this lets the polyfill load only when
it's needed
so this is what what I mean by
conditional polyfill loading so you're
all using JavaScript frameworks or
libraries nobody is building anything
from scratch and this makes a lot of
sense so this is why I crafted a set of
requirements that I personally look for
when I'm looking for a front-end
framework so it's not a comparison
between all of them but a set of rules
are a set of guidelines so first of all
I always look for a smaller bounded size
because if my framework is taking 150
kilobytes already or maybe 100 kilobytes
that's already too much this is gonna
take like four seconds to run on old
mobile devices so I don't have any
JavaScript that I can run in order to be
able to do a good experience
another thing is the ability to code
split because even if the framework was
three kilobytes eventually I'm going to
end up with a one megabyte javascript
file so I want to be able to do code
splitting also there's something that I
called platform leverage or that's
called platform leverage which means
there's no need to reinvent web api is
that recently landed in the browser and
the most common example put that I just
showed you is fetch so there's no need
to have like a library to do fetch
request or Ajax request because we have
just the tiny function that's natively
supported in the browser and when it
doesn't work it can simply do a
conditional polyfill loading so polymer
2 actually does conditional polyfill
loading I'm going to talk about it later
on so who's using react so recently with
react you can use the create react up
and this is going to give you a PWA by
default which is great starting point
because you don't have to add it to a
park or anything it's just work has
anybody heard of pre act
okay so pre-act is a react alternative
that's only three kilobytes so it's the
same API but it's only three kilobytes
uber is actually using pre acts and the
nice thing about it is that the
framework ends up being like three
kilobytes and your app size ends up
being bigger than the framework itself
it's worth noting though that pre art is
three kilobytes and es2015 so when you
transpile it's gonna be a bit bigger you
can also generate a PWA by just using
pre a command line anybody using view
yeah so for view as well you can use the
PWA template and this is going to give
you a previous web app out of the box
anybody using angular so angular 2 4
okay there's this mobile flag which is
currently disabled so but you can work
around it right now you can build for
production with ahead of time
compilation and then this doesn't really
exist but you can build it yourself by
using the Prakash sw-precache on the
stub your toolbox so this is like an NPM
script that you can do to produce all of
these things so to produce the
serviceworker anybody using polymer or
polymer 2 so I did some experimentation
with polymer and it what I really liked
about it is that on Chrome and Safari
it's only 11 kilobytes which is really
small the reason behind it's because
it's using web components and web
components are native in Chrome and
Safari so once again they're using
conditional polyfill loading if you open
on Firefox gonna be say 25 kilobytes if
you open on ads gonna be 30 if you open
on Internet explorer it might be as big
as 50 but that's the thing if you're on
a newer platform you don't need all of
these JavaScript and most users on
mobile are actually on Chrome or Safari
so it makes a lot of sense to use it
so now let's take a look at some modern
web api's and this is completely
independent from progressive Web Apps
but once again if you're doing a PWA you
may find yourself using those those who
have api's so has anybody used passive
event listeners so I want to tell you
something as soon as you add a touch
move event to your page you're actually
making it slower much much slower and
that's not your fault that's the fault
of the API itself of how the spec was
designed a few years ago so the reason
behind it is because you can actually
cancel this event so you can do event or
prevent default so the fact that you can
cancel it makes it slower let me show
you why here's for example a user doing
a touch event on on your bra on your web
app which gets picked up by the
compositor thread and then reaches the
main thread which is going to call the
on touch move event which is going to
call your own function your own callback
so it's going to call your function and
see if you called event or prevent
default assuming you did not call if an
prevent default it's gonna bubble up to
the compositor thread and then finally
commit it to the GPU and this is when
scrolling happens so why can't we go
directly to the compositor because we
need to know if you cancelled if you
cancel this event and this means during
this entire time scrolling is blocked
and this is terrible so this is why I
told this is not our problem this is an
API problem this is why we now have this
passive true which basically you're
saying I'm not going to cancel this
event and even if you cancel it's not
going to do anything
and this basically lets the browser
short-circuit the entire thing and
directly commit to the GPU so to see the
difference there is this video which
actually shows you on the Left how it
used to be and on the right how it got
fixed
stole motions even worse
so it's however I want you to know that
this is only the case for touch events
and really events so if you have a click
event or like all the other events don't
worry about it and as of chrome 56
Chrome's are doing it automatically
because 99 percent maybe of touch events
were not supposed to be canceled so they
made them passive by default but it's
good for us to know about it because you
want to make good experiences for Safari
Firefox and other browsers as well
another Web API lets us defer
non-essential work and a typical example
here is you have a button that triggers
an animation and you also want to send
analytics but so you're sending
analytics doing animation this ends up
making the animation much slower that's
why there's this new web API request
idle callback which lets you schedule
non-essential work so you want to do
some kind of work but not exactly right
now this lets you schedule non-essential
work in small core box and the browser
will only call it when the browser is
confident enough that it's going to have
some free time before actually sinking
again on the screen before drawing a new
screen and this basically makes sure
that all of these v6 happen every 16
milliseconds so end up having 60 frames
per second every time so this is good
for analytics or any kind of logging you
may be doing on the framework on on the
front end and this works right now on
Chrome and opera
there's also intersection observer which
is really interesting but browser
support is still limited to chrome opera
edge and I also saw that it's coming to
Firefox soon so this basically lets you
ask the browser about the visibility of
certain element so you can tell the
browser tell me when this element
becomes visible on the screen and this
is how it works so you define
intersection observer which returns a
list of entries and then you check the
intersection ratio of I'm gonna check it
for the first element only because I
only have one element for example and if
it if it's triple equals zero then the
element is invisible and in other cases
it's visible
then finally you decide to observe
actually
element for example ID box so it's that
simple but don't forget doesn't work on
all browsers yet and why I think this is
cool is because it lets you do infinite
scrolling much easier so you discover
the visibility of say the last element
and this will let you trigger the load
more method I think total light is using
it to do lazy loading of images so
because they're working with long feeds
they don't want to keep the images
always in memory so they can actually
remove images that become off-screen and
they can load them once they become
on-screen and I think this will only be
case for add libraries it only means
that once it's supported add libraries
will be able to discover advertisement
visibility much more efficiently than
having to actually hug the scroll events
on the window but if you're deciding to
doing to do any parallax don't use
intersection observer so this is not
meant for low latency scroll dependent
animations there's also an exciting this
one spw a specific PWA specific feature
which is background sync and there are
two sub features inside of it the first
one works on Chrome and this basically
lets you schedule I mean it waits for
connectivity and employs an exponential
back-off which means using this one you
can let a user send a message
close your app close the browser and
when they get back online your message
will be sent so just like you can send
messages on whatsapp offline and it's
going to retry every second two second
exponentially and the other one periodic
sync which is currently being expect so
it doesn't work on any browser yet it
lets you for example load content every
five minutes in the background and even
if your app is not open so for example
every five minutes I'm gonna get the
latest news you don't have to specify
those two but this basically you can
constrain it to be on Wi-Fi and to be
plugged on a charger
there's also CSS containment which makes
a lot of sense with web components
because previously once you change the
left property or the width property of
an element the browser had to
recalculate the style for the entire
page which doesn't make any sense so
this could take and worst-case scenarios
up to one second because the layout
route is called to the document but
right now you can use the contain layout
so you can specify or constraint the
containment to this element and such
layouts changes actually even become
much much faster there's also the
payment request API which works on
Chrome for Android soon coming on all
chromed chrome platform so on the web on
I mean on Mac on Windows on Linux and
even on iOS I think so this is not a
payment processor like Braintree or
paper this is basically just in native
UI that shows the user has already saved
credit card has already saved address
and if you want to use this you can
basically check for its support and have
the flow if it's working if it's not
working you can simply redirect back to
all of these legacy payments there is
also the web share API which is behind
an origin trial so it was being tested
in a couple with a few websites so it's
not available anywhere right now
but it basically lets us share so open
the native share dialog on on Android
right so and this is where we come to
the futures although most of these web
apps are not supported everywhere so
these are kind of the future but I also
want to show you why the future is even
more promising and the first one of them
is the improved add to homescreen on
Android let me show you so I was able to
record this on Android Chrome better I
think
but behind the flag so once you add a
home screen it's gonna take some time
because it's being tested at the moment
you can see here it's installing so it's
installing a web apk and now even if you
close everything rather than having like
a home screen icon you can actually
remove it and you will still find it in
the app and in the app directory you can
even inspect this app so this is like a
real app right now
that's packaged by the browser which is
a progressive web app so once again this
is only behind the flag right now and
not everyone has access to it but you
can check it out on android and you also
have some experiment experimentation for
pwace on desktop so for example Chrome
OS right now has the same flow you have
on on your mobile so you can add to
shelf and this is going to open Chrome
without its UI also Windows 10 is doing
the same so they're also they're also
finding all the progressive web apps on
the Internet indexing them and putting
them as part of the Windows 10 store and
if you install it's gonna be much faster
because you're just installing an index
with html5 and how many of you have
heard of webassembly web assembly great
so this is really exciting this is a
cross browser effort it's supported on
all browsers
some of them behind the flag so this is
a new language that runs in the browser
and it's designed to run native C or C++
code this is an example of a method
called add two which adds two numbers
together it's not the most exciting
scenario example but let me show you so
this is how you can use it I'm using
async await functions to a single way to
make it easier so you fetch the web
assembly file converted to an array
buffer create a module of it and create
an instance and then a few console.log
instance instance of exports what you're
gonna have actually is a native add to
method in your browser so just like a
new promise as a native button in the
browser I was able to export my own add
to method and the reason why this is
really exciting is because this is what
I think the future app model is you have
your progressive web app or you
what mobile web app and it's gonna do
awesome things because for assembly
because you can do like heavy lifting
using web assembly so this opens up the
door to image and video editing image
recognition encryption and so many
things we've never used thought we were
able to do on the web and actually figma
which is a sketch like editor on the web
started using web assembly for image
editing so I still have just maybe one
minute
so did I get you excited about the
future of web apps yeah great
okay so I have to call to action to you
if you go to speedtest.net they actually
tell you thank you for coming to our web
site but we cannot do it on the web you
have to install 15 megabytes to test
your internet speed which doesn't make
any sense
so if you'll know build your first PWA
i'd recommend to get rid of your
business logic first build the PWA from
scratch so you can know how it works and
then rebuild it or just add your
business logic as you go make sure to
always plug and test so because what
takes a fraction of a second on your
laptop could take up to five seconds on
a real mobile device so always have your
phone plugged if you're on Chrome use
Android if you're on Safari use iOS or
the opposite and use throttling features
in chrome so we can throw the CPU up to
five times and regular 3G if you do if
you're working on desktop and it's
always good to see that other players in
the market are doing that so you can
check out Twitter comm on mobile they
have an awesome PWA I uninstalled their
native app and I've been using it for a
few months there's also we go and
Flipkart and don't forget that there are
also other solutions for this problem
the problem of low Internet connectivity
and low devices and this progressive web
apps is one of the many solutions and
other solutions can be android instant
apps or android go so it's not like one
of them is gonna win I think all of all
three will remain and will get stronger
because they have different approaches
so I've used Google web fundamentals and
Mozilla developer Network to craft the
stock you can check it out as a resource
you can also find the slides here you
can also find my ademma course on
becoming a better developer here and I
hope you enjoyed this talk you can ask
me questions afterwards</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>