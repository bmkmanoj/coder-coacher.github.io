<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Elixir: 4 Reasons For Adoption At Scale | Coder Coacher - Coaching Coders</title><meta content="Elixir: 4 Reasons For Adoption At Scale - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Elixir: 4 Reasons For Adoption At Scale</b></h2><h5 class="post__date">2017-12-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0IysGcaWOEk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and so this is a talk basically as Bruce
alluded to about how we've adopted
elixir and how we've done it at scale
and there's only so much you can do I'll
try to get as much as I can in 40
minutes but there's some areas that I
won't be able to focus on that are
equally important such as documentation
how to properly test your applications
and how to deploy them as well and the
nice thing is that if we can do this at
scale then that means that any way
anyone can do it it pretty much any size
especially if you're a smaller company
you can apply these same rules to
whatever you want to do so we're gonna
focus on four areas the first is the
business case and unless you're
developing things about yourself you
have to convince someone else including
yourself I guess to develop with elixir
why would you do this if you're not a
bigger company
Bleacher Report is a moderately sized
company and we're owned by a Turner so
there's a lot of convincing that had to
be done the second is consistent code
when you again unless you're developing
by yourself and even if you are you need
to have a holistic application design
and this includes how do you do code
reviews how do you how do you make sure
that these standards they consistent
across the apps and when you're learning
a new language this is all the more
critical and all the more important
because if you don't do that you end up
having a lot more tech debt which you
wouldn't incur anyway but it at an
increased rate when you're doing it with
a new language and this is perhaps the
most interesting part is the realized
benefits you know how has the liquor
worked out for us how is Phoenix or got
worked out for us what we still need to
improve and and what can we do going
forward
and finally developer happiness I mean
most of us are developers in here and
most of us want to be happy and most of
us want to be happy when we're
developing so this is this is a survey
of what we're doing at work and how our
developers feel about it and we actually
have four other developers over here
from Bleacher Report so don't take my
word for it so we'll start with a
business case for us it was sort of a
perfect storm we had this is these are
some stats that they're to show the
level of traffic that we have and it's
an older platform we were transitioning
away from from from the old platform
which is eight years of tech dead so we
had as we started with rails 1.0 and I
was saying
ten years ago it was more of a web first
and then we moved to to mobile you know
with the advent of the iPhone this was
up this is when we sorry
moving from web first to mobile first
meant that traffic was came in a
different way we had in Silicon Valley
you save for at a company for maybe a
year or two so we had a lot of lost
domain knowledge and we had this
labyrinth monolith that was full of all
these dark corners that no one really
know what to do with
and finally unpredictable traffic spikes
since we're a media company feminine
stat that when breaking news happened
you know we had to be the first to
deliver the news before there's through
notifications or any other one any other
manner Ruby didn't handle that in a very
good way to say the least and so we
ended up having to scale up and scale
down and so before big events we would
have to plan like okay so how do we how
do we handle this or how do we handle
that
for instance when Kevin Durant moved to
the Warriors it was a big deal
traffic's byte four times in five
minutes and this was on the elixir
platform which was good because we were
able to handle it
had we done this on Ruby it would have
probably crashed and why do we choose
elixir everyone knows I guess in here
the concurrency parallelism high
availability distributed stuff but the
nice thing about elixir so we evaluate
other things we evaluated go and node
and in my own personal research I've
used closure and Scala but the nice
thing about elixir is that it looks like
Ruby which means it's easily
approachable so you say this is a
function definition I know how to do
this if you look at Erlang syntax it's a
bit more esoteric and so I think one of
the great things that josée did was to
say here's this great language Erlang it
has this battle-tested vm and now we're
going to we're going to put this very
familiar very approachable syntax on top
of it and for what if a reason
functional programming has a reputation
for being difficult for being hard to
understand for
something clunky something academic but
by giving this this nice facelift with
the Ruby syntax it made it very easy for
people to come and say okay I can get
started with this pretty quickly and but
I think you know we talked about we
happen to be a rail shop we happen we've
been using rails I was a rails developer
for five fire six years before this this
is really a paradigm shift and I think
the then the nice way to illustrate this
is with the observer so for those who
don't know I'll show some graphical
images of this as we go but another nice
thing didn't mention like having an
enclosure in scala in the past or
attempting to do scala scholar was quite
difficult never to get my head around it
really but so in this this is the IH
prompt and the observer is an Erlang
tool that's been around for a long time
and it's so easy to call Erlang from
elixir you just : observer dot start and
I think this is perhaps the the
intention that Joe's I had in mind I
feel like the relationship between
closure Scala and the JVM is much much
more clunky but our letting fits like a
glove elixir fits like a glove over
Erlang so it's it's a seamless
integration so this is one of the
screens of the The Observer you can run
this with any mixed application and you
can see here in the upper left hand
corner that there's the the chords here
this logical CPUs so it's really a shift
between singletary multi-threaded and
the way that the app the Erlang VM is
designed in such a way for a multi-core
world that you can take advantage of all
of these different course and this is a
second shot and this is this is this is
all built in information it's incredibly
useful this is all built in information
that's incredibly useful you can see
there on the on the lower left that
there's the the eight cores and you can
see each of the what's happening all of
them and and you can see that it
fluctuates up to about eighty percent
and what I'm doing here is really to
stress tests in my local machine I'm
taking production data and I'm seeding
my local machine with all the production
data and it's really easy to do this
because because of the fact that you can
spread out these
over these eight quarts and you get a
lot of other built-in information right
there on the bottom as well
items processes and all this is very
easily available continuing with that
this is the processes table this is give
this game this is a visual
representation of things that other
people have been talking about over the
last few days over the last couple of
days and it's it's really also a nice
way to benchmark your happen to find any
bottlenecks because you can see the
message queue if the message queue gets
stuck you can easily see what's
happening and find ways to debug it and
then last year at electric company you
Lance gave a talk about Phoenix not
being your application and this is a
visual representation of that you can
see that this is one of our app but this
is our first elixir application and you
can see all of the left on all the
applications on the left and you can see
that Phoenix is listed alongside elixir
which is listed alongside X ammeter
listed alongside cowboy and AMQP and so
on and so forth and then on the right
shows the processes and all of that
stuff and it's it's really nice very
helpful way to visualize OTP and to
understand how these things all relate
together and so now we'll come to
consistent code this is probably the
most important thing about adopting a
lick sir
other than once you assuming that you
understand the language when you try to
train other people with the language
this is this is where you have to focus
and I think that Josie and Chris and
have done a great job and really pushing
documentation do you have X doc which
makes beautiful documentation on hex it
makes it very easy to immediately see
what's going on and when Jose I
introduced Jenn stage he there's a slide
on the on his presentation that said he
had that there's our eleven hundred
lines of documentation and a thousand
lines of code and I think this is
crucial to understand this is one of the
ways to adopt a lick sir so going back
to Stefan's talk well it is harder to
set up Phoenix than it is to set up
rails you at least have the
documentation available to make it to
hopefully fill in these gaps
and it's actually I I joined bleacher
report because I was interested in
elixir that was my primary motivation
for going there and all the challenges
they're associated with with the sports
platform of the size that we have and we
had this one app and there's some issues
with it like it was it was a rails app
and it would be kept falling over with
under load and it's like oh this looks
like a relatively simple app and I ended
up rewriting it elixir in a couple of
days and it outperformed the rails app
and we still use it in production now
and we keep adding on to it and we keep
refactoring as we go along but it said
to me I can do this this is well this is
different at least I can move forward
and and we have a demonstrable small
chunk that we moved over to a lick sir
and it's working really well and
incidentally it was the last time I
really wrote rails code I think in the
last two years of bleach report I've
written maybe three hundred lines of
code of rails code of Ruby code which is
which is really surprising because I
really like for me I really you know I
have a lot of respect for for the Ruby
and rails community because of all the
things that they did but now I have no
real reason to write Ruby or rails code
anymore and that you know two years ago
I would have thought that would been
unthinkable so now that we have this can
no so now that we're adopting this this
new languages new framework how do you
teach other developers it's one thing to
teach yourself how to write rails elixir
in Pheonix code but how do you train
other people and when we started about
two and a half years ago there weren't
really any guidelines even in fact the
phoenix phoenix 0.5 slash dev the one of
the github guidelines was do whatever
you want basically like we do whatever
feels natural which is a pretty
laissez-faire attitude towards running a
production system and but somehow you
know we've tried it and we sort of
developed our own internal our own
internal guides how do we do this how to
do that a lot of it was exploratory and
at the time there are three of us
writing out three or four of us writing
elixir and we bounce ideas off each
other but now we have credo which i
think is a really really helpful tool
Toulouse to make your your code
superficially consistent I think that
credo is best used as not as an analyzer
but just as a way to standardize things
that you would miss normally in a code
review and it's also a good way to to
make sure that the code reviews focus on
the logic and the application rather
than oh you have a parenthesis that's
one space here this indentation here so
I don't really I rely on credo as sort
of a gatekeeper for first style not is
for substantive things but it's it's
still incredibly useful and here's
here's like this is the kind of
information that I would want to have
with credo and this is also really nice
because a new developer can do this by
themselves they can say okay I'll run
mix mix credo I get these errors and
then you can drill-down them and you can
actually go mix credo and go into the
file itself and it'll give you a nice
detailed rationale for for why it's done
like for the longest time a lot of our
modules had no module doc tags and part
of this was because maybe we didn't
maybe some the developers didn't know
this was important or or whatnot but
then you can see this oh I don't have
the module duck tag you drill down into
it and then you can see exactly why the
module dot tag is important and what its
function is which is really really
useful and I saw something on Twitter
the other day that was talking about how
credo was - was - they didn't like their
defaults they didn't want to deal with
all the defaults for credo so here's you
know you can change whatever you want so
say the only thing you care about is
line length the only thing you care
about is you know maybe you believe that
the max nesting should be more than
three you can adjust all of these here
so you can make it you can really use
this pretty odd exs file to set the
standard for your entire organization's
elixir projects I think it's really
really nice to have to have this out of
the way because all of these little
things like module doc tags or doc tags
or what-have-you
they're not really code reviewable in
the same sense code reviews are really
really important to me because this is
you know I I think you can have an
organization without it but without code
reviews but I don't know why you would
want to it took me a long time to sort
of come to this conclusion but the code
review process essentially is
essentially an editorial process where
you know we are programmers but
essentially our software writers and the
code reviewer is the editor so the code
reviewer will we'll review your code
like an editor like there's no there's
you know in the past there would have
been no it wouldn't have been possible
to publish a newspaper or whatnot
without without the code review in place
but now it's so easy to publish blog
posts or to to write code and ship it
there's there's no real cost to to skip
the editorial process but you lose out a
lot especially when adopting a new
language and I think that the tone of
the elixir community as it has done a
really really remarkable job by with
Josie and Chris in the sense that when
you look at you know when people submit
code code reviews or forums people
submit pull requests they even if even
if it's a poor quest isn't accepted or
even if the code is bad josée will take
the time to write out this is why this
is bad or this is why this is good and I
think that that sets the tone so the
because in the past and other in other
communities the it's been a lot harsher
when with Quaker you write if you submit
a pull request that's not good then
you'll be really rudely criticized and
it's really really a it's it's
detrimental to the community and
detrimental to people wanting to learn
the language and so when we to report
when a new developer is learning a list
of what we do is we do generally in
person code reviews you sit down you go
through the code and it makes a lot
easier because it's a back and forth
exchange of course you can use github to
write comments on pull requests but a
lot of contexts get lost and gets lost
in comment and in comments with when you
don't see the person face to face and
before the code review process but we
ask the new developer to do is to say
okay so you know use the programming
elixir book use the programming a
phoenix book you didn't get enough to
where you can understand the code or
here's some here's some old Ruby code
you see the context now write that in a
lick sir so it ends up generally
happening is happening is that they
write more Ruby ish elixir which is okay
because it works and we also ask that
you write tests of course that you to
the you can come so we do refactor the
code you can be sure that the code will
still work once it's been refactored and
we use a library called x coveralls it's
just you can print out
coverage and these kind of things and it
really helps to give us confidence when
we do the code reviews that this person
has done their due diligence to write a
test that will cover what they need to
cover so here's an example of some some
code that was submitted a while ago by a
newer developer and basically what it
does is it says it takes a URL shortener
shortened URL and it does something with
it
and this works fine there's nothing I
mean it's not bad necessarily but it's
good but it's a really nice teachable
moment I think so you can rewrite it
something like this so instead of doing
the case statement you can break things
out and it different in two different
functions and each function does one
thing and you get to introduce the pipe
operator which is which people seem to
really to really like you get to
introduce the attribute so you can put
these things up that you can give it a
more semantic name and then you can
handle things with private functions
below that do different things but it it
I think it really explains how
functional programming is is modules and
functions and if you are able to break
down what functions do and is simpler
and simpler concepts then it makes the
code that much more readable and that
much better and it also gives the
developers the confidence that they're
moving forward in the right direction
and this is something refactoring often
this is something that since we came
since I came to bleacher report it's
something that's been really important
to me personally and to everyone in the
organization as I mentioned before with
all of the eight years of tech dead we
didn't pay down our tech debt in a way
that we should and so where we were
paying the price for which is one of the
reasons why we were investigating elixir
in the first place and we adopted
Phoenix at 0.5 elixir I'd reach 1.0 but
there was still a lot of a lot of
changes on the Phoenix side and we ended
up getting behind in a couple of
versions and at this point they were
breaking changes and you know we're
doing that or you feel when the
guidelines say do whatever you feel like
they're gonna be changes and they're
gonna be breaking because it was a pre
1.0 anyway so we we realized that since
we're learning the language since the
framework is changing so quickly that we
need to have regular sprints are regular
refactoring I know
of ours friends and in addition to that
having this mentality of refactoring
often means that when you know with
Phoenix 1.3 comes out you have these
ideas these new concepts you have time
to say okay well how do we evaluate this
how do we look at our app how does this
make us reconsider our infrastructure
and so on this is the first elixir app
that we wrote and this is the additions
and deletions graphs with some divisions
and I think it it Ellis traits pretty
clearly how how much we've refactored
throughout the course of the app's life
cycle in the original the addition the
exploratory part was when we decided
okay this is a proof of concept let's
see if we can do it in Phoenix we'll do
what it says it does and elixir will do
what it says it does and then there was
a break in the definition point where
the product was like oh wait we have
this might be the answer to the problems
that we were having let's reevaluate how
we need to do this let's set up you know
set up the stories and all these things
and then the next four steps the next
four stages are the when we released the
production and we were adding features
and then the refactor part I think is
the most interesting part because this
was about a year or so after we started
using Phoenix and elixir at work more
people had started developing an elixir
and this was sort of the moment when we
realized oh you know we should move away
from this MVC pattern we shouldn't think
of of modules as models and the rails or
the traditional MVC sense and to start
thinking about modules as groups of
loosely related functions and and this
transformed the way that we we talked
about our data transformation and data
modeling so instead of having you know
say we have lots of different content
types we have an article you have a
video you have an Instagram post and so
on and so forth instead of thinking
about them as distinct models in the
database let's think about all these
things all these different model of all
these different content types have
common fields so using embedded schema
or using change sets we were able to
simplify our data models so we just
basically have three different we have
one content type that has one content
table one content item table and then
one metadata table so it's related in a
way that simplified our code base a lot
and you can see
this on the right side of the refactor
part we were where we took almost all of
the code that we done in the the first
chunk there and removed it and at that
point the code base I think was smaller
than it had been since the since the
beginning of the release phase so it was
a real win on our side to say okay we've
been able to to have this app that does
more than we thought it would do that
has less code than it did when we first
released it and it's just this is an
amazing feature of what happened when we
started to understand how phoenix and
elixir worked well together and this
also brings me to another point when i
happen to be listening to the elixir
found earlier this week and Dave Thomas
was was the guest and he put it he put
it a really nice phrase that there was
something that I was a concept that I
was sort of milling about in the back of
my head but he called production
prototyping which is essentially what
we're doing here we have an idea let's
deploy it this seems to work let's try
something a little bit different and so
on and I think and since been using
Phoenix and elixir for such a long time
I feel like you know you can sort of see
like it from a wider angle into a more
finely focused point which is I feel
like what Phoenix is doing especially
with moving things into with with the
stuff that Chris talked about with
Phoenix 1.3 and we're sort of following
that behind what we because we have this
because we refactor often because we
understand that things were going to
change because we think under because we
know that our understanding of how
things work are going to change we have
to be ready to make this to make these
changes in production and and so on and
that though and this really opens up to
the fact that we learn on the job that
there's a there's time that and the the
product that our product organization
and the management really have bought
into this to understand that in order
for us to succeed with this we need to
have be flexible enough to refactor and
move on together and it's worked out
really really well for us and then
monitoring is is essential for any
production application and and this was
something that we struggle with in about
in the beginning because as the rails
rail shop we use
a New Relic I think we're probably in
the first 10 customers of New Relic
so no New Relic so we're gonna do we
have there are many other options
Alex ometer which is a phenyl ixr
wrapper around X ometer which is a
monitoring tool there's static statics
which my coworker John just found last
week that we're going to evaluate so you
since we use data dog and stats D and
then plug louder Jason is a library that
he wrote that was really helpful in
debugging some issues that we had in
production um one of the most
interesting bugs that we had in
production it was it was really
difficult to track down and we probably
wouldn't have found without this without
being able to to monitor was that I
think that it's fixed in Hackney now but
if you have a high amount of traffic the
the workers would get confused in the
pool so you'd make a request and then it
would take like 45 50 seconds to come
back and we were I was like waking up in
the middle of night I can't figure this
out what's going on this is unbelievable
especially because we were putting
timeouts of three seconds and it was
still taking fifty seconds so we
couldn't figure it out and eventually it
turns out that under high load the
workers get lost and there was a comment
by Erik about it he'd had the same
problem with hex with with with Hackney
and so we disabled the pool and rely on
phoenixes to take care of it and their
problem in a way and then everything was
back to normal but this is just one
example of having proper monitoring that
we wouldn't been able to catch had we
not had this in place and this is I mean
this is some of the stuff that we use
for for monitoring I mean we have all
sorts of metrics that we do but it's
nice so on the top of the Erlang run
queue this is nice because we are with
examiner you're able to expose the inner
workings of the beam so you can project
that onto whatever monitoring dashboard
you use and then CPU utilization as well
and with the CPU utilization is another
interesting but because with rails we're
problem we had was that eventually you
know you the CPU would go 200 so we
scale up at another server and so on and
so forth and this is obviously
unsustainable but with
with Erlang an elixir it was hovering
around two to three percent and I was
convinced that we were doing the monitor
the measuring wrong this has to be a
problem or how is this you know we're
running all of our traffic on this and
it's only 3% and then before we released
our code into production for the first
time we had a erlang solutions come by
and they evaluated our code and they
which was nice before one because we
have the their expert opinion to
evaluate how we were doing and to
they're like oh you're doing a good job
which is nice because we hadn't worked
more confidence in what we were doing
but they're like oh yeah that's just not
the CPU utilization might not be the
best metric to use for monitoring elixir
line so it's so these kind of things you
have to be flexible to understand that
things are going to change and you're
understanding that things will change
over time and so now that we have these
things in place let's talk about the
realized benefits there are a lot of
things that we can talk about and you
can talk to my co-workers in the back
there they will be happy to tell you
about the things that they've enjoyed
with lucre in Phoenix but this is
traffic resistant response times is
incredibly important as I mentioned in
the beginning since we're a media
company we want to be the fastest we
want to deliver the content the fastest
no matter the size of the audience as
long as we're the fastest that's that
that's that's sort of the bottom line
because if you get you know if you have
ESPN you have bleacher report and some
other sports app if your ESPN or other
sports app notifications are
consistently quicker you're obviously
going to go to the go there first
so here's last week's traffic this is
this is a standard for us peaks and
valleys as people wake up and go to
sleep we have offices in UK as well but
most of our traffic is from the States
and this is our 95 percentile I don't if
you can see that on the left but it's in
milliseconds on the left the it's - it's
at the very top it's 300 200 100 and
this is this is pretty standard
so our 95th percentile hovers between
100 150 milliseconds for all of our
traffic and then Stephanie missed rooms
in his talk sub 1 1 second is good so
we're there we still have to I think
there's still room for improvement to
get under 100 milliseconds because there
are some limitations that we have with
our deployment process but you know it
takes time to do these things and we
also use fastly as
as a CDN the fastly hit time is
approximately point zero two
milliseconds and the hit rate is around
60 the gap is there between the actual
between the fastly projected end points
and then the the non-cash ten points and
what what makes unique last week was
that it was a Super Bowl this is not our
biggest traffic night of the year but
it's one of the biggest nights and in
years past you know as I mentioned
before we in years past as I mentioned
before we we had to scale up and prepare
these things and the last rule there was
nothing no one there was no meeting
there was nothing to scale up nothing
happened at all it was like a normal day
it was it was a testament to how far
we've come with the liquor in Phoenix
and it's a testament to Phoenix and
elixir as a language and a framework so
now that we have this now that we have
this platform how do we stress test it
how do we know that at this point this
is going to succeed you know so we have
X amount of normal users we have X
amount of this is our maximum how do we
know how much traffic we can handle so
we we built these internal tools to
ghost traffic from production to sort of
a testing production environment and
then we can multiply that and we were
able to get eight times on our normal
traffic on our same number of instances
without any additional infrareds kind of
things and it started to fall over
because the database connection it
wasn't a liquor or Phoenix thing the
database was the issue as I mentioned
earlier we hazarded of some of our
deployment issues and things that we
need to improve on in that regard we we
also tested it with ets tables and we
were able to get to 10 times traffic
before in before we started to see any
issues and we just stopped there because
at that point we realized that that
wasn't an option a viable option but in
the future we'll come back to that and
we'll see how much more traffic we can
get out of that so that's a really nice
thing to say when we deploy something
into production well you know we can
guarantee can with reasonable certainty
say that 8 we can we can support 8 times
the traffic which would be you know a
dream for the product team and for the
management team to say ok we have it we
can still handle 8 times traffic and it
really makes it tough
future-proof for for us as a company and
then further from that we were able to
reduce complexity by removing
third-party integrations we used to use
Redis a lot none of us are Redis experts
so we just you know maybe this is right
or maybe this is wrong and we were able
to jettison these third-party
integrations that were costing us a lot
of money and by jetting these
third-party applications and other tools
were able to become experts in one thing
which is you know are like an elixir and
it makes it a lot easier to say okay so
instead of you need to know about X
number of things I need to know about
one thing it makes it a lot easier and
it focuses your it focuses your skillset
as I mentioned earlier tangible savings
we saved a ton of money on servers we're
still sort of fine-tuning how we use
them as we understand how the beam works
and these kind of things we were able to
jettison a third party integration
service that we were paying a lot of
money for and it's kind of a funny story
so when one of our developers went to
went to break the news to this third
party that we're not going to use their
service anymore and we were paying them
a lot of money and we she explained he
explained well you know we're doing this
and with the liquor in Phoenix and now
we don't need to use you anymore and all
the responses hey well why isn't
everyone else do this so and it's and
it's uh it's it's a good point why not
and we have a much more reliable
platform now as I mentioned as I alluded
to earlier we were able to do Super Bowl
Sunday without any incidents without
even bothering to check it the NFL Draft
is our biggest night of the year
consistently for whatever reason people
really want to know when their players
are drafted I'm not sure one not a
sports person but I they liked it so we
were like heavily on push notifications
to send out alerts for people to come
into the app and check these things and
in three hours we sent 225 million push
notifications which is quite a lot and
our push notification system the actual
the thing that pushes out them the
notifications is running on two
instances and one is for redundancy so
this is I mean it's a really really nice
demonstrable win and this was one of the
times when both
summers who use our app work so we're
standing where app reviews like this is
amazing like which report is always the
fastest I don't know how they do it but
something changed and also the the
people who program the the content
streams like if you follow the 49ers or
I know the Texans or whomever they also
were like as soon as I click the mouse
button to send the alert my phone buzzes
with the alert and before it would take
we had to do all this we are caching and
this deduping and rubies is not the
greatest at that so we would it would
take it's if you say you send a push
notification to all NFL subscribers
which I think this about I think we have
about 10 million it would take up to
five minutes and now it's in now as soon
as you press the button within a few
milliseconds you start sending them out
and then it finishes significantly I
mean yeah I think it finishes probably
under a second or two so it's a huge win
for us and then relatively future proof
what this means is that we've designed
as we've come to understand how ecto and
Phoenix and what works and how data
modeling works in a functional
programming language and how we started
to move away from these hard concepts of
modeling like a cat's as opposed to like
a Christmas earlier not to use a cat
analogy but a user and a registered user
we've been able to model our data in a
very generic way so that if bleach
report decided to move away from sports
and on to some other topic politics or
at a regional cuisine on the backend we
wouldn't really have to change anything
we would be able to say okay this is so
now that we're talking about politics
instead of have we still have the same
concept we still have a youtube article
we still have a video Facebook post all
of these things so it's it's made our
platform much more agnostic so
decoupling the data from the models has
made it really really nice for us to be
confident that five ten years from now
maybe we'll still be running the same
platform especially given the fact that
it would be I'm pretty confident that if
our CEO said now we have eight times the
traffic that we had and we're still
running the same platform they'll you
know everyone's happy and then at that
point we were able be able to move into
other other platforms others other other
challenges and
to this point now that we have this
stable platform instead of being like
how do we support this how do this now
the question is what do we do with this
now how can we push this to new limits
what are these new product ideas and
suddenly for the longest time the the
engineering group was sort of the hold
up for the product they wanted to do it
look at all these different content
types
and then we redesign the system and now
what used to take a couple of three days
now a new elixir developer can add a new
content type within a few hours which is
really good for them as well because
it's a confidence hey here's now in the
app I see this type that I added and so
on
and it gives us a timed and for the
first time the in a while I think
product is like okay so you gave us all
that you you over delivered on all of
these things so now what do we do with
them so they're sort of figuring out the
strategy of how to use these new tools
as well and finally developer happiness
you know don't take my word for it again
ask ask my colleagues but when I first
started bleacher report we have everyone
goes on on Visa option you go on called
about one sim once a week per month we
have we have offices in London as I
mentioned so if someone had an alerts
someone if the site went down or if
there was some problem with the internal
tools you get waken woken up in the
middle of the night so the first few
times I was on call it was a nightmare I
would dread it I'd carry the laptop with
me all the time because there would be
something would go wrong and now the
last few times I've been on call there
hasn't been any any issues or if there
are you I mean there's been a few small
things but it's usually during working
hours and they're missed you know it's
significantly better than it was to the
point that now the last time I got what
kind of in the middle of the night was a
developer and a Content programmer in
London complaining that their hotel
Wi-Fi was down and what could I do to
fix that I you know it's sorry you're on
your own um and and it's there's a real
sense of accomplishment too it's you
know instead of it's not fun to fight
fires all the time it's not go it's not
fun to go into work and fight fires it's
fun to go into work and develop new
stuff and this is what we all do now
everyone is working on new projects
whether that's from taking out
functionality from them the old rails
monolith and moving it into phoenix and
elixir or whether that's the same or
whether that's having the option to make
something
new and push the limits of our platform
it's really exciting so you're actually
writing code and not just saying okay
let's add these you know X number of
instances to AWS and right now I guess
now everyone for the past six months or
so every one is an elixir developer I
bleacher report which has been a really
nice accomplishment for us and everyone
is pretty happy with it there you know
when you learn a new language with
anything else whatever whatever skill
you you know guitar drums whatever
there's always there's ups and downs you
know I'm doing this really well and you
hit a roadblock and how do you get past
that roadblock but once those roadblocks
are overcome it everyone's really really
happy and it's it's it speaks to the
design of the language and it speaks to
the design of the framework as well as
the community and how they have put
forth the efforts to make documentation
in first-class and a citizen and all
these kind of things and I think that
everyone is really really happy and in
even you know to Stefan's point to how
you know ramping up is slightly more
difficult but I think it's also more
rewarding because you're like with the
rails thing I mean I remember when I
first started doing rails I made the
rails blog and I was like now what like
what do I do with this but Phoenix gives
you the tools to say this is like it by
breaking things into chunks and
components and modules it makes the
development process more interesting and
more engaging and I'm sure that as we go
along it will be that much better and
any questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>