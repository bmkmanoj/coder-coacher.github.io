<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Web3.JS: Ethereum JavaScript API | Coder Coacher - Coaching Coders</title><meta content="Web3.JS: Ethereum JavaScript API - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Web3.JS: Ethereum JavaScript API</b></h2><h5 class="post__date">2018-02-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/E8l4UryS73w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now we will be speaking about web 3js
1.0 which is a major refactor from the
early version which was around for the
last two years shortly about myself my
problem focused Allah I am built the
initially film wallet the miss Bowser
and worked on web three.js since there
are two and a half years roughly build a
few other things also initiated the UC
20 tokens standard together with italic
and did a lot of other smaller things in
the space the web switch as well 3GS is
basically a library javascript library
which allows you to interact with your
STM node normally as a JavaScript
developer you don't want to deal with
low-level api decoding encoding you want
to basically have a nice javascript
object which you can interact with and
easily write your applications and web
sweet jess is exactly this kind of
middleware it's widely used and actually
the core piece of a lot of different
libraries built on top and working for
two years on it and it grew over time I
found very necessary to do a overhaul so
to say it was initially created by Jeff
Jeffrey Wilkin the go aetherium founder
core developer and mary cutter which are
but worked later on it I joined in 2015
working on it since then and we have
also a lot of contributors and there's a
lot more than on this list here so it
started out in 2015 Kru quite a lot and
now we structured a lot in the 1.0
refactor so how exactly the theorem
communication to applications work right
um node itself and the EVM especially
only understands byte code byte code is
not necessarily easy to work with for
most application developers and
everything which goes into the EVM has
to be first translated to the bed byte
code to be able to be executed so for
example this happens over the JSON RPC
API which is a low-level json api where
you have to send all of your requests
and this has to be pre encoded to be
understood by the vm and this is exactly
what web three.js does for example if
you look at this example here if you
want to call a function in the e vm for
somebody we want to call the transfer
function with two parameters on a
contract we would have to translate this
by hashing do you function including its
parameter types and then taking the
first four bytes of that as the function
name and then appending the other
parameters after that once which s is
exactly like taking care of that so you
don't have to do it and you can easily
community work with JavaScript objects
and the 1.03 factor is actually a major
overhaul to make that even more
convenient and even more intuitive and
give you a lot more features and tools
so that you can care building about your
application rather than thinking about
how to encode what and what kind of how
to watch for your transactions and
building all of that logic for yourself
so I hope that 1.0 fulfills all of that
needs and is kind of the DEP developer's
best friend
so the 1.0 refactor is a major effect in
the sense that i restructured a lot of
the the tools everything before was on
the major object kind of like this burst
this way and now we restructured it in
proper elements utility functions are
for example under the utility objects
and all of these packages are also
separate packages so you can load either
the ones you
eat or you can load it all together in
Braille a package so I will now go
through all of these package separately
and show a little bit of what I have and
what new features they have one
obviously very important piece in this
is that we now have promises something
which was something which probably took
way too long this is all due to the way
how it COO over time and we all had to
figure out what works and what doesn't
work initially think thinking also that
the connection to node will be way fast
and way more smoothly than it actually
is
with like a large network which we crew
today to basically promises allow you
simply to chain your functions which
makes it more convenient and more easy
to use and to see but we have a special
case of web switches and especially with
block chains we have the case that you
have an event which is not necessarily
final so it cannot really come with one
result only especially when you send the
transactions there's the possibility
that you can you get a transaction hash
but you're also able to get to receive
and there's also a lot of other things
you have to take care of for example the
chain can reorganize for certain amount
of blocks with a likelihood so you have
to take care of all of these things
yourself so when you just use the
promise for example you get the receipt
which is what most developers want they
won't simply send the transaction and
act once their mind but in most cases
you actually want to have more complex
and more detailed response to you up to
your transactions maybe you want to wait
for five confirmations or maybe you want
to actually do something with the
transaction hash directly so this prom
event construct basically allows you to
get all of these different types you can
get back from one transaction and do
something related to it so it can be a
promise but it can also be an event
where you can wait for a transaction -
receive confirmation and we can even add
a lot more and a few
web switches 1.0 has subscription and
this is something I worked on quite long
and it always takes a bit of time to
convince many parties to do something
and you are different or a certain way
and subscriptions are important because
we have a lot of events coming from the
node and the old way of doing that is
that your application is polling that
node that works quite fairly well if you
have one application and you pour for a
few events but it doesn't really work
well if you have many applications
polling on the same node so subscription
basically allows you exactly this pops
up model where you can wait for events
and you have to do nothing best but
waiting until it happens this would use
it a lot the resource load you have in
the node and this also improves the
processing you need to do on your node
itself on your application itself so IPC
sockets is basically the local socket
you have when you notice running locally
and web socket is when you would you
talk to a remote node the HTTP still
works as well but for subscriptions it
can't work there we are thinking about
using also some kind of polling again
but ideally you make it work with web
sockets or you actually have a local
node running directly so for example a
subscription could be locks or pending
transactions or if you know the syncing
or not the advantage of that over the
previous way how we did it is that it's
a lot more intuitive and a lot more
clean right now you can basically
subscribe for information which is a
pattern most people understand before we
had like filters and watch and get watch
and which was very unlike unclear of
what it even means now everything is
under the subscribed namespace and it's
pretty clear that this will be an event
Europe you would leave but also here we
have special cases that in zank some
cases you can't have an event which
actually can change for example you can
have an event coming from a smart
contract
and it might be different after chained
organization so that's why we also here
need this kind of pattern that we are
able to wait for the data at the actual
event or we are also able to wait for
the changed event so we can reverse it
in our dab and we can apply the Newton
to new lock which might look different
it might have different results the way
smart contracts are initiated in the new
web 31.0 is more the way we would expect
it when we actually initiate a class
object so you have to use the new
keyboard a keyword and you have to give
it a JSON interface this way you
instantiate the object and you can give
it an address optional or additional
options therefore also the options are
in a separate options object so you can
easily see what are the current settings
of your contract object also to note
here is that all the addresses returned
from web switches are now check some
addresses you cannot see this here in
this example but actually you can see it
from it has an uppercase D for example
uppercase F so when you use an address
and you pass it in you send it into any
kind of function in web to test it will
check to check some and if you check
some is invalid it will fail if you pass
in a lowercase address it will just
accept it as is because it cannot check
to check some now in the smart content
object itself all the methods and all
the events are separated in its own
namespace this helps with things like
where you have an event may be called
the same way than a native event on this
mark on an object and when you call that
event it gives you back a object with
moldable actions you can now do with
that function so for example if I call
this to something I get an object back
where I can also later even change the
arguments or I can decide to do I call
that on my note
I sent the transaction off to the node
to be mined in the network or if I just
want to estimate the gas of this
transaction or I maybe just want to
encode the API to be used in as a
parameter and another function and also
here we have the ability to add even
more if we need to in the future and
extend whatever the method methods of a
smart phone can do so if you for example
call that it would look like this you
call the method on the methods namespace
you paste in the parameters and as we
also now paste only parameters of the
smart conduct function in the parameter
space we are also in the future able to
allow structs which we are working on
right now before this drug was always
meant as the transaction object so there
was a bit of a confusion and if you
didn't want to send it you give it your
the options object of the same
transaction for example for example if
you then get this back and you wait for
the receipt or you just like we solve
the promise you would get back to
received and it would be decoded
parameters also the raw data and
everything else you need so this
structure is a lot more clean and a lot
more accessible than it was before
same here if you have an event so if you
have an event it's under the namespace
events you could have an additional
options that you want to fill the for
specific events for example you could
say I only want to have events which
matches the my index parameter
20 with the value 20 and 30 and my other
index parameter has to have an address
so and so and it would then only would
review these events matching that and
you would get them basically once they
are happening and this is under the hood
using for example subscriptions which
right now it doesn't work for HTTP so we
have to at the polling here web 3 use
accounts that's actually a complete new
thing because when through these
accounts allows you to actually generate
accounts and sign data
sign transaction encrypt use accounts
the cryptids accounts import key store
accounts and basically gives you all the
tools you need if you want to interact
with a public key private key account
and having these signing functions in
Webster HS directly allows us to do a
lot more what you before would have to
do with multiple libraries and note here
this is still in beta
there's no audit run on that so use it
at your own risk
we will ideally have an audit on that
and then it's probably more safe to use
we have a bi directly a bi
encoding/decoding functions I think this
is very important because you are able
now to like encode your own ABI calls
decode them and you have all of this
what sports which was before inverse
which is internal exposed and nicely
named and so on it even can decode you a
whole lock automatically we have now the
new swarm API as well so you're able to
interact with swarm swarm works a little
bit different than the theme node so the
provider is different it doesn't use
this the IPC connection you can either
use directly HTTP or it connects to your
local swarm node which opens a local
host
8-15 endpoint and this basically allows
you to upload files download files and
even opens a file take awaken file pick
so if you're in the browser you can pick
your files and upload them to Swan
directly and you get the hash back to
interoperate with it whisper is
currently the whisper version five API
web switch s there's right now a
discussion about refactoring into
version six which will also be supported
by parity the current version five is
basically in the old web switches and as
well and the new one and you can play
around with it and
experiment and the details function
obviously there's a lot of extra utility
tools you can use there's a lot of
things you would use as a the tap
developer especially here things to
check for example for camp checksum
addresses encoding and decoding to a
certain extent especially from utf-8 I'm
converting numbers and internally right
now we are using always BBN library but
when it returns a number it returns the
number as a plain string so that you can
actually use whatever library you want
to interact with large numbers and it's
also for departing reasons a lot easier
to see the number rather than a big
number object and very important
probably also you're able to hash
exactly the way solidity hashes so this
allows you to basically generate some
hash and then knowing that the
smartphone itself would come to the same
hash so this is tightly packing the
arguments there multiple ways of how you
can do that you can use the auto
detection which is probably not very
safe for things like numbers which
simply convert to you in 256 it's easy a
string would be converted right from a
utf-8 and obviously bytes would be bytes
the byte 32 right now I think but you
can also give it an object and tell it
the exact type so this can be V and T
but it can also be value and type and
you can basically tell them hey this is
my arguments this is the type of the
arguments and then hash them yeah it is
just a longer version and this is
another verse so yeah actually it works
right now I think for the reason how NPM
works it will right now by default
install the better version which is
probably not very wanted but this is the
fault of NPM I guess and there's a
extended documentation now
which is a major improvement to the
documentation we have before
basically all the functions are
documented and they're all with examples
and everything so go to read the docs
right now you have to go to the one
points your branch if you want to see
the one point zero documentation the old
one the old print doesn't have any so go
to an one point zero and you can read
the docs and that's the end</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>