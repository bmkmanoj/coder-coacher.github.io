<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CSS As BYTECODE | Coder Coacher - Coaching Coders</title><meta content="CSS As BYTECODE - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CSS As BYTECODE</b></h2><h5 class="post__date">2017-12-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/w4_1SagLY94" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right welcome this is CSSS bytecode
I'm Richard Feldman so first of all
hello everyone it's lava good to be back
good to see everybody so I wanna start
off with a quick question so let's
imagine that a designer comes to you
with this glorious mock-up this
extremely complicated web page and just
imagine that you're sitting in front of
your laptop with your fingers above your
keys and you're thinking okay I'm gonna
start implementing this how many people
quick show of hands could start
implementing this this horizontally and
vertically centered box without looking
anything up just immediately start
typing okay that's like as yeah single
digit percentage maybe and like keep in
mind this is this is a roomful of
experts
right I mean we are front-end developers
this is what we do and when I'm using
like Google slides which is what I use
to make this talk like this is the UI
for horizontally and vertically
centering things I'm like if I want it
horizontally centered there aren't even
any text in these UI just click this
icon if I wanted vertically centered I
click this icon so so why is this
different I mean and and what are the
consequences of this but there's sort of
like a lot of things like this in CSS
where are these things that feel like
they ought to be straightforward turn
out not to be and they sort of
accumulate and they end up with a lot of
frustration this is a this is a
sentiment that that quite a lot of
people seem to resonate with at least
based on the number of retweets and
lights and number of people laughing in
the audience right now
and so so I think it's a reasonable
question to ask like why what why is
there so much frustration out there why
are so many people frustrated by using
CSS so to lay out their websites and I
learned something about this and I think
I have a plausible answer to this
question which is just that CSS was
never intended to create user interfaces
that's not what it was designed for and
I kind of found this out when I was
reading about the history of CSS in this
extremely entertaining article the
languages that almost became CSS by Zack
Blum if you've never read this article I
highly recommend checking it out because
I kind of talked about it just goes to
the history of like how did we end up
with with the layout and stylings
that we did and he starts with talking
about back in 1991 Sir Tim berners-lee
introduces the hypertext markup language
which had an extremely fancy logo and
this was just for content like it was
for writing semantic content that you
would send out to people over the web
and that was all it was no styling
whatsoever in the initial draft of HTML
it's just a way to structure content
then at some point people got the site's
yeah hey maybe this content might like
to be styled which you think yeah that's
pretty reasonable idea right see this
big wall of text it'd be nicer if it
were styled said yeah you know but let's
take it a step further we got this good
idea we're gonna separate the content
from the presentation we're gonna we're
gonna do couple these it's gonna be a
separation of concerns and here's why
we're gonna do that the idea is the
authors are gonna create the content and
describe it using HTML and then when it
arrives in my browser I'm going to style
it like the end users are gonna write
style sheets to style the content
because hey what if I like a different
font than somebody else likes I want to
see my articles in that font I like
different colors like maybe I want to
use different colors for some articles
and different yeah like this is this was
the idea this was the design goal so
we've sort of like retcon to this thing
that like the separation of concerns was
for programmers but it wasn't like if
you look back like yet the whole idea
was that the separation of concerns was
because they were gonna be different
people doing the content authoring from
the people doing the styling so this was
the idea and there were these proposals
for how to describe these these
user-defined style sheets this was one
pwp that's not what we ended up with
there was another one called fossee
which is like very XML flavored like a
little bit later there was d ssssss I'll
out there's like a thousand s is in
there this is kind of Lisp looking and
there were also some people who thought
this is a bad idea
so here's somebody this quote style
sheets are an artificial construct
inflicted on us because of the whole non
presentation philosophy we've been using
I find it somewhat reassuring to know
that people still argued angrily on the
internet before like Twitter and reddit
this is cool is 1994 I mean we you know
we've been doing this stuff for longer
than I realized
and so this was like a controversial
thing this was not like Oh CSS obviously
I mean like for us it's easy to you know
have been become accustomed to this
being the way that always was but this
wasn't the way that it always was this
is just where we ended up after in 1996
browsers sort of ended up standardizing
on CSS that's that's what they decided
to go with as the way for these user
defined style sheets so a success green
now end users can finally style content
mission accomplished
okay that's forward twenty years to the
present CSS being I guess it's 21 years
now css3 1996 and now the web has become
the biggest user interface delivery
platform in history so this is what both
the web is sort of like the best at I
mean yes there's definitely still plenty
of content granted it's being styled by
professionals not by end-users and but
but really the thing that's sort of like
made the web take off is the fact that
it turns out to be a fantastic
application delivery platform the most
successful one in history so what CSS
was originally designed for was end
users styling the content that they read
and if you think about it like in that
system like why would you bother making
it easy to horizontally and vertically
senator center content like imagine the
last time you were reading an article
and like right in the middle of the
article is like boom on your screen
there's something that's like vertically
and horizontally centered it'd be weird
like when you're reading a block of text
you just care about the flow from left
to right and top to bottom or right to
left as the case may be depending on
your language but but this is not really
something that comes up in that use case
and there's a lot of things like this
where there's some set of things that
you really want if you're building user
interfaces there's a completely
different set of things that you want if
you're trying to design for these design
goals of separating the people who are
writing the content from the people who
are styling it so as we now know 20
years later this is not actually
something that a lot of people want so
much that in fact like some browsers
have been taking this out like they've
removed the ability to have end-user
customized style sheets in the browser
at all and you actually have to install
an extension if you want to be able to
do that so that was what it was designed
for and then what it actually ended up
being used for is creators styling
content and of course building user
interfaces so we have somewhat of a
similar situation when when you think
about like what we're all this
frustrations coming from with with
JavaScript from 1995
so 1995 JavaScript's created a famously
that the story goes that the Brendan
Eich designed it in ten days and what he
was doing in those 10 days is he was
designing it to build gigantic
multibillion-dollar web apps that was
what he knew that javascript would be
used for no that was that was not the
plan but that was what ended up
happening again because the web turned
out to be such a great delivery platform
for this but that was not what it was
designed for it was just designed to
make like basic real-time interactivity
the alternative was like plugins like
Java applets these these really
heavyweight things it was designed to be
something lightweight and kind of kind
of easy it was not intended for the
these enormous code bases that we now
have but we've actually ended up
figuring out some ways that we can solve
these problems for ourselves this sort
of like design goal mismatch with things
like compiled to j/s so we now have many
tools which compiled to j/s while
keeping the familiar J's semantics so we
have things like CoffeeScript so
CoffeeScript was really popular for a
long time right CoffeeScript code run it
through a compiler end up with
JavaScript that you hand off to the
browser that kind of got replaced by
different compiled to j/s solution Babel
which is compiling a future respective
j/s or the current spec of j/s into
legacy javascript for that older
browsers can support the same idea just
compiled to j/s and of course we have
things like typescript that are getting
more popular which are compiled to j/s
still same j/s semantics like all of
your JavaScript knowledge very much
directly translates to using any of
these three but typescript adds things
like a type checker and some other
niceties we've also seen more ambitious
compiled at Jas projects so these are
compiled of Jas projects that have no
semantic relation to JavaScript so we've
seen a couple of these at the conference
first close your script David Nolan
talked about that yesterday let's see a
little bit of reason ml later today
Jared Forsyth and me talking about Elam
so these are languages where they're
saying you know what we don't actually
have a semantic relationship to
JavaScript to to us
javascript is byte code it's something
that we use purely as a compilation
target because we want to get stuff done
not because we actually want to embrace
the original design of JavaScript itself
so this idea of JavaScript as bytecode
is what these languages are doing
similarly we also have compiled CSS
solutions that make CSS a little bit
nicer so we have again the many of these
things that sort of keep CSS semantics
tact so like SAS for example if you know
CSS a lot of that knowledge is gonna
translate to SAS but pretty much all of
it
same thing with JSS which is also at the
conference you know they're adding
additional capabilities different API is
different ways of presenting CSS but at
the end of the day ultimately it's
incumbent on you to have that CSS
knowledge to be able to use these tools
okay what about something that has no
relation to CSS what about something
that says CSS is just a compilation
target it's just byte code like these
languages that are doing the same thing
for JavaScript what goes in that box
well let me introduce you to style
elements so style elements is a library
created by Matt Griffith and he
introduced it at Elm Europe last year in
Paris and this is a library that is
written in Elm didn't have to be but you
know it was and it is it compiles to
JavaScript the Elm and CSS and dom it
was a complete user interface
abstraction like literally it is
conceivably possible that someone could
use this library without knowing
JavaScript without knowing CSS without
even knowing how the Dom works and still
make a completely functional user
interface that works and can be deployed
on the web that's the dream and it's
reality and this is done using clean
slate semantics like really going back
to the drawing board and saying not how
can I translate this concept from CSS
and make it nicer but rather forget CSS
forget JavaScript forget all of that and
just say I want to build user interfaces
and I want to deploy them on the web
what's a nice system for doing that this
is a totally different design golden
what we had back in the 90s when this
stuff was still early days and we were
still figuring it all out so some of the
design goals in a more concrete sense
wanted to say we want to create
maintainable user interfaces so this is
where a lot of this frustration comes
from is that CSS and you know not only
was it not designed for user interfaces
but it certainly wasn't designed for a
large scaling user interfaces like we've
heard from a number of people over the
course of the conference about scaling
challenges that people have run into
this is just as much a challenge in CSS
as it is in JavaScript
if not more another design goal long
term cross-platform support if you're
building a system for
building describing user interfaces
there's lots of different platforms
react native has shown that there's a
lot of value in being able to have one
code base that is shared across multiple
different platforms iOS Android Mac OS
things like that if you're designing
this for this use case up front you can
do a lot of work towards making that a
better experience and finally have one
compatibility table I love can I use com
I would love even more if I didn't have
to use it just being able to say if you
use this library you can depend on being
able to support these browsers any
layout primitives you want to use in the
slide library they will all work as far
back as these browsers you don't have to
go look them up on a case-by-case basis
okay so these are the design goals with
that in mind I'm going to introduce you
to this new set of layout primitives
we're gonna look at a user interface
that I built using style elements and
we're gonna walk through the concepts of
working it out I realized most people in
here or not probably not alum
programmers so I'm gonna speak in pretty
general terms but we are gonna see a
little bit of code later but what I ask
you is that when we're going through
this just try to clear your mind
don't be thinking like hey how would I
do this in CSS or what is that compiling
- under the hood just put yourself in
the mindset of someone who's learning
this stuff for the first time and saying
I'm going to learn this new set of
primitives for how to do layout in the
browser alright let's do this so here's
the the very simple application that I
put together it's got a little bit of
layout stuff going on we got a little
logo type thing over here the upper-left
CSS is byte code says built with elma in
the middle it's a little tag line got a
drop-down menu over here with a little
bit of hovering for stuff like that so
this is this is sort of the typical type
of thing that you might imagine seeing
in a web app I've also made it so that
we've got a little vertical and
horizontal centering in the middle there
so we can see what that looks like and
as I see how that's when it stretches
the image of beautiful bratislava castle
with the reactive logo staying centered
no matter how far I do it you might also
notice that if you look at that tagline
in the middle that says built with Elm
this is a bit responsive so as I shrink
it that tagline goes away beyond a
certain point and also you might notice
that CSS has byte codes in the upper
left the menus in the upper right as I
shrink it down further and further those
go away and we end up with just the menu
that's just centered so this sort of
shrinks all the way down and
and is responsive okay so let's walk
through how that's built using style
elements so first thing to note is we're
gonna introduce you to a new layout
primitive this layout primitive is
called a column and the idea behind a
column is that it flows from top to
bottom as you add elements to the column
like cells in a column
they just keep adding from top to bottom
stacked on top of each other so there
are two elements in this column the top
one is our header bar and the second one
is everything else like the big image
with the centered other image inside of
it so this is a column layout this is
our first layout primitive in style
elements okay so that's the conceptual
idea now if we zoom in a little bit on
that first cell in the column the first
element there that is a row so this is a
row as opposed would call them rows are
laid out left to right so as you add
more elements to a row they get added on
to the end so we have three elements in
here first one is the logo second one is
the tagline there is the menu so again
one two three as we add more things that
get added to the right okay
now let's zoom in on this one this one
we can layout using the same primitives
that we just talked about this is
another row laid out left to right so
again three elements inside of it
there's also spacing in between these
this is a new concept that style
elements introduces we're describing how
to space things out within a row so what
this is saying is let's say I give it a
spacing of five pixels what that's gonna
say is each element inside this row is
going to have five pixels in between
them so we can increase that if we want
to have more spacing say like ten pixels
or we can decrease that and have them
more tightly packed that's the idea
spacing so this is this is another one
of our layout primitives then we have
the drop-down menu that appears below it
again internally this is laid out as a
column right top to bottom if we add
another element in there the fourth
element would come below sign-out it
would be at the very bottom of that
column another layout primitive we have
here is these are not organized using
spacing which would put gaps between
them but we care about the hitbox here
right when we hover over these things
and we want to click on them we're gonna
have a nice juicy hitbox like anywhere
in this area around account we want to
be able to click and have it follow that
link so for this we use padding so
padding is a way of
banding in element size spacing does not
expand the element size but padding does
so if we want a bigger hitbox padding is
kind of the thing to to go for okay so
we got our column we've got we've got
our padding going on we've got our nice
hitboxes and we've got our row above
that I think that you might wonder is
how do we get these to be organized this
way
I mean previously we saw how to nest
things you can put rose inside of
columns columns inside of rows but this
is sort of breaking out of that mold
this is something we want to say this
drop down I want that to be below the
menu how do you say that how do you
describe the idea of one element being
below another one no matter where that
other one is in the layout well we have
a function called below and you give it
two arguments first you say the thing
that you want to put below the other
thing and then you give it the thing you
want to put it below and that's it and
now it just says this is just going to
be positioned below the other one that's
the whole deal okay so to sum up just to
recap what we what we talked about we
have this whole page as a column it's
got two elements inside of it first the
nav bar and then the second being the
rest of the body if we added a third one
it would go below because columns go
from top to bottom that first nav bar is
a row within that row we've got three
elements one two and three if we added a
fourth one it would go on the right
because rows go from left to right and
within that row we have another row
which is used to style the menu bar
itself beneath that we have a column and
it's got three elements inside of it and
the way that we positioned the one below
the other is by using below passing in
the the to the menu and then the thing
that we want to go below the menu okay
using that knowledge let's see if anyone
can guess how we would go about laying
out the logo in the upper left which has
two pieces to it it has CSS there which
is in white and then it has as byte code
which is in green you may imagine yes
let's sit let's just think about the
three poun is that we've got row column
below quick show of hands who thinks
it's below who thinks it's column who
thinks it's row yes all right yeah it's
it's just another row is it the same way
as the as the menu in the upper right so
it's got two elements in it the first
one for the white portion second portion
for the green portion speaking of
portions
you might also be wondering okay so if
these things are stacked why is it that
this navbar doesn't have these things
stacked up all the way on the left why
are they distributed this way so you can
give each element to width and in this
case what we're giving it is a width
that's not a hard-coded fixed value but
rather a portion so in this case I'm
saying
Philip portion one for each of them and
that means you get to have one portion
of the entire space so each of these
gets a fill portion one if I'd made the
middle one half fill portion too then it
would be twice as wide as the others but
still all three of them put together
would fill that entire space so a fill
portion is just one of the other
alternative ways to describe how wide
you want something to be okay you might
also notice that these are aligned
differently so the the logo in the upper
left is left aligned the built with them
tag line in the middle is Center aligned
and on the on the right we have the menu
being right aligned how do we do that
well some new primitives align left
center and align right that's it we just
describe them in terms of their
alignments in the same terminology that
you might use in like a word processing
system okay that brings us to the last
bit which is this logo which is centered
in the middle of this other image so
silents has you know images that that
you can use to you know position however
you want and it also has a notion of
within so within basically says I want
to use one of these elements as sort of
a container for another element so we
talked about how this is a column with
two elements in it the bottom column
we're saying okay I want to put that
logo within the other element so now
whenever I specify this things centering
properties it's going to be within the
context of that containing element so
this brings us to the live coding
portion of the demo so here we have a
version of this where I have not
specified any centering information at
all so we have we have to come flow go
and no nothing at all going on over here
I'm gonna add Center and hit save and
it's gonna reload and this happened to
me yesterday with a lightning talk
eventually the websocket gets
disconnected so so now it's centered you
know let's go back and do it with that
okay so we start off with it in the
upper left and then we add Center and
now it is horizontal
Center and if we want it to be
vertically centered we had vertical
Center and now it's vertically centered
da da so a funny story about vertical
centering is that this is actually how
Elm was created the programming language
was Evan Shu flicky was working at
Google and he was helping out a friend
he worked on Gmail on the backend and he
was helping out a friend on the front
end who was really wrestling with trying
to vertically send her something and it
ended up they concluded that it was so
difficult they decided that they just
didn't want to vertically Center it
after all and we're just gonna go do
something else
and now five years later somebody has
built his programming language on top of
his programming language a way to make
vertical centering much easier and it's
it's responsive so speaking of
responsiveness let's talk about that so
responsiveness how does that work
in this system so we saw that there are
sort of three break points here so this
is the the main way that things look
when it gets a little bit smaller the
built with Elm tagline disappears and
when it gets even smaller we're down to
just the menu here okay so basically Elm
has conditionals being a turing-complete
programming language and you can know
certain things such as what's the
viewport width so if the viewport width
is less than 640 then we're gonna say
render the menu centered so menu here is
a function and it's just accepting how
do you want it to be aligned this is
just a function that I wrote I wrote a
function called menu I said I'm going to
accept the alignment because I want the
alignment to be different depending on
how I'm doing this responsive layout if
you port width is less than 1024 then
I'm gonna say list out a pen so this is
a way to combine two lists together I'm
gonna say I want to have a list of these
things I want to have first the logo and
then the menu but I want the menu to be
aligned right so here's the logo and
then here's the right aligned menu
finally else we have take the logo and
the tag line with the right aligned menu
so that's it I didn't actually introduce
any new layout primitives all I did was
just use the fact that I already have a
Turing complete language to just
describe how I wanted my responsive
layout to work as simple as that okay
that brings us to accessibility so this
is another thing that is sort of opt-in
and CSS and
the idea here is to make accessibility
more the default and less something that
people throw on as an afterthought
so my co-worker Tessa Kelly made this
awesome package called accessible HTML
which is a way to help you write
accessible HTML on elm and one of the
things that she did in that package is
make it so that alt text or images
becomes a required argument you just
can't forget to do it if you don't put
all texts to your code just doesn't
compile now of course you can put empty
string if you really genuinely think
that there's there's nothing
semantically there but the idea here is
to make it so that accessibility is no
longer an afterthought it's something
that's just like front and center and
not something you can forget about and
style elements does a lot of these same
things especially with form elements not
just with images okay so we've seen
these these set of primitives that we
use to build this layout right
row-column blown within spacing padding
alignment and fill portion and we've
also seen how to make this thing
responsive so earlier I asked you to
sort of like clear your mind and forget
everything about CSS but now I'm gonna
take that back and say okay let's let's
actually think about this like think
about how you would build the same
layout the same responsive thing in CSS
what are the primitives you would use
how do they compare to these this is a
side-by-side comparison we can now do
and say like what's the experience of
building a user interface in this system
versus in CSS what's that gonna be like
what's it gonna be like the first time I
build it what's it gonna be like over
time as I got to maintain it so you can
actually have a system that's designed
for maintainability we can have a system
that's asking questions like hey how
should deeply nested layouts interact
this is not something that was on
anyone's radar when CSS was first being
developed because deeply nested layouts
were a UI thing
who's got deeply nested layouts inside
an article that just doesn't come up
questions like how can we make
consistent api's it's really important
that the web be backwards compatible
that websites from back in the day still
work in modern browsers which means you
really can't delete things from the CSS
API for HTML or from JavaScript now if
they're byte code that's okay but if
you're trying to work with them as
first-class things man this is just
inevitably going to be bloat there can't
not be bloat style elements is freed
from that constraint it can make API
changes and as the library of Olives
over time and then finally there's this
mantra of sort of if it compiles it
styles this is like an aspiration
something that people report when they
using elm is this feeling of if it
compiles it just works and silences is
aspires to bring that same feeling to
styling things like if it compiles if
the compiler says this looks good the
idea is that it should work and it
should give you what you expect so
having settle this I do want to caution
you like this is a massive effort and
it's under heavy development this is not
something I would say run out and start
using this right now because I mean it's
a huge effort to try and design a new
layout system from scratch having said
that there are some enthusiastic early
adopters some brave souls including
Oliver here who reported this nail and
slack and you probably can't see these
numbers but I'll bottom-line it for you
he had 25,000 lines of code and he put
down to fifteen thousand lines of code
when he replaced his SAS with style
elements now granted lines of code is
not a metric that tells you a whole lot
of information but that is the type of
thing that at least makes me sit up in
my chair and go okay that's that's
that's a lot that's a pretty substantial
change and as he didn't quite say in
this quote he ended up feeling that it
was a lot more maintainable over the
long term if you like this idea of clean
slate semantics I highly recommend
checking out Elm so we've been using it
at work at no red ink
we've still had no runtime exceptions
from our alum code because the compiler
is amazing in two years two hundred
thousand lines of code still has not
happened
our legacy JavaScript still throws
plenty of runtime exceptions but that's
okay it's mostly hell now so that part
of the code base has been excellent it's
got its own separate package ecosystem
that's totally separate so we don't
actually use NPM for any of our package
needs and semantic versioning is
automatically enforced like across every
package in the library if I try to
publish a package that makes a breaking
change and I don't bump the major
version number one package literally
will not let me publish it it'll say no
that was a breaking change you need to
bump the major version number all of
these things are possible because Elm
has this idea of cleanslate semantics
and just saying we're gonna say
javascript is byte code we're gonna
compile to JavaScript and we're not
going to keep any of the semantics with
it you'd like to learn more about Elm in
general there's a guide l9 org there's
an awesome slash channel with people who
are super helpful in beginner-friendly
I'm writing a book shameless plug Elmen
action for manning publications it's
available for early access and I'm doing
a free workshop tomorrow so if you'd
like to come I believe there's still
some seats left
which may not be true now that I've said
that to sum up so CSS was never intended
to create user interfaces we know this
but we can build a new foundation by
treating CSS as white code thanks very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>