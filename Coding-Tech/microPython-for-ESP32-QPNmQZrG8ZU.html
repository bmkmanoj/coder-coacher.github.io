<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>microPython for ESP32 | Coder Coacher - Coaching Coders</title><meta content="microPython for ESP32 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>microPython for ESP32</b></h2><h5 class="post__date">2018-02-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QPNmQZrG8ZU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">um yeah good day everyone my name's Nick
I'm a consultant I work with large
computers a long way away most of the
time so it's kind of fun on the weekends
to work with very very tiny computers
that fit in your pocket but see I mean
see is an interesting and exciting
language as a lot of you would know and
have seen but it's not a relaxing
language in a lot of ways and if you
write C you often find yourself coming
back to C code you wrote when going who
wrote this
this is insane I don't even know what
this does anymore and as anyone who's
followed computer security knows C and
it's it's lovely memory management or
lack of tends to lead to very very it
makes it very very easy to make mistakes
to have buffer overruns to forget about
D allocating memory to do the wrong
thing and so one of the really exciting
things that I've been really excited
about in the 80 266 is that we've
finally gotten these systems on a chip
to the point where they work well with
interpreted languages and more
interesting languages certainly easier
to deal with on a day to day basis
languages including Python I presented
about micro Python on esp8266 at PyCon
and there was a lot of interest there in
it and the ESP 32 came out and I managed
to actually get hold of some of them and
was talking to Damien George who's the
original kind of creator of micro Python
the piebald platform and so on and we
managed to scratch together a bit of a
plan to get it running on ESP so YouTube
platform which has been successful it's
very very early days but it's kind of
exciting so I wanted to come along today
and share that with you guys so SP 32
modules we've we've did a bit of an
introduction this morning was Gus but
I'll just very very quickly zip through
that again in case anyone wasn't here
this morning a very nice little
system-on-a-chip
originally that that 82 66 chip came to
prominence as a coprocessor network
interface for something like an AVR
Duino type based
thing until someone finally read the
spec sheet and realized it was several
times as powerful as the thing it was
helping and the relationship kind of got
turned around a little bit at that point
they've risen to prominence as a
development platform largely because of
the the way that the accompanying
expressive to their immense credit have
embraced the enthusiast world and the
open source world it's it's been a
really great platform to work on and
they've taken a lot of the feedback
they've got from that world and gone
another step further so where the 80 to
66 was a bit of a leap ahead from the
existing systems on a chip in the market
the 32 has just done another jump
forward we've now got multiple CPU cores
we've got far better IO we've got higher
clock rates we've got this really cool
ultra-low power processor off to the
side it's some brilliant stuff has gone
into this platform so yeah there's now a
networking stack that does all of the
area 211 stuff or 2.4 gigahertz stuff
Bluetooth lots of support for Wired
networking as well which is great and
the i/o is incredibly flexible and there
are so much stuff there that I haven't
even gotten to scrape the the really
look at it all and it's amazing just how
many things I managed to pack onto that
one little silicon die the IDF is the
the software development kit for this
platform it's a really nice load of C
code and fairly readable much to my
surprise building through our GCC
toolchain using extensive architecture
and light source stuff it's actually
quite easy to work with and you guys
have been playing with it there's an
Arduino thing there as a as a C thing
and so on
it contains a LW IP which is a quite a
lightweight Network stack and that's
made it quite easy for us now to bring
that network stack through to Python
micro Python so micro Python was
basically a reimplementation of Python
about 3.4 designed to run
very sort of resource constraints
constraint systems so it uses things
like value boxing to squeeze more out of
every byte of memory it uses and to get
better sort of cache behavior it is
written as close to the metal in C as it
can be written there's very little sort
of fuzzy abstraction in there and
there's a great deal of horrible C macro
ism but it's overall a pretty easy
platform to develop for I sorry that was
that slide the the distribution of micro
Python is completely MIT licensed which
means that you can take it you can work
with it you can fork it you can do
whatever you want you can include it
into commercial products you can develop
it further etc etc and that's something
I think is really important if we're
going to be saying to hobbyists this is
cool we can't also be saying them but
you'll never make a living out of it
so micro Python itself was originally
written for the Pi board which is like
an ARM architecture that's a really cool
little piece of hardware that you can
buy online from that link if you click
on the projector screen no wait if you
look at the slides later it also works
on things like 16-bit pix the 80 to 66
and the 32 part of the aim here is that
the same piece of Python should run
identically on the different platforms
although maybe quicker hopefully on the
first ones and with more i/o pins but it
should provide a layer of abstraction so
you don't have to rewrite your code if
the code you've written is for say
thermostat I think with an LED and a
button and a knob and
temperature sensor you shouldn't have to
rewrite that software just because you
change the CPU and so the idea of micro
path is to give you a little bit of
separation there you can talk about the
i/o pins in a much more abstract way
whether it's on a pic or whether it's on
an SP 32 it also gives us a little bit
of installation between your code and
the changes that might be happening down
at the SDK layer as mentioned before the
SDK is evolving very very rapidly and
very publicly its we're seeing I think
the other day we had a bug filed and
someone said oh well I hope this problem
and we said Oh upgrade to the latest SDK
or the latest idea and he said I did and
we looked at and we went oh yeah we
meant the latest one when we said that
not the latest one now which has 97 more
changes so it's it's a moving target but
part of the idea is micro Python helps
insulate you a little bit against that
moving target
alright so we actually have a separate
repo at the moment for the ESP 32 fork
of the the platform the aim is to
eventually merge that back into micro
Python proper and do that so far there's
only support for the basic IO pians you
can do a set a digital input or a
digital output you can talk TCP / IP v4
not UDP not opie v6 there is no support
for the really cool stuff like
capacitive touch sensors and the Hall
effect sensor and things like that but
these things are actually really easy to
add and what I mostly want to talk about
today which I'll get to is how we can
add them how as a community we can come
together and actually add stuff in
because it's not that tricky to do well
it's tricky it's not that difficult it's
not vastly theoretical and weird it's
just a matter of saying this is what the
IDF does this is what Python does how do
I connect the two up so we'll talk about
that in a sec alright so how do you run
this micro PI then great we've got micro
Python on a controller there's no
keyboard what do I do
so as you've noticed from these boards
there's a serial connector as we can
talk serial directly to the board to
program it once you've loaded up micro
Python you can also just use that serial
port
to talk directly that you were ripple to
a Python wrapper so anyone who's ever
worked with Python would recognize the
little prompt there this is saying here
you go write some Python and believe it
or not you can actually type directly
into your microcontroller you can type
Python code which is cool I just can't
get over that the minute I did that
exact piece of code pretty much in there
little LED turns on you go oh wow
this is cool and because it's Python
it's really easy to just take that next
step you know so far we've turned an LED
on we type a few more lines we have
blinky and what we're doing here is
we're saying forever remember forever
turn the light on wait a second turn the
light off wait another second it's that
easy to type stuff in and you can
actually see it immediately a feedback
that it's working which I just think is
fantastic it's really encouraging it's a
great way if you're a beginner gain to
this stuff it's it's always very
off-putting when someone says install
the tool chain all right now compile
your code oh yeah did I not mention C
syntax that can be really off-putting to
beginners so I think this is a brilliant
brilliant thing to get beginners kind of
sucked into the idea of programming
these tiny tiny little chip so I think
it's great for educational things as
well Python is one of the easiest
languages to learn and it really
encourages I guess people just give it a
go however typing stuff directly into
the console and having it run may seem a
little bit retro to you perhaps it's a
little bit like running an Apple to
again maybe that's why I like it I don't
know thankfully this is not all you have
to do you don't have to buy micro Python
magazine and type a list in
over 14 pages and so on and so forth
which would be a little bad we could
make some kind of mode of my guests so
you could play a cassette tape into it
so thankfully there is a file system on
that little chip again this is another
thing which if you said to me oh yeah we
have a V fat file system on a
microcontroller okay yeah yeah course
you do but but we do we do we actually
do and it has files and it talks
basically the same primitive is used to
talking to two files on from Python you
can open files you can write to them you
can close them you can read them again
you can look at directory lists erector
ease
I find that weird you can write files
into that memory now that's great but
you don't really want to write a program
to write a program into memory so that
you can have a program when you next
boot the thing that would be a little
crazy so there is a thing called web
ripple that lets you access that and
just transfer files directly there is a
small amount of fine print at the bottom
of this slide that says not actually
working on a SP 32 yet it's not actually
working on the ASP 32 yet that's a
screenshot from the ID 266 it will be
working for the city too soon
hey pull requests welcome so the idea
with this is that you connect up over a
WebSocket to the device so now you don't
even need to plug it in well to battery
so yes you can connect up over a web
socket and you can transfer files you
can type directly into the repple you
can combine those things and you can
control the device remotely over Wi-Fi
so that's really cool and that will be
coming to the 32 scene the other way you
can get files onto it is to use some
little programs I did I've put up on
github called Empire utils these are
actually really sneaky horrible things
they actually connect up to the repple
and they type the commands it would take
to write the program into a file into
the repple and then the rec will runs
that and writes the file which is a
little perverse and quite slow but
actually surprising well works and it
works so well when I wrote the uploader
that I win I should really just be
stupid about this and I wrote a fused
mount for it
you can now mount the file system from
your esp8266 or 32 on to your host
system and write files to it at 19 200
board so be a little patient but these
kind of nice because it means you can do
things like run and sha-1 some of a file
on the device you don't need a separate
utility to do that so it means that all
if your make and editors and things like
that can actually get it stuff directly
on the device
slowly but eventually so that's okay and
again pull requests welcome that's that
needs a lot of improvement a lot of
making it more robust and making it
retry when it fails and know how to
reset the board when it completely fails
and things like that but work in
progress okay
so right that's that one okay right the
other way you can get code onto it is in
the build directory for micro path and
there are two sub directories called
modules and scripts modules get any
Python code under modules gets pre
compiled to bytecode and then crammed
into the the actual runtime of Python
anything under scripts gets just
compressed down as Python source and
crammed into the runtime so you can act
as if there were files you can import
those modules as Python and things like
that so if you've got a big library that
you want to always include in your thing
you don't need to upload it and download
that to the file system every time you
can build that into your runtime and
there's a package called you pip which
is a micro pip it's it's like Python
package manager
but for micro Python that will hopefully
start to streamline that a bit it's
early days yet but all right under
construction like the web developing
from micro Python it's very early days
there's only really a few people working
on this project at the moment it's not a
commercial project although we do have
some support I think I forgot to mention
before we had some support from micro
brick to get the the first stages of the
32 port out and previously support came
from a Kickstarter campaign that was
really successful for
in getting the original version out but
we can't do the development of this
thing all alone we really want other
people to contribute and that's a large
part of the reason why I wanted to come
down today and talk to everyone it was
to try and suck you all into doing pull
requests and making a contribution it
doesn't have to be just pull requests so
even if it's just oh I wish it could do
this file a bug it's actually really
helpful it's actually a really useful
contribution to file bugs and to say I
wish it did this I wish it did that have
you seen this feature of the ESP IDF I'd
really love it if micro paithan can
support that filing bug starring bugs
adding comments making suggestions all
of those things are really really
valuable too and if you go oh I've got
this thing and I changed this thing and
I don't know if I can I can't really
pull request that that's embarrassing
whatever it's not perfect just just PR
at anyway please if if you have any
concerns about my code isn't perfect
enough to be a pull request see the
previous presentation about impostor
syndrome and so on and so forth it's
it's just just do it we will welcome all
things we will give you feedback we're
absolutely welcoming to people giving it
a go and worst case scenario is it turns
out it's not very good but it still
indicates that someone really cares and
we can then work with you and improve it
so those are the currently open bugs
there aren't very many of them which
doesn't mean there aren't many bugs it
just means that not many people have
filed bugs all right there are bugs like
doesn't support ipv6 which are obviously
a much bigger thing than themselves all
right so what's in the repo who's
checked out the repo for this thing in
the time it took me to do this talk you
excellent excellent
the first thing I did when I went I want
to work on this ESP 32 Porter's check
out the repo look at this file directory
listing and go oh what the hell what is
all this stuff and why is it all here
it's all jumbled in together and it is
so jumbled in there is a bunch of
documentation examples tests things like
that there's just highlighted days
that's all good stuff have a read
etcetera etc but we can sort across them
mentally off our map of the code now
Shin so there's also some directories
here which are shared between the ports
things like drivers and libraries and X
months their modules that are across the
different ports so not specific to one
port of the code they they're shared by
things Empire Cross for example compiles
Python down to Python byte codes and
it's used by all of them and then
there's these other directories are
individual ports individual platforms
that Marco Pathan runs on the one we're
most interested in in the moment is ASP
32 it's the newest one which is cool and
if we look in there we can see that it
also has a little layout of files
there's a readme file which is cool in a
make file which is cool and you really
do just do make and make deploy and it
will compile hopefully and there's also
these mysterious looking files called
mod something now before I did I had my
little demo and I said import machine
machine dot pin 5 and then you know so
on and so forth
machine is a library a python library a
python module it comes from somewhere it
didn't just get invented it comes from
in fact this modern machine up here
modern machine is a piece of C code that
implements the functions required to
make Python know what the platform can
do so I just thought I'd run through a
quick example of a really really the
simplest possible function in microplace
and to show you how the micro Python
runtime wraps up that ESP IDF function
and turns it into a Python function you
can call from the Python runtime so this
is just an example the ESP module here
is a bunch of ESP specific stuff so
specific to the just ESP platform it
includes a function and that module
which is called flash size which is
rather boring but it just tells you the
size of the chip so is on the size of
the flash chip that is on your
particular module which is a kind of a
handy thing tonight and you can call it
like a Python function there and it'll
turn a return a number this is is this
many bytes long
it's very very simple but it's a great
place to start simple and work your way
up to things that take varargs and God
knows what so where does this thing come
from well that's the ESP IDF function
declaration which tells you a few
amusing things such as my description of
it before was completely wrong it
actually tells you how big you said the
flash was when you compile the thing but
it basically says this is a function the
C function takes no parameters and
returns a size T returns a size to say
how big the flash chip is that's the ESP
IDF function as a C programming you just
call that directly it gives you a number
that's great as a Python programmer how
do we how do we tell Python about this
so the answer is we wrap it up we have
to wrap it up in a Python binding and so
we're just walking through that process
here so in that model SP you have this
declaration I've sort of cut and pasted
little bits out of these files to give
you the idea so we're pulling in that
header that says this is this is where
that function is declared and we're
wrapping this thing up here and it says
first of all well there's the function
we're calling right and then we're
wrapping that function up in this MP
irbs you in from you int what that's
doing is it's saying wrap me up a you
int C type into a Python integer type
right that's literally all that function
does it makes an micro Python object in
micro pythons little brain which is just
a C structure that represents that one
INT and then we declare a little
function that returns that object it
says okay this is a function that
returns a Python object now and so we've
wrapped up our int into a Python C into
a Python in and we return that how do we
call this function from Python we can't
call this function this is a C function
not a Python function you have to wrap
that as well so we're gonna wrap that
function up and turn the function now
into a pilot we wrapped the int into a
Python here now we're gonna wrap the
function that returning IND into a
Python function and that's what this
thing here does it's got a great elegant
name called MP defined Const
or 0 which to unpack it a little bit
just means micro Python define this
thing as a constant function it's not a
function we get a change
make it into an object it takes zero
parameters this is like the simplest
possible case so there are many more of
these that handle varargs and handle
multiple parameters and things like that
and we say take that see function there
that flash size function and wrap it
into a flash size function object which
is a micro path an object I think we're
starting to see a little bit of a
pattern here of course
how does microfiber know where to find
that Python function object it doesn't
know where that is it doesn't know what
that is so we have to wrap that up again
so what we do is we say well that's a
function object in it you're familiar
with anonymous functions in Python like
lambda functions and things like that
right there are nonnamous functions you
don't know what they are the only way
you can talk to them is to have a
variable pointing at them so let's have
a variable pointing at them this thing
here declares a table that says this
name points to this function right so we
say this is our flash size name now all
this nonsense about MP wrong Kuester or
MP kuester or flash size is literally
it's interning a string so it's saying
we have a name flash underscore size we
want to be able to talk about that name
really efficiently from C and who here
is used to seeing strings C is so good
with strings um so we in turn the
strings so that we don't have to deal
with them we don't have to stir comfort
them every time we want to compare to
them mister we in turn them into an int
that C is very good at dealing with and
that's what that stuff's about honestly
just cargo cult this stuff if you want
to contribute to this code and you go I
don't understand this stuff at all I
just cut and paste this from other
functions and we're good yeah that
worked ok that's cool that's how it
works
and so we say all right the name flash
sighs now points to that function object
we had before right so we now have a
name pointing at a function object it's
in a little table of course that table
isn't a Python table it's a sea table
and we're getting a pattern there so we
wrapped the table up into a Python
dictionary which is what this thing here
does NP defined constant here is a
dictionary I promise I won't change it
here's what goes in it wrap it up for me
and now finally finally finally we
declare a module and we say this module
has a base and it has that dictionary is
its Global's right it's these are the
symbols that exports and that is pretty
much all the code you need to implement
a simple simple zero argument function
in my code Python
except for you've just got to tell the
make file that sorry the config file
here to include that module in your
build and you got to tell the make file
where to go find it that's it that's
that's literally all the code that's
involved so if you wanted to sit down
and write a function for the Hall effect
sensor it would look pretty much like
that it would say take the the you know
somewhere in Maadi SP write a function
that says take a reading from the whole
sensor wrap that reading up into a place
an object now wrap the function that
generated that up into a Python function
now put that into the symbol table now
return that so even though a lot of this
stuff probably seems like nonsense if
you look at the code you can actually
see that it follows a pattern and it's
actually quite an easy pattern to sort
of just e to write on and add things and
add things and add things and then
eventually we might actually be able to
support the whole idea of like a Python
so back to the Python side of it now
when you see this where it says import
ESP you know what that's really doing
what that's really doing is pulling in
that global symbol table we declared
before when we do adder VSP we're
iterating over that symbol tables hangs
showing me all the symbols I put in that
list of symbols when we call a function
we're saying get me the value of that
function now call that function when I
call that function it calls the see
function right when I called the Python
function it calls or see function inside
the see function returns a Seend to see
and get wrapped into a Python and the PI
thing comes back to you we get to print
its value on the screen that's pretty
cool all right so there are lots of
resources out there there's the the main
repo which you can go to to look at to
to see where the things are at being
github we've got active github issues
we've got all of that sort of stuff
happening as I say please please PLEASE
contribute to issues - bugs - whatever
including if it's just I
we really wish micro Python supported
the hall sensor even if you go I wish it
did but next presentation has left me no
more confident that I could make that
happen then file an issue because it may
have left someone else here more confirm
that they can make that happen and they
may fix it for you which would be great
and that's just resources for the SP 32
all right thank you very much if
questions and comments</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>