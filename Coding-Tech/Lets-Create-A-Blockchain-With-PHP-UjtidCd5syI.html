<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Let's Create A Blockchain With PHP | Coder Coacher - Coaching Coders</title><meta content="Let's Create A Blockchain With PHP - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Let's Create A Blockchain With PHP</b></h2><h5 class="post__date">2018-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UjtidCd5syI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so a warning before starting to
talk about the blockchain so as I said
before I won't talk about the philosophy
I won't talk about I SEOs you know
expressions like to the moon or whatever
I won't even recommend you to invest in
any cryptocurrencies or alko you know
whatever
I'm not into speculation anyway so it's
not that interesting to me but as a
developer I'm I like to understand the
concepts and technologies technologies
behind new trends so the thing is I want
to know if a blockchain can be useful to
solve some problems that I might have
for my projects is it something that is
useful what kind of problems does it
solve why does it work that's the kind
of questions I'm interested in so mostly
from a technical standpoint and of
course it looks like the blockchain is
going to solve all the problems of the
world right almost all of them there are
so many new projects out there with a
blob change somewhere so it looks like
we've just discovered a magical
technology magic wand that would you
know solve any problems out there and
it's it you know it sounds like a dish
of you a few years back it was all about
no sequel databases for instance they
would solve all the problems right how
many of you are still using no sequel
databases MongoDB for instance okay so
it does not solve all problems
obviously so having something that can
solve anything
it makes me skeptical I would say so I
want to understand why people are so
excited about the blockchain and I want
to be able to realize for myself if it's
something interesting or not if it would
be a good fit or not and of course you
should always use the right tool for
what you are doing and before going
further I'm going to tell you why what
I'm thinking about blockchain and and my
take on that the concepts as you will
see are quite easily understandable they
are quite simple and powerful really but
there were the blockchain was created to
solve a very specific use case and if
you do have that specific use case then
a blockchain is probably something you
might want to use but the reality is
that almost no projects need a
blockchain and boring and you know
proven technologies are almost always
better than using a blockchain so if you
are interesting in finding ways to use a
blockchain I won't tell you anything
about that because and I've I have no
idea why it would be useful outside of
the main use case
okay now let's talk about digital money
because of course blockchain is or a
blockchain or blockchains
I don't know how to say that blockchain
seems kind of weird I would say it's all
started in 1989 with GT cash it was the
very first digital money and it I think
it went bankrupt ten years after that so
in 1998 20 years ago
it was kind of interesting as an
experiment of course nobody was you know
it was not useful because it was not
really accepted anywhere I think one
u.s. bank actually supported this
digital money but that was all but it
was interesting at least for something
because the day the company disappeared
the money was gone as well right which
is kind of not that great so more
recently Bitcoin and I suppose all of
you are aware of what bitcoin is yeah
more or less
that's a speculation tool basically
right that's a digital money coins and
the the white paper was published ten
years ago in 2008 and basically the
bitcoin is not about something as really
new or different from what we had before
but it is really just about a few things
put together and it makes the Bitcoin
system really powerful so the first one
is identity and we're going to talk
about that decentralized network and
consensus and the last one is the most
important one I highly recommend you to
actually read the white paper it's only
eight page long so it's reach out it's
really easy to understand what's going
on in the paper and hopefully after the
talk is going to be even more easier to
understand okay so the first step here
is I want to create a digital money
really quickly so that we can understand
what we're talking about so I'm going to
switch to some code now so that's my
take on digital money in PHP so it's
it's quite short basically we're going
to use HTTP and we are going to store
the state
of the balances in a file so this file
is going to include all the balances of
users of the system so if it doesn't if
it does not exist yet we create we
initialize the database with one user me
and let's say that I have a million fat
coin right so the money is actually the
fat coin okay so now what what we can do
three different things the first one is
we can get a balance for user we can
create new users and by default they
have zero of that coin of course and
then we can transfer money from someone
to someone else and we give the amount
and of course if the amount is more than
what you have you can transfer the money
that makes sense right
and then we do some math operations here
and and we save into dependencies so
basically we have one central server my
laptop here and you can call some HTTP
method to do things so let's try that so
first let me use the PHP building server
sure is it better yeah so first let's
have a look at balance for me so I have
no coins really oh sorry
so for user Fabian so I have a bunch of
coins let's create a user so we're gonna
submit a form
who wants some fat points okay what's
your name John like this like this okay
okay how many coins do you have now zero
do you want some okay fair enough let's
do that transfers some of my coins so
from me to you how many do you want -
okay okay
here you go you have two coins we do
have some money right cool can you see
some problems anyone hmm
no II story okay that's fair no history
yeah exactly
centroid server and that's a problem why
yeah sure and I can shut it down right
or the government can shut it down and
trust why trust you can trust me right
okay yeah uh-huh
yeah exactly yeah sure
Alkesh sorry so there are a bunch of
problems I'm going to recap all the
problems anyway because you almost got
all of them so the first one is so I
think the first problem is that there is
no blockchains
it's not interesting no blockchains
that's the very first problem the second
one is of course availability if I
should done my server no coins anymore
and we can cannot transact anymore so I
cannot send currents and nobody can
actually use the money anymore that's a
problem the authentication of course
because I can steal your currents really
easily
there is no authentication we could add
some kind of you know passwords or
something like that that could work and
security of course because if someone is
able to hack my laptop server whatever
then you can steal some money you can
print new money if he wants to that's
also a problem and trust you cannot
trust me
really I would not trust me you know
it's so easy to actually abuse that
power really easily so the first thing I
want to talk about is how we can
actually fixed fix availability so we
don't want a single point of failure we
don't want one central server we don't
want a central bank actually so
decentralization is one way to do that
and that's what was missing with DT
cache they add a central server and we
will understand why in a bit which means
that when they shut down all the servers
the money was gone so what we want is we
want a web of servers so many servers
that are participating in a network and
we want to do that in a resilient way we
we want to be able to join all
if the network without an impact on the
network so we need at least one server
of course if we shut down the last
server it's gone but if we have at least
one server the network can leave so to
do that we need also a protocol so that
the servers can actually talk to each
others right so that we can transfer the
money we can create users and we have a
shared state between all the servers we
can't use a client-server protocol of
course because it means a server central
server so what we want is for instance a
gossip protocol so a gossip protocol is
when everybody can talk to each other
basically which means that nobody is
actually controlling the network
everybody talks to each other and that's
how we can decide the state of the
system and instead of having one
computer or one cluster of servers
having the state everybody has all the
information about the system that's how
it works so to get started you don't
have you know one address you need to
know at least one node on the network to
be able to connect and then we propagate
the information so I'm going to connect
to John and John knows about Larry and
Larry is going to give me his node
address and we are going to communicate
like that right so we can discover the
topology of the network quite easily
like that ok so to understand the gossip
protocol we're going to forget about the
money for for a minute and I'm going to
take another example let's say that we
want to share our best session at Drupal
con right man is about I don't know a
session about tweet and John as
you like the session about Symphony
right yes of course
but you can change your mind so let's
say that you know quite randomly at some
point you need you decide that you don't
like the symphony session that merchants
and the session about Drupal 10 was much
more interesting so and we want to
propagate that information on the
network okay okay so the thing is every
few seconds I'm going to send to talk
through all the nodes I know I'm aware
of sending my state and in return you're
going to first update your state and
send me back your state and that's how
I'm going to be aware of what's going on
in the network and as you can imagine it
can take time to actually propagate the
information right before I knew about
the best session from some guys over
there it's going to take time to
propagate in the room so that I get the
information that I can also update my
own state so let's see how we can do
that in PHP ok so we have a state that's
where I'm going to store all the
information about the sessions that we
learned so the first thing is when we
create the server I need to know my port
that's the address where you can join me
contact me actually and then I need also
a pure port and that's one node in
system so that we can connect to each
other so the very first one we don't add
the pure pot of course because we need
to put strap the network and then we
have a loop here and we are continuously
checking all the ports that we are aware
of so at first that's only one pot and
we are contacting the node sending our
state so the state is
a simple array with the username the
session and version why do we need a
version here let's say that John said
that his best session was about Symphony
but then two seconds later he decide
that is not sinful anymore it's twig but
he can say twig to me he said symphony
to Larry and then Larry said Oh John
said that symphony is the best session
and now I have two pieces of information
the first one is you like tweet it was
true 10 minutes ago it's not anymore and
Larry told me that now it's symphony so
I need to decide the order of the
messages right so if you had a version
then if twig is version 1 and symphonies
version 2 I know that Candace go tweet
version 1 and the current best session
for you is symphony so that's why we
need a version here so we are sending
all the information about all the notes
we are aware of to all the nodes we talk
to via HTTP in return the Pierce and the
state that he has locally and we update
our state based on that information so
how do we do that so update is about
getting all the states so for each port
the data that they have it that's my
port you won't be able to update my data
so just ignore that and then so here
this is just to check that the data is
valid actually and then if I know
nothing about you then I'm going to
trust the data that you are sending to
me and if I already have something I
only updating data if the version is
more than what I already have in my
state right ok and after doing that with
all the nodes randomly or not really
randomly at least yeah randomly I'm
going to update the best session that's
all there is to it really
let's see how that works so here I have
different sessions I'm going to make it
a bit bigger okay so oh I also have a
script here it takes a user and based on
this user environment variable we create
a small PHP built-in server and we try
to find an available port so that people
can connect to us okay so here I'm
saying the user is Fabian and I'm
running the cost protocol like this
really okay so as you can see now I'm
only aware of my own best session and
you can see that front from randomly I'm
updating the session I like the most to
join a network I need to create another
user Alan for instance and I give it a
peer there is a new one
Fabian and I'm going to run the CAHSEE
protocol as well and you can see that
data they are starting to talk to each
other right so and you can see that they
at some point they reach a consensus and
they add the exact same information but
that's not always the case
because it takes time for the
information to propagate over the
network and we can create another one
Tomas is going to connect to Ellen so
this node knows nothing about the first
node but just because we are propagating
the information at some point is going
to be aware of all the nodes as you can
see everybody is talking to each other
now updating the position over time so
that's the cost you protocol which means
that I can kill any node it does not
matter
she works I can join again and I'm going
to catch up really quickly right okay so
that the gossip protocol okay so we have
achieved something very important which
is for turns I can you know a server can
go down it doesn't matter anyone can
join and leave and join again that's not
a problem but there is a problem here
someone can lie okay if you tell me that
Larry best session is twig and you put a
version number that is really high I'm
going to trust you but actually Larry
doesn't like twig that match so how can
we fix that the problem here is that we
don't have the notion of an identity
right so we need to fix that and the
problem with the gossip protocol and the
fact that the state is shared amongst us
we cannot have password I cannot send
you the password my password that would
not make sense so we need something else
and something else is cryptographic
identities or a public key and a private
key basically the public key is the
equivalent of a username so you can give
it to all the peers all the nodes in the
network that doesn't matter and the
private key is the equivalent of the
password so that's a secret you never
you should never ever share the password
the private key but the big difference
between a username and password and
public key and private key is that the
public key and the private key are
actually connected they are related
right there is a link between the public
key and the private key you can't change
the private key without change
the public right so your identity on the
network is made of your public key and
private key you keep the private key
private or secret and you can give the
public key to anyone and the great thing
about the public key is that it says
nothing about you right there is no tag
attached to that so it's not Larry it's
not John's not Nicholas not Thomas it's
just a random series of bits really so
the thing is with the private key what
you can do is you can sign messages you
can encrypt messages and that's the key
here when someone sends an information
message is sign it signs the message
with is private key and me and it can
also attach is public key and then with
the public key I can check that the
message actually comes from the person
who actually owns the public key which
means that now the messages cannot be
forged any more right because if you
don't have my private key you can't fake
a message with my public key even if you
do have the public key right so let's
see how that works I think it's going to
be much clearer with an example okay so
I'm going to use PHP again using open
SSL for doing the work so the first
function hi I have here is a generate
key pair method and basically we are
using open SSL to create that and we
return the private key and the public
key let's write that and then I have to
three more methods the first one is an
cryptic message so we give it a message
which is basically a string we give it a
private key we are using open SSL to
encrypt the message we get back the
encrypted message and we are using
base64 encode because you know when you
encrypt something you get back random
random bits so if
want to print that we need to convert
that to something that is more readable
and base64 encode does the work if we
have the public key and an encrypted
message we can decrypt the message and
validating the message is as simple as
UF the message in clear and we don't
care about the fact that the message is
in clear here we have the encrypted
message and we decrypt the message and
it's the same as the origin message we
know that this is valid right so here in
the example let's do it like this first
so I'm going to create a key pair of
public and private key keys I have a
message and a Drupal and I'm going to
encrypt the message with the private key
so here what you can see is the
encrypted version of the ello Drupal
message if I know your public key I can
decrypt the message back and you can see
that it's hello world but more
interesting is that you can also check
if it is valid valid means that I know
that the message was actually encrypted
with the private key related to the
public key right and that's what I'm
interested in here okay so next step so
we so that's the way we can be sure that
you can't lie about your best or
favorite session but the problem now is
that I can send I'm going to reduce Bob
and Alice it's going to be better I'm
going to send Bob a message encrypted
message that twig is my favorite session
so you can check that I've actually sent
a message and I'm going to send two
sent another information like symphony
to Alice so Bob and Alice they can check
that I am the one who actually sent the
message but the messages are different
for sessions at DrupalCon that's not
really a problem but if we are using
money now that's a problem let's say I
have a coin and the coin is actually
message and I sent according to Bob and
I want to send to send the same coin to
Alice as well both of them they will be
able to check that I am the owner of the
coin I have signed a message but I have
actually spent the same coin twice
that's a problem right so we need to be
able to solve that problem and that's
the hardest problem to solve for
cryptocurrencies and that's where
Bitcoin actually solved the problem
quite elegantly okay so and so the thing
is and of course I've sent the coins the
coin twice and I got back something in
return
write a book or whatever a car whatever
the thing is now Alice wants to spend
the coin again to buy something else and
that this punch is going to realize that
the coin actually belongs to Bob right
and there is nothing she can do so the
thing is if at some point Bob and Alice
if they were able to talk together they
would have realized that the coin was
actually sent twice right and that's
only possible if they had waited a lot
of time just waiting is enough remember
with the gossip protocol and network it
takes time for the information to
actually go from one node to all the
network right so if they can wait
enough they would have both the
information that the coin spent twice
right so in a peer-to-peer network can
we solve what we call the double span
issue the first one the first
possibility is coordination exactly what
I've just talked about coordination is
we wait enough so that we have all the
same state and when we have all the same
state we can know that there is a
problem
in the network and then we can resolve
and a problem so basically we want to
know if I sent the coin to Alice first
or to Bob first if it is a least then
the Bob transaction can be discarded and
just over
okay so coordination how can we do that
the solution of Bitcoin is what we call
proof of work so we need to wait for the
information to propagate or put another
way we need to slow things down we don't
want to have things going too fast so
instead of being able say okay I've sent
you the coin transaction done we need to
wait we need to slow things down so to
do that we're going to use what we call
proof of work and the idea is that when
you send a message you need to actually
do some computational work you need to
do some work with UCP your CPU and a CPU
can resolve math problems so we give you
a math problem to resolve but before to
talk about that I'm going to show you
something it's going to be much easier
to understand afterwards after that
let's say that I have my message again
hello world hello Drupal and we are
going to use a hash function a hash
function is something that takes an
input gives you an output for the same
input you are always going to have the
same output and the great thing about
hash functions is that if you change
slightly the input the output tolerate
different and you can't go back if you
have the output you can't go back to the
input right so let's see how that works
so in PHP you can use the hash function
and I'm going to create a hash for the
message okay that's a hash right random
bits really if I slightly change the
message here you can see that all the
bits are different and there is no way I
can go back to the string first because
we can't uncurl all the information even
if the string is really really really
known the ash is always the same size
right so you can't it's not encryption
it's really just a hash and whenever I'm
going you give me the same input you're
going to have the same app as you can
see computing a hash is really fast so
that's not enough so the problem to
solve here is can you find something to
add at the end here so that the ash
starts with a certain number of zeros so
let's say that I want one zero at first
so I can try it with I don't know a does
that work that doesn't work B does that
work that doesn't work see okay I can do
that all day long right so it's it's
something that is intensive CPU
intensive because you need to try a lot
of different possibilities to actually
find a solution so that that's the
puzzle that is behind the Bitcoin mining
process process actually so here we want
to find unknowns unknowns it's really
just a random string for a message
so the nonce here is an integer we are
iterating and adding one for each loop
until we find a valley notes and Valley
knowns is just
hache studying with a10 for instance
they try that so okay and I need to
print the ash to be sure that it worked
okay so we needed 25 iterations to get
one 0 at the beginning of the ash now if
I'm adding more zeros its exponential so
if I say I want 4 zeros it's going to
take much more time right and if I want
five of them and if I want six of them
it's not going to work it's going to
take a lot of time right
that's the complexity of the puzzle and
in the Bitcoin protocol the complexity
is automatically adjusted depending on
the number of nodes in the network right
we're going to talk about that a bit
later so that's the proof of work very
simple one you give me a message I want
to slow things down so you need to prove
that you spend some cpu time to actually
compute the ash because you know you
have you need to have X zeroes at the
beginning of the ash string okay so
that's what is called mining in the
Bitcoin protocol just because you know
you are doing some work to get some gold
or bitcoins but that that's not that's
not enough I can still send the same
message even if I spend a lot of time
doing the mining I can still send pub
and L is the exact same message and I
can also sign the message so what is
missing here is the order of the
transactions I want to know that I did L
is before Bob and I want to be sure that
when I know that Alice was first and Bob
after I don't want someone to be able to
say it's Bob first and then else so I
don't want someone to be able to change
the order as in fact so to do that we
need a blockchain
at last that's the problem we want to
solve with a blockchain so a blockchain
so a block is the message you want to
send someone to the network plus the ash
we've just talked about hash so the ash
is actually computed with the
proof-of-work algorithm so it takes time
to compute and then we also have the
previous ash of the previous block right
so when I'm I'm computing the hash for
block number two I'm going to find a
hash that is made of the message plus
the previous hash right which means that
after I have added block 2 I know for
sure that block 1 is before block 2
because I have this relationship between
block 1 and 2 yeah is it clear enough so
we cannot check out the blocks anymore
if we shuffle the blocks it's not valid
anymore
the hash is not going to be varied
anymore because the previous one is not
to be it's not going to be the right one
and basically that's a block chain a
block chain is a linked list with ashes
nothing more it does nothing it solves
no problems whatsoever
and know a blockchain is not a database
it's not a distributed database because
remember all the nodes on the network
they have the state the entire state the
history right so that's very different
from a database actually sorry ok but
still it's not enough the blockchain
like I've just talked about it's not
enough to have all the things that we
wanted for our fab coin cryptocurrencies
because what I can do is well first
perhaps we can have a look at how to
implement a blockchain let's see how we
can do that ok so I have my
proof-of-work class this is exactly the
same as before I have a blog a blog is a
message and the previous block right in
the block I'm going to keep the previous
ash of the previous block the message
and I'm going to mine at block that's
where I'm going to spend some CPU time
and here I want to find announce for the
message plus the previous ash of the
previous block which means that if I
want to replace the block I need to redo
the work of all the blocks after the
block I want to mine and then I'm going
to store the nones I'm going to start
hash something very important I need to
add is valid method so that I can check
that the block is valid and the block is
valid if the nonce actually has enough
zero for the message that I want to
encode ok now the blockchain is an array
in PHP of blocks pretty simple when we
create a new block chain we initialize
it with one message and no previous
block and then we when we want to add a
message to the blockchain we
create a new block with a message and a
previous block that's where the Manning
is actually happening and again I want
to validate my blockchain so at some
point with the gossip protocol we are
going to send our blockchain all over
the place so when I receive a blockchain
from a node I want to be sure that the
blockchain is actually dealt how and
doing that is really easy I'm iterating
over all the blocks I'm checking if the
block is actually valid if that's not
the case the blockchain is not valid and
then I want to check that the previews
ash Dupree of the previous block is
actually the same as the previous ash of
the current block if that's the case
then the blockchain is valid right
so here I've created a small block chain
with the Genesis block then I'm adding
two more blocks and I'm printing the
blockchain and trying to see if the
blockchain is valid so if we ran that
you can see that I have the first block
no previous hash you have the nones you
have the message the ash with four zeros
here then we have a second block you can
see that previous ash is actually the
ash of the previous block and then we
compute the ash with knowns and so on
right so that's a blockchain
now if I want to shuffle the block so
here I'm trying to move the first and
the second block it's false the
blockchain is not valid anymore because
you know the previous ash is not the
right one so now we have a blockchain
where when we want to add a transaction
I have sent a coin to Bob I need to add
that information into the blockchain I'm
going to do some work and then when I'm
doing the same with Ellie's I need to
compute the same thing again but if you
think about it you can probably fork the
blockchain right for block now
- I can compute two different nodes very
easily and send the nodes in a network
so we still have a problem with the
double spend issue we can steal double
spin the coin so we are not there yet so
we need something more to make it work
the way we need and the way we can do
that is and now you're going to
understand why we need to spend CPU time
to actually mined blocks the way it
works is that if there is a someone
wants to AK the blockchain so it's going
to fork the blockchain and adding some
force information right but the network
we are transacting all the time so we
are adding blocks all the time many new
blocks all the time so if someone wants
to fork at some point we need to decide
with which chain is actually the right
one and the rule is very simple always
take the longest chain and that makes
sense the longest chain is the chain
where the most work happened which means
that if someone wants to form the
blockchain he needs to have more CPU
power than everybody else so he needs to
control more than 50 percent of the
computation computational power of the
network which should not be possible or
at least it was what you know we thought
about but right now that's not the case
anymore because you can't mine Bitcoin
anymore in your laptop you name specific
ad work which means that only a few I
think it's something like 15 different
Chinese companies they are more than 80
percent of the power in the network
and if they can get together and having
enough power more than 50% of the power
then they can change the blockchain the
way they want just because of their
longest chain rule and that's why in the
Bitcoin world you need to wait and the
recommendation is to wait for at least
six blocks six new blocks after the
block where your transaction is Hin to
be sure that the transaction is final
because we think that after six blocks
the CPU time needed to actually fork the
the blockchain or change a node and then
we compute all the blocks after that is
almost impossible but that's just you
know it's not about warranty it's just a
probabilistic guarantee right okay I
think we have all we need to actually
create our cryptocurrency in PHP now
that's the final piece of code the block
is almost the same as before
the main difference now is that we don't
have message we have a transaction and a
transaction is a from so who is going to
send money that's the public key of the
sender then we have the public key of
the receiver the amount of money and the
private key of the sender and as you can
see we do not store the private key the
private key is only used to when we
create a transaction to actually create
a signature and the signature is the
encryption of the message and the
message is the concatenation of from to
an amount and we are storing also the
information about who is sending money
to okay and then we want to be able to
check if a transaction is valid it is
valid if there is
no from that's the first transaction
when we create the money and then it's
valid if the signature is actually valid
that's where we are checking with the
signature that everything is fine so we
have the public key we have the
signature which is the encryption of the
message and the origin message okay so
going back to block so a block is a
transaction and the previous block like
before and create Genesis is where you
create the very first block and the
first transaction is from nobody to the
creator of the blockchain with a given
amount of money and we have the private
key and the mining algorithm is exactly
the same as before and it's valid method
is we need that the transaction is valid
first but we also need that the proof of
work is actually doing the right things
so the nonce is actually a direct one
with the number of zeros then we have
the blockchain the blockchain is again
just a list of blocks I think is the
same we are adding a transaction instead
of message and then and that's the most
important thing here we need to be sure
that the blockchain is valid so for each
block we check that the block is valid
and that the previous block hash is
actually the previous hash of the
current block and we also need to check
that the spans are valid we don't want
someone to go under zero of course to do
that and remember we are only storing
transactions we do not have balances
anywhere so we need to compute that we
are computing the balances here and when
we check if everything is okay
if there is one amount that is less than
zero then the blockchain is not valid
and when I'm going to send you a
blockchain like that you're going to
refuse that because it's not valid and
there is no way you can forge that
because of the encryption and the keys
and now we need to communicate together
so there is again the same Gossip
protocol
and basically we are going still to
communicate with the peers we are
sending to the peer our state so the
state is really okay so the state is
really just the blockchain and the peers
we are working with that's all so we are
going to gossip with our peers they are
going to send their state and we are
going to update our state based on their
state and that's the most interesting
part here how we choose that how can we
do that so first if we do have a
blockchain we are going to update our
blockchain if we do not have a
blockchain then we are going to accept
the blockchain from the peer that's when
we actually create a node for the first
time and blockchain the update method
here the first one is the longest rule
here so if the pure block chain is as
less nodes than ours which is got it
right we only consider longer chains
then we validate the blockchain if it's
not valid we just don't do anything and
then really simply if it is longer and
valid then we accept it right and just
because of everything we've just talked
about we can be sure that all the
information in the blockchain is
actually valid okay let's do some
demonstration here one fab going okay so
the user that's me again and here I have
a script which is exactly this crib is
exactly the same as before we have a
user and we have a peer to connect to
and we have a PHP web so web server here
and then this is the service doing the
gossip protocol okay so I've just
started the network so I have a
febc Owens here and you can see the
blockchain at the bottom of the screen
let's make it bigger okay so I just have
one transaction and you can see here
that I have four zeros for the ash let's
create another node connecting the first
one they start gossiping together as you
can see and let's start as a one okay so
we have three different nodes in the
network and then I want to transfer some
money from Fabian to Ellen for instance
and you can see that it propagates on
the network and you can check that the
blockchain is actually valid you can see
all the transactions and we compute the
balances at the top of the stream now if
I try to send a lot of money to my wife
money I don't have that won't work
because the blockchain is not valid so
nobody's going to accept my blockchain
even if it is longer it's not valid so
we don't care and if there is a double
span at some point if there is a fork
and it happens all the time on the
Bitcoin blockchain at some point
eventually one is going to be longer
than the other one so we are going to
reach a consensus just by waiting and
that's why time is very important in the
Bitcoin protocol that's why the claim
that you know sending bitcoins is much
faster than sending transferring money
from a bank that doesn't work because in
the protocol there is this notion that
we need to slow things down to reach a
consensus that's something very
important and of course I can you know
go down and I can run again and it's
going to do the right thing okay so it
was a very quick introduction to
cryptocurrencies and blockchain we have
not talked about everything he
they're just about the core concepts but
hopefully you better understand how that
works and how it works behind the scenes
there really didn't Bitcoin is a bit
different for instance in a blog you
have more than one transaction of course
we haven't talked about fees or rewards
because of course a minor is doing some
work because as a reward if not that's
not that interesting we have not talked
about things like replay protection for
instance mirko trees like clients
because of course on my phone I don't
have to have all the information of the
blockchain so there's there's more than
that but hopefully you have a better
understanding now and you can read the
white paper it's quite quite interesting
in the template for Drupal con there is
a slide where you need to put a quote so
that's a quote for me whatever and and
of course if you are into
cryptocurrencies and if you want to
create a cryptic cryptocurrency then a
blockchain Mac make sense
oh I haven't talked also about a theory
on so the possibility to have a virtual
machine embed into the blockchain which
is yet something else but yeah that's
another story I think I'm running out of
time here so thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>