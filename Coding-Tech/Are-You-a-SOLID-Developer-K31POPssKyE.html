<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Are You a SOLID Developer? | Coder Coacher - Coaching Coders</title><meta content="Are You a SOLID Developer? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Are You a SOLID Developer?</b></h2><h5 class="post__date">2017-10-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/K31POPssKyE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon everybody my name is
Gareth Ellis and I'm a developer at the
in the language services group at a
company called icon I'm also the lead
organizer of the PHP Oxford user group
so if you're ever in the Oxford area on
the last Wednesday of the month we'd
love to see you there so I'm going to
talk to you this afternoon about the
solid principles and I created this talk
because I felt that it was content that
I couldn't find when I was a relative
novice to object-oriented programming so
the talk is pitched those of you who
have maybe heard of the solid principles
and know vaguely what they are at a high
level but you're unsure of how you can
actually apply them practically in your
day to day and to those people who've
never come across the solid principles
at all
the solid principles are five guidelines
for object-oriented design they were
first formulated in the late 90s under
the name the first five principles by a
developer called Robert Martin who some
of you may know may know as Uncle Bob
and then in the early 2000s another
developer called Michael feathers came
up with this acronym solid that we use
today to describe these principles
together and the idea is that when you
apply all of the solid principles
together to your code it will result in
code which is easier to maintain easier
to read easier to extend and easier to
reason about so what does reason about
me because I think when I first heard
that phrase I just assumed it meant
understand but I think it's subtly
different from understanding code that
we can understand this code that we can
look at we might have to ask a colleague
to help explain what it does we might
have to go and read documentation and
after those steps we might arrive at
understanding the code or as code that's
easy to reason about is code that you
can just look at you can just understand
it because it's self-explanatory it's
clear and I think that's a really
worthwhile goal of any code that we
write solid principles are about
object-oriented programming in general
they're not about PHP
we need to bear this in mind when we
interpret the wording of these
guidelines when you're trying to apply
solid to your work the goal is not
adherence to the goals themselves
there's no gold star this achievement
doesn't exist as software developers we
should all know that every decision we
make has a trade-off or trade-offs
plural and we need to be aware of what
those trade-offs are at every point and
you may come across the occasions when
the trade-off for not applying solid to
your work is worth it it's up to us to
know those trade-offs them to be able to
make informed decisions for our use
cases you will find that writing solid
code means you are writing more code . i
think this is okay because as developers
we spend way more time reading code than
we do writing i think we can all relate
to the idea of working on a problem
writing code and mean right in the
headspace of that problem right in that
context having all the information
around us and we write code then we come
back to it a week later and we look at
it and we gable i'm not really sure what
i was doing there
that doesn't make sense to me and that's
because we've optimized for writing
we've optimized for saving a few
keystrokes instead of making sure that
our code is easy to read and easy to
reason about so on with the five
principles and the first of them as you
may guess is the s and that is the
single responsibility principle or SRP
SRP states that a class should have a
single well-defined
purpose or more specifically it has one
reason to change so what's a reason to
change well in my opinion a reason to
change is something which can possibly
drive a change somewhere in your code so
for example if you have a class which
deals with talking to the database the
only reason for that class to change
would be if you change something about
the way you're talking to the database
so you're going to change a query for
example classes shouldn't get ideas
above their station the good rule of
thumb is that you could try to define
the purpose for your
in a single sentence without using the
word and or or and if you can't do that
your class might be doing too much in my
experience and certainly an experience
of applications that I have written in
the past controllers in MVC applications
tend to be quite big violators of this
principle so here's some code I've
completely made up for the purposes of
this talk but hopefully it will seem
familiar to some of you have worked on
applications of this type fairly common
function for a lot of applications is to
have a method for users to register so
here we have a user registration
controller has a method cook register
and we're passing in a request and a
response object so what's the
controller's reason to change
controller's concern should only really
be with control flow it's called a
controller for a reason the job of the
controller is to take the request and
return a response and that might involve
talking to the domain or the model or
whatever you want to call it in between
but it's very easy to stuff business
logic into our controllers and make them
bloated so in this example we've got a
user that we're creating from requests
data for making an entity we're then
going to save it in the database in the
controller so we've got some SQL in the
middle of our controller we're then
going to send a welcome email to the
user saying hey thanks for registering
and then we're going to return a
response so this controller has got
several reasons to change right here
because it's dealing with logic to do
with the database dealing with logic do
sending emails and it's got to do its
job as a controller as well it's the
first step to refactoring this would be
to move that logic into a separate class
so you could call this a service class
if you like I've named it user
registration here and what we're going
to use this for is that instead of
stuffing that logic into the controller
the controller will talk to this service
class so the controller knows I am a
controller method that is used when a
user registers I'm going to take the
user I'm going to pass it to the service
class and now I don't care what happens
after that it's none of my business I'm
a controller so the service class will
then deal with what needs to happen next
so here we've got the dependencies in
the constructor for the database
dependency and the email dependency
and we're assigning them to class
properties and then in the register
method of the service class which the
method that the controller will call we
can call those same methods from the
controller now we can still do a little
bit to improve this because all we've
done at the minute is copy and paste
code from one class to another this
class has more than one reason to change
because it's got logic to do with saving
in the database sending emails so we
could refactor that further and we could
move the logic to do with saving to the
database to a separate class called user
registration storage for example and the
email logic into another class called
user registration welcome email and once
again we assign those two class
properties and then we can call those in
the register method so now this class
has fewer responsibilities we could
improve this further using for example
the observer pattern and there's
something I'm going to briefly touch
upon in the next section because the OU
in solid stands for the open and closed
principle open and close States that
software entities which we can think of
as classes should be open for extension
but closed for modification that is we
need to be able to change the behavior
of a class without editing its source
code or you should need to cut your
chest open just to put on a different
coat closed for modification does not
mean we should never ever change source
code I think our jobs would be pretty
difficult if that's what it meant but
just as a little example how many people
here have had a class which is doing its
job working hasn't got any bugs that you
know of and you have to change the
functionality of it in some way you have
to change its behavior so you make a
change and then you introduce a bug we
hand up yeah quite a lot of people and
some liars
so changing code is a really common
entry point for defects so if we can
design upfront for extension design
upfront to anticipate ways in which we
might need to use our code in the future
we can hopefully avoid having to make
source code changes and avoid the
likelihood of introducing bugs on the
other hand there's always the chance
that you ain't gonna need it so the
trade-off here is how do we work out
what in what ways our classes might need
to be used in the future and that takes
experience it takes practice and you
just need to kind of get an inkling and
a and a feeling for in what ways you
might need to change things going
forward so it's a fine balance between
not writing too much code and closing
yourself off to future future extension
so open/close States the classes should
be open for extension and what does that
mean when I first read this as a PHP
developer I immediately thought
extension that derives from the word
extends which is a key word in PHP it's
what we use to create a subclass so I
thought well okay that just means we
need to be able to extend classes it's
inheritance right open for extension
means inheritance but solid isn't about
PHP PHP does have the keyword extends
PHP has inheritance but there are some
object oriented languages that don't for
example golang I believe doesn't have
the classic inheritance model that PHP
does it has alternative ways you can get
similar behavior but it doesn't have
that same approach built in PHP itself
has the final key word and when you
prefix final on to a class definition
nobody can extend that class you can't
subclass it so the truth is that
inheritance is just one tool available
to us for ensuring our classes are open
to extension and like all tools we need
to know what strengths and weaknesses
they have inheritance has its uses I'm
not going to stand here and tell you I
don't use it because I do but you have
to know your tools like I say
but in general we should trying to favor
composition over inheritance composition
is one of the fundamental building
blocks of object-oriented design it's
the idea that we can abstract things
which vary between components of our
applications and compose them into
separate units or classes so I've got an
example fear of how composition might be
better than inheritance in a certain
situation I've adapted this example from
a really great book called head first
design patterns got a link to it at the
end of my slide if you are not familiar
with design patterns and you want to
learn more about it I really really
recommend this book it's a fantastic
read so let's say we're working on a
duck simulator app everyone likes ducks
right
so in this simulator app we're gonna
have a screen and it's gonna have ducks
flying around on it and doing things
that Ducks do like quacking and swimming
and you know duck things so if we were
to approach this using inheritance we
might do something like this we might
have an abstract class called duck which
has methods swim quack and fly and in
those methods we're going to have the
logic concerned with actually performing
those behaviors so we don't have a real
code here because it's not real
application but hopefully you can use
your imagination and then we can add
different types of duck to our
application by extending the abstract
class so you can have a mallard and an
Ida and a Mandarin and so on this works
great doesn't it because all ducks quack
fly and swim then the boss says we need
to put a rubber duck into our
application oh say we extend our duck
abstract class ducks rubber ducks don't
swim and just kind of float bomb on the
water so we have to override the parent
method there let it quack either they
squeak when you squeeze them so again we
have to override that parent method and
they don't fly they didn't have anything
you could describe as flying unless
throwing it across the room could be
called flying and of course they have an
additional behavior because they can
help us debug our code so we're finding
ourselves having to override every
method from our parent class which is a
bit of a sign that something's wrong
with our design
now this might not be a big problem in
this specific example where we've only
got four types but as we scale our
application we're going to run into
problems maintaining this so said let's
say we have to also add a wooden toy
duck to our application this can have
some Sarila similarities with a rubber
duck because it doesn't swim
it doesn't quack it doesn't make any
noise at all in fact and it doesn't fly
so again we're overriding message from
the parent class we're having to
duplicate code we're going to run into
problems scaling this because we're
gonna have behavior code spread about
different classes and it's gonna get
messy so if we were to approach this
problem using composition we might do
something like this
let's say we create interfaces called
swimming with a method swim quacking
with a method quack and flying with a
method fly we're going to encapsulate
the thing which varies between the ducks
which is the way that they perform these
behaviors and we're going to compose
those behaviors into their own classes
these interfaces will not be implemented
by the duck classes they will be
implemented by classes which whose job
whose single responsibility is to
perform those behaviors by doing this we
also make our ducks more compliant with
single responsibility principle because
the duck classes are no longer concerned
with how they fly swim or quack so we
might implement this something like this
we've got the interface quacking for
example we'll have a quacking duck
behavior which the regular ducks can use
they'll make a normal crack noise we'll
have a mute duck for the wooden duck and
we're gonna have a squeaking duck for
the rubber duck and then it might look
something like this so we've got the
Eider duck class whose constructor would
look something like this and if you look
in the constructor here we can see we've
got type prints on those behavior
interfaces swimming quacking and flying
so we inject in instances of those
behaviors assign them to class
properties and then in the methods the
swim quack and fly methods on the duck
class we just delegate to those
behaviors so what does this have to do
with the open and close principle our
duck classes are now open to extension
because these tight pants in the
constructor here are interfaces so we
can pass in alternative behaviors if we
want and change the way that this duck
behaves now Ida ducks are a particular
favorite of mine because they have a
really cool mating noise kind of sounds
like this let's say some users of our
application want either ducks instead of
quacking to make the noise that I can't
believe I just made onstage in front of
a couple hundred people we might create
a class called ooh which implements our
quacking interface and it would take
care of the logic of making that
ridiculous sound and then we can inject
that into the I deduct class by passing
it in in the constructor so we've
changed its behavior without having to
change its source code it's open for
extension and that approach is a pattern
which is known as the strategy pattern
very common pattern you'll come across
very powerful way of changing behaviors
by passing in different implementations
of interfaces another way that we can
keep our classes open - extension is to
use something called the decorator
pattern I like to think of the decorator
pattern is a bit like sandwiches I like
sandwiches the decorator pattern is a
rewind slowly imagine you go into a shop
like press-on male or Tesco or somewhere
where they sell prepackaged sandwiches
and you take one out of the fridge
you take it home that clock that
sandwich is closed for modification
effectively because if you want to
change the sandwich as so you bought
chicken and mayonnaise and you don't
like mayonnaise you better open the
sandwich you've got to scrape the
mayonnaise off the bread it's not going
to be very good as it whereas if you go
to somewhere like Subway they have this
kind of production line process you go
up and you'd say I'd like wheat bread
roll with chicken in it please and then
they pass it along their production line
and at each stage of that production
line you can choose whether you want to
decorate your sandwich with salad or
sauce or cheese or whatever it might be
so Subway sandwiches are effectively
open for extension and they you don't
have to like send go all the way back to
the start and start again if you decide
that you want man
in your sandwich so that's the decorator
pattern effectively I've got a real
example for you but is anyone in here
done any implementing of PS r7
middleware in something like slim or
symphony or something like that okay
well if you've done that that's the
decorator pattern effectively this idea
of passing in request and response
objects down a chain the middleware
stack and operating on those objects and
when you get to the other end of the
chain those objects will have changed
they would have been decorated so here
is a real example adapted from something
we did at work so one of our
applications had to integrate with a
third party API and that API uses OAuth
2 for its authentication so every time
we hit an API endpoint to request some
data or post something or whatever we're
doing we have to send a valid a wolf to
a to token tokens from this API were
valid for 48 hours and we were going to
be making multiple requests to this API
every day so to us it didn't make sense
to just request a new token every time
we were going to hit the API we could
store an existing token for 48 hours and
reuse it so we realized we could achieve
this using the decorator pattern so the
first key step to a decorator pattern is
having some common interface that your
classes can implement and that you can
change together so in this case it was
called access token repository and it
has a single method called get which
returns an access token so this will
represent somewhere where a client code
can call this get method and get an
access token object back that's its
contract so we then made a class called
API repository and this will be a class
that we use to get a new access token
from the API so in the constructor of
this class we pass in an instance of a
class called provider which came from
the PHP League of Extraordinary packages
o auth to client really great library if
you want to work with OAuth 2 by the way
we assign that to a class property and
then the get method we can just delegate
to that provider class and call the
access token because we know that that
will give us an access taken object now
if we want to store that token we could
of course go back and change this and
put storage logic into that code but for
a start that's not making our code it's
not going to be very flexible if we ever
want to take the storage logic out we've
got to change its source code so it
would be open for modification we'd also
be adding additional responsibilities
this class is really simple because all
it cares about is getting a token from
the API we shouldn't be adding
additional responsibilities to it so
according to the decorator approach we
make a new implementation of our access
token repository interface so here it's
called storage repository and this will
represent somewhere where we can we can
get an access token from a store of some
kind whether that's a database or file
system or Redis or whatever you like and
in its constructor it has two
dependencies one is token storage which
is another interface we created I don't
have it on the slides but hopefully you
can imagine what it might look like and
that will just be something which will
represent talking that that will deal
with you know talking to whatever store
you're using so if you're using a
database that would be that would
contain PDO and some queries or whatever
and then the other dependency you can
see on the second line of the
constructor signature is another
instance of access token repository and
the eagle-eyed of you will notice that
access token repository in the
constructor signature is the same type
as in the implement statement at the top
of the class so what this means is we
can ask the storage repository to get us
a token from its store we can check
whether it's valid or not and if it's
not valid we can call that other
repository instance we passed in as a
fallback method so at our case we're
saying check the database for a storage
for check the database for a token and
if we don't have one we're going to call
the next decorator which in our case
will just be the API repository and in
this case after we've called it we've
got the taken back the storage
dependency can then save the token in
our database again so that next time we
hits it it'll be there and valid and
then we can return it
the important point to note is that this
in this instance of access taken
repository that we pass in could be any
implementation we like so if we want to
add additional decorators to our chain
we can do that so here's what the usage
of that code would look like we have to
instantiate a few different things and
wire things together this is an example
of solid meaning having to write a bit
of code or a solid tends to put the
burden on the calling code and this is
an example of that we've got to set up
all the dependencies and then what I
think is really nice and really simple
is that the client code okay it does
have to deal with wiring together these
dependencies but then it can just call
one method and it gets a token back and
it doesn't need to know anything about
what's happening underneath that it
doesn't know that there's any decorator
pattern involved there it doesn't know
that it's whether it's getting a token
from storage or from the API
it doesn't care it doesn't need to know
so if we wanted to add an additional
decorator here let's say if we wanted to
log every time we were hitting the API
to request an access token we could add
a new implementation of our repository
and sandwich that in between the
different layers of our decorator setup
final pattern I want to briefly mention
I don't have time unfortunately to go
into any detail on this is the observer
pattern and this is another way you can
keep your classes open for extension if
we think back to that controller example
where we refactored out into a service
class we could make that class more open
to extension by using the observer
pattern all I can say is this is a
really interesting and useful pattern if
you've ever used frameworks events
subsystems they tend to use a version of
the observer pattern and there's some
really great articles out there that you
can go away and read I would recommend
that there's a good section in that book
as well that I mentioned before
so Ron to the L of solid which is the
Liskov substitution principle Liskov
substitution principle was formulated by
a woman called Barbara Liskov she was
quite an awesome lady she was the first
woman in the u.s. really on his right to
get a doctorate in computer science and
her principle states that objects in a
program should be replaceable with
instances of their subtypes without
altering the correctness of that program
or if s is a subtype of T then objects
of type T in a program may be replaced
with objects of type s without altering
the desirable properties of that program
everything seems to come back to ducks
so when I read that wording and I see
things like correctness desirable
properties assess to me it's all about
behavior so here's an example of a
Liskov substitution breach this comes
from Uncle Bob himself he wrote an
article about LSP which is really
interesting I won't unpretending and it
all it's quite academic in places but
it's very interesting read anyway
so let's suppose we have an application
which deals with geometric shapes and we
have a class called rectangle which is
going to represent a rectangle and a
rectangle has a height in a width and we
need to be able to set and get those
this isn't a very good class is
completely mutable and so on but let's
just ignore that for this example we
then have a function called transform
which again I'm not really sure why it
would exist in real world but here we go
just serves it serves the purpose of
this example and when you pass in a
rectangle to this function it's going to
change the height of the rectangle to 10
so we'd instantiate a rectangle give it
a height and width and we'd call our
transform method transform function the
idea would be that if we check the
height and the width of the rectangle
after we've called transform the height
will have changed
the width will have stayed the same that
is the desirable property of the
rectangle class right transform function
when it calls set height it doesn't
expect anything to happen to the width
so let's say in our application as well
as a rectangle we also need have a
square now squares in mathematics in
geometry are in arguably a type of
rectangle so we should be able to just
subclass a rectangle right create a
square like that so let's do that let's
see what that looks like so here's our
square class now squares the fundamental
property of a square is that its height
and width are always the same so we can
get rid of the height and width
properties from rectangle and replace it
with a single height and width property
we then have to override the setters and
the getters to deal with the different
property once again as with the duck
example before the fact that we're
overriding all of those methods is a
sign that there's something wrong with
our design but here's the problem when
we pass in a square to the rectangle to
the transform function which PHP will
allow us to do because our rectangle
type in here will allow us to pass in a
subtype like Square and it's call set
height the height would have changed but
so will the width so from the point of
view of the consumer of the rectangle
type which is our transform function
this is performing undesirable things
unexpected things who's heard of a
concept called design by contract
few of you okay really interesting topic
it's worthy of many talks by itself but
there's a good Wikipedia article if you
want to get an overview on this there's
also a couple of rfcs in discussion at
the minute I think for adding native
designed by contract features to PHP
which could be interesting and in his
article anyway in his article Uncle Bob
talks about a strong correlation between
LSP between let's go substitution
principle and designed by contract
one of the things that designed by
contract talks about is the idea of
preconditions and postconditions so if
we could have a look at what that might
look like for our rectangle class the
precondition of our set height method
could be for example there is a
rectangle and it has a given height and
width the post condition of the set
height method what we would expect to be
the case after we've called it would be
the height of the rectangle has changed
but the width has not so this is a
useful approach for assessing the
substitutability of subclasses we can
come up with these pre and post
conditions and we can write tests to
assert whether we are meeting those
conditions in general I think the square
and rectangle example is another
illustration of the problems that can be
introduced by inheritance I would go
back to the point I made before about
favoring composition and I think LSP
pushes us towards composition away from
inheritance
the I in solid stands for interface
segregation principle an interface
segregation principle or ISP states that
many clients specific interfaces are
better than one general purpose
interface no client should be forced to
depend on methods it doesn't use you can
think of it as breaking down larger
interfaces into smaller ones small and
more specific ones Uncle Bob first
formulated ISP when he was contracting
at Xerox in the late 90s Xerox obviously
make these big corporate printers and
photocopiers you know all-in-one type
things and the software that was running
on these had this concept of jobs he had
a print job and a tan a copy job a fax
job etc and apparently these software
had one big interface called job which
has you know print method a copy method
that sort of thing it was he was big and
every time they wanted to make changes
to their software it was getting harder
and harder because they had this tight
dependency on this class which wasn't
the sorriest type which wasn't specific
enough for their use case
so before I go into an example I'd also
like to mention another talk
specifically about isp obviously in a
talk about all of the solid principles i
can only talk for so long about each
individual one there's a guy called dan
aykroyd who did a really good talk about
this at PHP Northwest last year videos
not online yet but the slides are so
I've got a link to those and obviously
he goes into a bit more depth than than
I can about this in this time so here's
an example of isp at work literally at
work this is adapted from something real
we did so the end of last year we were
working on an application which had
pages which had lists of things on it so
we had things like lists of users lists
of clients list of projects that kind of
and some of these pages were going to be
you know they can be lot loads and loads
and loads of items hundreds of items so
users needed a way to filter those lists
and find what was actually interesting
to them what they needed to use so we
had to include various search options at
the top of each page so we had types
like drop-down so if we wanted to search
for projects for a certain client we
have a select box with the client names
in them free text so if we wanted to
search by project name we'd have a free
text field and date ranges so they
wanted to find projects created within a
certain date range they'd be a couple of
date pickers that they could use so we
decided the way that we could implement
this would be to use our friend the
decorator pattern and the composite
pattern and we created this interface
called filter and the idea would be that
each of those types of filter date range
free text drop-down etc would have its
own implementation of this interface and
we'd additionally have a collection
class which would bundle all of the
filters together so they could be used
together so this interface has a method
called build query from which has to two
dependencies one which is a request
which is CakePHP s HTTP request object
and the idea would be that when a user
filled in the form it would submit it
and the data there to post it would be
populated in the query string and we
could grab their search data from the
query string so request the request
object in cage PHP cakephp has a query
method so we can just grab what's coming
from the query string using that query
method the other dependency is slightly
confusingly called query this is a
different kind of query this comes from
cakephp 0rm so this is a database query
and the idea would be that for each
filter we can look at what the user is
actually searched for and decide whether
we need to adjust our database query
accordingly so here's what the filter
collection would look like we have a
method add where we can add filters in
and then in the build query from
implementation we can loop over each of
those filters that we've added
we can decorate the query object by
passing it in along with the request
each filter will operate it on in turn
and eventually we'll get back a query
object which will have all the right
wear conditions and joins or whatever we
need to do the search for what the user
has searched for so here's an example of
an implementation of an individual
filter class this one's the free text so
we pass in the table alias and the field
name say for example blog posts table
and we're searching on the field title
we'd pass in blog posts and title and
then in the build query Fromme method
first of all we have to check does does
this field exist in the query string so
if request query this field name we're
basically saying query string do you
have the field that we're interested in
which an example is gave would be title
so we'll be saying does the query string
have a key title and if so what's the
value if it does have it then we'll be
able to decorate the query object by
changing the wear conditions so here
we're just adding a like condition for
our SQL and then finally we're going to
return the query back so the next part
of the chain can decorate the query and
so on so the usage is really simple
really neat this is what it looks like
just add our new free text into the
collection like that but then we hit a
bug after we deployed and the bug was
what if the user searches for 0 we had a
very specific use case where a user was
searching 0 and it was valid now because
we this is our if statement obviously
PHP will evaluate a string of 0 as false
so this conditional check failed and the
search wasn't working so essentially
what we needed to do is change this so
instead of just saying to the query you
know full C is this true C or false see
we have to more specifically ask it does
this key exist ie is it null and if it
does exist
does it have does it have a value does
it or is it just an empty string
so we started changing all of our filter
classes to have something that looked
like this and as I was doing this I just
thought to myself that this doesn't feel
right this feels pretty grotty and the
reason for that is that this is a leaky
abstraction our filter classes shouldn't
know anything about the way that CakePHP
requests class deals with the concept of
keys existing in the query string and
this all boils down to the fact that our
filter class has a dependency on the
request object and that is not specific
enough a type for our use case so the
way that we approach this and fixed it
was we created a new interface called
search parameters and we changed the
signature of the filters to depend on
the search parameters interface instead
and as you can see the search parameters
type search parameters interface has two
methods has which returns a bool and
value which returns the value of the
thing in the query string if it's there
we can still use cakephp request objects
we can still use the query string but
instead we can now wrap that up inside
this search parameters implementation so
here's what that would look like we
inject the request object in the
constructor or house method wraps up
that slightly grotty logic about the
implementation details of CakePHP
handling of query strings so now that's
hidden away we don't have to worry about
it and then we have a value method which
just returns from the query method as we
were doing before
the revised filters look like this this
reads so much better so much more nicely
than either the previous two versions
which directly depended on the request
object it reads like plain English
doesn't it this is something we strive
for it in our work is to try and write
code which reads as much like plain
English as we can so instead of dealing
with the internals of CakePHP it's now
just dealing with a nice interface which
is very specific to what it needs to do
benefits here of adhering to interface
segregation our classes are more loosely
coupled we've given our filter classes
one less reason to change because it's
no longer concerned with internal
implementation details of the framework
and our filter class itself has moved
towards being open to extension because
it's dependent on a very specific
interface so if we want to change the
way that we are sending in those search
parameters let's say we want to use post
instead of a query string or we want to
use JSON data on an API call or even if
we want to make a command-line tool we
can just create new implementations of
our interface as PHP developers I think
it's easy for us to read the definition
of the interface segregation principle
and think of an interface like this one
right an interface is a thing in PHP
it's an abstract type it's a way of
providing a contract for our classes but
Ruby for example is an object-oriented
language fully object-oriented
everything in the language in Ruby is an
object a string is just an object which
has methods you can call arrays boolean
is the same but Ruby being more
object-oriented than PHP doesn't have
interfaces it doesn't have this so how
would a ruby developer interpret isp if
they don't have a thing called
interfaces and the truth is that all
classes have an interface even if they
don't explicitly implement one so if we
go back to the IDA class from earlier
I'm not going to make the noise they end
up
you can see that the top there there's
no implements keyword it's not
explicitly implementing an interface but
it does have an interface and its
interfaces just it's public methods and
their signature which would look
something like this so this interface
doesn't exist but you can you know it's
kind of an abstract idea it's out there
so we can take this idea and it leads
really nicely into a point that Dan made
in his talk which is the ISP in for PHP
developers in particular isn't really
about interfaces but it's about types
and somebody's up really well with a
slide that looked a little like that so
let's quickly review what types are
Wikipedia helpfully tells us that a type
is a classification of data which tells
the compiler how the programmer intends
to use the data so in PHP we've got
complex types and we have scalar types
now I've slightly adapted that division
because I think it fits this example
more nicely so I'm going to say PHP has
objects and it has everything else so in
PHP we have two types of object really
we have abstract types and we have
contract concrete types so abstract
would be interfaces and abstract classes
and concrete's are anything that you can
put the new keyword in front of and
actually instantiate an instance of so
we've seen examples of interfaces like
filter abstract classes like duck
various concrete classes throughout this
talk and free text for example is a
class which is of type free text but
it's also a subtype of filter so it is a
type filter as well so in the other
column in PHP we have scalars and arrays
arrays are technically in the complex
type category which is why I've had to
adapt this slightly and I think there's
some others that aren't on the list
there that I've missed out but hopefully
you get the general point in PHP we have
objects which have methods that we can
call and then we have other types in
other languages like Ruby that I
mentioned and Scala for example they are
fully object-oriented languages so
everything in the language is an object
that you can instantiate and then call
methods on
and strings Bulls insert cetera so if we
were programming in Scala for example we
had a class which was dependent on an
array or a class which returned an array
as a result of one of its methods it
wouldn't be returning an array like we
think of it in PHP is this giant bucket
that we can throw anything into it would
be returning an object of type array
with methods so if we go back to the
point I made before the interface
segregation is about type specificity
space hardware same type specificity
then we can say well if we're depending
on an array an array has an interface
because it's a class and all classes
have interfaces we need to ask ourselves
is the interface of the class array
specific enough for our use case
that's what ISP is all about so we don't
have that luxury in PHP we don't have
these super amazing objects for
everything but we can still apply that
logic and erase as I said that's there
just this big bucket in PHP there this
Swiss Army knife of programming that we
can use and abuse to do whatever we want
and I would contend that maybe we
shouldn't do that sometimes so it's
quite a common pattern to see arrays
used for holding configuration values or
options so this is adapted from another
real example we did at work and we had a
date picker method on our form helper
and the job of this method would be to
render a date picker on a form right
pretty straightforward functionality
pretty common functionality and we had
two arguments to the method one which
was called field name it should just be
the field name in the HTML and then
options which would allow us to
configure on-the-fly things like the CSS
classes or whether it's a required field
or not change the text label that sort
of thing problem with doing it like this
is that in the class itself in there in
the method body we've got a half code
like this to check each option we've got
to check whether the
he exists in the array or not and then
we've got to check the actual value of
it doesn't read very nicely it's pretty
boring to type it's also pretty prone to
errors particularly from the point of
view of the calling code so here in this
example in the calling code I've
deliberately misspelled is required
field when I run that code I'm not gonna
get any error message so the only time
I'm going to realize it's not working is
when I notice that the codes not doing
what I want and then I've got to start
debugging and trying to work out why and
trying to spot this kind of thing is a
massive pain as I'm sure you are aware
we've also got no Auto completion
support I'm a pretty lazy coder I really
lean on my IDE and it's also a
completion support so I always want to
have it wherever I can so instead of
using an array we could use an object
could use a class so we made a class
called date picker options and then we
can define each of the options we want
in that class so for example is required
field which will default to false and
then we can turn that to true and false
using set required field and we have a
getter method called is required field
which just returns the value of it so
we're doing it like this we add some
constraints to our options as well
because now this can only be a boolean
whereas before someone if they wanted to
you could assign anything they like into
that array but now it has to be a
boolean because we've got type in
support likewise for the label which is
a string we can add additional
validation to it because we've got a
setter method so if some bizarre reason
we wanted to make sure that our label
was no longer than 25 characters we can
do that and we get autocomplete support
ray so this is what the revised version
would look like we pass in a date picker
options instance instead of the array
the method body now looks much nicer
it's easy to read easier to reason about
you can look at that line if options is
require field and you know exactly what
it means you don't have to try and parse
array type of stuff to work it out and
our calling code looks nicer as well
it's more declarative it's more is
easier to to understand it's it's
expressive code
we can apply that logic to other
primitive types as well this isn't
technically connected to ISP but I think
it's quite a nice little tip it's quite
common to see functions or method call
method signatures which have loss of
billions for enabling or disabling
certain things this is adapted from
something I've seen in the wild so let's
say this function is a factory a factory
for an instance of connection and you're
gonna call it and it will give you a
connection
the problem here is that when we call
the code we've then got this horrendous
line of brilliance when you go and look
at that code in a week after you've
forgotten what each of those mean you're
going to look at that and go of course
right it's yeah it's starting to connect
with the true false true right and it's
not so bad here because we've got the
function definition right above the
function call but in reality you're not
gonna have that so this is really hard
to reason about this code so sometimes
you know you might be working with a
third party library which has a front
you know a method function signature
like that and there's nothing you can
actually do to improve it but what you
can do is you can wrap around it you can
you can adapt so you could approach this
problem using the Builder pattern so if
we created a classical Connection
Factory and we pass in whatever we need
as dependencies and then we have methods
called enable persist and disable
persist and those are just going to
toggle the persist value between true
and false their setters effectively but
we haven't used the word set and the
method name because it reads nicer and
each of those methods you'll notice will
return an instance of the same class
because we can then use fluent method
chaining or making nice readable code
now there are other options in that
function signature that we had on the
previous screen we've got persist enable
awesomeness disable flux capacitor have
enough to fit them all on this screen
but you have to imagine that they're
there as well they've got our property
and then they've got enable and
sable methods as well now the most
important part of this class is this
function at the bottom that get
connections that's the part that wraps
that original connect with those nasty
boolean x' which are so hard to read so
we can wrap that function call in this
method and we're hiding the
implementation detail of those boolean
x' inside this class so now our calling
class instead of calling the function
can create a connection factory use its
fluent interface call the methods and
set whatever things we want to do and
then call get connection this is many
many times nicer to read and easier to
reason about than the function call but
yet we had to write more code which as I
said is something you find you have to
do more of on your writing better code
so the final solid principle and the D
is dependency inversion defense the
inversion principle states that we
should depend on abstractions not
concretions who has heard of dependency
injection get quite a lot of hands
dependency inversion though the
dependency inversion principle is what
we're trying to address when we use
dependency injection so when we say a
class depends on abstractions not
concretions we're talking about a
class's dependencies the things it needs
to get its job done we've seen several
examples of dependencies throughout this
talk and here's one of them so here's
the Eider class going back to it again
all comes back to ducks it seems and
this time I have adapted to the
constructor and I have removed the type
hints and the arguments from its
signature so instead of passing in its
dependencies we're going to instantiate
them in place so we're assigning our
behavior classes swimming duck quacking
duck and flying duck to properties by
using new so this class is now dependent
on concretions because they are
if you like concrete it in place we want
to change the behaviors we have to
change the source code right which as
we've seen in open/closed is something
we want to try and avoid so we can adapt
it and change it back to something like
this we're in the constructor we're
passing in arguments we've got type
hints and then we're assigning to
properties inside the constructor body
but what I want to note here is that in
this example we've got swimming duck
quacking duck and flying duck as the
type heads those are not the interfaces
we created earlier those are the
concrete classes those are things which
can be instantiated with new and indeed
we saw that on the previous slide but
this class is now dependent on
abstractions even though it's dependent
on concrete classes because from the
point of view of this class it doesn't
know what swimming duck of quacking duck
and flying duck it doesn't know that
they're concrete classes or whether
they're interfaces it just knows that
they are types with methods that it can
depend on so if we want to change you
know swimming duck into an interface for
example at a later time we can do that
and we don't have to change this class
so dependency injection and dependent on
managing dependency inversion principle
is not necessarily about using
interfaces like I said we could change
those concrete classes to be
abstractions to be abstract classes or
interfaces if we want to - in the future
but the point is that choice is now ours
it's not hardwired into that other class
because it's dependent on abstract
concepts I think we've seen plenty of
good examples in this talk of the value
encoding to interfaces but di does not
mean you always have to do it as always
evaluate the pros and cons of each
approach and make the appropriate choice
for your use case dependency inversion
is not necessarily about objects either
go back to my examples of rouille Ruby
and Scala as languages which are fully
object-oriented
you could have a class which depends on
strings or bullying's or whatever and in
those languages if they're still
depending on objects just in PHP they're
not they're not objects they're scalars
so let's have an example we have a class
called MySQL connection Factory and in
the constructor we have the username and
password for connecting to the database
these are concrete strings this class is
dependent on concretions because we
can't change those strings without
modifying the class it's in breach of
OCP and it's in breach of dependency
inversion a change of credentials
requires a change in the source code so
just like using dependency injection for
objects we can inject strings in from
the outside as well and it has what this
would look like we just changed the
constructor to pass in the values in the
outside and now it's up to us where we
store those values we can put them
wherever we want we can put them in a
settings file we could put them in
environment variables it's up to us I
said before that solid tends to put more
burden on to the calling code and I
think this is a good a good example of
that so you can see like the bad version
where we're not using dependency
injection and we're dependent on
concretions it's two words and a
semicolon but with dependency injection
we're having to do more we're having to
wire stuff together we're going to
instantiate things and hook everything
up this is where a dependency injection
container can help you so there's
several examples of DIY containers in
PHP they include pimple or in PHP di Zen
service manager there's loads of others
if you want to know more about those I
would recommend going and reading their
documentation they're very powerful
tools di containers the trade-off of
using them in my experience is that it
can make your code flow a little harder
to follow a little hard to reason about
because you take the logic of wiring
things together and you put it somewhere
else that you've then got to go
if you want to kind of work out and
debug what's going on it's I think
simplification through obfuscation and
it's a little bit like tidying your
house by throwing everything into the
cupboard under the stairs you just moved
the burden somewhere else
so di C di containers are really useful
tool for managing dependency injection
but you don't have to use one to do
dependency injection and you don't have
to use one to comply with the dependency
inversion principle either nearly there
you've got one more key note and then we
can go to the party so in summary here
are a few points that I ended up writing
down after doing the research and
writing this talk we spend more time
reading our code than writing and so we
should optimize for reading you keep our
classes small specialized and simple
because doing that means our classes are
easier to maintain easier to extend
easier to refactor we should favour
composition over inheritance but realize
that inheritance is a tool that has its
uses just like any other we should make
our types as specific as we can and use
arrays sparingly it's not just throw
arrays into everything we need to create
dependencies on the outside and pass
them in and use interfaces when they're
useful finally we need to always know
our trade-offs know our tools know the
pros and cons and be able to make the
right decisions for our use cases thank
you very much I've been Gareth Ellis
this is my first conference talk so I
really appreciate any feedback you can
leave on joined in I will tweet the
slides a little while which will have
all of these handy links in if you want
to go and read any more about it and
that is it
we've got time for one question anyone's
gone about solid or all the slides or
whatever
Wikipedia's got a good start solid and
then there's an article about each
individual principle and there's loads
of blog posts where people have written
their interpretations of the rules the
head first design patterns talks about
each design pattern quite a lot of me
says this will help you meet this
guideline and it references solid and
stuff so that's another really good
resource okay okay thank you very much
everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>