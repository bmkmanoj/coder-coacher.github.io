<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Toward A Better Front End Architecture: ELM | Coder Coacher - Coaching Coders</title><meta content="Toward A Better Front End Architecture: ELM - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Toward A Better Front End Architecture: ELM</b></h2><h5 class="post__date">2017-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aNour03V98E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right oh good afternoon everyone
thank you for joining me my name is
Jeremy Fairbank today we're going to
talk about Elm and was a functional
programming language that compiles to
JavaScript and it provides us a really
safe robust way to build our front-end
applications in a way that JavaScript
itself really can't provide so if your
shouldn't following me on they'll pop up
oh-yo on twitter and jay Fairbank on
github very briefly about me I work for
a company called C giant or a completely
remote team or does an agency focus on
design and front-end development and in
addition to be an agency we have our own
product called simply built which is a
website builder and editor along with
domain management hosting so front-end
development has been going under being
undergoing a big boom over the past
several years and that's largely in part
thanks to native web technologies and
advances in the JavaScript engines but
with that as brought a host of problems
as well probably the most notable of
which is JavaScript the T so there are
countless frameworks and options
available these days to choose from and
it can be kind of intimidating but at
the same time the reason why there's so
many choices is because they're all
trying to hone in on what are the best
ways we can do front-end development and
make building applications as easy as
possible so at the very least through
their collected efforts we've kind of
honed in on that MVC two-way
data-binding structures just aren't
really working on the front end and they
can lead to a lot of issues and bugs in
our applications so they've kind of
migrated to this style of unidirectional
architectures Model View update pattern
and a lot of reusable components so not
big classes and controllers but really
small composable components but there's
one thing despite all their efforts they
haven't really fixed and it's kind of
hard to do with JavaScript the language
itself now I've used javascript for many
years I still love JavaScript and do a
lot of development in it but we can't
deny some of the problems that do
live in JavaScript one of the biggest
obviously is null or undefined is not a
function we've probably all fell prey to
these type of errors in all reference
errors and they are a real issue and
JavaScript even though we can write good
clean code that's still the potential
for something like this to happen if
we're not careful javascript is also
impure and mutable now we can write pure
code and we can use immutable data
structures but it's still possible in
the language and some of the biggest
problems that come from that or this
idea that this function get named for
example no matter how many times I
invoke it
I'm never guaranteed I will always get
back the stream name Jeremy that's cuz
it's global state that's mutable so we
lose some confidence in our functions in
JavaScript when we allow ourselves to
write some impure functions with mutable
state api's can be unsafe as well in
JavaScript so here I'm fetching a user
but what happens somewhere down the road
maybe that API payload changes the shape
changes of the user and maybe it's not
username anymore it's maybe user dot
display name or what if the whole
payload itself changes and user is
stuffed and maybe a data key well this
may not throw an error and we may not
find out there's a bug to later on maybe
in our view code when things aren't
displaying properly so we would have to
write a lot of runtime validation code
to make sure we always get the
particular payload that we expect error
handling can be a little cumbersome in
JavaScript as well so typically we would
throw an error but then we have to deal
with try catch blocks worried that maybe
some function from a third-party library
could throw and then that's going to
just interrupt the whole execution of
our program and then wrap the call stack
and in the asynchronous context what if
I leave out the catch callback on this
promise well if you know anything about
promises and errors it will inherently
swallow errors and you may not know
about them thankfully browsers are
adding some warnings when this happens
but it's still something not built in
the JavaScript to make sure we deal with
the potential for errors so we have to
do our due diligence
so is there anything we can do with all
these issues with JavaScript it's still
a great language like I said I love
using it but it has these problems or is
there a way we can address this some of
these issues and build safe robust web
applications and thankfully we can
because of Elma
so Elam as I mentioned it's a functional
programming language it compiles to
JavaScript and it's strong statically
typed and one of them we're gonna learn
from all these different benefits that
offers that we can now build
applications that we have a lot more
confidence in so from Elms guides it
says no runtime errors in practice no no
no undefined is not a function those are
very strong guarantees but they are very
promising if we can build applications
and no longer have to worry about these
types of issues so let's look at element
C what is the benefit it's really given
us if either distill it down to one
thing I would say confidence that I as a
developer can now have confidence or at
least more confidence in the
applications I build that if my
application compiles more than likely
it's correct and it's going to work
properly and I'm not going to have to
deal with weird type coercion bugs or
other things like that and we get that
because of the static typing the
expressive nature of Elm it's going to
inherently draw you to write smaller
functions and write cleaner more succeed
code that you can understand better and
have more productivity with it's also
terse which is kind of like that it's
pure it's immutable and it has that
unidirectional architecture that we
talked about earlier so let's start
diving into Elm syntax learning about
these benefits more and see how they
help raise our confidence level and the
applications we build so I mention Elm
is a functional programming language
and what that essentially means is it's
all built upon functions functions are
our basic building block and functions
are inherently modular reusable and
composable because they only depend upon
their arguments they don't worry about
global state so they are more you
full than just using classes and
mutating some state in an object so what
if functions look like a noun so we
typically define a function by giving
identifiers I have a greet function and
add function it takes a list of
arguments or parameters but notice we
separate them with whitespace we don't
use parentheses or commas so it's a lot
more terse and expressive and then we
just set the function equal to something
kind of like a variable so we're saying
it equal to a single expression there's
no concept of multiple statements and
then a returning keyword and elm so this
inherently forces us to want to write
smaller functions and so this is code
that's easier to read and understand
so our greet function it takes a name
and then it returns Hello name by the
concatenation operator our add function
adds two numbers together to invoke
these functions we do something similar
we have our identifier and then we pass
in the list of arguments and we use
whitespace there as well so very concise
syntax and just inside this double dash
here that's how you do inline comments
announce so you'll see that in some of
the code samples so next helm functions
are pure and we've already hinted at
that and that is my function only
depends upon its arguments it doesn't
depend on global mutable state and what
the benefit of that is it now gives me
guarantees about when I invoke my
function for my add function if I pass
in two and three to it I have a
guarantee because it's pure and it
depends only on its arguments I always
get back five now imagine that at a much
larger scale or you have an application
with lots of functions you have a
guarantee that whatever you pass into
that function you expect it to give back
a certain value every time that's such a
universal concept of functional program
we call it referential transparency
where it's this idea that I could
technically replace every instance of
where I call add with two three here
with just the number five and so this
gives us a lot of those guarantees by
being pure
we can take that concept even further
with HTTP requests so here at the top I
have an elm code sample for fetching a
user on bottom I have these JavaScript
example for fetching a user but the
difference is that bottom one in
JavaScript that is impure when I invoke
fetch user every invocation is going to
be different because I'm have I'm
affecting the outside world by
immediately creating my HTTP request and
dispatching it the elm code up top
though believe it or not that actually
doesn't dispatch an HTTP request all it
does is create a value it's a pure
function so it's just going to create
what we call a command and we'll learn
more about those as we dive into the
architecture of a Elm
but it's reproducible now no matter how
many times I call fetch user I get back
a command value that I expect so if I
wanted to test that function I could
test it a whole lot easier with the unit
tests than trying to test the function
in JavaScript typically we would need to
use a mock server or something like that
to deal with the JavaScript example
element is also declarative and that's
something that comes with functional
programming a declarative style where we
want to declare what the desired role
result is we're telling the computer
what we want back not how to do it so to
understand that let's compare it with
imperative style with this JavaScript
code we want to create a function that
doubles the numbers of an array so we're
going to use a for loop in this example
you probably already know about the map
function but in this case we're gonna
write it an imperative style well this
just doesn't exist in elm and it's a lot
more lines of code to write an
imperative style we're just giving a
bunch of instructions to the computer
it's not inherently describing what it's
really doing which is doubling some
numbers in Elm though we can very
succeed Lee described this idea of
doubling numbers so we have what are
called lists in Elm they're kind of like
arrays in JavaScript but they're
actually more like linked lists so
they're not something we can index into
but that's fine because we're typically
just wanting to iterate over lists
anyway so now when I want to double
numbers in Elm
I could define a simple function called
double it takes it in and it returns in
times two and then I can create the
double numbers function which takes a
list and in one line of code I can do
the same thing in a very expressive
manner I use this special list stop map
function that's in the Elm standard
library it takes two arguments a mapping
function and a list to apply that
mapping function to so it's just going
to apply the double function to every
item in the list and produce a new list
where every number is doubled but notice
how fewer lines of code it took and we
could write this in JavaScript with map
as well and I would definitely encourage
that because we can accomplish a lot
more with fewer lines of code and
typically we associate fewer lines of
code with fewer chance of bugs so this
is a huge benefit Elm functions are also
curried you maybe heard of currying and
it may seem a little weird or hard to
understand but one way I like to think
of it from a practical perspective it's
a way of creating building blocks it's a
way for us to just to find really small
focused functions and then we can build
more complex functions out of it so to
really understand that let's first just
get down the concept of currying so we
can see what it means so I could have
this new add function that takes XY and
Z or turns the sum of all those but
really I'm not taking three arguments
I'm taking one argument at a time and
returning a new function so what that's
happening if I invoke add with one two
and three really what happens is I take
add takes in one argument X it returns a
new function that now takes in the Y
once I invoke that with two I get back
another function that takes in the value
for Z once all of those arguments are
fulfilled then we can invoke the
expression the function body and get
back our result so a contrived way then
we could use this as a building block is
I could create an add one function just
from this add function I pass in one to
add I get back a new function and then
later on I can invoke that with two and
three
get back six or I could take that
further add three could be made from
invoking add one with two and that gives
me back a function that if essentially
in folks it's argument or adds three to
its argument and we could do that to get
back six
so let's as I emitted a very contrived
example but let's take it back to the
earlier thing we were doing with
doubling numbers we can actually reduce
the lines of code in this one through
currying so remember that all functions
are curried that means the lists top map
function we have is curried remember it
takes two arguments a mapping function
and a list well if I invoke lists that
map with double I get back a new
function that takes a list so
technically I could just remove that
parameter and I still have the same
function I've just filled in the mapping
function I'm waiting to get the list and
so it's the same way to describe it but
with fewer lines of code how could we
apply that same thing with the double
function crazy as it sounds we can now
this is going to look really weird
notice we're wrapping the multiplication
operator in parentheses well it turns
out even operators in LMR functions and
the way to think about that is your left
operand is the first argument and the
right operand is your second argument
and so when LM I can wrap an operator
with parentheses and get back a function
that I can invoke like any other
function and since it's a curried
function when I invoke it with two I'm
filling in the first left operand and
getting back a function that's waiting
on the second operand so actually I
could apply that concept to the double
numbers function and reduce it down to
just this so the point is we don't have
to write all these functions out I would
caution there are times when you may
want to be more document self
documenting and write certain functions
but we can accomplish a lot more with
just simple curried functions
and see how we can create the double
numbers with just one line or two lines
if you count the new line there now one
thing you might have thought of we do
everything with functions what happens
when we need to apply it multiple
functions to something so let's say here
I want to take a list I want to double
every number I want to filter it leaving
only those numbers greater than 6 and
then I want to square every number well
if we were to try to do that with the
syntax we've already learned it would be
really ugly looking and hard to read and
understand and that seems to go against
the things I'm talking about having a
very terse readable language we can use
a special operator for this called the
pipe operator to deal with this because
remember functions and expressions are
all just one expression for a function
body so we can introduce this operator
called the pipe operator or the forward
function application operator which is a
mouthful but it's basically a bar and a
greater than sign so you can think of it
similar to in a UNIX Show and how you
pipe from one function or command to
another so it's the same thing the
operand to the left is going to get
piped into the item on the right which
is going to be a function and it's going
to basically make it the last argument
to the function on the right and that's
possible because these functions are
curried so a better way to understand
that is let's just watch how it would
pipe through so we take lists we pipe it
down to this list stop map with the
double function and that's essentially
the same thing it's doing so on the
bottom we have equivalent code where we
create a doubled list in a similar
manner just without piping so now we
have this doubled list and we can pipe
it through to the filter and it may look
confusing in this manner but we're
actually going to filter those numbers
and leave only those greater than 6 so
when we wrap that less than symbol we're
filling in the left operand which means
we're looking for things that 6 is less
than and that's how it's actually going
to produce numbers greater than 6 so we
have filtered and now we pipe it through
to square and so that's how we use the
pipe operator to deal with this issue of
multiple functions being applied and
then it does
a unique way to make it very readable
this idea of just transforming something
in multiple steps
I mentioned that Elm is strong and
statically typed and so to elaborate on
that more and how it benefits us it's
this idea of creating and hearing to
contract so if you've done other
languages that have strong static types
you kind of know what I mean we can
describe what types our program takes on
and if it doesn't match then it doesn't
compile and so it cannot run so I hadn't
really showed that yet now because Ellen
can actually infer types pretty well but
it does strongly prefer if you provide
types so to define a type you have your
identifier you have colon and then you
have the type and then you give its
value so we have our normal integer
strings and boolean s-- and then for a
list we would say list int and obviously
that list can only have int values in it
when we say it's a list of int now to
type functions we're gonna introduce
arrows which is if you come from a
language that uses lambdas with arrows
that kind of makes sense why we would
use an arrow here but we're essentially
saying for greet it takes a string and
it returns a string and then add notice
it has two arrows here and that may be a
little confusing but remember these are
curried functions and so this can help
enforce that idea of we take one
argument at a time so I take an int and
I'm actually returning a function that
takes an int and that function finally
returns an int so the way to maybe make
that more readable as we could wrap that
last part in parentheses and we see int
returns a function that takes an int so
what's the benefit of typing though on
all this boilerplate well now if I try
to invoke the greet function with a
boolean or add it's even just a string
my code will not compile I can't even
run it so compare that to JavaScript
though if I accidentally pass in the
wrong number
arguments or the wrong types either it's
gonna blow up at runtime or it's just
going to produce some weird type
coercion bugs we can avoid all of those
bugs right at the start by not allowing
the func the
application to compile thanks to strong
static types that's really beneficial so
we've looked at some primitive types but
for real applications we're probably
gonna have more complex types that we
need to use so let's start walking
through an example of how we can get
into some more that the complex types in
a home so let's say we want to create a
dog type well we could use tuples for
this and this is going to be our dog
type we'll have a name and an age so a
string and an integer if your Python Deb
you're probably familiar with tuples
it's a way to organize types together
essentially so my dog is going to be a
string and an int and we group them
together with parentheses and then to
create the dog we use the parentheses
with the values Tucker is the name 11 is
the age and then operate on our type we
could use the special tupple functions
from elm tupple dot first returns the
first value couple that second it
returns a second value now this will
work for really simple types but when we
need to add more properties to our dog
this could get really unwieldy and hard
to actually access our values so let's
say we wanted to add a breed to our dog
now well now we could reach for maybe
the record type instead so this is very
similar to objects in JavaScript notice
we have the curly brace syntax like a
JavaScript object so when we type it we
could have a name string age ant breed
it's going to be a string so we just use
colons to separate the key type pierce
each of those with a comma and then to
instantiate our record we use the curly
brace syntax with key value bears
separated with equal signs so to access
properties we can still use dot access
syntax like JavaScript so that's really
nice and useful but notice here I can
actually put dot name then dog well it
turns out just like operators record
access is also a function in elm so when
I say dot name its elm is going to
create a function for me that knows the
ticker record and pull out the name
property of that record so one
really beneficial use for this is if we
had a list of dogs and we wanted to pull
out every name for every dog we could
easily write lists top map dot name and
then the list of dogs with one line we
can pull out every name of every dog
thanks to this special record access now
typing with records could be little
cumbersome every time if we want to
create a dog we have to talk about that
long curly brace to declare what it's
type is so one way we can get around and
this is to create our own dog type via
type aliasing so Ellen gives you these
two keywords type and alias we can
declare this uppercase dog type and say
it's the same as a record of this type
with a name age and a breed and now when
I want to declare the type of any of
instances of my dog I use my uppercase
dog and then I can instantiate it with
the record syntax but elm actually even
gives us a constructor function for that
a more succinct way to create these
records and this is through type
aliasing and it works because its
function the order of arguments matches
the order of the properties that I
declared in the original record so name
is first ages second and breed is third
so this is nice and convenient now what
I want to update a dog though we're
gonna have to deal with immutability and
elm and the idea is we want to create
state we don't want to mutate it which
is possible in JavaScript and the main
benefit of that is if we prevent
mutation we can ideally prevent a lot of
bugs that we could encounter when we
accidentally mutate some state we didn't
mean to or we can get into some
incorrect configuration in our programs
so if I wanted to update my dog maybe
the dog wants to have a birthday well
instead I'm going to create a new dog
and I'm gonna use this special merge
syntax which is kind of similar to maybe
object on a sign or if you use some
future JavaScript features like the
spread operator in objects so I have the
curly braces in a bar and what I'm
saying is
take the original dog all of the
properties that are in it use those and
then to the right of the bar I can
specify every property I want to change
for this new instance of the dog so in
this case I'll say its age is 1 plus the
original dog's age but now notice when I
access dog died age age has stayed the
same we did not mutate the original dog
but our new dog it's ages 12 and that's
thanks to this special merged syntax and
it prevents us from having any mutation
in our programs that could lead to bugs
now one thing you might have thought of
with our breed inside of our dog why are
we using a string here if we had a
program where we wanted to confine what
values breed can take on you'd have to
imagine we'd have to write some runtime
validation code to make sure that when
we type shell T it's spelled a certain
way and then any other breeds you want
to take in are the only values accepted
but that's something we have to worry
about at runtime and so that's extra
code we have to write we'd like if the
Elm type checker could work for us in
this regard and so we can do that
thanks to Union types as well so Union
types are differ from aliases and that
we can create a new type and define what
values it can take on and this idea is
that we know breed is a finite concept
there are only so many so many breeds so
we can force breed to be type check now
in Elm instead of having to worry about
lots of runtime validation code to make
sure the breed confines to a certain
value we want so Union types to define
them we'll have the type keyword with
the name of the type we'll say it's
equal to a set of values first it's a
shell T and then we can use bar to then
specify any other value it can take on
so this is shell T or Corgi or Golden
Retriever or a mix of a breed and a
breed and then when we want to use this
type with our dogs we just use those
values we defined so Elm actually gives
us constructor functions for these as
well so I just say this dog is a Sheltie
this dogs a corgi well what about the
third dog we know it's a mix but this
actually won't be fully typed and notice
up there we have mix of breed and breed
and so if these are constructor
functions like normal functions they can
take arguments as well so we're saying
that a mix has to be of two different
breeds so that means I need to invoke
mix with the two different breeds I have
so not only do I have a finite list I
can still allow mixes of breeds and so
types can be recursive in that regard so
you could use a union type for say
creating your own linked list with nodes
or a tree type structure or Union types
are really beneficial for maybe a finite
state machine where you define all the
particular states that your program can
take on and then you can type check that
which is really nice so one other thing
we haven't really addressed
so we said Elm doesn't have a null but
we obviously all know and software
development know like situations happen
what if I fetch a user from a database
and that user doesn't exist that's a
real-world situation that is probably
going to happen and if Elam doesn't have
a null how do we deal with this
situation
well we can do that with a special Union
type that elm defines for us called
maybe and this is its literal definition
in elm source code so you can look at it
as maybe I have this or maybe I don't so
the values it takes on is either I just
have this thing just have a user just
have a dog or I have nothing and so the
way we write that is we introduce this
little thing called a type parameter
we're gonna let the stand-in for it be
just a lowercase a but maybe is a boxing
type type and it's gonna box over
whatever value we either have or we
don't and so a is a stand and we're
saying that this could take on any type
so it's kind of like a generic so to
speak so contrived example of how maybe
we could use maybe is if I have a
divided function that takes in two
numbers numerator denominator then
divides them well we know that
can't divide by zero so we could use
maybe to deal with the situation if
that's an undefined situation then we
have nothing so for the declared type
we'll return a maybe of a float and then
when we check if our denominator is zero
then we're going to return nothing this
is invalid so we're gonna deal with it
by using a maybe and returning this
nothing yes we'll get to that X coming
up upcoming slides a good question now
otherwise we'll do the division and
we'll wrap it in adjust and so when we
divide four by two four by two we get
just sub two if we divide four by zero
though an undefined situation we're just
going to return nothing and so what's
the benefit of that and also how do we
get to the value that's wrapped by
adjust we use something called pattern
matching and so pattern matching with
this case of expression is like a really
powerful version of a switch statement
in an imperative language like
JavaScript or Java and so we say case of
something so we give the expression and
then we have several branches so like
your case statements in a switch
statement so we either have just a and
what pattern matching lets me do is I
can now access the value inside that
just and bind it to a variable called in
and then I'll return a string result is
concatenated with two string of in and
for the nothing branch I'll just return
no result so now we've dealt with I had
it or I didn't
now what happens though if we say well I
don't think that nothing situation it's
never gonna happen there's gonna be no
it's gonna be fine well it turns out Elm
won't let you do that if I leave out the
nothing branch here in this case
expression it will not compile so Elm is
forcing you to deal with the null
situation and so if you compare that to
the JavaScript a lot of times we may
think we'll never deal with that
situation and maybe we really won't so
we can get away with that
not gonna allow you to do that it's
gonna force you to deal with those
situations where nothing does exist so I
hope that's kind of what you're looking
for so it's mainly the tight benefits of
it that you can box these values in and
be forced to deal with these situations
and it can catch it for you at type or
at compile time so that's kind of a
quick deep dive in some of some of the
syntax and benefits of Elm I want to
cover just a couple brief things and
then start looking at its architecture
and see how that really works to build
applications with them
so Elm has some built in tooling which
is a nice perk over JavaScript where we
have to add in lots of features it has a
package manager compiler repple and a
dev server it also has its own built-in
framework which is the architecture that
we'll look at next but compare that to a
lot of the JavaScript fatigue issues
where I have JavaScript and now I have
to pick what framework I want to use
what tooling I need to use where they're
babel typescript web pack etc I get most
of all that built in right with elm and
I don't have to worry about making all
these choices anymore
so what does this architecture look like
what's what we call the model view
update pattern and it's a very
unidirectional pattern I have state my
model I have a view and that is just a
reflection of my state displaying it my
view doesn't have business logic it
doesn't have its own state so all the
state is consolidated in one area and
then any changes to that state happen in
the update phase so we have organized
how the data flows in our application in
one way and we also organize the
communication through messages that
we'll look at further so when you have
an ill man ocation this kind of looks or
like this at a high level your
application is going to sit inside the
shell of Elm it's going to manage your
model your State on your behalf and then
any communication that your application
wants to do with the outside world has
to go through Elm and so that allows you
to only focus on writing pure functions
in Elm including your HTML you're not
writing real HTML you're writing virtual
Dom which is just pure values and Elm
handles that for you to actually build
the dom HTML so what are some of the
communication channels so to speak Elm
has commands we've briefly mentioned
that with HTTP requests but that's a way
where you can pass off a command value
to Elm and it can handle HTTP for you
you can also subscribe to things like
WebSockets or browser resizes and many
other things and elm will handle that on
your behalf as well and also dom events
whether that's on clicks or text input
and so what else is going to do is
anything you're interested in listening
to which you just give to elm as a pure
value it'll create a task in the
background and then eventually once
that's fulfilled it's going to give back
a message to you now this message is a
message type that you define so you're
not only providing a model view update
and issuing commands and what and
whatnot but you're also defining here
are the only ways that I expect
communicate and that's through messages
and we'll see that when we look at a
demo so kind of blowing this up to see
how these communications happen
we obviously as we say we give state to
Elm this is the state we wanted to to
manage on our behalf we give it that
update function which updates the state
and also a week we will use for issuing
commands and then the view layer for
displaying it so the life cycle of all
this zone takes your state uses your
view function everything you write is
pure functions that you can test and
then L manages creating the HTML and the
Dom nodes for you if there's an event
from the browser let's say the user
wants to change the color of this car to
red and it's going to notify that events
gonna go to Elm first LM is then gonna
look for the message type that you said
you were interested in listening to this
particular event when the color changes
and it's gonna use your update function
to supply it with the message that says
we're changing the color and it'll
provide the current state the blue car
your update function is then going to
use that to note to return a red car now
as the new state and give that back to L
and then Elm can use that to then use
the view layer to display this red car
so see everything is unidirectional
going in one pathway and so to make more
sense of that we're gonna dive into the
architecture now and see how we really
build an app with this architecture so
we're gonna build a simple just Twitter
client for loading a user's profile and
will be responsible for typing in the
user name and then clicking load to load
it up so we'll see how we deal with HTTP
NL so first off every file in Elm is a
module so it's a very modular language
so we first need to declare a module
this is going to be the profile module
we'll have a module keyword the name of
our module and then we'll have this
exposing keyword so we can specify what
we really want to expose in our module
so if I had to find a couple things like
f FN 1 FN 2 I could make them specific
or I can just use this double dot syntax
which is like a wild-card or rather to
say expose every function I define
since it's modular I can also import
other modules I'm going to import the
HTML module here which we'll use for
building the virtual Dom and notice I'm
exposing everything that it defines so
it primarily defines like an HTML type
and it defines functions for every tag
there's a div tag a paragraph tag an
anchor tag but these are all functions
that we're going to use to produce
values and get back to Elm so it can be
responsible for the real HTML Dom like
most programming languages we're going
to have a main function for this very
simple start it's just going to be typed
as an HTML of message and we'll learn
more about messages once we really start
building our app we're sending an equal
to then to a div or a call to div and
every HTML function takes two arguments
the first is a list of attributes so
this would be like class ID on-click etc
the second list here is any children so
this is how you start to compose your
view and your tags together so the Swift
could be any number of children for this
div tag in this case I'm going to use
just a text node this text function
comes from the HTML module as well but
now we want to turn this into a real
application so we're going to change the
types it's gonna be a program and it's
gonna have several type parameters the
first one is flags and we're not using
any flags for our program so we'll say
never it's a special type in elm we're
gonna have a model type that will define
and we'll have our messages the ways we
communicate back and forth with the
outside world so we're going to find
those two types to create a program
we'll call the HTML program function it
takes a record with several properties
has an it view update and subscriptions
so we talked about view and update we
have to provide those an it is a way of
providing our initial state as well as
providing an initial command
if we wanted to it we wanted Elam to
immediately issue an HTTP requests when
our application boots subscriptions is
something we won't use for this demo
where that would be a way for you to say
I want to listen to WebSocket events or
something like that so we're first going
to need a model since this is a Twitter
user we have a screen name and we want
to store that in our model for this
application because we're going to store
it to use it later when we want to fetch
a particular user
we need the message type and that's
going to be a union type because we have
a confined set of the only types of
messages we have in our program and for
now I'm just going to fill it in with
message again I'm going to define an
initial model for our elm to know where
to start
we'll use the constructor function that
gives us from the alias so the first
parameter would be the screen name once
we start off we're just we don't have
one so we use the empty string we're
gonna define that in it and that's going
to be a tupple a pair of our initial
model and of a command so commands and
elm they're of a type cmd' which is
short for command and they are
parameterize by messages because
remember we have to confine
communication to our message type so
we'll give it the initial model here in
this tuple and we use the command nun
function to say we don't want to issue
any commands initially our view it's a
function that takes our model and it
returns HTML of a message it's HTML of a
message because we can also subscribe to
Dom events and that's again confined by
the message type that we define and so
notice here viewing it's a reflection of
our model so that's why model is its
parameter so I'm gonna create a view for
typing in the screen name for right now
and saving it in our state
so I want to give it a class of load
profile which means I'm gonna have to
import the attributes model and that's
just going to provide all the functions
we might want forward defining
attributes for HTML so I have I'm going
to end up using class source type value
and disabled for this program now for
the children of this I'll have an h4 tag
it'll have load profile I have a label
for the input the screen name and then
an input element for typing be of type
text and we'll let its value be the
model screen name so even though we're
going to be typing in it to supply the
screen name because we want that state
to be in or that screen name to be in
our state we're gonna let this be a
reflection of what was just typed in
we'll have a button we want it to be
disabled initially if the screen name is
the empty string because we don't want
to fetch a user without a screen name
then finally I'm gonna put a paragraph
tag here and that'll be a way for us to
verify that we're actually going to
display a screen name we just typed in
to prove that it's in our program state
next we need the update function it
takes a message that we define takes our
current state the model and it's going
to produce another of those tuples which
has any new state and any commands we
want to issue for now we're not going to
deal with this so we're just going to
return the same state and issue no
command here
finally for subscriptions it just takes
model and returns sub of a message and
again we're not using that this example
so we'll just do sub nine
notice here we have type error there
that's fixed I'm having an issue with my
vim wanting to recognize type areas
there but notice here when I save
nothing's happening on the left and I
have an X over here on the left of my
editor I attentionally an introduce the
bug here so you notice this input we had
here every other HTML we've had the list
of attributes in the list of children we
did not include that with input so even
miss typed HTML where we forget certain
parameter that's not going to type check
and so our program will not compile once
I supply just that empty list there
everything's of the same type for these
HTML nodes I'll say that everything
loads up now so now we have that type
checking and that guarantee that
everything has to compile before our
program can even run now I'm typing in
notice nothing's showing up here in that
paragraph tag our button is still
disabled so we're not updating state so
now we need a way to subscribe to this
on input event from our Dom or our
virtual Dom in this case so we need this
input to start notifying us so we can
use the on input event function and it's
going to need a message type so now we
can start defining what are the messages
that our program uses I'm gonna have an
update screen name message and so on
input one say function a constructor
function that it can invoke with
basically event target value and then
that same message is going to get passed
into our update function down here
so to get our events will import the
HTML events module will also need on
click what we're going to pull in those
two functions and their functions like
everything else and now we can update
that message type to use this update
screen name message remember I said it
needs to take a string so we'll give it
that parameter there so now that we're
going to be able to issue this event
whenever we type in the text box we need
to handle it so I'm going to use pattern
matching on my message just like we did
with maybe in this case we only have one
update screen name and with pattern
matching we combine the value to this
screen name variable will create a new
tuple with new state with the merge
syntax and then we'll issue no command
in this case everything looks like it
type checks we'll hit save and now it
loads up there it's shown up in the
paragraph tag so we know we're saving it
in the state and the button is no longer
disabled now when I click on the button
it's not working so now I need to start
working on how are we going to get this
HTTP request to work and how are we
going to load the user up so if we go to
our button we essentially want to be
able to dispatch something here when we
click so we have the onclick that we
imported earlier we need to define a new
message type we're gonna call it fetch
user so now we're saying whenever that
buttons click please issue this fetch
user message that I can handle in the
update function so we'll add to our
Union type fetch user we'll also go
ahead and add a load user message as
well so once the user is loaded image so
we need to get it back into our
application so we're going to define a
message for that now it takes a result
parameter and I'm wrapping in
parentheses because the result type
itself takes a couple parameters takes
an error type and a success type
successful we want a user there's an
error we're going to use an H
TPR so what is this result type we
haven't seen that it's basically a
special case of maybe and it takes on an
okay value or an error value and has two
type parameters error in value so this
is just like maybe which had just and
nothing but instead of nothing not
wrapping anything now it's gonna wrap an
error so this is a useful way for doing
to do a success failure where if it's a
failure that error value right here
which can be any type is like a reason
code or an explanation message for why
this failed like the user wasn't found
so we'll need the HTTP module we'll need
a user type so we'll use another alias
here obviously this will be a screen
name because we're gonna be loading a
Twitter user it will also load their
name description of the user and their
profile image now we need to store this
user in our state we're gonna put it
under a profile key but do we want to
use the user type right here if we go
down to our initial model we need to
make sure we add a profile to it we
would essentially have to provide it
with an initial user but that's not
really valid we don't want to create
just a fake user here really we have a
situation where either we have a user or
we don't
so that actually sounds like maybe we
have a user which means initially we
have nothing
so now we could start updating our view
layer two to deal with whether we have a
user or not we'll use some a little bit
of composition or composable views here
so I want to change this to be a load
profile view the view we were using
before where we type in the screen name
and that's the case where we don't have
a user yet we do have a user though
let's use a function called profile view
that takes a user and returns HTML I'm
going to use a let expression here which
we really didn't discuss but it's
basically a way for you to introduce
custom bindings like custom variables
inside the body of your function but
it's all one single expression well let
that be the user's name concatenated
with their screen name in parenthesis
inside here we haven't do with class
profile will have their image tag for
their profile image
so here we'll have a h3 tag will use
that binding we created for displayname
and then finally will display a
description of the user so now we have
two separate views to deal with these
different situations
now notice though this isn't going to
type yet we have an arrow down here at
view now we got rid of view because we
separated it out into two different
views so now we need to compose over
them so we'll create a new view and now
we can build upon this idea of whether
we have a user right now or not by using
pattern matching so we'll use pattern
matching over modeled up profile if we
just have a user then we'll use the
profile view with that user if we have
nothing then we'll use that load profile
view with the model
we should be in you know type error here
type checker caught me need to be under
source in the attributes there now also
we're not going to type remember how I
mentioned with pattern matching when you
use it on a Union type which is our
message
it requires all branches to be
considered right now we're only handling
update screen name if we go down here to
this update function the very bottom
there and I don't know if you can read
that or not it says this case does not
have branches for all possibilities
so it's making sure we handle all the
possibilities with our message because
that's the way we handle communication
in our application so if we have fetch
user we're not changing stay in this
case but remember we also use the update
function for issuing commands so we're
going to need sort of a fetch user
function it takes the model screen name
so we need to define this function for
creating an HTTP command so that's going
to take a string which is a screen name
and it needs to return a command of our
message types take the screen name or
use another let expression here we need
URL for the user API is
and then we're gonna create a request
we're not going to issue the request
because everything is a value in elm
we're gonna use the HTTP GET function
and it takes that URL we just created
it also takes something else that we're
going to call a user decoder and this is
probably this may be one of the most
confusing parts of this but there's a
good reason for why we needed to find
what we call a decoder here so remember
we're gonna have some random JSON
payload we can't necessarily trust it
but we know it has to adhere to certain
shape that we expect because it has to
enter our world of static types so we
need to translate this JSON payload
somehow to our user type so to deal with
that we can create a decoder it's going
to require the JSON decode module which
has a couple functions string and then
it will a decoder type and then this
third-party pipeline module which has
required in decode and that's a lot of
random functions and a type we'll see
how we use them and it's gonna hopefully
look a little readable and
understandable still what we're trying
to accomplish so we'll come down here
when you to define this user decoder
it's gonna be a decoder of our user
we're gonna say I wanted to code this
user type and here's how I'm going to
recreate it from the JSON we're going to
use piping we're gonna use that required
function from the pipeline module we're
going to say it takes a screen name and
it's a stream so that's where all those
functions are going to come into play
and this pipeline allows us to structure
it in the same order that we defined for
our user type so we'll have name
description and profile image URL see
we've mimicked the user type and how we
define each property but what this
pipeline module allows us to do is to
say screen name is required name is
required description etc and they're all
strings in fact the string we supply
here is what the property is in the
payload Twitter
API uses underscores he remote
internally in our type we're using
camelcase but what it's saying is it's
going to look when it gets that payload
it's gonna look for screen name if it
finds it then it's gonna first invoke
user with that same thing with name once
it finds name it's then going to add
that as the second parameter so this is
a way for us to tell it here's how you
find what the payload has and convert it
into my type so now we can go back to
our fetch user we have the decoder which
means we have a request it's a value not
the actual HTTP request and then we can
send it off with the HTTP send function
now once this is sent we need to be
notified once all right we have our user
back so we need to provide it with the
type load user that we define that's the
message we want to know when something
the user comes back and then we're going
to provide it with the request and that
will create our fetch user finally in
our update function we need a handle
load user will grab the result remember
it's this special certain type of maybe
with okay and error so we can use
pattern matching on that if it's okay
successful we can grab the user create a
new state where profile is equal to just
that user and then I'm going to cheat a
little here for the error case since we
don't have time to really dive into
writing code for it we're just going to
ignore it but we would definitely want
to handle that case and do something and
so we'll just return the same stay and
not issue any new commands so everything
looks like it's compiling now we'll save
it look at our network it's really blown
up here
type in the pop-up puyo and there it
loads up so basically what we've done is
we've written a bunch of pure functions
I just described our UI describe how we
want to fetch a user and we've handed
all that off to Elm and it's done
everything for us and once it's loaded
the user it's given us back giving it
back to us but let's go back just for a
minute to see how would L deal with what
happens if the payload isn't what we
expect so I'm going to import the debug
library and it's log function that's
probably the only impure function in Elm
because it does allow you to log to the
console so if I go to my decoder and
let's say instead of name I thought it
had display name now this will type
check and compile because we don't we
can't check the API ahead of time but if
I hit save here and in fact I need to
make sure I log out what we have here by
trying to load myself now nothing
happens it's maybe a little hard to read
but when I logged it out instead of
getting the ok we got an error now this
is bad payload this is the message why
it failed expecting an object with a
field name display name but instead got
and in this case it's just logging out
the entire raw JSON but this guarded us
from that API payload change so now we
can immediately know there's a problem
the API is changed we have to deal with
this error and it hopefully is going to
prevent any issues coming down the
pipeline that might happen in JavaScript
so we'll quickly revert that just to
make sure it still runs
and everything loads up fine so that was
kind of a quick deep dive into looking
at Elm its architecture its types syntax
and I'm sure it's a lot to take in it's
a lot to put together in a one-hour
taller but I despite what seems like a
lot of boilerplate
I hope the main takeaway you can see
from this is that we can structure
everything in our code everything is
type checked and if it doesn't compile
then our program has an issue with it
and so we've been able to prevent any
runtime exceptions from happening we
even type check issues where we don't
have something or we do and even we're
guarding against bad API payloads all
within the language we haven't added any
special frameworks or libraries so Elm
provides a lot for us to write these
safe robust web applications that
unfortunately Java Script just can't
fully guarantee for us so thank you so
much for attending and I really hope you
enjoyed it there's a few links for Elms
documentation and the language itself
how to get installed and up and rolling
and then some links to the code that you
saw today and these slides thank you all
so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>