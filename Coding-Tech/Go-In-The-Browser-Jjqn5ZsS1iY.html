<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Go In The Browser | Coder Coacher - Coaching Coders</title><meta content="Go In The Browser - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Go In The Browser</b></h2><h5 class="post__date">2017-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Jjqn5ZsS1iY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Kell is a programming language many of
us are very familiar with a
specification I want to use girl I think
it's pretty good at the same time kind
of hard to ignore the browser in this
day and age suppose you're writing a web
application you know you start off by
having some HTML templates and then
before you know if you want to do a
little bit of Ajax and a front-end and
then you decide to turn the whole
application into a single page apps run
that application and then you're
rewriting it and react and before you
know it you're like why not just rewrite
the backend in JavaScript as well so
that you can share some of that business
logic I didn't want to give in to those
forces there were two main reasons that
we're really attractive to me and I
wanted to keep it is this refactoring
experience that you have when you're
using go so you probably felt this
you're working in a go project and you
want to basically take some Gil packages
move them around to refactor them and
it's a really pleasant experience the
other thing that I really wanted to keep
was the reusability experience so
imagine there's something that is common
between multiple projects and you want
to basically factor that out into a go
package and then be able to import it
from multiple projects I thought that go
already runs on multiple platforms right
it runs on desktop operating systems and
mobile operating systems
quite a lot of them actually so what
about one extra one this curious gopher
really wants to jump in the browser he's
very eager so what would it feel like to
think of the browser effectively is an
operating system that we want to target
luckily we can have a little bit of an
answer to that so go for Jess
it's a compiler that takes go codes and
compile it to JavaScript which then runs
into browsers to give you a little bit
of its history of support of the Agila
language specification it was created in
2013 and it had everything except
garbage scenes running the most of the
center library tests were passing it
could compile itself to
14 added goroutines channels and a
select statement with the caveat in 2015
that caveat was removed and there's
nothing left to do in terms of the
language features in 2016 so I want to
give a special thank you to Richard
Musil he's the creator of go for jazz he
that most of the heavy lifting and
actually created it so if there's
anything that's cool or anything you
like in his presentation you probably
find them and thank him after so a
little basics of what it's like to use
Gil in the front end there's a J's
package for accessing the JavaScript
world it is very similar to the C is it
a package but it has the semantics of
the reflect package this is roughly what
is API is like you have your object
which is a container for the native
JavaScript object you can convert it to
a bunch of these types and you can get a
key or set a key color methods so on the
package level of global that's the
JavaScript global object so it's window
and browser that lets you access and get
to all of the other things inside the
browser so just to give you an idea
here's some simple JavaScript and here's
the equivalent behavior but using the
J's package and go so something to
understand here just like there's a
saying that Seco is not really go well
let me tell you neither is JavaScript it
is not a lot of fun to use the J's
package it's not pleasant but the good
news is you only have to do this once
you do this internally inside of the
wrapper libraries but then you can
expose these really nice and idiomatic
Gale API for the users so there's
already a lot of them created there's
bindings for dom xhr fetch event source
WebSocket too many to name and let me
just show you a few of them so here's
the dom package that gives you the
entire Dom API there's a lot of symbols
there and it kind of allows us to write
the previous example in a slightly
shorter way that's a little bit more
typesafe friendly for auto-completion
here's my favorite one
there's a WebSocket package for
accessing the web socket API this is the
API it exposes it's a diol function that
makes a WebSocket connection blocks
until it finishes and then once ready it
gives you a napkin
that's an interface it's in a center
library it's very easy to work with and
you can use it with the nets our PC or
the JSON RPC packages here's another one
if you want to make an xhr request will
go for jazz it actually implements the
HTTP clients of Matt HTTP so you can
just do HTTP get the URL get the
response do you notice anything this is
exactly the same go cut as you would
write and on the back end to make an
HTTP request it's implemented via fetch
in a browser or if not available using
xhr so I want to give you three
interesting examples or case studies of
what it's like to use Gil in the product
so for the first one let's think about
what it'd be like to implement IO reader
and an IO writer in the context of a
browser let's port IV it's this APL like
language interpreter created by Rob I
can think of it as a calculator of sorts
to run inside the browser so it's a CLI
command that means what it needs really
is just standard in standard out and
standard error well how would we do this
on the back end or inside of a desktop
operating system this is easy we just
have standard in which is an IO reader
that's implemented by being assigned to
OS standard in standard out is an IO
writer that's OS standard out what would
it be though if we're in the front end
inside the browser an idea is to use the
Dom so we can make a console of sorts
that is just made up of a pre element
and an input element so the standard
output and air will go here and we're
going to get the standard and through
the inputs so that's just the HTML that
I showed on the previous slides there's
nothing here so it doesn't actually work
yet but that's what it looks like it's
already pretty close so now let's work
on implementing the IO writer that will
write inside of these this pre element
so we have new writer it takes a pre
element and gives back an IO writer and
the implementation is very simple that's
all it is
we're just gonna take the existing text
content of that pre element and take B
append to it and set that what about the
IO reader that's where things get really
fun so we're gonna have a pending bite
slice like this and we have an n-channel
of bytes of bite slices so the read
method does the following it checks if
the length of bending is zero which it
will be initially then we will assign
depending will receive a value from the
n-channel and then once that's done
we'll just copy the rest into the
piecewise but wait a minute we're gonna
receive from a channel that's a blocking
operation but that's perfect that's
exactly what we want our readers are
typically blocking until there is some
input available so what actually sends a
value on that channel let's see when
we're creating that reader we're taking
the input element returning our reader
what we're gonna do is add an event
listener to that and put events on the
keydown event type and whenever the user
presses the enter button
we'll just take whatever is in the input
value plus a newline and send that
across that channel and then just clear
it so we can now put it all together
we'll just have with this new file
constrain it to the jas architecture and
in the net we'll just say that the
standard in is that input elements
wrapped in a new reader the output is
the new writer and that's assigned to
standard output and so on and then this
file together with the rest of the IV
caleb is completely unmodified will give
us IV in the browser so i can do this
and it computes it we take two to the
power of 10,000 it's a really large
number but gives us an answer pretty
quickly do you notice something odd
about this when I take five points five
I get the answer but the input kind of
goes away so the reason is that we're
used to this but most terminals actually
take whatever is on the standard input
and copy over there copy that over to
standard output
so an idea is to use IOT reader to do
exactly that well just send a copy of
standard n2 Schneider output and by
doing that we have fixed the problem the
second example I want to show you is
streaming HTTP response bodies so
sometimes you want to make an HTTP
request and then actually stream the
response body process it and maybe even
stop processing it when we find a thing
we want and not download the rest of the
response if we're doing this in a
backhand it may look like this and go
we'll have an HTTP GET and we'll just
take the response body it's already an
IO reader and we can just start
streaming right away and to standard
output for example how would you do this
on a front-end with Gil well remember I
said net HTTP the client is actually
implemented using the fetch API and it
supports that in the browser so this is
exactly the same code you'd write on a
front-end to do this so a real or a demo
of using this could be to take this CSV
file and try to stream it parse it and
then find a value so here's some
JavaScript code that uses the fetch API
to do this there's a lot going on here
here's the fetch there's a promise
involved there's a search function that
calls itself to their callbacks this is
not the kind of account I'd want to
write or read or review or refactor so
what if I rewrote this and go then it
starts to look like this
it makes an HTTP request and will defer
closing response body so when we're done
it will get closed wrap that into a CSV
mu reader and then just iterate over all
the records until we find out what the
one that we want calling that looks like
this it's just simple blocking codes
it's very readable I like this a lot
better the third example shell is the
ability to create really highly
cross-platform libraries let's take a
look at packaged GL it supports smackle
Linux Windows iOS Android and modern
browsers that includes mobile browsers
on your mobile devices as well as on the
desktop the way we do this is by using
build constraints so the Matco at the
desktop is implemented by constraining
to the 3d6 and AMD 64 architectures and
then implementing all the opengl
functions like this you siegel get
opengl 2.1 the mobile ones are using
these build constraints implement the
exact same external API but using OpenGL
ES 2.0 in this case and for the
browser's will just constrain that to
the jas architecture and again implement
the same external API but now we're
gonna have a WebGL context in the
browser I'm just gonna call a method on
it in order to have that same behavior
so we're using WebGL 1.0 so with all
that together you can have a single
codebase written and Gil that can
absolutely run anywhere so let's see an
example of that it's a little unfinished
game I've created you can see that it's
running inside the browser it's gonna
open the track and load the model the
textures and then we have it running
like this so if you use your imagination
there's probably a little Gil for
insight that harbercraft and if you
don't believe me I can show you that
it's actually a go program it can also
run on Mac OS here it is
the exact same code base but running on
a desktop
I'll talk a little bit about the
challenges of using go in the browser
the biggest one in my mind right now is
that there's just no idiomatic react
like library for the front ends written
they go there at multiple works in
progress but it's just not there yet
there there are fewer Gil developers in
the world than their JavaScript
developers you're you often end up kind
of doing something for their very first
time and that can be fun but if you want
things to be already ready that's just
not the case the rest of the challenges
they're a little bit more go for jazz
specific but the JavaScript output can
be somewhat large so that makes it
really viable for single page apps but
not so much for like little short
scripts you can't really put multiple
scripts on the same page but this can be
approved to go better that kill it
elimination the performance is generally
really good sometimes it's actually
faster to compile to the browser and
have it run there the v8 is incredible
engine but there are some pitfalls you
can fall into where the performance is
up to 10 or 100x slower finally there's
a separate bill tool use unfortunately
you can't just do go arch jus you'll
build with a compiler equals to go for
Jess not yet it's probably a small one
but what is the future of Gil and the
browsers that look like so go for Jess
it's an AST based compiler it looks at
the ast of Gale and it targets
JavaScript specifically sure there's a
lot of work to make all the gore teams
work and everything it's ready today and
you can use it but I think the best next
thing that we can do is to target web
assembly we already know that many
browser vendors have backed it they're
supporting it it's being worked on and
it's likely going to be the next step
but it's just not ready yet and it will
not be go for Jess that targets it or
probably another compiler so I just want
to conclude with saying that go is a
very easy language to like it's a lot of
fun and it's actually possible and very
viable
to be an expert at its that reference
spec that I've shown that URL off I
think many of us have read it very
carefully and we know it pretty well
you have your static types and you get
compiler errors so those are really
great they're very helpful you have a
great experience when you're doing
refactoring if you want to reuse
something a component between multiple
projects it's very easy and you can
write blocking codes instead of having
to write callbacks a really cool other
aspect is that there's just no friction
between moving between the front end and
the back end it's like having a slinky
where one day you can have something
running on the front end and other day
you decide to move it to the back end
you don't have to translate to a
different language in order to have that
which means you can reuse some common
business logic and if you have some
validation codes that's running on the
back end the same code can run on the
front end you can share the same code
for rendering HTML you can use existing
Gil libraries or commands as I've shown
as well and finally you you can keep
using the same tooling the same style
the same practices as you do on the back
end it's very familiar and there's a lot
of powerful tools for ghio so if you
thought Gil was fun in the backend just
wait till you try it in the front end
the browser makes for a really
interesting and powerful operating
system of sorts there's all these new
api's like there's web vr so you can
actually start doing VR virtual reality
inside of the browser maybe somebody
will write some bindings for that so I
can honestly say that go made me like
front-end program again maybe you'll
like it too
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>