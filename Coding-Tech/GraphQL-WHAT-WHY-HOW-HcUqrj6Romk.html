<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GraphQL: WHAT, WHY, HOW | Coder Coacher - Coaching Coders</title><meta content="GraphQL: WHAT, WHY, HOW - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GraphQL: WHAT, WHY, HOW</b></h2><h5 class="post__date">2018-02-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HcUqrj6Romk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">with the recent trends in micro service
architectures cloud native and rich web
apps there's a lot more challenges when
building api's in this talk we're going
to talk about how to overcome these
challenges with graph QL an open source
API query language that we created at
Facebook let's go over the agenda
first we're going to try to define graph
QL what is it what is it not how do we
use it at Facebook and how does it
compare it to other technologies in this
space
next we'll talk about some of those
challenges that we face when building
api's and we'll look at how graphical
deals with them then we're going to
transition from theory into practice at
this point if you're convinced that
graph QL can help you solve your
problems then we'll talk about how you
get started how you get graphical into
production some of the advanced use
cases and features you can rely on and
specifically how you can deal with
authentication and authorization
and finally we'll wrap it up by talking
about what's in store for the future of
graph QL what's on our roadmap how can
you contribute and participate and
finally we'll have a resources slide
followed by Q&amp;amp;A so any hyperlinks you
see on here
don't bother taking pictures of it or
anything that's going to be on the on
the resources slide for you at the end
you
let's start with a demo
err
you
I have a graph QL server running on my
laptop and I've just plugged in the URL
into my browser and what we see here is
graphical now graphical is the graph QL
IDE this is just a tool this is not
graph QL itself but this tool lets us
author graph QL queries send them the
server for execution and display the
response in addition on the right hand
side you see there's this documentation
Explorer pane and using this we can
explore the graph QL schema that this
endpoint supports so we know what
queries to execute in this case I've
built a very simple example schema to
model an online library system let's
take a look at what contains on the
right here we have this query route and
if I click through it says it has two
fields authors and books and for authors
it says it's going to return a
collection of authors so if I click
through this off author entity it says
oh it's got these fields ID name image
and these are all primitive fields of
type string but then it has this edge
pointing to books and it returns a
collection of books and books have a
bunch of other scalar fields so knowing
that I can come in here and I can just
start authoring a graph QL queries so I
have a query
I can come in here and I remember that
these are my fields that I can use to
start accessing my graph of data so I
could say books I can say something like
ID so these are the IDS of all the books
in my system but I these aren't that
useful they're they're great for
programs but they're not great for human
beings where are the titles of these
books so it looks like we have some some
Harry Potter books the Lord of the Rings
trilogy now what if I wanted to fetch
the author for each of these books I've
got this author ID and I've execute this
that seems to be pretty consistent but
it's not giving me the data that I
actually want what if I want the
author's name well I could do something
like this and now I have the author's
name populating my query what if I
wanted to get for a given book I wanted
to get all the other books written by
that author well I can come in here and
just say books and now you can see we
started with this Hobbit was written by
token and then here are all the other
books in the system that dokyun wrote
but also I want to show that if I come
in here and I type foo it's telling me
what are you trying to do
foo doesn't appear to be a valid field
and am i coming here and type so like
this it says hey what's this you have
you know we've we've declared the the
opening and the curly brace for the
selection but you've got this extra
string outside of it what does that mean
so let me switch back to slides
what did we just see well we saw a
graphical document on the left we
package this up into a request we sent
it to the graph QL server and we got
back JSON as a response but we also saw
that we can't just send arbitrary text
it has to follow some rules and these
rules come from two sources the graph QL
language specification and the schema
now the graph QL language specification
describes the syntax so it says opening
curly braces must match or you must have
an operation type before the first
selection the second thing when we typed
food into the selection and it says hey
what are you trying to ask for I don't
understand the field foo well that
information comes from we call the
schema and the schema is domain-specific
and it describes the types and fields on
those types associated with a particular
domain in our example this schema that
we were looking at was describing an
online library system
and you also saw a server that can take
one of these requests executed and
return the response as JSON so there's
an implementation of the graphical
specification running that helps you
construct the scheme parse incoming
requests and fetch values for the
requested fields and the demo we just
saw we were using the reference
implementation that was written in
nodejs
you
it's also useful to describe what graph
QL is not and anytime anybody sees QL
they they probably think database right
but graph kill is not a database query
language although the asterisk here is
because there's this interesting new
database called D graph which happens to
use graph QL as its querying language so
I just wanted to point out that it's not
the design original design of graph QL
and it's also not a client-side state
management solution so we might be
tempted to think okay cool I've got this
JSON graph of objects I could just do it
with client-side state management right
not quite you still need some
client-side state management for for
dealing with things like caching across
new consistency and optimistic updates
and it's also not a good solution for
binary streams for example file
transfers images streaming video where
you're really streaming chunks of binary
encoded data that's not what graph kill
was built for and it's also not to be
confused with graph API so if you've
ever dealt with Facebook's third party
API is you've probably used graph API
graph QL is something different
altogether and it's currently only used
for Facebook's first party applications
it's not a limitation on the databases
that you choose it's actually just a
very thin layer as we'll see in the
stack diagram later and you can use
graphical with all sorts of persistence
backends ranging from sequel to no
sequel to caches like Redis to flat
files and that's because the graphical
fields that we saw in the schema are
backed by arbitrary functions that you
provide when you define the scheme
now although the represents implantation
is written in node it's written in
JavaScript on node that doesn't mean
that graphical as a JavaScript only
thing either there are implementations
of graph QL in just about every popular
language for example Java Python Ruby
c-sharp rust go you name it and and
these servers are used in production at
a large number of companies and you may
have also heard of graph QL through
other successful open source projects
such as react and relay and while react
and relay are really good choices for
building front ends that talk to graph
QL they're by no means exclusive the
declarative approach that graph Cal
provides is equally useful for jQuery
angular view as well as the native UI
technologies such as Objective C and
Java
lastly it's not limited to http we
happen to see graph QL going over HTTP
in our demo but it's not limited to HTTP
it happens to use HTTP very frequently
because of HTTP ubiquity graph Gil has
three operation types we saw the query
where we were essentially performing a
read against the system but there are
two other operation types we have the
mutation operation type which supports
writes and then we have the subscription
operation type which allows the client
to specify its interest in observing an
event a domain-specific event both
queries and mutations take a request in
the return a single response in the
future subscription by contrast takes a
subscription request and then returns
zero or more future responses and as a
result you can probably see that queries
in mutations are stateless and they can
operate on over any transport that
supports the request response model
however subscriptions are stateful and
that means you need to be careful when
trying to maintain durability
availability and throughput at scale
another thing is queries and mutations
are only semantically representative of
reads and writes just like HTTP verbs in
other words if you're implementing a
graphical server or a schema nothing
stops you from having a query perform a
server-side State mutation and nothing
stops you from creating mutation that
has no side effect these are just tools
to make the operations intent more clear
so if you if you had an HTTP GET
operation that's somehow deleted a
record in a row in a database nothing
stops you from doing that it's just not
very communicative and intuitive for the
user then a graph kill server doesn't
even have to support all these
operations for example if we don't want
to define subscriptions and which simply
leave them out of this chemo
let's talk about the origins of graph QL
how it's used at Facebook today the
first version of graph QL was built back
in 2012 by three Facebook engineers lee
byron knicks rock and Dan Schafer and it
was designed to support the growing
needs of our mobile applications where
the rest architectural style just wasn't
cutting it and in 2015 after years of
building extending an operating graph QL
the team decided to open source it but
this wasn't just a port of what we had
built internally this was an opportunity
to examine the initial work to take a
look at what worked well and what didn't
and make a bunch of tweaks and as a
result graph QL was open sourced in two
parts the specification and the
reference implementation
today graphical powers many things most
notably all the Facebook web and mobile
apps across these we have over 1.3
billion daily active users and these
users send us over half a trillion graph
QL queries per day
Groff kill is also seeing rapid adoption
at other companies for example github
Pinterest into it
Coursera Yelp there are a lot of other
companies using them for internal use
cases that haven't gone public with
their with their announcements
now there are a lot of architectures
frameworks and libraries and patterns
that facilitate client-server
communication or F kills not the only
one but we could be here all day trying
to grant compare drop kill to everything
else so the interest of time I'm gonna
focus on comparing it to rest because
rest is the architectural style of the
web and hopefully by comparing it to
rest
you'll transitively understand how graph
kill compares to any other api
technology in this space if not come and
talk to me afterward
before we dive into the comparison I
want to preface this by saying you'll
find a lot of literature a lot of
articles online about how graph QL is
here to replace rest or how awful rest
is and I think that kind of narrative
might be overreaching so I want to frame
this comparison in terms of trade-offs
try to avoid thinking about each row
here as a checkbox where the column with
the most check boxes wins but but I
could actually by show of hands how many
people here think they know what a rest
api is
okay now that's quite if you keep them
up keep them up please please keep them
up okay now how many people with our
hands up think they will agree with
everyone else with their hands up what a
REST API is where do they go so that
that's great for the first point of
comparison it's likely that if you put
10 people into a room and ask them what
is rest you're gonna get 20 different
answers and I'm here to offer a 21st
uh-huh so by rest I mean
representational state transfer as
defined in dr. Roy Fielding's
dissertation in in 2000 that is a rest
api is something that meets all six of
the rest architectural constraints
specifically there's one that stands out
it's called the uniform interface
constraint and the uniform interface
constraint is what contains the
hypermedia constraint which states that
hypermedia acts as this engine that
transfers state between the client and
the server now the degree to which these
architectural constraints are observed
and enforced is highly variable so
that's why all of your hands went down
because we have this landscape of HTTP
json api s that call themselves restful
or rest ich and if we take two paragon
rest api's unless they were built with
the same framework it's extremely
unlikely that they share critical
features like linked resource
annotations so I think it's safe to say
that rest has no shared definition at
least not in in concrete sense
Groff kills not like that graph kill is
not up for debate
given a specification and a schema you
know exactly what is and is not a valid
query and you know the shape of the
response that you're gonna get and
sometimes this specificity is good other
times the flexibility of rest is also
good
next let's talk about the central
organizing model behind rest in grass ql
in rest the central concept is the
resource and you can think of resources
as virtual files living on a remote
server somewhere they all share common
operations against them in graph QL the
central concept is a graph that is nodes
with fields and relationships to other
nodes and this has a profound impact on
how you add features to each API and
rest we're going to end up adding more
your eyes for more resource types
whereas in graph QL we stick with a
single endpoint and we expand the
possible variations of the queries
against that endpoint
and rests resource models also a huge
advantage when it comes to Federation by
Federation I mean we can link resources
between domains I can make a Facebook
post where I share a Wikipedia link and
then in that Wikipedia link there's a
citation of a New York Times article in
graph QL linking data across to
different schemas is difficult and
there's currently no good solution
Russ has another constraint called
manipulation through resource
representation and that means that a
given resource includes hypermedia links
that describe how to manipulate it for
example how you modify delete or replace
it in graph kya when you're at a node in
the graph there's no standard or
built-in way to access all the mutations
that could affect that particular type
for that particular instance
however you might argue that graphic
feel has something more general
introspection introspection is like
reflection for your API and it's the
core feature that enables us to build
tools like we just saw with graphical it
also allows us to generate typesafe
client code and some other integrations
that we'll see later
by contrast it's difficult to imagine to
introspect REST API is in a standard way
maybe something that resembles a sitemap
I don't see a lot of those that allow
anymore
in any case it's not mentioned in the
rest of constraints so it's any
implementations would immediately lack
standardization
and as a result of introspection graph
QL features strongly-typed
inputs and outputs rest has a hard time
pulling this off partly again because of
the decentralized approach to Federation
you
and modern api's commonly have to deal
with clients that observe changing data
rests stateless protocol constraint
makes this difficult it makes it
difficult specifically to build
efficient push-based api's that know the
state of the history of what was already
pushed to that particular client graph
Gale doesn't have this restriction and
the subscriptions it actually makes
real-time data a first-class use case
the trade-off here is that subscriptions
are stateful and therefore it adds a
great deal of complexity to the
underlying infrastructure that said
subscriptions support is optional
building modern api's is tough there are
a lot of challenges so we're gonna dive
into a few of them in more detail and
see how graph QL deals with them or
doesn't deal with them and the first is
efficiency within a single network
request response between a client and
server to common problems occur the
first is over fetching and that's when
the client made a request for some data
but the response contains additional
data that the client didn't ask for and
the second is under fetching and that's
when the client makes a request but the
response doesn't didn't contain enough
data
and that forces the client to issue
another Network request and under
fetching is especially common with the
rest architectural style because the
better you get at implementing the
hypermedia constraint the more common
under fetching becomes and these are
huge problems because networks suck I
mean I mean seriously that here's some
commonly any latency numbers so if we
try to read 1 Meg of sequential data
from a modern SSD it's gonna take about
1 millisecond while if we send a packet
from the u.s. to Europe the round-trip
time takes about hundred 50 milliseconds
so the network is exponentially slower
than just about everything else that
happens in a typical application stack
and that's assuming that we're on a
really good network
with mobile devices the networks are
even more unreliable subject to
interference from solar flares or other
devices buildings vehicles terrain in
many parts of the world wireless network
quality caps out at sub 2g and data
usage is heavily metered
and to get a better sense of this
problem I have a demo that we can do
together so if anybody has their laptop
here wants to follow along feel free to
open these two URLs and your browser in
two different tabs give you a moment if
you want to follow along just raise your
hand if your enterprise if nobody's
interested I'll just do that okay cool
yeah take a second
you
okay we all set
that first URL swap eco takes us to the
Star Wars API and says all the Star Wars
data you ever wanted planets spaceships
vehicles people
and this is this is great this is I'm a
huge Star Wars fan by the way
but this is great you can see you know
you've got this URL and it seems like
people slash one is the resource
representing Luke Skywalker and you've
got a bunch of data here telling you
about his his birth year is gender a
homeworld the relations to films so I
guess this means the films he appeared
in the species the vehicles now let me
point out a couple of things this this
films this film's one this URL here what
what is the shape of the data that this
thing is supposed to return
it's probably JSON right but is it is it
going to contain something called title
is that an immediate field in the root
of the object or is it nested in there
somewhere
what about the director does it have
that information I I just don't know
just from looking at this I kind of have
to go through this hyperlink to follow
through and take a look right so let's
do that let's let's check out what films
slash one is
so I guess right so I mean there is
something there is a title field it's
called a new hope this is episode ID 4
it's got opening crawl and then it's got
this bunch of characters all the
characters that appeared in your hope I
guess so imagine that we had a
requirement that was for the film New
Hope display the names of all the
characters that appear in a new hope
right I mean just as humans we can kind
of do this we can kind of take the role
of the Machine what we're gonna have
what are we gonna have to do we're gonna
have to click every single one of these
links and say ok I guess people one is
Luke and this one's c-3po and this one
is r2d2 but every time we click one of
these links this is another network
request if we're in the u.s. and this
servers in Europe well that's like 150
milliseconds for each request and we're
sending these off in parallel they're
gonna have to come back some of them are
gonna fail I'm gonna have to retry some
of them and I have to join this logic
back on the client
um so I think that's that's kind of
illustrating oh yeah and also look at
this this opening crawl thing that in
our requirement that wasn't even part of
it but this is a huge chunk of text and
this isn't even the only piece of
superfluous information so in this Star
Wars rest api given that requirement
we've seen a real-world example of both
over fetching and under fetching it both
gave us too little and too much data
which is not good if we're trying to
build really efficient mobile apps that
that can operate over flaky networks
luckily that second link is that same
API that same data but rebuilt with
graph QL and just like the library demo
we saw earlier we have this root query
and we can come in here we can see
immediately what is the shape of all the
different nodes that we have in this
starwars schema so let's try to fulfill
that requirement earlier right we wanted
to get all the characters names from a
new hope well I can come in here and I'm
gonna use shorthand notation if you
don't specify the query type and this is
the only query in the in document then
it automatically infers that it's a it's
a query type and you don't need to give
it a name so I can say all films and
within all films it says it's of tight
film connections so let's just get the
films out of it and let's try to guess
yeah so it has something called ID great
so it looks like this is the one that we
want and there are actually a couple
ways to slice at this where I only want
on you hope probably the easiest one is
I can just say first one right everyone
with me okay next in the film hopefully
there's something called characters
right there's a character connection and
you know we can we can just start typing
and we get type hints from graphical
because of the introspection query right
but just as just as easily we can come
in here into the into this thing and
search characters what's what has
characters and you get a lot of this
documentation for free so the character
connection I can say well for each
character I could get their IDs this
looks pretty promising
you
there you go I have all the characters
names from the film the first Star Wars
film a new hope in a single Network
request/response round trip with zero
over fetch and 0 under fetch this is the
exact data I asked for and nothing more
nothing less
now I want to stop here because you know
it seems like there's a lot of
experience in the room dealing with rest
api's and some of you're probably
thinking well we can do this with rest
api's absolutely can there are lots of
ways to do this right we can create a
custom end point we can create a end
point that's like Star Wars Co slash all
character first names from movie with ID
and then pass in ID as a query stream
how many people have done something like
that yeah so you know I'm talking about
we can do it another way we could we
could in order to get this nesting
filled structure we could pass it in
with it with query and we can say fields
equals whatever as a query parameter but
let's say our requirement changed ever
so slightly let's say our requirement
was that we want the character and we
want the home world or something and we
want the orbital period for whatever
reason I don't know I'm a huge Star Wars
if I did this what am I gonna do am I
gonna go and create another swap eco
slash characters and their homeworlds
orbital periods with ID this is not a
solution it takes you a little ways
forward but you can imagine for for
certain apps at certain scales this is
not a tenable solution for very long so
that's a good opportunity to kind of
mention that kind of a lot of people
think about graph QL as this client
oriented query language and it is but it
also makes the server engineer's life a
lot easier you can think of it almost as
is this engine that can create on-demand
rest endpoints where you don't need to
go and and and have a new end point and
a new endpoint has new authentication
authorization requirements and now
you're going to monitor it and deploy it
and gonna version it it's just a
headache whereas expanding the query
in graphic you're adding new
capabilities to a graph QL schema is
simple
okay so hopefully guys trying to follow
along with the on your laptops you can
keep exploring these two api's and let
me know if you have any questions
afterward
so we saw how graph QL can help us avoid
under fetching and over fetching it lets
the client declaratively specify all the
data that it needs in a single network
round-trip and it reduces the need for
complex client-side logic to deal with
error handling and retries client-side
joins we also got type safety out of it
through the schema graph kill provides
type safety for these requests and that
improves predictability because a client
never has to send the request to an
endpoint and then guess at what it's
going to get back it has a high level of
confidence about the shape of the
response and this is really useful for
native clients that are strongly typed
or gradually typed because it enables
compile and build time type checking to
help detect mismatches early on in the
development feedback loop and at
Facebook this allows us to generate
typesafe client models that correspond
to the graph Gale queries in iOS and
Android and I take advantage of full
advantage of the type safe languages of
objective-c and Java
graphical also enables another very
interesting non-technical capability for
your api's
and that's fluency for modeling the
business domain how many people here are
familiar with domain driven design okay
a few of you domain driven design is a
book by by Eric Evans in 2004 and it has
this really neat set of ideas the
central idea is that people across the
business both technical and
non-technical can build this shared
vocabulary called the ubiquitous
language and the ubiquitous language is
just natural language that describes the
business domain in terms of entities
processes and relationships and this
kind of natural language lends itself to
being modeled as a graph this means you
don't have to talk about the business in
terms of tables and rows and joins and
stored procedures or you know how to
talk about them in terms of resources
and your eyes and HTTP operations the
the entities and operations on those
entities can just be spoken and reasoned
about in natural language and I think
this is an incredibly subtle but
incredibly powerful feature that graphic
ale brings
versioning you know the web has spoiled
us if your app only has a web client
then then you get to dictate the version
that the client is running because the
user is essentially read downloading
that app every time they hit that URL
however it's not the case with native
apps as I'm sure many of you are very
well aware and if you use Facebook on
iOS or Android you'll probably notice
frequent updates but you have a choice
to update that app or not so you can
imagine that we have a large number of
different versions running at any given
time how does graph QL handle this well
how would rest handle this
would we version the API route will be
have we have thousands of those would we
pass in the version as a query parameter
we pass it in as in a header and the
mime type or something or the content
type will be baked it into the access
token
none of these are scalable solutions
we've tried so graph Gail deals with
versioning by simply not doing it
and that means graphical servers must
rely on backward compatibility and
forward only in versioning strategies so
and and to do that we can use the schema
and deprecated certain fields we can
mark certain fields as saying you know
we want to remove this as soon as
possible please stop using it and then
one of the following scenarios occurs in
the ideal case clients respect this
message and they migrate away from using
it and we detect when that field stops
being requested and then we can remove
it if the clients don't migrate then we
have two choices well we can either if
we value backward compatibility and that
older version of the client to continue
to work then we can keep the field
around and maintain it forever
or we can just say that version is too
old it's more than five years old we're
gonna stop supporting it and we will
just break that version and that's in
the you know that's but that's a
business decision decision
we've already seen graphical in action
and we've seen some pretty cool features
like inline documentation type hints
syntax highlighting execution but it's
important understand that all of these
features are powered by graphical
introspection and introspection opens up
this world of possibilities for tooling
and integration for example my teammate
Hyo has been working on something called
graph QL language service and this is a
package that will allow you to add some
of graphical capabilities to your
favorite IDE check out this demo of it
working inside
vs code
so we can write a query inside vs code
we get type hints we get inline
documentation we get type checking on
input parameters
you
and we get click go to navigation go to
definition on fragments and related
types and of course we also get that
same validation the same validation
capability as we saw on graphical it'll
tell us when we've declared an invalid
field will tell us when we violated the
graph QL language syntax itself
authentication authorization I think
this is such a common problem for aap is
that it requires it's dedicated we
should talk about in more detail this is
two concepts are often confused one on
there so let's quickly refresh
authentication were first identifying
who the caller or user is I mean this
can be done for example by including an
access token in the request header and
the first thing the server will do is
check the signature and the validity
window of this access token and then the
authentication requirements are usually
domain agnostic they don't vary with
domain and they'll go something like
this if the user can prove who they say
they are let them make the request
otherwise don't even bother cracking the
request to open or executing any more of
it authorization on the other hand
refers to whether the authenticated
caller has permission to perform a given
operation for example if we're building
a blog we might have an authorization
rule that says only authors and admins
can see posts in the draft state
authorization rules are usually domain
specific and therefore they belong in
the business logic layer I think a
diagram will make it all a lot more
clear
so you can see up at the very top we
have our transports and imagine that the
client is floating somewhere above this
slide and sending requests to our server
and these requests come over some sort
of transport
perhaps HTTP perhaps some custom
protocol and at some point the server
providing those Network transports has
to authenticate the incoming request
and that's also a good place to reject
in unauthenticated requests if
authentication is required for for that
endpoint for that API and you can see
that graph QL rest RPC these kinds of
techniques kind of sit in the middle
they sit in the middle of the transport
and in front of the business logic and
notice that I've put otter ization into
the business logic layer this is a
little tricky why should authorize a
ssin live in the business logic layer
a lot of newcomers when I start with
graph QL they get really excited because
they see how easy it is to build the
schema and they start adding business
logic into the field resolvers and
they'll add authorization logic there
consequently but if you do that this is
what it looks like right what's wrong
with this
well there's no single source of truth
across the different ways we can invoke
the business logic anymore we would need
to duplicate the authorization logic
across rest and RPC probably not a good
idea
we might get inconsistent behavior
depending on whether the user calls in
to us through rest or graph qaul another
way to think about this is how how we
would test our business logic if we had
a requirement from earlier like only
admins and authors can view draft posts
how would we test that ideally we should
be able to write a unit test that
isolates the business logic layer but if
we structured it this way then at best
we have to write an integration test
that involves graph QL as a superfluous
dependency just to exercise the
authorization logic probably a sign that
we made a misstep somewhere
so I think this is this is the diagram
that we think makes the most sense for
graphical on how to think about how
graph QL fits into the stack
now that we understand some of the
problems that graph care was designed
not designed to solve but I want to
emphasize that graphical as a tool it's
not a silver bullet it has certain
problems that it's good at solving and
other problems that it's not so good at
solving and part of our job as engineers
is to understand the shape of the
problem and finding a good problem
solution fit for example I wouldn't want
people to use grass field just because
they think it's cool or because it's new
but aside from the specific problems
that graph QL helps you address there's
another dimension to consider which is
when so you think you have a problem
like this but when should you deploy
graph QL and this comes up frequently
enough that I think it's it's worth
addressing in a fairly general way for
example if you're building something
like a hello world app on a white
background in a web browser it would be
silly to reach for some heavyweight UI
framework like react or angular and the
same is true for api's there's no
there's no real payoff for trying to
future-proof
everything but then just how do we think
about it here we can turn into the
something call the design stamina
hypothesis this is a this is an idea
proposed by martin fowler and he asks
what's the point of good design because
if you start off with no design nothing
gets in the way there you don't think
about how to do some specific thing of
some specific way so you have this very
fast initial velocity where you can get
a lot of cumulative functionality in a
short amount of time but as you continue
with no design that curve tapers off and
it becomes increasingly more and more
difficult or takes longer and longer to
add the same amount of cumulative
functionality consequently if you had
started with good design you are there's
an opportunity cost any time you spend
in getting better infrastructure better
documentation training whatever that's
time spent not coding or testing or
understanding the customer and if that
happens then initially at least for a
period of time it will be it will
deliver less cumulative functionality in
a given span of time compared to no
design
now notice that these two lines cross
over and this is called the design
payoff line and what the design payoff
line is saying that is that at a certain
level of cumulative functionality or
past a certain amount of time could
design winds and this is this is a I
found this to be a very generally useful
way to think about when to do X so so
graph Gale is no different try to think
about graph QL in this kind of framing
you
great so hopefully we have a fairly
decent understanding of graph QL now we
have these understanding the problems
and what graphical is good at solving
what it doesn't actually try to solve it
all now some of you might be wondering
how do we get into production you like
these ideas you want to try it out well
every organization is different and your
mileage may vary but here are some
general do's and don'ts when trying to
get graph QL added to your set of tools
in general try to prefer small
incremental changes over large overhauls
deploy in a forward only way and leave
v1 and v2 side by side for a while until
all clients have had a chance to migrate
specifically don't try to build the
entire schema if your business is in
building blog posts for example model
only a small portion of the schema it's
ok
model the minimum useful subset of it
don't try to replace rest in one push or
perhaps not don't even try to replace
rest at all don't place business logic
in the graph QL layer you'll probably
pay for it later
do work with your team we've we've we've
people get really excited about
graphical after they get it and they're
like oh yeah it just needs to go into
production and it's you know that's not
going rogue on this is not the best way
most distressful strategy talk to the
team try to help everybody understand
where the winds are why this is a good
solution for the problems you're looking
at and then choose a solution that fits
with your stack so I mentioned that
graphic URL servers are available in all
sorts of different programming languages
there's no reason why anybody has to use
the reference implementation that we've
written in javascript in node
build a simple query first perhaps even
something that requires no
authentication something like a message
of the day that you can show to anybody
build that first along with a minimum
useful subset of the schema and then you
can start figuring out how graphical
queries work from the client how they
work on the server and that means you
can gradually expand out and add
features like auth and mutations and
then I mentioned this before but it's
worth repeating but gradually expand the
scheme
you
so here's some advanced use cases I
think we're going overtime a little bit
so I'm gonna I'm gonna hurry this up
but graph QL is is clearly an edge API
technology that means people use it as
an API gateway a lot so if you have
micro services rather than having the
client know about the URL all those
different micro services you use graphic
QL in front of those micro services to
create a consistent and cohesive API
endpoint for the client to interact with
graph QL supports both third party and
third party use cases Facebook uses this
as a first party API solution github
uses as a third party API solution and
we've also seen it used for service to
service communication it's it's it's
really interesting that people are using
it for that but it works great skip over
that um you might wonder okay well that
what prevents clients from sending
malformed queries or queries not
necessarily malformed legal but are
extremely inefficient or infinitely
nested there's a there's a technique we
use a face book called the persistent
query and a persistent query basically
hashes all queries ahead of time and it
rejects any queries that are not hashed
and that way we can control the maximum
complexity of any given query what's
next in about two weeks there's an event
called graphical Europe where we're
going to be making some important
announcements about the progress we've
made on subscriptions situations is in
an RFC state right now but it's going to
go into the reference it's currently
being reviewed to go into the reference
implementation and the specification
we're also gonna see a rise in support
for persistent queries from our partners
and we're also going to see some really
cool experiments like batch defer and
live queries so live queries are
particularly interesting instead of
using subscriptions view to observe data
we can execute our standard query
operation but we can we can decorate it
with a special directive called live and
that tells us that that query should be
a living query I don't want just one
response I want a new response
containing the Delta anytime that query
would change
and of course we'd love if you were able
to contribute back to graph QL there are
many ways you can of course participate
in the design discussion of the spec you
can PR features to existing graphical
servers you can build a new graphical
server in your favorite language if one
doesn't exist and you can start working
on twilly integrations join a local meet
up and talk about graphic QL talk about
your journey or just hang out in our
slack channel be helpful so that's it
here are some resources as I promised I
hope I've equipped everybody here with a
clear understanding of what graph QL is
the problems it was designed to solve
and the associated trade-offs so if it
sounds useful to you and you have some
ideas if it sounds useful to you
hopefully also have some ideas of how to
get it into production that's it I I'll
leave this slide up and we'll do some
Q&amp;amp;A but but thank you very much for your
time and I really create you think</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>