<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>From REST To GraphQL (aka GraphQL in Production) | Coder Coacher - Coaching Coders</title><meta content="From REST To GraphQL (aka GraphQL in Production) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>From REST To GraphQL (aka GraphQL in Production)</b></h2><h5 class="post__date">2018-04-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fQlV0AzDxe4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">first of all let's talk about rest rest
is pretty awesome you can you know
you've got that separation of clients
and server code you can not update the
server and still have like mobile views
and and just different views of the same
stuff and yeah it's great right we all
loved our DRF but there are some issues
with rest one thing was that we were
noticing a lot of performance issues one
thing is when you're trying to get
related data so you've got you know you
normal ListView that's cool but what if
you want like a dashboard view and so
you want to show a lot of related data
you know you have to go into this nested
structure each one of those endpoints is
like a different request so that takes a
long time because you need a lot of
requests another thing is the amount of
time I was seeking for serialization
that ended up being the vast majority of
the performance issues we were seeing
per request for example our user
resource you know so what 7-piece does
is we have a performance management
platform so you can set goals you can
have meetings with your managers and
give peer feedback and give peer
recognitions and a lot of all of that is
user focus right so we're sending the
the user with everything our user
extended user resource has 34 fields in
it only four of them are important so
we're wasting about 88% of the data that
we're getting back from the server
so Rasmus still working for us
performance issues aside but then the
designers came up with this dashboard
that to build it looks like this you
know you can see my objective my
objectives or my goals the tasks that
are related to those goals the overall
progress and stats my latest update to
the goals but then this is also on the
page and all of the goals related to my
co-workers and my manager and then just
for fun
some summaries about the organization
and the team that I on so for an example
bunch of data that we need to get from
that we were shaking in our boots about
like how we were gonna do this with rest
right and so we had a little bit of a
challenge my coworker Tony had used
graphic you all before he thought this
might be a good time to check it try it
out he and I had a little bit of a
friendly competition going I would try
to use our REST API endpoints I didn't
have to worry about versioning I could
like reduce the number of data I was
sending per resource and he was going to
look at graph UL the winner of this
challenge if I won I would get to name
his about to be born baby boy my mom I'm
Filipino
my mom is a travel agent we have weird
names she knows someone whose child is
named spaghetti 88 so I was just going
to take that so so Tony's son was going
to be named spaghetti 88 angrily so and
if he won he I would not get to name his
son
so I was on and our results were with
rests this is what it looked like in the
chrome inspector but the network calls
there were a lot of them and in craft QL
it looked like this so comparison of a
ten point three seconds overall in five
point five a lot of that is just loading
stuff so what is this crazy voodoo magic
like and how how do we actually use this
in production we wanted to know there
were you know the security guys like
what about this and what about this and
what about this and we're like uh I
think we can solve them so as many of
you know github is one of the major
players to move to a graph QL API and we
all love and trust github right so if
they could do it we could do it we
actually did it about the same time and
I'm just going to show you quickly a
little bit about what that looks like so
here is the graphical app it is awesome
it's like swagger but way better or the
Django rest framework stuff so I want a
new query and so I am the viewer let's
see I want some repositories and I only
want to get the first ten and this is
weird stuff that I'll go over briefly
later and let's see oh those have some
issues cool
no I don't want that right now because
this is just a demo but let's see where
that comes up so so I can see my name
I've got a few repositories in here but
pretty much graph key well you can
it's a query language it defines how you
query data from your api's it's similar
to SQL which is a query language for
your databases but this is above the
layer of databases this is API business
level logic you can have totally
different models in the backend from
what you displayed in the front-end and
that's actually highly encouraged so
according to github
the ability to define precisely the data
you want and only the data you want is a
powerful advantage over REST API some of
these advantages include yeah the data
that you want and nothing more
nested fields and strong typing so does
it play well with Django the answer is
kind of since this is really powerful
for front-end and JavaScript and
especially react so Facebook I forgot to
mention Facebook was where the people
who actually created graph QL they've
been using it internally in production
since 2012
they had this issue with getting too
much data especially for their mobile
app that doesn't need as much data as
their website and they open sourced it
they announced it in January 2015 so
about two years ago open sourced it
about half a year later and now you know
it's just grown and evolved over time
but because it's more for the front end
I think the JavaScript communities have
really taken to it there's like five
different versions of it in node and in
Django we've got graphing which is
pretty cool it's pretty easy but there
are some drawbacks
so here's a github readme for it so you
can just use in Python it has hooks to
work with Django especially their ORM
you can also use SQL alchemy and maybe
peewee sometime in the future that's
been there for like a year so how do we
set it up it's like two seconds pip
install graphine Django add it to your
installed apps and set the URL that you
want Olive graph QL to go to so graph QL
it has a single endpoint and you send
the data that you want in the query and
your variables either through the get
query parameters or through the post
body so that can be anywhere I'm calling
it graph QL it also has it comes built
in with that graphical app which you can
explore it everything with so so that's
it mostly then you have to define your
queries and your schema it's as simple
as this if you're using Django you just
say hey I've got everything in red by
the way sorry for anyone who's
colorblind hopefully you can see it but
like Django object type is in red I
wanted to do that
so you can see what exactly is coming
from the graafian library or the Django
graphine library so it wasn't so long so
yeah
say it's a Gengo object type you're
creating a node and it's gonna be based
off of this model the task model in
Django you also have to define so beside
you nodes you have to define how you're
going to enter the schema so your root
query so here I'm just saying its goals
because this is the kind of data that
I'm working with in my company and then
you can resolve goals in a certain way
by saying here's the query set to look
at and then add it to your schema so
here's a little bit of a drawing that I
overlaid with things I got from the
Apollo blog thanks Apollo
so you've got the triangles is where
you're entering the schema and then you
can use graph QL to traverse the rest of
it and the yellow bits are the nodes and
then all the little things coming off of
it are like fields of that node so
graphene will take that automatically
from your Django models you can exclude
things of course you can also define
custom nodes so for the user node if I
want full name I can say full name is
this type string and string is from the
graphene library and then resolve it and
so whenever you have result anything
that's like a field you can have a
resolver for and I'm because I'm going
to talk about resolvers later a bit so
you can say what it returns great so
that's pretty easy so I'm just gonna
show you a bit about all that stuff I've
done just now what that looks like that
will get us this goals I've got some
tasks and they each have a name okay and
yeah so that's it for now so that gets
you that and so you can use this on top
of any project that you're using
regardless of whether you have a REST
API or not so next to adding filters and
pagination this makes it a little more
complicated so you've got goals and name
and progress but how do we get certain
things like what the total count is and
how do we do pagination and filter on
them so these red arrows are now going
to be called connections we're going to
add a few different things and so when
you are when you have like a many to one
or many to many relationship it's going
to now be called edges so that you can
do things like get the total count of
the edges or get these things
cursor for pagination and I'm just gonna
and then you can also use you can filter
you see Oh No
ah anyways it also adds it also adds
filtering so how you get that is
something called relay Facebook relay
has is kind of like Redux for JavaScript
it but let's not worry about that you
you don't have to use relay in
JavaScript to use the relay pagination
features in graphene so all you do is
say I'm using this relay node interface
and that changes all of your connections
to changes your list su connections and
then you can use something called Django
filter connection field and that adds
the ability to define your Django
filters class that you want to use and
so you can use your Django filters on
every node lastly or almost lastly we
have kind of built in documentation
which is one of my favorite features of
graph UL so I can just say here is the
description of this field and then what
that ends up looking like is in these
docs
I can go into query I can look at goal
node I can look at Oh No
sorry that is a mistake where did I add
it to anyways ah here so if I go into
progress I can see the description just
in here
but you can also you've almost never in
need descriptions because they should be
describing themselves
ideally hey then there's a lot of other
fancy stuff that you get which we're not
going to talk about but if you have
questions you can ask me outside
and pretty much the answer is it can do
everything pretty much everything that
you want it to do you might need a
little bit of tweaking but we've added
our own new fields we can return
different jangle model types on the same
node using unions
everything like that so you've got some
pretty cool stuff
there's some pros for graph QL it's like
self explorable like you don't have to
set anything else up and it's pretty fun
you've got easy documentation I find it
personally more intuitive to implement
than Django rest framework and that's
just on the back side like you know in
building AP is there's a whole load of
benefits for the front-end so what makes
what are some use cases that make it
better than rest so as we saw that
before those complex views if you want
summaries dashboards stats they your
nodes don't have to be connected at all
to Jenko models you can return whatever
you want so we have a stats node that
does a lot of processing in the backend
and send it to the friend and we were
good this way that you know that was
about September to November we were only
using graph QL for complex views and
gets but then we had this other
challenge we were building the feedback
forum and we wanted to create a survey
builder that would autosave and the
front-end people had tried implementing
it already in rest there was like all
this stuff we were using like reactive
like rxjs to to do certain things you
know determining when you're creating a
new object so a post versus when you're
updating an object versus when you're
deleting it things have to be done in
the right order and if you if something
fails you have to remember what else
needs to come back come after it
so we had this idea to use graph QL for
it and it ended up working really well
so instead of doing each item we just
like send it a big payload
and the backend it's up to the backend
to figure out how to save everything so
that what's in the database actually
looks like with a payload that you got
so if you got a successful response you
know that what you're showing is
actually what's on the backend and you
know you could do this without graph UL
but the benefits of doing it with graph
QL are the type checking you don't have
to check each input that yes this is a
float yes this is a string because it'll
it'll do all that for you and give you
an error if it's not right
so there are these things called
mutations instead of queries so those
are the two main components of graph QL
and how you set that up this is what it
looks like in the end you've got a
mutation here you can pass in some
variables and pass those variables into
the mutation and then when you press and
when you send it what is in here is
another query and that's the data that
you get back that's the result of doing
those that mutation so you know have you
if you've ever had this problem where
you change some data something else then
changes and so you need to do another
request to see how it affected it that's
all in one request now and you just yeah
define what you want to return so you
can define some inputs there like nodes
but there's actually no quick way that I
know of of getting the input types from
the Jenko model you kind of to build
these yourself and in that way it's
different from a put or a patch because
you're not you you're not supposed to
think about it in terms of I have this
object I want to change this field to
this in this field to this it's more
like I want to mutate this object in
some way I want to do something to it
and the back end should have a better
understanding about what that means and
do it itself oops that was not supposed
to be like that
[Laughter]
so yeah you can define a mutation like
so you have the graph QL mutation class
you define what inputs you're taking in
I'm actually only taking in an int and a
float in this case and not the inputs
that I showed on the previous frame but
I wanted to show you how it could be
done and and then the goal part is
defining what node is being returned by
it so that's what you can query on when
you're actually doing the mutation for
your return data and then you do a bunch
of stuff make sure it's atomic and then
you just add it as a mutation onto your
schema that's you okay so looking back
at our graphical a viewer you know you
can see that where the different parts
fit in the inputs the return data the
variables
and so this simplifies the client-side
logic that they have to do you don't
have to yeah along with the gets and the
writes the front-end loves it if you
want to make your front-end developers
happy think about using it but what's
the catch and so this is the more
important part of the talk so one thing
is that graphene is the only library
that you know is really viable to you to
implement a graph QL schema and Django
and Python it was released about a year
ago and you can see since then there
hasn't been that much activity on it
there it is a young library and there
hasn't been a ton of contributions and
so there are bugs there are you know so
is released in 2016 the docs are not
super complete if you have questions
often you have to ask a question as an
issue in the in github also sometimes it
lags behind the graph QL specs so for
example total count is in the graph QL
specifications but as far as I know is
still not yet in the graphene library so
we had to build out ourselves there are
some bugs with the resolvers if it kind
of has some weird logic so we've had to
rewrite a lot of that logic about how
things get resolved because you know
first we want to return the resolver
query set then we want to filter on that
and then we want to do other stuff and
the order that it does it by default is
not right and lastly one of the big
things is that the source code is quite
complicated there's a lot of meta
programming in it and as someone who is
only an intermediate Python developer
it's kind of hard to dive in and make
the changes that you want to make so I
would say that's kind of the biggest
hurdle to using it so yeah the real
world is messy
and you're not gonna want to use
graphene exactly in the way that it was
made this is not actually spaghetti 88
just a baby I found in gippy but yeah
the real world is messy and graph QL is
just a query language it's not telling
you how you should do certain things
like authentication and authorization
and and caching and stuff like that
so we had to dress it still so first
what about permissions you know for us
permissions were a really big issue
because we have different companies
using our product people from one
company should not be able to see any of
the data from another company so one
option that is kind of what the graphene
Doc's say you should do is perform
authorization on each resolver and that
would be a pain in the butt we don't
want to have to call our our DRF
authorization class every time we want
to get a connection the other option is
to extend graphene to perform that
authorization on every connection which
is what we did and what I encourage you
to do it's not like DRF it doesn't have
all these hooks to like you know put
your custom logic here you know you have
to you have to actually extend the
classes what we did if any of you have
tried to do it so we first of all added
to each node what the DRF class that
we're we're using for authorization is
and then we extended Django filter
connection field
on the connection resolver we added the
user authentication so are they logged
in can they actually see any data and
then when you resolve the connection we
say okay from your node we know you're
supposed to have this authorization
class we'll apply those authorization
limits on the original query set and
then that's what you should use to do
the rest of it so that's pretty good
that's a solvable issue if not it's like
even though it kind of takes some effort
but what if someone is requesting too
much data
we've got denial of service doesn't
necessarily have to be an attack it
could just be someone who's requesting
too much data and it's hogging up time
on your server and so what we did
because you know you can traverse as
much as you want graph QL has some
things like you can't do cyclical things
so you can't have an infinite loop which
is good but you can just like have
someone like a script create like a
really big amount of stuff so what we
went with that first which is the
easiest way of doing it is having a
white list for the allowed query so we
actually had all of our queries in the
backend in Python and gave each of them
an identifier and then the front end
would have to call that graph QL query
by its name and so that way we were
allowed to say these are only the
queries that anyone can run on graph QL
that you know works oh it works up to a
point and it definitely had its downside
so we were trying to move away from that
so another thing you can do which github
first did is add a maximum limit to any
connection so there's at first was 30
now it's a hundred so every time you
want to get a list of stuff you have to
define how much you want they also have
implemented a maximum query cost which
is something that we have only just done
last month finally so you can say you
know you can max Axess
5,000 nodes on any given query and this
is how github calculates there's we do
it a little differently
but you know having it there is awesome
and it enforces limits as well because
we just said if you don't have a limit
then we're assuming you're getting a
thousand and something graph QL also has
is rate limiting based on query cost so
before there v3 API had a certain rate
limit
now you can't that rate limit doesn't
make as much sense since you can grab so
much more data so it has a different way
of calculating the cost that's based on
the number of database connections that
you're actually getting and so they rate
limit you based on that and so lastly
what about performance and for some
people this is the big elephant everyone
uses this so I add it to my slide so
sometimes these queries take a lot of
time and Django graphine doesn't really
at first especially at the beginning
didn't really do much to focus on
performance and it mostly focused on
getting it to work since v1 has came out
that was like a big performance
improvement but there's still a lot more
that can be done for example by default
it doesn't do select related and
prefetch related when it resolves the
query as it traverses it which is not
necessarily the it's not the most
performant something we also did is
reduce the number of count calls other
so something you can do instead is have
something that looks at the entire query
and and adds things to it and resolve it
all at once
so that brings us to the data loader
this is Facebook's answer to the
performance issues so initially like
without the data loader this could take
thirteen database calls for all these
different fields right it's a lot of
database queries but what the data
loader does is it analyzes everything
which returns a promise and then it
batches grabbing things so if you have a
bunch of users here and the friends that
have the same PK then you don't have to
get them multiple times you just get
them in one big batch so having a max
query cost also helps with the
performance issue and for us one of the
biggest thing is just front-end
education about how to use graph QL
since this was a back-end initiative you
know they were like okay we'll use it
that's cool and they really liked it but
they didn't necessarily know much about
it and they see it more as a back-end
thing than a front-end thing and so
they're like we'll get all the data
especially before we had the query class
and they were doing things like this
where they're saying I have all these
goals give me the idea of all of them
and then in the front-end I'm just going
to count the entire length and that's
gonna then that's all I need that we're
like I actually don't get any of that
and just get the count if you're only
going to show two like either the full
name or if there's more than to one
person than just the number of people
then just grab the first person yeah and
this is you know 34 comments on here
this is one of the longer issues in
github about graphene and you know you
can follow it it keeps changing its kind
of interesting he's added a whole bunch
of new stuff but there's still more work
to be done
so there are some considerations it's
still a young library I'm hoping Cyrus
isn't here today is he no ok the
maintainer like
I was hoping to like maybe we could
sprint on it tomorrow but I actually
don't know how much he's into that but
yeah I could use some work
because especially because graph QL is
just a query language and it doesn't
specify how to do things so how would
graphene know what to do about these
things yeah and then authorization
denial of service and performance are
some of the big things that you have to
look at if you are using it so should
you use it who is maybe considering
using it now after this talk that's cool
so go for it if it's just a side project
and for fun it is really fun to know and
to like have as a tool that you know so
also if rest is causing some performance
issues that you're like I actually don't
know how to get around this I could
replace all my serializes serializers
with something fast there but you know
that's a lot of work also if your rest
format is making it difficult to read or
write things and importantly though you
have the resources and like development
experience to know how to extend it in
the way that you want and you know hold
up just like back off a little bit I
mean you should still try to do it but
think about it if you have a lot of
sensitive information and/or you're
trying to create a public API in which
case you have to worry about rate
limiting and query costs and you don't
have enough development resources to do
it or not enough experiment experience
to know how to extend it so that's
pretty much it
there's a lot of great resources on the
web the zero de Graaff QL video is you
know probably the one that's posted
everywhere about a good intro yeah and
so thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>