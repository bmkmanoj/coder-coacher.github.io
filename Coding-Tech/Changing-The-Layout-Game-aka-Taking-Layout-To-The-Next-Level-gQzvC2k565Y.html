<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Changing The Layout Game (aka Taking Layout To The Next Level) | Coder Coacher - Coaching Coders</title><meta content="Changing The Layout Game (aka Taking Layout To The Next Level) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Changing The Layout Game (aka Taking Layout To The Next Level)</b></h2><h5 class="post__date">2018-03-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gQzvC2k565Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">but what I wanted to talk to you about
today is how ideas and hacks become
features in browsers layout itself is
just an example of this because it takes
so long to get layout features it's very
complex it has to go through a lot of
different things too for us to be able
to actually get layout features so to do
that we'll look at how we solve problems
by using features in interesting ways
and we'll explore how we use the
features of today to influence the
features of tomorrow and we'll try to
avoid absolutes along the way it's very
easily to get functionally fixed about
what CSS properties are designed for
what is more performance and language
like right and wrong because in order to
successfully experiment we need to be
able to do it wrong we need to be able
to use things beyond what they were
intended for so we'll take a journey
today from browser hacks and
experimentation to a future where we'll
have AP is that will allow us to write
our own CSS and then finally we'll talk
about what we can learn and do to help
us shape the future of features but to
do that first we'll start by looking
back around about 15 years because if
you think about it the feats of the main
feature that we the technique that we
built the web on was actually designed
for pulling images to the side of text
that was floats its predecessor the
table was difficult to maintain it was
ultimately complex and having the
content and the layout together so
tightly wound often meant that we would
break things when editing the content
and trying to find the source of that
breakage was very very painful the clear
fix hack enabled us to part ways with
tables by allowing us to place items
with floats and this particular one up
here was my first ever
fix hack there have been many but that
was my first going forward several years
the feature that enables us to serve lay
out two different devices the media
query originated around our need to
cater to different media types like
projectors and printers it was 2001 the
proposed the proposal for media query
was around long before the smartphone
ever existed it was actually quite
brilliant
even before trogdor the burner Nader had
first burnin aidid the peasants at the
time I probably had a phone that looked
something like this
the browser was mostly text-based and if
you were lucky your phone could play a
game of snake you definitely weren't
browsing the web on this phone it wasn't
till the rise of the smartphone and the
fluid image hack that we started to
adapt to different devices and this
particular hack used the fact that
defining one dimension the width could
preserve the aspect ratio of the element
and it was one of the key ingredients of
Ethan Marcotte definition of responsive
design and then retina came along and
ruined our bandwidth so we blew up all
our images to twice the size and we
saved it out at zero quality to have the
file size and I guess the point I'm
making here is we make pretty creative
hacks these are all examples of how we
solve problems creatively for the
features that we don't yet have and you
can actually trace a line between some
of these features such as compressive
images impacted sizes and the picture
element the fluid image hack influence
object fit and clearfix
is now built into a feature called
display flow root packs are actually our
desire paths and if you're not familiar
with what desire paths are they
represent the paths that people actually
want to take and some town planners use
these to work out where to actually put
new paths as creators of the web this is
one way of signifying where we actually
want to go so I believe that brilliant
hacks are actually a creative use of
feature
and there is a distinction to make with
hacks because there are brilliant hacks
and there are very dirty hacks the
brilliant hacks tend to use unique
properties of features to get the result
that goes beyond the original design
Theory Coblentz technique for intrinsic
ratio and his example of this kind of
brilliant hack it uses the fact that
padding is calculated off the width of
the box to produce a flexible intrinsic
ratio for something like video when we
make we use it responsibly another one
that I would sort of class in this sort
of in this definition is Haydn
Pickering's quantity queries which gives
us the ability to style elements based
on how many elements there are and of
course there are the dirty hacks which
tend to be about browser isolation email
is full of these because they have 23
email clients and no way to actually
standardize and they're sort of then
sometimes a necessary evil but you never
feel good about doing them and of course
there are the hacks just kind of hang
around like a workaround for inline
block because inline block does weird
things with whitespace but why do we
hack away these features well it's
because our needs often grow beyond what
our tools are capable of providing and
we can't expect standards organizations
doesn't necessarily see the future they
have to see what we're doing and layout
itself is a fairly good example of this
it's an incredibly complex system to
design and for the last 15 years that
have been mostly a process of hacking
things together layout is easily the
most hacked area of CSS and if you just
look at how many different features have
grids built around them table inline
block floats flex box you can see that
they've all been shoehorned into grids
if you take one of these frameworks
apart you'll see there are so many lines
of code to manage simple things like how
columns should behave when the content
needs to take up more than one column
what should happen we're looking at over
60 lines of code to define this behavior
and if you need to touch a media query
that's another 35 lines of code so
thankfully as Rachel said now we have
declare
of grids all of those hacked grids
became a feature and with just a few
lines of code we can create the same
effect you define the grid you define
the gutters and lastly you define how
the columns behave the number of units
there is the number of columns and we
have fraction units and how fraction
units work is actually assigning the
available space to the number of
fraction units declared so one fr4 one
column two different one if ours give
you two columns and so on and the same
fraction can be written out with repeat
notation and we get min max which gives
us essentially a minimum with center
maximum width and the thing that I
really love about what grid gives us is
things are so simple like the idea of
creating white space we can just tell a
column to begin later than it would have
normally it's one line of code and it
works across rows and columns when we're
talking about the 60 lines of code to
define column behavior that ends up
being one line of code to do the exact
same thing and that same behavior
crosses in two rows we haven't really
been able to do this in the past without
messing up with them messing around with
the markup and this span which was the
thing that allowed us to go across
columns there allows us to build up
complex grids you start with the most
basic unit you have and then you apply
spans and you get some interesting grid
layouts and we can also use features
that are made capable of making complex
grids flexible across viewports now and
that's Auto Fiat which both Mike and
Rachel have mentioned already and if I
don't explicitly define any row auto
rows will take care of the rows that are
defined so you get a flexible complex
layout that you can easily manage across
viewports but what I get interested
about is when you start to combine
techniques with new features one of
those is getting paid and Pickering's
quality queries and meeting grid span so
you might define how it will behave when
there's just a single DIF and when there
are more than one div when there's sorry
there's more than four divs we might say
span - and you get something in which
you can add items to the grid and have
the grid start to adapt it goes across
rows and columns which is to me an
interesting concept now when we're
talking about simplicity CSS variables
add some more simplicity to what we're
doing and how we build and the thing
that I love about CSS variables or
custom properties is the fact that they
create relationships between values
where if you think about it all designs
have relationships that's the nature of
establishing hierarchies whether it's
the size of the visual elements or the
spacing between them CSS variables are
aesthetic ssin of formalizing these
relationships in code and here we're
able to simply define how column might
behave and then change it with a media
query later on and Mike's showing this
in his talk and then we're able to just
implement these things and allow the
media query to handle it
and we can use this for prototyping and
experimenting with these values much
easier you can build much faster with
variables whether you choose to actually
use the variables in production that's
up to you but for building this is
amazing and you can even simplify
feature queries so we've seen some
feature clear queries already in in this
conference but let's talk about the one
that Rachel showed us yesterday about
how grid essentially gets reset the the
the layout properties of non grid layout
get reset when you go in within the
feature query within the feature query
so in this case we just said all the
things here and we do it in the feature
query there with variables
and you just apply them and let the
feature query decide how those things
are going to be laid out and you can
test feature queries if you use app
supports and you're doing the feature
query and you want to see what the
layout will look like without the
feature query you can just flip the
feature query you can go supports not
and it will act in the Reverse so most
of the things I've covered so far about
grid about how designs work as pages but
our needs have shifted with the rise of
pattern libraries and atomic design we
came from a place of building pages in a
static way from sort of 640 by 480 to a
web that could exist at just about any
size and in recent years the pattern
library has meant we've begun sharing
the concept of the page the building
blocks of our sites and applications are
the components that need to live at any
size and I believe our first science of
moving this way were when we started
adopting content-based breakpoints but
this came at a cost
it meant that every time we needed to
modify a design we need a whole new set
of breakpoints and this come becomes a
maintenance nightmare I looked at over
50 popular responsive websites and I
found an average of 264 media queries
which blew my mind there are tools for
combining these media queries which
would probably have helped but it does
still speak to a problem that's there
that we're using media queries that are
page-level for something that is not and
that's no fault of the people doing it
it's the media queries I restricted to
viewports and media types and don't
really work for components an example of
this is if we wanted to define the
internal layout of a component and we
wanted to say that the component will be
a single column in a certain scenario
and two columns in a different scenario
unfortunately if you get that component
and you put it in the different scenario
immediately it's going to break because
the screen size actually has its
tangential it has no solid relationship
so it really leaves us between a rock
and a hard place
about how we approach sizing our
components so the dream is to be able to
define as you build the component once
and implement in as many places as you
can without having to micromanage markup
or CSS we need our components to be
modular so we don't have to have our
assets with brittle definitions of how
things should act the main paradigm
shift here is that changing from
building for a component to be served to
a device to a component to be served to
anywhere in a layout completely agnostic
of devices or screens there's a
principle in programming called the
principle of least privilege and it
means that things only need only
provided with the information they need
and in this case all our component
really needs to know is will it for the
space in Dan molds content display
patterns we can clearly see a use case
for something like this where all of
these things that we see on the screen
are actually an event layout component
they all have the same content but they
just displayed slightly differently
based on where they're positioned it's
clear that our need for media queries
has evolved and matured and you may have
heard of a term called element query or
container query and the name itself
doesn't necessarily matter because it
seems we can't seem to decide on what
that name is but it's the concept that
you could define how an element would
behave based on the space it has
available so you'd have something like a
default component and then we'd look at
how it would behave at a different size
and this is not real CSS but this is
sort of an example of what people were
thinking it would look like but it ran
into some problems the main issues with
the concept are infinite loops if you
can style an element based on how its
parent is or itself you could cause the
browser to crash because you would
continually Ray trigger that media query
the other is CSS passing because
ss only gets past at one particular
point in time and it's later on that you
have the information that this thing has
a certain size it turns out that there
are a number of different features in
CSS already that actually give us the
effect that we're looking for and Mike
talked a little bit about this already
the first of these is comes from flexbox
and it's a technique described by Zurich
Gillenwater first on how we could create
breaks in the content without a media
query the idea is that you flex wrap
with two fixed widths essentially what
happens is that you end up with a limit
in which the UI the the element needs to
be able to be within and of course if it
if it goes below that you end up
breaking to the next line and flex grow
allows it to go almost like it's a
hundred percent on each line and in
practice we might have something that
wraps and changes behavior as it
collapses but the problem is that it
will expand evenly and so as it grows
it's going to go in and in a way that we
might not want with the image and that
again is what Mike's already talked
about which is the Flex grow 9:09
variant which jiron Joran van he
introduced which is the ability to
freeze an item from going unless it's on
its own line technically it still grows
by one fraction over 10,000 but because
that's so small it loses to rounding and
that will still behave how the previous
technique would have when it goes to to
multi lines so it's how it behaves on
one line the other feature which another
feature which gives us this is multi
columns because with multi columns if
you don't define the number of columns
but you do define at the width of a
column when it goes beyond the width of
that column we end up with columns that
are created as they needed to so if you
combine these two techniques the
flexwrap technique and the column count
technique you end up with something that
is able to deal with line length issues
and we combine these techniques of
certain situations such as a feature
article preview and in practice it looks
something like this components that you
can drag and drop anywhere in your
layout and they just work unlike the
previous thing with media queries where
your component would just break when you
did it
as mentioned several times already grid
has this ability to but I'm not going to
dwell too much on that because I think
it's already been covered pretty well
and of course how component breaks
across size is not the only concern with
keeping the modular what images are
served can be important too certainly
for bandwidth but also for maintaining
focus and important parts of the image
unfortunately the picture element can't
determine if it's in a small area or a
large area and SVG is capable of having
its own context so if you load SVG
external to the page any media query to
find in the SVG is going to be treated
as is if the SVG is the viewport you can
also embed HTML inside of an SVG using
something called the foreign object tag
meaning we could embed the picture
element inside of an SVG and have it
believe that the SVG itself is the
viewport and trigger different images at
different sizes the problem with this
technique as Mike talked about slightly
yesterday is that in some browsers this
has some unexpected behavior where it
can actually download all of the images
so if you're looking for a production
friendly version of this I'd probably
use Mike's technique rather than this
technique so what other features are we
getting to aid us with this kind of
layout well we're getting something
called the resize observer and that is a
new API designed to allow us to
subscribe to the size of any element and
report that and respond to that size
accordingly
we can then respond to that change and
get informed of the dimensions and do
different actions based on that so this
particular API will actually allow us to
listen to CSS causing the change in this
case I'm just using width which you
would never do but I'm animating the
width and it's able to track that width
change now an old way of doing this
detecting the changes maybe if the
window is resized we quickly check if
the if the components had changed that's
a really really expensive thing
performance wise so resize observer
actually avoids the overhead of the
event system and it's very low cost to
performance and it's natural to come to
the conclusion that this API is designed
specifically to give us container
queries or element queries but it's not
all it can do because if I can listen to
the size of an element that means I can
actually tie two elements together that
are not necessarily part of the same
hierarchy and where might I use
something like that well if I had an
interface where maybe I had a wysiwyg or
something like that and there was a
toolbar and that toolbar was fixed and
not part of the same hierarchy as say
the column I might be able to manage
that toolbar slightly differently that's
just one thing that I came up with but
we have a problem because Rita's
observer is a JavaScript based API and
we still need to let CSS know what has
happened so how do we do that well it
turns out CSS variables are an amazing
way to communicate between CSS and
JavaScript we can get the variables
quite easily using this line of code and
we can set the variables with just one
line of code like this now thinking
about the fluid typography that was
brought up yesterday this is we've seen
quite a lot of challenges for making
this work and we've seen lots of
different libraries brought about to
deal with this such as modeling moulton
letting and feet of text there's even
seen one by Brent Jackson which uses SVG
to fit tight
for headlines and if we might already
explain his technique on how he creates
the ability for fully fluid type to have
minimum and maximum sizes but the thing
that I would really have loved is
something like a container with unit
which would be really excellent we'd be
able to size based on the length of a
line rather than a whole bunch of other
stuff so it turns out we can use the
resize observer to help us in this
situation and we could use resize
observer to give us container based
fluid typography now it's not important
what this code actually says so don't
worry if you don't understand it but all
it's really doing is reading the width
and it's injecting that width into the
CSS variable we have a resize observer
that just listens for that particular
element and in the browser it reports
that if you look at the very top line it
reports that to the element itself then
we have a component which has it starts
as a default of having a hundred
viewport units and we convert that to
pixels this this is so that we can use
this with Mike's calculation so
originally is it very begins it's
exactly the same as the calculation and
then injects the width straight in there
so we get something we get something
that at first is this no different to
that particular thing but once we start
to open this in chrome dev tools we can
change the width of a container and have
the heading actually change placed on
that container with which for me is
magic
so this technique is really useful for
techniques that use calc because you can
inject the width very easily in and you
can respond to that with calc but
unfortunately if we wanted to report
sizes to CSS we have a bit of a
limitation because it wouldn't really be
very helpful to have a class that was
called size 733 because if you had
something that was size 732 it wouldn't
capture it if you had something with
size 734 it wouldn't capture it it would
be useless a problem there is that CSS
can't range match a selector there's no
way of giving it a 500 to 700 in the way
that a media query would and of course
you can try to hack this as I did but
this is really really brittle because
this will match 77077 it doesn't matter
this is a bad idea so it got me thinking
what if we used resize observer to help
us calculate the area of a shape a
component lives in and then communicate
that to the component itself if we want
to adapt to that information we can
quite easily so if you look at examples
of element queries that people have put
on the web an article preview is often
the one that is the hero of this and if
you look this particular article it's a
bit hard because the contrast is a bit
off on this one but there's actually a
bunch of different shapes here that are
small rectangles squares and and tall
rectangles so the idea here is that we
use the resize observer to work out the
widths and the height of the element and
then calculate the ratio of the element
and we can match those ratios to shapes
like this so it's container shapes as a
ratio and this is an example in which
adjusting the height of a containing
element can actually allow us to reveal
certain elements as a proof of concept
as I change the shape of this it's
changing the class and it will suddenly
start to reveal different things based
on the shape of the element where the
element is capable of having and it
turns out the media queries are actually
just very good at this job they're
actually the only thing in CSS that is
really really good at matching a range
of values
so my initial thought was let's hack
media queries why not
unfortunately you can't inject the
variable straight into the media query
it's another case where you would might
end up with an infinite loop my next
thought was well there's a JavaScript
API for media queries maybe I can use
that but it turns out I don't even
really need to use that at all
in the component I could use CSS
variables to send information to the
JavaScript and just tell it that there's
a target minimum a target maximum and a
class that I want to apply based on that
then I use the resize observer to detect
a change and read the variables and then
determine if I need to add that class or
remove that class so we're able to then
size this based on that we open apply
classes based on the size of that middle
container now you might be saying at
this point but browser support because
this is a feature that only really works
in one browser at the moment and that
browser is Chrome Canary which isn't
even the stable browser and that's true
for the moment and if no one gets
excited about features like this I
guarantee we won't see them in
production for a long time so I believe
it's very important to play around with
things that are new and increase the
feet they help the feedback loop and
looking ahead we have some pretty
amazing API is coming and one that I'm
really really excited about are the
powerful API eyes that are going to be
for CSS will be getting the ability to
develop our own CSS features and
properties in a collection of API eyes
under the name of Houdini and I know it
sounds dangerous the idea of us
developing our own CSS it kind of feels
like the flash days it feels like people
hacking scrollbars and custom cursors
and making interfaces where no one can
navigate but we've all been through that
and we know better
so while entertaining that thought I've
been pondering the history of hacks and
X
imitation and really we do all those
things we've already experienced those
things and we know better so in
JavaScript there is a standards body
called tc39 and stage zero is considered
the strawman stage which is basically
people build a proof of concept and
people tear it apart it's actually very
useful for them to adopt standards but
we don't really have something like this
so well in CSS because you can't really
build a CSS feature easily and if you
build it purely in JavaScript it might
not actually be able to be implemented
so Houdini will give us the ability to
write our own animation paint layout and
custom at roles and we'll be able to
provide these proof of concepts to
actually validate that something is
possible that we can implement these
things one that I'm quite excited about
is the ability to do custom about rules
because of the things that I've shown
you here with resize observer there
might be the idea that we could
communicate the container shape or maybe
even just do a container query and it's
really exciting that we'll be able to
delve into designing and building
browser layout from the ground up but
unfortunately layout is a bit of a black
box there's a whole new terminology
we're going to have to learn and we're
actually gonna have to learn how layout
works properly because up until now CSS
is abstracted this away from us
there's a lot of terms that we just
don't know ideally we'd have this CSS
property and a value called layout which
would implement our custom layout and in
the JavaScript worklet for layout which
will be attached to the appropriate
render time browser rendering time it
will recognize this thing and be able to
use it and we'll give it a call back
inside of it that it will allow to it'll
be able to render with now I'm not going
to go into too much detail about code
that would be inside that block because
the detail of implementation is still
being decided on this there's no real
point in me going into it it'll be
probably be completely wrong so the best
sauce to go here is this link at the
bottom which is the Houdini layout
explainer there's a lot of information
there
and believe me you'll spend a long time
just trying to get your head around it
moving away from that
implementation-specific code I think
it's important to think about the things
in which we'll be able to do which is
we'll be able to write layout that can
define how child element positioning and
placement work will have the ability for
child elements to have flexbox or grid
behavior will have layout fragmentation
so it'll be able to work like columns
ultimately it's going to redefine the
way in which we build for browsers and
it also give us an understanding as to
why layout is so hard why can't we have
container queries or element queries why
it seems so easy but we'll actually
understand the real truth as to why that
is really really hard so this comes to
point in my talk where I asked how we
can actually shape the future of
features with experimentation and hacks
and that's by looking at how hacks have
been adopted it might seem that these
things are just workarounds but the more
we talk about the problems were actually
trying to solve the more levers spec
riders and implement it's get the
intrinsic ratio hack I hope I told you
about earlier on is now a proposal
called aspect ratios lives and advocacy
creates impact through writing demos
talks these get us the features we want
because they get exposure we didn't just
get CSS grid by accident we got it
because people like Rachel advocated to
get it for years and we can experiment
with things that don't have cross
browser support right now we will get
the features eventually it's not a waste
of time
these features will gain support and the
more we write and talk about them the
more likely they'll be implemented
correctly by taking on these features
early we can create a feedback loop to
help us get the best version of these
features and there are many groups that
can help us with that the first is the
web web incubator community group which
is a lightweight venue for designing
proposal of new browser features many of
the Houdini features
that I've talked about have actually
started out here then of course there's
the Houdini task force and they have a
github page here which has about a
hundred and twelve issues open and as
Rachel said yesterday there's a CSS
working group the hacks and
experimentation we do create visibility
and they really show the problems we're
trying to solve defining those problems
we have is often the first step of
getting the features we need to solve
them and we're doing so we change the
game thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>