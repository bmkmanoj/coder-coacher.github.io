<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Going Over The Speed Limit: Synchronous Rendering in React Native | Coder Coacher - Coaching Coders</title><meta content="Going Over The Speed Limit: Synchronous Rendering in React Native - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Going Over The Speed Limit: Synchronous Rendering in React Native</b></h2><h5 class="post__date">2018-04-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/z44gdjzI8Dg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this talk is about pushing boundaries
and I want to apologize in advance if
it's a bit technical I try to keep it as
pleasant as possible but we're gonna
talk about interesting problems and
interesting problems require that we go
under the hood and email did a good job
in his talk before mine and he explained
some of the concepts that I will rely on
so I'm very happy that his talk was
scheduled before ok let's go ahead first
I want to introduce myself if you don't
know me already my name is Thao and I
work in which comm Wix is a platform for
small businesses to manage themselves
and it all starts by creating a
beautiful website and it's not a small
platform we have over 100 million users
we're big believers in react native the
Wix app which you can see here on the
right is written a hundred percent in
react native we kind of switched all of
our mobile efforts from pure native to
react native in the past two years I'm
originally a native developer and being
in production with react native for a
year and a half almost two years teaches
you a lot and that's really why I'm here
so performance in react native are we
there yet so you know in software
engineering you always try to find the
best tool for the job and whenever I
start creating a new app I asked myself
is react native the best tool for the
specific use case of this app and this
is a react native conference so you're
probably asking yourself is there a use
case where this person would not use
react native and the answer is yes if we
have to be honest so if I were to write
for example
whatsup or Facebook Messenger or an
instant messaging app I would not use
react native for that why because the
performance overhead of react native in
this specific use case outweigh the
productivity the amazing productivity
boosted this framework it's and as you
know me I'm obsessed about performance I
do a lot of work in this space if you
read my stuff and I know I always ask
myself did we squeeze everything out of
this lemon I mean do we have more to go
so first of all there is a test you know
that's a phrase we coined in which the
Pepsi challenge how
do you know if we're there yet so this
is a way that I really recommend you do
is you try to take a nap a very simple
one and try to implement it
both times once purely natively and once
with react native and you run it on very
unidentified that just by interacting
with the two apps just like playing with
them can you spot the react native one
and if you try to do this exercise you
will see that in many many cases you can
and this means that we're not there yet
and this ties into Johnny's talk from
before we're close but it's not
indistinguishable and I'm obsessed with
that small part how do we fix that so
it's all about the gaps so when we when
you do this exercise you see there are
many major gaps that we need to go over
for example animations and the community
has been doing this for the past two
years we've been taking the major gaps
and solving them resolving them one by
one
someone emissions it was resolved with
animated it's the amazing declarative
animations library and the native driver
so now we have animations at 60fps
navigation is also a very big thing that
is missing and I personally don't
believe in JavaScript based medication
libraries and but there are native ones
there is one from Wix reactive
navigation there is one from a European
be native application and I think
eventually they will mature enough that
they will become the mainstream and this
will happen in the course of the next
six months gestures is also a big thing
that was missing in react native the
JavaScript gesture system is not good
enough and it is being reimplemented by
Christoph McGee era he has a very
exciting plan of how to do this and
interactions is something I talked about
in react con for example and I showed a
proof of concept of how we can do user
interactions in 60fps so there are ways
to resolve most of these issues but
Arthur Moore and what I asked my product
managing team in waste in charge of the
app is to make a list of all the things
that they're not happy with with our app
and I always go over this list and they
see which ones are reason which ones are
difficult and there are two small issues
that I want to talk about today that are
seemingly very very minor but they
represent something much much bigger so
I want to show you these small
your tickets that I actually have open
in our app and I want to show you what
they are so the first one is we use a
native the vacation library so this is a
screenshot from our app and there is
product is complaining I'm complaining
as well because I play with the app
complaining about a flicker when pushing
a new screen and I want to show you what
this is so I took a video and very super
slow motion because in regular run time
of the app you won't feel that almost so
take a look you push on your screen it's
white and then the content appears
suddenly so this small flicker that
happens for a few milliseconds is
annoying why because this is a way to
distinguish that this is a react native
app I'm going to show you another minor
seemingly minor use case and this time
with a ListView okay we all know that
lists are a very core thing in mobile
and smooth lists are like the pinnacle
of mobile development so in our app we
have a complaint from product and UX
that there is a put a flicker when we
scroll the list very very fast so again
what I did is I did a slow-mo video so
you can see what I'm talking about so
look at the cells from the bottom and
they're white and they're just appearing
so normally normal usage you would not
feel that because the JavaScript based
lists like flat list which is amazing
have clever ways to hide this problem
how do they hide it they just do a
render window in the bottom and this
flicker happens off screen in most cases
so the user doesn't feel that so this is
a way kind of to hide the problem and
ignore it but no matter if the user will
scroll fast enough or if the user jumps
to the middle of the list or Scrolls to
top you can't anticipate which cells
will be required and then you will have
this annoying flicker this problem
actually caused us to take one of the
major list views in our app which is a
ListView that shows you all the photos
on your phone okay you have five
thousand photos you want to find a
specific one if you want to upload it
and this list should be super smooth and
fast and we couldn't implement it with
react native no matter how hard hard we
tried so there is an issue here and I
investigated this issue and the first
question I asked myself oh it seems
minor it seems easy to fix and
apparently this is not the case
usually the trick that we do for
performance problems in react native and
this was pretty much the trick for all
the issues all the gaps the major gaps
that has been resolved so far is by
going declarative you do instead of
doing the animations yourself you
declare them and you have a native
driver to run them frame by frame so
this is the trick kind of the tactic
that we use for everything and this
tactic doesn't really work here because
this seemingly minor issues uncover a
very fundamental boundary of react
native and we are about pushing
boundaries and I want to kind of dig
into this boundary and show you what I'm
talking about so let's kind of jump out
from this specific use case and talk
about a general thing a general thing a
question to block or not to block okay
this is the question and every time you
have a system that you have two parts of
the system they need to communicate it
doesn't have to be react native and
anything at all even web communication
or server communications you always need
to decide if the communication between
them is blocking or non blocking this is
a fundamental design decision that you
need to make and let's see the
differences between them but I'll put
them in the context of react native so
when react native we it's the same thing
we have two rooms we have two parts that
are constantly communicating with each
other okay we have the JavaScript realm
and we have the native realm the
JavaScript realm is where you write most
of your business logic okay it's
JavaScript it's easy it's very
productive you right there with
JavaScript naturally and the second room
is the native realm that's where all the
UI sits the UI is not HTML UI it's not
Dom it is native used regular native
views that Emily explained very nicely
in his talk how it all works
so these native views in order to
implement them and most of them are
implemented for you in the framework are
implemented in Objective C in Swift in
Java in the native languages that are
appropriate for each platform and the
communication between these two realms
goes over the react native bridge okay
you just send messages and I think
Emal's old exactly how it works if we go
into a little bit of specifics than the
JavaScript realm runs on a thread there
is a thread in your app in charge
charged with running the JavaScript code
and there is a different thread there
are many native threads but the main
is the main thread both on iOS and
Android and all the UI has to take place
over there so let's take a look at some
design decisions that we could make when
implementing a system that has the
communication between these two parts so
one option is to block so how would that
look like
so let's say we have JavaScript and the
JavaScript is doing some work in
scheduling some work and suddenly there
is some work that needs the native side
so what you could do is that's when this
message a is ready to be sent then you
would block the JavaScript and
JavaScript will not run anymore until
the native handles some sort of request
or command that you sent over and then
the native side could schedule some work
and then when the response is ready then
JavaScript could continue running and it
would schedule more unrelated work and
then there would be maybe another
message and the same thing would happen
you would wait for the native side to
handle it and then the native will run
they know to come back in return so this
is effectively you could say it's
running both threads on one thread this
is a parallel and there are systems
build around this concept okay for
example native script is more with more
closely to this then specifically react
native a different alternative is to do
an unblocking approach how would that
look like then you will have both
threads scheduling work which is
completely unrelated to each other I
mean and then suddenly you would have
this message that you need to send over
to the other side this a message like
before so you queue it in some queue and
the other side is still doing other
things because it has its own workload
and it's just busy and you have another
message and it's cute as well and
finally you see that the native side is
ready to handle that and then this
message will be handled and then the
other message will be handled so this is
a different approach for the same
problem and if you had to make it choice
which one of them is better so the first
thing there is no clear answer okay
there are always trade-offs this is good
in some use cases this is good in
another in a different use case so it's
made mostly a strategic choice and what
was the choice that was made with react
and to go back to that choice we need to
go back to the days before react native
when react was only for the web and the
choice has already been made for us with
react
so if you look at how the web is working
with a Dom it's actually the very very
similar problem you do you still have
the two realms you have JavaScript and
you have the native realm which is the
DOM and JavaScript in the browser by
default is synchronous every time you do
a Dom change from JavaScript the
JavaScript is blocked until the browser
handles this request so by default the
web was synchronous was the blocking
kind of paradigm and as you know there
was a big performance gain with react
when when the concept of the shadow Dom
was introduced and we had JavaScript
updating JavaScript and then the updates
would be sent or synchronously in the
background so react made a conscious
choice to go there synchronous way and
that was it's it's not a limitation so
react rendering is a synchronous by
design and it's a pointer to understand
okay this is not a limitation but a
feature and this feature works well most
of the time the whole declarative
paradigm of react which is why I
personally love maintaining react apps
it's so easy is because of that concept
okay as synchronicity allows it so it
goes much much deeper than just
performance it's the way you structure
your whole codebase and it also allows
for some very interesting optimizations
for example diffing okay we know that
the react reconciler finds the smallest
differences between the trees and it
only updates what needs to be updated so
even if you of as a developer you're not
sure what needs to be updated just
update the whole thing the system is
still very efficient so this would not
work well with the synchronous system
okay only a synchronicity would allow
that another cool feature is batching
you could do a performance optimizations
that you will batch those changes
together and reduce overhead and this
also works only if you have a queue that
is batch every once in a while and the
third cool optimization is fiber
prioritization you know that not all
renders are equal some of them are more
important than others then how can you
schedule some of them and give them
priority over others when everything is
synchronous so a synchronicity opens the
door for that as well so there are great
things with the synchronicity but there
are also limitations that comes from
this design choice and I want to show
you the list example that I talked about
and I want to show you why this flicker
originates from
fundamental boundary of how react works
so let's say that the user scrolls and
pixels down the screen in a list ok the
exact use case I showed you before and
the right side is the native side in
black and the left side is a JavaScript
side in purple and the scroll view that
the user is using is a native view and
it has to redraw the content as soon as
the user moves it and then the user
uncovers the new row and this row is not
populated with content yet because of
memory optimizations so there is no
choice but we have a new uninitialized
row and it's white there is no content
there and the native side has to display
something so it just displays blank
space now we do want to start generating
content so we generate a scroll event
and this scroll event has to be sent
over the bridge to the other side why
because our business logic that will
populate the list exists in JavaScript
there's no way around it that's just the
way it works now it's not only the
overhead of going over the bridge the
overhead is waiting until the JavaScript
side is free it's doing other things now
it's processing other things we have to
wait until it frees up to handle this
request
so once the javascript is free to handle
it will prepare the new row react will
render the new row and once again like
ml showed the rendering doesn't do
anything it's just a series of
imperative commands that go back over
the bridge because the rent the views
themselves are native so this has to be
sent again and then you have to wait
until the native side is free to handle
this because everything is a synchronous
and only then the native views are
created for the row and the new row is
drawn with a correct content so if we
look at this very complicated process
and we highlight this part this is the
flicker that we're talking about this is
the white part that takes a while to
disappear and and the user can notice it
because it's not immediate we have
overhead here that can take a few
milliseconds and this is an inherent
thing now you might ask yourself ok you
told us about the Pepsi test so you
would implement the same thing in native
wouldn't you have that flicker a native
and the answer is no and it's actually
very easy to achieve every simple list
in native doesn't have that flicker and
the reason is very simple because the
model
there is not a synchronous the standard
model there is synchronous when ever the
scrollview needs to fetch another row
and render it the same main thread
renders the row and brings the content
and lays it out and does everything and
the overhead is so minimal that the
synchronicity of the thing makes it all
silky smooth so in native you would have
gotten this without any effort but with
react just because how this system is
built we have kind of work around this
huge thing and so let's talk a little
bit about how can we circumvent a
synchronicity and this is something so
deep in the platform that is actually
pretty exciting to think about
so before we start diving into the
details of how this could be possible
let's just go about the API what the API
would we give this so let's go over the
basic API of react native itself of how
react native connects to native so in
react native you have like your entire
react component tree lives inside a
native you called our CTO root view in
iOS in the specific example so when if
you write a Greenfield app then your
entire app is pretty much this view it
covers the whole screen but if you were
writing a brownfield app and it was
already native and you would want to add
a react native part somewhere then you
would use this view and from that point
on inside there would be a react
hierarchy so our city root view is where
it all starts and let's say I have my
app and all of you have written this
code if you wrote a react native app you
would have a react component and there
is always a line if you recall called
app registry register component and you
just write it without really thinking
about it so if you don't know what it
does I'll tell you now you basically
give this root component that you want
in your hierarchy a string name and you
just register it somewhere okay where
will where are we gonna use it in a
second so our CTO root view is the
native you were react towards rendering
okay the whole app runs from this view
and the API for our city root view is
very simple and it has one main command
that you need to know and this command
and this is objective-c code I apologize
if you're not familiar with the syntax
but the API is very simple you just
create this view and you pass one main
parameter which is a string and this is
the registered name that we registered
in JavaScript before that's a whole API
it's quite simple you have this line in
your
you probably didn't write it because the
boilerplate you use to kind of wrote it
for you but if you look in appdelegate
closely you would see this something
very similar to this inside your apps as
well so let's take a look at the second
use case I told you when a user pushes a
new screen in our app we have a slicker
why does that happen
so let's take a look the user pushes a
new screen what does our native
navigation library does it creates a new
york city route view because our
navigation is native and we have a
native view controller we need to push a
new react hierarchy to screen so we
create a new york city route view by
ourselves and just specify which
component we want and then as before the
system currently it's in the native side
because the native push happens in the
native realm and the content isn't an
uninitialized so we have white blank
screen just like you saw in that in the
slo-mo video and we have some sort of
creation event and this has to be
scheduled and sent over the bridge we
have to wait until JavaScript handles it
and then it will reel in it react and
the whole route in JavaScript okay the
left side in purple is JavaScript it
will render the whole react tree and
then there would be the imperative
command that email showed us there would
be sent over the bridge and then we
would create the native views in native
once again and we would have the new
screen content drawn finally for the
user once again if we look we have this
part that is non-negligible okay and it
comes from the Sun synchronicity of the
system and this is the white flicker
that I talked about so what do we want
to do if you want great API to kind of
go around this problem in a very core
way what can we do so maybe we should
have a synchronous fruit view so what
does it mean really so we will give this
route view the exact same API why
because we wanted to be easy to use so
you would use it in JavaScript in the
exact same way you would define a
component just like you did before
you'd use JSX and we want to use j 6
because j 6 is easy it's productive ok
that's why we use react native so you
would write your component in J is 6 and
you would register it just like before
but instead of using App Registry you
would use a new registry called sync
registry ok the special registry and
we'll talk about it and
so incensed of API is the API is
identical what would be the native API
if you want to use it from the native
side so we would have just like before a
create method okay that's what we want
but also we want an update props method
and the api's are identical to what we
had before it's just our City sync root
view instead of our city root view and
you would just pass on the string of the
component that you registered so all
this is super simple but what is the
main thing here what is the novel thing
the novel thing is the requirement the
disc creation and updates that
originated from the native side these
are native commands they're gonna take
place without going over the bridge
we're going to render the native views
by staying in native and this is
exciting because this kind of
circumvents the synchronicity of the
whole thing so what would it look like
when we push a new screen in the
navigation solution so the first of all
we had the j is 6 we did the register in
the sync registry and when to this
registration happen it happens when the
javascript loads it happens once on
initialization so an initialization
we're gonna render our templated
component just when we register it and
we're going to render it once because
it's j6 and it's gonna be sent over the
bridge there's no way around it and
we're gonna do some sort of a magical
store recipe for this component so what
I'm gonna talk later about how it works
but this part takes place on the native
side and this happens on initialization
once and now we go back to when the user
does an action and this action can
happen many times the initialization
only has to take place once so when the
user pushes a new screen instead of
creating in our city root view we would
create from the native navigation
library in our city sync root view
instead in this sync root view doesn't
go over the bridge it magically uses the
recipe that it stored before and it
stays on the native side and then the
native views can be created without
going over the bridge and the new screen
can be drawn immediately with correct
content so where is the slow part where
is the part with the overhead we kind of
pushed it to the beginning when the app
initializes which is no big deal it's an
extra millisecond when the app starts so
it's no non-issue
my eyes and what is the part that we
optimized or changed this part the part
that uses the recipe it stays on the
native side it doesn't go over the
bridge anymore and this is I think the
exciting thing about this approach so
the synchronous render in this case
resolves the flicker and it's just not
only the flicker I want you to
understand that there are certainly use
cases it's not the 90%
it's a 10% the 10% of the
distinguishable things are usually
because of this fundamental problem and
if we had some way to work around it it
would open up a whole exciting world of
api's of infinite lists and table views
and collection views that could be
implemented and this is the way to tie
them back into react let's take a look
at the list example and how this would
handle the list example so from before
we saw that with a list example with
traditional synchronicity of react we
would have the flicker because of this
overhead that we had when we render any
row so what would it look like now it
would be the exact same way when Java
Script initializes we would register a
synchronous component which would be our
row our template for a row in the list
view we would render it once when the
app starts it will be done over the
bridge there is no way around it because
it's JavaScript and we will magically
store the recipe for this problem
natively and when the user Scrolls down
the list eventually in this unlike
before when you say how many screens
does a user push this happens if you
have 5,000 rows this is gonna happen
5,000 times you want this to be fast
then you would probably rely on a native
list of some sort of like UI tableview
your collection view there are many
people who try to bring those native
views to react native and it never
worked and the reason they never really
worked is it's not that you can't bring
them in you can but they don't solve the
fundamental problems of the
synchronicity you still have the
overhead but now when you recycle and
all of these native lists are all based
on the same concept of recycling old
views just to make things fast then you
will use the recipe that we had before
and you would create the views for the
row and you would stay on the native
side so we would call this synchronous
the neuro would be drawn with correct
content immediately the slow part is
pushed to the beginning and the part
that we had the flicker in disappears
because it is now practically immediate
so now the interesting we had the magic
store and the magic use how do you
implement those things so it's actually
pretty easy so the first thing we need
to do is to kind of hack the reconciler
to really understand what react does
when it rains routes views and here is
where I'm grateful for a meal for
explaining this for a whole talk what I
have one slide for so I can run over
this really really quickly I have five
minutes left
so you would look under the hood and you
see what react does so how does react
render native views we could use this
same process just to do to record our
own recipe and it's actually pretty
simple so let's say we have a simple
component that we have unrelated to what
we're talking about we're just exploring
how react works under the hood and this
component has a view with flex flex tile
and a text input that's it and as we saw
when react reconciles this in JavaScript
it sends imperative commands over the
bridge and these commands are commands
for the UI manager and you already know
what it what that is so UI manager is
the native module that is in charge of
instantiating native use in react native
and the commands that you would send to
it or let's create the first view the
view the our city view and our city view
is the native counterpart of the view
component in JavaScript and it receives
the prompts simply inside and it has
some numbers these numbers are the react
acts that are allocated for this view
and then it would create another one the
text input you see that the native it's
not actually a text input it's our city
text field and the prompts are a bit
different instead of value it's called
text but that's okay knows how to
translate these things for us and then
put set children and play with the react
tags just to set everything up so how
would we store the recipe ok this what
happens when we run the render function
so we want to do this I remind you on
JavaScript initialization so what we
would do is we have our sink registry
and we do the register to sink registry
when the app starts right this is the
first line that with that
pretty much does so what we're going to
do is in the sink registry we're going
to manually call react native dot render
I mean have ever view any of you ran the
render function imperative Lee by
themselves so you can't do that so we're
gonna run the render function on this
template of a component and what will
this do the render function will resolve
in these messages being sent over the
bridge so what we're gonna do now is
we're gonna swizzle swizzle is we're
gonna stop the javascript functions of
UI manager we're gonna replace them
temporarily with stubs that instead of a
function like create view or set
children we will have stubs that all
they do is they record the arguments
that were sent and saving them in a
JavaScript array that's all we're gonna
do and we're gonna store this array and
when we finish the initialization part
before we return we're going to restore
UI manager and like undo our hack and
remove this whistling of the function
okay so what would we turn this recipe
of the native of the UI manager command
that we had to do we would change it
into some sort of json okay we would
have an array of commands and the names
this is very similar to what is sent
over the bridge actually but we're just
doing it ourselves and this is now our
recipe and we could see realize this and
send it over the bridge on
initialization and store it in the
native sync registry now comes the time
to use the recipe when are we going to
use it we're going to use it when our
city sink root view is created or
updated we told we said that our main
requirement from the api of creating in
our city sink root view or updating its
props it's to do this synchronously on
the native sign we don't go over the
javascript bridge the bridge into
javascript in that case so how would
that work whenever you create an RCT
sink root view or update its props we're
going to go over the recipe the json
recipe that i've showed you in it's
stored it's just serialize and stored in
our registry and we go over it and we
have the commands that we need there we
can just execute them we can instantiate
we can call the UI manager commands
natively and instancing the native use
without going over the bridge
so this seems like a magic solution that
kind of solves all the world problems
but I want to want to show you some
fundamental limitations of this approach
ok so this is not a perfect approach and
the main limitations of it and I I'm
hoping that some of you can already
guess them by themselves that this would
only work for declarative components to
compute components that don't have any
JavaScript code inside okay I'll show
you an example in a second okay so you
can't have for the rows in your list for
this specific performance boost you
can't have any JavaScript code in there
it's just declaration of components
calling components and passing down
props that's it and this is a severe
limitation but sometimes you have to pay
for the performance and the prop updates
that you do can't alter the tree you
can't have components in the tree
disappearing and appearing rendering or
not rendering all of them will be there
because they're part of our recipe so
let's have like 20 seconds left so I'll
show you an example what happens when
this limitation is is what blocks you
okay I need some JavaScript code so
let's say in my cell in my cell in the
list I have some JavaScript code like in
this example okay I want to render hello
or goodbye based on a prompt which is a
boolean what would you do in this case
so there are ways to work around most of
the cases I think and it's especially
true for list because lists that you
that are repeating and have the same
cell over and over if you think about it
real hard you see that it doesn't they
don't usually require a lot of
JavaScript code inside so what would you
do this is not it doesn't satisfy the
limitations that we talked about before
but you could just change the prompts
that you have so for example I would
define new props and the new prop would
be display hi and display by instead of
just adding a boolean called is I and
the values of these props would be flex
and none because I don't want the
business logic inside
I pushed the business logic to the props
okay so the part of my code that creates
all the rows for the ListView and
handles the data it will create this
transformation for me when I create the
data set and then our component is
simple
it just has the two different text
components and we just passed the props
directly to display and react native
currently supports display:none
it's a relatively new feature it has
been committed already
and you could say that if you do if you
want to display high you just pass flex
to the first one and none to the second
one and the second one will disappear
and this is completely declarative okay
there is no business logic here and this
works under our requirements so you can
see a proof of concept of this working
okay you have a code with the width of
the whole thing
with a synchronous root view and it's
available in the Wix github account you
can take a look I'll publish the slides
a little bit later and thank you I think
we're out of time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>