<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Rendering PERFORMANCE From The Ground Up | Coder Coacher - Coaching Coders</title><meta content="Rendering PERFORMANCE From The Ground Up - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Rendering PERFORMANCE From The Ground Up</b></h2><h5 class="post__date">2017-12-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/npRQvAaGQhM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today I will talk to you about rendering
performance and I think to understand
rendering performance we have to go like
you know take a few steps and I think
they've easiest step the easiest first
step to go with is looking at how we
transform the text that we've got which
is HTML CSS and JavaScript as well but
primarily I'm going to talk about
rendering it's like the visual thing so
I'm mostly concerned about HTML
Javascript in the first step how do we
take this text into something that
becomes visual and then in the second
part how do we actually I paint in all
the pixels and what our pixel somewhat
is rendering really and how does that
how do many different images get
together on the screen together as one
big website or web app then I'm gonna do
some interactive parts there's gonna be
questions and you can win eternal fame
no actually I have Swiss chocolate I
think so if you want Swiss chocolate
then you know come to me find me later I
have only a very limited amount of that
but you can also take a 360-degree
selfie with me if that's like if all
this chocolate is gone or you don't like
chocolate it's not lactose free
chocolate I'm sorry for that and then
we're gonna talk about WebGL in depth
sorry canvas 2d which is like the thing
you might want to think first off when
you hear rendering because it's like 3d
and 2d rendering awesome who here has
used the canvas before bead for 3d or 2d
that's a few people good all the others
try you got damn right part one the DOM
and other trees
isn't that beautiful picture so we start
with the website like this this is
probably something that could have been
around in the 90s but it's still more or
less looks like this unless we do
something really weird which we
shouldn't be doing if you start off with
something that is semantic HTML you
might start off with something like this
is a headline and an image now what
happens as the data comes in from the
network well the browser receives things
and goes woo this is an HTML document so
I'll start with like building a tree
with a document node and then there's a
body in there all right and then we have
this headline with text so I'll put
these two because the headline could
stay the same the text could change so I
want to have these represented as
individual bits in memory in the tree
and then we see an image and then we
load the image from the network and all
that kind of stuff and we kind of like
get information depending on the image
format we might get the information of
how large the image is very early on in
the download so we can fill information
in like that there's another tree being
built in the background which is the CSS
or M that Steve just mentioned and it's
basically getting like the visual
properties so for instance for the Hat
one element it might figure out how
large this is gonna be what funds we're
gonna use what color we're gonna use all
that kind of stuff is in a separate tree
as well so basically when we are passing
we are passing in the streaming fashion
which is amazing because if you've ever
used fetch or something to download a
larger file or get a larger API response
you know that basically the promise only
resolves once you have everything in and
even though I think I'm not sure if the
xmlhttprequest gave you actual access to
the thing I think it gave you a progress
event that tells you tells you how far
in you are I don't think you can get the
data the browser can do that the browser
can basically the moment it sees HTML
the browser can start parsing it into a
tree we don't have that power in
JavaScript so the browser has a bit of
an advantage here there's a streaming
API our streams API coming up Jake
Archibald gave great talks on that so if
you want to have access to things as
they come in streaming access to things
definitely check out streams API and go
to github and say I want this this is
awesome I think Chrome and Firefox are
already starting to ship it in like an
experimental form of it so we start
parsing them as they come in and then as
they come in we build these trees we
have two trees we have this Dom tree
which is like the elements and their
content and then we have the CSS om
which is the visual properties okay
great
but we don't we don't know how these
actually come together on the page so
there's an algorithm that depending on
which browser you're looking into it's
called reflow or layout I'll call that
layout for short because it kind of
makes sense has lace things out on the
page in my opinion and what it does is
it basically figures out okay so we have
this this Dom tree and we have the CSS
or AB and we know
we use Comic Sans in fourteen-point and
it says hello world
so it's this many pixels wide and it
uses native API it's for that depending
on which platform you're on actually it
uses a wrapper usually for instance in
Chrome that is skia so it's a library
that basically gives you these
informations and like figures out the
colors and all that kind of stuff and it
also figures out how much space we have
so how large is the window are we on a
mobile phone is it an portrait or
landscape mode is the window like
resized or is this a full screen thing
and basically on based on that and the
size information that we already
gathered it figures out how to fit
everything in according to how HTML
wants it to be fit in and there's like
block level elements and inline elements
and inline block and table and flex box
and grit so all this kind of stuff
happens in this layout process to do
that it looks at the trees and then what
happens is more or less like this so
here as the information comes in as the
trees are being created we have a parser
that is streaming parser these boxes are
being laid out ok great so we start with
the page and layout all the elements as
they come in that is wonderful but
that's not how my normal website looks
like I do not look at colored boxes
maybe for minesweeper but normally I
look at something more intricate than
boxes so we have to paint things as well
so painting is one of two steps of
getting something visual on screen
there's another step called compositing
that we're gonna look at in a bit but
basically when we paint we have to think
about like what does that mean I mean
painting and not sitting in front of my
computer and basically like do the color
in the you know the little dots myself
so if you think about screens computer
screens today until we have like
holographic displays and all that kind
of stuff are basically just a collection
of lamps very tiny lamps LEDs or
something like that or background light
in front of a thin film of whatever or a
little proton ray going fun if you have
one of these old monitors terrible
graphic quality anyways so but basically
they're two tiny little lamps and each
of these dots each of these pixels is
actually three of them there's a red one
that's a green one and there's a blue
one
if we turn them all off
surprise no light it's black if we turn
them all on it is white and then
basically we have like intensities of on
right you can like dim them up or dim
them down so basically you get 256
variations of brightness of each of them
and depending on how bright they are in
contrast to each other you get a
different color so for instance if the
right one if the red one is full-on like
maximum brightness and all the others
are off you get red surprise right
if you then turn on the blue one you get
hot pink probably looking beautiful and
what it really is is these intensities
are just numbers I laid them out in this
grid to kind of reflect the colors into
numbers but there's nothing stopping me
from just putting them as a list right
this is just for us so that we have a
better understanding of which numbers
represent which pixel but really it is
just a list of numbers so that means
rendering is actually not very
complicated if you think about it if the
screen is just an array of numbers of
three numbers for one pixel three
numbers enter one color leave to use
Thunderdome if that's an array and each
of these array items is technically like
four values or if we have like four
values in the air it depends a bit on
how we want to structure this array and
they represent red green blue and maybe
also transparency now well the screen
can't turned transparent but we might
have multiple colors that we want to
overlay on to each other so we have
these four values or three values if you
don't want transparency and when we want
to render all we do is we write these
numbers into the list now who here has
ever written numbers into a JavaScript
array I'm actually very surprised that
not many people are raising their hands
what are you doing anyway so yeah so we
figured out rendering is basically just
rendering is writing numbers into a list
writing numbers into a list that's a
very basic concept and it's a bit more
more intricate than that so when we
paint when we want to write numbers into
lists painting works on images and as
you might know images happen to be
rectangular that's also why we need this
fourth number what if we
a rectangular image but we want to
render something that is a circle ha
well the thing is the force number the
transparency or the Alpha Channel that's
where the magic happens if we set that
to zero then we just ignore that pixel
there and we're just not gonna draw it
but in memory they are basically a
rectangular piece of memory more or less
these rectangles are called
layers or images or textures I use that
term interchangeably it is there's a bit
of a technicality behind that but if you
hear texture or layer or image it's kind
of the same thing it's a bunch of
numbers that form a rectangular array of
pixels and now as I said we want to put
multiple of these over each other for
instance we might want to put like a
background and then a nyan cat on top of
it so we have to kind of combine them
and this combination of the two is
called compositing and it works like
this so here we have two pixels each of
them has an alpha value so here we have
like 64 which is like 1/4 intensity and
then here we have 128 actually just
should be 127 doesn't matter
that's like half intensity and we want
to combine the two and here we have red
and here we have green and then when we
combine them we basically mix them we
say we take for instance one part we
take one part red and two parts green
and then kind of mix them so like this
this color here is twice as important
gets multiplied it by two beforehand and
this one is not as important and so we
mix them up to this wonderful color here
and as I said the screen can turn
transparent doesn't really work like
that at least not with current
technology so we have to only use three
numbers for that one because we have
three lamps we don't have like a magical
transparency component so this is how
you can combine these four values and
another four values using compositing
into three values that you can actually
express with the three little lambs that
you have on your screen for each of the
pixels and you can use it in more
practical cases like this so you have
your background and you have a young cat
and and then what you do is you
basically render it all over again so
for each frame hopefully often enough
hopefully at least 30 times per second
hopefully 60 times per second because
that gives
very smooth motion you start by putting
and I put a little border around it so
you put the the neon cat image on the
other image and then put that onto the
screen and you do that again but you you
move the nyan cat a little and notice
the things in the rectangle here and the
background are the same so we don't have
to like write all our numbers again we
just copy our numbers into different
positions on the screen so we don't have
to draw everything we don't have to
paint
we only composite we only put the pieces
together in different spots and then we
do that again and then we do that again
and then it goes and so on and so forth
you know how the drill goes but how does
that actually work so how do i how do I
take one value of the array and then put
it onto another value like another value
of another array and then put that in
the third array sure you could use like
zip and all that kind of stuff but um
actually the graphics pipeline does
something slightly different it takes
multiple images so one of them could be
the nyan cat the other one could be the
the background for instance runs a
shader and the shader creates what is on
the screen later on now what is a shader
we have heard that term heav'nly
actually used that yesterday quite
extensively and I think she showed us a
few examples of what you can do but
shaders are not only for WebGL actually
shaders are what the browser uses to get
things on screen really fast and let's
look at how that works by looking at the
different kinds of of execution hardware
that we have so we have CPUs and the CPU
has more more cores these days than one
but it's a small number it's like if
it's a phone it's probably like eight
cores like you have eight of them
working together if it's a modern
computer it's probably anything between
four and sixteen and if you are have too
much money then it's like 32 or
something like that but then the GPU has
coarse as well and thousands of them
what must be expensive no because these
GPU cores are very very specialized well
the see
core unfortunately because it has to
like do all sorts of calculations has to
be a little more generic but it's highly
optimized to make these generic things
as fast as possible which makes it a lot
more complex so these course each of
these individual course isn't as clever
as the core from from the CPU but the
CPU can't do certain things can't take
certain shortcuts because it has to be
generic
and when I say generic I mean we might
have programs that basically read from
some memory somewhere and then check
what's in the memory there and if it's
some value that we expect then we write
to some memory somewhere else we can't
do that in parallel the sheer problem if
you have ever worked with
multi-threading and you know it's like
oh I haven't problem I'm gonna solve
that problem with multi-threading oh now
I have five problems so multi-threading
is a tricky one because of this you
can't just access the same memory at the
same time so basically if you have
multiple cores they have to do some very
clever things to like coordinate but
amongst themselves but it's really good
for that like it can do all sorts of
things it caches memory memory values it
does like a prediction of what's gonna
happen in the next circle it prefetch
these things because it goes like okay
I'm gonna run this code next so I'm
gonna get that already so it can do all
sorts of these optimizations and the GPU
does not really help there because you
have like a thousand course but they
can't do anything because this memory
thing has to be sorted out first so
basically they can't really benefit in
these cases but we have different
problems and there is a problem that is
particularly nasty for CPUs to be deal
with and that's like doing a large
amount of data work in processing a
large amount of data with the same
operation so here for instance this is
matrix multiplication so we take a value
from here and then we multiply it with
here and then we put it here and so on
and so forth it's the only thing is the
positions change but the operation the
multiplication is the same and these
matrices could be gigantic so this is
kind of the case for machine learning in
graphics because if you think about it a
matrix is nothing else than a very fancy
list a list that has two dimensions but
we could theoretically say it is a list
and then we have a large list and what
is a list oh the screen is the list
right our
pixel array is a list so we have to kind
of process the list somehow with code
and and that's where the GPU really
shines because it is optimized for that
kind of stuff that goes like whoo yes
give me an operation and then give me
these numbers and hey a thousand course
here we go into battle we go here's your
numbers and here's the equation that you
run on them done awesome here we go
again so they're really really good at
that kind of stuff that's why everyone
wants to do GPU computing for machine
learning for Bitcoin mining and for 3d
graphics or graphics in general so
that's what they are good at let's have
a look now obviously we have or well not
obviously but we do not have as many GPU
cores as we have pixels normally we
might have like a thousand course but we
have a million pixels or whatever like
4k probably has a million bazillion
gazillion pixels I don't even know right
now from the top of my head but for
convenience sake we have like one core
for one pixel here so we have the white
pixels on the right and our GPU is ready
it's like yeah give me work I'm like all
right okay here we go
take the X&amp;amp;Y coordinate of your pixel
and create this color value for your
pixel which is the x-coordinate times 85
the y-coordinate times 85 which means we
start with zero zero and go down to
three three here so we should have a
gradient and then they all at once go
all right off we go and we create this
graphic and this is entirely dependent
on what kind of code we are running here
and this is the shader that's nothing
fancy not like super complicated weird
 that's is a technical term I'm
not swearing on stage just to make that
clear so instead of having like
something very weird and a new concept
what it really is it is a function and
there's a function that takes a bunch of
inputs and produces an output that has
three values X red green and blue
actually it has four values but bear
with me here it has the Alpha value as
well and then like the graphics card
does the magic of combining it
so when we do compositing what we do is
we have a bunch of rectangular lists of
numbers and we combine them together to
form the number that is gonna be on
screen at the end and this number is a
color all right okay and it does so by
using a program that is called a shader
and the shader is just a function
welljust is a function that runs on the
GPU which is pretty freakin cool right
oh my god I didn't know we could run
stuff on the GPU in the browser
that's what WebGL really is about but
browser does that internally as well so
basically we get to write this code if
we're doing WebGL for instance or we use
code that is already shipping in our
browsers so browsers do have this kind
of stuff built-in for things like
compositing all our composite only
animations filters and blend modes
here's blend modes by the way so that's
that's a CSS blend mode allows you to
define how you want to combine different
images together and all it is is a
different equation that's that's the
entire difference the difference of
blend mode is the difference of equation
that you're using the difference of
shader that you're using to produce
colors on the screen it can do certain
things it is limited in what it can do
as I said the the GPU cores are not as
fancy as the CPU cores so they are
limited in what they can do they
couldn't do a few things they can do
moving things like they can move things
around they can figure out where to put
something in because we can just add to
the numbers where we are putting them
that's not a problem this is called
translate in computer graphics terms you
might have seen that as a CSS property
this is exactly what it is it just moves
things around it can rotate things
because as it turns out rotation is just
multiplying the values the x and y and
maybe zet values with the matrix and we
have established that the GPU is really
good at matrix multiplications because
it's the same operation on a bunch of
numbers it can also do that for scale
because it's the same thing again it's a
matrix multiplication or there's
actually some multiplication with the
single value and it can blend in filter
ish
so the different equations are built
into the browser but not all browsers
support this
mmm and a few things and a few filters
actually cannot be composited there's no
shader for them yet or they can't be a
shader because of the nature of the of
the filter and then they are actually
having to paint the pixels and that's
actually a shame because painting pixels
takes longer because we have to write
all these values into memory and that
takes a just until it's done
so whereas compositing is like hey
shader hey GPU course here's a shader
awesome we're done so yeah there's that
and this is a real shader and this is a
shader written in GL slang or GLSL is
shader language from opengl let's break
it down real quick so first we have two
variables that come in and it's the
semicolon is not optional just saying
and we have like data types here so we
the vector 2 is basically an array with
two items in it it's an x and y
coordinate and then we have an image
which is a list of things it's called a
sampler 2d but it's basically a list of
things a list of colors from an image
the different pixels and then here we
take the pixel value from the image at a
certain position which gives us like a
vector for so that's like RGB and a we
ignore a and then we calculate basically
we we add them together and divide by 3
so if we for instance have 255 0 255
these two together make 500 divided by
300 and then we have the grayscale value
of that and then we use this value this
grayscale this intensity between black
and whites for all three for red green
and blue in the output and then we put
1.0 which is like full-on as the Alpha
value so this is a grayscale shader this
is what it does this is how you do
grayscale on the GPU you don't have to
write like loops and stuff I mean you
can do that in canvas 2d with having
like a for loop that goes over all the
values in the image and then putting the
image back but it's much much slower
this is how you can use the GPU to do
exactly that
quick interlude I said something about
filters and blend modes so have a look
at this so this is the CSS filter and
CSS filter blur i have enabled paint
flash plain trekt flashing
if you see a green flash that means that
the pixels have been redrawn which is
slower if you do not see a flash that
means it is just compositing it's using
a shader for this awesome CSS blur
filter works great
no flash of sadness amazing now the SVG
filters have the same code but you see
that the green flash that's sad for some
reason it's the same filter on SVG so
using an SVG filter rather than a CSS
filter and unfortunately we get this
repaint which means all these pixels
everything that has has flashed green
has to be redrawn on its own screen
rather than just composite it so if we
looked at here you see it very clearly
this one's not very good Sarah drisana
invites all of us to say hey how about
half the acceleration for SVG to fix
exactly that and actually not even sure
if this is a bug in the dev tools or if
it's actually a bug in SVG filters I
don't know very good question good that
you asked I still highly recommend going
to your browser vendor of favor and go
hey I noticed this thing here can you
maybe accelerate it make it fast and
nice and composite only this particular
filter might actually not be composite
able that's why I'm not sure if this is
actually a buckin and this one is
actually lying to me but other filters
expose the same problem so all the
filters in SVG have this problem anyway
so if some browser vendor if someone
from the browser vendor sees this if
you're fixing it you get beer from me so
there we go awesome music video from
teddy bears by the way if the song yeah
depends on your taste right
and then there's JavaScript so we have
talked about HTML and CSS but we haven't
really talked about JavaScript yet so
what JavaScript can do is if I have a
perfectly fine website here headline
hello world and an image below it it can
come in and go actually how about we
make that headline in line instead of
block level and then the browser goes
fine okay I repaint the rectangle like I
fill the pixels back in how they should
be and I remove the pixels like where
the image was
no you and I move the image up and
that's a bit of work like things have
moved around and we had to repaint
things as well so if we look at what the
browser has to do the JavaScript kicks
in it changes the style object it st.
changes cssom under the hood and then it
has to do the layout again because it
has to figure out oh wait a minute we're
taking less space here so there's space
available over here so we move the image
over there
hurrah we have that settled and then it
has to paint in all these pixels that
have changed and then it has to
composite things together so it's a lot
of work actually and especially the
layout and paint stages are expensive so
that's particularly expensive work but
what if our JavaScript is something
slightly different what if our
JavaScript said hey can we make that
text a different color
Rebeca purple in this case and the
browser goes sure in that case I just
repaid the pixels that I have to change
and we're good
that's a bit better because we have
actually skipped a step in the process
we didn't have to move things around so
we skipped this entire expensive layout
process and just paint it and composite
it but there's other examples like this
so this menu just slides in without
moving anything on the page it can be
drawn once somewhere and then just moved
around and we have established wait a
minute moving things around translating
things that's something that we can
composite and this filter in this case
is composited as well so we do not have
to draw and we do not have to layout and
we just composite things like we move
this around in the shader and we'll be
good and if you think about it what we
want is to as often as possible hit this
one because if we hit this one that
means that we are doing less work and as
Paul Lewis has said performance is the
art of avoiding work do not try to say
that in a performance review at your job
but in browsers that is true I'm not
sure bosses like that really
I certainly do because I'm like yeah if
you do less work then you have capacity
for more awesome things but hey not
everyone understands that unfortunately
all right now that you have seen that
JavaScript can interact with our
rendering process and
the graphics card and shaders and stuff
let's do a little quiz so here we have
an HTS CSS element that is translated
nothing nowhere on an x axis and after
two seconds we change it by translating
it 200 pixels to the right do you think
this paint no oh yeah things that paint
oh wow
okay that's wow all right do we know
what the green flash means it paint it
it does and when I saw that I was like I
go on stage and I tell people composite
is like moving things around then you
just composite and yet I get this but
that's a good reason for it I didn't lie
to you
it's just I left out an important piece
of information the important piece of
information is that to do this
compositing remember we have a bunch of
images that we combine right so that
would require multiple images for the
page it would require to do that with
any element it would require having a
separate image for each of these
elements and translate X is a little
older actually so they are like yeah you
know you might use it to move it around
once and that's like a small operation
really you're not doing it very often so
we kind of take it as a hint to not do
an image because images or layers have a
cost right we have to keep this
additional image somewhere in memory so
the memory consumption is rising and not
only that also we have another array
like an area that keeps track of all the
images so that one grows as well and
then we have to like deal with it so
it's a lot of cycles lost and when
rendering all the things and what if you
have like five thousand Dom nodes here
five thousand images holy crap I hope
you have a few gigabytes left on your
RAM so basically the the render add-in
or the rendering engine the browser
takes hints when it makes sense to
create a layer and one of these hints is
if it's a canvas of video element we are
redrawing it all the time so we
appraised pretty much like doing all
sorts of things that if we want to do
anything with
like moving them around it makes sense
to put them in a separate layer so this
creates layer also 3d transforms because
they're a little newer and you pop
things out of the layout context and you
might if you goo if you go 3d you
probably go bananas anywhere so like
yeah you know what this might be more
complicated and actually 3d
transformations run best on this on the
shaders in the graphics card because you
know you have to do like four
perspective transformation and all that
kind of stuff and the best way to do
that is to put it in a shader so we pop
it into a separate layer and use that on
a on a on the GPU we actually accelerate
this one and composited only and then if
you have an animation no matter what
kind of transformation it is if it's an
animation that can be mapped to one of
the things that compositing can do like
moving things around then that actually
also is popped into a separate layer and
composite it but only if it's that if
you do like I don't know change color or
something right no that can't be
composited then it's still painting but
if it's something that can be composited
only rotate scale move then these things
are actually also popped into a layer
and then there's the wheel change
property which will not automatically
force a new layer but it will definitely
signal to the browser hey you should
double check because I I will change
this thing so if that makes sense to pop
out into a separate layer then please do
support for that one is improving it is
not very great just yet but I think
Firefox I'm not sure about chrome to be
honest I think Firefox and Noah Firefox
and Chrome do it
Safari and edge I'm not exactly sure
right now so let's play again what about
this one
translate 3d changes after two seconds
will it paint who here thinks it will
not paint
okay few players left in the game all
right let's see
3d transform does not paint very good
very good
I have another round last one I promise
I've stopped asking questions in a
second I know it's early in the morning
so here we have a keyframe animation
that has a translate X so it's a 2d
transform in an animation that is
playing will it paint who thinks it will
paint or things it doesn't all right
you're right doesn't because it is a
keyframe animation that is composite
only wonderful all right last but not
least I'm running over time awesome
let's have a look at WebGL on canvas and
I know that the image doesn't really fit
but I found it cute so go away so the I
I thought what about a little challenge
to like compare canvas 2d and canvas
WebGL to each other and the challenges
draw the same image as often as you can
at a different random location and a
different size so resize the image and
draw it somewhere on on the screen and
let's see how often we can do that
without having like serious performance
problems
so here's more or less the main code as
a bit of setup code is like ten lines
missing on this one here's the main code
for canvas 2d so we pick a random
position X and Y and we pick a random
size and then we draw the image using
canvas 2d api's at this position circle
around its center and then with the size
given by the parameters okay let's see
how website looks like and for this I
have to warn you you're not gonna be
able to read that code but it's
illustrating a characteristic of web
here yeah so this is the same thing in
WebGL it's leaving out the entire shader
code and it's leaving out the setup code
oh I have the setup code available as
well you know it's a bit more I would
say if you compare this to
this it's probably like pipelines more
right so yeah
moving swiftly on canvas was a bit
easier there in terms of how the amount
of code that we had to write but how it
does it look in terms of performance so
here we have the performance the frames
per second on the y-axis and the amount
of images or times we draw the image on
the x-axis and just to keep in mind the
green line is what we want to hit the
orange and red lines are not very good
the red line in particular is like the
minimum we can do to actually make it
look more or less like a motion so
basically from 500 elements on we are a
slide show great now how does how does
WebGL turn it up oh all right slightly
different performance characteristics I
would say and you can turn on hardware
acceleration which means likeshe during
all the things that you can shader for
canvas 2d as well and it doesn't change
much so the numbers are higher we start
with 10,000 objects and fair enough you
know I had to cap the graph somewhere so
10,000 objects fine 25,000 objects even
in WebGL a little slow and that was on a
MacBook holy moly and but I mean this we
are we a slideshow from basically here
on on canvas 2d so even have
acceleration on canvas 2d does not help
us much because we are not getting full
access to the graphics memory and the
graphics pipeline we're getting very
limited come support from what the
shader can do ok so that evens it out
which goes to say not necessarily one or
the other is intrinsically better except
for the fact that the only downside to
website is the amount of code that you
have to write really when it comes to to
the comparison but let's look at that so
canvas had much less code that we had to
write in there was relatively easy to
understand
WebGL comes with a bunch of lingo and a
bunch of things that we have to set up
but WebGL has a lot of libraries that
take that away from you so if you do
games for instance phasers using WebGL
in the background without exposing it to
you so it's very high-level abstraction
3js is a high level abstraction as we've
seen yesterday a frame is an even more
high level abstraction over that stack
gl Babylon all these exists and take
away the pain of writing all this code
we write a much nicer denser code of of
better conceptual abstraction so for
instance in three.js you make a movie
you have a scene you have a camera you
have objects on the scene there we go no
weird stuff that happened here over
there in the code
however canvas does not give us access
to write our own shaders and for a lot
of things that makes a lot of sense for
instance the grayscale thing if you have
like video coming in and you want to
change the colors and invert the colors
all that kind of stuff that's much
faster and WebGL because it gives you
the ability to write shaders that do
this really really fast also if you do
like edge detection or something like
that
all that works much much faster and
nicer in WebGL thanks to access to the
GPU pipeline and shader code canvas
usually is a very limited performance
however it works on pretty much every
device including a potato probably if
the potato has browser at least but the
the WebGL thing as it has to deal with
like driver bugs and all that kind of
stuff might be divided you activate it
if it's a really old machine or Internet
Explorer 10 who feels bad to say that on
stage then it's not available so mm-hmm
so should we anyways do like WebGL for
all the things and there was a few
people who attempted that like do all
the dumb stuff away and use WebGL on
everything and I say no it might be very
fast if available but it has so many
downsides when you do everything in
WebGL you have no UI primitives you have
no event handling you have to implement
everything yourself and it is not
supported everywhere and the beauty of
the web that we sometimes forget is that
it works pretty much everywhere and to a
certain degree
it's a best-effort kind of thing it does
what it can on the device you give it so
use the right tool for the job and that
might mean that if you use
or if you want UI primitives and basic
like interactions and all that kind of
stuff an accessible content which is
very important in fact you should go for
HTML and CSS with a bit of JavaScript
sprinkled in to make it more interactive
when available and then there's SVG as
we have heard yesterday from sarah SVG
is great if you have graphics that
should respond to the size and
environment they are in they're also
very tiny as they basically are just
drawing instructions and they can be
hardware accelerated if the browser's
want to make it happen it is very hard
to make it happen in their defense I'm
not saying that they are like lazy bums
they are working hard to make that
happen it is very hard to make it happen
unfortunately and then you can use
canvas 2d but I wouldn't use it for like
super complex stuff but if you do very
simple drawing operations or just need
to like extreme a video or something
into canvas to resize it or something
like that then that's actually pretty
good but for everything else and that
includes more complex 2d graphics that
are interactive and do magical things
then you probably want to go for WebGL
as that gives you full access to the
rendering pipeline at the cost of having
to deal with a full rendering pipeline
or a library that abstracts them away
and with that I'm done
slides are online I'm around ask me for
things or take a selfie with me thank
you very much enjoy the rest of the day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>