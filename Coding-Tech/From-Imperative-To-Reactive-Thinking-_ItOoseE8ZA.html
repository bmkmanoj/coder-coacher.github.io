<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>From Imperative To Reactive Thinking | Coder Coacher - Coaching Coders</title><meta content="From Imperative To Reactive Thinking - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>From Imperative To Reactive Thinking</b></h2><h5 class="post__date">2018-03-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_ItOoseE8ZA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so Todd is gonna start you off by
talking about a lot of the concepts that
we wanted to cover today we're thinking
about imperative and reactive
programming these are not particularly
obvious terms a lot of the time and
Todd's going to take you through some
concepts and then I'll walk you through
a code example together yep
so hopefully it's gonna be a good ride
for you we've got some friends things in
there as well say any friends fans so
we're gonna be talking a bit about
reactive thinking how we can start to
think reactively we're also going to
discuss imperative thinking there's no
point kind of just go into the end goal
without looking at the beginning now
what I want to cover to actually get get
us there is the design patterns behind
these so you may have come across
something that looks like this and I
remember you look at it and you go what
is that and you end up looking a little
bit like Joey when you you talk to your
friends about rxjs perhaps oh yeah I
know what this this stuff is so today
we're gonna make you not laugh like Joey
and you're gonna be confident in talking
about it so these are the two things
that I want to talk about and then we're
gonna hand over to James so I want to
talk about the observer pattern when we
deal with rxjs we typically use
observables angular has obviously a lot
of its core is based on observables and
then we're gonna look at some sequences
and some operators so first things first
I want to talk about the observer
pattern we're not just gonna go into
these are very conceptual so we're not
gonna just show you later code and
hopefully not confuse you so what I'm
gonna do is take a light switch this is
to call this light switch I could find
on Google they are all boring so we all
probably worked in an office you walk in
in the morning and it's pretty dark in
there and you turn the light switch on
and all of a sudden you're greeted with
a brand new office which looks way
better but it's got that instant and
everything is just on at once so what I
want to talk about is some of the theory
behind the observer pattern and how we
can kind of thing
is just light bulbs and a light switch
so if you imagine we've got our green
box here which is just a light switch
and we've also got some light bulbs so
we can obviously go to the shop we can
buy three light bulbs but we want to put
them in the roof and connect them up
somehow so if you imagine we just
connected our light bulbs to the switch
now in a programming sense this would be
a subscription when we when we think
about rxjs you've probably seen
subscribe and that's where you're asking
for that particular piece of data so you
can see here that we have the SUBSCRIBE
and we're asking for the green box and
we're subscribing to the green box and
each of these purple little boxes which
are the light bulbs are passing
themselves in as an observer to the
SUBSCRIBE anything changes they will all
get notified so if we turned our lights
on all the lights would go on if we turn
them off they would go off they're all
wired up their observers they do nothing
else they don't they didn't go to the
light switch themselves they don't have
a switch on them they're simply waiting
for a switch on the wall and then
they're on so let's say we've got two
blue boxes these are some new light
bulbs that we've purchased and all we
need to do again if we can just simply
put them in the same room and this makes
it quite easy to think about how and the
observer pattern actually works so now
we've wired up to more light bulbs we
can then add it essentially to the same
source we've got subscribe on the left
and subscribe on the right now you've
probably seen these terms observable and
observers so the observable will be the
source it will for instance with our
light switch it could emit a non-event
could emit an offer vent and every every
observer will respond to that
accordingly
now I've put question marks inside of
these because that's pretty much the
theory behind it the basics of the
observer pattern you don't it doesn't
matter what it is typically we have a
producer which just produces values it
can produce them constantly it can
produce them over time and our consumers
they just simply get given the data so
we call this the push and pull or the
push model where basically the producer
would push down to the consumers so they
just simply ask for it if and when it's
given to them so let's move to sequences
and operators so these these patterns
are gonna set James up and we've got a
lovely orange ball which is the mystery
of what it will be for so sequences and
operators you may have heard the term
streams or whatever buzzword this week
so I want to kind of use the example of
coffee to to talk about these these
sequences so by now we've understood
that we have some kind of producer it
produces values once it's done we then
consume the values now if you think in
terms of an angular application for
example the producer could be a routing
paramus obscure and we just simply
listen to it and we can change your
components data based on that so that's
an example now somewhere in the middle
because we are talking about the
sequence of the observable we're going
to call this the pipeline doesn't need
to be one it could be two so we've got
two blue boxes once I when I started
with rxjs I came across these map and
filter so the you've probably seen these
before in the rxjs documentation or even
on the angular documentation so these
typically make out what we call a
sequence so we can have a producer and
our consumer and somewhere in the middle
we can transform those values so this is
just trying to think about the different
parts of it so we got produces values
business logic we call it in the middle
it's important to note that they're just
pure functions so an observable sequence
can just be a pure function it has an
input and it returns something based on
what the input was and then we have the
final outcome bit for friends reference
so back to the coffee example how how
can we think about sequences in in terms
of coffee stay with me on this one okay
so let's imagine you've got a coffee
machine at home you've bought someone's
brought you this coffee machine for
Christmas we could say that we've got a
water and the water in the coffee
machine is we've heard the timestream so
it literally is a stream of water and
that that water will be just given and
given and given so let's assume that we
want to make two cups of coffee at the
same time I've got one cup two cups and
I put them underneath and one of them I
want a white coffee and on the other I
want a black coffee so we've got the
water and it's just giving both of our
coffees these values we've got the water
so the next step in the sequence I
actually want to heat the water I don't
want a cold coffee that would that would
be bad so I want to call this function
heat water after this has been completed
I want to add some beans to my coffee
now the difference between these is the
the one on the left is a white coffee so
I'm just gonna add some milk to it and
the end result is we end up with a white
coffee and a black coffee and this is
kind of a good idea idealization for
whatever the word is for imagine in how
a stream works so we we have the water
it's continuously given and it's up to
each coffee cup we want to decide so I
might press white coffee
I might press hot chocolate and it's
gonna add cocoa powder so essentially
it's the same stream and we can do
different things
and we get different outcomes so I've
split these up again so we have our
producer which is our water we'll start
with the water we can then heat the
water add the beans add the milk if
necessary and that that part is the
business logic so we start with the
water it's not business logic the coffee
cup at the end isn't business logic we
just consume it quite literally as a
consumer so for this we're going to
imagine
taking the previous diagram and actually
turning it into some fake code that
might be running inside of a coffee
machine so typically an observable might
have a dollar suffix on the end so we
can say this is going to be an
observable this is just a naming
convention what we could do at this
point
the first argument that we get is in
fact the water now you can ignore switch
map for a second so we first get water
we then have an arrow function I know it
doesn't have an equal sign which think
calls a function called heat water at
this point we take the argument and we
pass it into the heat water function and
we need to do this because this is this
is now our observable sequence and we
need to know when that heat water has
actually finished we don't want to keep
heating the water forever and the coffee
machine may explain now the interesting
piece is a switch map so when that's
actually completed our heat water
function we're actually going to get the
result from the heat water and we're
essentially going to switch to a
different stream or different observable
so we're actually going to get the hot
water back we're not just going to get
the water that we started with so we're
switching to the result of the heated
water so at this point we've got the hot
water and we and we want to add the
beans we're gonna pass the hot water in
the coffee machine can mix everything up
so at this point again we're doing
another switch map because we want to
know when all the beans have been added
we don't want a cup overflowing with
beans and at this point we get black
coffee and in this example we're gonna
add some milk and we're gonna pass the
black coffee in there's the function
argument when that's all done we then
have our consumer which is the resulting
coffee that we wanted and in a subscribe
you typically you want to do something
with it so at this point I'm just gonna
say I'm gonna add it to my cup and
that's that's that's the the coffee
analogy in terms of streams so now that
we've covered the observer the observer
pattern sequences and operators
when someone asks you about rxjs you can
be Joey how you doing now for the ball
now it's the most nerve-wracking part of
the whole talk this this throw is a fear
in order to blend our seamless
transition from one side of the stage to
the other we're going to distract you
with a shiny ball and it's going to be a
reminder of this particular friends
episode this episode was based entirely
around the fact that the friends were
throwing a ball around and the whole
game was just not to let it drop on the
floor we have already lost this game but
for example if I drop the ball the game
is now over now this is a lot of fun but
obviously we're developers so we love to
take fun concepts and ruin them by
writing code so that's what we're going
to do now we're going to think about
this game in terms of how would we
actually program this and fundamentally
were going to look at what would it be
like if we did it in an imperative way
and what would it be like if we did it
then again in a reactive way so here
comes a demo of what it looks like when
you turn what you just saw into an
application it's probably the best thing
I've ever made and I will be starting a
Kickstarter fund to productize it we're
seeking investment for this game so as
you might have noticed Todd and I get on
really well with the Brittney Mike's
because we love gesticulating so it was
actually really easy to find previous
talk photos of us both ready to catch a
ball so we're all ready to receive the
ball hopefully this page is refreshed
and basically we need some kind of event
to start the game so I've arbitrarily
gone for a start button so when I click
the button James gets the ball he throws
it well and Todd's dropped it let's
let's play that again that didn't last
very long James throws the ball it's a
good throw
Todd catches the ball good throw I
dropped it so basically there's a little
bit of probability built into this to
randomize the fact that we suck of it at
throwing and catching and we'll try and
cover the core concepts of this little
application in this talk so that was the
demo so first of all we're going to go
for imperative now in this talk
we're not saying that there's a
black-and-white binary imperative is bad
and reactive is good it's reactives not
some holy grail but there are always
different ways to approach the same
solution but we we have solved this app
we have fulfilled our brief of turning
this game into an application in two
different ways and they both work but
there are certain aspects of for example
the reactive one that might make its
ongoing support and our ability to add
features a bit more scalable so
fundamentally obviously we're dealing
with a little web application so the
elements of our game are turning Todd
knight in two divs and the ball is a div
and there's a start button so try and
keep up with those four moving parts
there will be quite a few things to keep
in your mind on the slides but we've
tried to boil it down as much as
possible something just to bear in mind
across both examples of imperative
reactive is that we have just a couple
of helpers involved so we have this add
Bal function and remove Bal function
that just handles making the ball
disappear for me and appear in tile and
that kind of stuff it doesn't matter
about the implementation details of that
it's not relevant and then we have the
exact mathematics of how likely is that
one of us will do a bad throw at any one
point and importantly we use that
information to inform how likely is the
other will catch it if I do a throw over
there it's much more likely that Todd's
not going to catch it than if I throw it
perfectly to it so we kind of got two
elements of probability in there the
exact probabilities are not really
relevant to the example again so
effectively we have for two dues in this
imperative example we want to start the
game from starting there clicking the
start button we want to throw and catch
the ball between us and then we want to
build in the fact that we need to check
if a given throw is good or bad and then
when it arrives at the other side we
need to check based on if that was a
good or bad throw did I catch it so
starting the game really simple we're
just going to be attaching a click
handler to the button so we're just
gonna have a function called handle
click and everything else we cover now
will live inside this handle click
function where I says odd game code so
we've done the first thing amazing
amazing progress will race
through it gets a little bit more
involved when we think about throwing
and catching the ball so we're going to
boil it down to we have this one
function called throw and catch between
and it's going to take two people two
Dom nodes in this case so we're just
going to throw and catch between James
and tot and that's our usage so this is
going to live inside our click handler
but then we're going to define the
function like this we're gonna have
person 1 and person 2 being passed into
the function and the key thing is here
we're going to have to make it call
itself so that we can keep the ball
going backwards and forwards in our game
so at the end of the function it's going
to call itself but it's going to swap
the arguments round so if James is
player 1 on the first call of the
function it's going to swap it round and
Todd will now be player 1 that will help
us minimize how much code we're having
to duplicate throwing backwards and
forwards between us after we've covered
that effectively what we have left to do
is we need to make sure person 1 starts
with the ball then we need to build in
the fact that there'll be a little bit
of a wind-up while we throw and then
they'll travel through the air and
person 2 will hopefully catch it so nice
and easy we've got a helper function add
ball to person 1 then we remove the ball
from person 1 as it flies we add it to
person 2 and then we go back again we
just keep calling that function so right
now we've just built in the way to add
and remove the ball from the two players
however this is effectively like saying
that we're superheroes
who always throw perfectly and it takes
us zero milliseconds or a fraction of a
millisecond to throw the ball between us
so realistically we need to build in
some human nature to this so all we're
going to do because we're dealing with
this imperative form we're going to have
to define our set timeout to delay the
fact that it takes a second before we
throw the ball so we're taking the exact
same code but we're just indenting
before we've removed the ball from
player 1 inside a set time and that's
just going to be one second we have to
do exactly the same thing before player
two receives it because the ball's going
to fly through the air for a second so
we've got one second one second catch so
still it's still pretty straightforward
is still pretty easy to deal with the
rest of the function is all still the
same so we've
fundamentally dealt with how would we
create a perfect game between people who
never throw badly and never failed to
catch it we've got an infinite game
going on forever all we need to do to
work out if the throw quality was any
good is just at the point at which it's
being thrown just just save that state
into a variable because we're dealing
with this imperative version we have to
kind of take that moment in time and
save it in a variable so that we can
access it at a later point in our future
set timeout for example so we just say
that 50-50 chance it's a bad throw and
we capture that in is a bad throw
variable so that's done as well three or
four not bad final points we need to use
that is bad throw variable later on in
our next set timeouts to check if the
ball is dropped so we had our helper
function check dropped so we're just
passing in our is bad throw into that
function and there's a probability that
if it's a bad throw off it's a good
throw it will be caught and if that
returns true then the game's over the
ball has been dropped so we will stop
our iterations of our recursive function
calls we've done it that's the
imperative example done nice and
straightforward
we have seen some potentially already
some weaknesses of this solution and
we're going to look at how maybe the
reactive solution helps us avoid some of
those things you might be thinking
already okay we've got some nested set
timeout so we're creating closures as we
go down we're having to pass state down
I mean to close over an outer variable
it's there's potentially some flags that
we've seen already for our reactive
example when you create reactive
programs or when you create reactive
solutions to things what you're really
thinking of is how can I build up an
event stream to look at from dependent
event streams so how can I break up my
problem into multiple small event
streams and then compose them together
to make a final event stream for my
overall game so essentially we can boil
it down to we need to observe somebody
clicking the start button has one set of
events one stream we need to observe the
whole concept of a throw all of that
that's incorporated the
wait as we throw it it's traveling
through the air we need to incorporate
all of that into some observable event
and we also need to observe the caching
process so those are our three streams
that we need to make up for our program
so again just like with the imperative
example starting it off is very very
simple rxjs which is what we're using
here there are other libraries for
reactive programming but obviously this
is angular camp so it makes a lot of
sense to use rxjs it comes with the from
event helper so we can just look for a
click event on our start button and
right now we could sum up our whole game
as the stream of clicks because that's
all we've done so far so we're just
going to call our game game dollar and
using that convention and at this point
we've done nothing because of the nature
of observables they're a bit like
functions that you've defined but you
haven't called yet so right now all
we've done is defined a function it's
only at this point where we actually
start listening for those click events
because effectively subscribe it's like
calling call on a function that you've
defined so this is the point at which
now we're now listening for click events
what we're going to do then is just like
with Tod where you showed you switch map
is we're going to switch map from those
click events
so those stream of click events that are
happening over time every time one
happens we're going to switch on to the
fundamental business logic of our game
here the handles throwing catch between
james and todd and the the only reason
that we're using switch map rather than
map for example is because our game is
fundamentally built up of observables
and switch map allows you to switch to a
different observable wrapped value
you're not just taking one value and
changing it to another you're taking one
value and changing it to an observable
of a value so this is how our game will
look in this reactive world we just need
to build up this handle throwing catch
logic so this was our usage how do we
actually define handle throwing catch
between so in the reactive world we're
just going to we still need the ability
to pass in our players as dependencies
so we've got player 1 and player 2 just
like with the imperative example but
this time we're going to be starting us
dream and because we don't really care
about the value a common convention is
to just use an empty string as a way of
starting a stream that you don't you
don't care about that initial value so
we're just going to start that stream
off and as we've seen before
rather than recursively calling a
function this time we can just use the
built-in repeat operator from our X yes
so we can just keep repeating this empty
string it's not going to do anything but
every time a button clicks we're going
to map onto this game so we've kind of
handled the first piece how do we how do
we take it from a button click to
beginning our business logic now we need
to think about what events make up a
throw to create that overall observable
of a throw how do we take these
individual events what makes up a throw
of it so let's quickly refresh our
memory of the imperative example we
basically have the following points to
cover we have person 1 starting with the
ball we have waiting while they get
ready to throw
we have person 1 throwing the ball we
need to capture whether it was good or
bad travels through the air so a slight
delay again and that's it that's the
whole throw event we could say that the
whole throw event is incorporated by
winding up releasing and the ball
traveling through the air that's one
throw so if we could set up a way to
observe that set of events as one person
throwing events then that would allow us
to build up a section of our program so
we've seen already that we're capturing
if the throw is bad by just using a
probability so we capture if it's a bad
throw and all we're going to do is
create an observable of that value so
all we're doing is creating a boolean
true/false and we're just going to
create an observable of that value so
that we can use it in our program to
build out the rest of this person
throwing the ball with those bullet
points I just mentioned we're going to
start off with a stream of true or false
events for whether the throw is good or
bad and we're just gonna use some
operators on it so that we can do our
side effects of adding or removing the
ball and incorporating the delay is
between throwing them so we're going to
start off with this boolean we're then
going to use the do operator so that we
can have the side effect
of the ball being added to my Dom note
this is just gonna give us a way to
perform some action as the stream comes
through it's not going to change the
value of the stream in any way and then
we're going to delay for one second so
in the imperative example we had to the
whole thing in a set timeout we had to
nest all of our program but in this case
we just need to use the very simple rxjs
operator called delay and we're going to
delay for one second person one throws
the ball so we remove it and we're using
a do again exact mirror image of our ads
and then we delay for the ball traveling
through the air again so our whole
example once we wrap it in a function to
be able to pass in which person this is
referring to becomes this code here
we're incorporating the quality of the
throw was it bad was it good as a stream
and when that happens we're going to add
the ball to the person that starts with
it delay for one second release the ball
and wait for one second while it travels
through the air we've managed to capture
for each given person in this function
exactly how a throw event takes place
because we've wrapped it in a function
like this as well we can make use of the
switch map again to switch based on the
logic we've just defined so we've seen
this is our usage as a refresher from
before we just need to plug in the
throws into our overall game so we've
got handle throwing catch between todd's
we start off our stream we're now ready
to plug in our throw logic we've got
player 1 having it set up as the handler
for switch map and we got player 2 and
we just pass in the two things there we
keep repeating so right now we've just
we're just both throwing the ball
somehow and there's no captioning in
between so all we have to do is repeat
the same process for throwing and we've
already encapsulated most of our program
in the throwing logic so the catching is
actually remarkably simple all we need
to do is use that boolean value to check
if we dropped it just like in our
imperative value and this time we're
going to if we've dropped it we're going
to return an observable that errors
immediately one of the qualities of
observables is that they have these
three core events that they
they can emit effectively you can have a
next value you can have a completion of
the stream so no more values from that
producer will be produced and you can
also have an error event and by using
this throw static method on the
observable we can create an observable
which immediately fires its error event
and so this will have a cascading effect
and kill the whole game because the ball
has been dropped if it's not been
dropped and we caught it successfully
again we're just going to create an
empty string stream that we don't really
care about the value we're just going to
add our ball so this will keep the
stream going and then we'll kick into
our repeat and so we'll keep going so if
we successfully caught it the game will
keep going so all we're going to do just
like with the throw we're going to wrap
it in a function just so we can pass in
that person so that we don't have to
duplicate the code between Todd and I we
can just pass in a person and so we have
our function which will take in our is
bad throw and be used inside of a switch
map because the only thing we need to
worry about in a switch map is returning
and observable so we're returning an
observable from both of our different
values one that errors immediately one
that doesn't and then all we need to do
is plug in the catch functions so we
have handle throwing catch between and
we have throws catches throws catches
repeats and this is one of the great
qualities of reactive programs is when
potentially you could see it as a little
more work upfront to conceptualize the
different events of your program but
once you've actually done that once
you've actually put the effort in your
program has become very very readable
and very very declarative rather than
having to fiddle with things in an
imperative way you can pretty much read
what this program does and that's one of
the great advantages so that's our three
dependent events we've built up our full
reactive example one of the things I
briefly was going to talk about was the
idea of where would we go from here with
these different examples if we wanted to
add a new feature for example Todd and I
are throwing the ball and right now it
stops if we drop it that's nice and easy
we've we've coded that but what would it
be like if we also said that we
throw and catch the ball until David
yells stop that is another way that the
game could end in our imperative example
we would have to add another variable or
another function which tracks whether or
not David has yelled stop yet and every
time the game could possibly stop we'd
have to check was that piece of state
true or false has David said stop has
David said stop we'd have to exit our
program at different points in that
nested set timer in the reactive version
all we would need to do is create a new
event stream of David yelling stop and
we could then use the take until
operator which many of you might have
seen in your angular programs because
that just gives us a way to kill our
event stream if another event stream
emits a value so often with these
reactive programs if you spend a little
bit longer mapping out the different
event streams it can really pay off in
terms of the future and adding new
features so that was the core concepts
we wanted to cover today
we've looked at the observer pattern in
general we've looked at producers and
consumers and a push based model of
producers going to consumers and then
we've looked at a little fun example of
throwing and catching a ball from the
friends episode to highlight how you
might approach different things in
different ways in an angular world we
have to approach things in an imperative
and reactive way a lot of the time
because we have a number of different
things which were built with reactive
programming in mind but we still have a
lot of things which weren't so we have
to deal with our templates often in we
have the async pipe for some reactive
programming but often getting things out
of our templates is not so reactive so
there will always be a mix and match
we're not saying imperative is bad and
reactive is good but it's often worth
thinking about is there more than one
way to skin a cat more than one way to
solve a problem thank you very much
thank</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>