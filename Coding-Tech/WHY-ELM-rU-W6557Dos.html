<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>WHY ELM? | Coder Coacher - Coaching Coders</title><meta content="WHY ELM? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>WHY ELM?</b></h2><h5 class="post__date">2017-09-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rU-W6557Dos" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I won't talk about Elm but before I
talk about Elm I have to talk about
everyone's favorite language javascript'
leaves actually done a great job of
setting me up here but I want to go back
to when we first started building these
kind of more heavy client-side
architectures in JavaScript and what the
kind of approach was and I think we
started with the the MVC the let's
replicate rails and then we discovered
this didn't really work but before we
figured out the components were the way
forward we had a lot of stabs we went
MVC when MV VC then we went MC v c v mm
CVCC c none of these really worked very
well and they they didn't report there
they were pretty tricky to to figure out
they caused lots of problems most
frameworks at the time focused on the
idea of two-way data-binding and this
this dirty checking or polling well you
have data in your your view that the
user sees and data in your code and
you're just constantly checking the two
to make sure they're they're kept in
sync I mean anything that's called dirty
checking can't be a good long term
solution right but got to a point where
this was so popular people even
considered adding it to the language
object.observe was a feature proposed it
even made it into a version of Chrome I
think and maybe other browsers and this
let us watch an object and get notified
when this object changed it turned out
however that long term this is a bad
idea and people began to think that we
can do better and it was confirmed that
we can do better this library that you
might have heard of came along and
really pushed this idea of immutability
and also components and it's not just
react doing this by any means if you
look at the latest version of angular
ember view j/s all sorts of frameworks
now are very much focusing more on
components rather than controllers I
said I can skip a whole bunch this talk
Li wasn't lying when he tweeted me
telling me he'd set me up for success
because he very much mentioned a lot of
the stuff that I'm gonna quickly touch
on to the problem comes because on the
client-side web apps have to deal with
changing of data all the time MVC worked
really well on the server because you
have much more control over how that
data changes you deal with post requests
and you can you can make sense of it and
control it very well in the browser
however you can have lots of HTTP
requests going different data sources
the user can do whatever they want
you've got brown
extensions all sorts of things that can
mess with you sorry this this mutable
data becomes very tricky to deal with it
can get changed from all sorts of
sources and it's just a nightmare to
work with as your app gets larger
so looking a bit more at the kind of
trends that we've seen more recently in
the direction we're going when it comes
to to Web Apps we started to see the
applications are begin to own their own
state so what we now have is mostly a
single source of truth which is where
all the data for your application lives
this data is stored as one big object a
JavaScript object you could even use an
immutable j/s record or object whatever
kind of type you need there and all your
data is now kept in one single
repository for you to manage it doesn't
all necessarily have to be there if we
look at it's a JavaScript talk I have to
do to do's as an example right if we
have like a to-do app you might let the
user I go to a specific URL to control
how they're filtering their to do's so
in the URL we have slash filter slash
completed that's a bit of state that the
user is in the completed filter so I
wouldn't then duplicate that in my main
application state because I'd have the
the data in two positions there it's all
about having a a single source of truth
most state lives in one place but there
are exceptions as as most of the answers
in computer science go it really it
depends which is all have really got for
you but anyway once we have that state
object our UI becomes just a
representation of that state at a given
point in time again taking to do MVC as
an example here I've got my to do and
it's done is set to true so it we we
have that one striked out on the list if
I swap that to false is now not done and
it's not struck through if I swap it
back though we're right back to to where
we were again once we've got this state
in one place it's very easy to build a
UI that represents that state because we
have much better control of all the data
and what we've also seen I'm bit worried
I'm going to get hunted down on Twitter
for this slide but what we have also
seen is that efficient rendering at
least initially is not a developer
concern things like react ember angular
2 etc Ellmers we'll see a very very good
taking the state changes and figuring
out the minimal amount of changes they
need to make in the Dom now I'm not
saying that you don't need to worry
about performance
rendering performance and I'm not saying
that developers shouldn't care about it
but least initially the frameworks will
give you a lot for free and enable this
this pattern to work if react when it
first came out was really really slow at
changing the DOM and dipping it it
wouldn't have got as popular as it is
today so it's great to see the
frameworks taking on some of that burden
but we we do still need to do work as
developers as well and then the tricky
thing is really keeping track of how
this state can change in the typical web
app there are tons of actions a user can
do that could that could change
something and really you want to be able
to very much model those in your
application and keep track of them this
is all about explicitly defining how
users can modify the state through
interactions like button clicks form
fills etc and also being able to trace
it I worked for a while in a big angular
app in fact I still do and stuff like
this but I'm not explicitly hating on
angular here that just plays very nicely
for my example you can modify things in
the view by just chucking them onto the
scope right and there are there are
patterns in angular I know that let you
avoid this but things like this it
becomes very tricky to track where scope
dot X has been changed or where it's
been mutated you don't know what called
that you don't know where it came from
and so on it can be very tricky when a
bit of data can be mutated in a ton of
different places however what we've seen
recently is a library called redux which
takes the approach that you should
explicitly define all the actions a user
can take for modify the state and these
are called these these are called
actions so this function had to do
returns an object that has a type and it
has some additional data and this is an
action that the user can perform and
we'll see in a minute we then have
functions that can take these actions
and deal with them and update the state
of our app the beautiful beautiful thing
about these is because they're playing
objects that can be logged and
serialized and you can replay them and
debug in and all the rest of it
so once we have actions and we have our
state we can have update functions that
can take an action on the state and give
us back the new state of the world
so if our state is an empty list of to
do's and the action is user added to do
the update function should take both of
those and give us back a new state if
you have followed redux these are these
are called reducers in redux because
they can reduce an action on the state
into a new state but the update function
is that just as good and a bit less
confusing so if we have this action you
lockout and my current state has a user
with named Jack in it I can get the new
state by calling update with both of
those and we just get back user
undefined so we now have functions that
can give us back the new state also
without mutating the existing state and
giving us back a whole new one
what's also really nice about this
pattern is your update function
encapsulate most of your business logic
which makes it really easy to test you
don't have to like fire up any UI or
deal with like mocking angular or react
or ember or whatever in your test
because it's just a plain function and
it also really separates your logic and
your user interface which is really nice
as a developer to work on I want to talk
a bit about data flow as well because as
I mentioned we kind of have the two-way
data-binding approach of angular and
early embers and all the rest of it but
more recently we've been taking this
almost unidirectional data flow so on
the left here we have kind of the
angular and the old way of doing it
where you just go back and forth
constantly you're checking and the new
way we have this this uni-directional
data where data only flows in one
direction around your application so the
user does something they fill out a form
they click a button that calls the
update that gives back the new state
which is given to the View function so
then rerender on to the screen in the
user and it turns out this just much
easier to reason with because you don't
you know where the data is you know
where it's come from and you know how to
handle it recommended reading and race
thoughts was definitely around here
somewhere and didn't pay me to put this
in honestly tell me that you should all
read uni-directional user interface
architectures which which kind of goes
into that stuff and a lot of detail is a
really good read so what you end up with
really is this this state at the top of
your app the big red box which can take
actions from components which are the
blue circles send them back up they get
dealt with and then the changes
propagate through your application but
data only flows in in one direction and
then we are update functions get a bit
more complicated and we can switch on
their types and we can deal with every
single user action that can occur and
then you have one place where most of
your business logic sits this is kind of
good but we still hit some JavaScript
issues it's very easy to accidentally
typo one of these user actions it's very
easy to forget to deal with one it's
very easy to return something in the
wrong shape like your your state will
have a specific
shapewear you're expecting certain keys
of values and it's very tricky to mess
this up when you have a big application
and it can cause weird bugs were like
something in your state get set to
undefined and it's pretty tricky will be
really nice if we can model these using
types so instead if we had a type
message which says these are all the
messages a user can perform it happens
to be called message because that's the
terminology in elm but you can think of
these as actions so these are actions
that the user can perform so we can have
a new user or we can log out and this is
a this is where Elm comes in so Elm L
tries to be a language to solve some of
the problems that Lee was talking about
that I just mentioned about these kind
of immutable architectures that we want
to build that for all the reasons Lee
touched on I'm not here to say it's the
perfect language yet I hope one day it
will move towards there I don't know if
there is such a thing other than
JavaScript right it's also not the
perfect solution to all our problems I'm
not here to say that you should all
ditch your JavaScript and rebuild an elm
although that would be great I do think
you know there are certain times where
elm is more applicable and also you have
to bear in mind the fact that elm is not
quite as mature as javascript and some
of the frameworks around so if you were
to google elm you'd probably hear that
it was functional typed and compiled but
those are a bit computer science C for
me and a bit boring
they don't make me really want to dive
into Elm so I've gone for the much more
exciting expressive self-documenting and
robust right cool
yeah there is a learning curve to this
there's a lot of new stuff in elm as
you'll see it's it's very dissimilar
from JavaScript the syntax is very
tricky if there's any functional
programmers or Haskell users in the room
then that's good I think you'll find the
syntax a bit easier to pick up for those
who haven't which was me I'd never done
Haskell or anything similar it does take
a bit of time but I promise you you will
get used to it and then really enjoy it
once you're at once you're there so the
code is very expressive it's very
functional it's a bit lispy so we call
add with one and two we get back three
we can map over list of numbers passing
this anonymous function the backslash by
the way for the anonymous function is
vaguely supposed to mean a lambda that's
how you can kind of around that one and
you can also do things like partially
apply functions a lot of things that
anyone familiar with this style of
programming
recognize we all stop this very nice
syntax called pipes so if we we have the
make person function that takes my name
jack I want to call that and take the
result of it and pass it to increment
age then pass it to increment height
hello I really don't want to get any
taller and then pass it to increment
weight we can instead of going from
there where you have to work from the
inside out you can use the pipes to to
make it look a bit cleaner
anyone who's written any elixir will
recognize this syntax as well
unfortunate for me these days it seems
to be more about incrementing weight
than anything else but we're doing okay
I think hopefully I don't look too bad
the syntax as well for Elm is just is
just really clean it's really nice to
you have income an age that takes a
person that's how we define a function
and then we take the person and then all
the properties to the right of the pipe
are the things that get updated
similarly add x and y is is very clean
and you can easily partially apply these
these functions with one argument so add
two as a result of calling AB with just
one argument to as I mentioned our mist
types which makes it very self
documenting you don't need to to tell
them what types you're working with it
can infer them automatically but it can
be really nice to add what's called type
annotations so if I have the add
function I can say it takes one integer
and another integer and returns a final
integer so the type on the rightmost
side what's over there for using it yeah
is the return value every other type is
the each argument in turn so is even for
example takes an integer and returns a
boolean I would encourage you to use
these and annotate your functions with
types it will save you in a couple
months when you come back to the project
and also kind of help the compiler out
as well then we have what are called
Union types and these took me a while to
kind of get my head around they're
basically a way of creating a type that
can resemble one of many states so if we
go back to thinking about filtering to
dues I might have a type called filter
which can either be show all or it can
be show completed or show active and
this is basically all the states that my
filter can be in what's really nice
about this I can then write a function
show to dues which takes a filter a list
of two dues and gives me back the new
list of two dues and I can use case
which is kind of similar to to switch in
in JavaScript and when the case that the
filter is of the show all type I'll
return all the two dues
if it's show completed I'll filter the
list to just finally completed to dues
and if it's show active I'll swap its
are finally not completed to dues this
is realized for a number of reasons they
can be checked by the compiler so the
compiler knows that you've dealt with
all the the cases correctly it's very
easy to change or rename one you rename
one if you forget to do it in all places
the compiler will will blow up at you
and it's really nice as well to be able
to work in your own terminology to say
that the show - dues function takes a
filter is is really really nice it just
makes things much easier to follow as a
developer and often in these client-side
apps were working a lot with JavaScript
objects right we'll have a big object
that probably came from an API that will
represent our user and all the
information about them in L we don't
quite have objects we have something
called records but you can think of them
basically as the same as a jar script
object literal and you'll often need to
pass these objects around your your
system you'll have lots of functions
that take a user object and do something
with them we can type these are known by
creating type aliases type aliases are
just saying right there's a record with
this specific set of keys and I want you
to act as if it's a type so say I'm
working with some API that gives me back
a person which is a name and an age I
can define a type alias person and then
any functions that either take a person
or return a person can be typed using
that person rather than just taking a
record this is really nice because your
code is much clearer it's cleaner it's
typed in your domain specific
terminology which makes it very easy to
work with the compiler will guarantee
your meeting those type requirements so
you can't accidentally take a record and
add an extra field to it or delete a
field because the compiler will tell you
that the types don't match and we can
avoid a whole class of bugs where you
expect an object to have a certain
property but it ends up not having it
because something's gone wrong somewhere
along the way and was also very robust
as well if we go back to JavaScript for
a minute if I've got an object and I
pass it into a JavaScript function what
guarantees can I make about that that
object turns out none right the the
function can just completely do whatever
it wants to it because it gets the
reference to that object and it can
mutate it as much as it wants that's why
we all love javascript in elm that's not
the case everything is immutable so if I
had this person right
Gordan Elm I call income an age it can't
mutate the person records it must return
a new person and then I've lost all the
mutation bugs that I've ever had to deal
with in my JavaScript career so just
there's a hole like blocks of bugs that
just aren't bugs are now because they
they can never possibly occur elf
functions are always pure as well a pure
function is a function that takes all
its input as arguments and it doesn't
need any external input so here the sum
function is pure because it takes a and
B and it'll return them added the other
sum function is not pure because it
relies on some external data window dot
foo so in the case of summer I can call
it with two and two and that will always
100% guaranteed before but other Sun can
be whatever the hell it wants because
something can be taped window dot foo
and an L you have to write pure
functions which means again you can't
have a function we're leech Ange it's
behavior because you've accidentally
relied on an external bit of data and
another problem that really hits us in
JavaScript is dealing with the absence
of data or something not being a present
I've got a quote here I call it my
billion dollar mistake does anyone know
who said this and it wasn't my boss
either hiring me no so this give me
another clue it was the invention of the
null reference in 1965 this by a chap
called Tony Hoare who said this has led
to a numeral errors vulnerabilities and
system crashes
he literally describes it as the billion
dollar mistake and one he wishes he'd
never made that was kind of the first
time that null or undefined in some guys
became it was influenced in the language
and then obviously it's been implanted
in every other language since within
reason and it causes a whole load of
bugs I'm a ruby developer as well as a
JavaScript developer we all had the like
no method foo or nil JavaScript we've
had you know undefined is not a function
or the rest of it
so Tony Tony Hoare made this mistake you
might say it's a horrible mistake but
that did not deserve any of that
applause and it's okay if you would like
to to leave the room okay I really
thought that was gonna go away but more
worse than that did anyway so no no how
do we represent a value being either
present or empty because sometimes data
isn't isn't there right if we take like
a react component
it might get some data from an API and
render it but when do we know that prop
star API data is actually present if
we're making this call asynchronously
and at some point that data will will
come back to us usually this means
wrapping your render calls in like ifs
or checking if the data is there and
using a different render function or a
different component maybe and all the
rest of it in Elm we have a very British
term called like maybe you can kind of
think of this like the shrug emoji or
the shrug command on slack it's got like
maybe this data is there and maybe it's
not so this is the type of maybe this is
built into the language and maybe is
either just a value or nothing so maybe
it's one of those Union types like when
we created a filter there may be Union
type has some data attached to it it's
either just that bit of data or it's
nothing so if we have if we take some
imaginary value as a value I'm either
just the integer 5 or I am nothing and
then I have the type maybe int because
there may be that might have an integer
around or it might not and this is
really important because now you you
can't possibly not have data when you're
referring to a variable so if we take
some lists one two three and I pull the
first thing off the list using list head
I try and times it by two if we have
data in that list this is great that
work I should point out this this isn't
valid L because list our head returns
and maybe if you imagine it wasn't and
if this was valid list our head that
would give us one times two and we get
back to believe this is empty we'll get
like undefined times two and then we've
got an error we've got a runtime error
on our wrappers blown up so you can't
you can't ever get into this state with
Elm because it makes you deal with every
possibility of the value not being there
and this I said this fish blows up if
list head is it gives us back nothing a
more concrete example say you've got an
app and you have a user who can log in
you might model them as maybe a user
which is a custom type you've defined
then in your view you have to use this
case statement to check if the user is
present or if they're or if they're not
so you can't ever forget to deal with
the case of some bit of data missing
it's just not possible and the compiler
will will shout at you this takes a
while to get used to I used to hate this
when I first got started with Elm all
these like extra bits of work to pull
data off but it turns out to be really
useful and also makes your app much more
robust just quickly we also have a
module called tasks which is used for
making a synchronous work mainly HTTP
requests and tasks either fail with a
specific type or they succeed with a
specific type and again you have to deal
with it you can't forget that a task
might fail you you have to deal with
that when we want to run a task we hand
it off to Ehlert to Elm in the form of a
command which is the thing we give to
Elm that it will run in the background
for us and we'll touch on those a bit
more later as I said there's a lot going
on here there is there is a big learning
curve but I hope there are enough
benefits to make you attempt it and I've
got a load of resources at the end as
well there's another really good blog
post by Andrzej that I'll recommend
called everywhere nassif ound ation the
old compiler makes sure 100% of your
code is thoroughly checked against
corner cases and error cases this make
Elm be almost able to guarantee that
your application won't have any runtime
errors at all ever which sounds like a
bit of a bold statement but it's
actually and be demonstrated to be true
in a couple of companies who are really
using Elm this is a quote from the
crater of arm Evan we also have a
compiler that gives extraordinary
helpful hints it's good enough that no
red ink which is a company who writing
lots of elm runs 36,000 lines of elm in
production and has never gotten a
runtime error from their elm code in
more than a year I think is is pretty
amazing we've got like track Jess at
work and then were like undefined is not
a function errors that just you've got I
hope a debug in them to be able to run
something like this is pretty cool most
compiler is also just amazing Corey
Haims tweeted this the other day so here
he made a typo so he was expected to
pass selected item but he passed
selected items the plural and Elm
compared it all and figured out where
his his typo was so just simple mistakes
as you spotted by Elm for you and you
just spend so so little time debugging
competitor 2 JavaScript applications so
I know I've got a fair amount to cover
so I'll trying to go fairly quickly
building actual apps are now and we have
something called the Elm architecture
and this is made up of three functions
we have model which just gives us the
initial model of our application so
that's all our data we have the view
function which can take the model and
produce the HTML that will be rendered
on to the screen and we have the update
function which can take those messages
or user actions and the current state
the current model
and give us back the new model an elm
deals behind the scenes with all this
data changing and re rendering on all of
it so when you have the what changed
question that the Li was talking about
Elm just does it for you and you don't
have to worry about it when your update
function returns a new state L will you
know diff the views and update the Dom
for you without you worrying because
it's all immutable data it's much more
efficient to do that as well in kind of
think of this date this architecture in
this kind of unidirectional flow that we
saw earlier we have the model the view
and the update and things go round in a
lovely circle so to build the hello
world of these kind of apps is a counter
app where we can increment and decrement
numbers firstly I define the model in
this case my model is just an integer
I'm just going to call it zero I define
a function initial model which gives me
back that zero secondly I had to find
the messages that the user can can make
or call Val clicking buttons in this
case they can either increment or
decrement the the number then I defined
my update so I take in the message in
the model if the message is increment I
return the model with one added if it's
D current I'll subtract one
fourthly the view M is a really good
HTML library the syntax of which does
take a little bit of getting used to
I'll give you that but you see there we
have a button once work one where we
click it more decrement and one where
we'll increment it then I put it all
together Elm ships with an HTML app
begin a program function where you give
it the model or the view in the update
and it just hooks everything up for you
highly recommend using this to get
started and then if we run that it does
indeed work and we can click on things
go I've got a link in a bit to get hub
where all the code lives by the way and
I'll go fairly quickly through it in the
interest of time but feel free to come
grab me or raise an issue on github
whatever you like so we left the view
until last which is property I really
like about building L maps that we can
just kind of worry about the UI less and
make sure our business logic is sound
and also the update function where I'll
call logic is would be so easy to test
because it's not attached to the UI in
any form dealing with side effects as
well so often will will need to not only
update some data but make a request to
an API to fetch some data for example
you know when we explicitly model those
so we hand some data off to Elm in the
background it will run our our task or
HTTP request and then it will give our
some data back when that
that task is being run so now we call
these commands so you give our command
it will go off and it will call your
update function once it's got some data
back so the L mech architecture part two
again there's a bunch of code I'll go
friendly quickly please grab it on
github come and find me today I'm happy
to walk you through it in more detail
because it can be a bit tricky to to get
this across to you in in five minutes
we've got a new signature for our update
function it now not only returns the
model but it returns a command and this
is some background work for Elm to do if
you want to think of this in diagram
form it kind of looks somewhat like this
the command is up there our date
function can give our commands it will
run them and then it will give them back
to the update function cert say I want
to grab some data from github I create a
get a person this has a name and company
and this is data that comes back from
the API and I have a model which has the
username I want to make the request for
and then they get her person which is
they maybe get her person because we
might not have the data yet then we
define the messages so we've got fetch
github data that will be sent when the
user clicks the button you get hub data
is what I'll get back when I've actually
resolved a request and got data from the
API and fetch error is if the API is
down or something goes wrong in my
request then we define the update notice
that we're now not only returning the
new model but also at any commands so
for example in the case of new github
data will return the model and will
update the github person because we've
got data now and then we'll also give
them command nun which basically means
chill out you don't have any work to do
in the case of fetch github data where
the users click the button I won't touch
the model I'll give it about the same
model but I'll tell it that I want you
to fetch this github data with this
username I won't go into how that fetch
github data function works so I haven't
really got time but again all the codes
on on github so again we've got our
update function we give it back commands
elm runs oak commands and calls back to
us then we define our view so again we
swap on the github person if it's just
the person I'll render the person's name
and company and if it's nothing I'll
show the button and have the load thing
finally we have the initial model which
use named Jack Franklin get a person is
nothing and our init function which
gives us back the initial model and any
initial commands we want to run this is
useful if you want to run a command when
the app first runs for example then I
hook it all together
ignore the subscriptions bit
is gonna try and pretend they don't
exist for now and if we run this we can
hit load and we do get my data back from
the github API you'll notice as well
that I'm actually using opera here which
I want to make perfectly clear is not an
attempt to influence anyone at this
conference at all so just just never
example go for this and diagram form so
the user clicks the button we call
update we give it the fetch github data
action and we return the new model and
we also return the fetch get up data
command which is over over here the view
renders in the background behind the
scenes we make a request the API in Elms
doing that for us
then finally we get that data so we have
this new github data message that has
come back over here so we call the
update with this new github data and the
model and we return our new model and
also command rock nuns we've done all
our work and then the view renders and
we get the data back I made this this
slide in keynote a long time ago when I
I worked for pusher rather than Songkick
and I couldn't find the original keynote
so there was no way I was making this
again so I've I've done this very subtle
update which I hope hopefully I get away
with okay deep breath that was a load of
code right and I'm fully aware like
through a lot of code and concepts at
you in a fairly short amount of time
this does maybe seem like a lot and I'm
aware there's lots take in but it it all
comes down to trading off boilerplate
versus explicitness I like that L makes
me write a decent amount of code I like
that I have to structure everything the
thing is it's much more apparent how
good this is when your application grows
fetching data from github API you could
do that in two or three lines of
JavaScript but you wouldn't have any of
the structure that the Elmer's has given
you here so I think it's very hard to
get across a lot of the benefits of Elm
in a small application but I'd encourage
you to try building bigger things with
it as well all the code is on github
I'll put these slides up our tweet a
link but that's me on github so that's
the the repo you can find all this code
I know I'm running out of time I'll go
fairly quickly through the rest and then
we kind of use components I just wanted
to touch upon this because I saw a tweet
yesterday which was really well timed by
guy called Scott he says the more
amusing Elm the more I see
the components were a mistake components
components needed to exist because types
didn't in JavaScript about types
JavaScript needs a way to isolate
mistakes from the rest of the system and
types like the ones in elm help us with
that a load I'm not sure I entirely like
I think the idea of some form of
components in Elm is is good but what's
really interesting if you do try Elm is
that you'll find you don't want to
create these these small components
you're quite happy with this bigger kind
of architecture so I think that's kind
of something to ponder all right very
briefly the Elm ecosystem how you get up
and running and all the command-line
tools that Elm gives you and reactor if
you install them you run em reactor it
will run it on a local server on your
laptop you can go to that URL and then
it will run your L map for you you don't
need to run anything else it's very easy
to get up and started you could do this
in like two minutes now on your laptop
if you wanted there's also an package
which is a package manager for elm it
does all the things you expect it's
really cool it's also I've got to show
you this the most British package
manager do you approve of this plan when
I was still something and if I install
like a specific package like the HTML
package may I add that to the package
JSON for you it's a very polite package
manager which i think is probably the
biggest selling point for me anyway and
there's so much more I haven't covered
like I didn't have time in half an hour
which I've already gone over sorry to go
into everything so I would encourage you
to check it out I've got a bunch of
links coming up but just to summarise
why when should you consider using elm
are you fed up of silly errors I
undefined function that take up loads of
debugging time you want to develop with
the confidence that types give you and
the clever compiler to back you up
I found that I write way less tests when
I'm writing Elm apps because I've really
confident that the compiler has got my
back and more spots silly errors your
happies are kind of ride the wave arm is
fairly new it's settling down it's
picking up a bit of traction but there's
a lot of stuff still to be done and
worked on you're happy to kind of build
some packages you know things like react
have this humongous amount of components
available on the net that you can pull
down and use Elm is a bit newer it just
doesn't have those yet you know more
packages get added every day but we're
still not quite a like a react or an
angular or Ember state what this talk
has put you off Elm I hope it has not
but it does take time to learn I know
this is can be a
overwhelming guy blank dog is like a
book freely available online that talks
you through everything highly recommend
giving that a go if you do give it going
you get stuck please come and find me
more than happy to help and also l in
the language brings many concepts that
leaves already touched on that a very
language agnostic saying even if you
don't use them in production there's a
lot of stuff we can take away from this
this kind of explicitness of the Elm
architecture and how things are modeled
across our app very explicitly makes
things easier to work with I don't think
I need to sell these too much but types
are great they have a lot of benefits
again immutability using something like
immutable J's for example gets you a lot
more guarantees about your data that you
don't have by default and JavaScript and
also the thing I like most is the this
process of defining your application
step by step so you define your model
define how the user can interact with it
define how those interactions are dealt
with then define your view and rinse and
repeat over and over again I think that
approach has really stuck with me will
everyone be writing Elm in 1 2 or 5
years guess what
it depends I have absolutely no idea I
think it's a really cool experiment it's
great fun
as someone who's written primarily kind
of JavaScript and Ruby over the last
four years picking up something very
different like almond working with it
has been really really enjoyable
I've really enjoyed hacking on it so I'd
encourage you even if you don't think
you'll write use this in production
which not many people are to pick it up
and give it a go because I think you'll
have a load of fun doing so so yeah as I
said I'll put the slides online and I'll
tweet them with the hashtag I'll put
them in the slack channel but here's a
few links to take away guide elm lang is
the best place to start the docs are
where all the API Doc's lives community
has links to like the IRC the slack
Channel etc which is very active
there's my talk as well and the slides
will go up on speaker deck afterwards so
thank you very much for listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>