<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Blockchain For Software Developers | Coder Coacher - Coaching Coders</title><meta content="Blockchain For Software Developers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Blockchain For Software Developers</b></h2><h5 class="post__date">2017-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1fKnjMGmB2U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is Mark from kike and I'm
working for info support as a blockchain
technology expert and today I want to a
couple of questions for you first of all
well there's a blockchain how does the
blockchain fit in a software
architecture because a blockchain is
never a thing on its own and when would
it be appropriate to look into
blockchain in the four projects of yours
one of the interesting things about
blockchain and if I take Bitcoin for an
example of what we want to achieve there
is in Bitcoin we want to transfer money
from one person to another person
without relying on a central party like
a bank in our current system we need two
bank we trust a bank there in the
software we trust that they do
everything correctly but if you want to
remove that level of trust you need a
different system a peer-to-peer system
and you need to solve a problem how can
you do this a very naive way to start is
les model coins and banknotes as files
but then I can copy a file and give it
to you and I can copy the same file and
send it to you so we want some way to
find out that you did not copy this file
so this approach is not going to work
I'm going to tell you what the
blockchain is and I'm going to introduce
five ingredients that will be there in
every blockchain the first one is a
state machine and in a state machine you
have a couple of of components you have
a state where you start in it's the
initial state and you have messages
going into the state machine and you
have a transition function that takes an
INT state and a message and it will
progress into a new state so to make it
concrete you see here an example where
both the message and the state are
integers or numbers initial state we say
we have a value of 0 and the message of
failure 7 comes in and our transition
function just adds the two failures so
if we apply this function we'll we'll go
into a new state with a failure seven
we can repeat this over and over again
so when we send in a message with value
minus five we sum the two we come to two
now in blockchain we have extended this
concept of the state machine a little
bit we've added a validation function
which acts on the same two input
parameters a state the current state and
a message but it will output a boolean
value a yes or a No it will say this
message is valid and allowed to to be
acted upon in the current state so if we
take a salad ation function one that
says the message the value must must be
higher than the value that is in the
current state that in this case seven is
higher than zero so it's okay so the
failure sailfin flows to the transition
function and it is applied so we go
forward now if the message minus five
comes in it is smaller than seven so
this one is blocked the message sixteen
sixteen is higher than seven so this one
is allowed now if you think about this
in for example and money transfer
context what would this what would this
be the validation function checks
whether one step back the state contains
information about balances for accounts
so it would say in the account of mark
itself in euros and in the account of
jean is 12 euros and then a message
would say I want to transfer five euros
from the account of mark to the account
of gene that is validation function then
can say this is not allowed if there are
less than five euros in the account of
mark so it will say no and it will not
be executed in this case it is so the
transition function will be executed
will which will remove five euros from
the account of mark and add five euros
to the account of gene so this is our
first ingredient the next one we need is
a distributed network I've created one
here there are four nodes and they are
separated in different persons or
different organizations so it's not that
one organized
is running a cluster of nodes like you
would do with for example a Cassandra
cluster and here this is actually
distributed across organizations or
persons we need those notes to
communicate so let's add some lines and
we need to be able to pass messages from
one node to the other node but we don't
need to be fully connected because nodes
can forward those messages so when a
message is sent from the left most node
to the one at the right top it can
forward it to the bottom right so
messages don't you don't need to connect
everything to everything now let's get
our previous ingredient and put it in
here every node runs a state machine by
itself and thus exactly the same thing
as every other node so in here you can
see the state machine running in all the
nodes just as we have seen before
now let's say so on inserts this message
- five into a node this message is now
distributed across the network and each
node by itself will run the validation
function and we'll see no this one is
not relative the sixteen comes in maybe
at a different note it was forwarded
across the network and every node for
itself can now see the sixteen is valid
and will progress into the next state
this is one of the ingredients we need
because now you need only to trust your
own node you do not need to trust what
everybody else is doing if they're going
to screw up make mistakes or actually
try to do things differently not by the
rules of the games they will end up in a
different state but you can trust your
own your own node but this is not enough
let's say this following happens these
two nodes there may be geographically
separated and both have a new message
twenty nine and 72 let's see what
happens in this case they start
forwarding but we don't know what
actually should happen because some
nodes will receive 229 first and
notes will receive 272 first so let's
take a look at what happens inside this
note we were at state q2 the message 72
comes in the note will decide 72 is
larger than 23 this is okay so we
progress to the next state where now we
sum them up to 95 and we see the new
message 29 is not valid so okay this is
what we do but let's take a look at what
this note is doing it will first see the
message 29 so 29 is larger than 23
that's okay we continue we are at 52 now
72 comes in which is larger larger than
52 so we progress into a state where the
value is 124 now we have a difference so
here we need a new ingredient and that's
consensus all those notes all around the
world or maybe just in one country
doesn't really matter they need to
achieve consensus on which of those two
progresses is going to be the truth
which of them is the one we will assume
is okay and which is the one we should
discard now there are several consensus
algorithms and for those of you who know
Bitcoin the part of mining what we also
call proof of work is is one of those
implementations but there are others I'm
not going to dive too deep into those
because we don't have too much time but
I'm going to show you two classes of
consensus algorithms the first class is
a lottery type and then a lottery type
watry what we do is we assign lottery
tickets to all nodes and the exact ldren
algorithm we choose decides how those
tickets are distributed and then one of
them is going to win let's say this
ticket and what that means when this
node has the winning tickets is that
this node can say ok this is what I
believe is true and I'm going to send it
to you and you are now also going to
believe this is true so another node
might have fault this is exactly what
what
that's okay he will do nothing will
change
but another mode that has at first
decided on a different ordering will now
refer to what he thought and will agree
on this is the correct ordering so from
this point on we all agree what is the
the real truth for those of you who know
Bitcoin we do this by mining and
actually you could see every hash you
try is one of those tickets but there
are other ways you could do this you
could for example say every euro you
have in the SAS system you get a ticket
so those that have the most euros have
the highest probability of proposing new
state to go forward the other class of
algorithms is for voting it's a folding
style and this one is not really
suitable for systems or a block change
that I use where everybody can join but
if you're using a blockchain where you
have a group of participants and you
know who are participating you can use
this style and then you can say someone
is is going to propose let's say this
one and the exact algorithm decides who
it is it could be always the same it
could be round robin it could depend on
something else
but then this party is going to propose
a new state to move forward an ordering
of messages to move forward and he's
going to propose this on to the network
everybody who sees this proposal then
stamp set to say I agree and now if the
majority agrees with the way forward
then we all assume this so in this case
if only two of them say I agree on this
state and the two others say I agree on
this which state we could get a split
but two is not a majority if we have
four participants so if you have three
and a participant saying this is how we
move forward
then you can say okay this is what I
what I accept there are some advantages
and disadvantages for choosing either of
them if you are interested in learning
more of them come come to me after this
talk
okay so now we have consensus there's
our third ingredient but consensus is a
process that takes time it takes
resources and therefore every
transaction we want to reach consensus
for every message going into the
blockchain we would have to do a hell of
a job and this would be the bottleneck
in a blockchain so the next ingredient
what we what we need is a chain of
blocks we're going to group those
messages in blocks and you can see it in
this way we started at zero and messages
are flowing into the system and at some
point we're going to say now we're going
to do this consensus algorithm we reach
consensus on a block and this block
contains a list of messages and while we
do this consensus algorithm new messages
can flow in and any node and you just
queue them up and when the next round of
consensus starts and you pick this new
list this new set of messages and you
vote on them now if you also add in
every of those blocks and the hash of
the previous block and the cryptographic
hash like Asha function then you get
another property you cannot change
anything in the past anymore because if
you would do so the hash of your block
changes and therefore on the next block
you will not have a valid value pointing
to you so with this we have a history of
messages which cannot be changed
afterwards anymore and we have the same
transition function and validation
function everywhere so if you start at
the first block and go over them all one
by one you will end up at this exact
same state as every other participant in
the network without needing to trust any
individual or the party so now we have
four ingredients we need one more
ingredient because in this blockchain we
created now there's one thing I
which gene would not like I could insert
a message into the network sending five
euros from her account to mine I would
like but then I know someone else can
take it back from me again so we need
authorization an authorization is in two
parts reading and writing the reading
part the principle is very simple
everybody sees everything and this is a
logical consequence of the fact that all
the messages are propagated through the
entire network and everybody runs the
same note so you need to see all the
messages otherwise you cannot validate
whether or not in there is enough
balance for example this is true however
there are some solutions and two of them
are being investigated at at this in
this time and one of them is using some
advanced cryptographic s-- for example
there is a project that is trying to see
if they and they actually succeeded if
they can make a modified version of
Bitcoin where you can hide the amount so
it is encrypted in such a way that you
can still be sure that you are not
spending bitcoins or currency that is
not yours that you have never received
before but nobody can see how much how
much you own how much you are sending to
someone and this is they use homomorphic
encryption for days other technologies
that people are looking into a zero
knowledge proof but this is really the
dark magic of cryptography another
solution you could choose is to look
into hardware and this is something that
intel has done for example intel is
creating the processes two CPUs of your
computers and an insight some of those
CPUs they have created something which I
call as the X technology and it is an
enclave where you can send encrypted
data in inside the CPU it is decrypted a
program can run the output is encrypted
again before it is sent to your ram
memory so even if you put I'm going to
measure what happens on the pin of the
processor you will never see the
unencrypted value and also your
application and your operating
unable to see this so using those kinds
of technologies you can build privacy in
a blockchain but you need to rely on
Intel being honest in some level the
other side is writing and this is a
problem which is actually solved we use
a submit a symmetric cryptography for it
you have a public and a private key
using a private key you can create a
signature and put it with a message and
then the receiver having the public key
is able to verify that this signature is
actually created using your private key
and not by someone else now if you have
here this message saying I want to send
five euros from the account of gene to
the account of Marc then the validate
validation function needs to check two
things one the signatures actually felid
and to the public key or the private key
used to generate the signature is
actually allowed to send funds from the
account of gene and the private key I
have is not allowed to do so I can only
send funds from the account of Marc so
now we have five ingredients with which
we can create a blockchain we have the
state machine which consists of a
validation function in the transition
function we have a distributed network
such that every participant can run its
own node runs its own copy of the state
machine we reach consensus using some
algorithm and then we form a chain of
blocks and we use authorization to
prevent anyone from doing whatever he is
not allowed to do I wanted to prepare a
demo using a Java blockchain but due to
some time constraints and and an
expected defense I was unable to finish
it but to not let you down too much I
can show you a different one which is
using aetherium
and I'm going to marrow my scream so I
can just look on my own machine what
we've created here is a network where
some people can generate power for
example using solar panels although
people are using power this is Dutch by
the way and here are some meters that's
that measure the amount of kilowatt hour
that is flowing through this wire and we
wanted to create a network where we
don't need to rely on any trusted third
party we don't want to use a web server
somewhere we don't want one of those
participants to run a centralized
database that everybody needs to check
to trust so what we created
we used a blockchain for this now in
those segments that these two blocks
they need to sum up to zero so the
amount of energy that is flowing in must
equal the amount of energy flowing out
and if that is not the case then some
things could be happening either there
is a malfunctioning thing where
electricity is lost due to an decay in
cables for example or someone is
attaching a line to there to this cable
stealing electricity that is not theirs
or someone is tampering them meter but
in any way if those values do not some
do not sum up to zero then something is
wrong and you can start investigating
now I don't have the real meters in here
but I first have to stow
I first start the consensus algorithm it
is taking quite some CPU power so I only
run it when I'm actually doing this
presentation and now what I can do is
for this meter which has registered 80
kilowatt hours before I'm now going to
or 86 I'm now going to set it to 80 and
what we will see that is happening is
that the system will notice it is no
longer 0 and an alarm can be raised and
the interesting thing about this
blockchain is that every participant
which has one of those meters can run
its own copy of the blockchain and every
one of them will by themselves come to
the conclusion that there is a problem
and the problem is in this segment and
now we don't really know what is wrong
but at least everybody who is
participating here can go and see start
an investigation and that's something
that you can probably do collectively so
let's go back to our presentation very
good so this was just a smaller example
now when you're creating a blockchain
your blockchain will always be part of a
bigger thing so in the example I just
demonstrated there is a blockchain that
stores the kilowatt hours that has been
measured that is able to say at this
point is a problem the measurements
don't add up but that's just one part of
it outside of which you build the
measurements you need to inject them
into the blockchain maybe you want a
graphical user interface etc so to
answer this question I'm going to take
CQRS as a starting point and as a
reminder or for those who don't remember
secure as secure as is an command and
query responsibility segregation so
reading and writing a system is
something different
on the left side of the system binder
boundary here we see a system and on the
right side we see a user interacting
with the system which could be a person
or it could be a different system when
this person wants to read know something
about the current state he's going to
ask the top surface a question which
will use the database to answer this
question now this this can be for
example Cassandra cluster it is
optimized to very quickly also read
questions well when he wants to change
something
he sends a request to a different
surface on the bottom side and here is
some business logic involved you can do
authorization authentication input
validation all the old stuff and see
whether everything is OK
and then you write something into a
database and this database is then
informing another surface or at the
surfaces another server squaring this
database and transformed this into such
a way that the reading side can very
quickly give answers again to questions
now if this lower database is just a
journal a journal where you add those
commands that are happening and time at
the end and never change anything before
it anymore
then what we created this event sourcing
the interesting thing about event
sourcing is if for whatever reason you
want to rebuild the top part or you want
to scale it out one if a simple way to
do is just start reading the journal
from the beginning run it through the
surface that is drawn on the left and
you will come up with the same database
at the top in the end so this journal is
an is an event lock and it'll append
only so to show it this is the state
machine we've seen before
if you see how this maps to a journal
this is what you store in the journal
only the messages now that's very
interesting because we've seen this
before it looks a bit like the input to
the blockchain so this journal we could
replace with a blockchain and what we
then get
is a system where we can put messages
into events messages transactions they
now all are just the same thing they go
into this this blockchain the blockchain
distributes herself or the network and
when consensus has reached about the
messages then the blockchain could
output this and the surface on the Left
will be able to update database on the
top again in fact it is a bit more
difficult because there is a extra
database often enforced because you want
to do some administration but this is
the general picture this is also how for
example a Bitcoin wallet works the
balances that are actually showing and
when you use the user interface to see
what is your balance this balance is not
actually recorded in this form in the
blockchain so you transform and using
this surface on the left and store
something in a local database that that
is just for you for your person for your
organization in the information that is
relevant for you and what is then stored
in the blockchain are just those things
that are needed to in the future
validate whether new messages I fell it
and to move forward in this system so
now we've seen what the blockchain is
and we've seen at what place in an
architecture you could put it there's
one final question I want to answer when
is a blockchain appropriately well the
simple answer is in most cases it is not
and what you see on the Internet is a
lot of people hyping about this
technology and saying Oh blockchain this
is the Silver Bullet and we're going to
do I don't know but it is not always and
in most cases not even a good solution
or the best solution there are five
things you really need to answer five
questions you really need to answer with
yes and if all of those questions are
answered yes then blockchain may be
appropriate if one of them is answers
with no then just find a different
solution so the first question do you
need a data store if yes okay let's go
to the next question are there multiple
Reiter's if no then just take a file on
your heart that's going to take an
Oracle or sequel surfer database and put
it in your organization and build a web
surface on top of it or a user interface
and you're done
but those multiple writers even this is
not enough they do not need to trust
each other completely if they fully
trust each other then I would say maybe
not but go for a spreadsheet on Google
Docs but I do not trust everybody
especially not if it comes to my money
with two other valuable things so people
may be honest but I don't know they may
lie and if this is all there is there is
a simple solution you could pick a third
party and I don't know for example how
it works in Poland but in the
Netherlands if you want to transfer an
ownership of a house you go to a notary
you make a deed and we all trust this
notary so we don't need a blockchain to
store who owns which house however if
there is a situation where you don't
have such a third parties as you can
trust or you don't want to trust or for
a political reason it is a difficult
thing then a blockchain may be
appropriate this could for example be in
Bitcoin we don't want to trust banks but
it could also be in international trade
for example in Europe
if you pay with euros you have like an
iron key where we as consumers trust
commercial banks commercial banks trust
a central bank the European Central Bank
so that's okay and in the States is the
same and the top there is the Federal
Reserve and in the UK we have the Bank
of England but if there is trade between
those continents there is nothing above
the ECB there is no global trust of
party for money
so in those that's also why those
payments are more expensive commercial
banks are using other mechanisms to
transfer funds across continents across
currencies so in in this example of
blockchain could be something that is
moving forward or an order situation
could be an international
trade when I want to import as an import
are able to import Kiwis from New
Zealand I trust my bank here in our
country but I do not know all those
banks in New Zealand I do not know which
one I want to trust and the other way
around the exporter has the problem in
the other way and those banks don't
trust each other also completely maybe a
little bit but not completely so here
this is a very expensive process that's
going on over there a letter of credits
and stuff this is a place that may be
solved with book chain but there is one
more question we had to answer I said
there were five I've only had seen four
now
is there an interaction between the
transactions that you want to put into
the blockchain if no then you may not
need a blockchain for example here what
we have seen is this example with 1629
and 72 going into this state machine and
the ordering seemed to matter because if
you change the order then one message is
no longer valid anymore so there is some
interaction between those if this
interaction does not exist then what you
could do for example is create a digital
document just put a signature on it and
that could be enough so if for example I
want to prove or if I'm going to give
someone a note with a claim with a
statement that again get something for
me I can just put a signature on it and
then later on they can show this this
document with a signature say you have
made this statement I'm here to collect
my claim but if this claim can be
invalidated by some other transaction
then a digital signature is no longer
enough so then you could say okay let's
take a look at blockchain so the five
core things you need a database with
multiple writers that do not fully trust
each other you don't do not need to
fully distrust each other but also not
fully trust each other you do not have
or won't a trusted third party and there
is some level of interaction between
messages
and if all those things apply then I
would say give me give me a heads up a
call and I'm really interested in said
looking with you further if blockchain
is still appropriate and if yes start a
project with it are there any questions
okay the question how can I run a
blockchain on my computer
well one thing you can do is download
Bitcoin and you have a blockchain
running on your computer if you want
something more and what I always say is
a very easy way to start this with
aetherium and the theorem is an
open-source blockchain it's written in
there's a client written in go and one
in C++ and there's also a jaffa one
nowadays and in a theorem you can create
a network for yourself or you can
connect to a global network you can
actually start creating applications
that run inside those nodes so if you
create application which you run inside
in a theorem network then whatever code
is executed is executed on all those
nodes and everybody will come to the
same conclusion so that's the easiest
way to start programming with blockchain
if there are no more questions I would
like to thank you I wish you a pleasant
stay today</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>