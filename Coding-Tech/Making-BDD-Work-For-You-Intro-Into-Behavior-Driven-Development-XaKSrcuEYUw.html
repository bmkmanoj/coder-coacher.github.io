<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Making BDD Work For You (Intro Into Behavior Driven Development) | Coder Coacher - Coaching Coders</title><meta content="Making BDD Work For You (Intro Into Behavior Driven Development) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Making BDD Work For You (Intro Into Behavior Driven Development)</b></h2><h5 class="post__date">2018-03-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XaKSrcuEYUw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's talk a bit a little bit about
behavior-driven development and how to
make it work for yourself and your
project with your tools like in a very
lean way and sorta to speak but first of
all you know that's certainly in the
morning let's do a little bit like
warm-up exercise everybody just like
lift your head I just want to see like
who was really too tired to do this this
morning okay good this works so basic
mechanics are there I would like to know
you know who am I talking to who are you
guys who calls himself a developer
that's almost everybody so that's
through the counter check any designer
Sears like who calls himself that's
great okay so too was that third one I
feel like there was a third one to at
least that's cool any managers was like
not really programming anymore much all
right that's great because this is a guy
I'm always hoping like to get some
managers because this is mostly you know
for like the communication between
developers and managers and if always
feel like are there's no managers but of
course it's a technical conference like
it's a developer heady but I'm happy
this is changing because every year
there they're like more non developers
or like a former so anything else I
missed like who like POS PJ's I don't
know like not hip anymore
all right so those I like the broad
categories that I like to use anyways so
now that I know you let me introduce
myself my name is Nicholas Martin so you
can find me on the web on Twitter and on
github and I started programming like in
early teens with QBasic neq basic people
who started with Cuba's you're like all
right this is getting less and less
every year well then I did some power
over Java mostly web stuff studied in
Munich at the technique university
worked at ResearchGate for a couple
years mostly with PHP that's where I
picked up all my PHP knowledge and now
I'm freelance consultant in Berlin so
this is where I get a lot of exposure
with startups from like early-stage
projects stuff like that's a lot of fun
and I I consider myself a software
engineer I like the engineering
because it's not I mean the whole
tanning you know and like building stuff
like that's what engineers do right but
for me an important part about
engineering is not only thinking about
your problem and how to solve it but
also to improve the process of solving a
problem so this is what we usually call
mythology right or methods that like to
identify the like hurdles that you find
in every project and good ways to get
around them because there's certainly
similarities between every project so
this is where I found or like how I
found behavior driven development
through this looking into you know how
can I become better at building stuff at
solving things and the question of
course you should always ask in the
beginning is why do we even need to do
this why do we need methods and and why
do we need something like behavior and
development and it's most because okay
so this is I mean we're mostly
developers here so this is us I hope you
can identify you know it's a little sad
looking guy almost because his life is
very hard because he has to work with
these things with the computers and
they're stupid I mean they're awesome
but they're really stupid and they take
everything you tell them very literally
so like even if you tell them something
ridiculously contradictory or something
that they'll do it anyways but it gets
even worse because he also has to work
with those guys you know we call them
sorry everybody of the manager type but
we call them the business the Tyus you
know and we a little suspicious of them
right because they talk a weird language
they talk like and I always like seem to
only care about money so it's a little
bit odd and it gets even worse because
we also have to work with these guys our
colleagues you know we'd rather just do
our own stuff like right but we can't we
have to work in teams to collaborate
usually systems are too big for just one
person
so that's awful and so we need to do the
thing right and it turns out it's really
tricky to do the thing right even if you
know what the thing is just to teach it
to that stupid machine it's surprisingly
difficult and we're still struggling
with it
even like 60 years after the first line
of code was written and we not only have
to do a thing right we also have to
figure out what the right thing is to
do and that turns out it's also
surprisingly hard because nobody knows
what they really want
you cannot just ask them you have to
find it out like step by step it's awful
so and the last thing is of course we
have to do together because the
collaboration is key and how what I like
some common tools to solve this problems
well we have like specifications or
stories so we try to make clear you know
like best-behaved before we even start
working on the project right we say like
okay what is that what we have to do
okay we have to do this and this and
this and this and how much is this going
to cost so we try to get that straight
and then well the best thing I think of
like making sure that you did the thing
right is to you know test it and of
course you can test it yourself
or you can teach the machine to test it
which is even better because then you
don't have to do it yourself and the
program is always like the lazy type
right we love automation because then we
don't have to do it ourselves so that's
a good idea and then of course in order
to collaborate we need to describe what
we're actually doing and I mean what is
in the code but we need to describe why
we did what we did right what our
intentions were and how this thing is
supposed to use but the problem with
these things are released in my
experience is that the specification
always leaves something out it's never
quite never answers all the questions so
it doesn't matter how much time you
spend writing a good story or a good
specification when you implement it you
always realize there's something we
forgot so you always have to go back and
then there's confusion and then you
realize oh there's something big we
forgot it's terrible and then tests
anybody who's like big into test-driven
development who loves it and joy is it
really only okay that's not too many
what I'm a big fan obviously but if you
have a lot of tests and they sort of
become their own problem right suddenly
you have a lot of tests and then you
have to maintain them as well you have
to maintain your production code and the
test Suites so that's suddenly a lot
so and then documentation is basically
by definition outdated like the moment
you wrote the documentation it's
probably not even up to date anymore
because somebody changed something in
the code so I don't know like who has
ever written like or like found a piece
of documentation which was not true
anymore and it cost you like half a day
to find out that it was actually
documentation okay so this is actually a
common problem I have this all the time
I'm always very suspicious if I find
documentation I always try it out first
so you know it now comes the good part
if you combine all these three things
and you try to like find a common
denominator of what like specification
tests and documentation has in common
you find that they're actually all just
examples of how to use the system right
the specification describes the use case
and example before the system spilled
the test described an example for the
running system and the documentation
describes something like about the
system after it's built so we can we can
try to extract it and say okay there are
examples so why don't we use this method
called specification by example and now
maybe you're wondering what I thought
this is about behavior driven
development what is specification by
example well has anybody ever heard that
actually the term specification by okay
does one to two people three all right
so this is a very not very known term
but maybe you've heard of example driven
development who was heard of that nobody
okay that's even less agile acceptance
testing well okay
acceptance test-driven development
there's a lot of those okay a C and of
course behavior driven development who
is heard of that so obviously then North
does the best marketing of them all
because this is the term that stuck
around but I feel like you know for an
industry or for like a field that spends
most of their day naming things which
sometimes surprisingly bad at naming
things because all of these are very
similar things they have a huge overlap
and even worse if you asked like five
people what behavior-driven development
is you probably get five different
answers and this is not only here it is
the same with like automated testing you
know there's no really consensus of what
a unit test is what an acceptance test
is what assistant test is was an
end-to-end test this we have no idea
what we're talking about which i think
is weird because that's our main job
right it's through like makeup concepts
and find name for those so this is the
main reason why I like specification by
example because I'm actually not sure if
I'm up to date I don't think this is
there a book about behavior driven
development by now and I totally missed
it there's not right okay yeah but none
there's no book called behavior driven
development right so that's always my
problem because if you want to be able
to talk about something you need to like
know what you're talking about so you
have to need you have to have a common
understanding right and if it's just
like a bunch of blog posts or somebody
describing like a nice idea ten years
ago and then it went in like a hundred
different directions then you know you
cannot really agree on something and
this is why I like unknown terms better
like specification by example because
then at least you know I can tell you
what I think what or what the book says
that's with sophistication by example is
and we can have to agree on that if you
think anything is not really good in
that book you can write your own book
but at least we have something some
corpus we can agree on and so I always
have problem bronzing that gosh gosh
cool
that's a cheek rotus I forgot when I
think 2008 or something like that and he
tried really hard to find good names for
things
problem is he didn't find very sexy
terms he calls it validating frequently
or refining the specification what we
might call refactoring or illustrating
using examples what we might call like
specs or my favorite automating
validation without changing the
specification we might call that
continuous integration so he's like he
tried to find his own terms for a lot of
things that already have terms with the
hope that you know to have a better
definition and I appreciate that so this
is why I'm using it alright so this is
I'm going to call it specification by
example from
and you'll see why because it has the
word example in it and I really like
that one but what is it really it's not
a project management like method so if
you hoped I would like to tell you how
to manage your projects with
specification by example sorry and it's
also not a tool alright so this is
something I find a lot is that behavior
driven development is basically like
synonymous with the various tools with
cucumber with B head like gherkin they
think this is what behavior driven
development is but it's really it's
really not because it's something about
communication alright it's a it's it's a
way to bridge the gap between the ties
and the glasses between the business
oriented stakeholders and the technical
oriented stakeholders this is what it's
for me so you don't need heavy tools you
don't need a new like software to do it
you can just do it with your current
tools with your current process and you
just have to to concentrate on the
communication so this is what I'm going
to concentrate on as I said there's this
there's those two main actors and a lot
of companies I work at I always feel
like they're fighting I always feel like
you know it's like ah we need to
refactor this now we don't have the time
or the money but quality but money but
you know time to market and they can't
ever agree on what is what is more
important and I think that's ok because
you know our job as engineers is to make
sure like we do the best we can on the
technical side and the job of the
business stakeholders to make sure that
he does the best for the business from
the business side and there sometimes at
odds but that's ok and I just see like a
lot of times it's like taking personally
you know when I tell I tell somebody you
know you don't know what you're talking
about this needs to be fixed ASAP then
and there like neuron first we need to
find a good client we are in the same
boat we're finding this for the same
cause so this is important like to you
realize logically because yeah as I said
the the business people that think about
you know features ideas the the
bottom-line of course
and technical people they think about
the structure of the system and how
they're going to build stuff and how
there are the awesome technology and
there's sort of like a disconnect
between the two so to put this in words
developers care about implementation and
vision capability is sort of like
feature sets there's this word like
marketing or business people think think
about right they don't care about how
its implemented they what they care
about is what can they sell to the
customers what can they tell to the
customers like look we have this awesome
thing you should give us money that's
you know because in the end you need to
be paid unfortunately so in between we
could say there's some if we you know
try to define an ontology here you know
there's a feature set which is like a
whole bunch of features maybe something
you can like like a reason to buy your
system or to give you money and then
there's individual features and you can
break them further down into stories and
scenarios this is what anyway so it's a
specification by example does so and
this is how how to gap is bridged okay
because we say like those three things
is something that is still close enough
to implementation because scenarios is
basically just a specific very specific
specification but it links to the
features so it's also interesting to the
business that's like the general idea so
how exactly do you do this and this is
where ties together with whenever I said
yesterday because just always bring
everybody together at the beginning like
everybody all the stakeholders make sure
that you know the people with the
original ideas are there or like you
have to care about a market like the
analysis people the testers or QA people
should definitely be there and
developers you know and it should be
like not too many developers necessarily
like a nice you know five six seven
people something like that and it's
gonna be difficult in the beginning
because everybody speaks their own
language so you might want to have also
like a moderator to make sure that
people you know don't drift off into
their own things too much because what
you need to write is you just write on
examples okay or
like stories basically just like how is
this system used there's no form you
just write it down very loosely but at
the end to make sure you have like a
bunch of examples and then of course you
want to make sure that the more
important are on the top and you you
think you know what how is the system
actually used not what is it does it
have to do what are the like features or
something like that just how is it use
just describe the user story principle
right that's not not something that is
too unknown but the difference is that
you use these examples and actually
implement them so you turn them into
automated tests and that's the tricky
part and then they can evaluate yourself
so that's the that's the difference to
like you know something like story
mapping or or scrum where you also have
user stories but these user stories they
always stay in their own right they stay
like a little post-it and then maybe you
move it to done but there's no like hard
link to the code like between the posted
and the code so these examples you
actually write down in code so to speak
and then they can run themselves so
let's you know let's use an example to
describe the specification by example
because I love examples so let's give an
example
so we're in this company called Aminata
comm and this guy he has a great idea he
says you know our competitor he offers
free delivery so we should do that too
let's offer free delivery and then
you're like ok but for everybody no no
only for like VIPs alright so if a VIP
or does anything he gets free delivery
no no no no only like if your orders
five articles all right so if they've
order five articles of anything it gets
free no no no no no only books
all right away that's confusing you know
maybe it's a great idea maybe it will
you know generate a lot of revenue but
let's write it down as specific examples
and when you write down examples you
want to concentrate on the key examples
because they also might get a lot if you
try it to describe the whole triangle
for example with every point you have a
lot of points but if
concentrate on the corners they're
actually enough to describe the entire
triangle so this is like my analogy to
say okay you don't have to have all the
examples only in the important ones and
I'm sorry I cannot get more concrete to
you but that very much depends on what
you actually domain is but usually get a
feeling for it so as an example we say
you know VIP customer the five books
gets free delivery check but if the VIP
customer has four books in the card you
doesn't get free delivery okay so this
is the example the difference between a
specification and the specification you
might say if he has less than five books
but less than five can be anything
between zero and four so in an example
you want to have like a concrete number
in that you want to say if he has four
books it doesn't get free delivery of
course you could say if he has three
books he doesn't get if he has two books
but that would be over over specific
because if we make sure with five he
gets a free delivery with four he
doesn't well then it's most likely that
with three doesn't neither and you might
want to have you might want to you know
put an example down if you're worried
that you know it's not understood but
usually people are really good at
generalizing and regular customers with
five books doesn't get free delivery
neither and the VIP customer with five
washing machines doesn't get free
delivery all of like obviously and now
was a tricky one
right VIP customer of five books and a
washing machine does he get free
delivery or not we don't know and that
would have been probably something that
would have been that would have been
missed in there in the specification if
you just say somebody with five books
gets free delivery because you don't
know so we have to decide and in this
case we just decided he doesn't get free
delivery we could also say he gets free
delivery for the books but not for the
washing machine so but these are the the
tricky edge cases that when I whenever I
do these sessions we find them
surprisingly often and it's nice to find
them early because those are the the
interesting parts the ones that really
stress your model
where you have to like like weird edge
cases and as a developer Sinhalese so
usually like the QA people or the or the
business people are better so these are
the treasures and you know these are 2d
annoying like exceptions but their's are
the important ones now how do we put all
of this in sort of a framework and what
I love using is system theory because
it's so simple what defines a system
well that everything outside it is not
the system that's it it's very simple so
you can say system always has a border
so something comes in and something
comes out and we can give it names we
can call it input and output and then in
between I didn't find really a good name
for that transformation I don't know
like infer this input is transformed
into output well design by contract
anybody gave you okay but this is what
this is called in design by contract the
precondition and the post condition so I
thought those are better names but then
I'm still missing the name of between
quarters does does design by contract
actually have a name for the thing that
happens between the precondition of the
post condition not really right okay
let's call it the action so this is like
your frame word of thought okay you
always think in threes everything has
three three like states a beginning a
middle and an end right this is like how
every story like I'm talking about fairy
tales is made and it's it's very helpful
to put it this way because then you can
just say okay great so we just have we
can just put it in a grid because we
have input and output we can make it
like a truth table sort of and just
iterate through all the examples we say
VIP with five is free and then all the
other ones are not free and this is a
nice approach I personally don't like it
too much because it's not very flexible
and also the the thing that is happening
the action is not even in the table
because it's always the same you just
subtracted it away but it's it's where
the word interesting part is happening
right
so what I prefer uh sentences and this
is where where you're like you said you
don't want to use gherkin but now it's
gonna get gherkin anyway so difference
is though that the sentences they use
English or like whatever your languages
and they use the ubiquitous language so
this is a term from domain driven
development which means that whatever
you call something you know if you call
it a customer in the example it should
be also called a customer in the code
and it should be called a customer when
you talk to your colleague you shouldn't
call it a user or an account or whatever
you know you have to make sure that you
use the same word for the same concept
and you can use that very nicely in
those languages so and you can also map
the three states to words so this is
where the whole given when then comes
from right it's just a nice structure to
put those three states into into
sentences so we're still at our example
right so given I'm a VIP customer and
given I have five books in my basket
when I check the delivery options then
the delivery should be free all right so
just so who's actually using like like
be head or leg or you know something
like that
all right so like about ten so this
should look very very familiar to you
but maybe even notice the difference
because when I the companies I see that
use be head they a lot of times go like
test through the UI who test through UI
okay about half of the we had people all
right so for me that's that's not what
the examples should be about because the
UI is not a ubiquitous language usually
of your domain unless you're doing UI
development usually it's it's you know
your domain is not just I click on a
button but is I check the delivery
options alright so by having to make
this to come up with like what does the
user actually do to find out if it's as
if his delivery is free like we used to
that it just pops up like while checking
out that suddenly it's
Oh your deliveries free by the way but
there has to be an action like there has
to be like a request or something like
that and just by having to give that a
name you suddenly find maybe a new
domain concept or you at least like you
flesh out another domain concept so this
is the huge advantage of trying to use
ubiquitous language in your examples you
may still map this to a user interface
action if if you so want but it
shouldn't say if I click on the is my
delivery free button because that's not
what your domain is about it's not about
kicking buttons it's about finding out
something about the state of the system
alright so that's why you know this is
the main language this is something that
is very important for me and usually the
first thing I try to change whenever I
see like scenarios that are purely
specified in UI and this is also why I'm
not a big fan of B hat and an selenium
and that whole suite because it makes it
really easy to test through UI makes it
ridiculously easy which is awesome
because a lot of systems really profit
from that but if something is easy you
tend to do it and you tend not to think
about the alternatives so you just
follow the like easy path and this is
why I think it's tricky so instead you
know using these tools you can just use
your own tools whatever that is so I'm
going to show you how this looks like in
one version of PHP that I sometimes use
we just create a class okay just imagine
you have a test runner like PHP unit and
that can run all the methods in
something that extends test case as
tests all right so all you need to do is
create a class and you just give it a
really descriptive name like free
delivery to VIP customers and then you
can put the story for example you can
just put it in a method you can just say
what is the story well in order to
create incentives to become a VIP
customer I want to provide free delivery
for VIPs if you want that I mean that's
usually you know like there's some
there's some people who who like really
appreciate these things and this way you
can put it in the code
so it's not like you know somewhere else
and then you need to find how do these
things belong together you can just put
it in there it's fine
and then each scenario we can just make
a test function for example scenario VIP
with five books and usually these test
runners they allow you to specify like a
prefix it doesn't have to be test it can
also be scenario so this way everything
that starts with scenario is considered
a test and this one is the one scenario
where where it's a VIP customer with
five books we can make this method name
longer you can say I am a VIP customer
with five books or you know something
like that but usually this is enough
because the content the body of the
method describes precisely what what
happens okay
and here I'm just using you know really
long function names they're basically
sentences if you use the camera casing
this is easy to read if you not use the
chemical thing this is probably a little
bit harder to read so you might also use
like underscoring anything that makes it
easier to read for everybody and the
other funny thing is like the second one
says given I have blank books in my
basket and then five in the end so this
is because PHP doesn't have in fixed
notation and as I said like this is
something that I prefer doing because it
gets you started more quickly and it
allows you to use your tools you're
already familiar with and you know this
is I tried this out with a couple of
companies and this is actually readable
even through non-technical people so you
can just throw it to them and it takes
like maybe a day or two and then they
can read it like make no problem and you
put it like on github or anywhere in
your repository and then they can even
browse to it and answers questions like
what does this thing do and what are the
edge cases they can answer themselves
because they can just read through this
but of course you need to implement
these methods but you can just do that
in the same class even and you just use
your like normal mocking that you always
do so this is test automation if you're
not into it yet then definitely get into
it because it's awesome it saves a lot
of time you just create like a fake
customer and like foot put fake books in
it
and then you you actually do the thing
so I don't know here I call it a
delivery manager and a delivery manager
knows that if the delivery is free I
don't know if that's a good design at
all I never actually build a shopping
cart system and but you just make sure
that the you know this property is free
is true and that's basically it all
right so that's all if there wasn't like
this nasty habit of reality to always
flow and you're like fly in your face
when you don't need it so but now you
know how it would work in an ideal world
where everybody you know with is happy
and smiles all the time and always talks
nicely with each other but in reality
you have a couple of problems
first of all scope of tests definitely
want to talk about that because I see
that I see a lot of different approaches
to it and like I don't want to tell you
know this is how you have to do it but
this is how it works best for me and
I've tried every other I tried every
option like extensively but so the
usually problem is you have a certain
scenario and it like changes one thing
in one module in your big complicated
system right so how how do you make sure
that this works do you look only at the
module like only at the smallest
possible thing you can look at to make
sure like this tiny thing you just
change you just change that does like it
behaves as you expect to or do you find
out well it does this one mod you will
still play nicely with all its
collaborators does it still like or do I
need to to make maybe change a
collaborator because I broke something
or should I just take make sure that the
whole system still works right these are
usually the problems of test scoping and
in my in my opinion which is not a very
popular opinion I think that the bigger
the test scope the better because you
really in the end you want to make sure
that your system still works for the
user but the problem is of course this
tends to be very slow because it
incorporates everything maybe have like
databases in there or a network call or
even like external libraries like
external services that you know don't
like a sandbox so it can't even really
test with them but still like my deal is
the bigger the better and of course
another problem is when you when you do
this approach is not only very slow but
you also get this test multiplication so
you usually have one happy path and
that's fine and if everybody every user
always would behave the way we expect
them to we only had to specify the happy
path that would be awesome but
unfortunately people do weird stuff so
we need to test all the possible error
like ways that this thing can fail and
if you know if you do the math and we
think there are three ways for every
like there's a chain of three modules
and every module has like three ways
something can go wrong so it has three
checks in it if we wanted to test all
the error cases for all the three
modules we end up with 27 error cases
which is you know usually you have more
than three modules but if we check each
one individually we only have like the
sum of them so this is math and I see
this example a lot in theory I have
never really seen it in reality usually
there's a strong correlation between
error modes and you don't actually end
up with the multiply so this is less of
a problem for me but I'm not sure if
that's just something that I do weirdly
or if that's actually true but this is
something you should definitely keep in
mind because it creeps up on you and
then suddenly you have like a lot of
tests because you need to check
everything that's awful
and then what people usually you know
the best practice that at least maybe
still yeah it's the test pyramid who has
heard of the test pyramid not too many
maybe it's not not that big thing
anymore so it's a little bit like the
food pyramid for food pyramid you know
with like cereals on the bottom you know
the food pyramid who knows the food
pyramid okay
but that thing is a lie don't listen to
it that's like that's like some mean
scientists in the 80s that got paid off
by the industry right don't don't eat
too much cereals anyway some side
tracking the the test parameters also
sort of a lie usually you say you know
this is the direction of the scope and
then so that means that
like UI tests on the top it's like
chocolate you shouldn't have to too much
of them but you need them
sometimes coz the tasty and they're slow
and then you need to have a lot of unit
tests right that's what they always say
and then they usually have this like
middle thing which I call system or like
logic and they say I am maybe you should
have some of them but for me the
downward Direction really is an
optimization so I don't see why you need
a lot of unit tests if they're just an
optimization because it's just a way to
make it faster instead what I usually do
is I just cut off the top and say what
is it what about the system right for me
system is your core of this is the core
of your whole system usually is where
the business logic is so and what makes
it slow is HTTP calls the UI the files
of some database all of that stuff but
you don't need it because they're not
core you don't develop them you don't
you know if you find bugs in them then
it sucks but usually you don't need them
so just cut them off and just make sure
that your system has a really nice way
like a really nice API to set the
precondition to test the post condition
and to invoke an action that's a good
idea anyways because that leaves that
leads to better like system design so
that's what I usually do I say you know
I don't do a lot of unit testing because
we cannot agree on what unit testing is
anyways so everybody has its own sort of
definition so I do unit I I consider the
whole system as the unit but I consider
my domain as the unit so I want to make
sure there's a nice interface to that
and the other big problem with if you
have a lot of specification is
maintenance of course because things
change all the time and that's the only
truth about universe you can get things
always change so the requirements the
business requirements change of course
as well and you have your examples you
have the implementation of the examples
and you have the individual steps you
know the the given when ten things so
one thing you can do with the steps is
if they become too many alright so for
example you have a customer you have a
lot of logic concerning the customer
a lot of properties a lot of things or
you have a like very complicated basket
a lot of things you can describe about
the basket you can put them like into
collections
I call them fixtures it's actually not
that maybe that's not a good name
because pictures also mean something
else but anyways you can collect them
and just say if you want to do something
about a customer you'll use this class
if you want to do something anything
with the basket use this case so this is
you can structure that way and of course
you always need to refactor the
implementation because every time
something changes in your system you
need to tie it up with your tests again
so be ready to do that be ready to care
about your scenarios about your specific
automated specification as much as you
care about the production code it needs
Admiral's as as much maintenance it
needs as much refactoring as much design
as much love so you basically doubled
your your efforts but it's really worth
it it really pays out because you find
defects way faster and you can and you
find weird edge cases way better and you
can fix them quicker one thing you
should never do is change the actual
example all right unless something
unless the business changes but this is
something you shouldn't do for
optimization so if you realize you know
this has like weird side effects if you
only change like the order of these
things or like reformulate that it would
work better don't do it without talking
to all the stakeholders if that's okay
so that's maintenance it's also big big
real-life thing because you have to keep
it up to date all right so to reiterate
if you
managed to do these things actually you
get this awesome trophy which is a
living documentation and that's for me
personally the most awesome outcome of
all this endeavor and the living
documentation is basically a
documentation that validates itself so
you can use it as a single source of
truth you know how we always say the
code doesn't lie and if you want to know
the truth you have to look into the code
well the code doesn't tell you why and
the code doesn't tell you the intention
behind it but the examples usually do
and the examples also much more readable
so if the examples of the documentation
also never lies then you win a lot
because it can answer the two questions
one of our one is the most more
important question may be does it work
have we thought of all the edge cases
and maybe more important question is how
does it work like if you work in a
bigger company a lot of time you spend
just finding out how a certain feature
works whoever got the question like from
from marketing how does this feature
work and then you have to dig into code
and find it out no that's just me okay
good all right I thought that was just
me so that happens right imagine you
could just point them like to github
fire and be like just look it up here we
describe all the edge cases find out how
it works you know if you feel like we
missed an edge case let me know we write
a new specification and then we make
sure that works which I love
so once again I call it specification by
sample you can contribute calling it
behavior driven development I don't care
but I like the example in the word and
what it is it's about communication it's
about making sure you speak a common
language it's not about the tools it's
really not about the tools and the goal
is this living documentation which I
which is my favorite thing all right so
yeah to get the you know people say
humanitarian thing really it's not not
technical anyways if you want to learn
more about it there's of course the book
I think it's free on the web I'm not
sure anymore but it's a good book it's
worth buying it there's the seminal
blogpost about behavior driven
development by Dan North that's really
by now I think it's like 10 years old or
something like that and I like this blog
post which is how to sell BDD to the
business because that's usually what you
need to do if you find out it's a good
thing as a developer you need to
convince the business that it's a good
idea and this gives you it gives you
really strong arguments because it
actually makes sense business-wise and
then because I you know was thinking
about book suggestions oil so I was like
oh maybe I have some more book
suggestions clean Kotov from
Uncle Bob best book on development
hands-down I also really if you if you
like
methods and stuff extreme programming is
an awesome book and I love the Lean
Startup I don't know why I put them
there
I just love books anyways thank you very
much for showing up let me know if you
have some questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>