<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How Merkle Trees Enable the Decentralized Web! | Coder Coacher - Coaching Coders</title><meta content="How Merkle Trees Enable the Decentralized Web! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How Merkle Trees Enable the Decentralized Web!</b></h2><h5 class="post__date">2018-01-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YIc6MNfv5iQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi my name is tara van cyl and i'm gonna
tell you about Merkel trees and how they
enable the decentralized web so I want
to start out by talking about to
centralizing forces that affect how the
web works the first is what we'll call
the server problem so if you want to
upload files to the web you need to have
a server but most of us don't have
servers lying around and they're also
sort of burdensome to manage
so typically we choose the more
convenient option which is a hosting
service like YouTube or medium now this
is convenient but what it results in is
a lot of web content being concentrated
on the infrastructure of a handful of
providers the second centralizing force
relates to how we address content on the
web we currently use what's called a
host base addressing model and what this
means is that I if I upload a video to
YouTube the URL for my video is tightly
bound to the youtube.com origin and if I
ever want to move my video to Vimeo for
example I need to get an entirely new
URL so there's a lot of friction
involved in exercising choice between
hosting providers and most likely once
I've made my original choice I'm
probably gonna stick with it now luckily
both of these problems can be solved
with a peer-to-peer system and the first
part of the solution I want to talk
about is called content addressing
content addressing is pretty much what
it sounds like it's generating an
address for a piece of content based on
the contents value and we do this with a
cryptographic hash function a hash
function is a one-way function that
takes an input like a file and generates
a fixed length output typically 32 bytes
and it's important to know that a
well-designed hash function guarantees
with extremely high probability that no
two inputs are ever going to generate
the same output so a hash is a unique
identifier for a piece of content so how
does this help us solve the host based
addressing problem well if a hash is a
unique ID for a piece of content that
means we can also use it as an address
for that piece of content so at this
point if I want to move my video from
YouTube to Vimeo it can maintain the
same
a dress no matter where it's being
hosted but we still haven't talked about
how to reduce the burden of hosting
files on the web and we can also do this
with a peer-to-peer network we can take
a data set split it up into small chunks
and distribute it across a network of
peers and then those peers can share the
responsibility of providing bandwidth
and disk space now this does make the
responsibilities a little bit more
manageable but there's something else
really important that we need to
consider and that's trust participants
in a peer-to-peer network are anonymous
and untrusted so it would be really
risky to download a file from a peer
without first verifying that it's the
file that you actually asked for and not
something malicious and this is where
Merkel trees come in a Merkel tree has
some pretty unique properties that
allows us to do efficient data
verification across a network of peers
so what is a Merkel tree it's a binary
tree where the nodes store hashes
instead of sort storing chunks of data
hashes of what well the leaf nodes store
hashes of chunks of data and the parent
nodes are a little bit different the
parent nodes are the result of
concatenating the left and right
children and then applying the hash
function to that result but let's
actually step through constructing new
Merkel trees so we can see how this
works so we have four chunks of data and
we start out by determining the leaf
nodes we're simply going to apply the
hash function to each chunk from there
we'll determine the parent nodes let's
look at a so to do a we concatenate the
hash of one and the hash of two and
apply the hash function to that result
and we'll do the same exact thing for B
and its children finally we do the same
thing for C the root node concatenate a
and B and apply the hash function so a
root node has a special name in a Merkel
tree we call it the root hash and as
we'll see in a few moments this actually
plays a pretty important role in
peer-to-peer networks so let's look at
an example let's compare to Merkel trees
to see if they're equal remember
a Merkel tree is just a representation
of a data set so in effect what we're
doing is comparing two data sets to see
if they're equal you'll notice that
these trees have different root hashes
and you might be able to see why it's
because one of the leaf nodes in the
tree on the right is different than the
tree on the left so as a result its
parent node is different and
consequently that nodes parent is going
to be different as well so a change in
any single leaf node bubbles up all the
way to the top to the root hash and this
means that the only thing we need to
consider when comparing to Merkel trees
for equality is the root hash and this
is wonderful because not only does it
reduce the number of comparisons we need
to do most importantly if we're doing
this comparison over a network then the
only thing we need to send over the wire
is the root hash and typically that's 32
bytes but how does this come into play
when we start talking about peer-to-peer
systems let's see another example so I
mentioned that the root hash has a
special role and the first value it
provides as serving as an address for a
set of files or data and this is a lot
like how URLs work on the web our URL
points to a set of files that live on a
server somewhere and if you visit the
URL you can download the files but you
would never visit a link from someone
you don't trust because it might just
point to a virus and we have to apply
that same principle here when we get a
root hash it needs to come from someone
we trust so that's what we've done we
got the root hash C from a friend and at
this point we can start asking peers on
the network to send us the files that
are associated with that root hash and
we got the files we have four chunks of
data the numbers one through four but
remember that it came from a bunch of
random people on the networks and we
don't trust them so we need to verify
the data so let's ask ourselves how
might we do that well this is the second
role that the root hash plays we have
the root crash from our friend so why
don't we just reconstruct the Merkel
tree to get another root hash and see
what we get
and that's exactly what we can do well
construct the Merkel tree with the data
we receive from the network until we get
a root hash and we see that it's the
root hash that we got is our friend so
we know with 100% certainty at this
point that the data we received wasn't
accidentally corrupted or intentionally
tampered because if it were we would
have gotten a different root hash so at
this point you might wonder if the
purpose of the root hash is to let us
address a set of content and to also do
some integrity checking over that
content why don't we just concatenate
all the data together and then apply the
hash function to that why bother with a
tree at all and that's a pretty astute
observation that would work but it turns
out there is some value in constructing
a tree and we're gonna see why in a
second so in the last example we needed
to download all of the data before we
could verify it but on a peer-to-peer
network we download data from people all
over the world and at different times so
it would be convenient if we could
verify data as we receive it likewise we
might not be interested in the entire
data set maybe we only need one or two
files so being able to partially verify
data sets would be pretty cool and it
turns out we can do that and that's why
we need to construct a tree so let's see
another example that's pretty similar to
last time we received a root hash from
someone we trust and we've started
asking peers on the network to send us
data and we got the first chunk of data
it's the number 4 so let's ask ourselves
what other data do we need to
reconstruct this root hash and verify
that the number 4 belongs in this Merkle
tree well it turns out it's not very
much data at all we already have the
number 4 so we can determine the hash of
4 we'll need the hash of 3 so that we
can calculate B and finally we'll need
the node a so that we can calculate the
root hash and again we see that we got
the root hash that we expected to so we
know that indeed the number 4 belongs in
this tree now it's really important to
notice that the only thing we needed to
download from someone we trust was the
root hash
the data itself and all of the proof
required to verify the data came from an
untrusted peer and this is a critical
piece of making it possible to
distribute the responsibility of hosting
files across the network of peers Merkel
trees are used in dozens of projects and
they actually have some other cool
properties that I don't have time to
discuss today but they're of vital
importance to peer to peer networks and
decentralized systems being able to
address content with the root hash means
that we get consistent links that stay
the same no matter where the content is
hosted and being able to efficiently
verify data sets makes it possible to
distribute the responsibility of hosting
files in summary Merkle trees make it
possible for the web to be built on the
small contributions of many rather than
the concentrated resources of a few
Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>