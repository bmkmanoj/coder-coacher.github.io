<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What's the Deal With TESTING? | Coder Coacher - Coaching Coders</title><meta content="What's the Deal With TESTING? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What's the Deal With TESTING?</b></h2><h5 class="post__date">2018-01-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/giFSMmEoaW4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everybody so excited to be here so
we'll show of hands who how many of you
are developers and how many of you do
software testing already much smaller
group how about designers with some
designers in the room like other roles
like project management or QA do we have
folks who kind of don't fit into either
of those buckets cool and then everyone
else
I'm so happy to do this talk for you
today so imagine you're riding in a car
through downtown New York City with the
cast of Seinfeld stuff's falling off the
ceiling of the car petty grievances are
being aired it's a pretty painful car
red now you the next time you wrote in
that car you'd want to make it a little
bit smoother of an experience right I
mean that's kind of the charm of
Seinfeld was that they it was always
painful but in real life we try to fix
those problems and when it comes to
shipping code and software we're working
with humans to write code that will be
executed on computers and I don't know
about you but my goal at the end of that
process is to have thumbs up and to have
a good experience so I'm not being
called back to the office to put out a
fire when I really want to go home for
the weekend and take that time off like
Jani was Dennis was talking about
earlier so in terms of your your process
of of delivering code there's a lot of
things that you could do manually but
you could really increase your
throughput if you automate some of it so
what I'm going to talk to you about
today is how to automate some of your
process and what really spurred this
talk was a tweet I saw recently from
Hayden Pickering where he said I don't
understand Tess if my code breaks I know
already I get errors and you know
followed up with I don't really
understand tests either to be honest and
it really took me back to a spot earlier
in my career where I didn't understand
Tess I worked at an agency building
websites I just didn't know what tests
were for I hadn't gone to school for
computer science and so to go back to
where I was and to talk to people who
have the same issue of understanding how
tests can fit into their
floo we're gonna talk about what's the
deal with testing as Yoona mentioned I'm
Marcy Sutton I build accessibility tools
for developers at DQ systems and that's
all we do is web accessibility you can
find my slides online at Marcy Sutton
comm slash smashing BC n17 and I just
tweeted them out on my Twitter account
at Marcy Sutton but today we're going to
talk about a little more general than
just accessibility in terms of software
testing and how it can fit into your
workflow we'll talk about why you should
write automated tests and try to
automate some of your workflow so it's
not completely manual you might be
thinking oh do I really have to and
we'll talk about some cases where maybe
you don't need to write software tests
and then we'll talk about how you can
even write quality software tests
because that's sort of the you could
write test for tests sake but you might
end up commenting them out and that's
not a good situation so the first goal
of writing software tests should be
designing software components and this
really goes back to the idea of
test-driven development where you're
writing code and writing a test at the
same time and the value in that is that
if you're designing software the test is
really asserting that your code does
what you you say it does and so it sort
of evoked this quote from Kramer saying
do you think people will still be using
napkins in the year 2000 you want your
code to be future proof and really be
working for future situations and tests
are a good way to really get that
written down and get it
in a healthy way moving forward this is
a big one for me maintaining quality so
that over time your code doesn't just
show up with bugs you can actually build
a stronger infrastructure so that your
code and your tests work together to
really enhance quality and keep things
fresh this is a really big one working
with people because I don't know about
you but I work with other people in code
bases and if we didn't have software
tests we could often be
undoing the work that someone else was
doing you could even be writing tests
for future you like maybe you put your
code down and then a couple months later
you have to come back to it and
understand what was I doing again and
tests are a really great way to
communicate to you and other people how
things should work in a way testing is
all about documenting functionality now
it doesn't really replace actual
documentation which we absolutely need
more of but your tests are a way to show
different code paths and scenarios that
it's supposed to that's how it's
supposed to work and when I come on to a
code base it's really helpful to not
only look at the code but to look at the
tests that go along with that code and
it helps me to understand all of the
different scenarios that we're counting
for I found that it makes it tests make
things it makes it easier to find bugs
and fix them and often if something
breaks I'll write a test to capture that
failure and then in testing driven
development style I'll go get the right
the failing tests go fix the code and
then the test is passing and that's a
really great way to get that peace of
mind of like no really I was able to
reproduce that problem and now I know
I've fixed it and it's going to stay
fixed because there's a test that
asserts that it's fixed
it doesn't necessarily that that style
of finding bugs and capturing them it
might apply more to what's called
integration tests which we'll talk about
a little bit later less so for unit
testing but it can certainly help the
goal of this is to not be like Homer
here creeping across the room picking up
a box to look for a bug and they all
fall on your face you want to do this
iteratively so that you're not just
dealing with a million bugs at once it's
something that you can chip away out
over time
for me really taking myself back to
working at an agency and going I don't
understand tess at all for me it was
about leveling up in my career and
becoming a more serious software
engineer I could see that that's what
you know actual software developers were
doing they were writing tests
I thought hmm there's something to that
that seems like a great way for me to
level up in my career and make sure that
I'm actually producing quality software
that other people can reproduce and it
just seemed like something I really
wanted to learn more about so I went
from working on websites at agencies to
working full-time on the angularjs
framework that's a pretty big leap that
I had to make from website development
with no tests at all because you're at
an agency and the website only lives for
three months and then it goes away to
then working on a framework that
thousands of people use and it really
software testing was a big part of that
so I sort of had to learn it on the job
and now I can't imagine going back
testing is such an important part of how
I work so I'm hoping that by the end of
this talk you'll start to see the value
if you don't already I remember looking
at code bases like reveal j/s which is
the framework I'm using for my slides
and I would look at the repository and
say what is this test directory and I
remember leaning over to my colleague
and saying like what's the deal with
this and I just didn't know anything
about it I would comment things out and
it just didn't make any sense to me but
when I drill down into this folder I
could see oh there's JavaScript and HTML
and maybe some CSS files in here and if
I look at one of those JavaScript files
I could see there's so the code is being
called and there's tests that assert
that the code is doing what we expect
and I started to wonder you know what's
the deal with that I want to learn more
so really over time I realized that it's
the goal should be to try and add some
automation to reduce the amount of
manual testing that you have to do in
Hayden's case he said I don't understand
testing because I know when it breaks
but do you really know when it breaks
like do you know when you broke a
carousel on a page that you didn't tell
QA to look at
it's like QA can't if you even have a QA
team you can't always have them expect
them to do a full regression test of
everything so if you have test coverage
it sort of gives you eyes and the back
of everyone's head so that you can test
if things are broken and just really
catch yourself from break
things that was my motivation as I broke
things and I wanted to have a healthier
way of working moving forward now
there's some times where maybe you don't
need to automate and we'll talk about
that in a minute but I think it's really
valuable to like pitts manual and
automated testing against each other and
there is some sweet spot of value there
I love this quote from Jeff Sutherland
where he says the human mind has limits
we can only remember so many things we
can only concentrate on one thing at a
time and I find that testing really
gives me these superpowers so that I can
offload some of the cognitive overhead
of trying to make sure that everything
is working on every page and every
component all the time and it really
helps with working with teams so that
you can sort of spread that quality
around and make sure that nobody's
breaking things for each other because
people forget look at home alone
they forgot we're human and we need all
the help we can get I think that's
really helpful to know that there is
this method of testing and it can help
you if you use it correctly
and I had to laugh that there was a
woman asking for help on go fund me with
a fund raiser to quote bring back the
90s she's really asking for money to
bring back the 90s she needs some help
so in front-end testing because most of
us are front-end developers that's kind
of you know what we get out of Smashing
is these ideas and techniques for how to
make better front-end products and
websites front-end testing is great for
accessibility support and we'll talk
about accessibility elate a little bit
later on but this idea of both manual
and automated testing has a huge role in
accessibility but in a more general
sense testing is great for reusable
components things that maybe you're
consuming in other components or other
people are consuming something that
you've built having tests make sure that
that quality stays up so that you can
leave the office and rest at night
because you know that you've shipped
something that's solid and it's not just
going to magically break it's really
great for code that lives on now I
remember working at agencies
where the websites didn't live very long
and it was hard to make the case for
testing I still think it's valuable
especially if you're going to reuse
things but if your code lives on if
you're working on an application that
has a longer shelf life absolutely
testing should be a part of that because
stuff breaks it happens and often when
something breaks I go whew I didn't have
a test for that how can I capture that
in a test so we'll look at some
scenarios of how we can actually test
things so you might be thinking what
about prototyping and this is a place
where you could argue that testing it
might just slow you down so some people
would add tests and prototyping phase
some people might not
I am personally I'm of the belief that
you could probably skip it at that phase
because you're iterating fast on ideas
you may or may not use that code in the
end but if you have prototype something
which I would highly recommend doing
especially for accessibility so you can
test things out before saying oh crap I
need to add accessibility later on you
can sort of play with it early just like
any other prototyping but the second you
go to move from prototype to real thing
like you're going okay that's the
solution we chose we're gonna bake it
into our product or our website now
that's a signal that you should probably
be starting to test it because it's
going to live on you've already iterated
on it and it's time to put it into the
real thing so that's a sign that you
probably should start testing at that
point so where to test live this can
vary a lot depending on how your team
likes to work what tools you're using
you might be using something like mocha
or Jasmine as your testing framework you
might be using a linter that's a way of
automation you could lint your
JavaScript and/or your CSS and that's a
way to quickly catch things so you're
not manually having to go and say in a
pull request hey we don't use semicolons
here or whatever these are tools that
can help your team it free you up for
more complex tasks you might be using
task runners like gulp or grunt we use
those in our projects the way you render
your tests could vary you could use a
headless browser like phantom Jas or
Google's puppeteer
this chrome tool that's when I'm really
excited about if you're actually firing
up a real browser instance you might use
selenium webdriver or the angular layer
on top of that of protractor and there's
new test tools every day but if you see
these you'll know that these are testing
tools and you can choose which ones work
for you and it might depend on if you're
using a framework or if there's already
some tools in your tool chain it might
make it easier for you to select which
ones you want to use so in terms of
where exactly your tests might live as I
said it can vary so I have one project
showing in sublime text where we have
our tests and our code live right next
to each other in the same directory some
people prefer that while in another
project we have a whole test directory
so there's code in one directory and
tests in another directory and inside of
those directories they have the same
structure and I like that convention it
makes it really easy to search for
something because I can just type the
word test in front of something and then
it'll like filter all of the tests in
that folder so it's up to you I could
see having some long arguments and
discussions with your team trying to
decide but there's validity in both
approaches to this and it's really just
what is the most productive thing for
you so no matter what location where
your code your tests live compared to
your code to me they are meta the code
and the tests are self referential
because you're calling the code from the
test and it's asserting that the code is
doing what you expect and it really
reminds me of Cramer's coffee table book
of coffee tables being this sort of meta
concept of self referential code so how
to test and this is a really important
part because I think people get in this
idea of like I don't want to test it all
because they end up being they slow me
down
and it's just not worth it I can't get
the budget for it all of these things so
it's important to really plan out how
you're going to test and do it
effectively so let's take a look at some
different techniques we could use
there's a project called Marquis
markdown YouTube which has the best
project
I have to say marky-mark down but in
their library they they take markdown
and if there's a youtube embed they want
to craft some HTML around it so it can
be styler ball and if you're using this
project yes you would probably want
those style hooks so that you're not
having a style an iframe for example so
they have a test that asserts that a div
is wrapped around an iframe and that's a
good one in case someone else comes to
work in the code base and they're like
we don't need that div there but well
you probably do maybe it'll break the
CSS and you wouldn't know right away and
you can see how quickly something as
simple as a div wrapper could cause
problems especially I mean not only
working on your team but then for all of
the people downstream who are using this
project you could quickly have some
problems and I have definitely had to
fix problems that other people are
depending on and you could have saved it
with a test there's different types of
automated testing in front-end
development we do a lot of you at unit
testing integration testing and we'll
talk about both of those in detail and n
testing is a type of integration testing
and there's all of these buzzwords that
depending on who you ask might have a
different definition but there's things
like regression testing that might
happen a little bit later after your
product has sort of stabilized a little
bit and you want to make sure that
things haven't broken over time you can
definitely automate some accessibility
testing and we'll talk about that in a
minute there's also things like snapshot
testing verification testing performance
and then no matter what type of testing
you're using it's really helpful to use
continuous integration so that you can
go run your tests on a server somewhere
for example if you use github or
bitbucket you could have when you check
in code or someone submits a pull
request you could have it go run your
whole test suite automatically and
that's great because then you don't have
to go run the code and run the tests
yourself you can have it happen over on
a machine somewhere else so it's really
helpful when you're working with teams
it just frees you up to not have to do
all of this manual testing yourself this
really starts to fit into an agile
workflow so how many of you
already do agile how about waterfall we
have this sort of chuckit over the fence
it's unavoidable sometimes that's in
agencyland we were definitely waterfall
the design would do their thing and then
development and then QA whereas with
agile it's more concurrent and you're
doing things together all the time
in true agile you would be paired with a
designer probably and really be
iterating fast and so there's this sweet
spot where you can try and stay up to
date with your tests and your code and
iterate over time and I think even if
you aren't working in true agile I mean
depending if you even have a QA team as
a developer it can be really helpful to
take on some of this responsibility of
testing yourself I know that I mean even
with or without QA I like to hand off
things and I know are solid and quality
and an agile that's a big part of the
process so with testing you really want
to encourage a good return on investment
and when you're trying to convince
leadership for the time to add testing
you can really help everyone involved by
focusing on these three things
doing key testing first so focusing on
the core path of your application or
your website and really getting test
coverage on those reducing redundancy
and keeping things dry so you're not
repeating yourself because if you test
the same thing all over your application
like in unit tests and integration tests
then once something breaks you have to
fix it all over the place and it can be
a headache and morale goes down and you
want to automate effectively so really
plan you know what's gonna be the most
effective way to test this and then
evaluate how that's working over time so
it's not just writing tests for tests
sake you want to be methodical about how
you're testing it so that it's not just
getting commented out because that's
kind of pointless then you've wasted all
of that time and the team members that
come on can't benefit from from the
tests that you've written if there's one
thing that I want you to take away from
this talk it's that you should test the
outcome and not the implementation the
goal of this should be I mean for
example if you could you know have a
piece of code and then you do a rewrite
if all of your tests could
stay passing at the end of that rewrite
you've done this successfully and a
really great example of this is the
recent rewrite in react of react fibre
they did this successfully and it was
important for them because they have
public API is they need to be backwards
compatible and so they basically just
like pulled out the implementation and
their tests still work because they had
done this successfully there's a great
blog post that hints that some of these
ideas called tautology tests about
sniffing out these code smells in your
tests know whether you're actually
testing the implementation things like
did you assert that dependencies were
installed that's probably not that
useful you read rather write a test that
asserts that it has the correct result
at the end so if this is all like you
already know all this information you
could consider this talk a volume 1/2
the volume to talk called how to stop
hating your test by justin Searles
justin works at a company called test
double we partner with them at DQ
sometimes they're fantastic at testing
that's that's what they do
whereas we do accessibility so in his
talk he goes does a deep dive into the
nuts and bolts of writing tests so if
you're really like ok I want more I want
more technical detail go watch this talk
because he covers so many interesting
things and even though it's at rubyconf
it's so applicable to what we do and
yeah so I don't have enough time to do
both volume 1 and volume 2 so definitely
go check that talk out in that talk
Justin talks about how you set up your
test this idea of a range act and assert
alternatively you could think of it as
given when then so given this scenario
or these inputs when I execute the code
I expect then that it should be doing
this result now there's usually a
subject so the thing under test and then
the results at the end and those should
be clear to you when you're looking at
the test what is the subject under test
and what is the result when you're
writing unit tests in particular there's
this idea of inputs and outputs and the
example I have here is a project called
ASCII table and
in this test the subject is this ASCII
table the input this sort of arranging
is the an array of arrays that we're
passing to this ASCII table and then in
the result we assert that those inputs
made it into this ASCII table and that
the the code under test is just doing
what it needs to do internally and then
it produces the result that we expect so
that's one example of a unit test where
the code isn't like we're passing it the
content that we want it to produce this
result we don't care what happens inside
of it we just expect that it will return
the thing crafted into the correct ASCII
table in this case so a fundamental
building block of testing is what's
called the code unit and it really can
vary between the language the domain the
project but the basic idea is that unit
tests are isolated they don't call out
to the network they don't call other
parts of the system it's a way to write
a single unit that's isolated whereas in
something like an integration test
you're testing across the whole system
and you can think of it like these
puzzle pieces fitting together and it's
really how they fit together that you're
gonna test to make sure that you're
incorporating it like a real user would
experience but both of these ends of the
spectrum have value so you should try
and get it some mix of both some
qualities of unit tests are that you're
testing in isolation so that you're not
making those network calls or like
involving other components the unit test
is just that unit you pass in inputs and
this could be you maybe your stubbing
something so that you aren't making a
call outside of this unit test maybe
you're passing it some static fixture
data so that it loads fast and you're
not having to hit a database
they're often run in headless browsers
like phantom j/s or headless Chrome and
that is because you're just running this
isolated unit you probably don't need a
whole browser instance and they're
really about this fast changing of state
so with these given inputs I expect that
the state will change in this way so
here's a unit test example
this is taken from XCore which is a
project I'll talk about a little bit
later but in this example we start with
an HTML element which has a type of HTML
node we can call it a Dom API on it like
the text content and give it a string
like dududududu boom boom boom boom boom
boom boom boom boom
because anytime I hear Seinfeld I got to
sing the song right so that's a Dom API
that we call but in the code we assert
that it's going to return an object we
can no longer call text content on this
object because it has a different type
so that's a unit test for something
that's changing the output into what we
expect and we have a test to make sure
that it doesn't break nobody will break
the DQ element method so that it's still
a node it is in fact an object so I love
hearing people's tweet storms and blog
posts about how they feel about testing
and there was one from Ashley Williams
at NPM I think a week or two ago where
she talked about unit testing really
fitting into her development workflow
and she didn't even necessarily commit
the test they were for her in her
development process so I think you have
to balance that your development
velocity and what really helps you do an
efficient job with that return on
investment and at some point it might be
helpful to commit those tests so that
other people can benefit from that work
that you've done but it is a balance of
doing a healthy development process and
actually having a good value at the end
so that's unit testing let's talk about
some integration testing it's often done
in real browsers using something like
selenium webdriver um and that allows
you to mimic the experience like a real
user would have as opposed to a headless
browser for example there's one called
Jes Dom that you may have heard of and
that doesn't implement all of the api's
that you would have in a browser so for
something like accessibility testing it
doesn't go far enough to mimic the real
users experience in integration tests
you want to test common permutations
across your app especially in core flows
that the user might experience it might
be a little bit slower
and that's usually kind of the knock-on
integration test is that they might be
slow but it's really valuable to test
things as they're working together so
here's a real-life example the chrome
team reese recently released some
components called the how to components
and in there they have accessible
components and they have both unit tests
and integration tests for each of these
and integration tests are really great
to assert keyboard support so things
like focus States making sure
something's actually operable because
it's the AP is and the experience are
much more like a real browser because
you're in a real browser so in this test
they're pressing keys and asserting that
this tab list will send your focus into
the tab as you change the tab switcher
so as working with something like a tab
switcher if you haven't written
accessible components before this test
is fantastic because you can really dive
in and see oh this is how this is
supposed to work so back to earlier when
I was talking about documentation tests
are a great way to go and understand how
a piece of code is intended to work and
you prevent regressions and braking by
having it asserted it should do this
thing some integration tests use cases
it's really about composing modules
together so if you think back to the
puzzle pieces and how they're working
together and hopefully you can catch
some of the the side effects of things
working together in a real-world
environment but you've written a test
that captures that behavior unlike a
unit test that's more isolated this is
great for things like focus management
where maybe you're focusing like the the
user is focused on one component and
they hit Enter key and their focus is
sent somewhere else that's multiple
components like that no longer makes
sense for a unit test it's great for
things like navigation and client-side
applications form validation where the
users error messages are popping up and
things that are more page level so that
you have everything loading at once and
you can assert that maybe you didn't
break a carousel on this other page that
you weren't expecting because that
totally happened to me I didn't know a
carousel was being used on another page
didn't tell QA to test that page
that would have been a really helpful
integration test I wish I would have
written it there's a gradient from unit
to integration based on how many
external things the test touches and how
many of those you mock this is another
great conversation on Twitter about the
value of integration tests this quote
was from Alex early so there's sort of a
spectrum on either end of isolation and
this integration and you want sort of a
mix of both for different reasons let's
talk about writing testable code cuz
it's not only about the test you have to
be able to write a test for her the code
so that's a big part of it as well first
of all you have to have enough logic in
your code to test I have an example a
totally contrived example of taking a
string of characters for someone's name
and converting it to a username this
might not be that useful to test because
there's just not that much going on and
a good code smell to know whether you
should even be testing something at all
is if there's a lot of business logic in
your test that means that your code is
probably not that testable and you might
get it thrown off by side effects in the
test code itself so you want to make
sure that you're you actually have value
in testing it so you might either need
to refactor your code or just get rid of
a test it might not be that useful the
code has to be portable to be tested and
sometimes this just means exporting it
in your development environment if
you're using something like web pack or
browserify you have to export this code
in JavaScript so that then you can
import it into a test and call methods
on it sometimes you might need to
refactor your code if it's really
event-driven jQuery or something maybe
you need to decouple the event from the
method so you can call the method but
not have to call the event itself
there's all different techniques and it
depends on how your code works and what
it's actually doing but making that code
portable it makes it more isolated
passing them in those inputs then you
can actually you know isolate it and
write a good test to make sure it does
what you expect this is a big one for me
about writing testable code is that your
tests shouldn't require one-to-one
Changez so if you change your code and
your tests always break it's probably a
sign that they're too tightly coupled
and going back to the the react fibre
thing how they were able to change the
implementation and most of their tests
still passed that's what you want to aim
for because that keeps your team's
morale up it means that you're really
testing the outcome and not the
implementation and this is something
that we're still working on on our own
team because it does happen and it can
be frustrating this is a big one your
tests and your code really should be
readable and compact and Justin Searles
had a great quote in that talk how to
stop hating your tests that the logic in
your tests can confuse the story of
what's being tested if it's not
immediately clear to you what the test
is actually testing it might be a sign
that you have too much business logic in
your tests so it should be compact and
readable and be really clear what's
under test what the results supposed to
be what the inputs are if any and so
that's a really good goal to have with
both your code and your test now let's
talk briefly about a different technique
called snapshot testing and you might
see this often especially in JavaScript
frameworks and react where snapshot
testing is a way of testing a component
to see if it changed you could also use
it to test something like JSON output if
you're expecting an exact result now
that could be brittle I want to warn you
that that might be best left for
regression testing after you've sort of
stabilized your codebase it doesn't
really work well for test-driven
development or component design but it
is more declarative and it can free you
up from having to write as many tests in
some cases since we're there's a lot of
visual people in the house it could be
helpful to kind of extend this idea of
snapshot testing to what's called visual
snapshot testing where you're actually
comparing screenshots to see visually
what changed and there's a cool post
from clarinha engineering about how they
use visual snapshot testing it's useful
in projects that have a lot less visual
churn like if you're working on a
pattern library or something where you
really care if like a single pixel
changes it might be less valuable in
some
that's rapidly changing that isn't a set
of patterns but it is a tool that's out
there that you could reach for some
snapshot testing tools include jest
that's a framework from the react team
that you could use with or without react
there's a thing that builds on top of
that called react storybook which is an
interactive testing environment and that
might be a cool thing to play around
with because you're not actually having
to write the test yourself you can just
play around in this visual interface and
then there's a tool that builds on top
of that called story shots which
actually will give you those snapshots
if you want to compare visual output so
you want to use these tools to focus
your efforts so that when you do manual
testing you can focus on exact component
states that require human attention so
it's all about improving your throughput
and making sure that you aren't having
to test everything manually so let's
talk about some accessibility automation
because this has a huge part of trying
to fix your process and building more
accessible user interfaces because if
you are building interfaces that humans
use your job is to make them accessible
. so for accessibility it's all about
making things that work for people with
disabilities along with everyone else
and if you need some help motivating why
you should code for accessibility and
use inclusive design microsoft has a
really great inclusive design toolkit
that has all kinds of personas and ways
that you can really see the value in
making something accessible because
often if you make it accessible for
someone with a disability you're
improving it for everyone else some
low-hanging accessibility fruit that you
could just knock out right away are
things like keyboard support and we saw
an example of this earlier in the how-to
component from the google chrome team
both manual testing and automated
testing using the keyboard plays a big
role making sure you can see where you
are on the screen with a focus state
making sure that things are reachable so
you want to do that initial manual test
and then you can bake some of that
functionality into your automated tests
you could automate things like HTML
markup to make sure you didn't forget an
alt attribute or a form label
you can automate things like Aria
attributes to make sure you didn't
misspell one or forget something or use
it wrong cuz I know I did that and then
lastly color contrast that's a really
big one to automate because you can
actually test the foreground and
background colors to make sure that
there's enough contrast for someone with
low vision someone outside and the Sun
it really starts to benefit everyone
another the number two tool so my number
one tool for accessibility testing is
just using my keyboard but my number two
tool is something that I went to work on
a DQ which is ax we have a browser
extension for Chrome and we're
redesigning it for Firefox as well but
it'll allow you to test some of that
low-hanging fruit right in your browser
there's other tools like ax but this is
my preferred tool and I love working on
it it's pretty awesome you can find ax
the underlying JavaScript library you
can find on github and NPM and so x core
is the set of rules and the engine that
power the browser extension and you can
pull that into your code in your
automated tests and then you're getting
the same set of results that you would
get in the browser extension and the
latest version supports shadow Dom which
I'm really excited about so to write a
test with X core you can get it from NPM
and then require X core and then write a
test using the accident run method you
can pass it any element reference or
select your string it'll default to the
document but here I'm passing in a
drop-down that I've included in my code
and then you can set any number of
options and then at the end it will give
you a JSON result set and in there is a
violations array and I'm expecting that
it has zero violations now you want to
make sure that you're testing multiple
states so in this drop-down I'm testing
it on first load but user would then be
opening the drop-down so I want to run
the test then as well so in my tests I
can go and call the open method on this
drop-down and then assert that it still
has zero accessibility violations really
great way to work
now there's another tool that uses X
court called X webdriver j/s and this
uses a selenium webdriver in a real
browser instance and the difference is
that ax webdriver jus will do the work
for you to go step
i frames and if you're working on
something that has iframes inside of it
from a user and accessibility point of
view you want to know if there's
accessibility problems in those iframes
because that's what a user would
experience you may or may not have
control over those iframes that's
another story but that's the difference
between ax cor and ax webdriverjs is
that you get this access into iframes so
in this one I use selenium webdriver to
open a URL could either be on localhost
or out on the internet somewhere and
when that promise returns I can use the
X builder and call the analyse function
and then it passes me that same result
set that I can use to check for
accessibility problems now this makes
sense on the integration test level so
you can test page level things like
color contrast the HTML title all it'll
run the whole result set for you so some
tips for accessibility testing if you're
new to it start with your keyboard like
before you do anything just make sure
that you can actually use the keyboard
and that you can see where you are on
the screen this is so important I don't
know about you but I have carpal tunnel
on my elbow that flares up and I can't
get anywhere near a mouse so I'm often
wondering like why he doesn't more of
the internet support just the keyboard
like that would be the best thing that
you could do is just support the
keyboard you want to test multiple
states so make sure you're testing after
modal dialogues of open and after
drop-down menus have opened it's
important to note that we can't automate
everything so this sort of automated
testing with tools like XCore are really
just the start and if you're new to
accessibility start with a checklist go
get a list of things that you can just
go check off and that's a really great
place to start so that you're not
missing things and if you want to learn
more you can go to a DQ university to
get some training and that's a great way
to work as well and if you if you know
someone at the disability they can get
training for free so the goal with
automated testing is to test and
refactor as you go along so in that
spirit of agile even if your team isn't
officially capital a agile you want to
iterate on this so you're not home or
with that box of spiders jumping on your
face all at once because you can quickly
get buried with technical
that especially with accessibility so if
you chip away at it you can keep this
healthy process that's continuously
improving and it keeps everybody much
happier
so to recap tests are really important
for teams if you have multiple hands in
the codebase you want to make sure that
your code isn't just magically going to
break it's even important for you in the
future to protect yourself from yourself
because I know if I put a project down
and come back to it I'm like wait a
minute what was I doing again you can
spend less time hunting down bugs if you
can capture something in a test then
you're not having to look for
side-effects and it really has value in
trying to create quality software you
could spend more time shipping code
instead of manually debugging it and
yeah it's really about shipping quality
software that holds up over time and
that's usable by more humans so thanks
so much for listening you can find me on
twitter at marcy sutton and i've had a
really great time today so have a great
conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>