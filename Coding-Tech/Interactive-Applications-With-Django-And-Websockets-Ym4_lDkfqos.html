<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Interactive Applications With Django And Websockets | Coder Coacher - Coaching Coders</title><meta content="Interactive Applications With Django And Websockets - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Interactive Applications With Django And Websockets</b></h2><h5 class="post__date">2018-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ym4_lDkfqos" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so the title of my talk is butter smooth
interactive applications with Django and
WebSockets so I'm gonna be giving a
little preview of interactiveness on the
internet with regards to web
applications and then build up to its
django channels and WebSockets and the
kinds of problems that be faced
I'm not going to go too much detail into
how web
Django's channels work because it's a
work in progress
and there I believe there was a full
tutorial on django channels and a lot of
the other talks talk about django
channels specifically so I'm gonna be
talking about the tooling and some of
the deployment issues that we've had a
more formal introduction about myself
I've been working with Python data for
over 10 years started my career writing
assembly programming and just woke my
way up to up the stack so I'm like a
full stack dev but stops at the other
server level so I've written programs
for GPUs a lot of that kind of stuff but
I really love Python I love Django
I love how clean and none of the magic
nor the black box stuff you can just
open up the code and see what's going on
I've been doing data analysis and sequel
for the past couple of years my claim to
fame is I wrote the first wiki engine
for Emacs and wiki blog engine so that
was pretty cool it was accepted into
mainland mainland Emacs and this is a
long time ago I currently run Saluda
which is a is a is a data analysis tool
for professional data analysts sequel
recipes which our product is something
like this this is just to give you a
context on the challenges we faced you
type in sequel there it's a text box and
you hit run and it creates these charts
and then you can schedule these charts
share these charts and do whatever you
want so that's essentially our product
who uses our product professional data
analysts so if your it's not sequel like
the ORM style sequel it's for building
histograms correlations doing
forecasting regressions all the kinds of
data analysis stuff that you would do
but using sequel so if you google for
Saluda sequel recipes there's a full
list of I think two dozen recipes you
can copy/paste
everything is straight-up sequel so this
is a timeline of asynchronous behavior
on the web how many of you guys are
familiar with iframes that's awesome so
but 20 years ago iframes was how you be
you get interactive web applications if
you guys are familiar with MapQuest and
some of the I guess the pre web 1.0 kind
of applications you click a button and
then it dynamically generates iframe
URLs and then it refreshes I believe in
even hotmail the first version of
hotmail worked that way so you click
send and then it refreshes his iframe so
that was like interactive web apps and
then around 99 Microsoft introduced xml
httprequest which is the precursor to
ajax it's a way of creating asynchronous
request responses around 2004 Gmail
launched and Gmail was the first I would
say kind of a single-page app so there
was no full page refresh when you hit
Send
to send an email around 2005 Ajax the
tome Ajax was coined 2005 was when
Django was released publicly and then
2012 meteor yes how many of you guys are
familiar with meteor GS or heard of
awesome so meteors is like was
mind-blowing when I first saw well how
it worked
so it was like interactive fluid web
framework where there was a subset of
your database being held
on the front end so you query your front
end and it's it's pretty fluid it's
pretty amazing how it all works
I I still don't know if it's a good idea
but it's pretty sweet 2014 react was
public started gaining adoption I
believe that's when the single page app
acronym SBA was started getting into the
mainstream 2016 I believe there's a
small framework called rails they now
include WebSockets support into their
mainline they call it act action cable
so that's roughly the outline of
interactiveness on the web so this is a
very common way to visualize how
technologies grow and get adopted across
a wide spectrum so I would say three
2004 a lot of the innovative webs a lot
of risky applications were being built
probably only 10 or 15% of the browsers
out there support of the technologies
but those are that's the innovative
innovation on interactiveness being
introduced 2004 to 2014 early majority
big teams a lot of resources very
expensive to build these interactive web
apps but it was being done case in case
in point Gmail Google Maps a lot of the
first version of the web streaming
services and so on
2014 and up to now I believe you're
inching towards the promised land it's a
lot of the best practices have been
established there's still some
challenges on the fringes but more or
less we understand how to build a single
page app what are the concerns what are
the difficulties there at least three or
four mature front-end frameworks that
that look out-of-the-box view j/s is a
popular one react.js is another popular
one a lot of folks use ember gs so
that's pretty awesome
so I think we're getting there between
2014 around then there have been a lot
of the
commercial applications of these fluid
you know push notifications and other
kind of stuff so socket IO pusher
firebase meteor GS these are all a
hybrid of open-source and a back end as
a service kind of system to have
interactive web apps so the main
question is why do you need this like
what's uh what's the need
right because Django has been around for
ten plus years and it works pretty sweet
why would you want to change something
that'sthat's working perfectly fine so
in sort of answering this broad question
about why I'm gonna be scoping it into
our web app and why we saw the need for
web sockets and interactiveness and why
just regular web apps didn't cut it so
as I mentioned our product is a is a
sequel editor essentially you have a
text box you hit run and then it creates
these charts and then you go through
this workflow over and over and over
again so that's basically what our
product does so if you were to draw a
schematic on how this works you have the
app which is the web app running the
browser there's an ajax request that
reaches the back end and then the back
end which is django executes the sequel
query and then returns a HTTP response
so that's basically the the lifecycle of
your one one single iteration if there
is a mistake in your sequel your execute
sequel throws an exception and then it's
sent back as a HTTP response for the
right
error code and your friend handles that
so this this work for you know version
1.0 when we had no users everything
worked great so it's always pretty fun
to see you hit run and then it works
okay so awesome
so let's go to production the minute we
hit production and once we got a couple
of users we started seeing these
problems that were creeping up so I'm
just going to enumerate some of the
problems we've had with this regular
request-response cycle the first problem
is unbounded run time for the request so
here essentially what's happening is we
let the user type in arbitrary sequel so
we do not know beforehand how long this
sequel is going to take it could take
you know three minutes it could take 30
minutes it could take half a day nobody
knows because it's up to the user what
what kind of model or what kind of
analytics they're running so the problem
was some of our users were typing their
sequel hitting run and then closing
their laptop because they knew it's
gonna take half a day to run the query
and from our side you know having that
connection that recurse response coming
back and restoring the state was being
was a big challenge so that's the first
difficulty the second difficulty was
what is this what we call 8:00 a.m.
traffic spikes so in our product you can
organize the sequel queries into a
dashboard so you can have half a dozen
to a dozen different charts and create a
dashboard and at 8:00 a.m.
our users load up these dashboards and
you have 15 queries hitting our back in
and they're all trying to run and so the
the ratio between the peak load to the
low point was about 7x so you had to
provision 7x the number of servers and
resources to handle that load so when I
casually talked to my non-technical
friends so yeah I was at the office at
a.m. it's like oh good for you you wake
up at 6 hit the gym go for a run make
your breakfast and then you were at work
at 8 a.m. no actually no I I get paged
at 7:55 that the servers are down and
they're rushed to the office to fix them
but I don't tell them and say yeah I hit
the gym and you know do all that stuff
the third challenge was about deployment
because the Django's
were actually executing these queries
you couldn't really swap out new
versions of the code so if you have
let's say five servers that are
executing these sequel queries and they
could take anywhere from 30 minutes to
let's say three hours deployment was a
problem because deployment would kill
that executing query and the user would
never see the results so you know we
believe in active deployments quick
deployments the minute the unit tests
change or they succeed they just push
into production but we were not able to
do that because our users queries were
failing or were being terminated so that
was a big challenge so that is you know
a summary of the challenges we've had
with synchronous request response cycle
so we had to look for a alternate
solution so looking around you know I
think I met Andrew last year or the year
before and he was just starting out
maybe this is like version point zero
zero one of Jango channels and I was
pretty excited about it
it's like okay Janet Jango channels
seems like the Holy Grail right what can
go wrong so let's let's play with it
and so high level how Jango channel
works is that you still have your
synchronous request response cycle which
is under on the top half and then you
have a persistent bi-directional
connection based on WebSockets in the
lower half and so you send a message to
your back-end to the Ajax request and
then the backend sends in the response
through HP response just as usual but at
the same time you can send messages back
and forth through the WebSocket so your
server can initiate a message without
having a matching HTTP request or Ajax
request
so that's conceptually how WebSockets or
Django channels work they don't replace
anything it's just an add-on to your
existing workflow so the the method we
used was you continue to use when our
users hit run its
makes a HTTP request to your back in and
then your back end which is Django I'll
float it to this worker queue excuse a
sequel and once it's done using
WebSockets notifies the front-end that
the results are ready so we're able to
push it out of Bank so the just as a
thought experiment the alternate
old-school approach would would have
been using a thread on the on the front
end to pull your back-end for results
and if there were results you get a
response but then that's undo load right
you can't set the polling interval based
on the query because you don't know so
you're gonna hit the back and let's say
every 30 seconds and that's gonna break
if the user queries only take two
seconds to run so the long polling
approach had its own issues so pretty
amazing just went to the documentation
copy/paste examples into our code two
days and we had it all working amis was
working everything was working on my
laptop okay
amazing let's go out for drinks because
this project is done you know where can
I sign up for my bonus check well no not
really
it took us about six weeks to make it
production ready
so going from our laptop to our cluster
servers took a lot of time so you can
copy/paste examples from the Django
channels but the rest of my talk is
going to go into the challenges we faced
taking it to production which I get I
guess is the meat of my presentation so
it it works it all out on my laptop you
know an MVP it's a proof of concept the
challenges seem to you know that it
looked promising
so this is when you sit down and write a
business case for how to react your app
because this is pretty expensive you're
writing the core or rewriting the core
of how you're doing book
so we came up with his a list of bullet
points and I'll just walk through them
so the the big overarching aim of this
project was to make the backend the
driver of work the front end just
because the user says run this we're not
going to obey that command we're going
to schedule it and work on that query
when VC fear when we see is as a good
time so we're going to be the back end
is going to be the driver rather than
the client saying hain handling of state
you know the the state could be a query
is in progress the query has failed the
query has succeeded the query is ready
to be run and then there disconnections
in the middle because people could go to
trains people could shut down their
laptop so you just have to you know map
out all the possible states and try to
understand what's going on just a clear
picture server-side events there are
lots of approaches for doing this but
the silver should be able to communicate
new data to the front end without the
front end asking for it I think that's a
very powerful concept no propriety
solutions
another time against propriety solutions
but I feel that when you're working with
brand new technology it's a lot harder
to debug propriety technology solutions
so one of the difficulties I have had
with socket IO is you have to run socket
IO on the back end which is no js' and
it was pretty challenging to debug what
was going on because I come from a
Python back-end and debugging in the
external stack was was a challenge
keep investments in Python plus Django
stack I guess what a lot of other people
would have done is they were just thrown
in meteor j/s or a node.js stack and
then offload this asynchronous component
can do to no js' and let no js' deal
with this because there are lots of
frameworks on node.js that help you do
this we did not want to do that because
every time you have an architectural
decision and you add a new layer
to the stack I think your your product
becomes kind of a Frankenstein product
and it just it's just too much to keep
in your head because now if you're
trying to hire someone there you're
asking them for like react from an
experience you're asking them for Django
experience you're asking for no J's
experience and then the deployment
options it's just too much so we wanted
to keep everything standard out of the
box Python plus Django off-the-shelf AWS
components our stack is completely on
Amazon Web Services so we do not want to
build something custom which means no
recompiling nginx to add WebSocket
support because we wanted to use
Amazon's load balancer for example
because it has a lot of benefits it
gives you health checks
it has good logging a good logging
framework it does DDoS attacks a lot of
lot of good features and we wanted to
tie into that ecosystem so it didn't
make sense a lot of sense for us to
bring in our own infrastructure
components so roughly this is this is
our architecture diagram so we have our
clients on the bottom which could be I
just found this in some kind of stencil
program there it's a phone it's a laptop
and it's a desktop so three kinds of
clients and they connect you a load
balancer which has WebSocket support and
these the load balancer then starts to
load balance to a back-end which could
be the web sockets plus the regular G
unicorn so it's a it's a hybrid it with
the synchronous in the asynchronous part
and then Redis is the persistent layer
where the channels are being shared so
if you go through the Django channel's
documentation this is one approach
that's recommended using Redis as the
backing server and of course you still
have your standard Django components you
have a database you have the ORM and all
that stuff but roughly this is the
architecture
so now the challenges why did it take us
six weeks you know that's that's a
little odd you know did I go on vacation
for four weeks during the project no not
really because we were iterating through
the solutions and we found that
something was wrong and then we had to
go back to the drawing board and then we
were trying to swap out this stuff I
think there was some conflict with our
initial motivations and our business
plan where we wanted to stick to just a
Python stack so it was a lot lot more
effort to get it to work but I think in
now I'm really happy with how it's all
working out and going forward it's gonna
be a breeze to maintain because there's
no custom code anywhere so the first
challenge was cloud deployment I'm gonna
go step by step into the challenges we
faced so if you remember the
architecture diagram we need a load
balancer in front of Gina Khan and the
asynchronous web server the problem with
a lot of these standard off-the-shelf
webs load balancers is that they're HTTP
load balancers but what WebSockets needs
is a TCP load balancer so all the stuff
if you're familiar with Django's cookie
base authentication cookies are HTTP
layer concern so if you have a TCP load
balancer
you can't really attach that cookies
like it can't read the cookies so if
you're trying to have sticky sessions
based on cookies it's not really gonna
work and I was surprised to see this but
look a lot of the load balancers out
there on the cloud we're all HTTP load
balancers so Google Cloud Azure Amazon
but fortunately Amazon launched a brand
new load balancer last summer called the
application load balancer which is a TCP
level load balancer but the problem with
a lot of Amazon's products there is is
that the documentation is just straight
out wrong or they say yeah we don't
recommend you doing this but that is
exactly what you need to do so it's kind
of fortunate that I was taking the train
from Vancouver BC which is home for me
down to Portland for PyCon and
one of the elastic Beanstalk engineer
has gone in the train so I just fed him
like tons of beer and asked him like why
the hell is is not working what's wrong
with this why is it documentation wrong
what do you have three versions of the
same stuff which are all like in
different layers of compatibility so the
lesson here is make sure it's working
with the application load balancer the
deployments on your laptop are very
different from the deployments on the
cloud and try to try to figure out how
application load balancer works with
your rest of your stack the second
challenge we had was to do with missed
messages on disconnect so here's an
example let's say Jango periodically
sends a silver sent message to your
front end right so it's moving upwards
and so the green bars is when your
client is connected to the back end and
then for some reason is disconnected
either the user goes through a tunnel or
there's some kind of disconnection
notice and the server sends a message
but this message has nowhere to go
because the client is not connected so
that's the stop sign or the no entry
sign and then the client reconnects and
it's missed those messages and then it
happens again so if you're going to be
missing a lot of the messages that your
backhand sends you and the back end has
no no kind of system to to acknowledge
that these messages that have been
received you're gonna be left in a very
bad shape your your client state is just
going to be an invalid state it's it's
pretty challenging and I was surprised
to find that on the cloud it's actually
quite frequent to disconnect persistent
connections there's just not not a
guarantee there is an NPM package called
reconnecting WebSockets essentially does
a for loop and if it's a disconnect it
tries to reconnect so that was easy but
what we had to do is actually fix the
missed messages on the back end so our
solution to that was to serialize all of
the messages being sent from the backend
timestamp it and implement a cursor on
the client side so if the backend sends
message one message to message
three message for the client keeps track
of one two and then it receives four
okay you know what there's a problem so
go back to two and give me all the
messages since two so that's roughly how
it's essentially a table that we store
on the back end and then the client
implements this logic where if there
there's a gap in the sequence it can go
back and rewind that cursor so what we
did here as an implementation level
detail is not distorted in our database
but Redis has this data structure called
sorted sets and so you can actually pop
and push into this reddit structure and
it's actually really fast so there's no
there's no delay in in trying to store
this this ring buffer we also wrote a
middleware because we wanted to make
sure that every message going from the
back end was going through was being
time-stamped and sequentialized so it
was important to go through that single
stream our third problem was a friend
architecture our front end is a is a
single page react app and these messages
from the back end you don't really know
when they're gonna come they could be
out of order it could be different
components because it's a single bus
that all these messages come in and so
we were actually pretty confused in
terms of how do you update your
front-end State and so what we did there
this is an example let's say that's your
web app and you have a notification
system that gives you a drop-down with
all the new messages and then you have a
feed which tells you all the new
elements that are inserted into your
feed system and our WebSocket handler
gets all these messages and then you use
standard J queries on messaging so you
essentially implement your own messaging
system on the front end to dispatch
these messages so if you guys are
familiar with how i OS apps are built
there
a single bus and you get these messages
and then they're dispatched through
different views and these views listen
when they loaded and then they destroy
the handlers when they unload so it's
the same kind of concept that way your
notification system and your feet are
not tying directly into WebSockets
there's an abstraction layer there and
for whatever reason if WebSockets is not
supported you can always fall back this
is just an architectural idea on how to
organize your front-end problem number
four debugging debugging testing all of
this was was a big challenge because you
cannot use curl to mark requests a lot
of the Django test clients and all that
stuff doesn't work so what we did is you
know that example with the middle way
that serialized the messages we just
stored that as our fixture so we were
able to bring up a friend inclined and
then feed it messages from the backend
based on this fixture and then it's
pretty important to keep that stream of
messages on your back-end and the stream
of messages received on the front end
and push them both into a centralized
data store so you can reconcile the
messages that have been sent from the
back end and the messages that have been
received from the front end and see if
there are any gaps so without this
unified view across the client and the
server it's kind of difficult to figure
out what's going on here's another tip
Chrome as is pretty awesome ws tab I
spent two weeks debugging Chrome
WebSockets without knowing chrome had
this built in so you can just click on
the frames and this gives you a
sequential list of all the messages
received through the WebSockets
it's either outgoing or incoming no
problem it just shows it to you and we
just use JSON as a transport so you can
you can inspect it
you can purify it whatever you want
so guys that concludes my talk and I am
open to questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>