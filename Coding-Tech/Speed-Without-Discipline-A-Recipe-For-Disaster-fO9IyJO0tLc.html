<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Speed Without Discipline: A Recipe For Disaster | Coder Coacher - Coaching Coders</title><meta content="Speed Without Discipline: A Recipe For Disaster - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Speed Without Discipline: A Recipe For Disaster</b></h2><h5 class="post__date">2017-12-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fO9IyJO0tLc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's a great pleasure to be here to talk
about a topic that definitely I'm keenly
interested in I'm sure a lot of other
people are interested as well I want to
talk about you know we a lot of times we
talk about agility we talk about agile
development I worked with a lot of
different clients and when I walk in one
of the first things they want to tell me
is we are agile and I often tell them
I'm so glad we got that out of the way
now let's talk about what you actually
do and so what I want to talk about is
is identity but part one of the part of
agility is what I call as sustainability
and sustainability is something
extremely important for a lot of us
because we can't really be agile if we
can sustain the pace of development and
in a world that is changing very
constantly we really definitely have to
do anything and everything we can do to
sustain it and that's what I want to
talk about but before I talk about that
particular aspect let's talk about what
will you see around us well we live in a
world of buzz we we have a lot of
different buzzes around and so what are
some of the latest buzzes that we hear
about well I've been kind of listening
to a few things that I've been hearing
about one of them of course is
micro-services well we we can't get by a
day today without hearing about
microservices everybody suddenly wants
to build micro services and then we tell
here about Big Data everybody is talking
about big data cloud of course
everything is on the cloud how could we
escape that and of course docker
are is it Moby and then of course we
hear about function of programming quite
a bit it's been around for a very long
time but suddenly it's a new excitement
and then of course it's angular 2 R is
an angular for already and then of
course then we hear about IOT we hear
about AI and it really draws smiles on
my face when I think of the word
algorithm because you know that
something has become a total buzz when I
hear the word algorithm in TV shows
these days everybody wants to talk about
algorithms all of a sudden of course
machine learning and recently I was told
machine learning is so obsolete we're
now talking about advanced machine
learning
have a clue what that is but that's what
we wanted to do so we live in this world
of buzz we want to be always catching on
to the next big thing always looking at
things what everybody else is doing but
what is this really leading us to words
I started programming a good I don't
know maybe 35 40 years ago and I look
back at the time when I had to learn
programming to the time now people in
schools and colleges having to learn
programming honestly it's overwhelming
it is absolutely phenomenal in terms of
how many stacks of abstraction we are
built upon and the things we have to
learn things we have to know it's just
incredible so we are dealing with high
level of levels of abstraction as we are
building more and more larger and larger
systems how do we really survive that
kind of complexity of what we need to be
building and I think this is one of the
most interesting things if I look back
at my own career programming for a few
decades now all I can think about is
those times when it hurt me the most and
those were the times of paradigm shift
paradigm shifts are really hard for us
because it really requires us to change
our way of thinking we have to rethink
about how we solve problems and there's
been about maybe three if not four
different paradigm shifts I've gone
through in my career and I think we are
again to a paradigm shift right now this
paradigm shift is not new it is just
that its newly being adopted but it's
been around for a very long time but
looking at the paradigm shifts the
paradigm shifts of the 90s was
predominantly into object-oriented
programming before the time we were
pretty much building systems using
procedures and and structured
programming languages but we generally
adapted to object under programming
pretty pretty widely in the 90s and we
the structured programming to the object
when the programming mindset and almost
every single system and libraries and
languages we've been using since have
been in object-oriented one way or the
other
very very significantly but in terms of
the latest paradigm shift that we are
going through right now like I mentioned
is not new but just that we are
beginning to adopt it so you may wonder
what it is and I'm gonna say that is
from imperative to declaration style of
programming and I want to outline this
because we have this buzz about function
of programming right now and I feel that
it really misses a very important point
it's not really that the functional
programming is really that awesome
that there is something very underlying
to functional programming that really
makes the difference so it's my
excitement honestly is not about
functional programming my excitement
really is around declared style of
thinking and I'm saying decorate I love
thinking because it's not just about
programming and declarative style but
beginning to think in a declarative
style and good outline of places where
we see this almost consistently and
almost every aspect of what we do not
just in programming but also in the way
we live our lives as well and how we
interact with this aspect societies so
why not functional programming well the
reason really is in the imperative style
of programming you talk about what to do
but you also focus your effort on how to
do it an imperative style of programming
has ruled the world almost every single
one of us in this room has spent a lot
of time and effort programming an
imperative style
I spent my youth learning imperative
style of programming that tells you had
a terrible childhood and it was that we
programmed an imperative style for a
long time and unfortunately imperative
style of programming is inherently more
complex and we've been dealing with
really poor choice of a tool given to us
in the declaration style of programming
we tell what to do but then we let the
underlying libraries and tools figure
out how to do it this is a very
fundamental shift in the way of thinking
not just in the way of programming and
it turns out that functional programming
is actually a declaration in nature not
all declarative code is
functional but all functional code is
decorator so one of the biggest
strengths in functional programming
really comes from the declarative nature
of programming and a lot of times when
developers don't think about it and
instead rather focus their time and
effort on functional style it gets a
little frustrating but once we get the
idea that we really are trying to be
declarative rather than being imperative
our line of thinking immediately it
changes quite quite nicely so then what
is the relation in these two well the
relationship really is that the
functional style of programming is
actually declaration style plus the
higher-order functions so it really is a
mixture or a marriage of these two
things that we think this effectiveness
into it so anytime we program in
functional style not only do we use
higher-order functions but we also
pretty much focus on programming
declaratively as well but this is not
just in programming but we can see this
pervasive in almost everything we do so
let's just spend a little bit of time
thinking about what the difference
really here is in the imperative style
of programming we tell what to do but we
also have to spend the effort telling
how to do it so here's a little example
to think about I have a list of names
right here let's say the problem given
to us is due to let's say count let's
say count the number of names which are
let's say four letters in length so
that's what we want to really do very
simple problem if you really think about
it but how much time and effort do we
take to do something like this well
first of all you start with a little
variable called camp eventually you want
to display the value of count but
between these two you're going to start
with a four and and we have tools given
to us when we deal with a lot of
different tools but this is what we
normally do it with these different
tools to get our work done you could
start with for example I equal to zero
then of course you say is I is less than
and then your struggle is it less than
or less than or equal to you have to go
through all this details of complexity
and an instead of doing all of that
thankfully we can also use a few simpler
constructs we could say
and then of course of names and then
within this of course we could say if
the name dart length is equal to four
then we could say count is countless
plus and that uses a result of three not
only did this require a lot of typing it
required a lot of doing
we had to control the loop we had to
tell how to really go through it
we had to branch and do all of lot of
these things this is inherently a
declaration of style of programming that
we are so used to when it when it comes
to programming and that can be really
really annoying in terms of how we have
to get the work done but the complexity
really comes from these things
complexity comes from having to deal
with all these low-level details in our
code almost constantly but rather than
doing this the declarative style keeps
our focus we are able to convey what we
want to do and we let underlying
libraries do things for us in a way if
you really think about it the imperative
style of programming is like talking to
a toddler when you first up to a toddler
it's very exciting because you are like
wow I was able to talk to the start ler
it was so much fun but the second day
you talk to the toddler you begin to
realize it's not gonna be fun anymore
because you gotta repeat the same damn
thing again and the third day becomes
the same thing on the fourth day becomes
the same thing and then you realize this
is gonna continue for the next 18 years
that's called parenting isn't it that's
how it feels when you programming the
imperative style well with the
decorative style of programming we can
focus and tell what to do and let the
underlying libraries figure out how to
do it so for example in this case we
could simply start out and say names
dart filter and given a name I could
simply say named dart length is equal to
four and then I can simply ask for the
length of it and get the work done
so the point really in this case is we
can keep or focus on what we want to do
and we can use better tools to get our
work done and in this case of course
it's the filter tool and similarly map
tools and reduce tools and these
constructs but this is really the
decorators style
that is really shining right here of
course this is a JavaScript and
JavaScript incidentally has been doing
this for a good 20 years but one of the
reasons why we haven't really exploited
this is especially with the language
like JavaScript most of us will
programming not just in JavaScript but
we're programming in JavaScript and yet
another language like Java or C sharp or
what-have-you and because the mainstream
languages did not support functional
style of programming most of us their
developers had to become comfortable
with doing similar things on both sides
so we gravitated towards more of an
imperative style on JavaScript as well
even though the language has supported
this for a very long time but now that
most of the mainstream languages are
beginning to support functional style of
programming we are able to enjoy this
lot more easily in JavaScript as well
but this is just at the programming
level and that is declarative in code
but we can go a lot further than this we
can see this take effect in almost every
aspect of our lives including front-end
programming for example let's say you
want to program the front-end how do I
write the code for programming the
front-end so here's a little example and
what does it really mean to create a
rich environment for programming the
front-end well tip you are manipulating
the Dom so here is an example of a piece
of code I'm saying document dot get
element by ID and I ask for a little
element whose ID is called greet and
once they get it I create a Tom as a
variable and then I say you know Tom how
are you and I said that into inner HTML
this of course we know as manipulating
the Dom how many of you have manipulated
the Dom before of course everyone here
but how many of you want to do it again
not a single hand I can see up because
the first time you played the Dom you
quickly realize it's a word that should
be given to people in the prison nobody
in the free world should be forced to do
it right because it's no fun it's too
low-level detail
it's horrible way of programming and
some of us did this and some of us still
do it very quietly
we just don't you know announce this in
public so this is really a lot of work
this is an you
of style of programming on the front end
and very quickly we struggled to move
away from this well what could we do
differently than this well we could try
to use jQuery for example now jQuery of
course puts a little dollar greet we
didn't say document gal Gilman bad ID
and then what did we do one of the
complexities of the imperative style is
not only to do all of this work but you
also have to know what the properties
where the methods were for different
things and honestly I could never ever
remember this is it clicker on click or
is it checked or unchecked
I cannot smart enough to remember all of
these details I just suck at it every
time I get to it well take where he said
I'll give you a set of convenience
functions to use but alone honesty
jQuery is like taking morphine to reduce
your pain it didn't remove the pain
jQuery still is imperative style of
programming it's just a little bit you
know a wrapper around things so you
don't have to struggle that hard but
then where are we today well we are
moving towards something like angular
and an angular what we are doing is we
are saying select or is greed and then
you say the template and you specify
what the content of the template is well
notice the clear difference between this
code and and this one this one here is
imperative style of programming whereas
this one here is declarative style of
programming you simply said I have an
element whose name is great I have a
content which is the template and that's
it you told what to do but you'd let the
underlying library figure out how to
actually do it this is a consistent
theme that we see in development today
so what does this really feel like well
I'll give an analogy to what this feels
like in in our lives
um I am in all honesty not a fan of
course I have friends who are really big
fan of course I've got children who are
big fan of course I just don't care
about cars personally when I go to the
rental car company they often ask me
what kind of car would you like I say I
would prefer one with wheels please
that's how much I care about cars I just
don't know
don't care enough about them you will
never ever catch me drive a stick-shift
that's just not for me that's way too
much cycles in my mind to be focusing on
driving which I don't care about so I
don't really care to drive sticks just
though there are people who really care
about it programming with the dom
programming imperatively is like driving
a stick shift not so much fun in my
opinion then of course you could use
auto transmission cars
I have an order transmission I can put
it on Drive and I can just focus on you
know steering or please don't have to
mess with the gears and the clutches I
don't have to worry about it I still
have to keep with a focus on my street I
still need to manage the driving so that
is like auto transmission I would say
jQuery is your auto transmission you're
still doing the work but at least it
removes a burden on you but a couple of
weeks ago I was in a Tesla and I have to
tell you I am sold already I got on the
freeway I said there you know maximum
speed 270 I put it on auto drive and I
took my hands off and I was just sitting
there and driving and of course not
really driving that's the fun part of it
and and after a while it said are you
still awake and it just kind of beeped
at me to make sure I hold the steering's
a little bit and then it said okay
you're still awake let go and I had to
let go and of course it had just his
speed accordingly and I was able to
change lanes automated it was wonderful
well okay I'm not there yet it's still
not fully available yet but they're
getting there but what do I do in the
meantime well I'm a goober are a lyft
kind of guy right now and that is one of
the things I really like a lot I arrive
at the airport it doesn't matter time of
the day or night when I walk over to the
curb I find it over or left I get in and
I tell the person where to drive and
then I sit in the back of the seat and I
do what I like the most to write code I
don't want to be doing the driving I
just tell them where to take me the
driver does a much better job navigating
the cities and I'm a trust me it's
better the driver drives than me drive
if you know how I Drive and the point
really is that I'm more of a you know
person who sits in the car and have
somebody else
me doctor me is like a decorative style
of programming so you simply tell where
you want to go you're not doing the work
of going there and let somebody else
take care of it and that's where the
world is heading towards is a
declarative style of programming
decorative style of living in fact but
how does this really impact us and the
point getting back to we are living in a
world where we are no longer going to be
programming at the lower levels for you
know for very long the level of
abstraction has already increased and
it's only only get even more higher as
we go through and as we do this the code
we're writing is going to become a lot
more expressive it's going to become a
lot more concise the code is going to
become a lot more easier to maintain and
you can support rapid change but the
question is now that we are sitting on a
very tall stack how do we really deal
with all this complexity and it really
comes down to economics of software
development
we cannot be developing at the low level
every single bed it just simply doesn't
make any sense
so we have to gravitate and move towards
this direction no doubt about it but
let's talk about how the world is
changing you know a lot of us
programming Java I program in Java or
the JVM language is quite a bit but I've
also been programming in JavaScript for
a few decades now and slowly but surely
I'm doing a lot more work in JavaScript
these days as well but let's talk about
JavaScript for just a little bit because
some of the things I'm gonna talk about
is a problem in Java as much as any
language but it just simply aggravates
in languages like JavaScript but what is
JavaScript I'm gonna say javascript is
the he's a great example of a black
swamp a Black Swan is is an idea or a
concept or just about anything you never
knew existed enly become so prominent it
did anyone ever expect JavaScript become
to become such a serious language even
the author of JavaScript did not think
that it would and it's just amazing how
one day you wake imagine this was the
year 1995 and somebody asked you
what language you think would be more
popular and people will be talking about
in 2017 would you have ever imagined to
say JavaScript and had you said
JavaScript what would people think of
you they would say are you crazy out of
your mind
but that's just amazing how it's turned
out to be but but what is really
JavaScript though a hominid a physios
JavaScript in one way or the other
how many of you like JavaScript well
fewer hands stay out right I know the
feeling for that well I think there is a
reason for it
javascript is an extremely powerful tool
I can't think of a language that is as
powerful as JavaScript in terms of its
capabilities but javascript is
dynamically typed but javascript is also
is weakly typed and the weak typing of
JavaScript also becomes a burden I was
programming with JavaScript the other
day and I had made a certain small
change and the next thing you know I had
no clue what was happening anymore in
the application so that's what did this
and this is a true feeling I have over
JavaScript because I really like
JavaScript and and the truth feeling
either but javascript is that javascript
is like an infant it is cute to play
with but you have no clue when it begins
to cry and and that is so true in a lot
of different ways because once the
language begins to misbehave you're like
mom this kid is crying I don't know why
and then you go through this checklist
of things that you feed it did you make
sure the diapers change you got to go
through a set of debugging to figure it
out it can be very frustrating because
there is one thing that I've understood
very clearly you never use the word
JavaScript and logic on the same
sentence because there's no logic when
it comes to JavaScript and and so when
it comes to writing code in JavaScript
how do you deal with this it's a very
big slippery slope it's a very powerful
language no doubt about it but it got to
really be very careful using this line
guys it can hurt us really bad and when
it comes to this we are mixing this kind
of scariness and power in our hands with
agility on the other side so let's now
talk about agile developments
what does agile development well agile
development is responding to change
oh well wait a minute that's not just
responding to change it is responding to
change even late in the game which means
anytime anybody could come to you and
say gosh we really want to change this
and you must be able to accommodate
those changes so how in the world can we
accommodate change late in the game and
survive it and how can we really sustain
it so in this case what does it really
mean to sustain this and so this is my
observation you go to a developer and
you say I want you to make these changes
I want you to make these enhancements I
want you to fix these bugs and I want it
tomorrow or maybe later today and the
developer goes around and makes all
these code changes and then when you go
to the developer you ask this question
that everybody hates being asked you ask
the question does it work socially it is
evoking a response called I hope and
this is a sentiment we all share and
I've been struggling with this and I
finally figure it out there is actually
a technical term for that particular way
of development it is called jdd it
stands for Jesus driven development you
put hope in the faith of Lord and you
say dear Lord
please stay with me I have written this
code my boss is on my tail I've got this
code to work please so we all do jdd
every single day but I think we should
really let the Lord do more important
things there is to do in our world and
let the stinking code be right to up
ourselves so I like to really do TDD
rather than doing jdd but even the PVD
has different connotations I was with
the company recently and they said we do
TDD and I said I don't get it how do you
guys say you're doing TDD and they said
well that's called threat driven
development
I don't like thread driven development
either where somebody says you will do
this otherwise well I think we should
really be a lot more mature about it how
can we do this so I was
one one morning I wanted to really go to
a travel site and get my boarding pass
and when I went to the boarding get the
boarding pass I won't mention the
airline right now but but when I fly
very often and all I can see in the
airline's website when I went to
check-in was all these curly braces on
the HTML page and I remember saying oh
you're so cute you're using angular I
really wish I'd taken a photo of it but
the next morning when I realized it
instead of taking the photo I made this
tweet I said don't bother testing your
software if it does not work the users
will tweet about it well we've live in
this world where we cannot be developing
poor quality software because it becomes
more visible today how do we stand
behind the code be right how do we make
sure it's actually working so I've also
come to realization about what we are as
software developers it's a little grim
but I think most of you will agree with
this so who is a software developer and
I'll tell you who else after developer
is it is a person a profession where
people get paid to write poor quality
code and get paid more later to come
clean the mess and this is a great
profession to be in I mean why would you
not want a job like this you can screw
it up today and get paid to screw it up
more tomorrow right and and we have
fundamentally changed the way we do
things because we have to become
professional we have to really think
about our job as a profession and say no
we cannot be writing code like this we
have to do a lot of things differently
sure we have pleasure pressures from the
organization for the management from the
company from the requirements from the
users but we have to really turn into
professionals how do we go about doing
it how could we become better software
developers over time than being this
definition of software developer where
we are getting paid together right poor
quality code and they'll get paid more
to clean up the mess later so we can
have to rethink about what we do this is
what one of the areas where I care about
a lot and I spend a lot of time and
effort on on testing
I'll be honest about this I always worry
about what I say I always think about
what I say and I ask myself is it
something I would do if it my money was
involved in it and I'll tell you where I
firmly begin to realize and benefit from
this because I used to work for a lot of
different companies I used to work for a
lot of different clients and it's easy
to really say things when when I work
for somebody else but over the past few
years I've been writing software for my
own company and when I write code the
person who is paying for my time writing
the code comes out of this pocket right
here and if I mess up the code I'd write
I have two choices I can spend the night
fixing the code I wrote and if I'm
spending the night fixing the code
honestly I would rather spend the night
doing more fun things like writing new
features than fixing the mess I created
or I could hire somebody else and say
here take my money away and clear the
mess I created neither one of them is an
option so when I started writing code
for myself I quickly realized that I am
actually spending a lot more time
writing tests much more rigorously and
and I was struggling to understand my
behavior in this case because I was
extremely tight on budget I was didn't
have time and that's when I came to this
realization I like like to automate my
test not because I have a lot of time it
is because I don't and this is one
realization I came to eventually is that
I'm doing stuff the way I do not because
I have a lot of time time is one of the
most precious thing ever can have and
and I do things a lot more efficiently
not because I have a lot of time but
it's because I don't have a lot of time
and time and again spending the effort
doing this right has come back to pay
dividends in a very huge manner over
time in terms of not only saving my time
but also improving the reputation as
well I remember very clearly one
Saturday morning I wake up in the
morning
I had a client here in Europe who
emailed me and said hey I'm looking at
your app it would be so nice if you just
gave me this one feature it was about
5:00 in the morning on Saturday just got
up early I looked at my watch I have two
hours before the family is gonna wake up
and start running and I said to myself
why don't they just spend some time
working on this and I want to emphasize
this arrogance but about really knowing
what we are doing and so what I did is I
went ran all my automated tests
everything passed i'm wrote a few tests
for this new feature the person wanted
ran all the tests made sure all the
tests are passing checked in the code
pushed into production never actually
ran the application
manually to see if it's working within
about 3-4 hours I get an email back from
the person saying exactly what I wanted
thanks for doing this and and the point
where I'm getting to is when we can do
automated verification we can get that
confidence and agility and to me agility
is not words that I speak but the life I
live in the way that I do things that's
extremely important for me
so given this what what about testing I
want to start out by emphasizing that I
truly love manual testing and I want to
emphasize this I truly love manual
testing but I want to emphasize also
what I mean by the word testing to me
the word testing really means it's an
act of gaining insight into applications
now this is one of the sad things people
often argue are we taking the job away
from testers no we are not taking the
job of it from testers because we never
gave them their job in the first place
and that is the sad part of this because
we've been doing asking them to do stuff
they shouldn't be doing in the first
place the job of a tester is to really
gain insight into the application is it
usable is it intuitive to use is the
workflow really useful should I be doing
something else what are the features
missing in there should we really be
changing the way
the user interacts with this application
there are so many things that we need to
focus on from the point of view of
testing and to me that is really what
testing is but I want to really think
about the word test versus verification
testing is an act of gaining insight
verification is on the other hand
something extremely different a
verification is asking this really
mundane question does it work and if you
really think about it this is what we do
about 95% of the time you modify the
code and the question is does it work
the code worked yesterday does the code
continue to work today and there is a
strange behavior in the code and I'm
sure you have seen this as much as I've
seen it the code always does what you
type and not what you mean how annoying
it is and then when you go back and look
at it tomorrow
dammit that's not what I meant I meant
it to be less than and not less than or
equal to or plus 7 rather than plus 8
all these things that come to annoy us
and haunt us does it really work and I'm
gonna say that no human should ever be
asked to manually verify if the code
works I take that as an insult on
humanity for somebody to go to a fellow
human and say can you verify that that
code works that's a poor form of respect
not to that human but to the entire
human race in my opinion because no
human should ever be subject to this
does it actually work that is the job of
applications and systems and computers
to tell us not for humans to waste their
creativity and time and effort to
determine that something that worked
yesterday continues to work today
so tests manually but verify
automatically and and that is one of the
reasons why automated verification all
automated testing is really so important
well we can all agree that automation is
critical but how are we getting there
so I work with a lot of different
companies around the
and this has just been my observation
learning from these different
organizations and I've found out that
there are three different groups of
companies out there or I would say three
phases of verification the first phase
is no automation these are companies in
denial they're like we're cool we can
just do this manually and verify this
works and they're in denial they're just
facing really really slow death or maybe
greater death depending on the industry
they are and it is impossible to keep up
with the demands of the application by
manually verifying if the application
works so I used to be in this in this
phase in companies I worked with I've
realized that that's not the place to be
I moved on very quickly then there's the
second phase yes to automation so of
course we need to do automation no doubt
about it but but this is where the
challenge comes in there is cases where
we want to automate but what are the
companies do they go hire somebody with
really beautiful titles one of those
titles is called automation engineer
what a beautiful title so automation
engineer Joe walks into work and says
hey folks on your new automation
engineer what is the core programmers in
the team do they are very busy fixing
bugs and they say hey Joe welcome to our
company now leave us alone don't bother
us we are busy here we don't want to
talk to you so what does Joe the
automation engineer do spends a few
weeks looking around the team and
notices the programmers are nose-down
very busy working and everybody is doing
their own stuff and what does Joe the
automation engineer do scratches the
head and says what what in the world
what do we do now and goes to the
programmers the programmers are like
don't talk to me now I have no time for
you so in the meantime the boss comes to
Joe and says so Joe how's it going I
want to see some automation and work
what are you gonna do and Joe is stuck
between a rock and a hard place
Joe can has to automate but programmers
don't want to talk to Joe so what does
Joe do that's when you start hearing the
words like selenium
and when you start hearing words like
selenium I come to this realization you
I level mostly you a level automation
has a really good technical name for it
it's called the pathway to hell
automation and this happens a lot in
companies when I go to companies they
never seem to use the per sentence when
it comes to you a level automation they
often use the past tense when we use to
write all these automated tests I'm like
why do you see used to oh we used to
have thousands of tests running at the
UI level then these damn programmers
change all the user interfaces and
nothing works anymore we don't have time
to keep up with this there was one
exception though I had a of mine down in
Texas and and they said oh we do this we
hired a company out of Vietnam they're
doing a really good job this works I
said no no no it doesn't work oh no no
it works really let me show you to you
this gentleman said and takes me to his
desk and shows me a system doing
automation at the UI level it was like a
ghost to sitting there and playing the
application you could see unseen hand
type into the keyboard and characters
appear and then things change on the
screen he said it's a little slow that's
all I said how slow is it oh it takes
about 12 hours to run the suite of tests
but it's beautiful it works I said are
you really sure this words oh absolutely
I said you know what I speak in
conferences if this works the world
needs to know about this so I'm gonna
submit a talk on how to rock at
automation in the UFO if you will teach
me all your secrets he said I will teach
you all my secrets this is going to
change the world so I said I'm back here
in your company in six months let me you
know schedule and afternoon with you
I'll be your student you teach me
everything let's just do this
absolutely so six months goes by the day
comes when I am inclined sided goad him
and said remember we had this talk can
we have the half a day that you're gonna
teach me all this stuff oh those damn
tests we haven't run them in three
months now I'm like whoa what happened
well they drastically changed the UI and
none of the code test is working we
don't have time to fix it well I thought
there was a whole point
there but unfortunately no and this is a
repeating theme I see over and over just
to share one experience about it this
was back in January a couple of years
ago I had a client of mine with who has
offices in the UK has a testing team
here in Poland and the boss calls me on
the phone and says I've got a you know a
tester here Poland was having trouble at
automating this test would you please
help him so we are in Skype I'm in
Denver Colorado the bosses in the UK a
developer the tester here in Poland we
are on a three-way call and the tester
explains to me what he's doing and I've
listening to him I am I got a suggestion
for you don't do it and go talk to your
developers sit down with them find out
how to reach one level below the UI and
do the automation testing don't test the
UI level this was in January then and I
was actually physically here spending a
week at the client site here in Poland
and when I went in this tester came to
me and said do you remember we had a
talk back in January and and you told me
not to write those tests at the UI level
I said of course I remember very clearly
he said I've been doing it since that
time and I said well that's interesting
how's it going he said it doesn't work
I'm like well if it doesn't work why are
you doing it still he said that's okay
don't worry about it
I know you're coming here this week so I
said that Thursday it's you and me I'm
like oh my dear God can I die before
then and so it was Thursday in the
morning I sit down with them and I'm not
kidding with you I never felt so stupid
in my life before because we spent four
hours and this one little test would not
work and here I'm telling don't do it
and here's the tester who says do it and
I mean they say the customer is always
right I don't who ever said that to be
shocked but the point really is I'm
sitting here trying to figure out how to
make this work and and then we do this
manually you go to this little item
there's a little list box you click on
the list box and this box shows up you
select an item the list spark falls and
the
content on the right side changes
beautifully it works we write as he has
written a selenium test for it I look at
it it doesn't work after a little bit of
struggle I tell him oh my gosh I know
what's happening cuz like what is it
well when you click on it it's
instantaneous to your human eyes but
humans cannot see changes too rapidly it
takes 250 milliseconds for a human to
know of a change in front of us that's
when you don't see the fan blade
spinning when it spins our selenium test
is wicked fast it is querying for the
results before the JavaScript had time
to respond to it let's put a little in
sleep so we put a little sleep in the
code and guess what that test passed he
jumps over the seat and says it works
I'm like no sit down now you're not
supposed to do this and it took me the
rest of the afternoon to convince them
no please don't do this and the point is
it's extremely brittle and we spend way
too much time doing this it's pretty
pointless there is a name for it we live
in a field where we are the most amazing
people in the world the developers
because we'll do absolutely stupid
things but we'll give a nice beautiful
pattern name for it it doesn't feel bad
anymore so this stupidity I talked about
has a beautiful pattern name it's called
the ice cream corn pattern the ice cream
cone pattern view Google what you'll
find about that and the ice cream cone
pattern is where you do a lot of tests
in the top levels and very little tests
in the bottom level this is the industry
standard this is what people are doing
mostly when it comes to test automation
they are living the life of pathway to
hell by doing the ice cream cone pattern
we should definitely run away from this
and and this is very largely ineffective
what we really want to do is what fewer
companies are doing really well and that
is right level of automation to the
right degree to the right measure and
this has also has a name if you google
for it you'll find it it's called the
test pyramid and test pyramid and and
many people have written about it Mike
Cohen has written about in his book
Martin Fowler has talked about it blogs
as well so the test pyramid is where you
do the right amount of tests at the
right level now I care a lot about
automation testing I care a lot about
integration testing but to me I don't
want all the tests to be in the
integration level
I want the test to be at the right level
for the right reasons and this is
something that can give us a lot of
different benefits but why is it so hard
now I believe a lot in writing tests
first write tests and dendrite code that
is something that I believe in a lot but
then I realized it's really hard for two
reasons the first reason why this is
really hard is when you hear people tell
you the cord is hard to test what
they're really telling you is the design
of the code sucks if your code sucks in
design it's really hard to automate the
test for it that is one of the reasons
the second reason why this is so hard is
something that took me a while to
realize and figure out and the problem
here is when we are when I go to
developers who are really smart and I
tell them here's a problem go implement
it they go away and within a few hours
they come back and say here you go
here's a solution that works well
awesome then you go to the same
developers and you say here is a problem
but don't write code write test first
and then write code and they look at you
like you're stupid and say are you out
of your mind how can I write code how
can I write tests without writing code
and so it really baffled me why can't
smart developers who can write code not
write tests before writing code and
eventually I realized there is a really
good reason for it and the reason is how
do we actually write code is there
anyone in this room who is given a
problem and you just sit down and say
I'm gonna write code and then you just
type it
and everything works and then you just
get up and walk away bu is that a person
like this in this do we have such a
divine presence in this room nobody
stood up right that's not the way we
write code how do we write code I'm
gonna try this I'm gonna try this that
doesn't work let me try this other thing
that does damn this doesn't work how
does this work
well it's almost works but not quite we
struggle through it and then eventually
it works so what is programming so I'm
gonna say this is what programming is
programming is a series of mini
experiments and this is what programming
really is that lead us to discoveries
and honestly this is what programming is
to me programming is a series of many
discoveries and to be honest this is the
reason why I am still a programmer today
because being a programmer is like being
a kid in the candy store every single
day you go to work you learn you
discover you understand and you never go
really sit down and just write chord
boringly and sleight gosh this job sucks
I wrote all the code I know I'm going to
go home now
no if we discover we experiment we
figure things out well if that is what
programming really is how in the world
can I write a test first when I don't
even know what I'm implementing in the
given time so if it is something you've
done a million times over
maybe you should reuse it not rewrite it
but if you don't know how it's working
don't do test first in the beginning so
what should i do how could I make it
work really and the answer to that
really is to to spend the time on this
activity called spiking so in other
words you cannot write the test or
series of tests on a very large unknown
it just doesn't make sense to do it so
what you want to do is you want to take
very small steps you want to divide and
conquer but the most important thing is
you want a spike to learn and and
spiking to learn is one of the most
important phases that we tend to forget
when it comes to automated testing so
when I sit down with the right automated
test to give you an example of this I
wanted to write a piece of code that
integrates with Amazon Cloud to push a
particular file on the cloud and manage
this and in all honesty I have never
ever done this in my life and I said to
myself I'm gonna write a test before
writing this code I'm like my gosh how
do I do this I don't have a clue so I
left my project right here leave it
alone and then walk over here to a
separate directory and I created a
standalone project that would allow me
to purely experiment and I spent the
next 15 20 minutes writing a piece of
code that will push this kind of file to
Amazon Cloud with the reader with those
type of requirements I had in mind and
once I got that working it's no longer
an unknown I have taken the time to
experiment I've taken the time to
explore I've taken the time to program
it and now I left the code right here
walked over back to my project and now
that unknown is not a series of unknown
those are a series of known in my mind I
started writing tests and writing code
there are two benefits I got out of this
the first is that little experimentation
the spiking I did was a throw hood I
should throw away that code and it was
just a little mini experiment but the
code I'm writing here is going to go
into production the tests were driving
the design of this quote very
differently than the little spike that I
created second later on when I had to
come and make changes to this code it's
been a written production for about
seven years now I made several changes
to it over the years and every single
time those tests are the angels on my
shoulder they tell me that the code
worked yesterday but they work today as
well and that confidence it gives me is
enormously powerful so a lot of times
the reason we have difficulty writing
these automated tests is we don't take
the time to do spiking but by spiking to
learn and then come back and write the
test really helps us a great deal in
doing it so is it possible to even write
automated tests on something like
JavaScript and the answer is absolutely
yes
and two as an example you know here's a
sample of taking a copies of code from
all the way down to the MongoDB in the
bottom all the way to a X for a server
in the middle and all the way through
angular 2 on the top into HTML and in
this little sample these are the number
of tests at each of these levels more
tests in the bottom level fewer tests as
we go up and and that's exactly what I
came when I was writing the test draw
alpha script applications essentially
the aha moment for me was to really
learn and figure out it is not just a
theory but we can actually do this and
and having done this on on some client
projects it's to really bring this out
and say it is possible to really capture
these details and and bring it out so
but what does it take to really be able
to write these things well the very
first thing is discipline it really
takes discipline and just really
concerns me a lot because it's easy to
throw our hands up and say gosh my
managers won't allow me to do it our
management won't allow me to do it but
remember we are part of professionals we
are professionals you know with all
respect Management cannot know the
details of what we deal with actually on
a daily basis it's far too technical on
no level for them to comprehend us but
if the people who know these things
don't write the change we have
absolutely no hope in my opinion so it
requires discipline on our part to
really affect this change we need to
have the discipline it takes time and
there are two types of time it actually
takes the first time is the time to
write the test itself and rather than
just writing we are taking the time to
write the test and I would argue that
time is relatively negligible in the
long run as time goes on we gain that
time back in not having to deal with the
other issues but there is yet another
time we need to really keep in mind and
this is where I see a lot of
organizations actually fail and that
time is time to get better at our skills
now step back and think about the time
you didn't do
thing and you had to really learn it
like learning to bicycle learning to
drive a car learning to play piano
whatever it is you have to take the time
to practice and practice and practice
until you got better with it
test-driven development is a skill and a
lot of times organizations don't give
enough time to get competent with that
skill we try to write a few tests and
then we hate it right away and we don't
get the speed and that's like getting on
the bicycle for two minutes and saying
gosh I would never be able to ride a
bike this sucks and get off of it so we
have to really invest the time to learn
that learning time actually is very
significant and and and and
time-consuming as well it also is a
skill and learning that it's a skill we
have to develop is something that really
gives us the ability to say it just
another skill if I put myself into it
and practice it I can get better at it
and it's a skill that we're gonna get
better at it over time no doubt about it
and of course it's also a culture it's a
culture of caring about what we do in in
some organizations there is that culture
where people take pride in developing
things that are of quality and for us to
really seek those organizations and to
build those organizations as well
becomes very critical but I'm gonna say
automated verification is the software
equal and tough exercising if I ask
people in this room and you don't have
to raise your hands for this but if I
ask you to raise your hand who here
thinks exercising this is you know
useful or beneficial almost everybody in
the room will raise the hand but if I
ask you to keep your hand up if you
actually exercise it very few hands
probably stand up and the reason is we
all give excuses we all have good
reasons why we don't exercise I've got
this report I have to write I got this
bug to fix can you imagine having to fix
a bug and going to exercise that's not
going to happen I have this proposal to
write a card two flights for my next
stock whatever your reasons are going to
be I'm not gonna exercise today and when
you don't exercise today the next
morning it's a fresh set of excuses and
sometimes I go
for five months without exercising until
I begin to feel the pain and I tell
myself I should never do this and I have
to get back on to exercising but that's
kind of automated verification everybody
may agree this is very important and
useful to do but very few of us have the
discipline to do it I'm gonna say what
year are we in in software development
well no it's not 2017 I'm gonna say we
are in 1820 of software development
because if you look at year 1820 the
Year 1820 was very significant in the
medical field in the medical field in
the year 1820 that mortality rate was
very high after surgery if somebody went
into surgery if they did not die during
surgery they died within three weeks
after surgery if a friend of yours comes
to you and says I'm gonna have a baby
should I have a baby in the bathtub or
should I go to the hospital you may tell
your friend bathtub is better you will
survive and that is the way it was back
in the 1820s and the reason for that was
largely unknown the hospitals in major
parts of Europe and especially in the UK
they thought something was bad in the
air they used to keep the windows and
doors open in the middle of the day to
clean the air hoping that patients will
not die so much and they just didn't
understand it
a Gummer buys a Hungarian had a kind of
an inkling he didn't have a proof for it
at this point but what he started doing
was he started really boiling in hot
water all the instruments he was using
and then he would perform surgery with
it and his patients died very less
compared to a lot of other doctors and
he was the one of the very first people
to propose the thing called germ theory
unfortunately he didn't live for too
long they killed him eventually and and
that's what happens when you try to
speak sense into the crowd it becomes
really hard sometimes in the world we
live in and and a few of us really get
together and say maybe this was a better
way to do and some of those guys were
these two guys Joseph Lister and Louis
Pasteur and
they did was they said hey maybe there
was some truth to what he said and they
started experimenting and and and
looking into this more and these people
really brought together some of the
changes we live today in terms of how
things are being sterilized and how they
started reducing germs they especially
Joseph Lister was one of the people who
went into to the the establishments and
said hey doctors do you know why your
patients are dying back in time some of
the really good doctors we're really
known for how big certain they were
based on them onto blood the hair on
their coat and so these doctors were
carrying germs from one patient to
another and actually helping the
patients to die and when they pointed
out and they said you need to be
cleaning your clothes you are carrying
the infection one of the very first
things they did was they disallowed
these people to practice medicine so
that is basically the world we live in
it takes a lot of time to affect change
but a few group of people will sit
together and start doing better job and
I'm gonna say we are in the 1820s of the
industry in terms of where we are today
in our field I want to end by saying we
are practicing a beautiful craft
programming is something that is deeply
enjoyable and it is something we come to
work every day and honestly a lot of us
have fun writing code it is a great
beautiful profession and we want to
continue building on this profession but
it's time for us to take a return into
making this wonderful it turning this
into a wonderful profession and not just
a craft we can become professional by
focusing on quality focusing on creating
things that we can stand by and I hope
we can do that thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>