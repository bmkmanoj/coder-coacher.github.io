<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Reasonable JavaScript | Coder Coacher - Coaching Coders</title><meta content="Reasonable JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Reasonable JavaScript</b></h2><h5 class="post__date">2017-08-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0cJqiO_Q0KA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my talk today is called reasonable
JavaScript and I know I'm sitting
between you and dinner and drinks so I
hope you can give you 45 minutes of your
time to get through this and hopefully
you walk over at something what does it
mean for code to be easy to reason about
like I've heard it at many conferences
I've heard it up meetups oh I've heard
it I've heard just people randomly say
easy to reason about when they talk
about some code or some concept like
they might say react makes code easier
to reason about or one way data flow
makes code easy to reason about or like
static type checking it makes code easy
to reason about or you know immutability
makes code easy to reason about your
functions make code easy to reason about
and before you know you hear you hear it
everywhere in so many different contexts
and I didn't really know what it meant
and I kind of want on like create a
concrete definition or somewhat of a
concrete definition for what this means
and why we talk about reasoning without
code so that's kind of what my talk is
gonna be up be about today and so the
goals are what makes code easy to reason
about so define what makes good easy to
reason about why JavaScript sometimes
make it harder to write code that's
easier to reason about and then lastly
talk about different methodologies that
we can use to write JavaScript code
that's easy to reason about if you walk
away anything in this talk I want you to
walk away with knowing what it actually
means to reason about code and not hand
pain wave over this concept before
getting started someone keep track of
how many times I say easy to reason
about because it's gonna be a lot okay
so let's get started I'm gonna start off
by saying that javascript is a fantastic
language for many reasons I mean you're
all here today you probably use
JavaScript every day we're crazy enough
to use it on our servers as well so why
is JavaScript awesome well for one it
runs everywhere right it's on every
browser every operating system every
device it's incredibly everywhere
second it's really versatile like we can
use it for a lot of different things we
can use it to as a simple scripting
language we can use it to build complex
web applications we can use it to build
sophisticated api's
it's IOT apps desktop apps and now even
mobile application ativ mobile
applications so it's sort of everywhere
immediate feedback loop I think this is
really incredibly important especially
for beginners like creators need to see
what they're making immediately and I
think javascript HTML CSS gives you that
most of the languages don't give you
that as much so that's really important
also the community I mean you guys are
located you guys are all here today it's
an awesome community I love being part
of the JavaScript community and that's
one of the reasons I fell in love with
programming and I and I think the
community around javascript is just like
incredible and lastly it's
beginner-friendly and the reason I say
it speaking of friendly is because
there's no compilation no complex
developer environments all you really
need is a text editor and a browser know
type system that you have to learn as a
beginner global support in any browser
and as I said before immediate feedback
loop but I would say this is a blessing
and a curse
because I think the same correct
characteristics that make JavaScript
easy to learn or and great for beginners
are also the same thing that make it
difficult to write code that's easier to
reason about and so I'm gonna start off
at an example and kind of show you what
I mean by that we're gonna have this
calculate area function and you're gonna
see this a lot throughout the
presentation so I hope you get used to
it and all it does is it takes a bunch
of radii and it interacts over them and
calculates the area and returns the
areas of these radii now as good
programmers that we are let's understand
the program's behavior let's actually
figure this out if it works right first
question we might ask is does it
function right like so we might just
pass a bunch radii and check that the
output looks correct and to me that
looks fine so we can just say yeah it
functions it looks good so far the next
question we might ask is does they do
anything that we don't want it to do
like
we tested that it works but what if you
log the original array of raid radii we
see that it got mutated it's now the
array it's not the areas and no longer
the radii that's not good what if we
want the radii to calculate the diameter
later or the circumference whatever it
is
so we're mutating our original array
next question we might ask is is it
consistent in its behavior so here we
pass in a bunch of radii we get an
output then some time passes and later
on your program some evil programmer
checks in some code that updates your PI
variable and then now your Radia your
areas are totally jakie enough that's
not very good right another question you
might ask is does it properly handle all
possible inputs so what if radii is for
some reason ends up being undefined what
ends up happening in JavaScript is you
throw it throws an exception at I per
and says you can't calculate length on
undefined okay so then you you being the
good programmer that you are you're like
okay let me go back and fix this let's
redesign our program so step one let's
not mutate the original array so what
we're gonna do instead is create a new
array called the result and put the
areas in that result array and return
the result array another thing we're
gonna do is remove the global
dependencies so the PI was global and so
anyone can mutate it so we move it into
our function and put it in the scope of
the function so that no one can touch
our PI step 3
handle invalid input arguments so we're
gonna do some error checking before we
actually iterate over that array of
radar radii we're gonna say if it's
undefined or null do you throw it there
our next turn or if it's not an array
throw nerve and then we actually do our
logic so now let's go back and
understand our improved programs
behavior right does it work yeah it
works does it mutate the original radio
I know does it return
assistant results over time yeah it
seems to and does it handle invalid
inputs yeah it seems to do that too
looking good but I'm gonna do some more
battle testing because I thought of
another edge case what if you pass in
undefined instead of a number into an
array because in JavaScript undefined
squared is nan we get nan and it
silently fails and returns you that
array similarly if you pass in a string
you get 0 cuz string squared apparently
is 0 she's awesome right so then you cry
and you go back and you redesign your
program again and you test for this edge
case where you actually check that each
of the radii being passed in is a number
if it's not there on earth
otherwise actually calculate the result
now I think we have a winner where it
correctly handles all those edge cases
so what did we learn
one reliance on global variables causes
our programs to be unreliable I think
this is a no-brainer everyone knows this
already but we just learned that through
our calculator area function second
mutable data can lead to unintended
side-effects because we were able to
mutate the radii we did mutate it we
didn't have a restriction around it so
we did having no way to restrict the
type of data that can be passed into a
function makes us think extra hard about
error handling because in JavaScript we
don't have types we can pass in anything
and so we have to do extra error
handling in the function and type
coercion like undefined squared being
nan or string squared being 0 makes it
hard to protect the behavior of our code
and realistically if you look at this
our finished version of the program like
is this something a beginner would
really write like I don't know a year if
this was me a year a year ago I probably
wouldn't have thought of all these edge
cases and written a function like this
out of written just the original one
because these are not things I'm really
thinking about I'm just thinking about
getting a function to work
and so this is why some people get
frustrated with JavaScript there's like
no compile time restrictions it allows
you to do a lot but you will do anything
so one possible conclusion is you can't
write code that's easy to reason behind
JavaScript so then we give up definitely
not right I'm here for the same reason
you are and we all love JavaScript so my
proposed conclusion is with a little bit
of extra effort you can write reasonable
JavaScript so for the rest of this talk
I'm going to talk about a few of many
building blocks that we can use to write
reasonable JavaScript and before getting
started I want to create a definition
for how we can think about thinking
about reason to me out or like what
makes code easy to reason about so that
we can go back after each building block
and see which one of these criteria that
building block meets so I'm gonna say
when a program does not affect your
mutate external state it's easier to
reason about and it should not also rely
on external state and it should always
return the same corresponding output for
a given input and we'll see why these
three characteristics lead to the code
that's easier to understand the intent
of easier to reuse easier to maintain
easier to refactor easier to test and
hence easier to reason about ok let's
begin first building block is unit tests
so we have a function write original
function and we might write a test that
says this should work and you pass in an
array of radii and you expect it your
expected results and you test that it
equals you expected result and that
passes and if you're a good test writer
you might also write a test this is this
should not work and you pass in invalid
inputs in this case you expect that
function to throw an error but this test
it doesn't throw an error because we saw
the undefined squared equals nan and
I'll not throw so then you might go back
update your program to so that your test
passed and now your test pass so if you
go back to about three bullet points how
do tests help do they help us not affect
or mutate external state not really do
they help us ensure that we do not rely
on external state not really but do they
help us ensure that they're always
returning the same corresponding output
for a given input yeah we can test for
that because we can always tell if you
have a test that something should return
something we can guarantee that it will
always return that so overall white
tests right there's a lot of benefits to
writing tests we can verify that our
code behaves correctly you can test
error cases in edge cases it's like
living documentation essentially and we
can make changes without fear because if
your tests fail then you just update
your you know that something went wrong
so second building block is types types
are not native to JavaScript so I'm
gonna explain give a definition because
I know most people might not be using
types yet so a type is just a
classification of data which tells the
compiler interpreter how the programmer
intends to use the data essentially it
just defines a set of inputs and outputs
to a function so I'm gonna use a library
called flow which was released by
Facebook and it's an API that allows you
to add types to JavaScript you can also
use something like typescript
I chose float because it's just easier
to I find I use it not myself I haven't
use typescript but sorry I haven't used
you have a new type string so I'm gonna
add types to our original program and
you'll see I added a type of PI as
number and then I added to our input
argument radii I set up an array of
numbers and then the output is also in
our array of
purrs now if we had a function that
properly passes in an array of radii and
when you flow check it will say found
zero errors but if you had somewhere
somewhere in your code if someone passed
a string into this function and you type
checked it flow would complain and flow
would say string this type is
incompatible with array number so it
catches this catches this stuff for you
at compile time before you ship it to
your customers while you're coding so
that you can fix it and deploy correct
code
so why types I want to explain a few
different reasons one it separates data
from behavior so when your type when
you're writing types it forces you to
think about what your data is before you
think about what the actual behavior is
and this kind of mental separation helps
a lot when you're coding so that's our
data and then this is our behavior - it
searches Limit living documentation I
actually pulled this right out of our
code base so we have this function
called generate params it takes
apparently a quote a commit an amount
and it returns it does some business
logic and returns a params object when I
looked at this I was like what do I pass
to this function what's quote is that a
string is that a is that a number is
that a boolean like I had no idea how to
use this function I had to ask around
and then or like grep through my code
base and figure out what's being passed
into this and then I updated it so that
I added documentation on top saying okay
this is this is a boolean this is a
boolean this is a string this is great
and all but comments go out a day and
documentation goes out a day I know I
see so many comments in my code base
which are totally out of day or just
terrible documentation it's not
consistent so what types what happens is
your your documentation is in your code
and anytime you update the function you
have and you have to update the type so
the documentation automatically gets
updated so here we say quote boolean
commit boolean amount boolean amount
number and then we say it returns an
object
so another reason is it removes
convoluted error handling and testing so
this is our flow our type sorry a
function with that's type checked right
so we did we told it that it's gonna
take an array of numbers and return an
array of numbers sorry and because of
this we don't have to check do all the
error handling that we did before
because even if you try to pass in a
string or some invalid input it'll
automatically throw at compile-time
so now our program becomes actually what
we would have written without all the
error handling another reason is it
eliminates an entire category of bugs so
the number one bug that we see in our
react or like front-end code bases type
errors and type a static type checker
would eliminate that so I'm gonna show
you a very basic example of how this is
how the type checker could help so let's
say you have some app state and it's
there's is fetching it is fetching or
not and then there's an a simple array
of messages and then you have a you
fetch your data and then you have a
component that takes your app state and
it just says you have messages don't
want unread messages and then it maps
over the message and displays a message
super simple component but what if your
API is unreliable and it returns
undefined or no or something then you
have a typer in your bug snag that says
type or a Qunari property of a length of
undefined but if you were to use a type
checker like flow we can add types we
can say our app state is fetching as a
boolean and I'm gonna say messages
because I know my API is unreliable I
want to say messages is a may be an
array of strings that maybe means it can
either be an array of strings or null
and undefined that's the data the same
component now if you try to flow check
this well flow will say is property land
a property cannot be accessed on
possibly non null values so it's saying
because your messages array can be
possibly no
you can't do dot length on it handle
that programmer so then you go back and
you're like okay I'll handle that and
now you cannot you remind it to say okay
if it is fetching display something else
or if the message is no undefined
display a message saying that it failed
and if it actually exists then actually
display the component that you want it
so all this is happening at compile time
and the compiler is telling you how to
fix your mistakes before it gets shipped
so you can define your program
invariance and let the compiler tell you
when something goes wrong and then flow
will say zero errors and you can do your
happy dance okay
other benefits of types earlier
detection of mistakes as we just saw if
it the the the satisfaction of like if
it compiles it runs can refactor with
greater confidence because if you update
a type and you see compile errors you
know exactly where the code is being
used incorrectly and it serves as a
domain modeling tool where like you saw
a simple example with the app state you
can expand that and like actually model
your entire app domain using types which
is really helpful for documentation okay
so going back to our checklist
how do types help well do they ensure
that we do not affect or mutate external
state not really do they ensure that we
do not rely on external state not really
do they ensure that they always return
the same corresponding output for a
given input I'm gonna give this a maybe
because they do ensure that they all the
function always returns the same type so
if you say array of numbers you know
always return an array of numbers but it
doesn't ensure that it always return
just returns the same data per se so I'm
gonna give this a maybe but we also we
both saw that tests and types give us a
lot of benefits and it they don't really
fit into this like model these three
bullet points so I'm gonna propose that
we add another bullet point to our
reasoning but what it means the reason
about code I'm gonna say when we can
when the code is guaranteed to work as
intended by the programmer
because that's what tests and types do
essentially they guarantee that their
the program works as intended by the
programmer so this is our updated list
okay
so third building block immutable data
so Libra and gave an amazing talk about
this earlier today so I don't think I
have to explain the concept as much but
basically immutable data is when state
cannot change after it's created if you
want to change the mutable immutable
object you don't what you do instead is
you create a new object with a change
value and point your reference to it so
example here's me today and then I have
a me a year from now and I just
increment my age by one and if I check
that they're the same it returns true
this is not immutable because we're
updating the object but if you were to
use an immutable object we can I'm using
immutable j/s we create an immutable
record and then we when we want to
update it it creates a new object so
we're setting the age to what my age is
today plus one and we check that it's
equal it's not because it's a new object
that's immutable so going back to your
area function let's use immutable data
instead of immutable data and because
we're using immutable data we're forced
to map over it and return a new array so
here we're just mapping over the input
radii and calculating calculating the
area and now if we check that the
original radii equals a new areas it
doesn't so now our data is mutable and
you probably like okay so why would I
care about this right all right I'm
going to show you try to convince you
with another example who's gotten this
in an interview question ok this makes
me cringe so this is quicksort I've
gotten it a billion times in an
interview question and it's like the
most it makes sense logically but the
most confusing thing to implement like
you start at your new you started at a
pivot point and then for each value
lower than
pivot you put it you increment the pivot
by one and put the value to the left of
the current pivot and you keep doing
this recursively until you get a sorted
array but let's say we were in an
interview and we accidentally make this
tiny mistake or you put this J plus plus
down here instead of at the top of the
if block then when we go to show the
code to the interviewer we get this so
then we might put a debugger and try to
figure out where stuff is going wrong
and then go fix the program to match our
intent but we probably won't get the job
but what if I told you that with the
immutable data our function could look
like this each time because we can't
mutate the values each time what we do
is we first get the pivot which is the
first item in the list then get the rest
of the items in the in the array
calculate a new reference to all the
items less than the pivot calculate a
reference to all the items greater than
the pivot and you're simply at each time
Concannon all the items less than the
pivot to the pivot like we're in the
greater than the pivot to the pivot and
because you're not having to deal with
sequence of operations for loops while
loops it becomes a lot more declarative
like when you read this it looks like
you're just describing your quicksort is
you're not actually telling it how to
count how how to do the quicksort and
now when you do the quicksort on this
you get the correct answer and so you
get the job a lot of people might say
well it's a lot of objects especially if
you're arrays massive and my favorite
quote one my favorite quote someone I
look up to West Dyer is he says make it
correct make it clear and make it
concise to make it fast in that order
like oh I don't think unless performance
really really matters I'd rather have
code that looks like declarative and
looks like the second example than the
first one
so overall why me immutable data because
when data doesn't change we can just use
the data and not think about why they're
making too
is safe no one can mess with your data
nor you theirs so if you go back to our
checklist
what does immutable data give us does it
ensure that we don't affect or mutate
external state yeah that's the
definition of immutable data does it
ensure that we don't rely on external
State not really does it ensure that it
always returns the same corresponding
output for a given input not really does
it ensure that it's guaranteed to work
as intended by the programmer I'm gonna
say yes because we're not mutating stuff
and so there's a higher guarantee of
things working as intended
other reasons things like temporal
coupling persistence lazy operations
these are the things I'm not gonna go
into but what digging into if you're
interested about immutable data okay so
next building block pure functions
definition so I'm gonna start off with
what is not a pure function when
something relies on some external state
that's not explicitly passed to it as an
argument so what is a pure function a
function that relies only on parent
parameters that are explicitly pastured
as arguments to produce a result so
example here we have a self-executing
function I'm going to pull out and just
pass in one I'm gonna say C equals and
fasten one and what C is C is a function
now that takes in B and returns a and a
is bound to one because I passed in one
up there now if we take C and pass in
anything it will always return one and
that's because of the closure variable
the magic of closures right and this is
not pure because if you look at the
function B returning a you can't tell
just by looking at it what will return
without understanding the magic of the
free variable a so this is not pure
similarly let's say we have some
function that just simply tells you if
some amount exceeds the buy limit
of your customer so then you have you
can you first fetch the limit for the
customer asynchronously
and then you say if the amount is
greater than the limit return true
others false this is not pure either
because it relies on some external state
simple enough right when something
relies on external state like this the
one thing that becomes really really
hard is testing so to test that function
we have to now go find this a mocking
library mock out the response from the
API and then test it which is a pain in
the butt we all know but if you were to
purify this we're gonna assume this fun
we're gonna assume this function somehow
knows the limit and then you can program
in like a higher level you can say
simply if the amount is greater than the
limit return true others return false
and now testing becomes so much easier
so going back to our checklist there's a
pure function ensure that we do not
affect or mutate external state no but
does it ensure that we don't rely on
external state yes does it always return
the same corresponding output for a
given input yes because it's never
relying on external state so it should
always return the same output is it
guaranteed to work as intended by the
program right yes because a pure
function you can look at exactly what it
is and you don't need to look at
anything external but there there's more
when you combine the previous two
concepts of pure function and
immutability what you get is something
called referential transparency and this
is simply means the ability to freely
replace an expression with its value and
not change the behavior of the program
so anytime you see a function you can
actually replace it by the return value
and it'll always be the same and your
program should work the same and why
does it matter because if you go back to
our checklist when you have referential
transparency which means pure functions
and your mutability what you get is all
four so I could end my presentation here
but I want to talk about one more
building block
because I think it's pretty important
and it javascript is particularly good
at letting us use this building block
taking advantage of functions as
first-class entities so what does it
mean for a function to be a first-class
entity right it just means we can refer
to them as constants and variables we
can pass them as parameters to other
functions we can return them as results
from other functions so functions you
can think of them as variables and pass
them around do whatever you want with it
so why use them let's take a look
I'm going to talk about four different
ways that we can use them there's so
many different ways that you can use
functions for first-class citizens we
won't have time for all of them
so sedition one is replace loops with
higher-order functions like map filter
etc it's an example going back to our
original function if we just I'm using a
library called Ram DES so anytime you
see our dot something it's it's a
library called Ram DES which is a Java
Script utility library for like similar
to lodash but it's functional and I'm
just replacing this for loop with a map
and it automatically makes it so much
smaller and simpler and if you're like
that's not a big deal I'll try to show
you an another example and convince you
so we have this function sum of odd
square is less than 10,000 and you need
to sum all of the odd squares us in
10,000 so you have a array of odd
squares and first you determine what all
the odd squares are they're less than
10,000 so you have a while loop and find
all the odd squares and push them into
that array and then you iterate through
that array of odd squares and sum them
up this is one way of doing it and you
get 16 166 650 if you were to use
higher-order functions we can break this
up like this we can say let's have a
simple function just just tells me if X
is less than 10,000 let's have another
function that tells me if X is odd let's
have another function that tells me if X
I had a square axe and then I'm just
gonna I'm just gonna tell it what to do
and not how to do it so I'm gonna say
first map over my array and square the
items then I'm gonna take the take the
ones take all the ones that are less
than ten thousand filter for the odd
ones and sum them and I get the same
thing
so here I'm telling you what to do
whereas before I was telling it how to
do it and it becomes so much more
declarative so if you go back to our
checklist or do what a high order
functions give us do they ensure that we
don't affect or mutate external say not
always but like things like map and
filter they'll usually return you array
but it's not always guaranteed so I'm
gonna give that a maybe do the ensure
that we don't rely on external state not
really do they ensure that we always
return the same corresponding output for
a given input not really do they
guarantee that to work as intended by a
programmer not really but they do give
us a lot of other benefits like things
are shorter and less clunky they're
easier to read more descriptive allows
us to define computations by what we
want instead of how we want it overall
when you use Hydra functions it's more
information and less noise another way
to use functions as first-class citizens
it's parameterizing as much as you can
so going back to our calculator a
function let's say later on we want to
have a calculate diameter function
that's the same thing but it the the
computation in the for loop is a little
bit different it just multiplies the
radius by two let's parameterize this
right let's parameterize our action by
extracting out the common code and
parameterizing it so I'm gonna say
here's my here's how you calculate an
area and here's how you calculate
diameter except my function is wrong
just pretend that this is radius times
two for calculator and then I'm gonna
have a generic function that simply take
the
and a list and maps over that list and
performs the action on each item now I
can pass in my calculate area function
and calculate diameter function with any
into my generic action on list function
now I can use generic functions
everywhere let's say I can have a square
function a double function and negate
function and I can Pat it can use the
same action on this generic function to
pass in a the action and any list and so
what we end up having is very generic
functions instead of specialized
functions to do everything so going back
to our checklist does prioritizing stuff
ensure that we don't affect or mute a
external state not really does it ensure
that we don't rely on external State not
really does it ensure that we always
return the same corresponding output for
a given input not really there's a
guarantee to work as intended by the
programmer and not really but it does
give us a lot of other benefits like
passing any list to any data and
basically having like a generalized
function and decoupling the behavior
from the data licker action from the
list so just in three partial
application so first the definition
partial application means we can turn a
function that expects multiple
parameters into one that will keep
returning a new function until it
receives all its arguments this is a
mouthful and hard to kind of picture
until you probably see an example so I'm
going to jump right into an example I
have a simple function that applies fees
it takes a fee and an amount and it just
applies a fee to the amount and returns
the returns a new amount this is a
regular non partial application function
and we want to use it we have to pass in
a fee and an amount if we try to just
pass in the fee as in the last example
here here it will return and because
when you don't pass in all the
parameters in JavaScript will return an
but if we were to use partial
application I'm again using Ram de I can
partially apply the fee so I let's say I
have different types of fees like a coin
because you have all different types of
fees and so I have one function that
uses up my apply fees function to create
a apply bank fee function and it uses
the same function to create a credit
card fee function and uses the same
function to create a paypal fee function
and now I have these functions that are
partially applied and when I when I use
them I just pass in the amount I don't
have to worry about passing in the fee I
just pass in the amount and I get the
different amounts based on what my fee
is so what all right so I'm going to
show you another example to see if you
if you might be convinced here's an old
piece of code that I found in a code
base that I updated but this was how it
looked
basically what it does is it fetches
the valid payment methods for a user and
what valid me into this first effect is
all the payment methods for the user
then it picks off then it iterates
through the pay methods and finds the
ones that have allowed by true as as a
property and then it iterates through
them again and checks that a property
limit stopped by the remaining is
greater than zero so meaning there by
limit is greater than zero and then it
just formats it by by returning just an
ID and the name of the pay method now if
you use our own advice
and use higher-order functions you can
clean it up to look like this we can
just filter for the ones that allow by
then filter for the ones where limit up
by that remaining is greater than zero
and then just return the ID in the name
so that looks way better already
what if I told you that if we use
partial applications it can look like
this
essentially each time you're getting
about you're passing in a function that
expects data at the very end you're
never dealing with the data itself the
data is always coming last instead
you're just dealing with
what you want to do with it you're
saying first I want to pick the data
property off the response then I want to
filter for the ones where the property
alibi is true then I want to filter for
the ones where limit up by the remaining
is greater than zero then I want to pick
the ID and the name property off that
off those objects so in this case
because I'm simply telling it what to do
I'm never introducing the data it just
becomes so much smaller and cleaner and
more expressive so going back to our
checklist does it ensure that there's a
partial application ensure that we don't
affect or mutate external state not
really does it ensure that we don't rely
on external state not really does it
ensure that we always return the same
corresponding output for a given input
not really is it guaranteed to work as
intended by a programmer not really but
there's obviously a lot of benefits like
you saw number one is readability number
two it's a powerful way of transforming
transforming your data in a functional
way third we can use functions as
generic building blocks that work with
different kinds of data because you're
never dealing with the data the data
always comes last and dependency
injection like with the fifi example I
pass in the fee as a dependency and and
I can use I can now use generic
functions on with the fee passed in all
right last last building block I promise
use composition this is no no this is
another way we can use functions as
first-class citizens so we saw in all
the previous examples however kind of
throwing functions around we're passing
them as parameters returning them as as
our return values so once we get used to
this idea of passing functions to other
functions we can start to discover ways
to combine two or more functions
together and this is what composition is
so start with an example this function
just takes an amount and it applies tax
and shipping and handling and it just
applies the tax and shipping and
handling and return to you the about
with composition I
break this up into apply tax and then
apply shipping and handling there are
two separate functions and I composed
them so I'm doing Graham DeLaet compose
and how compose works is it works
backwards from left to right so first
you'll apply tax the data I passed and
then I'll apply shipping and handling to
the data I passed in let's say later we
want to add a gratefulness surcharge
surcharge because I live in San
Francisco and people find reasons to tax
you on the most ridiculous things and
surcharge you on the most ridiculous
things like I got it cleanliness tax
once at a restaurant which was awesome
so let's say we have an apply tax and
shipping and handling and gratefulness
surcharge function so we might just add
our gratefulness surcharge and get back
that or if you were to use composition
we can create a simple apply great from
the surcharge function and just pop it
on to our compose stack like that and
then later let's say we don't want to
add this surcharge we can also create a
separate function that doesn't apply
that charge later we want to add a 5%
discount so we can either apply tax and
shipping and handling and gratefulness
surcharge and discount or you can use
composition and apply our discount and
pop it onto our compose stock I think
you're sure to get the point but in case
you don't let's say we want to also
format money I'm not even going to I'm
not even going to go into the regular
example I'm just going to go into the
composition example but you just create
a function that formats money and then
pop it onto a compose stock and we get
our formatted amount it's a Y
composition each function becomes useful
on its own we can easily create fresh
new functionality from existing
functions we can break apart pieces of
behavior and test them independently we
can test each of those functions
independently and easily because there's
so much more simpler and a decluttered
code so readability again
so going to our checklist does
composition ensure we don't affect or
meet a external state not really does it
ensure we don't rely on external state
not really does it ensure that we always
return the same corresponding output for
a given input not really does it ensure
that we're guaranteed to work that does
it is does it ensure that it's
guaranteed to work as intended by a
programmer not really so we saw that
like with first-class functions it's a
little bit weird they didn't really meet
any of our criteria for reasoning about
code necessarily so but they did give us
a lot of advantages right like when you
start to take advantage of advantage of
functions as first-class innocence it
encouraged us to use functions as the
primary unit of abstraction like small
independent composable functions become
the tool we used to model and solve any
problem and we saw all the benefits of
doing that so I'm gonna propose that we
add one last bullet to our list of what
it means to reason about code I'm going
to say encode is modular and generic it
enables us to read with a reason about
code better and that's what functions as
first-class citizens gives us it creates
modular and generic code so when you
have all these what you get is code
that's easier to understand the intent
of easier to reuse easier to maintain
easier to refactor easier to test and
easier to reason about so recap we
talked about test types immutable data
pure functions functions as first-class
entities and in and within that we
talked about how higher-order functions
over loops
parameterizing as much as you can
composition and partial application so
I'm not gonna leave without putting it
all together and in one of course so
here I'm gonna go back to our calculator
a function and use basically everything
I just talked about you don't have to go
to this extreme obviously I'm not saying
you have to adopt every one of these
things I'm just showing you what it
looks like if you want it to I'm
importing a list from immutable Jas and
map and pipe from lambda I'm using flow
as you can see so
have can't my PI defined as a number
then I'm creating a type of action and
this type of action is takes in a value
which is of type number and returns a
number and I'm creating a generic
calculus are including a calculate area
function that is of type action that
takes radius which is a number and
returns the area which is a number which
is what I define the action type to be
and then I have a generic do stuff on
list function that takes a list which is
of type list number which is a list of
numbers and it takes an action which is
a type action that I defined up there
and then it returns a list of numbers
I'm just mapping over that list and
performing the action on it and then I
have my radii which is an immutable list
and then I do stuff on the list I pass
in the radii and the calculate area
function and I get my list
I haven't mutated anything there's a
couple things I missed in here are
composition so I want to put that in
here too so I have another function
format which is also of type action
similar to our calculate area action it
takes a radius and it formats it so it
truncates all the decimals extra
decimals and I'm gonna pipe pipe is the
opposite of compose so it just does
right to left left to right so I'm gonna
first map over my array and calculate
the area then map over it and format it
and then what I end up getting is a
formatted list so everything you know so
I don't think we need to go to this
extreme of obviously using everything I
talked about I think the point of it is
you can kind of pick and choose and
JavaScript what you want to use like if
type errors are a huge thing in your
codebase maybe introduce static type
checking that might help or if you're
finding that it's really hard to
maintain large state may be using
immutable data might help likely Byron
said or if you're finding that you are
having a hard time testing functions
maybe think about using more pure
functions like figure out what your
problem is and solve for that you don't
need to use everything but what
amazing about JavaScript is we have all
these tools that we can use to write
better JavaScript so putting it all
together
javascript strives to be an incredibly
dynamic and flexible language this
sometimes puts the burden on a
programmer to consciously write good
code and it makes it easy for someone to
bash on javascript for dynamic typing
aggressive type coercion mutable data
structures and whatever you want to bash
on javascript for but just remember that
javascript wouldn't be where it is today
if it weren't this flexible and if it
weren't this dynamic it's incredible
flexibility and forgiving nature is
exactly what gets beginners in the door
and it enables it to be used for
everything that it is used for and we're
fortunate enough that there are tools
and methodologies that enable us to
write good JavaScript code so I call
this a win-win situation so let's go
write some code that's easy to reason
about</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>