<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Immutable User Interfaces | Coder Coacher - Coaching Coders</title><meta content="Immutable User Interfaces - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Immutable User Interfaces</b></h2><h5 class="post__date">2017-08-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rtcn9I9sB5M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today I want to talk about making great
apps both mobile apps and web apps some
of the problems that make that hard and
a few of the patterns and solutions that
I think can really help us not only do
that faster but actually make more
robust apps that use less complex code
and they're actually easier to
understand a little bit about me my name
is Lee Byron I work at Facebook on a
team called product infrastructure so
product infrastructure on this team we
build the technology and the tools that
all of our products use to be the best
that they can be and and part of that I
work on a lot of our open source
technologies so I'm a core contributor
to react I'm one of the co-creators of
graph QL and I'm the creator and
maintainer of immutable J's and I may
mention these tools and a couple others
just because they're relevant to how we
are doing this at Facebook but this talk
is not about any specific library or
framework it's not actually about any
specific platform or language either
what I want to talk about today is the
architecture underneath the apps that
we're all building what I'm going to
talk about applies just as much to an
iOS app as it does to a JavaScript app
and these ideas can actually be
implemented in a huge amount of ways so
I'm going to show you is kind of one way
to do this idea but there's a lot of
different forms that this can take in
order to do this I think it's really
important that we first get a shared
understanding of what it is we mean when
we talk about architecture when we're
talking about software architecture is a
metaphor and what we're actually doing
is we're borrowing from the idea of
building actual buildings and there are
some really clear parallels that we can
draw between these ideas our key texture
itself originates from studying one of
the most important technological
advances in building things and that's
the arch this very simple shape has
proved to be nearly infinitely
composable which allows us to build
larger and more complex buildings than
ever before
this is Vitruvius he was a Roman scholar
and architect and 2,000 years ago he
wrote about the principles for
satisfying good architecture fermitas
utilit oz and Venus das firma toss means
durability a building should be robust
and have longevity and when we build
apps we look for the architectural
choices that help us reduce bugs and
improve performance utility means
utility a building should be relevant to
how it's going to be used you know the
materials the technologies and the
aesthetics that you would choose to
build your home are going to be very
different from building an office
building or a place of worship or an
auditorium it's because each of these
places is used in a very different way
similarly the architectural choices that
we make for our apps can differ wildly
depending on the complication of the app
how it's going to be used if it's more
static or dynamic simple or complex or
if it's going to rely on more networked
or live data and Venus fast means beauty
building should be both usable and
desirable by using proportion repetition
and scale and you know obviously we want
our apps to be desirable and usable but
what I believe the parallel here is is
not a user experience but two developer
experience the architectural choices
that we make they impact not only how
easy or hard it's going to be for our
teams and ourselves to improve our apps
but to also iterate on those over time
so architecture is about making
fundamental structural choices about how
we're going to build things with the
qualities that Vitruvius set out for us
2,000 years ago in software architecture
we make these same fundamental
structural choices based on our
understanding of water app needs to do
in the challenge instead is going to
face we choose our few elements are
abstractions to create variation and
robustness
support the role of our app solve its
primary challenges and create a
productive space for ourselves and our
other developers and engineers and for
the information rich user facing apps
like the web and mobile apps that a lot
of us in the room have been building
there's been a really dominant
architecture over the last decade or
more and that's MVC and rest and for
these kinds of apps there's one single
biggest challenge that we need to solve
and it's this what changed how can I
tell when something has changed so that
my models my views and my servers stay
up to date with each other
I believe that NBC is really just left
us with a poor solution to this problem
because it attempts to solve this by
adding even more things that can change
you've got models sending change events
views that are easy to get out of sync
and race conditions when you're doing
multiple things interacting with the
server when models and views both need
to listen to each other for changes it's
easy for what seems like what would be a
small change to have these cascading
effects that create unpredictable
effects on your entire application and
there's also a second big challenge that
these information-rich app space and
that's synchronizing data with our
servers you know modern mobile networks
they're just they're just really crappy
okay first there's latency we can
measure latency often in large parts of
an entire second so minimizing requests
to our servers is actually really
critical for performance and then
there's intermittency so we often talk
about supporting offline mode but as we
all know no one goes offline instead
what happens is you know you go
underground on the metro or you're
driving in the car between cell towers
so we're actually talking about when we
say offline mode is intermittency mode
so handling these kinds of network
failures is really critical and well
rest us model our data in terms of the
network service it can really be
crippling to performance when our app
needs food lots of data that's dependent
unloading lots of other data so let's
take an example okay say we want to
build a social calendar app
we're going to need to get our friends
we're going to need to get you know
their names and their their profile
pictures their avatars we want to know
the next events that they're all
attending and the names and the details
of those events and so we're going to
have to load a lot of stuff from our
rest endpoint and since rusty pies
typically return URLs when one resource
references another resource then we're
going to end up loading lots of these
things dependent on others we're going
to have to wait for previous URLs to
load before we can even start loading
the other ones and that means that even
the new stuff that we're getting like
HTTP to pipelining it just really can't
help us solve this kind of problem and
when networking network latency on a
mobile connection is measured in big
chunks of a second this stuff adds up
really fast you're talking about four
even moderately complicated apps three
four five second slowdowns just on the
latency not to mention all the other
things that have to happen all over the
network so needing to deal with this
problem of handling both a flaky Network
and the slow Network it puts us in a
really sticky situation you know we
might want to show a loading indicator
if someone performs an action in our
apps but networks can be slow so you
know we might not want to have them sit
and stare at that loading indicator we
might just want to you know guess what
the server's going to do and show that
to them right away but you know networks
can be flaky so what if that doesn't
work are we going to roll it back
what happens if they've done multiple
actions at the same time we got to
figure out what order to do these things
in it's a really big mess and you know
not only is this challenging but it's
also unfortunately a very common
scenario that we need to solve in our
apps and so I actually think that
there's a really powerful technique that
we have to get a better control in these
problems and that's why tightly
controlling what can change in the first
place by embracing immutability what's
really exciting about this to me is that
immutability is not more complicated in
what we've already been doing it's
actually less complicated because we're
removing a feature removing the ability
to mutate data and when we give up the
ability to mutate data where you know
we're giving up some power we're giving
up the power and the abilities that come
with that power but in exchange for that
we get new
suppose and we have principles we have
new guarantees about what can and can't
happen in our programs and we can
leverage those principles as guarantees
to do performance optimizations and
other whole program optimizations to get
a better you know app speed overall and
I really think you know this is the crux
of what we do as software engineers it's
all about balancing between power and
principles to get the power that we need
to build the apps that we need to do but
also get the principles that we need in
order to build the best things and if we
only cared about having our software
have the most power possible then we
would have stopped it assembly or go-to
right like all languages are Turing
complete so you know we really have the
same power everywhere and go choose are
incredibly powerful you can do a lot
with them but instead we're always
looking for more principled ways to
apply the power that we already have you
know so of course most modern languages
all modern languages have forgotten
go-to in favor of for loops and you know
you can't do everything with a for loop
that you can do with go-to but the
principles and the constraints that it
provides let you guarantee some things
about what can it can't happen in your
app and many of the you know more modern
languages even forego for loops in favor
of map filter reduce and other
higher-order functions that happen on on
things that you can loop over so it's
really not the power of your software
it's about the principles that you can
leverage and immutable data brings with
it these principles this guarantee about
what can change and when so we can use
techniques that previously we couldn't
rely upon like memoization and time
travel talk about those a little bit
later so you know I'm done with MVC and
rest I really think it's time to rethink
the core architecture for how we build
all the stuff that we build all the time
and as I've been observing the apps both
that we're building at Facebook and that
I'm seeing built by the broader
development community I'm seeing a new
kind of app architecture emerge to
better solve these problems that I like
to call the immutable app architecture
and it's heavily inspired by similar
architectures that we've seen and made
functional reactive programming
environments which has been the result
of many years of research so of course
these aren't all my ideas at all and
it's actually heavily inspired by the
program language Elm which we'll hear
about right after me when Jack presents
so a mutable of UI doesn't mean that our
screen is frozen you can't do anything
with it you know it's not like we're
going back to 1998 web pages instead
what it means is that we're just going
to embrace the principle of immutability
at each point in the architecture of our
application that means that we're going
to be able to control exactly where
changes occurred and then we're going to
leverage that in order to apply some
techniques like memoization and time
travel to build faster more robust that
so let's start with first principles
views every platform that we care about
building apps for already has a concept
of a view the web has Dom elements iOS
apps have UI views Android has Android
dot view but all of these have a similar
API that helps you build this view tree
right we want to use these because they
expose the native user interface on each
platform but these api is they're not
great you know you create elements you
alter their properties you add them to
parent elements all of these are muted
of operations we're talking about
immutability so you know and after this
you got to keep track of all these
references and you do things like
looking stuff up by ID and keeping
things around and as you know members
and your classes it's really hard to do
this there's just a lot of stuff that
you got to keep track of so what we
really want is an abstraction on top of
views that lets us declare what views
should be displayed at any point in time
and we call these components and a
component it just defines this pure
function kind of the state of things the
state of the world goes in and what you
want to see on the screen comes out and
what a good component library should do
for you is provide this pure functional
developer API but under the hood
actually do all the hard work of
managing this you know mutable view API
that all of the platforms that we care
about actually expose and it needs to do
that in a way that leverages all the
performance tech
so we can get when we apply this limited
power in favor of the principle of
having this one function to define
things so let's take a closer look at
this just an example in my example going
to call this my view and it's going to
have some data okay and when we render
this component we're actually going to
get back our virtual views so virtual
views are a representation of what we
ultimately want to see right they have
the same structure elements property's
children but they're really just
in-memory objects they're not on the
screen yet and what that lets us do is
the first time we render these
components and get these views our
component library can take the virtual
views and then create the actual
underlying native views on whatever
platform it is that we care about and
when a component function is called a
second time you know we provide some new
data then we're going to get a new set
of virtual views that's the output of
calling that you know rendering function
a second time and so what a component
library is going to do is compare
virtual views from what it was
previously called to now and it was just
called and it's going to compute a diff
and then computing a diff what we're
going to get is a translation into the
set of mutable operations that we need
to perform on the underlying native UI
in order to get the views into the state
that we want them to be in so good
component libraries can do this very
very efficiently running really
complicated apps at 60 frames per second
even on some mediocre mobile devices so
components are really important aspects
of this architecture and of course react
is an excellent library that implements
this concept react lets you write pure
JavaScript functions and then manages
the mutable Dom elements on the webpage
underneath for you and if you're
building native apps you've got options
so there's react native react native
lets you write these component functions
actually using the same reacting API in
JavaScript it actually will bridge down
to the native UI UI framework so it'll
use UI kit on iOS he'll use Android
views on Android it'll even use Windows
UI views if you're you're building for
Windows but then there's also component
kit so component kit is this exact same
idea but it's entirely implemented in
objective-c so if you're building iOS
apps and you don't really want to deal
with JavaScript
that's fine too you can dive in here you
can write pure functions and objective
C++ and it's going to manage the
underlying UI views for you and by the
way if you've ever used Facebook
hopefully you've used it once or twice
and you've used the news feed on an iOS
app you've used component kit in action
that's how all of our news feed product
is built so these component functions
they need some data as input and that's
where models are going to come in but
you know these are not the models that
you may have seen in your favorite data
management libraries before these are
immutable models which means they're
just pure data they're very simple
accessors only no setters no events
nothing like that and I really recommend
you know building these with you know in
JavaScript just plain old object or
whatever the equivalent of your plain
old you know pojos and Java or you can
use persistent mutable data structures
if you need to do something more
complicated like the ones that immutable
J's provides and I'll talk a little bit
about that in a moment and then of
course you need to get those models from
our server but I want to first take a
closer look at these models and
components together so these two
concepts are actually really tightly
linked they're couples when a component
wants to render something new right
you're building your app you're adding a
new feature then you want to make sure
that the corresponding model also is
knowledgeable about whatever data you
need for that new feature that means
that the server is also going to need
send that new data as well right so
we're going to add something to render
function we got to make sure that it's
represented in our models as well and
since one model can appear in multiple
views and it's easy for these to end up
in kind of different parts of your
codebase it's really accidentally
possible to kind of do something in your
view and forget to put it in your model
and then you got broken UI or what I
found is actually more common is that
you're refactoring and you're kind of
deleting some experiments that didn't
work or something like that and you
forget to remove it from your model and
now you have over fetching so if each
component describes not just a function
that you need to take the state of the
world and give you your views but also
all the things that it will need from
the model then you have both of these
things within the same place that define
both what data you need
how to render that data onto the screen
because they're described right next to
each other you know it's really easy to
avoid these problems of over fetching
under fetching broken UI and we call
this co-located data dependencies and at
Facebook we do this using a tool called
graph QL which if you're here for the
back end you might have already heard a
little bit about but if you haven't
graph 2 L is an API query language that
we've developed at Facebook for as a
replacement for rest and it powers all
of our mobile apps at Facebook and if
you haven't seen graphical I'll just
give you a brief overview of what it
feels like to use graph QL so this is
kind of the hello world of graphical
queries I just want to get my name and
the first thing you'll notice is that
this looks a little bit like JSON
they've got these curly braces they look
a little bit like objects we've got
these things here that looked a little
bit like object keys we call those
fields and if we send this query to our
graphical server it's going to resolve
and come back as a JSON body and one
thing you'll probably notice here is
that this JSON body and the query have
very similar structure and this is an
important part it will makes craft UL
easy to learn and use and it also
provides some some principles that lets
us do some really interesting
optimizations with graphical and
sophisticated systems we can also
request fields of complicated data so
here there's a profile picture and
avatar and it's got you know not just a
URL to go load but also the width and
height so we can make sure you know we
get the right region of the screen
before that URL comes back and I bet you
can already guess what this looks like
if we run this right it's going to look
exactly like the query but more
importantly graph shows design not just
to query stuff about one resource it's
designed to smoothly navigate between
resources in a single query so for
example I can get not just my name but
the names of all of my friends and do
that in a single query and notice that
here's where a REST API would have given
us a list of URLs to go load a second
time or maybe you know you've got a
sophisticated rest library that lets you
pass some additional fields that you
want to do and and you know get these
names instead of the URLs but it's a
little bit harder to do that at multiple
levels down and graph kill makes that
really easy
so remember example from before where
we're making
social calendar well this is all the
data that we need to render that social
calendar we've got our name we've got
our friends we got our events right and
we can do that in a single round-trip
huge difference dramatically improving
our network performance and in order to
match how developers how they think
about views and to allow proportions of
queries to be recycled graph scale has
this language feature called fragments
and what fragments let us do is describe
co-located data dependencies right next
to our components so here we have a
component that describes both the data
that we need and the rendering function
to do a profile picture on Facebook so
we need a profile picture of a user we
need a width height and URI and then
we're going to render an image tag and
what we can do is we can use that
component within another component so
here we're rendering you know maybe a
row and a list of users we want to know
the name of the user we want to know if
they're friends with them not so we can
render this button and then we want to
render this profile pic so of course
we're going to need the name and the are
you friends but for profile pic it's a
little bit cumbersome to repeat that
data so instead what we do is we just
reference this other fragment and then
we get all the data that we need no more
no less and queries fragments they let
us define not just the requirements next
to one component and compose them one
time but they compose all the way for
your entire apps you can have a really
complicated application which tons of
nested views and then you can describe
all those things and roll them up into a
single query that we can run in one
round-trip to the network and get all
the data exactly as you need it no more
no less to render your app which is huge
for network performance also for
understandability ok so what we have so
far is great for like a read-only app
like maybe a news reader or something
like that but what about apps where we
have actions we have stuff where user is
going to interact with our views we need
to perform actions we have these models
that are immutable so we're going to
need one place where we can apply those
changes we're going to call that state
it's really just like a bucket where we
can hold on to all of our models so we
also have the initial query to our
server that's
they give us kind of our initial state
and of course we want state to also be
immutable so we can't change that thing
so what exactly is happening here well
let's look at an action an action is
just a function it takes the old state
of the world in and it returns the new
state of the world so you might write an
action that takes in the old state of
the world and then make some changes to
some models applies to every change you
want and returns a new version of the
state with that change applied and once
this action returns a new state with
some new models then we can provide
those to your components which are going
to go back to your views which they're
going to update the underlying native
views those then you can act on and we
can then get back to our state again so
it's a loop and so you might be thinking
okay that's fine but like these
functions that change your whole state
you're going to do that for every time
user does anything that's going to be
really slow right well actually not
really and not really because we can
leverage the principle of the mutability
to do this really cool thing called
structural sharing so what structural
sharing lets us do is take a previous
version of some immutable thing and some
change we want to apply and then recycle
as much of the old version that thing is
possible literally all the underlying
memory we want to recycle as we can so
what we can do this for playing objects
but this actually enables an entire
class of really interesting data
structures called persistent immutable
data structures I'll just illustrate a
little bit how this is going to work and
by the way if this is interesting to you
and you're a JavaScript person you can
check out immutable GS which is just an
implementation of these data structures
so let's take a look at this example
here this is some structure of data and
we want to make this change so in order
to make this change and we can't do it
in place we kind of have to copy this
node with a change applied and it can
reference other nodes that's fine but
anything that points to it also needs to
change in order to have that new pointer
again no mutation so we copy that thing
and we do that all the way until we get
to kind of the top of our data structure
and once we do that then we have a
completely new structure with our change
applied and importantly we've recycled a
lot of it you know this is super
contrived I just got it to fit on the
screen but still recycles more than 50%
of what's happening here and in practice
it's more
in the 90 plus percentile most
importantly we haven't changed anything
about the existing data structure we can
use this continuously that's totally
fine we can actually use both of these
at the same time if we want to that will
continue to work and as soon as we don't
want the old one anymore we can just let
go of it and the garbage collector will
handle that for us and any modern
JavaScript VM or Java VM or anything
like that with a good garbage collector
this stuff is super performant it's not
going to be a problem and so by doing
this we can really leverage immutability
while still having very good performance
for CPU and memory and a prime example
the kinds of things that we can do when
we have this is memoization so
memoization is when you take a function
and you know if you call a second time
with the same arguments you want to kind
of skip running the function and we just
return whatever it returned last time so
this is a cool performance technique
that you can do for expensive functions
like rendering a UI and so I would just
want to show like a really basic example
this is going to be the sum function so
we're going to take a list of numbers
we're going to add them all up and I
know I'm going to give this like a
really big list of numbers so I want to
memorize it so I'm going to give a list
from one to a million and then I'm going
to add them all up and then I'm going to
push on to that array and then you know
call this again so this is what I want
to see right so I went looking for this
function I literally went on Stack
Overflow and it's like Java Script to
memorize it was like here's the most
upgraded version of memo wise I
simplified it a little bit just to get
it to fit on the screen but this is
largely it and I don't know if you guys
see the problem with this but it's this
json stringify of course we're doing
memoization to get better performance
but json stringify is really expensive
especially if the input is big which is
exactly why we're doing this and so as
you might expect running the memorized
version of this is actually much slower
than running the not memorized version
totally not we want what we won't have
see happen so I rewrote the function and
instead of using json stringify i just
want to see if these two things are
equal that's all so I did that so I ran
it and at first it looked really good
right I call it a second time and it
looked like it was basically free and
then I pushed my next number and I
called this again but this time it
didn't do what I expected it looks like
it memorized and it didn't return the
right answer
of course this is why an array is
mutable when you push into it you don't
change the identity of that array it's
still equal to itself so this check
passes and got it now I understand why
json stringify was there but let's try
that same thing and use a mutable list
from a mutable j/s so same exact
implementation of memo wise I haven't
changed anything I've just replaced
arrays with lists immutable lists so so
far so good this basically works the
same and if you're paying really close
attention you might notice that calling
some on the list rather than array is a
little bit slower that's to be expected
immutable data structures are a little
bit slower than their mutable cousins
and but what we want to do is reap that
performance benefit back by applying
these global optimizations and now I'm
going to push into it what will happen
with the immutable data structure is
when you push into it rather than
changing that thing it's going to return
a new version of itself so we're gonna
make sure that we keep track of that and
then we get the answer that we want this
is great so back to our diagram we're
still really we're missing a big
important piece and that's how our
actions are going to communicate with
our server doing that synchronization so
let's go back and look at what an action
is an action is this function that takes
the old world and returns the new world
right but if we're going to go to our
servers this isn't going to cut it we
need we need a synchronicity we need to
be able to wait for the server to get
back to us so what we really want is
like a promise or a you know a task that
will eventually give us back our new
state but like we talked about this
could be slow we don't want to be slow
we want to show people updated UI as
quickly as possible and you know even on
a really fast network connection even if
you're on a desktop computer and you've
got like a hard line people are really
good at noticing delays like we noticed
delays and hundredths of a second so
even on a faster connection it's too
noticeable but of course on a more
typical slow mobile connection it's
going to be just really painful
so here's accident we want to do we want
to return immediately our guess at what
we think the new version of the state is
going to be which we can do locally but
we also want to return a promise for
the real version of the new version of
the world that the server is going to
help us fulfill and that brings me to
one last problem and that's what do we
do and there's multiple actions
happening at the same time and for this
we need a cue so this is the last
important part of this architecture and
it's going to make sure that things
happen in the right order and we don't
get race conditions so a cue what it's
going to do is going to keep track of
the most recent version of the true
state what our server thinks is true and
then it's going to keep a list of the
options or the actions that are
currently in flight so say a new action
comes in what we're going to do is
immediately compute what we think the
state is going to be we called our
optimistic state and then we send this
to the server and if the new action
comes in that's fine we just add to the
queue and we compute a new optimistic
state and then when the first one is
done that's great we can just remove it
from the queue we're going to get a new
version of our true state from our
server from having done that and we'll
just recompute the optimistic state if
there's anything less than our actions
queue and then when that second one
comes back then we're dealing with true
data again nothing needs to apply we
just have true state option six-days
same thing so this is really interesting
because it lets us model apps that let
us first create a thing you know like a
to-do item wouldn't be complete without
like a to-do app example here and then
let's just kind of make changes to that
thing even before the server knows that
it exists and this is usually something
that's hard to do so first we're going
to create it to do and then we're going
to you know change some stuff about that
and at this point we don't really know
how to tell the server hey set the due
date of this to-do item that we don't
know anything about yet so we got to
wait for the server to come back and say
well here's the unique ID for that to do
and then we can replay that action to
get a new optimistic State and once that
has been done then we can actually have
the information we need to go to the
server and give it the right info to do
that thing and then we have the state of
the world that we want so this kind of
behavior it's typically really hard to
do in traditional apps you may have
bumped into this before I do kind of all
the time and it's really hard to do
without creating race conditions and so
this technique lets us avoid the
majority of the race conditions that we
end up running into
alright let's take one last look at this
whole architecture our components
describe the data that they need which
informs the shape of our plain old
objects and beautiful models which are
first created as the result of a
structured query that we send to our
servers which creates our apps initial
state from there these models are
provided to our components function
which is going to describe our views
which is then actually created in the
underlying UI view framework and then
we're going to interact with those views
which is going to create actions those
actions are going to optimistically
update our states but they're also going
to be ABS that queue and asynchronously
sent to the server to let them know
about that change and when the server
responds that we're going to get the
action removed from the queue applied to
get an update version of the state which
is going to contain new models we're
going to provide that again to our
component rendering function which is
going to describe new views which will
then take the underlying native views
and update them as efficiently as
possible
and then we're going to repeat that
forever and ever and ever and ever until
the user leaves your app you know kind
of depending on how good your growth
team is so this I think makes some
dramatic progress on solving the
challenges that we have in modern apps
that we're building today
it lets us keep track of what's changed
keeping our UI up-to-date synchronizing
with the server that more and more
recently is at the end of a slow spotty
network connection and we can do all
this precisely because everything is
immutable it's part of our codebase any
part of our codebase could edit our
models or views at any point in time
which is super common in MVC frameworks
then we couldn't use any of these
techniques anymore we would have given
up principles and say her power
we couldn't apply actions in order we
couldn't easily rollback State we
couldn't do these optimized view
recycling techniques and we couldn't do
all this on multi-threaded platforms
like iOS and Android where a mutation
makes jumping between threads very
difficult and also this architecture
it's simpler than MVC in rest because
there's no direct mutation so I know
I've covered a lot of pieces here and it
feels complicated and of course
component libraries are very
sophisticated and they can be that way
because they're leveraging the simple
principle
pure functions immutability and
composition and what makes me really
excited about this is that this powers a
lot of our apps at Facebook where most
of our mobile apps actually follow this
pattern I mentioned earlier that if you
use newsfeed you're using some of the
stuff a newsfeed is actually one of the
inspirations for putting this talk
together so I really think that
traditional NBC and languages that have
mutation by default are going to slowly
be added to the pile of old ideas but
I'll leave you with this NVC unrest they
did not solve all the problems that we
face in app development but what I
presented today also won't write these
ideas are going to be far from flawless
and they might not be right for the app
that you're building I want all of us to
continue to challenge the notion that
there's like one right way to do things
that's not true and also just recognize
how quickly and continuously our ideas
about what good architecture is and good
tech not technology ideas are you know
just every time I finish building
something I just have this urge to go
back to the beginning and start over
because of course by the very nature of
having built it I've seen all the things
that went wrong and I want to do it
again with all the ideas that I have to
make it better but of course if I did
that as soon as I was done I'd want to
do it again because I would have seen
even more ways to do it better and so
for justice reason I think it's you know
the process of this architectural
improvement it's just never-ending it'll
never end and we're never going to end
up at like in architecture nirvana
where we have all the answers it's just
not going to happen it's an important
realization and what fuels me is this
process of exploration and trying new
things it's the process of improvement
that's exciting
rather than some mythical you know
destination of perfection in our apps so
I hope that you found this these ideas
as mutable app architecture interesting
hopefully they're useful for some of the
things that you're building today but
more importantly I hope that it inspires
you to continue to improve on these
ideas so we can all build even better
apps tomorrow so thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>