<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Why WebAssembly Is A Game Changer For The Web | Coder Coacher - Coaching Coders</title><meta content="Why WebAssembly Is A Game Changer For The Web - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Why WebAssembly Is A Game Changer For The Web</b></h2><h5 class="post__date">2017-12-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_5IjJi74KFA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning and welcome how many people
have done anything with webassembly or
looked into it at all no this is new
it's it's early days for the technology
I started talking about it earlier this
year and I was a bit concerned that it
might still be a little bit too early
but there's been a lot of activity in
the last six months since the the
browser's entered their their preview
mode in February and so it's a it's a
very exciting time now the problem is
there still isn't a lot of that learnt a
lot of tutorials out there there's not a
lot it's easy for people to get exposed
to in the first time so my goal today is
really just to get you excited about
what's coming and to make you interested
in looking further into it and to point
you in the right direction I'll make
sure that the conference organizers get
the slides because there's a lot of
links to places for you to look and
things to play around with but mostly I
just want you to kind of get a sense of
what's coming and why this is this is
gonna be interesting
so we'll start with an introduction to
the problem we'll look at sort of a
stepping stone towards getting there
called in script n' we'll look at where
sort of web assembly is now and kind of
how the fundamentals work and then take
a look at what's coming next in terms of
the future this is a very demo driven
talk so I'm hoping the network holds up
apologize if it does not so here's a
question I'm almost afraid to get the
answer to how many people remember life
before the web okay I don't feel too old
that's enough of you rose
raise your hands that you're you're with
me on this one I was exposed to mosaic
the week that it came out and it just
blew my mind right I had been an Archie
user an FTP user gopher user and a
friend of mine showed me mosaic and I
really understood the impact but at the
same time I didn't necessarily connect
in my head the hypermedia information
spaces of the web to what I was doing in
school and the work that I started
getting into when I first graduated
which was C X and motif and then very
quickly C++
and OpenGL I worked on the world's first
whole earth visualization environment so
I think Google Earth but 23 years ago
and I was I've always been an advocate
of the way I spend a lot of time talking
about rest and hypermedia and Link data
and Semantic Web and stuff like that but
it wasn't until along the way that I
started to think about web development
and software development in the same
sense right though the web was about Ted
Nelson and Tim berners-lee and Paul LA
and Vannevar Bush and people like that
and then the software development was
more about new than McCarthy and
Kernighan and Ritchie and right just the
world didn't collide in my head and
certainly the the development experience
was was nothing alike right initially it
was just hand editing HTML files then we
got a little bit better about generating
them along the way Netscape was
introduced and there's this weird thing
called JavaScript that emerged and for a
while you were actually considered a
more serious programmer if you didn't
know JavaScript right because it was
just a toy it was a toy for popping up
menus they stole the name Java to be
cool
and it just was something that I just
didn't spend a lot of time looking at
because I was off doing serious software
development things and then somewhere
along the way things changed right we
started to see the performance
improvements in the toy technology
called JavaScript running in the browser
and again I was even attuned to what was
going on I was attached to what became I
believe one of the first if not the
first books on Ajax and then ultimately
decided it and I didn't want to spend my
time on that because it didn't didn't
seem like everything was ready yet to me
obviously I was wrong on that and so as
we started to see the performance
improvements in the browser people
started doing more and more interesting
things with them and then that sort of
translated into the development of node
and doing more interesting things with
JavaScript on the server as well and so
suddenly the world of what's happening
in the browser started to feel more like
software development and less like just
the the hyper hyperspace hyper media
world of the web and it was in this
space then we started to see the
emergence of new api's and html5 came
out that standardized how audio and
video were handled and whatnot and we
saw the emergence of web RTC as an
in-browser non plug-in technology with
JavaScript API s for manipulating the
connection to peers across the world
across networks doing net translation as
needed with the peer channel discovery
mechanism the data channel mechanism and
it was all being done within the browser
without barriers to what was happening
in the browser it's not a plug-in right
with flash and Java applets and things
like that there are memory barriers
whereas here we can start to apply CSS
filters directly to the video that's
coming in off the stream and it was this
marriage of the capabilities of html5
with the JavaScript API is from WebRTC
with the evolution of the support of
css3 and and the things like that and we
can now combine CSS in canvas and video
all in one thing so we're starting to
see this emerge as as a rich platform at
the same time we see the emergence of
WebGL as a way of having hardware
accelerated 3d graphics in the browser
also without the need for plugins and
whatnot well this is this game called
cube slam as a WebGL based game that
uses WebRTC if you wanted to play a
friend you could generate a link send
them the link it'll do the network peer
discovery and the network address
translation and you can end up playing
them and it uses the WebRTC data channel
to send movements and updates in the
game back and forth then this is
obviously being done within a browser
with with hardware acceleration of the
3d graphics so our platform is evolving
into
these incredible capabilities and really
exciting things are coming out of them
we see the emergence of web torrent as a
torrent capability being built on the
back of WebRTC and if you haven't seen
this I absolutely encourage you to look
at it within seconds I will be streaming
high-definition video from people all
over the world and then showing it here
in the browser and so we now have the
ability to find and discover peers and
share large amounts of information in
real time and this is all fantastic the
problem is we have to wait for the
browser's to add support for these
low-level things things like the network
discovery the network jitter management
the bandwidth usage handling the HD
displays and the video streams that are
coming out of them and doing some of
these transformations these are all
low-level things that we would want to
be able to be very performant and high
you know high performance we're not
going to do that kind of stuff in
JavaScript but the JavaScript API is
that the browser's end up supporting
take advantage of capabilities that the
browser's have built-in at the low-level
C C++ library level and so we're kind of
at this point where we were happy with
where the platform is but the delay to
get the browser vendors to agree upon
things and then support those standards
with you know polyfills and stuff like
that in you know along the way that
takes time and it takes heart time to
innovate and so web assembly is emerging
as a way of solving some of these
problems allowing us to do low-level
coding stuff and yet still have it be
accessible within our JavaScript
environment now Google started something
like this called pinochle and they have
basically since abandon that because it
did not have the same at the right
characteristics in terms of
interoperability with the JavaScript in
terms of being crossed across a browser
and Mozilla had a project called asm.js
to show how we could have some of the
same native kinds of performance and
still maintain JavaScript
interoperability
and that basically sort of fueled the
thinking that eventually became what we
have we've come to know as webassembly
but on its face right this definition of
webassembly
as being a new portable size and load
time efficient format suitable for
compilation to the web that doesn't
sound very exciting right
that doesn't seem like some kind of
next-generation thing that you know you
got up early to come to the first talk
today to see so let me take you through
exactly what this is going to mean
number one this is not web assembly this
is using SAS mm dutchess in its initial
form but just to give you a first step
in I'm going to run a QT application
directly within my browser so if you're
familiar with the QT cross-platform user
interface toolkit right this is a QT
application and it's running in the
browser that's kind of cool right I can
take it a step further and here's an
animated tiles demo so it's downloading
JavaScript and the engines that are
emulating the low-level code but the
performance is pretty amazing given the
fact that we're sort of emulating an
environment that the QT platform can run
it now as I said that was not
webassembly that was ASM dutchess so
let's look at web assembly and you have
to forgive me here I'm terrible at this
game but this is a Unity engine based
game that's now being run in the browser
without a plug in everything that it
needs to download and to run it does so
it downloads what it needs through web
assembly modules so here we see
I win when nobody else is playing okay
that's kind of cute well how about this
as another WebGL webassembly interaction
using unity running in the browser no
plugin I am equally as bad at this game
but just think about that for a second
think about what is possible now that
we're able to do these sorts of things
within the browser without having
plugins by using low-level languages
like C C++ and being able to run these
applications in there we see where we're
going even further I mean the network
works here well should do okay using
this one final platformer game it is
worth it so give me a second just to let
it download notice is just downloading
javascript in elements and it's
compiling it down into a format that it
can be used and now we have the capacity
to do triple a kinds of games in the
browser the web becomes a platform for
deploying desktop native kinds of
applications and doing so in a way that
does not require us to have to care
about distinctions between Linux and
windows in OS 10 or Mac OS right because
the libraries are compiled into an
intermediate representation that is JIT
'add sorry I have to hit that a couple
times to break out of the out of the van
but I can jump up and slide down anyway
you get the idea this is this is a
triple a quality game that is now being
available in the browser but I don't
have to worry about waiting for browsers
to support particularly low level kinds
of capabilities I don't have to worry
about
downloading the right library because
the intermediate representation will be
cheated into native format as needed at
by by the underlying engine now before
we had the support in the browsers we
would have we had this M scripting and a
SMAS as a step in this direction and in
script n' as a technology allows us to
compile C and C++ into JavaScript by a
way of LLVM bit code so if you're not
familiar LOL is a is a back-end that a
lot of languages have started omitting
the intermediate representation for and
a lot of the optimizations that go into
the the back-end research are applicable
to the various languages then that omit
to the LLB M IR code so we don't have to
have parsers and optimizers for every
single language we have something that
will do the parsing omit the bit code
and then we can take advantage of
optimizations in a platform a specific
way so the idea is to take C and C++
which already were supported with LLVM
parsers and then convert the generated
bit code into JavaScript and the idea
here is that the the semantics of
translating bytecode into bytecode or
bit code into into sort of bytecode is a
lot easier and faster than trying to map
one language to another and the
semantics of one language and what's
possible in one language into JavaScript
and then the idea is once you have sort
of like c and c++ based scripting
engines like Python like lua then those
languages can run on top of this
JavaScript back-end - once they have
been ported into this platform now why
are we doing this is because the
JavaScript engines are getting faster
and faster and faster and this is where
a lot of the momentum is in terms of
optimization the JVM has a lot of many
years of optimization in it but I would
say more effort is now being put into
making v8 and the various other engines
faster we also have a lot of people who
still have a lot of familiar
charity and experience and whatnot with
non JavaScript languages and the tooling
and the build systems and everything
that goes into that so we want to be
able to capture that and JavaScript all
kind of sucks
right I mean there's a lot of good
things in it but in terms of you know as
its maturing its we have all these sort
of like weird States and plugins and
transpilers and some support for the new
module system and it's just it's still
kind of a mess and people would like to
be able to use different kinds of
languages on the web so the idea is we
if we can compile these other languages
C and C++ are the starting points but
there are already rust converters to
generate this in the backend people are
looking at doing similar sorts of things
with go right now web assembly does not
support garbage collection but in future
versions it could and that would open it
up to other types of languages that
could be generated and supported on the
platform I'm not going to follow this
link but there are hundreds and does you
know hundreds of other kinds of some
language to JavaScript tools out there
but they're all sort of like hand
optimizing hand converting hand mapping
and it's amazing that they work as well
as they do this is just an attempt to
get some more consistent coherent
momentum behind bringing other languages
to the web as as sort of first-class
citizens
excuse me so in scriptum as a tool chain
was designed to make it easy to do these
kinds of conversions and to be able to
bring these native languages to the
platform that runs on anything from PCs
to Linux to Mac os10 to iPads and
iPhones and things like that and so C++
developers don't have to learn
JavaScript tools and tool chains and
things like that don't necessarily have
to be overly modified and we don't have
to take these pre-existing libraries and
make them available for different
platforms when they can just be compiled
down so as a very simple example right
we have main that it calls the standard
i/o function printf and then returns
there's nothing weird about this there's
no weird annotations no weird pragmas or
anything but you just take the EMC the
inscript
compiler compiled it it will generate
some truly god-awful JavaScript don't
look at this late at night you'll have
nightmares but what comes out can be run
as a node application it can be run in a
browser and I'm sorry I you can't read
this but it says hello world it's within
the the browser environment it's it's
executing the same framework and
producing the same results and it's not
just for toys right we have support for
things like lib STL and WebGL and other
kinds of libraries that are available to
be used within this platform as well so
I'm scripting was a step along the way
and they added support for generating
web assembly back-end directly not just
they asked Asma s output and so we'll
see an example of that in just a minute
but web assembly itself was designed to
be a stack machine it's designed to have
a size and load time efficient binary
format the binary format makes it easier
to parse it makes it easier to send
across the network because it takes up
less space and then the idea is with the
just-in-time compilers and the the
native interpretation being already well
handled on the individual platforms for
v8 and and whatnot well we will achieve
near native execution when the code is
running so it's a little bit like the
difference between sort of hand
optimized C++ versus JIT add java it can
it could take a look at how that systems
actually running and make optimization
choices based on that now if you've been
paying attention in the news at all in
the last couple of years the idea of
running native code and the browser
should scare the crap out of you right
but it doesn't actually have that kind
of potential because we're moving away
from having direct pointer support we
have chunks of memory pages of memory
that are then interpreted as pointer
references and whatnot but we don't have
the same pointer kinds of capabilities
expressed expressible in in the
intermediate results and so it's
actually it'll need to go through
further security investigation
but it is already a fairly secure
environment
now the idea is that this can run within
browsers and when it does it'll enforce
same-origin policies for the web
assembly modules like anything else but
we also have the ability to run it
outside of the web browsers as sort of a
native standalone application that can
be used in embedded system kinds of
scenarios as well what we want is we
want to be able to have good developer
development tools so there's an
intermediate format a textual format
based on s expressions of the ast es so
we'll see some examples of that in just
a minute the idea here is we want that
to be easy to read these textual formats
that will assist in debugging and being
able to help developers understand
what's going on as this code is passed
around but also allow them to do further
optimizations based on on these
structures as well
but one of the things that cannot be
underscored enough is that this is also
attempting to be part of the web and the
web has certain characteristics and we
do not want to throw those
characteristics away just to achieve
some kind of optimized form the web
supports version 'less interactions it
supports you know this idea of backwards
compatibility and evolve ability such
that people don't have to be locked in
to this version of this library running
on this version of the OS in this
version of the browser right we want
things to be more flexible and and and
change friendly and so a web assembly
was designed to be part of that so the
main concept is that we have these
modules of code expressed in ways that
can be exposed functionality currently
you can only interact from these
languages with JavaScript itself or the
other way you can call from JavaScript
back into these native methods but in
subsequent versions as they said there's
there's a goal to have garbage
collection as a goal to have the ability
for these other languages to manipulate
the Dom directly and so there's some
really exciting things that are coming
but they tried to not be overly
ambitious and then
produce nothing so the MVP the Minimum
Viable Product has some fairly serious
limitations but it's also an attempt to
give people enough of a platform to play
around with such that they know what
what some of the optimizations and
hurdles that they may face as they move
into what they're now called the Bret
the browser sort of preview mode right
where all the browser's are supporting
it in some version and they want to see
what people do with it they want to see
what problems they come up with and then
they're there reforming a new w3c
working group to extend the standards in
new directions based on what they find
all right so the binary format if you
just look at gzipping source code right
that works pretty well and so there are
some people who advocated the very
simple approach for doing that and if
you just take the asm.js code in gzip
but you could get some pretty good size
reductions but we also in putting it in
this binary format also got the same
size reductions and then had the ability
to be able to look up index binary names
rather than parsing strings in the
structures huge performance improvements
came from that but by taking this of
this approach this layered approach they
have the opportunity for taking further
advantage of advancements in structural
optimizations over time so the first
step and layer 0 is to have a simple
binary representation of the modules so
that it's easy to parse easy to send
across the network and already we have
some reductions there the layer one will
allow local optimizations to take
advantage of structural relationships in
the code you know finding dead code
trees and and things like that down the
road and then at the end of the day they
can put a high-level compression layer
on top of it just to compress whatever
is there they just compressed it in the
first place then they would lose the
capacity to do a lot of these other sort
of optimizations and so that's the
thinking behind that part of it the
textual format as I said is a series of
s expressions so the most
s expression that's valid is just empty
module functions this would get
translated into the wasm equivalent of
the magic numbers in the version numbers
but nothing else is really going on here
so there's not a whole lots to do there
in general the structure of the module
is going to have a series of function
definitions with signatures that have
some local variables and then a series
of instructions in the body so we will
see some example a simple example of
this in just a moment the arguments that
are being passed in can be parameters of
at this point only instant floats
32-bit and 64-bit instant floats and
they can only return a single value so a
lot of these again are going to be
modified in subsequent versions they
just didn't want to have to get into
supporting funky esoteric structures and
what like what not in the minimum viable
product so because they come in in this
order you can ask for the local local
values through positions or you can give
the parameters and local variables names
and then refer to them for their names
now again keep in mind this is not how
you're necessarily going to be
programming there's nothing stopping you
from programming it and at this level
what you're going to instead probably be
writing C C++ rust something like that
and this is what gets emitted and then
this is what gets converted into the
binary format and then optimized and
jetted locally when it's running within
the browser this is sort of the
intermediate textual representation so
here we see a fully functional version
of a module we give it a name called add
takes two parameters and then it has a
single result as a stack machine the the
operations are intended to manipulate
the stack in in meaningful ways so the
first get local will pull the value from
the LHS / am and then push it to the
stack the second local will get the RHS
parameter the stack and then the i30 to
add instruction pop off to
integers from the stack and then push
the response to the stack and then the
value that remains on the stack is what
will come back through the return value
so this is generally how how this is
going to work and then we export the add
function from the module so it's now
going to be visible to anybody who
parses the structure of the module
now the JavaScript to do that is going
to look something like this
so this fetch and instantiate is a
helper function that comes with library
called Wazza moodle's Jas but you can
see that it looks just like the same
kind of normal promise based stuff that
people are familiar with
so we could say fetch and instantiate
the module called add in its compiled
binary format we haven't talked about
that yet but this is what it's going to
expect and then that is going to fetch
you know fetch the the bits generate
buffer instantiate an instance of the
module in in the browser through the web
assembly JavaScript API which is part of
the definition of the Minimum Viable
Product project and then it's going to
create an instance that the JavaScript
environment can interact with and notice
then once it has the instance it just
says call through the exports collection
the method called add pass in the
functions 1 2 or the values 1 2 and then
this will generate 3 because obviously
it will add those two numbers together
so we can see that calling stuff into
the native functions will work
relatively straightforwardly right look
just like other JavaScript function in
vacations but oddly I can define
function calls within the modules that I
want to use and leave them as externally
defined and then satisfy them with local
JavaScript functions so when I
instantiate the instance of the module I
can hand it a JavaScript object that
says you know satisfy the log function
with console dot log and then stuff can
be logged from the native language
through JavaScript tools so even though
we cannot yet manipulate the Dom
directly we have some certain
limitations
once we can call into JavaScript within
JavaScript we can do whatever we want to
do there so it's it's a surprisingly
powerful combination given everything
that is available to us now you're going
to have command-line tools to do some of
these sorts of things but just to give
you a sense of how this works I'm gonna
use a tool called wasm Explorer I'm
gonna pick a an example so in this case
we'll look at a factorial function and
so we'll see here actually you will not
it will not allow me to zoom in but
basically this is just double fact takes
an int in does a factorial calculation
notice over here we see that this has
been compiled into the vast s expression
textual format we can see that the
assembly is available here we see that
it can it can be run but we can also
download the Assam locally so if your
once you're playing around appease if
you have some libraries and you don't
necessarily want to set up all the
tooling and everything there's nothing
stopping you just doing all this
directly from within the browser so
here's the C code you want to compile it
generate the wasm from it download it
and now you can instantiate it like you
just saw me do on the previous slide but
obviously right you have the ability to
to do other sorts of things so Q sorts
and and whatnot so the idea is we can
take advantage of things like the
hardware accelerated 3d graphics in
WebGL and we can connect them up to
existing numerical libraries written in
C or C++ and they can all run within the
browser without having to worry about
native versions of libraries and
nonsense like that and that should start
to give you a sense of what's going to
be possible with this combination
another quick example wasum fiddle is
another tool that's that's available to
you so you can play around here you
could say let's
I realize it's very small but I can add
in like a new function foo that takes an
int we'll call it X and we'll return x
times 3 I can say build that we can see
it generate the text format here and run
it obviously I'm not doing anything with
the foo function but we see that done in
the corner that the console says 42
which is what the main is returning
right now so we have the ability to play
around to look at to see how C code gets
translated into this but with in
scripting you're also able to to
generate those and again I'll show you
an example just a second I'm not going
to go here but if you want to see sort
of what the limitations of the MVP
platform are webassembly org slash docs
slash MVP is the the best place to go
it'll talk about not just the decisions
that were made but the motivations for
the decisions as well where we are and
what the next steps are going to be for
the the platform there's also a series
of use cases so they're going through
and talking about building things like
document and video or image and video
editing tools within the browser being
able to do sort of triple-eight game
platforms so we don't need a steam we
don't need a console you know to handle
these sorts of things you can write
these games deploy them to various
platforms and they will have near native
performance but all the benefits of
running within the browser as well so
you get a sense of what other people are
expecting to see from the emergence of
this platform as well if you want to
play around with inscription and web
assembly it's as simple as cloning this
get github repo running these tools to
install and activate it and then there's
a shell script or a batch file to source
these to set up the environment there's
a lot of trickery in terms of where it
finds the LLVM version that it's using
and the other tooling so you want to be
careful about that but basically this
sets you up so that you can then take
your hello world or whatever it is
you're trying to do use the EMCC
pass
the C files passing the compiler
directive to omit wasm on the back end
you could give it a name of a HTML file
to generate to have sort of the
bootstrap infrastructure for running
within the browser or you can obviously
generate code to run within node as well
using out outputting the wasm tools and
then there's there's a sort of a
standalone web server particularly if
you're using Chrome or something that
doesn't like pulling stuff off the file
system so to avoid same-origin policy
problems
eeehm run will run out of a browser and
then the inscription scaffolding
framework will work just like it did for
the asm.js stuff I showed you earlier
except now we're using the web assembly
back-end not just the JavaScript so
there's a lot more that you can do with
this we obviously don't have time to go
into it all but I do want you to sort of
have a couple of takeaways and some some
more things to get you excited about
this number one as I said it's early
days and not everything is going to make
sense particularly once you get into the
the various conversions and marshaling
things into and out of the the format's
there are some things that are just not
going to make sense to do natively and
so as you start to play around with
these things right you can look at here
is a JavaScript implementation of the
Fibonacci calculation and here's the web
assembly C code and we see that that's
not substantively more or less code one
way or the other the code is not all
that much more complicated and when we
run it we'll see given the gains that
have happened in the optimization of the
JavaScript platforms in the in the last
couple years the gains aren't always
dramatic this was a pretty good one but
some of the other examples here you'll
see parody or even the JavaScript
running slightly faster so just just
like in the early days of C and C++ hand
optimized C and C++ could could run
circles around
Java but as the java vm optimizations
got better over time and we're able to
look at actual runtime sorts of things
there were cases where it would make
more sense or you could get comparable
performance out of it so we're in early
days in terms of the optimizations that
are available but as as you saw with the
games that were being played they're
still quite good and so the decision
when to to shell out to native code when
not to is gonna have to be a measured
one it's gonna have to be based on
whether you already what you have
already written code in these languages
that you want to bring into the browser
whether you're gonna start from scratch
and use a different language or just do
it in JavaScript that's we don't have
hard and fast rules for those things yet
and the answers will change as the
optimizations get better over time but
we're starting to see more and more
capabilities come in so this is doing
some edge detection in this case using
webassembly against video coming in off
of WebRTC and we can sort of see the
frame rates and the time and if I switch
to JavaScript inverts it just to show
you that you're running in a different
mode I don't think it's trying to say
that javascript is the dark side or
something but we can see that there are
you know comparable performances
depending on whether you're using the
the C C++ Sobel libraries or the
JavaScript ones but we're starting to
see more and more like real uses show up
almost on a daily basis so it's it's a
very exciting time to start to pay
attention to what's what's going on here
but we're also seeing real stuff start
to happen so this is an actual deep
neural network implementation everything
is done entirely in the browser here
they go through and they talk about the
process and how they get there and
they've got a web assembly engine but
they also have some some web GPU
backends web GPU is an API that Apple is
starting to support but so looking here
the whole concept of neural based style
transfer allows you to take one image
and take another image and then
basically interpolate from the one to
the style of the other so I can say take
this picture of this dolphin and read
you know sort of apply the the the color
schemes and the style of the the wave of
the very famous Japanese painting to
that image and it doesn't have to be
just a simple image they can get back to
our friend WebRTC video camera and do
the same thing it looked like Neptune or
something I don't know
but again the thing to keep in mind is
this is all being done within the
browser and so given that the browser as
its value proposition has to do with
being a universal zero installation
platform the fact that we can now write
things in native libraries native
languages things other than JavaScript
and get in your native performance and
the benefit of zero installation and get
the sort of promised write once run
anywhere of the the JVM and you start to
see why these are all going to combine
to a very very sexy combination of
capabilities all right so where do we go
from here the the site wisdom news is a
good site it's it's it's updated
periodically to look for the emergence
of new projects new tools new approaches
back in March right they announced that
the Lua VM is now running in a wasum
environment so once the engine runs in
the wasman environment then Lua should
run successfully on top of it
hmm we're starting to see loaders for
web pack and people you know looking at
other sorts of tooling and whatnot so
why am that news is a good place to to
find to track developments there the the
first couple images with a JIT curves
that I showed you comes from a great
little cartoon introduction by Lynne
Clark
called the cartoon introduction to
webassembly but she's she's a very
strong advocate for what's happening in
this space and is writing a lot about it
so she's talking about
now that the browsers are all in this
preview mode what are the next things so
being able to invoke function calls
between javascript and web assembly in a
faster way she explains what the
problems are and how they're going to
improve improving load times and then
looking at things like letting web
assembly directly modify the dom and so
code that you're writing in one native
language can now modify the HTML
environment that it's running in on
completely different platform doing some
shared memory concurrency things doing
some single instruction multiple data
kinds of parallelism so to take
advantage of multiple CPUs and GPUs
within this environment a better story
on exception handling which basically
means a story on exception handling
trying to make it so that the errors
that happen within these native modules
are easy to consistently trap and and
deal with in JavaScript moving into
things like garbage collection building
better tooling that supports these sorts
of things so this is where we're going
but it'll take a while until we get
there so we'll see lots of open source
projects starting to emit the the wasm
binary doing conversions between the
text format parsing new languages in
that are not requiring garbage
collection a lot of a lot of cool things
like that will happen in the interim now
where I want you to think about this is
is to think about the fact that all of
this is now happening within the browser
so this this video has nothing to do
with web assembly but this is just him
showing what it's what it means to now
be able to do WebGL in the same
rendering context as the Dom being
rendered and the Dom being manipulated
so now we have three-dimensional objects
that are able to coexist
with actual Dom elements that are still
interactable right and so as you see in
just a minute
where he goes you know taking these
ideas a step further so now that we can
mix together hardware-accelerated 3d
graphics low-level peer discovery
network address translation busting the
ability to send arbitrary data through
to these peers over these data channels
the ability to build web torrent like
capabilities on top of these api's and
then now being able to link in modules
and capabilities expressed in native
low-level languages that are able to
achieve native performance in this
environment without having to wait for
the browser's to support new JavaScript
based api is to expose those to the
JavaScript environment you'll get a
sense of how the web that you know is is
going to be very little like the web
that's very quickly going to become our
daily experience and the whole concept
of desktop applications can start to get
disappear the things that we like about
direct manipulation can be embedded
within scenes so now we have a minecraft
engine with a television component where
the television component has buttons
that you can click on and yet the
rendering environment is still Dom based
right and so the YouTube video editor
can be there you can change channels to
watch different YouTube channels and you
get a sense of where all this is going
right combining near-native optimization
of these languages with the environments
that the browser's have evolved into is
going to be very very very exciting the
fact that it's done being done in this
incremental way in a safe way is is very
powerful as well but I hope that you are
interested in digging a little bit
deeper so here's my email address I'm
happy to take we have a couple minutes
for questions if there are any but I
will get the slides available to the
conference organizers but if you have
any questions please feel free to
contact me
as well so thank you very much and I'll
be happy to take any questions if there
are any</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>