<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Better Way To Write Code | Coder Coacher - Coaching Coders</title><meta content="A Better Way To Write Code - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Better Way To Write Code</b></h2><h5 class="post__date">2017-08-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vh_gddKS5OU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I suppose like many of the things I do
this talk and the work that I'm going to
present is in some ways born out of
frustration and my attempt to redirect
that into something productive so if if
you've ever gotten frustrated trying to
understand how your code works or why
doesn't work or trying to understand how
someone else's code works or trying to
understand how my code works sorry about
that
well you're not alone and this talk is
for you so the release of d3 for Dido
last year was focused on making d3
easier to learn you know more consistent
more modular but despite the large
number of cosmetic changes to the API it
wasn't really a radical departure from
earlier versions the core concepts of
selections scales and shapes were
polished but they were you know mostly
unchanged they were basically doing the
same sort of thing and I think this was
the right balance for continuity I mean
I know that the API changes themselves
are disruptive but you know I don't want
to change everything completely every
year I want to make a balance between
sort of doing some innovation and some
improvements and keeping things the same
but after the release of for Otto I
wanted to think a little bit more deeply
about not just how to make d3 easier but
how to make visualization easier yet in
seeking to better a tool for
visualization I remembered something
I remember that visualization is itself
a tool a means to an end a means to
insight right a way to think to
understand to study to communicate
something about the world and per ben
shneiderman
the purpose of visualization is insight
not pictures and so if you consider only
the task of assigning visual encodings
of constructing visualizations you
ignore myriad other challenges right
like finding relevant data cleaning it
transforming it into efficient
structures for analysis designing that
analysis statistics modeling simulation
explaining your findings and I don't
mean to or I don't wish to downplay the
importance of visualization tool
and innovation therein I have many
improvements I still plan on making 2d3
and I'm really excited to see other new
approaches like Vega light come out but
I also think it's important to step back
occasionally and consider complementary
approaches to related problems tasks
supporting discovery are often performed
by writing code and coding is famously
difficult right even if name suggests
impenetrability code originally referred
to machine code low-level binary
instructions to be executed by a
processor code has come a long way since
then but it's still hardly human
friendly to give a sort of comically
dense example here is a Bosch command
that I wrote for generating a corpus of
population density from California
census tracts so I mean it looks like
vid it starts with geo - topo here but
that's not actually what it does it
starts with this it doesn't start with
nd Jason joining either it starts with
this shape - Jason which is reading a
shapefile converting it to a new line
delimited Geo Jason stream and anyway
it's not actually just bash here these
are also JavaScript expressions which
are embedded within bash and then you
know anyway I could spend probably a
whole talk just going over how this
particular slide works now Brett Victor
gives this very concise definition of
programming programming is blindly
manipulating symbols and by blindly he
means that we can't see the results of
our manipulation we can edit a program
rerun it diff the output but programs
are complex and dynamic and so this is
neither a direct nor an immediate
observation of the impact of our change
and by symbol T means that we don't
manipulate the output of our program
directly we operate in abstractions and
these abstractions can be powerful but
they can also be difficult to grasp in
Donald Norman's terms these are the Gulf
of evaluation and the Gulf of execution
but clearly you know some code is easier
to understand than others
so what are the symptoms of inhuman code
the first thing I think of is spaghetti
write code that lacks structure or
modularity where in order to understand
one part of a program you have to
understand the entire program and this
is frequently caused by shared mutable
state right if you have a piece of state
that is modified by multiple parts of a
program it becomes much harder to reason
about its value and indeed how do we
even know what a program does if we
can't track its complete state in our
heads then reading the code is
insufficient and so we use console.log
who use debuggers we use tests but as
I'm sure you've all experienced these
tools are also limited write a debugger
can only show you a few values at a
single moment in time until your ability
to see sort of rich or complex data
structures and patterns of execution are
limited and so we continue to have great
difficulty understanding what our code
does and sometimes it can feel like a
miracle that anything works at all and
despite these challenges we continue to
write code right we're still writing
code all the time for lots of different
applications more than ever before and
so why is that right are we masochist
maybe maybe are we unable to change I
mean yeah probably but I mean is there
no better solution and in general and
that is a very important qualifier no
code is often the best tool that we have
because it is the most general tool that
we have I don't mean best in some sort
of absolute sense but I do mean best
like for the right here and for the
right now and the person's doing the
work and that is because code is the
most general it has the most unlimited
expressiveness and alternatives to code
whether that sort of higher level or
that also includes higher level
programming interfaces and languages can
do well in specific domains but these
alternatives must sacrifice generality
for greater efficiency in their domain
and if we can't constrain the domain
it's unlikely that you'll find a viable
replacement for code right there is no
blanket replacement as long as humans
are still thinking and communicating
primary
early in language and if it's hard to
constrain the domain of science right
science is fundamental we're studying
the world we're trying to extract
meaning from empirical observations to
simulate systems and a medium to support
discovery must be capable of expressing
novel thought right just as we don't use
phrasal template mad libs for composing
the written word we can't be limited to
chart templates for visualization or a
drop-down menu of formulas for
statistical analysis we need more than
configuration right we need to compose
primitives into creations of our own
design and if our goal is to help people
gain insight from observation we must
consider the general problem of how
people code bread Viktor had this to say
about math but it applies equally to
code the power to understand and predict
the quantities of the world should not
be restricted to those with a freakish
knack for manipulating abstract symbol
okay so when I talk about it being hard
to code it's not just a question about
making our work flow more convenient or
more efficient it's about empowering
people to understand the world now if we
can't eliminate coding can we at least
make it easier for our sausage fingers
and finite size brains and to explore
this question I've been building
prototyping an integrated discovery
environment called d3 Express it's for
exploratory data analysis for
understanding systems and algorithms for
teaching and sharing techniques and code
and for sharing interactive visual
explanations I do want to make
visualization easier but to do that we
need to make coding easier I cannot
pretend to make coding easy the ideas we
wish to express explore and explain
maybe irreducibly complex but by
reducing the cognitive burden of coding
we can make the analysis of quantitative
phenomena more accessible to a wider
audience
the first principle of d3 Express is
reactivity rather than issuing commands
to modify shared state each piece of
state and a reactive program defines how
it is calculated and the runtime manages
their evaluation the runtime propagates
derived state if you've written
spreadsheet formulas you've done reactor
programming this is a simple notebook in
d3 Express just to illustrate reactive
programming it looks a bit like a
browsers developer console
except here our work is saved
automatically so that we can revisit it
and it's reactive so in imperative
programming c equals a plus b copies the
current value of a plus B into C right
it's a value assignment and that means
if a are V changes C retains its
original value until you execute a new
value assignment but in reactive
programming C equals a plus B a plus B
is a variable definition and that means
that C is always equal to a plus B even
if a or B changes right so if I'm
defining a and B and I update their
definitions the runtime is automatically
keeping C up-to-date with all of the
active variable definitions and so
reactivity means that as the program
author would care only about the current
state and it's the run times
responsibility to manage changes in
state and that may seem like a small
thing when you're just adding a couple
numbers but as your program scale up
this is eliminating a substantial burden
now obviously a discovery environment
needs to do more than to add a few
numbers so let's try working with data
so I'm going to load d3 and then I'm
going to use e3 dot CSV to load this CSV
file here now both of these operations
here requiring the library and
downloading the file from github are
asynchronous but in a reactive program
we hardly notice this and that's because
the definitions that depend on these
asynchronous values aren't executed they
aren't evaluated until their inputs are
resolved and so reactivity means that
you can write most asynchronous code as
if it were synchronous
now you can also see the output here
from the results of downloading this
file and d3 CSV is conservative about
types it doesn't infer any data types
and so all the values dates and the
clothes this is like two years Apple
stock price or strength but to start
working with this data in to do analysis
we need to convert those into more
precise types so here I'm defining an
Access or function or row function to d3
CSV that I can map those types to more
specific types map strings to more
specific types or even change the format
of the data if I wanted to so the closed
field is a number so as I change that as
I put the little plus symbol there the
unary plus operator you saw that the
closed
purple strings changed into green
numbers so it's immediately giving you
feedback of the changes that you're
making in likewise if I want to convert
this date into a more precise type into
a JavaScript date I need to parse that
but JavaScript doesn't understand that
date format natively and so I have to
write a function but in this case I've
actually called the function before I've
defined it like in a reactive program I
can write my code in any order and as I
finished writing the program it'll bring
everything up back to date so I call the
parse time function and now I'm defining
that parse time function using d3 time
format passing in that value here again
I can see updating and as I substitute
the fields would be appropriate whatever
percent commands you can see the devout
dates and it looks correct now that the
data is in the right format I can start
to ask questions of it like if I just
want to compute sort of simply the the
range of dates in this data set but
again I made a mistake here I forgot to
give the data a name so that's going to
give me an error but I'll just go in
there and assign it a name and then it
really early err command rate so it
becomes much more resilient to error
when it's automatically re-evaluating
things as they're currently defined
rather than sort of constantly thinking
about sort of what state is your program
in how do I get it into the right state
you're always operating under current
definitions okay now unlike the
developer console cells in d3 Express
can have visual outputs simply
by returning Dom elements so we can take
this data and we can turn it into a
chart so we'll specify what the size of
the chart is the width height and
margins sort of the standard d3
convention and then we can go back and
we can take the domains the extents of
our data that we've computed and use
those to construct scales so we'll have
a time scale Forex mapping that domain
of data to sort of exposition and
similarly for y for y we can have a
linear scale taking the domain of the
closed dimension and mapping that to
sort of a vertical position so those
have changed to be scales now and now
I'm going to open up and I'm going to
create an SVG element so this one unlike
the other ones has curly braces on it
sorry skip ahead there
so when I open up the SVG I'm going to
use curly braces so that I have sort of
the ability to write an arbitrary block
of code there I'm not limited to just
writing a very shorthand expression and
so inside of the SVG definition I'm
going to use Dom SVG in order to create
an SVG element that's just a convenience
wrapper on top of document create
element NS the idea is that your
notebooks they're basically just working
with detached Dom nodes and then by
returning those nodes they end up
getting displayed in the browser all
right so this starts out it's just an
empty SVG node and then I'm going to
start to add some structure to that
using d3 selection like I can add access
here and by default that's going to be
at the top because it's rooted at the
origin in the top left corner then I can
specify my translate function or sorry
my transform attribute to move that down
take that code copy it and make the
y-axis which goes there on the left and
so as I making these changes I can sort
of immediately see what the effect is on
the output right I'm not having to sort
of constantly switch between my editor
and then reloading it in the browser
likewise when I want to add the actual
path there to draw the line I can add a
path element I'm going to need a
function in order to compute the
geometry for that path so I can use d3
line and then pass in the the right x
and y-axis or using our scales and
pulling out the appropriate fields that
looks driven but it's not quite right
because path elements of course still
black by default and SVG so we'll change
those attributes to remove the fill and
replace it with a blue stroke now that's
a very basic line chart but already you
can see that the program's topology is
starting to become more complex so this
is the directed acyclic graph of
references in that line chart and this
graph was itself made by d3 express
using graphics and the 93 at the bottom
is the sort of unnamed cell which is the
SVG output so a few observations of this
graph right it's now trivial to take our
chart definition and make it responsive
so with the height in the margin feed
into the scales they feed into the SVG
definition they're currently defined
constants but if we wanted to make this
chart responsive to the to the window
size we could just replace those
definitions appropriately and everything
else would update likewise if we want to
replace the data if we want to have like
a real time data stream coming in there
we're just replacing the data definition
and our static chart becomes a dynamic
chart and I'll show that shortly in
action but before then let's look sort
of more closely at the difference
between the imperative style coding and
the reactive style so this is your sort
of typical d3 code you might see on
blocks or again some of my examples
where you know at on page load you're
defining a scale but on page load you
don't have the data available so you
can't initialize the domain of your X
scale and so then later after the data
load you're defining the scale or the
domain of your X scale and so if you
think about it you're separating the
definition of this object into two
places in your code and you can have
sort of arbitrary amounts of unrelated
code separating those definitions if you
compare that to the reactive definition
the reactive definition is centralized
because we no longer care about the
order of execution and the dependencies
in our code right those are now managed
by the runtime and so we can centralize
our definition and so reactive
programming is not just sort of about
making things more convenient or saving
you time it's also about getting a
cleaner code structure and this is
particularly useful if you want to be
able to reuse these definitions in
another program right because your your
definitions are now localized and
they're easier to copy and paste or to
import into other documents so lastly
you know on line chart like despite the
name d3 Express you're not required to
use d3 right it's just doing Dom it's
doing JavaScript and you can use
whatever library or whatever format in
your browser support to create your
visualizations so this is a similar
chart but now using Vega light to show
that same data with the nice sort of
concise syntax that provides rather than
operating sort of on the low-level
objects okay so another example of that
is if I wanted to use you know canvas
instead of SVG to do something else like
in this case like we want to make a
globe
I've loaded top of Jason I've loaded
some topology of world country
boundaries and now I'm going to open up
a new block and create a canvas and get
the context for that canvas and then
again like if I returned that canvas
that and this is going to be displayed
but I can now start drawing to that
canvas to get it to display and so this
is a sort of standard way of you might
use d3 geo to draw to the canvas where I
have a geo path object it takes a
projection and then I pass in the
context that projection and here the
projection is defined just as like your
fixed geo orthographic projection and I
can add like another outline to that and
stuff to which you'll see in a second
but I want to use this to sort of
showcase another powerful feature of
reactive programming which is I can take
a variable definition that's static like
this sort of fixed aspect orthographic
projection and then I can replace it
with a dynamic definition right like a
rotating projection and I can do that
only using sort of standard JavaScript
which is that I take the static
definition of this projection as just a
Geo orthographic and I can replace it
with the generator so here you're seeing
like a Mercator and equal rectangular
and it's updating automatically but if I
put the star in front of the curly brace
here I'm now defining a generator that
can yield multiple values rather than
just a single value that's a constant if
you haven't use generators before I mean
this is a standard JavaScript thing
they're relatively new but they are
really cool and they've been it's a lot
of fun to sort of just take a little
static definition and replace it with
something dynamic like this and so the
way that that's working is that the
runtime is pulling new values from the
generator sixty times a second so the
generator is kind of it runs once and
then it basically gets suspended until
the runtime is pulling a new value from
it and the way that the code works is
that when it's pulling a new value it's
just setting in the new rotation angles
on that projection and then returning it
and again because the runtime
understands sort of the relate
shifts between all of these different
variables it knows to recompute the
canvas whenever that projection changes
and so it's really easy to take sort of
a static thing and then add a scripted
animation on top of that like like we
have here for this rotating globe but
one of the things that's going on here
is that you may not have noticed is that
it's actually throwing away to canvas
and creating a new canvas each time that
it's rendering and that can be pretty
expensive to just throw everything away
and restart it it's nice that it kind of
works by default but if you want to go
in and you want to optimize it to make
it a little bit faster
d3 Express you can refer to the previous
value of a variable as this and so in
this case I've changed the canvas
definition to just use the existing
canvas that we have previously rather
than to create a new one and you can see
that once I do that it starts to smear
because it's just drawing it every time
rather than having a blank canvas so
that it's drawing onto but of course I
can then change the code I can clear the
old value I can fix the sort of context
line would and the result is you can
have these very efficient animations
right there's negligible overhead
because you're doing basically the same
thing that you'd be doing in vanilla
JavaScript it's just that you didn't
have to sort of worry about managing all
of that state yourself ok so again to
just sort of a look a little bit more
closely at the code right this is a
static definition for a projection it's
just a Geo orthographic instance and
then this is our rotating projection and
so it's a block statement would star in
front so that we can yield values and
we're just going into a while true loop
that sets the projection dot rotate and
then yields that value and that's it
basically doesn't have to change
anything else
so if generators are good for scripted
animations what about interaction
well generators can do this too and the
way that it works is that you yield a
promise that resolves whenever there's
new input from the user so I'll go
straight in that now by going back into
this sort of rotating projection and if
we want to make this into an interactive
rotation the first thing we need is sort
of a little widget slider for somebody
for the user to draft so we can again do
that by just creating the right Dom
element here so Dom that range is just
again like document create element
creates an input element that says the
type is range min values 180 max values
a 180 you could write this all by hand
but it's nice to have sort of concise
syntax now that's not hooked up to
anything so dragging it doesn't really
do anything but we can give that a name
and then we can write a generator that's
going to yield the new values whenever
you're dragging with it now again I
could write that by hand but that's a
very common thing to do so there's this
built in generator called generators
input and it's just going to do that for
you it listens for input events on the
Dom element and then it yields the new
value all right so now when I'm dragging
it I can see what the value is as
another cell and notebook likewise it
give that a name take that angle plug
that into the rotation of our the
projection and then now when I drag the
slider goes back and forth you can see
that the globe is rotating now again
that's this is such a common thing to do
that there's even a shorter syntax for
that where you can define both sort of
the graphical interface like the Dom
element that's being displayed and the
value that gets exposed to code so
that's what the view of operator is and
it's it's two definitions in one and
they work exactly like the definitions
that you just saw it's just a slightly
more concise definition of that okay so
again this is our sort of long form
definition for an interactive projection
where we've got the projection we've got
the angle which is comes from the Dom
element which is the input range and
then this is the shorthand syntax for
exactly the same thing where we use view
of angle okay but cool thing about this
is that we now have the ability to sort
of create arbitrary graphical interfaces
and design the appropriate sort of
programming interface like the values
that get exported along with that you're
not limited to just sort of sliders and
drop-down menus and some fixed palette
of user interface so in this example I'm
actually going to create sort of like
this complex compound input to make
color picker so this is like a form here
with the table inside of it and there's
going to be an input for each of the
channels in our color space a hue
saturation and lightness and this is
just using Sadam HTML it just takes a
big string
that's like innerhtml of a div and
returns that so that I don't have to
like create all this stuff in JavaScript
I'm just kind of embedding an HTML
fragment in my code and then likewise
like here is where I'm sort of defining
how this is going to be exposed to my
code I'm setting what the value is on
the top-level element and that's going
to be updated whenever you drag the
slider whenever there's an input event
and it's defined here to create a d3 qpx
instance and it also is sort of updating
the outputs that go along with each of
these inputs so that you can see what
the values are in this table below so
when I drag the hue slider it's both
updating that cue angle that's next to
it and you can see that it's emitting a
new color which is displayed in the cell
below and then that is used sort of to
set the background color of this div so
that we can see what that color actually
looks like okay now that's sort of a toy
example again I'm sort of defining a
custom interface but sort of where this
starts intersecting with visualization
starts to make it much more interesting
so this is a histogram showing the
return of a few hundred stocks over a
five-year period you can see that it's
like a bell curve right that's the mode
of that is slightly greater than one
sort of expecting a positive annual
return but there's also like this long
tail of stocks that did really badly and
a long tail of stocks that did really
well now in another environment you know
it might be difficult to sort of inspect
this directly right there visualization
can kind of be a dead end where you can
see it but if you wanted to sort of know
what are the data points behind these
individual bars you have to phrase that
as a new question in code and the goal
of d3 Express is that you can sort of
quickly augment these visualizations so
that we can start to manipulate them
directly right getting back to what red
Victor said and so the way that we do
that is by basically taking this
visualization and treating it like we do
an input like we do with the slider like
we do with the table and so now when I'm
brushing back and forth just using the
standard d3 brush it's actually exposing
its current selection as the array of
data
that are there and I'm just displaying
that sort of using the default inspector
but it's good enough to let me know sort
of what is under the selected range and
I can just drag that back and forth
without sort of doing any work and just
to show that there's not really any sort
of real magic going on behind the scenes
here this is the code that adapts sort
of your standard d3 brush this is not
like a special version of B through
brush this is just the same d3 brush
that you're using today and fitting it
into this new framework where you're
receiving your brush event you're
looking at the brush selection and then
you're pulling out the x and y values so
basically like the start and the stop
and then you're filtering your data
based on those values and then you're
setting the property this is what the
value property of your nodes that's what
gets exposed to code and then you're
just telling the generator you're
telling d3 Express that the value is
updated by dispatching an input event
now another thing that you can do in d3
Express that's useful is that you know
by default these reactions to your code
are going to be applied instantaneously
so whenever a variable changes the
runtime knows what depends on that and
it's going to recompute all the derived
variables and update the display
instantaneously sometimes though that's
not what you want right you have is
something that changes and you want to
be able to observe what's changed so we
want to use these animated transitions
to have some object constantly constancy
so in this like again simple bar chart
I've written it in such a way it's using
the d3 data join and there's a
transition that's staggered so that when
this data updates it's going to move the
bars into their new positions so you can
see how the values change and then
likewise like this data set here which
is just sort of the frequency of English
letters is defined so that if you change
the sort by value flag it's going to be
sorted either by descending frequency or
sorted just lexicographically so now
when I go back up to the top and I
change the value of this by using the
check box the code can sort of apply a
transition from the old values to the
new values
so you can use sort of access to the
previous value both to improve
performance and to get better visual
output because in the reactive system
you can kind of acht into controlling
how these changes get applied so again
it's sort of like opt-in complexity as
you want to add richness to to your
implementation okay so that was a pretty
rolling tour of reactive programming d3
Express but you also saw how you can use
the inline outputs the visual outputs of
cells to improve our ability to see how
or to see the program's current state
but I want to dive into this a little
bit more and show you how to use
visualization in d3 Express to improve
our ability to scrutinize a program's
behavior so reactive programming where
you can sort of change the code and
immediately see how it updates is also
known as interactive programming and
interactive programming allows us to
investigate how code works by poking it
right you can change it you can delete
some code you can reorder it and you can
sort of see what happens and it gets
lets you get a sense of how that
individual bit of code that you changed
is contributing right you're again doing
a more direct observation of how that
code impacts the program so in this
notebook I've got sort of the standard
force directed graph of lame-o's data
and this is your sort of force
simulation so I add or remove the charge
force and I can see how that's using it
the charge force is causing the nodes to
repel right otherwise if you remove it
they sort of collapse down into the
center where the only force that's
really applying to them is the link
force likewise I can modify parameters
of the charge force so I can set the
strength to be a hundred and of course
that is now they're attracting each
other rather than repelling each other
so they all kind of collapse down on the
center change it to negative 100 and
they kind of expand out 50 100 whatever
and what you're seeing here also is that
it's not sort of reloading the entire
page when you're making these changes
it's a reactive sort of topology and so
when I'm changing the definition of
these forces it's not sort of throwing
everything away and starting over it's
just operating on the current
that's running you're doing live editing
of the program and so that sort of
improves the stability and lets you see
more easily how these changes are
contributing to the program's behavior
so likewise like I take out the link
force here they're sort of no longer
connected to each other and they start
spreading out or if I take out the the
centering force then it can sort of
start floating away by okay now a more
explicit approach to studying program
behavior so rather than sort of
tinkering with it is to try to expose
its internal state and I'm going to
illustrate this by just using a very
simple example of computing a running
sum so we can take sort of a normal
JavaScript function which returns a
value and we can turn it into a
generator in the generator now yields
values in addition to its normal return
value and the idea is that those values
that were yielding as the program is
running give us a view into what that
code is doing when it's running and the
nice thing about having sort of both
yield and return is that you can
essentially take sort of arbitrarily
complex functions at least if they're
not already generators even recursive
ones and you basically have this like
extra channel now where you can expose
the internal state of your program and
that's really useful for visualizing a
program's behavior or for studying and
programs behavior because it allows you
to sort of cleanly separate your
visualization of the behavior or your
analysis of the behavior from the code
itself right like if I take some code as
I've done before and and put my
visualization code directly within that
algorithm it starts to become a mess
like if you're doing canvas draw stuff
and then you're using a debugger and
it's like switching between the
algorithm and the canvas stuff it just
gets complete chaos but if you have this
approach then you can just sort of
extract the data out of your program
either while it's running using
generators or sort of statically
building it up as an array of values
then it becomes much easier for you to
do that analysis and so in d3 express
here's sort of how you extract the data
out of that generator so the simplest
way of doing it is you just call your
function like you would do before
and because it is now returning the
generator you automatically get an
animation right so III Express knows
that when your variables design is a
generator it's going to pull new value
out every animation frame but you can
also do things like this which is a
spread operator where you're you're
essentially pulling all the values out
of that generator at one go and putting
that into an array and that's useful if
you want to do serve more static
visualization or if you wanted to do
interactive visualization where you're
sort of scanning in between individual
frames now that's obviously like you
don't really need to study running some
function I think we all know how that
one works but I want to use sort of a
more real-world example and this may get
a little bit hairy but I'm gonna try it
anyway so looking at the circle packing
layout in d3 so you've probably seen
this before this is the flare class
hierarchy and circle hierarchical circle
packing is basically like tree Maps but
you have this sort of extra wasted space
because your nesting circles rather than
squares and that extra space is not
really wasted and sort of helps to
indicate sort of the hierarchical
structure in a way that's not always
obvious with tree maps now in order to
produce these sort of diagrams you first
need to sort of lay out the individual
circles right the set of siblings in in
part of your tree and so this is sort of
a little example of how it works right
you you have a set of circles that you
want to pack in order one of the time in
into a small space as possible without
overlaps or a little bit like them
penguins huddling in Antarctica and so
your job is to place one of these
circles at a time until you placed all
of the circles and since you want the
circles to be packed as tightly as
possible you know that like each new
circle you place should be tangent to at
least one of these circles you've
already placed actually two of those
circles but if you just pick sort of an
existing circle at random as you're
placing the new circle as your tangent
circle you're going to waste a lot of
time trying to put that new circle sort
of in the middle of the pack where it's
going to overlap with the other circles
that you've already put down so ideally
as
you're determining what your tangent
circles are you should only be
considering the circles that are on the
outside of the pack but the problem is
like how do you efficiently determine
you know which circles are on the
outside and so Wang's algorithm which is
what's used by d3 and by other
implementations of this layout maintain
the front chain and that's what the the
red line here is and the front chain
represents sort of these outermost
circles and so when you're placing in a
new circle it picks the circle on the
front chain that is closest to the
origin and the new circle displaced
tangent to this circle and it's adjacent
neighbor and if there's no overlap with
other circles litter on the front chain
then it can just move on to the next
circle but if there is overlap like as
you see in this case here where the big
circle overlaps with the other circles
that are on the front chain then it
needs to cut the front chain so that it
can now choose a different pair of
tangent circles and effectively move
that overlapping circle out to the
outside and so if you look closely at
this animation you can actually see
those moments where it's cutting the
front chain as these sort of larger
circles get kind of squeezed out of the
pack and pushed down right and so I find
this kind of mesmerizing to look at but
more than sort of being eye candy
this animation and this notebook was
extremely helpful for me for fixing a
long-standing bug in d3 s implementation
where you know there's a little bit of
vague wording in the original paper and
it wasn't obvious which side in some
situations of the front chain to cut and
read about it's like circular structure
and in some cases it's not obvious which
part of the front chain needs to be cut
in order to place the new circle and
having the ability to sort of inspect
the program to see what it's doing as it
goes along rather than just sort of
seeing the output at the end and it
being wrong made it much easier to sort
of isolate the the conditions that led
to the bug to make a change to the
algorithm and see how it affected those
specific conditions without sort of
starting over with new random output now
this is only sort of one part of circle
packing the other thing is that once
you've sort of laid out you
siblings you need to in compute the
enclosing circle for that pack so that
you can then move on to other parts of
the hierarchy the conventional way of
doing this is that you just sort of scan
the front chain and you pick the circle
that is the farthest from the origin and
that works pretty well because the packs
tend to be roughly circular but
sometimes the packs can be like sort of
slightly shifted off to the side and so
that doesn't end up being an exact
solution and I learned that there's this
algorithm called well tools algorithm
that gives you the optimal solution and
it runs in linear time and so there's
really good kind of no reason to not do
that I mean it's a little bit more work
to implement it but if I can do it once
and improve these things even if only a
slight improvement that's good and and
also you know it's just fun to kind of
understand how these things work so well
fools algorithm sort of is again an
incremental algorithm it's working on
sort of one circle at a time and it
works in random order and you can see
just in this animation that it's sort of
very quickly because of that approach
converges on to sort of roughly the
right enclosing circle but there is a
chance as you get sort of these circles
that are on the outside that it has to
expand so how does this algorithm work
well actually one thing I should say is
that this is sort of a slightly harder
problem that I'm showing than what
happens inside of the circle packing
layouts because in circle packing it
already has the front chain so it really
only needs to complete computes it and
closing circle of the front chain but
here I'm just sort of showing the
general case where you have an arbitrary
set of circles so and you don't know the
front chain ahead of time okay so how
does this algorithm work well let's
assume that we already have an enclosing
circle for some set of circles for
circle 0 through I minus 1 and it sounds
sort of like circular to start assuming
that we already know what the enclosing
circle is but this is kind of like how
math works how induction works how we
can start to build an algorithm as a
starting point so if we assume that we
already have an enclosing circle for
some set of circles and all we want to
do is sort of incorporate the next
circle into our enclosing circle well if
that new circle which is the black one
here is already inside our enclosing
circle then we don't need to do anything
right
circle to fine and we can just move on
to the next one but if the circle that
we're trying to add is outside its not
contained by the enclosing circle then
we need to compute what the new
enclosing circle is but we can actually
make an observation about this new
circle and that is that if this circle
is outside the enclosing circle we know
that it's the only circle that is
outside the current enclosing circle and
that means that the new enclosing circle
must be tangent to the new circle that
we're placing right so that looks like
this
but the problem is we don't know what
those other two tangent circles are they
might not be the same as our previous
enclosing circle but the result is like
we know what one of the tangent circles
is to the new enclosing circle we can
actually apply this algorithm
recursively where each time that we have
a circle that's outside of our current
enclosing circle we recurse to find the
next tangent circles and we also know
some other boundary conditions like what
being closing circle is when you just
have one circle or two circles or three
circles it's called a Polonius's problem
and in geometry I'm not going to show
the geometry proofs this is already
enough but you know you can get a sense
of sort of how this algorithm works and
why it's able to terminate okay so now
that we understand sort of this
recursive structure we can sort of
produce a visualization that sort of
shows this more complete view of how the
algorithm works and so from left to
right here you're seeing basically the
four possible depths of the stack like
it can't recurse more than three times
because you can't have more than three
tangent circles or else you already
contain all the circles and that
geometry but so before you just saw sort
of the circles on the lek but now you're
seeing sort of as it has one of these
circles that's outside of the red circle
it's going to add the new tangent circle
and it's going to start descending into
this into the recursive approach but you
know in addition to sort of showing you
how this algorithm works one of the nice
things is that you can get a better
sense of how much time the algorithm
spends sort of in different states of
the program and like in this case you
know you see that the the enclosing
circle gets bigger very quickly but you
can see that whenever it finds
sort of a circle outside and needs to
recurse it actually needs to revisit all
of the previous circles just to make
sure that that new enclosing circle
actually contains everything but I'm not
going to prove that it's linear time
that's that's too much work but anyway
you get you get kind of a sense here
anyway
all right so one way to write less code
is to reuse it and the four hundred and
forty thousand or so libraries that are
published to NPM sort of attached to the
popularity of this approach but
libraries are an example of active
reusability right you must design a
library to be reusable and this is often
a substantial burden right it's hard to
design effective general abstractions
just ask anybody that is an open-source
maintainer and in contrast like
implementing one-off code like you see
with the d3 examples
tends to be much easier because you're
sort of only worried about the task at
hand you don't have to generalize into
some abstract class of tasks but with d3
Express I'm trying to explore whether
there's sort of an intermediate solution
with better passive or usability where
you can use the structure of these
reactive documents to more easily
repurpose code so one part of that is
that you can treat any document it's
basically a lightweight library so in
this case like had some other document
it defined a color interpolation
function and a ramp thing which just
generates a pretty gradient and I'm now
going to import that into this document
and then I'm going to call it and so if
I had some other color function or some
other utility that I wrote in one
document you know I don't have to create
a package on NPM and publish that or
github repo or whatever I can just pull
that into my code and the cool thing
here is there's also pulling in the
dependencies of that definition
automatically so the original definition
of that used d3 HSB which is like an
optional d3 plug-in and that's going to
be loaded automatically as I pull in the
interpolate terrain I don't have to sort
of load that separately but likewise
even though I'm loading that definition
of d3 in the remote document it's not
going to conflict with my own local
definition of
because I'm pulling in the functionality
that the definition but I'm not pulling
in the symbols I'm only pulling in the
symbols that I explicitly referenced in
my import statement but you can do sort
of even cooler things in these three
Express which is that you can rewire
these definitions to sort of inject your
local definitions into the remote
definition excuse me so this is the case
where I have data set that is going to
be streaming over a WebSocket I'm not
going to explain like how all this code
works I think the idea is that you have
like sort of an API for connecting to a
socket and getting some real-time data
stream it just has like an array of
values which it keeps like the last 60
seconds oh but the result is this is a
generator it's just going to admit a new
array of objects x value and so the
question is like can I visualize this
just using an existing line chart right
we already have a line chart that was
showing Apple stock price which is
basically the same structure just an
array of objects with date and close
here I'm actually pulling in a slightly
different definition because time and
value but so here I'm embedding the
chart and you can see it's just that
same sort of basic chart but if I add
this with Clause here I'm injecting my
definition of data into the chart right
so that static chart becomes a real-time
chart and I didn't have to change any
other aspect of the code because that
code was already defined to be reactive
right where it's setting the domains of
x and y but the cool thing is like I
don't have to stop there right I can
also augment sort of other aspects of
that chart definition because they're
all part of this this topology which is
exposed and then I can override it so if
I don't like the fact that the Y scale
is sort of dynamically adjusting based
on the window and I just want to have a
fixed window because I know sort of what
the expected values are from my
streaming data set I can do that and I
can pull in other definitions like the
width and height and margin in order to
do that and then I'm going to inject my
Y definition here and so that changes so
that it's now like fixed scale and
likewise I can do the same thing with
the X scale so that rather than sort of
like showing you like the chunks as it's
updating I think it updates like four or
five times a second here I can just have
like a very smoothly sliding X scale
the update 60 times a second and just
sort of like crops with a little bit of
update of data so that it's slightly
outside the time window and so that's
replacing the X scale with the generator
again like it doesn't care whether the
generator the X scale is like a constant
or a generator I can just plug those
things in alright so notebooks in d3
Express they run in the browser right
not in the desktop and not in the cloud
there's the server to save your edits
but all the rendering and the
computation happens locally in the
client so the question is like what does
it mean to have a web first discovery
environment and in my view a web first
discovery environment it embraces web
standards that means vanilla JavaScript
and the Dom it works with today's open
source whether that's like snippets that
you find on the web or whether that's
libraries you're getting from NPM and it
tries to minimize the amount of like
specialized knowledge that you need to
be productive in this new environment
there is some new syntax in d3 Express
for reactivity but I've tried to keep
that as small and as familiar as
possible right so it's using generators
to define sort of these dynamic values
these are sort of all of the forms of
variable definitions and they're just
you know expression block statement sort
of a generator block statement and your
standard sort of function definition
probably more important though is that
your code can now run everywhere right
so if it can run in your browser if it's
using web standards it can run in
anybody else's browser right there's
nothing to install and that means it
becomes much easier for others to repeat
and validate your analysis right and by
extension your code for exploration can
grace gracefully transition into code
for explanation you don't have to start
over from scratch if you want to
communicate your insights I mean it's
great and I want to commend journalists
and scientists for increasingly being
open and sharing their data and sharing
their code but I also think that sort of
you know putting code up on github isn't
necessarily enough to make that reusable
right specially a lot of work
for people that want to run your code to
recreate the necessary environment maybe
they need the right operating system
they neither write software to be
installed and need the right packages
certainly they need familiarity with the
tools that you're using and that sort of
stuff
but if the code is running in the
browser again there's nothing to install
and it just sort of works by default so
again I mean maybe should have gotten
Bret to give this talk instead but I'm
going to end on another Brett Victor
quote from the explorable explanations
like I just explained sort of the
implications of this approach so an
active reader asks questions considers
alternatives questions assumptions even
questions the trustworthiness of the
author an active reader tries to
generalize specific examples and devise
specific examples for generalities an
active reader doesn't passively sponge
up information but uses the author's
argument as a springboard for critical
thought and deep understanding and so
you know imagine if our our algorithms
are communicated not just in prose in
PDF but they're shared in live code and
they're shared with interactive visual
diagrams become so much easier for the
reader to sort of look at how they work
and to question it into tinker with it
and and to make modifications for that
ok so I want to end on a slight
disappointment this is a lot of work and
it's not ready for you to use yet but I
hope it's going to be ready very soon
you can actually sign up for like an
early access thing when it's available
on d3 dot Express
that's a URL but if you are interested
in this stuff please come talk to me
about it if you want to help me build
this so that's available sooner rather
than later please very much get in touch
with that and thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>