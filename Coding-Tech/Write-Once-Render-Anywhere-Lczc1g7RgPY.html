<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Write Once, Render Anywhere | Coder Coacher - Coaching Coders</title><meta content="Write Once, Render Anywhere - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Write Once, Render Anywhere</b></h2><h5 class="post__date">2018-04-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Lczc1g7RgPY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right well today we're going to talk
about something really exciting that's
generating a lot of buzz in the
community over the next 25 minutes
you're going to learn how to write a
component once and render it anywhere
I'm talking web native VR sketch and
more without changing any lines of code
does that sound cool alright so before
we get started I wanted to introduce
myself
Shalom my name is Peggy raze this and
you can find me on Twitter github and
media Matt my handle right there and as
you can see I've had an awesome time in
Israel so far I even made some new
friends on the tour I I work at meteor
development group on the Apollo team
building open source graph QL tools and
previously I was working at Major League
Soccer as an engineer on the UI team my
talk actually is an about graph QL today
at all but I I do think that Apollo
client compliments a universal
components architecture very nicely and
I'll explain more about that later in my
talk so before I tell you what
cross-platform component libraries are
and the problems that they solve I want
to give you some context first so in the
beginning we had react on the web and we
all thought it was awesome clearly
judging by the amazing international
community we have here today react
allowed us to build beautiful you eyes
pretty quickly and iterate upon them so
then came the custom renderers that
brought react success on the web to
native platforms the first of which was
react native and react native was so
great that in spiral inspired several
Forks on Windows and Mac OS and Apple TV
and and more recently we also have
custom renders for web VR and sketch now
which is super exciting so needless to
say react native was a hit
so just quick show of hands who here is
use react native before okay a couple of
you awesome so check out these stats
from the last state of JavaScript survey
over 10,000 developers responded and
they reported a 92% satisfaction rating
for react native now I don't know about
you but I can't think about the last
time that 92% of developers agreed upon
anything I mean we're still arguing over
spaces and tabs here so this is pretty
astounding and there are a lot of
reasons why that satisfaction rating is
so high and why developers are
continuing to bet on react native so
with pan responder you have an intuitive
way to handle sophisticated multi-touch
gestures you have style sheet a built in
CSS and j/s solution that allows you to
co-locate your styles with your react
components and dynamically up they
update that when props change with the
animated api it's easy to create
performant declarative animations to
enhance your UI and you also have yoga
which is facebook's cross-platform
layout engine now don't worry if that
sounds a little confusing right now all
you need to know is that it uses flexbox
by default for positioning your UI so
all of this was really exciting
and not too long after react native was
officially released nicholas gallagher
atwitter released react native web to
bring these api's and building blocks in
this awesome developer experience over
to web development so yeah when I first
heard about this I thought it was weird
too I mean you bring react over to the
web with from the web to native with
react native and now you're trying to
bring react native over to the web it
sounds a little strange but in reality I
think he was ahead of his time when you
look at the react ecosystem in totality
and where it seems to be heading it
actually doesn't seem that strange so at
the most granular granular level all of
the building blocks or primitives and
I'm going to use that term primitives
throughout my talk today all of those
primitives for the platforms on the
right are all the same they also share
the same api's for styling animation and
gesture handling so theoretically you
can write a pretty basic component using
react native primitives and have it work
on every single one of those platforms
just by changing the renderer that
you're importing from and in fact the
odd one out here is actually the web the
web's primitives are tied to the Dom so
instead of building our components with
views and texts we're building them with
divs and h1 tags and styling and
animation are not implemented in a
uniform way here so just to put it in
perspective
Daan primitives were actually
standardized in 1998 and that's the same
year that n'sync released their debut
album Don primitives are almost twenty
years old so it kind of like begs the
question why are we building modern
applications with primitives stuck in
the 90s our websites don't look like
this anymore
we need a new set of primitives that
better reflect modern application
development for the mobile web and
luckily for us we kind of already have
the primitives and api's we need with
react native I love this quote from
Jordan wok the creator of react in his
interview with reactive flux he
advocated for further unifying react and
react native for mobile app development
so how do we accomplish this goal and
bring the joys of react native
development to the web I actually think
this is a pretty difficult problem to
solve and it won't fully materialized
without some advancements in support
from browser vendors I mean who knows
maybe someday we'll get a react native
app browser ken wheeler built an
excellent proof of concept for one and I
highly encourage you to check out his
talk if the subject interests you and
I'm going to compile a bunch of links
into a github repository that I'll post
at the end so you can discover if you're
interested but and
till all of that happens we need to play
the hand that we're dealt so there's
actually a solution that you can start
building today and that's universal
components so first I want to explain
what they are and I also want to
introduce the concept of a universal
application because I think it's
important to contrast the two so
universal components are platform
agnostic components compatible with any
renderer and when I say render I mean
things like web VR sketch web native and
they're built with react native
primitives and api's so with Universal
components you separate the business
logic by platform but you compose your
features with Universal shared
components to share these components you
would publish them in an NPM package and
consume them in each separate
application which is probably living in
its own repository so you can kind of
think of building these Universal
components as writing once and rendering
anywhere and this is what we're going to
cover in detail today in contrast you
can think of developing a universal
application as writing it once and
running it anywhere you will need some
kind of intermediate layer between your
UI and the platform to determine the
render in a universal application
Universal applications are actually
built with both Universal and platform
specific components you can kind of
think of Universal components is a more
incremental approach to this goal so
we're not actually going to cover
universal applications today but if
you're interested I highly encourage you
to check out create react native web app
and create react XP app by NAT or dabit
and once again I'll post the link to
these projects in my github repo after
the talk so 3 libraries have emerged to
cover these needs and all of them are
excellent so the first is react native
web and that was developed by Nicolas
Gallagher at Twitter it's actually been
battle tested in production which would
are light they're new progressive web
app and second we have react primitives
and now that was developed by Leland
Richardson at Airbnb he gave a really
excellent talk on it at gene
react that you should check out if
you're more interested in this library
you also have react XP and that was
developed by Microsoft it's the newest
of the three and it's used by the skype
team in production if you'd like to see
a comparison of these libraries
explaining how they work and maybe some
of their trade-offs you should check out
the first version of this talk that I
gave and all my slides are clickable so
you can just follow the link below today
however we're going to focus on react
native web in order to build our
universal components it has the highest
platform parody of all the libraries and
what I mean by platform parody here is
how similar it is to react native I
actually ran the numbers react native
web supports 21 out of 43 react native
api's now that's things like stylesheet
and dimensions and nine of those 43 that
are unsupported are actually ios and
android specific now four components
react native web supports over half so
if you combine the two and subtract out
the irrelevant platform-specific api's
and components react native web supports
around three-quarters of what's
available in react native and i'd also
like to point out here that the way
react native web works is by acting as a
compatibility layer on top of dom
primitives so you can write react native
code that ultimately renders two divs
and spans so you're probably wondering
with a healthy dose of skepticism
whether universal components built with
react native web are production ready or
if this is just like another javascript
hipster fad but my answer to this
question is a resounding yes react
native web is already being used in
production by large companies today
twitter uses react native web for their
progressive web app twitter light and in
order for twitter to use react native
web and production they had to solve
enterprise level problems at scale like
right-to-left layout and also
accessibility and i also want to point
out here that this architecture is not
just for green field applications
twitter has been incrementally migrating
their component base to react native web
so it's entirely possible for you to
render your new universal components
besides your old ones we also used it in
production at Major League Soccer for a
real-time match experience on the web
and everything you see here is actually
built with the universal components so
it's really exciting so one of the
things that might have concerns you when
I told you that react native web renders
two divs and spans is that it's a huge
concern for accessibility reasons
because there is no way to preserve your
semantic markup for screen readers so in
fact they actually thought about this
problem there are built-in accessibility
api's to make sure that you can apply
the correct aria role to your dom
elements so a div that you intended to
be a button can be read as a div and so
on and so forth so that's really
important just to make sure that your
applications are accessible to all users
react native web is also performant
react native web stylesheet
implementation is on par or faster than
most popular CSS and J's libraries today
how it works is it extracts your Styles
into CSS it applies a class name for
each unique declaration and then it
memorizes them at runtime to improve
performance so a aside from all these
benefits adopting this architecture also
increases your team's velocity so
instead of developing a feature once
times the number of platforms you're
supporting you'll only have to write a
universal component once dramatically
increasing your code reuse you'll also
be able to standardize your third-party
libraries across platforms so instead of
having a calendar library for a web and
a separate one for native with a whole
nother API that you have to learn you
can just use one resulting in less
duplication of work
so just by configuring a couple things
in your build process you can actually
use react native libraries on the web
and the reason why all of this is
possible is react native webs almost
complete
your parity with react native as we
discussed earlier so let's dive into
some code so I can show you how to do
that so the first thing you're going to
want to do in your project is alias
react native web to react native and
here I'm showing this with web pack but
you can also achieve the same thing
through the babble plug-in module
resolver
so since react native modules are in es6
you're going to have to compile them
with babel and your web pack build in
order to use them on the web so to tell
the babel loader to process the react
native module you're going to want to
add the modules name as a negative look
ahead to the exclusion regex
and you'll need to do this for every
react native module that you plan to use
on the web so sometimes your react
native module will contain code that has
already been compiled in the case of
victory' native which is a charting
library victory shares a couple core
modules with the web however the react
native version points to the uncompelled
es6 code so if this is the case you're
just going to want to point web pack to
the compiled code instead so you're
probably asking yourself how do I know
which libraries are web compatible
surely not all of them can be so the
one-stop shop for determining web
compatibility is native directory and
recently I partnered with the folks at
Expo to add web compatibility features
to native directory they're curated list
of react native libraries so all you
need to do here is just check the filter
to find what you're looking for and
you'll find a list of all react native
web compatible libraries I just want to
give a quick shout out to Jim Lee who is
able to execute this feature super
quickly before my talk really appreciate
it and in the upcoming weeks I'm going
to perform an audit to add more web
compatible libraries to the list but I'm
not going to be able to do this alone I
need your help
so if you're using react native
libraries on the web that are
listed please send a pull request to add
it and if you're a maintainer of a
popular react native library you should
consider adding instructions to use your
library on web in your readme so all
right I'm gonna switch gears for a
second I know this architecture is very
new so I want to just answer some of the
questions that the community has about
universal components so recently I just
posed the questions and my followers on
Twitter to see what people were curious
about so let's start off by briefing
briefly discussing how to write render
agnostic components so a lot of the best
practices with react in general actually
applied to universal components you want
to keep them as small and focused as
possible and I like to do this with a
top-level wrapper component that passes
its data down to any amount of child
components so for this example and for a
couple examples throughout my talk we're
just going to be using a simple movie
card that passes down a movie prop to
all of its children so the way you kind
of want to think about this as you're
developing is think of your Universal
components as your primitives for
features in your application that you
can then compose based on the platform
so here we're rendering a poster a title
and a plot inside a card but these could
also be standalone components used in
other parts of your application so just
continue to think of reusability as
you're developing so with that being
said it's actually really difficult to
make all of your components Universal
sometimes you're going to need an escape
hatch and that's okay because we have
one so for small one-off changes you're
going to want to use the platform module
and this is great for things like
styling differences that don't affect
the overall logic of your Universal
component and you can just do a quick
switch case there now for bigger more
substantial differences you can use
platform extensions and you will need to
configure this in your web pack build
here's where this comes in handy you can
prefix your file extension
with the platform so dot web ksi OS jsv
rjs etc and web pack and the reacting of
packager will know where to resolve to
depending on the platform so this is
really great for things like linking
where the implementation varies
significantly between platforms you're
going to want to split that up with a
platform extension here so how do we
test our Universal components a really
helpful tool for this is react storybook
and if you're unfamiliar with react
storybook it's an interactive
development and testing environment for
your react component and what it does is
it removes the platform out of the
equation so you can focus on writing
your components quickly by developing
our components in isolation and keeping
them focused we can iterate much faster
I like to use the web version of
storybook to ensure that my Universal
components then work on the web so
another really cool feature is that you
can automatically convert your stories
to snapshots ingest so that just saves
you a little bit of development and
maintenance time because you don't have
to write them yourself alright so we're
developing our components in storybook
now what about styling so personally I
stick with stylesheet but you can use
libraries like glamorous native to if
you're familiar with more of a styled
components like API it's really up to
you but I would advise you to keep the
performance benchmarks that I mentioned
earlier in mind and just run them for
yourself on your own project so one of
the problems you're going to have to
tackle right away with styling is the
variation of screen sizes so luckily if
you're already following responsive
design practices with your web
components this shouldn't be too bad now
if you're designing a component for
desktop you can easily port those styles
over to apple TV because of the wide
screen size and on the flip side if
you're already developing styles for the
mobile web you can apply them to react
native so to determine the media size on
web you can use a library like react
media for media queries and
passed down a top-level media prop
either through maybe context or a
higher-order component and on native you
can use the dimensions API and the on
layout event handler to determine
whether the phone is in portrait mode or
turned over in landscape so then once
you have your props like media and
orientation you can pass them into a
function that returns the output from
style sheet creet just like you see here
all right so we can style our components
but what about fetching data so I think
this is a perfect use case for Apollo
and this is not just because I work
there I was actually a huge fan of
Apollo for universal components even
when I was working at major league
soccer so if you're unfamiliar with
Apollo it's a graph QL client that
manages data fetching and updating your
UI for you you can kind of think as a
Apollo as a universal data solution for
your universal component and it's used
in production by a number of large
companies ranging from Ticketmaster to
Airbnb it's also easy to integrate into
your app incrementally so you don't have
to refactor your whole application at
once you can use it side by side with
your existing Redux reducers for example
the reason why Apollo is a universal
data solution is it because it supports
any client including react native and
even sketch without any additional
configuration you just get this for free
and I think this sketch example is
really cool because now designers don't
have to mock-up data they can fetch and
design with real data which i think is a
really interesting development in the
space the other cool thing about Apollo
is that your components only need to
request the data that they need
now this aligns really nicely with the
modular philosophy of universal
components since the goal is to keep
them small and focused now with Apollo
you can write your queries once and run
them on any platform you can even
publish shared graph QL containers to an
NPM package along with your universal
component
use them side-by-side to compose
features in your application so even
though Universal components are really
useful there are definitely some
challenges because the ecosystem is so
new so one of the challenges here is
flexbox performance is still an issue in
WebKit and older browsers however there
is a workaround which I've listed here
so I believe this is fixed in the newest
version of WebKit but it's still
something to keep in mind as you're
developing your universal components
cross-platform SVG's can be difficult as
well especially for some more newer
experimental platforms like sketch
luckily a solution exists for web and
native SVG's by GoDaddy is a
compatibility layer that allows you to
use the react native SVG API to render
SVG elements in the browser now this is
essential for using libraries like react
native vector icons and victory' native
on the web which both rely heavily upon
SVG VR can also be tough for a number of
reasons so on it is that units of
measurement in VR are actually in meters
they're not in pixels unless you decide
to wrap your 2d components in what's
called a cylindrical panel then you can
use pixels so just keep that in mind as
you're developing for VR it can also be
really hard to normalize user input
events since there are so many to
account for you have things like gaze
tracking you have keyboards you have a
bunch of different handheld controllers
so that's another difficulty that you
might face when developing universal
components for VR also you're limited to
view image and text text for
cross-platform components so just keep
that in mind as well okay so that was a
lot of information to throw at you all
at once but if you take away one thing
from this talk even if you don't plan on
executing a cross-platform strategy any
time soon is this be open-minded to new
platforms and possibilities as our world
becomes more connected new platforms
will
possibly as a react custom renderer and
if you're a library maintainer you also
have to account for the possibility that
people may be using your libraries in
ways you never expected react is truly
becoming a platform for application
development so just try to think of the
bigger picture thank you all so much
you've been a fabulous audience</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>