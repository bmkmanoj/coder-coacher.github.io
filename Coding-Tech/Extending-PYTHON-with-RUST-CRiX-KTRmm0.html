<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Extending PYTHON with RUST | Coder Coacher - Coaching Coders</title><meta content="Extending PYTHON with RUST - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Extending PYTHON with RUST</b></h2><h5 class="post__date">2018-01-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CRiX-KTRmm0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so why am I at a Python conference
speaking about a completely different
language Alan Perlis the first recipient
of the Turing Award once said that a
language that doesn't affect the way you
think about programming is not worth
knowing this is a statement that really
resonates with me and for me rust has
been a language that has really changed
my way of thinking about programming
rust is a systems language that combines
the speed and the control of lower level
languages like C with the safety and the
expressive power of higher-level
languages like Python today I'm going to
be talking about why I'm so excited
about rust as a language I'll give you a
brief introduction to rust and how it
works and then I'll talk about two of
its features that I find most compelling
its type system and then the concept of
ownership and borrowing and then at the
end I'll talk about how you can use rust
alongside of Python to speed up critical
parts of your code
I've been using Python now for over 10
years and coming from a background of C
and C sharp I was really amazed with how
easy to use and how functional the
Python was and I've been I fell in love
with it as soon as I started using it
and it's been my favorite language for
most tasks ever since
Python has a mature ecosystem and
there's a library for doing almost
anything you can think of but most of
all Python has really welcoming and
diverse and passionate community that
I'm really proud to be a part of but I
think there are good reasons to learn
other languages and one is just to
deepen your understanding of and the
theory and the craft of programming and
of computer science the next is just to
expand your tool belt so python is a
great language for most use cases but
there are some cases where it's not
necessarily the right tool for the job
and actually I just recently read an
article by house about how sentry used
rust to speed up their sourcemap parsing
component so that's just one example of
when you might want to use a different
language but most of all I just find it
really fun
I think it's rewarding to learn new
ideas and to apply new techniques to
solve towards solving real-world
problems and rust has a number of killer
features that are I'm really excited
about and that's why I'm talking about
it today the first is that it has a
strong type system so it's something
that I've been noticing in dynamic
languages is that they've they seem to
be moving more towards static typing so
actually we can see that the
announcement of my PI at PyCon in 2016
and also the JavaScript world is
starting to move more towards static
languages like typescript
or elm and even with static type
checkers like flow rust also provides
memory safety and it provides freedom
from data races and these are both
provided by the type checker
and finally it also provides zero cost
abstraction so things that you're used
to in high level languages like
iterators or closures or even pattern
matching rust is able to have these but
without any runtime cost and it is and
it uses LLVM the compiler infrastructure
in order to optimize that away to almost
nothing so I really think that rust is a
great language so if you're already if
you already know Python and you're
looking to go deeper I would really
recommend learning it and even if you
had never actually end up using it for
anything I think it's concepts can apply
to your everyday work so let's start
looking at the language let's look at
some code here's a simple hello world
program and rust the first thing you'll
notice is a function called main this is
the first one that gets called when your
program starts and we're using the FN
key word which is like def in Python and
on the next line we have a variable or a
name binding called greet and we're
setting this to the value world and the
name variable is a bit misleading and
rust because actually variables are
immutable by default meaning once
they're assigned you can't change them
and the second thing is that this you'll
notice I'm not actually specifying any
types here the rest compiler has type
inference meaning that it can guess the
types for your variables based on how
they're used so on the next line we're
printing hello with a format string this
is very similar to pythons format
strings and this exclamation point that
you see is actually what's called a
macro so I don't have too much time to
talk about macros today but what they
are is if you see the preprocessor for
SI has macros but one advantage that
rust has over C's preprocessor is that
instead of operating just on the text it
operates on the parsed syntax trees from
the compiler which I think is really
cool and we'll see an example of that
when I talk about how to extend Python
so here's a more complex example this is
a function which returns the average of
a list of 64-bit floating-point values
and so here we're putting the types
explicitly on the function and the
reason is that rust isn't able to infer
or won't infer types across function
call boundaries so for functions these
are required and here we have
a mutable variable so a variable called
total that we're going to change as the
function runs we loop through each
element in the list you'll notice
there's no parentheses so it's a bit
different than C but it's it looks a bit
more like Python and then for each
element we add it to the total but first
we have to dereference it using the star
operator and the reason is that when
this function is called it doesn't
actually receive all of the data it
receives a pointer or a reference to
that data and when you loop through each
element you actually have a pointer to
each successive element and so in order
to get at the value you have to
dereference it and if finally we divide
it by the length and there's no return
statement here in rust the last
expression in a function is
automatically used as the return value
so this is what's called the declarative
style sorry the imperative style of
programming so that means that you're
telling the computer explicitly which
steps to take to achieve a result so
higher-level languages normally provide
abstractions that let you be more
descriptive rather than prescriptive
about how to achieve a task and the
reason that's good is that it frees the
interpreter to decide on how or the
compiler on how to actually implement
and how to do the execution plan so if
you were to write this in Python you
would probably say just give me the sum
of items and then divided by the length
and you can do that in rust
- so rust has these abstractions like
iterators so what I do now is I ask for
an iterator over this array I ask for
its sum as a and then I type annotated
with a 64 bit floating point and then
divide by the length like before so this
works and it's actually the same speed
as the other one and the benefit of this
of writing it in this declarative style
is that it's also easier to parallelize
and rust actually has this library an
awesome library called rayon which
provides optimistic parallelism what
that means is that the decision on
whether or not to parallelize is made
dynamically at runtime based on the
utilization of your CPU cores so all
I've changed here is that I changed it
er two parallel adder and now this will
run in parallel
I'll show you one last way to write a a
verge function and that's to use reduce
some of you might know that as the
function that was removed in Python 3
but in rest it's called fold and so it
starts with a single value and then it
and then we pass it an operator which
says how to take successive values and
combine them into one so this is an
example of a closure if you're more
familiar in Python that's called a
lambda and this has the same result but
the difference is that in dynamic
languages if you use a lambda or in
Python if you use a lambda that normally
adds runtime overhead because the
interpreter has to call back into your
function for each iteration
whereas in rust rusts is able to
optimize across this function call and
inline it automatically as appropriate
and so this will take the same amount of
time and just to prove that to myself
and to show you I actually wrote all
four of these versions and benchmark
them so you can see that the three
sequential versions all run in the same
amount of time and the parallel version
ran faster but also it sometimes ran
slower and the variance was a lot higher
so that's something I'm not completely
sure why it happens yet but something to
look into so that's a quick intro to the
language so now I'm just going to talk
about types and traits and rust
so we've already seen the primitive
types the 64-bit floating-point value
these are the other types that Rus
provides I'll just mention that rust has
a built in boolean type which i think
was a really good decision and it's also
used some rust forces arguments to
conditionals to be boolean so there's no
concept of truthiness or false eNOS like
in Python and C which doesn't have this
boolean value there's different
conventions on what represents success
or failure sometimes it's 1 &amp;amp; 0
sometimes it's 0 and negative 1 and
that's led to a number of security
issues in high profile cases so rust I
think made a really good decision with
with that and characters are actually
for byte Unicode code points and then
Russ also has a number of more complex
types that you can build out of those
I'll just point out that arrays
something that I found interesting is
that these are stored on the stack and
the length of the array is actually a
part of the type information which means
for arrays on the stack rust can check
at compile time for certain bounds
access and then arrays of different
lengths won't unify
but the main way to create more complex
data structures and rust is by using a
struct so this is similar to how you
would do it and see you here's an
example of a rectangle with two fields
the width and the height and strux don't
have methods associated with them they
only have the data and in Python
normally you're used to using classes
where you can put both the data and all
the methods and functions associated
with it this is an example using the
outer library for Python which if you're
not using it I highly recommend and
there's here's how you would do the same
type of thing in rust so here's the same
struct it's a person with a name as a
string and then separately from that you
create what's called an inherent
implementation so this is a collection
of methods that will be available on all
instances of this person type and a bit
like Python the methods take an explicit
self parameter so for those of you
coming from object oriented languages
you might be more familiar with classes
as the way to achieve the three
principles of Oh P which are inheritance
encapsulation and polymorphism but rust
doesn't really have classes what it has
instead is something called traits
traits are a bit like interfaces in
other languages or if like type classes
in Haskell they're used for a number of
things so they're used for operator
overloading so to customize how addition
or subtraction works or other operators
they're also used as indicators of
behavior so if a type can be copied or
sent between threads safely those that's
used as a trait that's done by
implementing a trait
there's also used as bounds on generic
methods and you can also use them for
opt in dynamic dispatch at runtime so
here's how you define a trait use the
trait keyword give it a name so this
says any thing anything implementing
this trait needs to have this name
method that returns a string and it's
not like duck typing in Python you
actually implement explicitly need to
implement this and here's how you would
use that trait you use the same employee
word and you're saying you're
implementing the trait for that type and
then you put something which has the
same
signature and you'll notice that here
we're actually returning self-named
clone and the reason you need this
brings me to the second thing about rust
which is the concepts of ownership and
borrowing so so for me this was the most
difficult part of rust to learn and to
understand but I also think it's the
most interesting part of it and it's
really I think a major breakthrough in
language design and the the running joke
is that you'll be fighting with the
borrowed checker for your first couple
of weeks of using rust but I think it's
worth it once you get past that and also
this is what really provides the
guarantees of safety and of data race
freedom in rust so I think it's easier
to understand with an example here's a
vector so we're creating a this on the
heap the elements are stored on the heap
and then we have a pointer to it and V
has ownership of that resource so as
soon as V goes out of scope and as soon
as this function returns that data on
the heap is freed so this isn't like C
where you need to manually call free for
data that you've allocated and if I
assign this to another variable like W
that ownership has been transferred to W
and if I then try to use V afterwards
we get an error and that's because that
ownership has been moved and we can't
use that value that variable anymore
so here's a function called print it
takes a vector and prints it and so here
if we if we call print this call
transfers ownership into the function
and when print returns that data is
freed which means that if we try to call
print again with that same variable
we'll get an error so if we want to fix
this
you'll notice that all we had to do was
change this and add an ampersand so this
means that we're actually taking what's
called a borrow we're gonna borrow the
value instead of transferring ownership
so now when we call this and pass in a
reference instead with the ampersand
we're not giving it ownership we're
giving it we're lending it we're giving
a least this variable and then when it
returns it doesn't get freed because
this still keeps ownership which means
that now we can call it a second time
and this is okay if you want to have a
function which modifies the reference
that it's passed you have to explicitly
say that it takes a mutable reference
and also you have to pass a mutable
reference here so borrowing follows a
number of rules that are what guarantee
the properties of memory safety the
first is that mutable borrows are
exclusive once you have a single mutable
borrow to a object you can't have any
other active borrows at the same time
and the second is that a borrow can't
outlive the object that is being
borrowed so just to show you two
examples of that here's the first one
that if you have a number of borrows to
object as soon as you try to take a
mutable one because those are still
active
this is forbidden and rust will give you
a compile time error and here's another
example with a what's called lifetimes
so if you have this outer variable and
then inside the scope you have a
variable V and you try to assign it a
reference to of to that variable to the
outer as soon as this goes out of scope
V is going to be freed and so this gives
you an error saying that V doesn't live
long enough
so I've kind of I think it's probably
too much to cover in one talk all of
this you could actually probably do a
whole talk just on this subject it's
based off something called a concept in
logic called sub structural logic and
for those of you who are familiar with
the curry Howard isomorphism which is
this correspondence between types in
type theory and proofs and propositions
in logic this is a type system known as
a fine types and it's actually an active
area of research to prove that
this system is consistent and safe so
I'll get to the main point of the talk
which is how you can use rust to speed
up your Python code there's two options
really for doing this the first is by
using CF Fi and calling out and making a
library and rust that follows the C
calling convention the benefit of that
is that it will work with any
interpreter but the problem is that your
rest code won't have access to the
interpreter objects and the second way
of doing that which is what I'll talk
about today is by using the C Python
bindings and so the benefit of this is
that you can actually access a lot of
the interpreter internals however you're
limited to the C Python interpreter and
to make this more exciting I'm going to
do this as a live demo and hopefully the
demo gods are with me today you see my
screen so I have a function here in
Python called count doubles and what
this does is it takes a string and it
looks for the number of pairs of
characters that are identical so 2a is
in a row or two B's in a row and so on
so I have a variable called total and I
loop through the string with zipped with
the string offset by one so this gives
me pairs of characters in the string and
if they're equal I increment the total
and then I return it so this is a bit
slow in Python there's a way to speed it
up which is by using a reg X which does
the exact same thing but maybe you want
to make this even faster and to do that
you can actually write a pipe extension
module so let me show you how to do that
so the first thing I'm going to do is
I'm going to create a new crate or which
is what Russ calls packages
and this is using cargo which is the
package manager for rust so what this is
created is a folder here and we have a
cargo tunnel file this is a bit like
setup I in Python and so this is where
we specify the dependencies so first if
I wanted to just pull in the latest
released version I could say this of the
C Python bindings but to get the latest
and greatest I'm going to pull this in
from github
and the other thing we want to say is
that we're building a shared library so
I'm going to give this library a name
this is what we import it as from Python
and then I'm gonna say that I'm building
a crate whose type is a dynamically
linked shared library so that's all we
need for this file and then rust or
cargo has also created this file called
Lib and this is where we put our code so
the first thing we're going to do is
pull in the c python crate and we want
to use all of the macros that that
create defines and now i'm going to pull
in a couple of types from that crate the
first is python and the second is pi
result and i'll explain these in a
second and now i'm going to build the
function so this is count doubles this
is what's going to count the number of
pairs of characters in my string the
first argument is going to be this
Python object the second one is the
string and this returns a PI result so
this pi result is the object that lets
us raise python exceptions if we want to
and it's generic over this unsigned
64-bit number so then we're going to
write just the function but what I want
you to notice is how similar this is to
the Python version so I have the total
and then I loop through the pairs of
characters in the characters of the
string and then I zip this with the
characters offset by one so this is very
similar to the zip call in Python and
now if those two characters are equal
I'm going to increment the total and I'm
going to return well I don't need to
return I'm gonna say that there was
everything was okay and returned the
total so this is all we need this is
just ten lines of code and now we're
going to make this import a bowl from
Python eliezer and this is a macro that
the C Python binding is defined we pass
it the name of our module and then the
name of the function for python two and
three
and then the last argument here is a
closure which receives a module object
and lets us modify it and add different
methods to it so what I'm going to do is
I'm going to add function to this module
call it count doubles you're supposed to
tell me if I make a typo and we use this
PI FN macro which builds the Python
version of the function
so here's count doubles and then we also
give it the type that we want it to be
the arguments and that's all we need for
this and just say okay so that's that's
all we need now if I go back to my
terminal I go into this folder and if
everything went well this should build
the package for us and while that's
going I'll just explain what this Python
object was that I mentioned so this is a
reference to the Python interpreter and
there's something in Python called the
global interpreter lock and any access
to interpreter internals needs to be
holding this lock and the way that rust
achieves this or that the rust bindings
achieves this is by having using the
lifetime concept and saying that as long
as you have a reference or as long as
you have this object alive
you have the interpreter lock so this is
a really nice way of getting around
having to do this manually and see ok so
this is done so you'll notice that
what's been built in here is this
example shared library so what I can do
is I can copy it
to example ESO and this means that it
can be found by Python and now if I
import example it's just a simple Python
module that has this count doubles
function and I can pass it a string and
it'll tell me how many pairs of
characters it found inside that string
Oh oh sorry
better okay so yeah so this tells me how
many times there were pairs of
characters in the string and just to
show you that the bindings will also do
automatic marshaling of the types so if
I try to pass this something that's not
a string I get a type error and just to
show you the comparison in terms of
performance we can compare all of those
different versions of the count doubles
function so this is benchmarking all
three versions and we can see that the
rust one took about here's the mean took
about two milliseconds on average the
reg X took about 30 milliseconds so 12
times floor and then the pure Python one
took about 16 milliseconds so about
thirty times slower and I ran this test
in pi PI just to check and it's still
about five to eight times slower than
the rest one so just to wrap up
you
okay yeah so just to wrap up I think
rust is a really good way to speed up
critical parts of your code I encourage
you to take a look at it I hope I've
piqued your interest and one of the rust
communities big focuses in 2017 is the
story of the integration with other
languages like Python so expect to see a
lot of improvements in how cargo and
setup tools work together and these are
just some references that I would
recommend taking a look at and that's it
we have about ten minutes for questions
so please put your hand up and I'll get
you the mic after or in sequence here
thanks for that I'm just wondering in
your rust module right at the bottom as
you are hooking it up into the module
you quietly put a question mark at the
end of it yes I can explain so there's
the arrow type and rust the rust doesn't
have the exceptions like python does it
has this error type this question mark
is new syntax in rust 1.14 I believe for
1.13 that was just released and what
that does is it basically checks for an
error and if there's neuro it raises it
up and returns it as a and courses it
into an error of the appropriate type so
it's a bit like try catch but it's used
so often that they added specific syntax
for it hey so um Russ has a bunch of
like specific stuff like borrowing in
order ship that Python doesn't have so
like I see in your function count
doubles you're taking uh you're taking
uh you're not taking ownership you're
borrowing it so what happens if you
don't borrow and you take ownership so
like from Python you have to think about
that stuff like oh well I'm calling a
function I can only call a function
that's taking a borrow of my variable
not ownership or something like that you
have to think about that kind of stuff
when you're calling Rus functions from
Python so you do have to think about it
a little bit so the binding is what they
do is they'll figure out that ownership
implies that you have a reference count
basically so the c python interpreter
uses reference counting as its way of
doing garbage collection and what you so
yes if you take a borrow then it'll
increment the reference count and then
or i don't think it needs to increment
at all but if you're not taking a borrow
I think the bindings will actually check
that for you and make sure that as those
are not handled appropriately so use
something to be aware of but what's nice
is that the compiler will check on these
lifetimes and so you end up having the
same type of safety properties there
still some things to be figured out
rusts is looking into how you could
write custom garbage collectors and how
you could integrate those with other
languages garbage collectors so that's
one of the actives like topics of
research and that's ongoing help yeah so
I noticed and most of the magic metals
in Python are economic terms and they're
objects yeah does that apply to all
objects or just some of them for example
a zip which is a function in Python is a
method only in rust houses or do all
objects have such mittens so this is a
method that's called the same thing in
rust but this is a method that's a part
of native rust iterator so you'll notice
here what I'm taking isn't a PI isn't a
Python object I could do that if I did
this and then I would have access to all
of the methods on the Python methods on
this object but what I'm taking is
actually this reference to a string and
what that means is that the bindings
will marshal this into a native rust
string and it doesn't do a copy it
actually converts it to utf-8 and then
this string is a pointer into the Python
string object and the characters is a
method on rust strings that returns an
iterator over the characters and then
zip is a method of rust iterators all
iterators in rust yeah does that help if
I want to
distribute a Python package that
includes rust module as a source
distribution now what will my end
consumers need to have to be able to set
that up so I've been doing a little bit
of work on this you they'll need
obviously the rust compiler if they're
going to compile it from source there's
a setup tools package called Russ txt
which tries to make that as seamless as
possible
so you can just have a setup that PI
file and say that there's a rust file
that gets compiled I think that can
still use some improvement but ideally
it would be just as simple as having a
regular Python package adding a little
rust code and adding something inside of
Pi and then distributing that to anybody
who has the rest compiler installed yeah
that are you currently using rust right
here are you currently using rust at
work or personally and python together
or at work and python together so we
were I work at Survey Monkey and we
mostly do web I work on the enterprise
team and we build web applications and
for the most part I think Python is
actually really good and good enough
actually for for that so there hasn't
been any cases where we need to have
something that's a lot faster this has
been more of a kind of hobby and just a
passion that's something that I've been
excited about and maybe we can use it if
something comes up where we need
something that's faster
any other questions for Samuel yep okay
well thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>