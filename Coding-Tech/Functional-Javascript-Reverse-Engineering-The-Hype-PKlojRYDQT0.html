<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Functional Javascript: Reverse Engineering The Hype | Coder Coacher - Coaching Coders</title><meta content="Functional Javascript: Reverse Engineering The Hype - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Functional Javascript: Reverse Engineering The Hype</b></h2><h5 class="post__date">2018-04-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PKlojRYDQT0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right cool so we're gonna talk about
functional JavaScript today but before
we dive into monads and get into some
complicated stuff I want to talk about
just a little intro about learning to
program as a working programmer which is
I don't know I feel like I something I
don't talk about enough because it's
like and it is like simultaneously the
most exciting and stressful and anxiety
inducing thing in the world to be
working programmers but join you for a
long time and then have to try to learn
an entirely new way of programming to be
a beginner then and so it's a lot
different like if you've never written a
lot of programming before and you start
to look at like you don't doing things
in a functional way I will say that it's
probably easier for you because you just
you don't know any other way and you can
just kind of like kind of quick build
and go from there does this program look
familiar to anybody not those specific
syntax but I've probably written this a
hundred times
and like every intro to object-oriented
programming class has some sort of
variation on this where you you know
they try we're trying to demonstrate
inheritance here so we have a base
animal class with some properties and
some methods and and then we do do
something like exhilarating and amazing
like create a dog class that can
override some of these methods and if
you were able to stay in your seat with
all the excitement than that you know
you can extend it even further and
create a person class that does things
like we tell it to walk it complains it
says I really have to and so like this
is how we learned how to program right
and but when you think about it now like
does that get you fired up as a
programmer like using object-oriented
techniques but you get like who wants
the leads this talk right now would go
like write code because yours like
motivated by that it doesn't happen at
all right but at the time we didn't
think that it's because we didn't we
didn't really know anything right and so
the reason why we went on to build these
amazing and complex systems in object
orientation and the whole reason why
you're here today is a working program
is because we put in the work we would
go home and you didn't know anybody like
this is how I build programs and so we
trashed and we built things we built
real things that we ships and stuff and
that is the whole reason why it became
valuable and why hopefully we get paid
to do the work that we do every day
but hidden under those like that tiny
original example we're some big ideas
like inheritance and polymorphism that
the instructors trying to get across
it's just now it's just it looks silly
to look back at it so these are big
ideas but we put such small examples
right and I think the same is true when
we try to learn a new paradigm and this
is a common thing that they'll show you
when you learn a functional approach and
as a working programmer so if you're at
the beginning like old Cardy this is
kind of a cool thing but as a working
programmer now you're like cool this
literally helps me do nothing as part of
my job and so we don't get excited right
we have a higher bar now and it's a lot
harder to get us to change our minds
about little writing things and it's
funny if you ever ask somebody Oh have
you used X framework or library how many
people have heard the answer oh I've
played with it all right I got toyed
with it that's like the new you put it
on the resume when you've played with it
which is like a weird thing because it
just pretty much means you typed up the
example but never used it in a real in a
real-life setting and so and that's
because we did it but we didn't really
see how to apply it in the real world
and there are some amazing function
logic script
tutorials and books like functional
JavaScript by O'Reilly is an amazing one
but I and I think you have to start
there but I think there isn't enough
from going in the reverse angle so what
I want to do is kind of like reverse
engineer the hype to talk about building
a whole system in JavaScript instead of
starting from the ground up and so
hopefully it's just a little bit of a
different take but adopting big ideas is
hard right this is the reason why we
toyed with that functional language or
framework and didn't actually start
doing it is because how many people have
seen this book before yeah I figured
you'd have something like that but this
is Douglas Crockford and so he actually
gave a talk a year or so ago and he
called the better parts which was pretty
interesting and he talks about this idea
of adopting big ideas big new ideas and
he says it's way back when it took a
generation for us as the programming
community at large to agree that high
level languages were a good idea which
is funny to us now because like you
could just picture like it's some
assembler some assembly programmer just
like why see like really do we really
need to have like that level of sort of
sophistication in our abstractions this
just seems like a waste like why would I
waste my time to learn a whole language
for that now that's obviously it's you
consider that silly right and then it
took another it took another generation
to agree that objects were a good idea
so when we consider to be you know how
we build apps today was once thought
about it's just unnecessary right like
we had we had programs with functions
and we could do all these different
things and so like why would we go
through the trouble of like creating a
dog that hurt space animal like I just
don't see them but now we see it sort of
take it for granted right because we
other generation that adopted that and
then he says it took two full
generations to agree that lambdas work
good idea and instead of that but now
lambdas are in every language there in
the net these core object-oriented
languages are now everything has lambdas
right and so he makes the argument that
lambdas took two generations because
they had the best idea in the history of
programming and so I didn't really
follow that logic
maybe we just wanted to get it right
especially twice as long not really sure
but what I really took away from this
was his next quote he says the good in
order for us to wait for the next big
thing to catch on we need to wait for
the previous generation to retire or die
before we can get critical mass on the
next idea I'm this is a quote I be sure
I got every word right because when he
said this the audience started clapping
and laughing and they went crazy and I
was just like wow this is getting dark
yeah how did this happen so quickly
and so I understand the sentiment like I
know what he was going for there and
it's the same thing it's like you get
home from your job you don't want to
learn a new thing or you're interested
in it but it's just it's a lot of work
and so we'll wait for the next people to
do it and I'll just hang on to my my
languages and doing things the way the
way I do it but I I'm going to take a
different approach I'm gonna be a little
more positive and like we're here a lot
of us are here on a day off or like we
couldn't work we're taking our time to
further ourselves professionally we are
not the programming community at large
this is a group of people who is here
today interested in making themselves
better and so I think that for us to
adopt big ideas the real thing we need
to do is we need to make real apps with
it because we need to see it all the way
through instead of that little utility
function we need to see the end result
and so that's this is what I'm going to
talk about today
so here's the agenda I'm gonna briefly
cover why now in white JavaScript just
because you're gonna have you you're
gonna get confronted with this all the
time so let's just squash it then we'll
talk about functional patterns for
relapse this I hope to be the meat of of
this talk today and then lastly we will
talk about revisiting the mental model
because we're sold on object orientation
as being the only way of doing things
because it models the real worlds
because of that mental model where we
can make the relation of it is this
thing in my program that balls the thing
of real life and so I know how to
program it and we'll just talk about how
or if that changes and we've to start
unfortunately with is public public
service announcement that this is a talk
by a practitioner for approach for
practitioners we're not going to talk
about math or like any sort of like
crazy high level concepts because that's
been covered a because it's been covered
enough by everyone else and be because
it would be disingenuous for me to do
anything else I'm building real apps and
I want to build apps in this way and so
that is what I'm gonna talk about and
it's unfortunate that we even have to
have that as a PSA public service
announcement because for reasons like
this right uncle Bob Martin who's like
this guy's no slouch and he knows what
he's talking about this is the arrogance
of some functional programmers is a
significant barrier to entry right so
god forbid you post a question about
functional JavaScript in a forum and you
just get torn apart by some of these
functional guys and as such as him this
is the crater of lodash says you know of
course like this mirrors my experience
to then this guy knows what he's talking
about he is not you know some beginner
person and if these guys feel that way
when you first start going down this
path I need you to be aware of these
people because this is forever I this is
just every programming forum ever per
and there's a million beams like this
but I really like this one not even a
soccer fan but like particularly look at
this like look at this guy's face he's
just happy and these guys are just like
look at the skis trying to write
functional javascript start even a real
language it's a toy language like why is
he wasting his time but every time
someone does that to you I want you to
feel like this guy right cuz this guy
just shipped something he just shipped
the feature something is real in
production he's just gonna go have fun
while these guys are just gonna hang
back
whine and complain so realize that when
when haters hate on you in the forums or
whatever you feel like
oh I'm not smart enough through
functional programming because these
guys say monad over and over again it
has nothing to do with being smart
enough it's just this is this is the the
world that we we live in sometimes so so
then why bother right if it's like this
I just made it something this credibly
harsh landscape so why do we want to do
functional anyway
Dave Thomas is a guy that I've I've sort
of I've looked up to in my career he's
that you wrote the pragmatic programmer
and so he says there's no longer any
debate the future has to be functional
immutable data and it has to be
concurrent it's the only way to grow and
then uncle Bob Martin again it's almost
certainly true that functional
programming is the next big thing I like
this one just cuz Uncle Bob Martin
offered the solid principles like to me
he is the object-oriented guy and so how
many people here feel confident and
certain that the JavaScript libraries
were using today is going to be what
they're using next month like we don't
have certainty like it in front of us
but there's a whole lot of certainty in
these two sentences the future has to be
functional it's almost certainly true
and so why how can they have so much
confidence in this does anyone know what
this is
he'll be surprised I didn't it's Moore's
law right that's pretty good
yes it's about that and so this is just
it's the trains just kept going up over
time and talk about how it doubles every
two years and I looked at this I'm like
this is a pretty good slope like this
with my bank account I'd be pretty happy
but the even more interesting thing is
if you like dive into the data here
right so it's like we started off in the
70s and 80s going from two thousand to
ten thousand which is like a huge dump
and then we go to a hundred thousand a
million and then all of a sudden we're
at two point six billion right so this
is impressive but then you realize this
is but even a little your graph this is
mental we can like read the lettering
and stuff if we actually plot it
linearly this is what it looks like this
is the same time span in the same actual
data plotted linearly has much more
impact for me for JavaScript
single-threaded like why why do we care
about transistors or anything like that
and so just to be clear the argument
there is that in order for us to grow
going forward and skin to reap the
benefits of Moore's law we're going to
have to program it in a parallel and
current way that is the identity
argument that we're just otherwise we
won't be able to take advantage of of
all that new power but the reason why
javascript is capability meets
opportunity
right it's like I'm such a sucker for
sports analogies I feel like this is
such a sports thing but the opportunity
is that it is that the future has to be
functional for up for every other
language right and so then you have this
little tiny engine that could in
JavaScript that's like they did one
thing extremely right and it's the best
thing about JavaScript is its
implementation of functions it's just
got everything right in this regard so
it's the capability of a language that
just happens to nail every the it does a
lot of things wrong don't get me wrong
but the things that it got right all
lend itself towards this functional way
of programming and then there's also
this other side benefit that I'm not
going to spend much time on but
familiarity is a big thing otherwise we
wouldn't be writing classes in es6 the
only reason why these exist is for
familiarity for Java programmers and
c-sharp programmers but what happens
when the feature is functional
familiarity is not going to look like
this as much anymore
and so having familiarity in JavaScript
this is a much lesser argument I'm not
gonna this is not a building block of my
argument here but it's just something to
observe but I promise that we talk about
relapse so enough of the intro I want to
talk about I created a demo app and it's
I swear it's it's the example app that I
recreate every year but I record from
scratch so this is a stock ticker and
the way the reason why I find it
interesting is because you have many
different types of concepts that you can
demo so this is actually like there's no
database especially lives it's like live
streaming data it has so you have to
solve like the domain problem you have
to have queries that are live updating
on the write a whole bunch of rendering
things that are interesting in a nice
small package so we're going to use this
as our demo app today so at first
want to just kind of take a look at this
thing as from a holistic perspective
this is the real app running
let's push this up oh that's not what I
wanted
all right so just show that it is a real
thing this is the operating
locally and you see Cho just behaves as
expected we've got a whole bunch of
stock transactions coming in we have
opening prices which is just like the
you know the price that each stock
started at and as you see as we get more
and more data and we're able to crunch
some of these more advanced calculations
that will sort of flesh out on the right
so I'll just stop this from now and so
what I want to do so the source code of
that is completely available because I
wanted people to be able to like poke at
it and kind of look at what it looks
like but I want to talk about this
entire UI container and mainly cuz I
just want to get this out of the way
functional you eyes there's a huge
problem and it's that if anyone was here
last year
I won't rant about the skin but the DOM
is stateful and imperative and that just
flies in the face of all the functional
techniques that you're going to try to
use it's going to undermine your
functional quest the only way like
unless you're just using like lodash
isn't like you are functional paradigms
are limited to your utility folder
you're gonna want to solve this problem
and by having a functional rendering
layer so for me that's react I'm known
as the right guy law I spoke about a lot
last year but this talk is not about
react I promised I wouldn't be that guy
today so there are other there are other
options as well LM is like one that's
huge right now on a on the come-up I
should say and there's plenty of other
implementations too so if you want to
use these other ones be my guest I'm not
gonna talk about that today let's talk
about the surrounding functionality
around it but when I do have to render
reference a render layer I'm gonna use
react just because that's what I know
and love so but this is as long as your
rendering layer can implement this I'm
happy so it should do I layer should be
able to take in all of your app state
and be able to render out the same UI as
long as it's the same state keeps coming
in and there should be no surprises
there that's that is what we'll call it
functional UI and we're getting there
right so like this is the new version of
react that just landed I'm pretty fired
up about this I mean this is this is
everything we want with no boilerplate
this is a real component where's this
each row in that table is a transaction
which just takes in the transaction
model and you just return the
representation of what you want to be UI
to look like so that's this is why I
like react so much but that's it Tory
Act
what I want to do is dive into the other
parts of the app I want to talk about
this first really just because this is
the bulk of yep this is where all of our
app data lives and I also think that
this is where this is where I tripped up
at first and so I'm hoping to kind of
throw some minor cautionary tale in
there and also just kind of point at
functional domain logic and how to set
that up in sort of a reliable way so
this is the data this is all the data in
your app and we'll first talk about
collections and models and we'll talk
about them in those terms because that's
the easiest reader to understand I think
it's fair to say that every wonder
stands of collections and models when I
say that so when you think about that
table that is just that's that's the
collection of each row being a model
with only one caveat in that it's all of
the data has to be immutable and you'll
hear that throughout the presentation
and we'll find out why this is important
later I use immutable j/s I happen to
love it and use it every day but you
don't have to there are other ones too
and you can also just mop you take plain
JavaScript objects if you want I just
think that takes more discipline and
you're you could it could be more
frustrating to you at the beginning so
if you're just starting off I think that
this is a more friendly way to go so
from the collection perspective what
this gives you is gives you like real
data structures which is pretty cool
list stack map order map set ordered set
a whole bunch of ways of organizing your
data that map that matches your business
model and it's easy they behave just
like you'd expect what's more
interesting to me our models mainly just
because this is usually where we build
our applications around models but first
a little side note this is a term I wish
I could remember the origin of it but
this term primitive obsession has been
in my vocabulary for a while from the
old object-oriented literature I used to
read and it's I couldn't remember the
quote slide
paraphrased but it's the idea that your
app or your domain model no matter how
complex can be described by solely
primitive values at the language level
so this is things like okay I have a
transaction what it should just be a
plain JavaScript object why would I
bother like I could just it's a key
value and a list of it is just a race
and that's fine at the
getting but like this we're going to
want to add behavior and different
things to that and if you don't have a
home for it it's going to end up leading
out through all different parts of your
app and this is where the driving
principles come from to kind of reel
that in and I'm also going to say that
the supplies the library level as well
so we have maps list sets stacks etc in
immutable but I don't want you to just
think like okay that's cool so I'm just
gonna do everything that way it will
fall into the same exact trap and this
is exactly what I did and salsa was a
second trap because what I did was I
fell prey to
one of these this is a post read by
David Nolan who is the creator of home
and he's pretty active in the closure
script community and when I was first
getting into functional JavaScript I
read this and I was like really inspired
by it and so I'll just read it so you
can hopefully see where I got lost
so it's actual tangible data in home he
says object-oriented programming as a
paradigm has many real benefits but one
of the worst plagues that has inflicted
on programming is obscuring data
functional programming is not a silver
bullet but its emphasis on unadorned
data is a guiding light no bottles so
that no models part is just like yeah
he's right you know like we have a map
and that's like it's similar to a
JavaScript object and like I can model
my entire domain using that key values
and then a list is the same thing as
array like yeah this is good and me I'm
sure I'm missing something here but I
think it's a trap if you're going from
object-oriented enormous georgian-style
and you go directly into that because
you will end up with you're a business
model your business logic living in a
bunch of different places and you'll
just start to be like okay wait I need a
real I need to like real something in
here I need a home for all this
functionality and that's where immutable
records come in and they're just like
other models except you can't change
them which is kind of funny because
people think of models as being the home
of your business logic with some helper
methods and that's where you change them
you call methods you update the values
on it so this will seem strange at first
but when you actually look at the code
that it takes to create an immutable
record it's actually the weirdest thing
about this for you will probably be the
es6 syntax not the actual record but you
just essentially you give it some
default values and then you just can
provide some helper methods over it if
you want to find out if it's a loss if
you can put your business logic here and
I get that you can put this in a folder
with functions somewhere else but I
promise that coming from another
framework or something like that this
will feel more at home to you you'll
know where to put things and things will
it be less strewn about and you'll be
less stressed out just by having an
answer for where things go
and so what are the benefits of using
immutable records instead of just
instead of just like a regular model
like what kind of juice pack four
bottles well first you can trust them
and this matters war and it like a
concurrent paradigm we just like hand
off your model to link if anything
changes that you're screwed for like you
can't you can't trust it in JavaScript
you just get the mind of benefit I was
like you can pass this object around
your entire application and not worry if
anything just mutated it can't and you
can count on knowing that you can
accurately find a source of bugs because
understanding that nothing in your core
domain can modify these objects and that
really helps you you know think down but
I think the more important but weirder
concept at first will be that you're up
and Trust immutable objects is that
something weird that your app can trust
them it did to me when I wrote it so so
what do I mean by that well let's look
at a different part of the UI and talk
about where that comes into play so as
opposed to our core data which is our
models and collections we've got these
alternate views right the opening price
the RSI calculator and you'll see the
average loss calculator these are sort
of queries on our core data right
they're functions that you would
pressure coordinated to and you sort of
like and you can like process it and
transform it so I'm gonna talk about how
we do that sort of thing in in the
functional world since our models are
immutable and we need to that we can't
change them to have something head them
off to something else to do this well
that's pretty easy so if the last part
was the data this is the functions part
of our domain with all these services
and queries just to give them a name but
you already know what they are a service
is just a stateless function that
accepts insurance forms of Yubel data to
fulfill a business operation so if you
used to have an order model and a method
that says place or finalize or something
you you can do that on an immutable
model because you can't change it so you
just plug that thing right off and you
have a function called finalized order
or create order and you pass your model
into it it will transform it in return a
new version of that model that is that
is now updated and finalized that is
what we'll call services queries are a
little bit different they start off
setting the same they're stateless
functions that accept immutable data and
they transform calculate reduce or
repurpose data much like that sidebar
we're just taking a different view on it
and there's a pretty the big difference
here is like we want to really actively
cache queries whereas like a service you
don't really want to be you still kind
of wants to let the service handle what
it's going to do with business logic but
a query when you're dealing with the
middle data but your functions if you
receive the same object you know that
the city it's gonna be the same end
result no matter what that is a
guarantee that we get and so we want to
be able to short-circuit that for
performance so just to be thorough I
want to show you what one of these looks
like this is actually the function that
calculates the initial stock prices
there's nothing interesting really here
it just maps over the stock objects and
it transforms it to an object that looks
like this and we just pass this down to
the UI layer and it just goes how to
render it there really nothing
interesting but more interesting one is
at the RSI calculation and at first when
I created this screenshot I I don't know
I just like it from a distance it looks
just such like spaghetti code and it
just feels like you're gonna be going
backwards and but I promise you I assure
you that it's not this is actually a
module that has about four fewer
functions in it that easily easily have
been broken out that are just pipeline
together and so I want you to think
about if you want to think about who
here is kind of like new to immutable
data
so there's more people and I thought
that are kind of kind of sold on it but
if you want to kind of understand how
this works
imagine that you worked at this company
that created this app and before this
app was created you it was your job to
manually do this right so at the
beginning at the at the beginning the
week you're handed this folder is full
of data and it's like here's a list of
five socks and I need to find out what
the RSI is on on this by the end of the
week how would you go about doing that
you would say all right so let's figure
out what stocks are there so we first
will pull out which stocks that I need
to figure this out for and then let's
figure out the average loss and gain for
the last two weeks because that's what's
needed and then let's then from that we
can deduce the RSI and that's pretty
easy so you write up your report you'll
be running a desk for your boss you come
in on Monday and your job depends on
tation and just being accurate and then
you come in and your boss says I love it
their report looks great I've modified
some of the numbers in there but the end
result like it still looks fine I think
it should present it as is how many
people feel comfortable going in that
meeting and presenting their findings
well you'd have to do it all over again
like there's no way you can know what
change is like ha
god damn it so there's no shortcut here
you have to recalculate everything cuz
you don't know what has changed but
imagine that instead of that folder you
you were smart and you brought a
briefcase to working you locked that
thing before you left your boss he might
have some ideas about how it could be
different but you calculations are sound
it's impossible for the end for the
result of this calculations we have
changed because no one could have
changed the source and so in functional
programming to be talked about
memoization in caching and that's all
that it's about
yep yep so I says like hey this is the
same thing I received last time it
returns the cache version than this what
brick returns the cache version than
that returns the cache version it needs
to do no more extra work until the thing
has actually changed that it receives
and so that this is a big reason why
immutable data support and when the core
of your entire app becomes imputable
data you get all of these queries get to
benefit from this sort of caching
automatically like you just don't have
to worry about it because you're not the
only mutating have to and and these
functions can tell when it's mutated and
when it needs to do actual work so you
don't have to write any casual logic it
just it works that one and so
for the last part of the UI we've talked
a lot about immutable data and different
things like that but how many people
have written a program that never mutase
anything like anything interesting any
way other than a calculator like there's
no real-world apps have to do two things
and so I want to talk about this sort of
interactive part all right so we're
going to start we can reset can
configure like this is gonna change the
state of our app so we want to examine
sort of how it impacts that core domain
how do we get changes into an immutable
ecosystem like this so we've been
talking about no change no change no
change immutable immutable immutable
tour functions now we're gonna talk
about change we're just we're in our app
to mutations and changes so this part so
we've covered the data and the function
status talk about the actions and how we
change the outside world outside of this
well this is where I think we need we
really should have like we should rely
on libraries to be able to help us in
this regard just because it has been
such a good idea for me I use reduc
Slyke I've used flux for the last year
so pretty pretty much every day
we're Ducks is sort of an age a slight
take on with some pretty good
improvements and so it'll just I love
this title Redux is a predictable state
container for JavaScript apps that that
just sums up exactly what I'm looking
for I hope you write applications that
behave consistently and are easy to test
on top of that it provides a great
developer experience with live code
editing combined with time-traveling
debugging that sounds that sounds kind
of crazy you can use Redux with react or
with any other view library there are
actually adapters for angular or like
whatever you want to use and this is my
favorite part is like we all like oh
he's pitching another framework but I'm
not this thing is 2k ok so for by
comparison we don't think of backbone
being like the smallest of UI libraries
backbone is 4 times bigger than this so
this is not a framework that's not
anything this is just like a pattern
that you can use to put over your core
immutable app that you're creating that
is your business logic that will let you
trigger actions that update state in the
outside world and could participate in
this in this flow so I wanted to create
my own diagram but this guy Andre stalls
he did such a good job that I figured
I'd talk about his and this is just
works I said this is react for me it
could be whatever you want but when the
user clicks I'm most just fighters off
actions into this store which just has a
bunch of the immediately I can probably
feel like your eyes are glazing over but
this is where you put your services and
things like that so if you want if you
you would trigger an action and say like
I've kept this order and it needs to be
finalized and that's it you just pass it
into that store your services live in
that store and is like hey I know how to
do this thing and so it will accept your
order object it will modify it into the
next version which is the finalized
order person it will stick that in the
store in place of the old one this is
how data is changed in in this sort of
unidirectional functional flow system so
it is completely inspired by flux but
I'd argue it's more inspired by elm
which I don't know if anyone is really
with that but it has way more to do with
elm in situ RS which is coming in query
responsibility segregation than it does
with flux at all it just used the same
terms as flux and so there was there was
one mention of time travel debugging and
stuff in there and that that could be
like a pretty funky concept has anyone
seen time travel debugging before so
most people haven't okay cool
what I want to do is simulate like these
are all nice terms and my goal here is
to not get people to buy into like the
buzz or to hide behind something but I
want to talk about is like making our
jobs easier and so I want to actually
simulate fixing a bug in this app I left
the bug in here on purpose like I always
do so that we can go in and fix it and
we can see what the difference is if
there's any difference between like your
existing workflow so
if you notice when I ran this app
previous to this this probably slipped
right by you but everything looks fine
here we've got our opening prices and
then we've got Google's our size
negative infinity and I don't like I
don't know by the way I didn't even know
what RSI RSI was before I into this I
just needed i googled an interesting
financial calculation that I could use
to just demo this app but negative
infinity you're gonna get a bug report
for that like that's not right even even
if it is right you can't be just plain
it like that right so what it was the
first step you do well if this was your
app we would you start someone someone
said something say it louder yep putting
in debug earnest and also probably
putting in some console that logs too
late to just look at the state of your
app well one of the cool things about
using leaning on a framework like 2k
library I should say is that we get some
of these things that are that are built
in and so this it has nothing to do with
my app this the only thing this does is
it says since you're using immutable
data I can rely I can count on you're
not changing it and every time you omit
an action an action is a is a thing that
we can point to it is like a little JSON
object that says here's the type of
thing I want to change and here's the
payload you need to change it almost
like you would save off in like a
distributed system if you wanna like run
a task on I can't ask you and would like
give it enough information that it knows
how to perform that job later so every
action instead of it being like a
function call like like events like
we're used to it sends that off it goes
through that unidirectional pipeline
changes the data and anything that it
changes since maybe a mutable data
cannot be changed it just leaves that
one behind and moves forward with the
new version right so every action that
goes through leaves a snapshot of state
at that exact moment when the action
went through the system and since we're
saying we could where we won't change
anything I promise
Redux can actually keep track of all the
stuff for us and provide us with some
development bowls which pretty cool so
let's see
all right probably see the little part
now all right so negative infinity how
do we get here so if you want to play
with some of these dev tools we can
essentially undo actions that happen as
part of the our app so if we toggle off
this ticker stop that's when I click the
stop button and you see that UI just
reacts because the only thing that we
changed was when you click stop it just
sets like a boolean flag and so we
changed the state of that button the
bottom right that's all that happened
all right but our book is still there so
says negative infinity so let's start
plucking transactions off of our list
here so where we are doing time-travel
debugging by essentially just moving
back to that snapshot of state at that
exact moment and if we have one giant
blob of mutable state we cannot do this
because it's still the same blob and we
don't know what changed from one step to
the next and so we can essentially so
we've still got this bug and we can just
keep walking through until we oh ok so
we plucked off that last action and now
we're back to a real value ok so now we
know where to start we haven't even
thrown empty butter or anything like
that yet we know that something happened
here with this particular transaction
that caused our UI to get wonky and then
so what we can do from here is we can
actually like open up this action and we
can inspect like ok this is what
happened this is all the meta data that
came in but you know we don't see
anything strange but if you'll notice
like when you when I'm toggling this
you'll also notice that average loss for
Google is going from 50 around $50 to
zero that's the only other thing so we
don't know is it related ok all right
let's figure out let's figure this out
so we want to actually dive into what
just happened there
all right so then what we do is we've
come into our RSI calculation we can
actually take a look like okay well so
what happened here it's kind of leaping
our site like we need to do a bunch of
different things blah blah blah but it's
all relies on this one thing where I
became divided by average loss and so it
seems like something happened where when
average loss changes to zero this
becomes a problem does anyone know what
happened here divided by zero right so
it's like okay I think so I wonder if I
was smart enough to leave the real
working version of the code commented oh
right below the bug I wonder if that is
the case so if we uncomment that and
save and come back we even have the
Google is hundred okay so by definition
that is that that is the correct thing
to do if you cannot calculate if it's
divided by 0 the value 100 that is our
business domain says so right and that
we can actually keep rewinding back and
just make sure like this thing it didn't
break anything else we can go back in
time for it in time and just essentially
figure out what's going on and if you've
ever worked with like a live reloading
system or some like that you've seen
something like this before but there's
one big difference though and it's that
like this app doesn't persist any state
so if this live reloads it's gonna blow
away everything this is a live feed you
can't pause the real world and so how
can how can we get this sort of like
this behavior without any sort of live
reloading and that's what we'll talk
about I'll talk about next I want to
talk about
the mental model of static versus
dynamic and also how we got into that
world where we could do that time travel
debugging and I'll give you a hint a
passage with the way we looked at
actions as they go to our system but
first I want to talk about static and
dynamic have you remember the first
console program that you wrote that
might have just like and it's counted
numbers and spit something out how
complex was that
worried that if you ran it like a
different time that it was like it would
be weird and like not output the right
thing or like maybe would hang that
didn't happen because it's a static
program it's pretty easy it does want to
run through it does this job it prints
the phone and it's thought it's over a
dynamic process something that runs over
time like a daemon
how many people have per have had a
problem with a daemon before something
like is it did it just goes rogue it
won't respond to anything like this is
so much different from the simple
console program that you wrote and that
is the difference between static and
dynamic as far as as far as we're gonna
talk about it today
and so redux if you read it when we read
the docs you just words like predictable
and behaves consistently which are big
words that don't mean anything really
until you can actually back them up so
so how does it make things more
predictable behavior consistently and
we'll go back to that requirement that
had at the very beginning which is we
need functional UI's and this is why we
need functional you guys if you remember
it takes the entire app state in and it
spits out the same UI this should be
deterministic we should be able to rely
on this as a function and in most
systems that can kind of be the case
right and so if we're in like backbone
world or up or whatever you you have it
like if you refresh the page it's always
good no matter what the state was right
and so that function of state equals the
UI is first is true the first time you
run it but the difference is that this
happens in between first run into your
bug and I showed this that same rat's
nest of actions and a fan flashes
because their fire and forget we just
trigger them off they're functions that
get executed and you're just like if
something broke you have to do a
debugger or console dot log and if
you're in the middle of ten actions deep
like we were in that stock ticker if
that if we made a change and it reloaded
we just lost every all of our detective
work to get to that state in the app is
gone blown away because these things are
not persisted these are just ephemeral
just events that happen once and you
can't really trace them if you contrast
that with the system that we just looked
at which it actually every action
interest of the system is a thing that
you can point to it hold it is an object
that goes through that system and you
can store it with the data at the time
that it went through then this doesn't
so much of an issue anymore this is part
of your app date right and so if these
are persistable and we can point to them
we can look at them we can replay them
rewind fast-forward then this really
becomes true with a function of state
plus all of the actions that are
happened that have happened since you
reloaded equals your UI and we can count
on that rely on that and that is how we
can get these sort of amazing debugging
tools and be able to like really
rationalize about our UI at any point in
time and not I remember how it was and
these eleven things happened and I think
I still remember how it should render
but there's a bug and I don't know how
to reproduce it and so I I was debating
there's one of my favorite points of all
time and I think I still don't even
fully understand it but I think there's
so much in here and I debated not
talking about it today but it has to do
with that static versus dynamic
difference when we're writing programs
so it's long so I want to break it up
into parts but it's by Dijkstra and I'll
read the whole thing at first and it'll
likely be confusing but it says our
intellectual powers are rather geared to
master static relations it our powers to
visualize processes evolving in time are
relatively poorly developed for that
reason we should do as wise programmers
aware of our limitations up most to
shorten the conceptual gap between the
static program and the dynamic process
to make the correspondence between the
program spread out in text space and the
process spread out in time as trivial as
possible and so think about that static
as being that console app simple dynamic
process that daemon that is very hard to
predict over time he's talking about
shortening that gap and trying to make
as though with pure functions if you
look at an add function you can see the
input in you already know the output
with long-running processes with mutable
state you cannot do that and he's
talking about shortening that gap so if
we take a look at this one at a time
first of all I just want to applaud him
for even saying this because it's
something we don't say enough but like
we're not super like no-one's superhuman
like we all have limitations and this is
about our programs getting too big for
us to hold in our head and not being
able to like rationalize what's going on
anymore that is that's what he's going
for here
so our intellectual powers the way our
brains are wired are geared for static
relations that predictable given this
one thing this other thing should happen
not most of the time it happens but like
yeah everyone's allowed to totally
different thing in his strange outcome
so our brains are wired that way to
visualize processes evolving in time
they're poorly developed we're just not
good at it
as a species it's not you and so for
that reason we should do our utmost to
shorten the conceptual gap between the
static program meaning we take
everything into account when rendering
out that UI all of the actions all of
the state everything comes into play
that is a static static relationship we
we understand everything going in so we
can predict what's coming out versus the
dynamic process where everything's fine
at the beginning and then a whole bunch
of mutation and things happen in the
middle that we can't measure or see and
we're supposed to predict the outcome
and so I hope that you come back to this
quote and maybe Bleen some more insight
from it but this is how this is why I
liked it so much when I read it and when
I didn't hadn't even heard of her ducks
yet and so when I sort of saw these
functional principles I was like this is
I think this is what this guy's talking
about and so with that I just want to
say thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>