<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Functional Programming For Dummies | Coder Coacher - Coaching Coders</title><meta content="Functional Programming For Dummies - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Functional Programming For Dummies</b></h2><h5 class="post__date">2017-12-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aKXKC_N_0hw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">of course the question everybody asks is
what is functional programming and some
people say us programming with functions
so this is not functional programming
but um what is functional programming
I think functional programming is is
complicated it's the properties of the
language so something can be a
functional language or not but it's also
some common practices that functional
programmers do and and it's a
theoretical framework and this is very
abstract but what I mean is you've got
these concepts and techniques and
they're very central to functional
programming it's not just pure functions
it's more than that so this is what I'll
talk about today and I'll start with
referential transparency so the
definition that is that an expression is
referentially transparent if you can
replace the expression with its
corresponding value without changing the
behavior of the program for example we
have here a main function that
calculates the meaning of life and
there's this expression that evaluates
to 41 because it's a post-increment
so if you change this with its value
this is allowed because it's just a
expression statement then the return
value changed so so this program was not
referentially transparent this
expression instead if you write it like
this you assign 41 then you assign 41
plus 1j
you've returned J you can change the
expression you see there which evaluates
to 42 with the actual value and the
program will be the same so here the
expression is Trevor
in Chile transparence that's the the
only thing you need to know about
referential transparency and and it what
it also means why it's so important is
because he FB guys they say well it
means you can recode but you don't have
to think about state you just think
about the outcome of an expression you
can forget about state or the way that
evaluating an expression can change that
state so less cognitive burden while
reading code cleaner code but also this
referential transparency it it gives you
stuff and it make sure you need other
stuff it gives you peer functions and
immutability but then you need immutable
data structures and recursion so pure
functions this function is pure because
you can replace a call to this function
with the output and you could write the
function another way and the function
itself will still be preferentially
transparent still be pure but inside
you're using mutation so these plus
equals is actually a operator that then
returns the total so it's an expression
but if you would swap out the expression
with value the program changes so this
is not this this function is not
immutable this function is immutable so
it doesn't look very pure because you're
doing assignments but inside the body of
the expression you're not mutating any
variables so then so there's a subtle
difference there between pure functions
referentially transparent and
immutability
but if you want to do stuff with data
you need also needs immutable data
structures just numbers it's not enough
so you want to make lists and to make a
list actually you just need a pair so
you have values 1 &amp;amp; 2 you can have a
pair of two values of course you cannot
add a third value to the para later
because that would be mutation that's
not allowed and to make lists with these
pairs you can use the first value in the
pair for a value of the list and the
second one for the tail so this is these
are called the head and the tail and
then you can write a function that
either returns the first value or the
rest and these functions are called head
and tail and an empty lists you could in
PHP write it as null and then the list 1
2 3 would look like this and then you
need recursion but to understand
recursion you must first understand
recursion so let me try to explain so if
we want an average of not just two
variables but a list then you take the
sum of lazy divided by their length of
the list that's the average and we
create a length function but it has a
loop with mutation and that's not
allowed right so we have to write
another way and the same goes for the
sum function we cannot write this with a
loop so what we do instead is we use
recursion which means that the function
calls itself so if axis is an empty list
then the length of an empty list is 0 so
we just return that otherwise we take 1
and we add it to the length of a rest of
the list
and the same goes for some except that
you take the value that's in that's
first in the list which is the head he
added to the sum of the entire tail now
to see why this works it's actually
quite nice to step through the
evaluation of this function and we do
that by taking part of the expression
and replacing it with its value because
we can do that because it's
referentially transparent right so first
we fill in the list and then we take the
function the body of this function had
like the division sum divided by length
so we put that there then each of these
function calls we can do the same and
then here we see a head we know how to
calculate that it's just the first value
of the list right one and the tail is
rest so we see another tail here do the
same and then we have two function calls
so you see the loop happening here's the
recursion again we change it with the
outcome and we change that head and a
tail and then we repeat this so
recursion is a sort of repetition and we
repeat finally the sum of an empty list
and the length of an empty list is zero
now here are all these plus operators
which is a sort of function we can
replace those with the actual numbers
and then another operator and we replace
that and we just calculated the average
of the numbers 1 2 3 and this is called
the substitution model of execution and
it's only possible because of the
referential transparency and to do loops
sort of you need recursion
so let's look at this recursion because
here we have the recursion at the end of
the function but this means that you get
a very large stack trace because every
function calls itself so if your list is
a thousand items big then your stack
trace will be thousands items as well
and there's a way around that if we
write this function a little more
complicated and we pass the start value
so if we have an empty list then we just
return the start value where we should
start
apparently and then we recurse at the
last line by passing the tail and as a
starts value the head and the start
family that we started with this
function does exactly the same thing but
this one can be optimized because as
soon as we return the some call then
there's nothing in between the call to
sum and returning this function so we
can throw away the item on the stack and
that looks like just like a loop like a
go-to and this is called tail recursion
and according to some people it's equal
to the meaning of life
so this was part one next stop point
free programming not pointless point
free so um in order for me to explain to
you what point free programming is I
first need you to understand these
concepts and it's a lot but it's all
intertwined so it so bear with me okay
higher-order functions are defined by
functions that accept a function as one
is of its parameters or and/or returns a
function so we had some code in PHP I
will switch to JavaScript especially at
my script six because it has a nice fat
arrow syntax and our code will look
pretty ugly
if we keep continuing PHP so so this is
the same fun sum function it's not tail
recursion it's a regular recursion and
and inside there is a plus and I want to
rewrite that plus as a function so it's
the add function of course and a add
function has two parameters but I'm not
going to write it this way I'm going to
write it like this this is called
currying you have two functions an inner
and outer outer function and they both
have one parameter and to calculate the
sum of these two values you first apply
the first parameter and then you get a
function back you apply the second
parameter so ads of one of two evaluates
to three and add of one evaluates to a
function so ad is actually a
higher-order function and applying only
one of the parameters of a function is
called partial application
so why is this relevant well we can now
write this ad at this some function with
using the add function and if we look at
it this way and we compare it to a
function called fold right then we can
see some some similarities so first this
is this is the sort of value that you
apply for empty elements so you this is
your start value and then this add
function corresponds to the F that you
pass in and then we even have the
recursion because fold right of f of Z
should be apparently the same as sum so
what fold rise does is it takes a
function to apply like add a start value
Z and then takes a list and does a fold
and some does just takes a list and then
recursos so actually what this shows you
is that sum is actually a partial
application it's a full right function
we can do the replacement here and then
these will be the same so this is a
little trick but we can do much more
because we also have a map function it's
also very important it takes a function
and then applies the function to each of
the elements of list we also have a
compose function takes two functions and
then returns a a function and a new
function that first applies the second
one and then applies the first one I'm
not sure this actually correct I think F
and G should be
the other way around and a another funky
function called Constance so you pass in
some constants and then what you get
back is a function that always returns
that constant takes a parameter but it
ignores it
just returns X so let's use these as
well so we'll create a function called
ones so this does a map of constant one
so constant one is a function always
returns one and a map of that function
will take a list and turn all the
elements into ones and then we have a
length function and that's just the
composition of turning stuff into ones
and then doing a sum now we have three
functions that we defined without using
a single single parameter and this is
called point free programming so Y point
free programming I looked it up and
there's a branch of mathematics called
topology it works with spaces composed
of points there's points in a space
everybody knows that and functions
between those spaces so a point free
definition of a function is a definition
which does not explicitly mentioned
these points in program you call them
parameters or values of the space on
which the function acts
so that's part two next part algebraic
data types so why the word algebraic
well algebra is is rules for
manipulating numbers but there's rules
for manipulating types and some of them
are some and products and I'll show you
some of these rules and what you can do
with them so I am I stopped using
javascript now I'm switching to Haskell
because Haskell has the nice type
notation so I'm hoping I'm not scaring
you all but um well actually that was my
goal so an example of a sometim is
boolean you have two types true and
false which contain of one elements now
boolean is the sum of those types and it
contains two elements true and false and
you can write functions that map from
boolean to boolean like not an example
of a product type would be
two-dimensional points so it's called a
product because you if integer would
have thousand points and and you take
two integers and turn them into one
value then a point can have a million
1000 times 1000 different values so
that's why the name product type is it's
quite fitting and you could write a
function for example that translates a
point using distance which you also
write as a point
there's type constructors type
constructors are sort of functions for
types so maybe is a type constructor and
a is a type parameter and you can use
that if you might have a value of type a
so you might have a number but you might
not and it is actually a sum type but
it's pereira parameterised so you can
have a maybe of ins or a maybe of boo
and an example of a function would be is
nothing which checks if you have a value
or not and if you don't have a value it
returns true oh yeah and what you can
see here is that is that maybe it's
called a type constructor but we're just
that's a type that's a value constructor
sorry so you can take a value 3 and you
can type just before it and then you get
just 3 for example so try to remember
that you can also have of course
recursive type definitions so list a is
defined in terms of itself it's actually
a product of list a and a that's cons a
list a that's a product type and then
you add that to nil which is an empty
list so it's a sum of a product type of
itself and our length function you could
write in Haskell like this so it has
really as clearly empty lists have
length 0 otherwise you add one to the
rest
and that is called pattern matching you
saw it with a translation and there the
the point is also the value constructor
so you use the value constructor to
deconstruct values of product types on
the left hand side of the function so
you like you pack them out it it was one
point but now it's two values and the
other points is now two values now you
have four values you calculate the stuff
and then you pack them into a point
again using the value constructor and
that's exactly what you can do with
lists as well and and this is I think
the the main reason that the thing that
we miss in most non functional languages
is this sort of pattern matching music
algebraic data types so haha there's
also something they call the
hindley-milner type system and this is
where it gets all arrogant and like
where functional programmers we we
understand this so I'm like I'll try to
understand as well come on
ok so it's a type system that allows you
to do type influence and lambda calculus
in order to write them most generic type
of a free expression in a program not
helpful ok so this type inference what
is it well I wrote a type definition for
length so I I said length is a function
that turns a list of a into an integer
but I can just comment that out that's
the - - it's a comment in high school
and that will mean that the compiler
will have to figure out on its own what
type length is but it has no problem
with that as long as I behave if I do an
oops in the code then the compiler will
complain and say that it cannot there is
no instance for an amateur arising from
the literal
and I'm like what is this
well apparently num is a type
constructor that says this type is
something that you can add and charb
between brackets is actually just as a
char string so a string charli's to a
string and it says so you're having so
there's a string there because you use
the double plus which is string
concatenation so the result of the
second line is string so length is a
function that map's to string and 0 is
not a string even if we make it more
generic which is not what we meant it
should have been in so we can tell the
compiler that and then our UPS is
actually on the right line so it says oh
I couldn't match type int with actual
type string so you're making a mistake
there on that line so types are optional
but they're helpful for the compiler
error messages and for readability of
course and even if we put total nonsense
in there then it compiler says oh no I
can match int to this function type
there's an error in there which means a
function that turns a list a 0 into a in
the a 0 because what does this algorithm
roughly do it starts by taking all the
code and all the nodes in the code and
all expressions and sub expressions and
assigning a type variable to it both
left and right up in equals for
definitions and it just starts at the
top and it moves to the next piece of
code that imposes your constraints I'll
come to that then it unifies these type
variables
and then it goes back to step three
until it reaches the bottom so these
constraints could be things like left
and right hand side of equals must have
the same type so if those are two type
variables it will unify those which just
means make them the same name or
complain if it can't or do something
other they're smart thing and the result
of plus for example has the same type as
the expressions on either side which
also must be equal I think and applying
applying a function with type a zero to
type a one is only valid for a parameter
of type a zero of course and it always
should always reproduce produce a value
of type a one and it can be really smart
about it like somewhere it finds that a
zero should be int and a 1 should be
equal equal to a zero then it can also
conclude that a 1 is equal to int which
is basic logic and also if you have type
constructors like maybe it's a maybe int
okay so if a 3 is maybe a 4 and a 2 is a
3 then a 4 must be int it can deduce
that sort of thing usually um and also
the arrow is not that special
in type inference is just a type
constructor a should do type inference
for all types so why not the arrow and
it's a type constructor because it turns
two types into a new type so how are you
on time we have time okay so of course
there's also one thing that all
functional programs talk about category
theory and especially monads and
do you know Douglas Crockford so he said
that once you understand monies for
yourself you lose the ability to explain
them to others so in Category Theory
there are a lot of weird names like
Frank term annoyed applicative monads
and I will not try to explain even
monads and the other I will try to
explain functors only and hope I succeed
and a functor is actually we saw a
founder because maybe is a functor and
in practice it just means that there's a
function f map for that type so in high
school you've got these type classes and
then you say class Fronter where a
functor should have F map and this is
the signature and data maybe this like
the type declaration that we had first
and then you can explicitly tell Haskell
that maybe is a functor by saying
instance functor maybe where and you
have to define the F map function for
maybe which is maybe a value maybe not
maybe nothing if you try to map if you
map a try to map a nothing then there's
nothing to map so we can just say ah
it's nothing if we try to map F just a
so we have a value we have a function f
then we just apply F to that value and
we get a just a value back so this is a
very simple definition you can do lots
of useful stuff with it but of course
oh yeah so like for example if you have
a function that tests if a value is even
then if you try to map of if you try to
if you do f map of is even of just one
well one is not even so it's false so
it's just false and if you try to do
that with a nothing then you get nothing
back
so the in practice is pretty simple but
but yeah so in practice it's it's pretty
simple and it's pretty powerful here's
also where the point free programming
comes in because you can also have a
function that works on a maybe even
maybe it's called maybe even so you
partially apply the F map function and
then you can say maybe even just one and
says just false maybe even nothing
there's nothing so but now I will try to
explain functors using category theory
and there I went on googling on category
theory and there's this website by by
guy called Bartosz Milewski and he it's
a very good site it's a it's a lot of
reading but it's and and and he doesn't
make it simpler than it is he really
tries to explain category theory and not
like the like that watered-down variant
where you get the intuition you know
like really what is it called
and why is called that way and but he
also says category theory is quite
simple actually it's it's easy in its
essence because it's about objects and
morphisms and morphisms you can see like
arrows objects category theory doesn't
care what the objects are so actually if
you go and make drawings you can write
the draw the objects as
piggies and the morphisms as fireworks
is still the same which is what he does
and so I'm like okay but I still don't
get what what do people use category
theory for and so there's two examples
of categories group which is a category
with groups for objects and group hummel
for him morph and I heard of group
theory somewhere in college something to
do with symmetries but I don't really
get it but there's another group called
sets and these this is the category
whose objects are sets and if you think
of it all our types in programming are
sets a number can be either 0 1 2 3 etc
but it has a maximum value so that's a
set boolean czar sets of true and false
strings are even sets if you say our
lists of characters and characters like
the character type is a set so and then
you have functions between those sets
like for every number there's a boolean
that says if it's even or not so that's
a mapping from one set to another and
those form the whole morphism so the set
category is actually pretty useful for
programmers so what is a functor a
functor is a mapping from one category
to another for example we have a
category drawn as a cloud with objects a
and B and you have a functor f that
map's that cloud unto another cloud
which also has objects for F a FB and
the arrows in between those have must
also be mapped to them to the the other
category and a example of this is maybe
so if you have a a for example int then
maybe maps that to the set
maybe int and if you have a B or boolean
then may-maybe maps a - maybe boolean
and then you have the is even function
for example and you apply F map and then
you get D maybe even function and also
because it's maths they're saying well
these sets these categories they have
certain properties which means that
these properties if you map a category
to another category it must still be a
valid category so these properties must
still hold and one of these properties
is that every objects can only have must
have exactly one arrow that points to
the object itself and it's called ID for
identity because if you take a value and
you put it into the identity function
you get the exact value back so if you
put all the values of a sets into the
identity function you get the exact same
set but then of course if you apply
maybe you must still have a maybe
identity in the new category and it must
behave the same way also it says that a
set is only valid if you can compose the
arrows so if you have a arrow F from A
to B and a G from B to C you must have a
function from A to C which means that if
you map it to another category there
must still be the function that map's
from F a to FC and in practice this
means the following so here we have the
definition of f map for maybe
and we have the law that says if if you
apply F map to ID it must still be
pointing to itself so it must be the
same as ID for example if you put in
nothing it must be the same as ID
nothing you can look at the definition
for F map and it says F map underscore
as in don't care nothing and and the
right side it says nothing so we can
replace again the left side with nothing
on the right side we can do the same
because we know that the identity
function always returns the stuff you
put in so we can replace that with
nothing as well and nothing equals
nothing so this functor law holds for ID
and for nothing but does it hold for a
value as well so if you put just a in
what happens well if we look at the
definition then f map f just a is just f
a so we stopped substitutes f with ID so
the left side turns into just ID a but
if you apply a to ID you get a so that's
the third step on the Left I'm gonna
write the identity function we know it
returns the same thing so it's just a so
now we have just a is just a so the
first functor law that f map ID must be
ID for that functor instance holds for
may be great now let's look at the other
law that says f map PQ so the dot here
is the functional composition which
means apply P apply Q and then P so f
map of P composed with Q must be the
same as F map P composed with F map Q
like this if H is a composition of F and
G then F H must be the composition of F
F and F G yeah so if you do that for
nothing
it's a lot of noise but essentially yes
this holds and if we do it for just a
then we have to do a lot of work
especially on the right side where we
use the composition so f map be composed
with F Q of just a means that first you
apply F map Q so that's in the
difference different brackets and then
you have you look up the definition and
it says oh that should be just QA and
then you have another F map that you
apply and you can look up the definition
again and you get just P of Q of a so do
this as a training exercise at home it
really holds which is a good thing
because otherwise maybe would not be a
functor so category theory is in essence
just a lot of math about objects and
arrows and as Christopher Pitt says said
earlier ammonia's are just abstract data
types
just like functors and my opinion is
these three concepts are in practice
what you really need to know to do
functional programming so it's not just
pure functions but you really don't need
any category theory so that's it thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>