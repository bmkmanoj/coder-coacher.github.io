<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Gor Nishanov “C++ Coroutines - a negative overhead abstraction&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Gor Nishanov “C++ Coroutines - a negative overhead abstraction&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Gor Nishanov “C++ Coroutines - a negative overhead abstraction&quot;</b></h2><h5 class="post__date">2015-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_fu0gx-xseY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in C++ 17 this is how you will do from
hello world well this will see out and
hello world will stay but what you would
say you would say Auto of course hello
sorry const char star s no I'm
old-fashioned in this way
how about P be better because they
aren't going to do this you know while
it's not now I will heal the star P plus
plus and here I would say 400 okay see
I'll call hello I will pass it hello war
hello world
ok and now see if our mission is not
good so let's fix deformation ok ok good
so we're good with format run it and
look at that hello world 17 style good
and what happens here is whether we do
yield uh you will see the stack right
there's a main it's cold it's called
well hello who is it some funny prefix
we can strip it out in later but doesn't
matter
then we yield oops we go back to main
and then we pool again and we back to
hello so that's that's Colchians okay
done
no no it's it's an it's an old old old
thing and actually
co-routines used to be way better than
they are today so imagine that you are
okay you are in yes in the year 1958 so
you take your favorite COBOL program and
this is not a collusion John Cobb who
had a point
guards and the Kabul program his
favorite slide deck and me it was
completely independent so and then you
pass it to the most modern nine path
cabal compiler and this is from the
paper in 1963 by Conway and this is the
first time called Kings were mentioned
ever so how this guy would try to deal
with your program so what it will do it
will you know start the main routine
that will go to the basic symbol
register which will eat the punch cards
and then spew the tokens onto the tape
and then it goes back to this mains
routine and main routine will now call
name reducer which is like name lookup
for us now but you know whole pass for
that which we were in the tape and then
would observe out on the next day and
they will keep going and eventually you
will get the thing you wanted the result
of the compilation and a whole bunch of
extra tapes you no longer need you know
this guy who thought that it is
absolutely insane that to pass a token
from a lecture to a parser it requires
this whole expensive piece of machinery
okay just to pass a single token so he
thought that functions are just like
it's a lot it's not good enough
we just need to raise a level of
abstraction a little bit subroutine is
just a little subset of a more general
abstraction which is a coaching which
allows you to write the code the same
way but pass this stuff directly so and
how and this was another guy who at the
same time invented that concept but we
never published a paper so his name is
forgotten so if we think about what
functions are they support to operations
in the way how they relate to other
functions so S stands for suspend and
the first circle is what happens to me
to this function
and the green circle or the right circle
the second circle is what happens to
another function so the first operation
that function can do with respect to
other functions is suspend itself and
activate a different function now when
you're suspended all of your local
variables are preserved including
exactly the spot where you are and the
second operation that functions have
that you know to do stuff to other
functions in iteration two other
functions are to terminate itself to
destroy all of its local state and yield
back to the caller and you probably all
know that other names for those fancy
circles have drawn right so what is the
first iteration yes it's a function
called yes and that's the second
iteration is returned it's in the return
statement or you hit the curly at the
end that's what functions do and
workings can do all of that stuff
because go routines are more general
generalized functions they have the call
and return and let's mix up the circles
a little bit they have this funny thing
where you can suspend yourself but
instead of doing a function call and
activating a new function you actually
heal control control back to whomever
hold you and this magical third
primitive is what allowed Conway to make
nine pass compiler which used big
expensive slow machines to pass a token
from a lecture to a parser make it into
a function call and that's how
essentially it went it went so the main
called the basic name register this guy
tries to Cobre talking it used to it's
used to it used to go to the punch card
write routine but instead the little
help help aretalking would say oh I can
talk to a corrosion I will activate that
co-routine it will start going and at
the point where that corrosion will say
output
I will suspend it without killing it
state without terminating it and I will
yield back to whoever called me and that
is exactly what we saw at the very
beginning with hello world because the
hello was yielding back to the to the
main and then jam it back and forth so
with this new improved generalized
routines he was able to do what nobody
believed was possible nobody believed it
is possible to write and one passed
cabal compiler by humans they thought
that they may invent compilers of
compilers where they will try to like
manage the code wonderful fit machine
but it's like nobody believed you could
write it and with coroutines
with coroutines yes we were able to
compile your entire crew program at a
speed of hundred cards per minute
unbelievable now this is an example
maybe of a negative overhead abstraction
essentially it's an abstraction when you
raise the level of abstraction suddenly
your stuff is not only simpler shorter
neater tighter than before but also much
faster this has been forgotten about
coroutines since those times since those
old times people try to imitate that by
inventing cheaper versions of the tape
machines people try to imitate
co-routines using threads using fibers
but they has forgotten the coroutine is
just a generalized function it should be
as fast as a function and faster okay
we no longer at least most of us here do
not write cabal compilers so maybe this
problem is not so relevant to us so
cover your eyes were going to the future
ok ok ok I will just warn the transition
from dark to white will hurt the eyes so
I made this little thank you thank you
okay so remember the diagram of nine
past compiler that we had before
actually we cannot solve much simpler
problem look at the state machine a
problem with problem description that's
simple it must be simple to write but it
is not of course if it's synchronous
yeah we can write it simply in
straightforward enough and we'll say
well yes this is how many bytes you want
to read yes and it's a buffer I will
initiate the connection and when
connection is done I will start a loop I
will start reading into a buffer it will
tell me how many bytes it read I will
have some terminating condition
you know if it's now if number of bytes
already zero connection is gratefully
closed on the other side so I have to
bail out or if if I've read enough I
bailout to and I will tell how much okay
it's simple
so how do we write it asynchronously in
C++ today so there are two ways and I
will show you to a to two possible ways
how we can do it in C++ today in C++ 11
there was this pair of types introduced
promise and the future and this is
essentially a channel which allows you
to transmit a single value from one
party to another it is a rather
heavyweight mechanism you can see to
implement that we have intrusive pointer
pointed to the hippo like in that shared
state which has atomic leaf count and a
mutex to guard the state and the very
end which can contain value is not here
yet
empty or here is value of T which is the
end result of it and if an operation
wasn't able to produce that value it
will be an exception bollinger and we
need a conditional variable so that the
guy in the future can block and notice
this is not helpful for asynchronous
programming this is fine for for join
where we launched a bunch of operations
and then we block waiting for them to
complete so to address that in C++ 17 we
might have we will have do then and
probably you some of you have seen our
true stock
yesterday about concurrency - yes so
let's see how it goes
what computer city has Dean it added an
ability to provide a continuation
sensory you supply to do then a function
object and you tell the future hey
future when the way wouldn't you get the
value like kogas function object so now
we call this a theater
remember the functions they have this
funny little iteration in the end when
you return you must kill yourself there
is no way to return back to the covert
yield back to the caller reserve in the
state there are for whatever we used to
have in the synchronous function must go
on the hip so here I have a struct with
all of the variables I used to have
before in the synchronous version I
stuff them in a struct I put them into
the hip now I will do the city connect
and because it's a synchronous and in
this case let's say it returns a future
with Doe then I will say dot then after
connection is completed it will actually
give me a future which is already ready
to go it has either exception or a
connection itself then I will grab that
connection from the future and put it
into the state and now I need to do a
loop dot then doesn't do loops
gracefully but it's easy to make this
little helper
that essentially you can see I will give
it a function of a function of future
that returns future of wool it takes no
arguments essentially says hey call this
guy in a synchronous fashion until he
says please scold me and now we can
write a board you will say body dot them
and then when the body completes it
continues with this lambda and it will
tell me done or not done if not done
then I will go and recurse in some way
back into myself otherwise I will return
the future which is already ready this
is a very helpful function which allows
you to make a future which is ready if
it takes an argument
deduced what kind of future is if you
give it no arguments is the future of
void so let's continue now we can use
this helper so return do while and we
give it a lambda which returns future of
boo and then we'll check do we need to
leave at all nope if not we'll say may
create a future false initiate
connection then we will get the bytes
thread and if nothing so yeah we're done
now who wants to write code like that or
who feels comfortable thread : excellent
there was one hand so James this code
has a bug can you fix it I will tell you
where their buckets so the bug is very
very simple see I forgot to return
statement because this function before I
I wanted to return back to the guy who
called me eventual return immediately
eventual number of like what is the
remainder did they read everything you
wanted more or less so I forgot to
include that in the program before so
the only thing you need to do James this
is not our constraint that he just
raised the hand I didn't meant to pick
on him is you need to return the total
and by the way James is is the guy who
does the very important stuff for the
zip of a sniper cube so he is an expert
so James how do I fix it okay let's go
easier the fix is either on this line or
on this line or on this line so just
tell me which which first second or
third
okay okay enough or shooting James so
the fix is here because I need to
connect them to I think somewhere here
do this do why I think oh maybe here I
don't I mean the point is it is
unreadable I'm a rightful unmaintainable
so never ever write this code but what
do you do what do we do today when we
want to write this code actually the
technique is there is a very very very
good technique it's called
callbacks don't forget about callbacks
they are good then this is the way how
state machine have been written for you
know not centuries but turns intention
in terms of years if you have a state
machine do it as a state machine okay
put a state there then for every arrow
write an answer
write the number function and they will
be rather small for example the start is
just allocate the reader you know
connect the future start the connection
pass the lambda and you see lambda to
make call back mortal good loud this
shoe this mobile you just forward to the
thing which actually does and also has a
name
all connect is a good name for that
thing so now two questions
why why do I have beauty Lee's here so
happened if I if I remove the Pyrenees
yeah absolutely so correct in this case
I do not like you know making extra
interlocked increments decrements
eternity aberration I want to have the
this thing to be just plain unique
pointer and the ownership of this memory
will be in the asynchronous activity so
if I successfully launch that and it
didn't throw any exceptions then it owns
it
so I transfer the ownership inside but
if there are any problems and this this
accept would have thrown and we will
never get to Pyrenees but if we get here
then all good and this is the same
reason why I had to grab the future from
the promise before because by the time
I'm here it could be too late it could
be gone now unconnect is very
straightforward we're checking an error
code with transition to the error state
and we grab the connection so I mean
it's all very similar and I think if if
what you have are playing functions this
is probably a better way of writing a
synchronous code and in fact if you look
at boost edge that you're that
essentially the model in most
efficiently encourages so all of the
functions they're a synchronous once
they have the signature you have a bunch
of parameters to pass and eventually it
takes a function object at the end which
is the completion okay so we have
written handcrafted state machine and I
completely biased you because I thought
I would ask you which one would you
prefer but you know this is okay but
this still we're not here we're not
there in terms of making it well it is
close but can we make it even simpler
because the the the synchronous version
was pretty much travel so what
coroutines do for us they address this
wonderful operation which called suspend
and yield not call them about the
mentally in the circles model I suspend
myself here and await keyword March that
point and he will control back to the to
the guy who called me but because I
haven't finished I did not provide the
result to him yet I cannot because I
don't know it result is right here it's
in the future I will return a type that
can represent that concept it doesn't
have to be a future but that's the
vocabulary term we have right now so III
use the future so that's pretty simple
that's that's awesome you know you have
seen this in other languages so that
maybe not the most surprising thing but
what do we pay to get that yes yes
Richard will suffer Richard is the
maintainer of clay and you know some
other compiler vendor but not counting
compiler vendors what is the cost let's
measure so that laptop I just you know
compiled with the Artyom version of
Visual Studio I am just trying to
transmit one gigabyte over a loopback IP
and both sides server and the client are
written in the same fashion so either
callback fashion or the quality fashion
so let's see the numbers okay first row
one of them is just horrible it's zero
another one is okay it's 380 another one
is 30% better you know let's look at the
object size on purpose I haven't used
any extra libraries because they bring
too much stuff so it was just a little
abstraction over raw OS for both
callback model and for corrosion model
okay what is this it's hello world
just to get the baseline and and yeah I
know it's embarrassing hello world man K
I didn't have time to figure out how we
can compress it but just to give the
baseline do nothing it's it's nine key
here is handcrafted and here are origins
so with coroutines not only your code
looks better
not only the code runs history it is
also smaller so these are the claw
routines which were meant to be 16 years
ago because back then corrosion was just
an idea they were doing it in assembly
now we're given a syntax a customization
ability that allows you to achieve this
characteristics of being a negative
overhead abstraction but you don't have
to go to assembler together
okay-y like what is the secret easy you
see it with traditional functions even
the best state-of-the-art library like
boost SAR you are still too far from the
metal go routines bring you closer and
we'll just see that we will see exactly
the abstractions that I have to build up
to consume roll ads so what do we have
this is what the user writes in the
traditional model right I pass a lambda
as the COBIT parameter then this is the
signature of function that takes you
know whatever and Wilko it later
but this is what OS expects overlapped
on windows unpronounceable thing on
POSIX you know whatever but but it is
the same idea in spirit that there is an
a synchronous separation and you need to
give it some kind of context it will
twiddle with it and it has to stay
stable in memory for entire duration of
the asynchronous iteration so what good
libraries do they would combine a heap
allocation of a context that have to
stay stable in memory it cannot be a
local variable
we the functional so just one location
and let's write this so we want to do
this we want to take OS context that I
have to have and I want to glue to it a
function object that user wants to call
whenever the operation completes sorry
use virtual functions you can produce
shorten to do longer but without details
but this music virtuals so essentially
whenever OS calls me back with the
completion packet
I will reconstitute myself back into
unique pointer so that whatever happens
I would delete that hippo located thing
and then I will invoke an abstract
function here and then I provide okay
I'll explain it in second then I'll
provide the real thing which will
combine your function object with the
overlap based and I override the invoke
to actually call the thing you want to
be called in your function object and a
little helper
down below just a ramp function that
will create the class and I like it on
the heap so one thing you need to tell
to the OS or a thread pool or whatever
is that whenever an asynchronous
operation completes on this handle you
know call this callback so that's how
the linkage it happens sometimes
OS API says hey here is the callback to
code here's give me a call back and I
will call you back sometimes it's like
hey just tell me for this handle what go
back to call her whatever happens it
will keep it will be called using that :
okay good now let's finish it
using this helper let seniors they read
this is what user writes this is what
the API looks like but now we can see
inside so inside what it's doing it's
doing a type erasure it erases the
function object was passed from the
outside and then presses to the real
read again the only thing that really is
doing it just strips out the unique
point earnest calls saying Oh
see I this is just like but from a
protection layer it has nothing
interesting inside then I chicken error
if there was an error there are two
clients the error could be I don't have
a value for you I don't know what just
you know there is no value yet it's it's
in the it's tangent and that's okay
because gweicher OS will complete me or
it's a real error I will invoke the
callback and in either case if
everything is great I will release the
ownership of the unique pointer because
now the asynchronous operation owns this
this structure was the function object
that we created okay good what happens
here what do we have to write to make
this possible and why it is the fish is
more efficient than what we saw before
just to slide this don't make okay so a
wait about what do you await if one
so you await upon any type that
satisfies a way table concept and
conceptually it is conceptual futures
but real to the future and what is
conceptual future of T so this arrow is
a time line it's time and this T is the
value T and this arrow pointed down it's
the present so essentially there are two
possibilities the value could already be
with us something happened in the past
or it could be in the future so we need
some way to ask about it so a way table
has to provide an ability to ask that
question and a wait ready does exactly
that give it an away table it will tell
you whether it's ready or not well if
it's not ready then compiler will form
this function object called quality go
routine handle and give it to you and
says hey please call me back
whenever you know that the value is
there so that's what the await suspend
does and eventually operation is done
now I want to get what I want say in
case of the Essene Creed I want to get
number of bites you've read or maybe an
exception or whatever else the hydration
wants to return to me so a weight resume
is that part so when we resume it allows
you to unpack and away table and give
you the thing you are looking for so let
me show you a little pseudocode of what
compiler is doing essentially it's the
same thing on the previous slide just
with code whatever happened whatever you
like better so we check whether you are
ready and if you are ready we'll just
jump back to the end and resume you with
whatever this function returns otherwise
we'll suspend you and this is the magic
line this is the magic land where
compiler just suspend this quality and
richer yields back to the guy to acquire
a cold without killing in state okay I
remember this this was our base class
it's the way how we can we can link the
OS context that OS wants with the code
that we want so with qualities it will
look very very similar so yeah we heard
from a scene context so what is
different there is no virtual functions
but maybe they're inside of this cotton
handle well not really it's a void star
on purpose no destructor no we're
counting it's a it's just a void star
with the fancy template you know
syntactic sugar on it and we don't want
to do PL one where a function work is
how I remember it
used to be able to have multiple entry
points with different parameters known
you're not getting that you get the
initial entry point where you pass all
of the parameters you want on resume you
pass no parameters whatsoever so this is
essentially how you pass parameters
inside how will transfer it you have a
here I stored error and number of bytes
and when we has called me I will greet
grab the overlapped the 2's give me back
I will reconstitute myself down question
then an extract an error from the
completion packet and then by
experts here and depending on on yours
your API is actually this stuff this
copy is not necessary because you can
actually made you make your inner loop
whatever in a thread pull stuff out just
pass an address of an error and you know
by its transfer then it will directly go
there as opposed to this intermediary
completion packet but in any case this
is the biggest part now let's see the
rest
oh yeah I'm just breaking that resume is
also very very cheap and we're
experimenting with different kind of
code jams and yes control flow guard
will add extra checks but in the
simplest most efficient and hackable
form this is how it will look
or make Michael what else let's finish
it so just as a reminder I keep the
slide the previous slide here and now I
want to write an Essene Creed and the
only thing it does it creates a local
class a wager
and immediately returns it so now we
need in that a winter we need to define
three things await ready I wait suspend
and I wait resume well it means some
stage right I passed this buffer and
when I need to capture so essentially
the operation is not launched yet I just
defer an illusion of liberation and I am
not ready I haven't launched an
iteration moreover I want I want
compiler give me that give me the
curtain handle to be able to complete it
to resume the collagen so in a way to
spend I will take this handle that
carries you'll be cooking and stick it
into the resume field in the inevitable
base so that whenever OS resumes it can
it can quote and we are good I will call
receive if receive give me an error
which is not our painting then I throw
otherwise I'm good
and when I resume I will check what they
have an error I will throw and then I
return bytes so this is all the code
you have to write to do this there is no
HIPPA locations this is all inlinable
within reason so this is pretty much as
fast as it can go
but I feel bad for the traditional case
can we make something better can we
improve the other side well let's see I
profiled nothing in the profile you know
really sticks out shape is the same yes
this guy below doing allocations but
they're not very you know large part of
this execution so what else can we look
at well I checked that 50% of i/o has
completed synchronously and 50 was
asynchronous and by default on Windows
when whether you complete synchronously
or asynchronously a completion will be
always post it to the thread pool
now this is actually a very good default
because for server applications you know
it works out ok but in this particular
case change that this default behavior
by changing the mode of notification
would actually be good so if I said this
flag it means that if a sync operation
returns success it will not attempt to
post the completion so let's modify our
infrastructure layer for the traditional
model to support this optimization so
can we do it in abstraction layer let's
try if I said this flag it means that if
socket received gives success nobody
ever ever will complete the function so
one way to do would be just remove that
so I will call invoke either on error or
on synchronous completion and otherwise
I will just release the unique pointer
and let it fly anybody see a problem
with that triggered you
don't answer this is the problem you see
we could be unlucky we could go to
string of synchronous completions and
we're trying to push like gigabytes and
gigabytes of data and if string of a
synchronous completion is synchronous
completions is long enough and we're
unsuccessful we can hear the stack over
phone yeah but tail call optimization
sure maybe sometimes you know - it will
not crash but unity bug you might not
good good we actually for this
particular case need to implement it on
the Euler side again with sophisticated
threatens you can give hints if you look
at current executive proposals there are
moves where you could say you know post
which is definitely post or maybe defer
in this case you know we could have
deferred this invoke it's one way but I
don't have you know any threat post
support and just showing you what to do
in a row code if you have no vibrates no
nothing no no anything so I would modify
the ring to give me a boom which says
synchronous completion or not and then I
will just do a little do-while loop okay
okay let's see what happens
excellent we are getting close to
co-routines good but to be fair let's do
the same optimizations two collisions so
here I need to touch this function to
make it work essentially I need to be
able to veto suspend I need to be able
to say look I know I meant to suspend
but I just discovered there is no need
to suspend and we support that if you
change the current value of a way to
spend from void to woo and I don't feel
you know good about this strange
behavior but you know at the moment this
is how it works then the compiler
check did you actually mean to suspend
and if you say oh no never mind it'll
just go back to resume so this is all I
had to do to enable that optimization
notice that user code didn't change at
all
I just tweaked the bottom layer the
abstraction layer and let's again this
shows how the expansion changes we go
from here to here so it's very very
similar wealth measure aha
and I mean this is the motivation this
is why I okay I will do the yaki await
ready but twice as fast that's good
enough motivation so I still feel bad
about handcrafted state machine can we
do better
let's profile so who can notice
something interesting that appeared now
anyone well actually last time we were
discussing that I think BR you asked but
why don't I see allocations yes you are
saying there are so many more locations
which are going on well like in it this
is the case notice now the biggest costs
are allocations finally we were able to
reduce the the overhead of whatever wes
is doing low enough so now we can see
allocations good libraries like boost si
or they have wonderful wonderful
allocator to lessen that impact
it's a thread Keshan it's trying to
reuse your things it goes right to use
those little little overlap thing is so
it's good but it's it's good to run
where we squat in there is no code to
run whatsoever and we can let's see if
we can fix locations can we get to
quality level of performance so
again you can go the hard way you can
define very very giving sophisticated
allocator to lessen the impact but in
this particular case we keep pitching
the same lambda to read me in a tight
loop what if we simply don't call the
upper layer what if we manually call our
type erasure get a handler that we need
to pass to the bottom API and pass it
directly again it's an error prone it's
hard but we can do it for the type loop
in some application after we profiled so
the code will look not horribly just
need to make sure that nobody this is it
do we get to karate in performance no we
don't we still ran wore code I'm sorry
but it was a good change notice the size
also went down again not to the
coroutine well but still stupid so no
wonder karate is a popular right nearly
the same symptoms in at least four other
languages before us but what is
different what is different in C++ from
any others I'll have two slides what is
political another is you know practical
so if your sofa can slide we actually if
you look at should not fall down so it's
a generalized function it is we're just
raising what function is and when a user
give us some code compiler we look at
that code and I use some random dragon
so that like nobody's offended and if
you haven't used a wait it would be like
a task if you okay one more thing so a
future right future has three
possibilities it has no value yet here
is the value and here's an error there
is another class which is
similar but it has one less of a value
that is value or or expected of T where
there is no temporal aspect well you
know what you can apply to that too
so it can help with expansion so it's a
weight and no suspension keep going if
you use yield it's a generator if you
use yield any weight it's an a signal
generator and if you use now its POF who
knows what p f stands for yes wait oh
fudge function good and I expect a
question are you making compiler legends
that complicated does C++ have to care
about all of those things like other
languages you know compiler doesn't care
because who cares is cooking designer
because compiler just given you this
generalized function abstraction but
semantics is trade driven depending on
what recording designer which is you
it's not hidden in the library defines
you can get all of those and maybe more
we don't know we release the language
change or will release and then we will
see what happens what kind of crazy
abstractions you can invent with that
machinery so this is philosophical this
is how we are different from others we
are trying to stay true to the original
you know 60 years ago where coroutine is
the generalized function we're not
trying to make a little well expo k
practical considerations so these were
design principles that we used to you
know focus our design to give us answers
where to go and that answers we want
scale we won't call kills to be scalable
to billions like in a browser you can
make every character 40 maybe or maybe a
picture just you know don't worry about
that you can have as many of them as you
want
and also it's not if it's a function
linearization that firm iteration
suspend and yield back
should be as fast as the call so you
should not be concerned about that it
should be as test and a function call
overhead another one we wanted
coroutines to be integrated gracefully
with the rest of the world on two sides
from the outside kuru teen is a function
it's indistinguishable it's it's you can
put externally units you can put it on
the API you can store it you know as to
function void pointers or void function
pointers as a function pointer right
then you throw the other side when you
are trying to communicate with some
other library or OS
co-routines just void star for them you
pass that void star context and then
they we can reconstitute back in a call
back and resume the culture so we
interact without overhead on both sides
whoever calls us directly or indirectly
and sleeves the previous slide explain
that point is that unlike other
languages which define that okay if it's
a generator it's that class if it's you
know a task it's that class we don't
want to do that we want to use coal kids
for whatever you can invent so they're
open and finally we wanted coroutines to
be usable everywhere even though my
acceptance before my example before was
shown exceptions you can actually use go
routines in environments where you
cannot use exceptions like like kernel
no drivers they need help
so this is the help there should be no
reason for you not to use core audience
when you have them in the language and
there is a proposal going through the
C++ that notation committee there is an
experimental version in
RTM Visual Studio 2015 client
implementations in progress and this was
presentation like narrowly focused on
one aspect of coroutines if you want to
see like more of an overview you can
look at last year's presentation latest
wording is in this paper and expect fun
stuff in Kona in those papers and thank
you and there were a lot of people that
were doing work contributed in various
different ways and not mentioned and
people trying them out it's actually
quite very helpful some of the design
changes between now and between between
previous meeting and this one are driven
by customers saying oh my god you just
broke what you had before so we fixed
some of those things and do you have any
questions yes okay the question is what
happened to KO a wait and ko yield so if
you look at the wording paper it has the
keyword placeholders there was no
official vote on the matter of what
exact keywords were going to use
there was one definite vote there were
two votes two votes with respect to
coroutines
at your next meeting one was we shall
not have a tag on the core team like
other languages do so notice we don't
have any marker on the go to himself and
second vote we had was you absolutely
cannot take huge as as the real keyword
because it'll like destroy the world so
there are some papers which are trying
to address that so the keyword question
wait for it we we haven't we haven't
finished that part but conceptually
that's how they will we need to solve
some lexical issues yes please
surely sure so the question is how this
relates to stateful coroutines
and stateless quarantines okay I'm
looking for nice way of saying it okay
the theme of that presentation was you
probably go this is that we are the only
core teams
the rest are imitations because none of
them are true to the weight show me the
slides sorry
so only only our cookies a
generalization of a function not yet
what's good on a weight thank you
excellent excellent so cool till we
treat them as a generalization of a
function now I talked about dark years
dark ages between the 1960s and now what
people did they try to imitate cookies
what people were trying to do is hold on
hold on what people were trying to do
they were trying to make this thing
cheaper they did not do that
so boost context is the thing which
powers the booth core team and it's
magnificent it's wonderful it's it's
great it's its cost plot applause
cross-platform fibers in Windows we only
have on Windows right and all ever come
out we did that for all of the platforms
so they are great but they are they are
lighter weight threads and your
programming style is if you do threads
you can make you know your preliminaries
fibers cheapens the cost of context
switching you can make your own fiber
misses so it is
very progressive style but if you are
trying to build a coral team out of
heavyweight things the co-routine you
get will be heavyweight so in that sense
fibers are great they're useful in
certain scenarios use them but that's
not this one so this is I think that
maybe it would be useful to have a fiber
in the language in the standard library
but it will not be a core routine by
this definition it's not a generalized
function the question is why would you
use fibers so one example I I heard was
imagine you have an application like the
one that you mostly cannot change you
cannot change right and you want to
remove this expensive thing without
changing this code at all so what you
would do you will create a library you
know helper that will allow you to do
the context switch between fibers and
that's lesson in the impact of that
because coquilles require as proposed
today require syntactic marker there are
some ideas how in some case you can
avoid it but they haven't been
completely explored but maybe for some
scenarios we can avoid the syntactic
marker of the suspension point but in
general fibers allows you to just do
that directly without altering any code
apart from the inside whereas right so
definitely cold heels are intrusive to
the code base but again implementation
wise if you returned futures and used to
do futures in the rather convoluted way
now you can do it in a simple way yes so
we use iterator new to allocate it by
default but in some cases compiler can
avoid it when it know that lifetime of
the court it will not escape the
lifetime of its caller and I was talking
about those traits that guide the come
while the transformation well you can
like / you can overload a traitor new
there and that's how you can put your
own alligator but yes because we have to
suspend using the current existent :
conventions the state that has to
persist across resumption cannot be
stored on the stack unless you know in a
very special scenario yes please well I
think I have an example of using the
collusion with the standard algorithm
but essentially if somebody'd
implemented a generator that returns a
sequence of values the generator itself
is iterable so you can say dot begin you
can say dot end and patter to any
algorithm so now you hooked up generator
2 to an STL algorithm let me show you
let's see I not sure I will show you a
demo of it but I have it somewhere you
still want to look for it but let's see
they have it here somewhere
oh good you don't see it in here so this
is an example of let's cubic this is a
cursive generator and I'm trying to
solve the problem
same fringe where you are trying to
traverse two trees and you want to check
with a traversal of those tree in order
depth-first like there is a bunch of
words you have to use before that
results in the same sequence of values
so here's what we're doing we're saying
thread on the 3 1 revelatory 2 and they
both internal generators hooked up to a
routine and then you say equal and with
ranges you would even be able to avoid
this entire temperature just say equal
thread one and for them to and what
happens is that those guys at this point
nothing has run yet cobra tune is
created but no values are produced so
it's only when equal will start saying
to the iterator you know plus plus or
dereference it
that's where to activate the coroutine
and will will start getting ready so yes
you can interact with that oh yeah can
you tell me more about your concerns
sorry but but but is it a fiber like
thing yeah III don't know but
essentially you cannot imitate these
corrosions without a language support so
whatever you can do with OS primitives
or with library primitives you cannot
get to this level of efficiency yes
please
okay so the question is that there is
work seastar something which loops into
improving futures making them lighter
weight and having the runtime to make
certain guarantees that we can avoid
locking and the question is well how how
those things like are related so
remember the slide which I will show
again because it really like it where I
said that compiler does not care what
synchronizations you are talking about
like in the standard is warning there is
not a single line saying this simpler so
I think realizes with that because
coroutines don't have to be used in the
synchronous fashion at all you can
imitate goroutines with that alright and
ever sitting maybe on a single thread
just using the cue scheduler or
something like that so this is fully in
the hands of a library developer like
just for fun I did a little experiment
how a future would look like if we had
called teens in the language from the
beginning it's a pointer and no
synchronization whatsoever and no hippo
locations do so but it doesn't handle
cancellation I think the real future
should handle cancellation but that's
for the future so III think it would be
interesting for
developers of sISTAR library to play
with Microsoft or clan implementation
and see whether we have we have
sufficient you know customization points
that can make the sea star futures at
least s test as their today but I'm
pretty sure they will be faster then you
can achieve because you can combine the
promised part with the goal kill himself
oh session is over thank you very much
but always know</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>