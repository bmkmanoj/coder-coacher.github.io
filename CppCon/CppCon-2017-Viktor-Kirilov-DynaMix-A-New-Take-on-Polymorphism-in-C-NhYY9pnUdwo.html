<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Viktor Kirilov “DynaMix: A New Take on Polymorphism in C++” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Viktor Kirilov “DynaMix: A New Take on Polymorphism in C++” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Viktor Kirilov “DynaMix: A New Take on Polymorphism in C++”</b></h2><h5 class="post__date">2017-10-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NhYY9pnUdwo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- [Viktor] Hello, my name is Viktor,
I'm gonna present a library
written by a friend of mine,
and let's go.
So DynaMix is hosted on GitHub,
and it's about composing and
modifying objects at run time.
It's also very hard to
explain in five minutes,
but I'm gonna try.
So supposed we have a
hostile AI component,
which has an act method, in
which we find the good guys.
Me move to them, and then we'll tag them.
We also have a player
controller component,
which also has an act method,
and we read some keyboard input,
and maybe we move to the left.
We also have a flying creature component,
which has a move-to method,
in which we flap our wings and
possibly update our position.
So we might multiply inherit from this,
but then how do they
communicate with each other?
So we might use CRTP
with compile-time mixins.
But then, everything
ends up in header files.
And also, we can't have an array
of the composed of objects,
unless each of the
components inherits virtually
from a common base class.
But even then, we have problems like,
if we have an array of point of objects,
then we have anything in common.
There's no common interface.
So, if we use multiple inheritance,
with virtual base classes and no CRTP,
and all possible methods are
in the base class is virtual,
then there's a combinatorial explosion
of manually added types.
The base class is a coupling focal point
with the huge interface,
and also we can't modify
objects at runtime.
We can't remove and add components.
So, there is the interface
component pattern,
in which there is an object class
which has a bunch of pointers,
which are pointers with
different interfaces.
And the hostile AI
component can be implemented
by inheriting from the control interface,
and in it's act method,
it can access itself,
which is appointed to the object it's in,
and get the mobility component
called move-to, from it.
And here we can make a dragon object.
We can assign and build interface,
a flying creature implementation.
We can assign the control interface
a hostile AI implementation,
we can make it act,
and then we can swap it's
run time the implementation
of the control interface.
But here, each new
interface has to be added
it's appointed of the object class.
(clears throat)
and we also look at the sequence to
implement an interface partially.
So, with DynaMix, we make a dragon object,
and we mutate it by adding the hostile AI,
and the flying creature components.
Then, we call act on it.
Then we can mutate it again,
by removing the hostile AI component,
and adding the player control component.
And when we call act on the dragon,
we actually get ...
We actually call act from
the player component plus.
And the hostile AI component
will look at the following.
It has an act method,
(clears throat)
which the class doesn't
inherit from anything,
and to call move-to,
we use the end this, which
is something like self.
It's the way to refer to the
object we're currently into.
DynaMix has three building blocks.
Object, messages, and mixins.
So messages are
global-function-like pieces
of interface which
objects might implement.
Mixins are component classes you write
that implements different messages.
This is not to be
confused with CRTP mixins.
DynaMix stands for dynamic mixins.
Also, we use the library
by mutating objects,
by adding and removing mixins at one time,
and we also call messages
in these objects,
which is like methods.
Also, the object is always first ...
Oh fuck, I need some water, wow.
Sorry for this. (chuckles)
First time speaking.
So objects is always first it's parameter,
and that's ...
It's unfortunate, there
is no uniform call syntax
in surplus plus yet.
Messages can be unicast and multicast.
Unicast messages are ...
Only one mixins within an object
can implement a unicast message.
If we want to have more
implemented of unicast message,
we have to have different priorities.
And only the one with
the priority gets called.
That's why we can implement
shadowing and overriding.
Also we can have multicast messages.
And in that case, multiple
mixins within the object
can implement the same ...
The same message,
and when we call it, it gets
called for all the mixins.
And that way we can
implement serialization
for all mixins within the objects.
Also, DynaMix is ...
It enforces the good use of
object-oriented practices,
and it's also perfect
when we're dealing with
complex polymorphic objects,
which are commonly found
in games, or big software.
And also ...
(timer beeps)
it's very useful for plugins
which enrich the business
logic of our program by, yeah ...
With mixins, that's it.
(audience claps)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>