<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2014: John &quot;JT&quot; Thomas &quot;Embarcadero Case Study: Bringing CLANG/LLVM To Windows&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2014: John &quot;JT&quot; Thomas &quot;Embarcadero Case Study: Bringing CLANG/LLVM To Windows&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2014: John &quot;JT&quot; Thomas &quot;Embarcadero Case Study: Bringing CLANG/LLVM To Windows&quot;</b></h2><h5 class="post__date">2014-10-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HjfFKNByDvY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright thanks for joining me today for
this session hey I know you nice to see
you again friendly face go way back I'm
JT I'm going to talk to you today about
our experience at embarcadero of working
with clang in LOV m and some of the
challenges and good things that came out
of using it to bring a window solution
to bear earlier I Fickell's Tuesday now
it seems like so long ago lots of great
sessions I've been having a great time I
talked a lot about you I prototyping on
multiple devices this is what we're
trying to do in a marketer we're trying
to solve the application developer
challenge for developers to build
applications with good performance using
C++ across multiple platforms trying to
use a common API not just for standard
framework things like network services
or i/o but also for things like data
access for things like user interface
some of the things that C++ standard or
stl or boost for that matter don't
necessarily provide common services for
so that's what we're trying to do and a
big part of that is when what drives the
engine behind all this is good compilers
in good language support so a while back
I'll give you a little bit of a
background when we get to it here in
just a moment but what we're going to
talk about over the next hour I'm going
to give you the help you understand what
we were trying to do what were our goals
first of all in selecting clang llvm is
the architecture the tolling that we
wanted to use to achieve these goals and
then I'll give you an overview of the
project itself and we'll talk about what
worked well what didn't work well I'll
try to be as brutally honest as I can a
lot of self-reflection went on as I was
putting this together a lot of good
input from the team as well and then
lessons learned and what we want to do
going forward so I tell you straight out
that we're very pleased with what we've
been able to achieve with clang in l a--
vm and we think it's a wonderful tool
chain
the kudos to the team that's been
working on that and bringing it to the
you know making it available to people
like myself teams like us who are
building application developer tools so
some of you remind talk just wanted to
share a little bit about myself I've
been programming since I was a younger
young guy parents part home with vic-20
had to learn how to use basic to do
something with it and that's kind of
when I fell in love programming and
tried to stay with the graphical systems
until das came out and that's when I
learned C++ so that was okay my first
ide was turbo c++ how many I'll set out
there used turbo C++ yeah so what was
great about it was it was more than just
a compiler right you got everything in
one you were super productive it was all
about minimizing that edit compiled
debug cycle you could just write more
code and man wasn't it nice to have an
integrated debugger and it fit out a
floppy in fact i was going to share with
you that i borrowed my first copy from a
friend yeah exactly no license checking
back then i ended up going to school
UCSC which is University of California
Santa Cruz I was a Stephenson and it
didn't really matter but I wanted the
nice open field for the graduation which
overlooked Monterey Bay actually didn't
live on campus but and I studied there
at a graphics rendering that was my
thing I mean I did all the compiler
theory and all that too but it was all
C++ and all about graphics I really
wanted to do game development for a
living and build 3d engines and I also
learned as I was going to school there
that Borland happened to be like right
down the road and I was like shit I'm
gonna go work that so that's what I did
I started in the support ranks and it
was a incredible place to learn because
you didn't learn how to code in support
what you learned how to do is debug
other people's code and man what a
valuable asset that turned out to be so
as i'm coding these days and writing
bugs a much better figuring out what i'm
doing wrong
but over the years spend a lot of you
know work mostly on the c++ team and
around 2000 i spent about 10 years of
portland and left to go work in the
valley at a bunch of different startups
doing things like embedded linux worked
a research in motion for a little while
and all of this was C C++ programming
selves right at home about three years
ago I ran into an old friend who had
worked on these products at Borland
turned out embarcadero which how many
people have heard of embarcadero before
this week okay few of you wow really
that many that's surprising embarcadero
had bought the board would totally
bought the important Borland developer
products and he was telling me that they
had some grand plans and ideas and was
wanna know if I was interested in
helping out so three years ago I
rejoined embarcadero and I'm not doing
daily development and I'm running the
business side of it now so it's a little
bit different view of the world but I do
like to stick my nose in the meetings
and see what's going on and help the
teams to achieve what they're trying to
achieve three years ago it was when we
really made the decision to go with
clang in llvm and since that time we've
delivered a 64-bit Windows compiler
toolchain on clang we've delivered a iOS
tulle train and we delivered an Android
toolchain and we're actively working on
32-bit windows and this is taken a lot
longer than we'd like so going back to
the game development thing a little bit
there was this wonderful publication for
many years called game developer
magazine anybody here ever hear of it
awesome so it was pretty much free never
had to buy it they just keep sending it
to but you know in addition to some
really great programming articles they
had always had this section called the
post mortem and it was big development
teams building Triple A games and they
did they basically were brutally honest
about what went wrong in the project and
I was always loved reading those
articles because you got appreciate that
people learn from their mistakes but
they also talked about when we're at
right and that was really interesting to
see too because you can learn things
about how to make these
how to make very complex software
because games are very complex and bring
it to market I mean ultimately their job
is to ship something or a sub bunch of
wasted effort so that's my job to my job
is to help the developer team ship
something get it to market in time
market it sell it and keep that those
funds going so we can continue and
continue to invest so just a quick throw
back to turbo C++ the one thing I wanted
to point out here was that turbo C++ was
more than just a C++ compiler can you
guys still hear me i should probably a
little closer turbo C++ was more than
just a compiler it was a development
environment it was a collection actually
have a lot of tools that you may or may
not have been aware of a debugger
profiler and there's a lot going on
there and that's what we're doing as
well in embarcadero we're not just
shipping a compiler we're building
actually a pretty complex development
environment trying to solve some very
modern problems that application
developers have so the compiler is
critical of course without it you're
never going to get an app to run on a
device or run on a platform but all
these other pieces are very important to
delivering a a good developer experience
and so borland pretty much had invented
the IDE and from there a lot of
innovation went into trying to make
developers more productive whether it
was in the framework or in the tooling
or in the language itself this was this
is what the heritage of the people that
are working on these tools today
continued to take forward so Borland
throughout the years had been a big C++
company turbo C++ was incredibly popular
borland c++ did pretty well too until
visual c++ really just started to take
off and it was interesting because we
had competing frameworks so you know
people are getting framework religion so
we had oh w ell on the on the borderland
side we had NFC on the Microsoft side
but language compliance was always
something that was important to C++
developers so if a new standard came out
hey we got to be able to use these new
language features
throughout the years pardon me
throughout the years Borland had written
her own C++ toolchain so one of the
hallmarks of a boiling compiler for
those of you that remember was that it
was incredibly fast at building and it
took a lot of shortcuts to do that so
for example there was no intermediate
representation between the front and on
the back end they had let's call it
carnal knowledge of one another which
you know over the years of trying to
keep up with the standard also made the
codebase pretty brittle and so that was
the cost of having a fast compiler was
that she lost some flexibility and you
also ended up especially over years
losing some some of the architectural
value of separating these aspects of the
the tool chain but Borland continued
trudging on trying to address a lot of
these new features over the years and
around the code gear time this is
probably more history than you may be
aware of code gear was a spin-out from
borland Borland decided to wanted to be
an alm company which was like would he
call him requirements management testing
all that kind of stuff and so they set
the tools out on the side which was the
money-making business unit and and then
Borland started you know our customers
being C++ developers also told us hey we
really appreciate the productivity that
we get but we need to have good language
compliance we need to be able to write
code that allows us to take advantage of
these great new features we also need to
be able to write some portable code and
our compiler was falling behind frankly
so started looking at different
front-end zdg was one that the team
spent some time with was great for an
end it just didn't quite fit with the
model so it was abandoned and like I say
about three years ago when i came to
embarcadero clang llvm was pretty pretty
new at least two beyond the apple
platform and the team convinced me we
should we should do this it was a great
decision it think it's exceeded
everybody's expectations
in terms of how easy it was to really
work with although there was a
tremendous amount of effort in doing the
things that we do to the language to
enable the complete development
environment it was worth it because the
one thing that we could deliver and be
sure that we can deliver also was good
language compliance and something that
that clan really really delivers on plus
l OV m is a great backend one of the
best optimizers out there very clean
intermediate representation so this has
been I think a very valuable experience
so as I mentioned we deliver more than
just tool chains we actually deliver a
C++ an object Pascal tool chains overall
we probably ship about I would say ten
distinct tool chains maybe more tool
chain including the front end and the
back end linkers debuggers assemblers
all the ancillary toolchain kind of
stuff but we also build an application
platform and are again our goal is to
build cross-platform libraries that ran
across the main desktop operating
systems as well as the main mobile
operating systems since we do two
languages we also share a common RTL in
this RTL is something that is shared
between the object Pascal and c plus
plus side you can still continue to use
pure c and c++ RTL but this is an
additional our tail layer that's
provided to developers of using this
product and on top of that sits an
application framework so that stuff like
data access collections and containers
again doesn't mean you can't use C++
containers and collections of course you
can this is just another set things like
talking to cloud services rest in JSON
middleware user interface which is one
of the bigger challenges of building
cross-platform abs today especially with
C++ so that so that's another I mean our
team is probably in total about 200
people and just to put it into context
about a fifth of those are working on
C++ compiler so there's a lot of work I
mean half of those guys r QA too so
there's a lot of testing and stuff that
needs to go on
product this immense i was sitting
through the the microsoft office talks
to the last couple days and again that's
another humongous product i can fully
appreciate I mean it was great to see
the architecture but I know it's going
on behind the scenes it's just a
tremendous amount of work to bring
something like that to market especially
when it's on multiple operating systems
and then on top of this is a
full-featured a de code editors building
project management UI designers changing
platforms that you have to support and
your to run on as a host integrated
debugging so these are all things that
come together to deliver a product that
we bring to market so again the
compilers critical for critical link in
the solution but it's also just one link
there's about ten other links that make
up this total product so with that
context in mind we needed to definitely
find a project that we could leverage to
deliver this fancy compliance that we
needed and that our customers were
asking for so that our compiler team
could also focus on platform enablement
that's actually extremely costly trying
to move all this stuff from one platform
to another to support iOS and Android
even though there are C++ compilers on
both for a C++ in runtime environment
very challenging to get something to
support all this runtime on each of
these so this is our vision today you're
working on one platform with one ide and
you build one target platform app if
reach platform that you go to you have
to do this with different tools and
different languages in some cases and
this is what we really want to try to
push one team one language multiple
devices multiple platforms that kind of
sets the stage I think for helping you
understand what motivated us to do what
we're doing we also have actually very
long a very most alluring looking for a
large but a developer base that goes
back 15 20 years some cases that have
kept
and are still trying to maintain their
code base as well and we're trying to
bring forward so there was a lot of a
lot of conflicting goals in what we were
trying to do and try to help people
build a modern application but at the
same time also help him do it in a way
where they could leverage a lot of that
code that they were were using and
continue to get the advantages of our
development environment around the
productivity with the IDE in the
development environment and user
interface design and integrated
debugging and on and on and on we do
actually yes and that's something that
we'll be talking about in a little bit
so that was they don't really because
they don't think about that often but
yeah so the question was did we plug in
our object Pascal friend into llvm yes
we did I mean I'm going to talk about
that because that's a great example of
why Ella vm is such a great project
really easy for us to take our front-end
and do that as I mentioned before our
tool trains were very intimate in terms
of the front and a back end and we were
able to separate those and build to that
I are and it went actually rather fast
so this is what we're trying to do sorry
was our question ok so we're trying to
build let's call it a language engine
for lack of a better term look at all
the things we're trying to support
trying to support many different
language standards including
compatibility with borland c++ c++
builder these are our existing products
and the standard standard language as
well so again these are in many cases
sometimes conflicting goals as well as
all the standard libraries that people
use up there not the standard library
but boost and low key ace those kinds of
libraries that people do these out there
our development environment I talked
about just a little bit during the UI
prototyping talk encourages a visual
design and in order to deliver that
there's actually extensions we made to
C++ many eons ago because C++ didn't
have the facilities at the time things
like taking public members and
making them publishable to the design
surface so we created a new container
class called published and a property
was basically a public member that had
getters and setters for reading and
writing these values inside this object
inspector in fact it was a 2002 we
brought a paper to the committee
suggesting some of these additions to
the language and I remember the
committee wasn't keen on it because they
said who's going to write user
interfaces in C++ well that was 14 what
14 years ago now so of course the world
has changed we still think it's really a
great way to write not just any half but
also client-side applications which are
heavy on user interface and so we
continued on with our extensions there's
actually not that many extensions was
like four or five but they do a lot and
this is what the first part of moving to
clang really was about it was about
writing these extensions that did things
like allow classes or class definitions
to include published members with
properties also to do things like
generate rich rtti and when I say
recharge it's got me more than just
being able to cast and be told if it's a
bad cast but just go well I try not to
use an explicit of a lot of information
about that object so that it can be
dynamically invoked dynamically queried
about what it can do a lot of the
framework utilizes this rtti so that was
a lot of effort in fact it took about it
was a good two years in total effort to
get all of our extensions and work into
clang in the first place and again it's
not a lot of extensions from the
perspective of the developer who writes
double under of our property for example
was all the work that went into trying
to get it to fit in to clang and Clank
for for its sake was actually pretty
easy to get to get it into it's just
that this was a lot of
code in the background that did a lot of
things the real you know one of the real
goals for us of course was to be able to
generate arm code as well we knew we
wanted to get to mobile and arm was the
platform so this really led us to look
at many choices but clang llvm was the I
think it was the obvious choice after
looking at the pros and cons of various
approaches we certainly could have tried
to continue to build our compiler out
and we could have gotten it's a lot of
this something would have suffered
though and probably would have been
language compliance which would have
been really sad I did not want that I
wanted to deliver the highest levels of
language compliance and the benefits of
the tooling as well so there's the
background so our goals in bringing
clang and ella vm or adopting it was
first to deliver a 64-bit windows
toolchain so at the time clang was not
thinking about windows at all or
climbing or relevant projects and this
is something we decided to try to tackle
was a couple reasons for this one is it
was highly requested from our developer
base to build 64-bit apps they were
missing out on that they were but we
were behind frankly and delivering that
kind of support the other reason was
that there was a lot less complexity and
going to 64-bit and 32-bit 64-bit
basically had a pretty straightforward
standard in the sense of Kali
conventions in object formats and kinds
of things that you don't think about
with the toolchain but will kill a
project when you're trying to support
all these things and we're going through
this right now with 32-bit so this was a
really good test bed for us to see if we
can do this and make it work as I
mentioned one of the key goals was to
have to deliver C++ 11 and have a high
level of language and library compliance
so that was a critical must have feature
in addition to generating 64 bit
binaries on top of that we needed to
support our frameworks and that meant
these common ap is in existing
frameworks with existing conventions and
language usage based on 15 year old C++
technology and bring those guys forward
as well and lastly we needed something
that gave us a flexible architecture to
at least support various Intel platforms
which included 32-bit 64-bit but also
arm platforms so we knew that right
after finishing 64-bit we were going to
jump on to two arm platforms and try to
build an iOS version and try to build an
android version as quickly as we could
because we felt like we were behind
there was already in the mobile space
kind of an interesting thing going on at
the time at the time there was a lot of
apps being built with web technologies
everybody was saying we got to get
mobile apps we got to do it as quickly
as possible we can't build a separate
app using objective seen a separate app
using Java so we're going to build using
HTML in JavaScript and almost everybody
did this especially from the enterprise
side and they actually were able to
deliver applications they're pretty
simple applications for the most part
but they were able to deliver
applications and so that's what we were
kind of fighting against people didn't
believe it at the time and the value of
native now a couple things have happened
since then one when they started
delivering apps this way users stopped
using them because the user expectation
on a mobile device was a lot different
than in a browser and the the latency
exposed by a JavaScript runtime was too
much for the typical end-user they could
tell how many people are familiar with
Facebook's experience and trying to do
this a few of you it's a pretty famous
story I mean these guys are the web
developers in the world they no html5
they know JavaScript better than anybody
they I would think we would all agree
that they write one of the most complex
web apps there is and they try to take
that exact same source code and bring it
to mobile and they got an app running on
mobile but guess what nobody used it it
everybody wanted to use it but yeah it
it suffered well I went to a talk at
Facebook with the project manager and
she basically said their stats showed it
people adopted it and then quickly
stopped using it and they said this is
not going to work they rewrote their
apps using it objective-c and Android
and it was kind of a new wave of people
starting to appreciate the value of
native applications again unfortunately
also during that time the term native
got kind of overused in fact people
writing frameworks for web based
languages started calling their apps
native because you could package it and
sell it through an app store so we're
kind of dealing with that too ultimately
that's our biggest competition in terms
of language adoption and usage in mobile
there's some people that do a platform I
would call platform as opposed to native
using dalvik and java using objective c
or now swift and and cocoa there are and
then there's everybody else who's using
web and again more and more people are
trying to use platform or native
solutions to get better performance so
this is what we went into a a couple
years ago trying to solve and thinking
if we could solve this we may be able to
deliver a platform that could deliver
the best of both worlds there's this
business benefit of having a shared
source code base that something like
html5 and JavaScript can deliver on but
the the things you had to give up
performance in particular device access
was was really hurting developers versus
the expensive proposition of having to
build in a bunch of different code bases
for each platform so this is really what
we've been trying to achieve and we're
finally there so specifically for this
case study we're going to talk about
delivering a 64-bit windows toolchain
again we wanted to make sure we could
deliver a high level c plus plus 11
compliance ultimately the number one
goal is that our developer based could
build 64 bit binaries but there were
other must-haves language compliance was
one of those we wanted to have the best
optimizer possible we wanted to have
compatibility with our existing
frameworks and design methodologies and
approaches we have a lot of unique
features in our product something you
may not have heard of a fee a reason to
call packages packages are basically
shared libraries that do a little extra
work so that you can manage objects in
shared libraries much easier that's the
simplest way to describe it but it's
more than just your typical dll or s oh
and it turned out to be one of the big
things that hit us when trying to move
to llvm because lv just didn't have this
kind of support at all so these are the
kinds of things that we're working on as
we support these things and we also
needed a a good debugger I think we can
all agree we write bugs we need to be
able to debug them so debuggers are
critical I'm about you but it's a lot
harder to do see out or CR to an android
phone than you might imagine okay so
let's get into the meat of the case
study we'll talk about what went well
first and i hope i do justice to the
development team who couldn't be here
they're busy trying to get our 32-bit
compiler out they've certainly we've had
a lot of meetings on this they've
expressed a lot of opinions some louder
than others very passionate group and so
you know like most developers they
always I don't want to classify
everybody but they like to focus on well
weren't wrong sometimes more than that
went well so this took a little teasing
but a lot of things went really well one
we have a product on the market that
delivers on all these goals and I think
that's a big win so we'll start there
the first thing that the team noticed
that it was clanging lov em and I'll use
those terms together even though we know
there's
projects are very have a very clean
architecture you know there was concern
about using a separate front end and
back end because we knew there would be
a compile-time effects but it was a
godsend really because it made our work
much much easier much cleaner really
extensible front end all the component
parts of a front end were well
documented and well architected it was
easy for us to add you know key words
exactly for example to the scanner and
that kind of thing and to extend the
parser with our semantic information it
was well documented fairly well
documented is how the team put it it is
an open source project we all know how
to use the source Luke but this actually
had good comments and documentation to
go along with it as well which is
helpful the intermediate representation
yeah that was actually something that we
felt was very well how many repeat
question oh thank you that's awesome the
question was what do I mean by IR that's
the intermediate representation so
classical compiler theory front-end
spits out intermediate representation
back and reach that and generates CPU
code and 30 minutes left okay great and
so you asked a question earlier now
repeat that question too did we take our
object Pascal compiler and go to lv m
and the answer was yes once we
discovered how well this project was
architected how well we could understand
it and work with it we decided to build
we were already building an arm back end
by the way I mean pretty far down the
line with it we decided to try to bolt
our friend in on tail of em and it was
surprisingly easy of course this all
relevant but it took us I'd say a few
months to get it basically up and
running and things were working I'd say
that was pretty impressive because the
back end we were working on was already
you're into it wasn't quite there yet
and the hard part was still coming up
writing a good you know good optimizers
per arm ella vm already had a good
optimizer
so that was a big win and and it was
actually a small team that moved that
object Pascal front end to llvm so
that's just a testament to how well this
project has been designed and
architected and supported by the
community the second win was we needed
to support dinkum where I dinkum where
is our stl we've been actually we've
gone through lots of STL's over the
years how many people remember rug way
if that was one of the first ones we
supported way back when fist knows and
several years ago we went to dinkum
where because they just write a really
good stl especially for windows problem
is they never really supported our
compiler very well because we weren't a
market leader compared to visual studio
at the time and also GCC which is pretty
much the de facto or had been the de
facto I think clanging lvm has quickly
overtaken it so we based a port on the
GCC branch one of the things that really
went well there was that clang had a
really great switch compatibility with
GCC made it pretty easy to start working
with it and getting up and running and
the question was why didn't we switched
to the clang guest hill because it
didn't exist on windows at the time we
could have yeah but we had a license
with the with dinkum wearin plogger and
he was interested in making this work
too we also again one of our goals was
to help people with existing code move
forward as well and his tales can have
different support they were already
working with dinkum our stl we wanted to
support them on the same stl of course
it looks like the clang stl it's coming
along very nicely to this something we
can consider for a future and I'll talk
about that actually in a moment that's
something that is I think was a little
challenging for us actually back porting
was something that we did quite a bit of
actually since we had to do a production
tool chain that had a lot of other
dependencies we needed to settle on a
version and at the time I was 3.1
and there was a lots of features that we
needed or desired that weren't available
in 3.1 sometimes there were features
that were in klang but not in lov n that
we needed to support the platform so we
started doing some back porting in
picking pieces out of a non release
builds to bring back a one example is
when we went to Android the 3.1 version
of ella vm didn't support exception
handling at all there were some stubs
there but it didn't it actually didn't
unwind or do anything so we needed to
backport that from a more recent version
of llvm and that worked out pretty well
so that was something that's been great
about this project being open source
being able to see what's there being
able to have access to two versions out
of further out for back porting as
needed here's one that may seem like a
really odd one to you guys but it was
something that ended up being
interesting for us and actually turned
out to be a nice surprise in our
framework we decided to support
reference automatic reference counting
in the framework and mobile and this is
mostly for the object Pascal guys
because they were asking for this memory
management help and of course we didn't
want to do a garbage collector so we
started looking at arc as the as a good
approach to do this we went through a
lot of ideas on how to be this of course
you can do automatic reference counting
in C++ with just you know smart pointers
and good practices but it also would
mean that code would have to change in
terms of brick helping developers bring
an existing code over today in their
class definition they would point to a
pointer or they would have a pointer to
an object in the framework so if we were
to use a more standard C++ approach we
would ask them we would have to ask them
to change all their code either in the
declaration by wrapping it in a smart
pointer or in the implementation by how
they access that point
after they've implemented it and so we
started poking around a little bit and
someone had remembered that objective c
had implemented some arc and then of
course he was clang so we did some tests
and it turned out we were able to access
those hooks pretty easily if it was
built with dark we can create a little
type that rather than the standard new
and delete operations would call into
these are cad ref and release hooks and
surprisingly fast took us about two
weeks to get that up and running and so
we were able to arc enable the framework
from a c++ teller developer perspective
so there are these kinds of features
that are in the product largely because
apples had been using it to support
objective-c and that we were able to
take advantage of for a certain feature
that's not really a C++ feature at all
but something that was important to our
goals of enabling this memory management
support in the framework and allowing
the developers to continue to keep
source code the way it is and not have
to make big changes to their existing
source code some of which are millions
of lines of code so this isn't strictly
related to the 64-bit project but after
we finished that project and we actually
started this work before we were
finished with a 64-bit project we
started looking at the arm back end and
started doing a lot of things in
parallel and connecting to that back end
was really smooth there were things I
made it a lot easier we could also
depend on one object format on the
mobile platforms to we decided to use
the STL's that were provided by the
platforms and not clanging in this case
or to port dinkum where although we had
a lot of discussions about that and we
use things like g DB server and some of
these other ancillary toolchain items
that are delivered by the platform and
so as i mentioned previously so most
platforms were more ready than others
Android wasn't quite ready at least at
the time
I with exception handling support at
least and also in the version that we
were using at the time to question it's
a 32-bit today yes so the question was
is the app 32 bit or 64 bits 32 bit so
what went wrong this is the fun one
there's a lot of challenges in this
project one is a lot of this early
extension work we farmed out to people
we knew who were no longer working for
borland that we'd work with in the past
running her own company and this is you
know sure to know because all those game
developer post-mortems are red typically
contracting at work tended to be
something that didn't go well so
nevertheless we thought it was a good
idea so we could work on some other
things we're still shipping products
these guys were excellently compiler
developers but just like in most
contracts we sometimes have missed
expectations different ideas on what
means a complete project testing because
they're not a QA team necessarily so you
know looking back on it we probably
should have taken the time out to do
that work ourselves and to because it
took a lot of time to integrate that
knowledge back into the team and someone
was talking about tribal knowledge the
other day this was definitely one of
those tribal knowledge kinds of things
our guys are really up to speed now but
it took probably more effort than a
would have otherwise if we had done this
work in the first place and this was
with regard to the compiler extensions
that I've been talking about this
front-end compiler work and it took a
really long time you know in total I'd
say that part of the project is to
enable our extensions in the front end
was probably about 24 months to get it
from parts leak partly through the
contractors back into the team go
through the testing process that we
needed to get a base of basically
production ready so that was a long haul
to not have a working compiler yet the
other thing that is really awesome about
this project but is really hard for us
when we're trying to stabilize on a
version is that it's really
really active open source project both
are very active projects actually every
project that covered under lvm is
extremely active this is awesome but
there's a lot of churn and keeping up
with daily changes is difficult not
keeping up with changes after a week is
almost deadly or months and so we're
actually in a pretty tough situation
right at the moment because we're not on
trunk as because we started moving to
that model but we're behind and we're
feeling the pain let me tell you is that
we have basically two full-time
engineers that are just trying to keep
merges up and keep this up to speed so
this was a big did not go well big
lesson I think for all of us the other
thing that is can happen and does happen
is you'll get competitive
implementations that come in somebody
got to their got to a sooner maybe
you've been working on it they're going
to win and so you're going to end up not
getting your version in there you may
end up not you know losing work or
having to change work or having a fork
yes though this hose 22 part small parts
keeping up with it the other part is
moving changes back in absolutely got a
question over here we hadn't been
frankly and that's something that we
need to change and that's something that
you'll hear in our the question is how
we've been contributing a lot of our
changes and we hadn't been and it was a
mistake something that is that when in
the not went well category and something
that we're going to talk about in the
end going forward yeah
a lot frankly and then and to be honest
reseting competitive implementations get
in there now so yeah yep there's a lot
of history there and there were things
that prevented us from doing it that had
nothing to do with technology that might
be happy to share in a non-public forum
with some people legal stuff frankly and
that was imposed by ourselves which was
really unfortunate and frustrating but
we want to change that so anyways this
is a good this is just good to recognize
if you're working with open source in
general you know try to be as connected
to that project that you can if you're
not contributing at least build on that
daily and do your merges when the
changes happen otherwise this world have
heard the other thing I those
challenging for us does all the other
toolchain items I mean most people just
think of compilers of front-end and
back-end right well that's true but
there's all sorts of other tools that go
into making a binary and being able to
debug that binary on the system a lot of
tools and some of them are in various
states of commercial readiness some of
them were taken more time to get to know
and learn LD B's looks like a great
project we want to get there eventually
we're not there yet we're still using g
DB servers on the on the platforms lld
is something we're really interested in
excited about but it's not ready yet
we've had to use several different
linkers I mean we basically have
Frankenstein tool chains and our guys
are sitting in hexed editors a lot
working on object format differences
calling convention differences and all
these kinds of other things that most of
us don't ever want to think about when
we're writing C++ right how many of you
out there at work on a compiler okay a
lot of you well then I'm just gonna say
you probably don't have to deal with a
lot of this pain but those guys that do
yeah this is kind of your daily life and
so we built a Frankenstein we use and
one of the reasons we use our own linker
on Windows is because
we wanted to improve the build time we
have a good incremental Winkle linker
technology and so even though lod wasn't
ready that was actually kind of a
blessing in disguise because we ended up
having to use our incremental linker and
that helped with with regards to to
build times Oh question yes and ll DB
yes those are ones we're going to start
with because we have more opportunity to
to participate those we have been
actually in those projects clang lvm
we'll get back to that one we are on the
on the mobile platforms yes but we're
not using native debug formats so that's
a whole nother topic which is another
what didn't go well yes that's coming up
partly yeah we also have always built
very verbose debug info and dwarf didn't
really have the capability to support
that elf does a little better but yeah
Dorf on windows which is we ended up
using didn't support all of our debug
info question is which Oh actually we
hadn't this interesting I thought the
question is rather than debug format
used AST directly well part of the
problem is that we do have to write it
to a file that can be separate from the
binary for for debugging actually not to
say that that sounds like a really good
idea I'm gonna look into that more 15
minutes anyways so quite a bit of
Frankenstein we're going on there but
lots of I think a good progress on these
other tool chain pieces and stuff that
we definitely are involved in and want
to get more involved in here's one that
was kind of a surprise some language
figure features don't come for free
anybody believe that I'll give you a
simple example we supported iOS pretty
quickly in terms of getting darme and I
was writing some C++ 11 code i was just
using the most basic c++ 11 feature
default initialization
turns out that's not in the compiler at
all oh that's all that all of us in the
library setting up constructors for all
the different types so if you're not
using the correct stl that feature is
not going to work yeah so we had naively
used the stl that was on the mac
platform not the one in xcode and so
that one was behind and we found out the
hard way pretty thankfully pretty
quickly though that you know not all s
tales are created equal so that's a
simple example but those are kind of got
just as you're going to other platforms
and relying on existing libraries like
that this was one that we talked about
already you know once we got it up
running this is kind of thankfully it
wasn't a case of premature optimization
was finding out after the fact oh shoot
we got a real problem here our
developers are used to really fast build
times and they were i would say at least
i don't know five times slower and that
was you know this is that the cost of
flexibility and optimizations to some
degree yes and that's a reasonable
argument to make although we're also
trying to build an environment where
people can quickly create apps for
turning around so like for example one
of the things we try to do since we have
a common api is you can build a lot of
your app in windows that will also work
on iOS and Android so we try to keep it
local a lot of the stuff we do actually
runs inside the IDE in memory also so
these are all things that we try to do
to minimize having to go through lengthy
builds and the build time or the cycle
of not just building but also deploying
and packaging and all those stuff on
mobile just add so much more time to
these these daily cycles or many times a
day cycles so that's something that that
we've rediscovered and we had to figure
out a way dude and we decided at that
point okay our incremental linkers
definitely gonna help here and made it
really work with that but you know
turned out to be something that wasn't
as big of a concern as we thought it
would be most developers who experienced
it we're willing to exchange the bill
times for bed
language compliance and better
optimizations so that was good you know
we were worried about that but it turned
out to be a problem that wasn't as bad
as we thought it would be okay so some
of the lessons learned from this I'm
gonna going on time okay so one of them
is that clang is very strict with regard
to the standard that's a good thing
right problem is if you're bringing up a
C++ code base this could be 20 years old
their developers are pretty crafty
people they're going to work around bugs
they're going to work around weird
switches they're going to do things that
rely on which you present is the
interface to the tool change that
probably shouldn't be done I guess it's
true of anything that you put out there
that people can build upon and they're
going to find all sorts of corner cases
and workarounds and so one of our goals
was to help our customers move forward
and I think you know one of the lessons
there is instead of just putting a new
standard in front of them or nude
language implementation in front of them
you also got to help them move past a
lot of these issues you don't
necessarily think about different types
of switches and the impact it has
different looseness and the compilers in
terms of language standard that maybe
our old compiler was very forgiving
about and the new compiler is not for
good reason I was trying to think of one
just the other day that that hit us had
to do with template initialization and
to pass and Clank did it correctly we
didn't in the past even though it worked
go right exactly good one so let's learn
here is better documentation better
drivers when I say driver I mean things
that set up things like the path that
also set up all the environment for
building so that they call you know they
call our XE but it does all this set up
for them so those are the kinds of
things that we could help improve on
question is about refactoring tools yeah
those are some ways to deal with it as
well yeah I mean in general the customer
base has been really good about adopting
the standard in making these changes and
we were probably overthinking the goal
to try to help keep them working with
older conventions so you know there's a
lot of leverage their that we don't
people won't move up when your
businesses around upgrading people you
want to make it as easy as possible to
and that's our business model so that's
something that we had to take into
careful consideration at the same time a
lot of these things that we really rung
our hands about our hands about
customers were willing to to make those
changes for better compliance for
example so this was ended up being a
good thing we could have done a better
job by helping them though I've talked
about that initial contract work well
this is a second I must have moved it
yeah this was a lesson learned to we
should have done this work in-house
basically was a lesson learned or just
had better project management better
more check ins more frequent check-ins
kind of the same lesson we learned
around just working with an open source
project in general to be more connected
to it and this is kind of up to the next
one keeping up is painful if you don't
keep if you don't merge daily this is
probably the biggest one when I said
some of the feedback out loud this was
the biggest one because the business in
general is keeping our developer team
from accomplishing this and it was a
mistake and so yeah we're paying the
price for it now but that's something
that looking forward we definitely want
to change we should have committed
changes we should have done it earlier
should've done often and I think from us
we also want to pay more attention to
all the other tool chain items again a
ole DB 0 LD we're very actively working
on these right now we're not shipping
them as production components but we
definitely want to spend time on them
and support them and be more involved in
the community and take these lessons
learned forward
so looking forward right now we're
working on 132 supports way more
complicated than anything we've done
structured exception handling is
probably the biggest challenge and
that's something that I mentioned
earlier was something we could have
contributed back but there was legal
reasons that we created that kept us
from doing this so up to make long story
short it was a patent that expired and
so this is a good thing now we're all
freed from the handcuffs of this
implementation there's lots of
non-standard calling conventions I guess
you can call them standard if win32 but
there's lots of calling conventions so
this has been really challenging and not
to mention lots of object formats we'd
never support a cough is because it's
never been documented and so we've
always had our own object format but you
know each tool chain like for example
we're trying to mix dwarf an omf and
trying to figure out all the right
object formats to work to get our debug
info get everything working correctly
this has been a pretty complicated task
it's taken longer to do this even with
the front end work then it has taken us
to get the arm for example so this is
actually something that's about ready to
go and debate it to our customers so
this is it's been a long time coming but
is it was a lot of effort and so for us
on the Klang an lvm site in general
we're looking at taking it to more
platforms as i mentioned our goal is to
deliver full application development
environment that people can build C++
applications for target multiple
operating systems and devices so when 32
is next we do also build back in Middle
where software so Linux 64 is definitely
a next target today actually yes but we
stopped to do our work to that yep which
okay no question isn't isn't clang 64
already supported on linux and yeah
so this is it's a good head start but
other platforms could grow quickly
android on intel and again i think and
who knows really when our tea anyone I
don't know that nevertheless platforms
are going to come come up that we want
to get to and lvm is definitely going to
help us get there but we also have their
go work on the client side too so we're
finishing a 3.3 update and you're going
will 3.5 just came out yes it did and
this is when i get back to the pain of
not keeping up with the trunk this is
what it cost us or behind on it and so
it's getting better but it was not ideal
and i was something that again it's been
a very painful lesson for the team and
we want to definitely explore strategies
with the client team from a business
perspective in particular how can we do
more to share code back with the
projects that will use and be more
involved with the projects ultimately
what we'd like to do is we want to help
promote C++ as meeting is potential for
application development across multiple
platforms it hasn't really been
considered a viable language for most
for mobile development largely because
the platform vendors have chosen other
languages iOS with Objective C and
Google with Java dalvik for example
although they both have very good C++
support and so we you know in building
up the solution we definitely want to be
C++ advocates in evangelist on the
client side in particular on the mobile
did demonstrate more and more let c plus
plus 11 is accessible to developers
we're at a seat post post conference so
you guys are probably thinking what's
the big deal c plus plus 11 pretty easy
to use there's a lot of developers out
there who are scared of C++ for for
reasons that are not necessarily logical
so we have to we have to teach them we
have to inform them we have to write
articles about it that's loud we're
spending our marketing effort is in
educating developers you don't have to
live with html5 and JavaScript to get a
common code base you can do it with a
real language like C++ in the way we're
going to get them really to buy into it
is what C++ is best at great runtime
performance and great facilities that
are available to developers because the
biggest competitor to it right now on
these platforms is html5 and JavaScript
and who wants to live in that world oh
yeah yeah Sam oeun actually I think
doing quite well they're definitely
question is xamarin competitor
definitely they definitely put their
their bucket and c sharp as the language
which you know hey there's a lot of C
sharp developers out there so they have
a definitely a market opportunity but we
want to definitely do this the same kind
of the same thing for c++ definitely we
come up against amarin we come up
against a bunch of JavaScript solutions
like Coney and upsell reiter a lot of
these are pretty easy to overcome
depending on the how well the developers
versed in developing with languages
other than html5 and JavaScript but
absolutely I we run into xamarin renan
to this is quite it there's actually put
this is a pretty exciting time to be a
developer tools vendor again I mean back
in the 90s it was crazy there was lots
of tools throughout the 2000s or is
almost nothing going on and now it's
like everybody wants to be a developer
tools vendor again there's probably a
hundred different choices for building
mobile apps these days it's crazy QT
would be an example although they're
primarily just focusing on the framework
which is largely with Zaman's doing two
of though they're building an ID as well
who else is sorry the question was who
else is competing in this base and the
non HTML there's certainly a lot of
scripting language solutions out there a
lot of them tend to be focused on like
2d casual game development or
Oh 30 real app development yeah it's
funny that you say that but those are
the moneymakers on all these platforms
but you're right enterprises don't write
in these languages generally speaking
that's a good question I think Sam is
probably going to be the biggest biggest
competitor but bigger than both of the
boat than us and salmon is going to be
html5 and JavaScript because it's still
especially by enterprises seen as a very
cost-effective way to solve their mobile
challenges and a lot of enterprises are
driven by cost what's that then that may
be a viable strategy for some
enterprises but eighty-five percent of
the world is on Android at this point
anyways I think we're towards the end I
just want to let you know that in
pushing C++ we built a new product
called that method it's basically our
c++ builder but we wanted to give it a
new brand and get people who you know
are looking at solutions something new
to think about and really pushing C++ on
this one there is a free Android
compiler that you can use for commercial
development in it that's sort of our
seating strategy so if you want to play
with clang lvm on android it's more than
just a compiler to it's also the
development environment in the framework
etc but if you certainly have a compiler
there at the ready this clang lvm for
you to play with that you can get from
the add method home website
yeah you basically get all the platforms
in the first 30 days and then you
continues the android compiler continues
to work for an annual renewable
subscription okay session is over I just
got the note I could take a few
questions though in the last before the
next session so if you have anything you
can feel free to go to the mic there
otherwise you're welcome to leave to
your next session thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>