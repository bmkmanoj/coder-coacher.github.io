<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2014: Yuriy Solodkyy &quot;Accept No Visitors&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2014: Yuriy Solodkyy &quot;Accept No Visitors&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2014: Yuriy Solodkyy &quot;Accept No Visitors&quot;</b></h2><h5 class="post__date">2014-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QhJguzpZOrk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright sorry for the delay heroin my
name is Yogi and today I would like to
present a word that actually been done
in collaboration with the first order to
this race and dr. Pierre khabar back at
nm and it's some sorts about
visarjan pattern why we should start
moving away and why language is kind of
ready to get facilities to do that so I
would like to remind just a slide from
dr. short presentation on Tuesday where
he said like a in the language we should
keep simple things simples we should not
make a complex thing like unnecessarily
complex and especially we should not
block people from helping themselves
they should be able to do what they want
to do and we should never try at least
not to sacrifice the performance so as
as they are going to talk I'll I'll
remind what Wizards that pattern is this
talk is not really meant as a you know
passionate circle pattern it's more of a
discussion of what problems we have in
the observer pattern and what
alternatives do we have to resolve it
better this is not going to be a
technical talk on how we implement a
particular thing it's more of a software
gene talk like what kind of facilities
it enables us to write code if you would
like to to know more about the details
of implementation we have wrote papers
on it and we had the earlier
presentations that like C++ now so you
can look it up but visitors are I they
work they solve real-world problems
everyone knows that but there are better
abstractions to do the to express the
same kind of solutions for for the kind
of problems that visitor solves and we
would like to show two alternatives one
of them is better matching the other one
is it's open multi methods we none of
them is in the language yet but we would
like to them to become in the language
one day and we would demonstrate pattern
matching on on the real library we've
made so excuse us for some of the quirks
of the syntax that up just because it's
a library it's an experimental library
so the the syntax we would like to
propose eventually for the language will
not look exactly like that so don't get
you know like worried about like the
little we would like to just present to
show you what kind of facilities it can
bring into the language but don't like
jump into immediate you know like
something you don't like about the
syntax and open multi methods it's
another work we did earlier we did like
an experimental implementation on top of
EDG again like I will not go into
details you can look up the paper I'll
just show like what kind of syntax and
it enables and briefly mentioned what
kind of what kind of facilities it
enables so the goal is basically to
compare the solutions the typical
solution to some common problems using
visitors and pattern and what these two
alternatives enable us
okay so we know about mr. Ginetta
pattern I think mainly from the again
dove for book and they I will quote they
they call it it's a visual a pattern
represents an operation to be performed
on the elements of an object structure
which lets you define a new operation
without changing the classes of the
elements in which it operates which is I
think the main definition okay I should
not touch them for us
visitors because visitors design pattern
is often used in combination with other
patterns like interpreter patterns
reversal pattern people a lot of time
look at it as like this Swiss Army
knives it does everything for us for the
purpose of this talk we will look at
visitors and pattern only as a technique
for performing like external case
analysis so we will not be discussing
something like you know like how do you
do traversals with it how do you mix it
but we will definitely demonstrate it on
examples that originate from from from a
user you will see in the interpreter
pattern so an interesting thing about
the visitors and pattern it's even
though like it was presenting in in the
Gang of Four book outside patterns on
using the polymorphic classes it can be
implemented in a whole lot different
ways
visitors and pattern actually became
this interesting phenomenon where any
language feature you add to the C++
people will find a way to use it to do
better visitors like you we had we had
templates added people figure out ok I
can ignore like digital function calls
we had like when somebody invented
something called polymorphic
and see here on idiom and that turns out
we probably not something to do but it
can be abused to do visitors you've seen
in this conference people like to put
lambdas in in tuples or something to
also do this kind of so no matter what
language feature you add you can turn in
to do a better visitor what we think is
probably time to to do something to
replace visitor in the language is
except to kind of keep keep doing them
better one thing I would like to mention
here so for the example we will use the
polymorphic classes the same way it was
presented in the design patterns book
however most of these kind of issues
I've mentioned in the examples etc they
are applicable to two other
implementations to whether you implement
it using a tag inside your your class or
whether you you do some sort of compile
compile time resolution etc most of
these issues will still apply so what
are the the use cases for the visitors
that pattern essentially anytime we need
to add a functionality to a class here
are here we can use visitors and this is
where you would use a virtual function
otherwise but some things that you
couldn't foresee in advance that's a use
case for visiting our visitor design
pattern and other things like if you
have graphs of objects of different
kinds and you need to either figure out
like what what
a structure for an object or links
between an object what kinds they are
that's also usually in a good
application of visitors net pattern any
kind of interactions in games like where
you have different objects those can be
handled with visitors customization
points plugins basically all these use
cases for regular virtual functions -
the only difference is that as we will
see in a soon sometimes you don't have
oversight of all the possible things you
would like to have new interface so I
took directly an example from from
design pattern book where they use
visitors and pattern in combination with
the interpreter pattern where they say
okay you can have this language of your
own and compose like terms and then
interpret them to do something whatever
customizable stuff you have so here
we'll be actually dealing with the with
boolean expressions so we imagine an
algebra of gülen's and we would like to
to represent terms in in this simple
language and be able to do few things
about it like evaluate it transform
prints you name it like so here a small
picture just demonstrates an example of
terms so it's a basically we will we're
not going to do here with parsing per se
but we will assume you already have an
abstract tree represented using some
classes and we will look at those any
questions so far
so traditional object-oriented way is
basically we would introduce an
interface and we will put a virtual
function into that interface for add any
useful
chan a letís that we think we might
need in that interfaces we can call it
later and override it on a particular
variants of that boolean expression
examples of those things we can do would
be something like printing an expression
copying which most of us probably know
it as cloning like clone the entire
expression evaluate an expression given
a context context in this in this
context in this context is essentially
just a map from variable names to values
of those variables nothing too
complicated but we might want to
evaluate that expression in that context
we might want to replace a sub
expression so it replace a variable in
an expression with another sub
expression and interested in other
interesting cases like we might want to
check that two expressions are the same
like deep 3 wise as a same essentially
or we might treat one of the expressions
as some sort of pattern where where
let's say variables can match anything
you might want to implement a image
function where we would try to match one
term against the other using variables
as patterns this is this so the note
here too to make is did we miss any any
functionality I'm reassure like anybody
has something extra to add to this
interface no matter how many seams you
put like there will be something more to
do and some of the things is like
unifier replace the entire subtree
conjunctive normal form this Junction
number for all these can be a little I'm
sure there are more ok so once we've set
in this pure object-oriented set and
once we've set up the
the basic interface we will just the
variants basically the the concrete
terms would be the right classes into
which we will have as members either the
the subtrees or like the name of the
variable of the value etc and then we
just implement those virtual functions
to do the concrete seeing the to do that
function on that on that particular
expression this is an example for not
expression but it's pretty
straightforward I'm not going to go into
it details the immediately what we see
here is like should we group those by
classes like in when we when we do you
know our traditional so right and
software should be groups on by classes
or should we group them by functions
just like when you do your case analysis
ideally you want to see all your cases
together which is not something
typically we do in an object program we
usually group them by by classes so if
you group them by classes your cases I
essentially get scattered around
multiple translation units so just to
summarize this the traditional object
already well the advantages of it it's
it provides extensibility of that of
data because it's very easy to add new
new essentially kinds of expressions we
just derived from frumble expression it
gives us all the traditional
object-oriented features like modularity
manipulation it works in the presence of
multiple inheritance dynamic linking so
it supports well the object model
obstacles pause the disadvantages of it
there is no extensibility of function so
every time we would like to add a new
function we have to essentially change
that interface which which is not
something you can have worth always
there's also no local reasoning as I
said because this these functions can be
scattered around the different
translation units and it's inherently
non-relational because we essentially do
it on one argument we don't we cannot
use it to compare like two arguments or
three arguments
so now stretch actually that we have
those virtual functions because
basically we would like to to look how
would we implement something like that
user using now visitors that pattern
assuming we can not foresee all the
functions in the interface we would like
to essentially design a visitor
interface where we would implement
essentially the same functionality using
visitors so we will still use the same
class hierarchy but assumes there is no
virtual functions I mean those virtual
functions in it okay so the first thing
we do is we usually released our cases
which is basically our the kind of terms
we have in the in the grammar and then
we define our visitation interface which
essentially does the case analysis so it
says like a what should we do when we
find this kind of expression was that
kind of expression etc note to make so
to yourself here is like it requires
foresight of cases so we essentially
have to to think about like what what
cases will we have another saying is
this is important I found it important
when
when you when you have to teach this I
will serve that pattern
don't use overloading unless you you
really have to if you're using it just
to teach students they they get it much
better if you don't because if I can
call all these methods visit what which
is what people typically do but it's not
always used and if you don't really
depend on that just call them
differently so people can see what's
going on and it will save them a day or
two in understanding and that's what we
do also in the design pattern book which
which is they they they have actually
discussed that that so anyways I'll
mostly presented with different names
just to for the ease of understanding
and we'll also a case where it might
make sense to have to use the overloaded
so once we define the the visitation
interface we essentially then have to
embed what's called the accept method
into the actual here okay so we declared
this virtual function except it takes
that visitor and then in every of the
variants we overwrite accept to
essentially call it saying hey I am this
case because in a particular accept we
will know the exact tag of this or if
it's not at least the most derived that
we know of and then we will call the
corresponding visit method to say like
hey I'm this case so essentially we we
are covering in the except we are
covering our dynamic type and then we
pass the dynamic type to the
corresponding case I'm sure most of mean
everybody probably thinks that so unless
if you have any questions so feel free
to stop me so a note to make yourself
here it's intrusive basically we had to
change the the boo X interface to be
able to I mean to add those functions so
this means that we cannot add this
retroactively if the reason exists in
class hierarchy we cannot add and and
the same happens it doesn't yeah it's
not true only about like this
way of implementing certain apparent if
you implemented with tags or something
it's still going to be the case it's
going to be intrusive like if you don't
have your tag yet you will have to
introduce it you will have to to define
your visit interface and then like
somehow map your tags to the visit calls
so ever since still still applies
whether you implemented with polymorphic
classes obviously it was something else
and note here that it's also specific to
the class hierarchy so if we were to do
the certain pattern again on a different
class here he will have to essentially
write this go the game so okay now
having having done the groundwork for
the visitors now how would we implement
something like eval which takes a an
expression and the context and evaluates
the value of that expression in that
context so anyway so what we do
essentially is we derive a class which
we call eval visitor from from our
bullet expression visitor and that class
overrides each of the visit methods to
do a corresponding st. to evaluate that
specific class we then make an instance
of that visitor and we call except on
the original expression and pass that
visitor a thing to note here is within
the visitor we don't have direct access
to two variables of the original
function
a while and we don't have we cannot
directly return so because of both of
these are because of the control
inversion because we get called as
opposed to we are we are already in that
function so because of that we have to
save our context inside the visitor and
basically also save the result inside
the visitor which is what I highlighted
are like in a this red color and then
essentially return that result this is
common saying to do the the the thing to
note here like why I was like why why
wouldn't be chain accept and and visit
to essentially return let's say bull X
star since most of time here we do that
we do that well that might work if you
if you if if you're in a language where
everything is derived from a particular
class which is not the case in C++ and
I'm sure you might have a use cases
tomorrow where it sort of return and say
expression you would want to return just
a bool which is like the result of this
and so you might start parametrizing but
then you visitor in the phrase becomes
parameterize and all the results and
that pops up into the exception except
and since we don't have parameterize
virtual functions that's not quite
doable in C++ right now you can
parameterize implementations to to do
that and kind of reuse a little bit of
the of this boilerplate but still that's
that's not the main thing any question
about it also form okay so let's look at
slightly different example the main
difference about this example
handling of the visitors is that now the
essentially the the subject is not a
constant pressure okay so the meaning we
would like to give to this replace
replacement is essentially we don't
create a new data structure we instead
traverse this data structure and if we
find a variable with the name that we
are looking for we replace in place that
variable with with whatever we have we
have to replace it so clearly this
requires to have a right access to to
the to the objects that's why we don't
have haunts that creates a problem with
our current visitor implementation
because I mean as soon as we try to take
address of that uncovered type it's a I
mean you you cannot cast constant non
Const
well we can we can argue we can start
casting them and maybe pass always like
a modifiable reference but both kind of
like more like workarounds to if you
start contrasting them it's kind of like
deferring the troubles and like your
code will get even even bigger and hard
to understand now if we will decide to
pass it by reference always by
modifiable then a function like copy
where I take a bullet expression and
would like to create a copy of it there
is no need i I need to have a right
access to that function I would like to
have but like with with the
with the requirement or to have a
mutable access to the I will I will not
be able to put the Const on my copy
argument essentially and so one way or
the other like I will still have to do
Const cast somewhere so to do it
properly we will okay to do it properly
we will essentially have to add a new
visit visitation interface which is what
we will call here immutable bullets per
visitor which which won't help Const as
you can see which might look something
like this so the regular visitation
interface takes the the expression kinds
by Const reference and the mutable take
by by mutable references now notice we
have to implement two different accepts
one except that takes the mutable
visitor and another except that takes
the the immutable visitor we roughly now
doubled the amount of boilerplate that
we have to do right sometimes we can
save a little bit so most of the time
like your your functionality where you
really need to write it's just in some
of the cases that you have you need to
write cases but the remaining of the
functionality doesn't really need to so
what people typically do is they use
this trick called forwarding where the
mutable calls are forwarded to immutable
calls on the regular visitor and you and
we derive the immutable visitor from the
immutable visitor that helps us to reuse
sometimes some of the immutable visitors
and so that we can override only those
pages no to make here is how this
forwarding technique is useful not only
for this forwarding of mutable
implementations to immutable
implementations but it's also useful for
where inside your visitation interface
you have both base and the right classes
so let's say you
a instead of having like a value you
have now a try value which gives like a
third stage the value and the tribe Lu
is derived from the from the value so
you can introduce the tribe value into
the interface and make by default it
forward to the to the regular value or
something like that so yeah is it is
anything any questions on this okay so
what about the binary functions how
would we implement something like
equality of two terms where we don't
just want to uncover the type of one
argument but we want to uncover the type
of both arguments and do something on
the on those so we start the same way we
essentially declare a visitor which we
will call an equality visitor and
instantiate it call accept pass the
result etcetera
what's not clear is what should we do in
the middle because once we uncovered the
first argument the second one is still
uncovered so we have to pass the
uncovered first one somehow to no the
second one we do this essentially by
parameterizing a new visitor over the
uncovered type and that that helps us
essentially to to save the the static
file this seems to remember here like we
these patterns will repeat a lot so you
can easily factor it out into something
where you you just pass a visitor name
in and just do this sequence of
operations this is how the this
parametric visitor will look like so it
will essentially take the actual dynamic
type as an argument and
what it will do it will forward to a
function EQ which is which is
essentially just a set of overloaded
functions which I will show in a second
this is actually the first I mean in our
examples this is one of the useful
places where it would have been useful
to call it visit instead of calling it
specific because then instead of writing
five of them we could have just written
one wide because this is in case of
equality we are only interested in the
cases where both types are the same so
once we uncovered one arguments type we
are only interested to over to overwrite
the visit method on the same type and to
return false on everything else does
that make sense
okay so so essentially as rara
especially if you if you like to use
generic programming it's it's good to
call them all visit but if you are
presenting to students don't ok so and
so but basically the EQ does that does
the actual case analysis where we have
okay if they are both variables just
compare names if they both values
compare values if they are both let's
let's say and expression just compare
left and the right parts which is pretty
straightforward there is nothing so
communicate the same is I wanted to make
with this one okay one thing before I go
into the alternatives is note here that
we've used 5d table entries for
essentially each of the visit methods
and now we've instantiated five classes
using those so we essentially have now
spent like 25 V table entries why I
mention this and that's assuming only
immutable visitation so if you add
mutable than we have like 10 by 10
action but like why I mention this
because a lot of times this is mentioned
as
why people don't want to use multi
methods because essentially you generate
like n to the power of M table what we
will see in the slides is that this does
more like this generates more energy
ideas and the multi masters done if you
do it the visitors that way so what you
don't have to read this code essentially
this this does the same implementation
as we just saw for equal but it
implements match the only comment I
wanted to make but by putting all this
slide is basically that all these
boilerplate code that you see on this on
the slide is is driving to do this
little case analysis there so that's how
much we have to write and this is not
reusable both for its specific for class
hierarchy and it's specific for for from
match function so you cannot reuse much
of this you will have to write it over
and over again when you have that as a
new function on new class here are can
and you can try to reuse some bits but
it will complicate code again and makes
it more complicated so this seems to
take about the views of that pattern is
they provide less
extensibility of functions because we
can now add new functions without
changing the interface they are they're
fast they take just two visual function
calls which is better than a lot of
other alternatives and if you implement
visitors and pattern using not virtual
function but something like tag
dispatching when you know your your set
of cases is closed which is a pretty
common case in all the scenarios then it
can be even even faster it's a library
also solution so we can help ourselves
to basically do that we don't depend on
a compiler to implement at cetera the
disadvantage is it's extremely hard to
teach the students I was TA back at the
University and I had to teach it to
students and it took them about the week
of the bargain to really understand
what's going on and to be able to go and
like this use it with pattern matching I
can show them over
in the class and they will be able to
use it after the class which is kind of
what I'm saying it's it's hard to teach
it's also intrusive as we saw
specifically class here are here lots of
boilerplate through central inversion it
also hinders accessibility of classes
what do I mean by that we can still
derive new classes from those that are
already in visitation interface but they
will only be distinguishable as though
scape for us as those cases we listed in
the in the visitation interface so we
essentially we limit the set of
distinguishable cases let's say okay any
questions so far about the visitor
design pattern okay so let's move to our
first alternative which is the pattern
matching so what's what's a pattern it's
essentially usually a brief notation a
term that describes some sort of
immediate predicate on on an implicit
argument and implicit here is usually
important because you can compose
patterns and they usually correspond to
the composition of your subjects what is
pattern mentions and it's essentially
it's a usually a language facility that
that provides you the electronics in
text to do that and that allows the
compiler to generate an efficient
decision procedure that will do that
case analysis okay so that will do that
that checking examples of patterns we
find everywhere like wild cards
variables like regular expressions you
can compose those into terms you can see
drummers as as pattern two because they
distinguish you know valid programs from
invalid where a program is essentially a
subject so we see patterns in a lot of
different places why should you care in
in functional languages where it's the
pattern machine super popular para
machine has do not like to drastically
simplify code like there were documented
cases where people
when they had to choose the language for
the project they chose a functional
language just because of the pattern
matching in it versus C++ it's not used
only for this kind of like compiler
cases there is a paper where they also
document they chose blue either camel or
Haskell for some sort of like trading
company in New York I believe but yeah
you can do essentially high performance
computing too with these kind of
abstractions it's not inherently kind of
like non simplified when is it useful
whenever you need to perform an analysis
of structure of your data like wow it is
part of it that's that's when you
typically you will use it so now I would
like to show it on a real library that
we implemented as a part of this
experimentation the way the library is
not what we try to standardize or
anything the library uses quirks and
different things you wouldn't want in
the standard but the library gives you
pretty good idea what's possible and
efficient actually this is more
efficient than any other alternatives
for pattern matching we found in C++ and
we have performance results in the paper
so if you are interested that you can
look it up I have just like little
performance one slide on on it but you
can you can read more on the details so
don't don't take it as an actual syntax
that we are proposing take it as a
syntax we we use to experiment with
what's possible okay so the library is
called Mach 7 it's available in github
if you would like to try it and
essentially the code I'm presenting both
of visitors and
the the pattern-matching it's it's there
it's in files that start with cv pecan
so if you wanna kind of read those like
those those the ones you should start
start from a still kind of a student
project it's not polished into
industrial standards so I apologize for
that I don't have too much time to to
maintain it but I'm trying but yeah if
you if you if you ever want to look at
it start from the CP pecan files so what
the library brings us essentially the
library is it's a library solution to
pattern matching it's open to new
patterns what what it means it's that
all all the patterns in the library are
user definable so you can add your own
new patterns to the library and you will
be able to take advantage of the
efficient much statements that I will
show you in a second and the path
depends our first class so you can save
them in variables pass to functions
etcetera and their type safe it will
would say most of the time report
incorrect complication like we have like
a lot of static checks there whenever we
cancelled it so did you don't get like
all the templated errors on yourself so
it's pretty reasonable just to give you
an example I first wrote all the
examples in visitors and then it took me
about 1 hour 20 minutes to rewrite
everything using the library and of
course I had errors during that and the
errors were quite understandable they
were I could figure out from of course I
I wrote this so it's probably easier but
I
in all of the errors I had some
indications what went wrong so hopefully
yeah your mileage might vary but
hopefully it's not it's not intrusive so
you don't have to change anything about
your classes you can add it
retroactively way it works
what's what's more important why we
think it has a chance to sometimes
become part of language it works with
the with the existing C++ object models
so you don't have to change anything it
works in the presence of multiple
inheritance both repeated and virtual so
all that works and
so it's actually very efficient it's
it's the faster sometimes a little bit
faster sometimes a bit slower than the
visitors if you are talking about the
case analysis on on essentially dynamic
lives but it's not limited to just
constructor patterns it it as I said it
can take other patterns too so with this
how do you work with with the library
essentially and parts of it you will
also have in the language solution so we
have our old class here are where we
don't have any anything else and what we
have to do is to be able to do the
composition of those patterns we have to
tell the library what to match against
in the first position what to match
against in the second position etc so
that's kind of like if you if you looked
at the C sharp is is getting para match
into language soon and they have like
blue it's like es operator which is goes
kind of like this color way where you
can define what should be when you
extract so this is our way of doing that
bindings is basically for us to say
which member to extract in a given
position so members is essentially
something that generates code there it
doesn't have to be data members
specifically this can be freestanding
function taken as an argument the class
this can be a member like do I remember
function so everything and this respect
access control so you you I mean you
only get access to like public members
etc so this respects like encapsulation
and everything and then you just have to
say okay which of the existing patterns
like you would like to use in case you
just want to reuse some of them so point
point to note here it's not intrusive
and respects member accesses I said so
how would we implement the same evolved
using
this better mention library essentially
because in C++ we don't have implicitly
introduced variables like I have to
declare like variable patterns
explicitly which is what we do with
these red ones which are the patterns
the variable patterns but once we did
that we just do a match on the original
expression and we do okay in case it's
basically between K and C there is still
a parenthesis it's just like I was
trying to make it less of the color but
I guess here you can't see it at all so
case in this case but right like it is
right now it's probably closer to what
it will be in the language so ignore
that but yeah it's a wrapper and the
rest extra parenthesis there so we do
essentially and we say okay if if the
expression is variable bind whatever it
the name of that variable into this
pattern name if it's a value bind
whatever the value of that of that
actual value expression to the to this
variable pattern value and etc for like
sub expressions of each of those and
then we just essentially do our
traditional stuff so for the case of
variable we just returned its value from
the context we return the value there
the actual value itself or we pass
recursion forwards to recursively call
ourselves on sub expressions and that's
essentially everything that you have to
do to implement the same values and
using this library any questions on this
so the node two to make out of these
slides the same so same like whatever
brownish color these patterns they act
as patterns in the left-hand side so
they match stuff and they act as values
in the right-hand side because you saw I
could use name in the right hand side
and the right hand side I mean like the
imagine
lines that divides returned returns from
the from the case statements so you can
use them both as values and in the right
hand side as patterns in the left hand
side there is no controlling version
your returns are real so you don't have
to save your state etc and and you get
direct access to arguments so we didn't
have to save like context we just access
context directly from from the argument
list so the issue we saw with with the
replace where we wanted to have
essentially a mutable access to to the
tree it's it's even easier here we don't
have to do just because now the subject
where is is mutable the what what what
what's happened here actually once we
recognize a particular pattern the
library introduces implicitly a variable
called map Mac and position and the type
of it is the same as a reference to to
the type in the constructor pattern so
what happens here if the subject was
originally Const that reference will be
caused if the subject is is mutable the
reference will be mutable so we don't
have to do anything essentially to
distinguish you know mutable cases from
immutable cases we can now assign to
parts of those discovered cases and
drive our recursion for further the
point yeah at the point I did you said
that the ability of of the uncovered
subject is the immutability of the
original one now the point is here what
I want sales also in this case we have
to forget about the false through
behavior you have in the usual switch
statement why if you look at the last
two cases the code syntactically looks
exactly the same so you would imagine
like why why should we be able to just
you know fall through this thing is yes
it's the same however the type of match
zero is reference to end expression in
the first one and it's a reference to or
expression in the second one which is
why we can't reuse it because potential
results can be completely different
objects and stuff so this is this is
actually similar to how we how I showed
the example with equality the reason I'm
trying to show here an example of how to
do the match is because you remember I
had a slide how much it takes to
implement the match using the the this
resent pattern this is everything you
need to do to implement that same match
using the the pattern matching the
what's happening here essentially
instead of doing a pattern matching on
one argument we now do pattern matching
on two arguments one of them is P and
other one is X okay and then we
correspondingly have two sets I mean two
patterns for each of those so what we
are saying here if the first argument is
a variable expression with a given name
and the second pattern is anything which
is our instance of the wildcard pattern
check if if it's already in the context
if it's if if it's not just copied over
if otherwise check it's the same then
otherwise if it's value expression
checks that the other value expression
is the same the little plus you see it's
a it shows kind of like that set of
patterns is extensible in the library
plus is what's here is what's called
Combinator so it love it's an operator
that lets you compose new patterns out
of existing patterns what it does it
says okay once the variable pattern
value was bound in the first argument
use it as a value pattern in the right
hand side so basically make sure it's
the same in the right hand side against
what so what's that what the second case
say is like if they
both value expression and their values
are the same just return true and
similarly a further like if they're both
not expressions we just drive the
matching further on the essentially sub
parts etc so pretty much the same as the
same implementation will before just
equal but you can see instead of having
these pages of of stacks this is
everything that's that that you need and
that's exactly the same you can compile
both of those files on github and see
and it's actually faster than visitors
and Google's will see it in a couple of
flights so what else can we do it here
is something you can't do with it with
visitors imagine like we would like to
implement some this is of course not the
entire algorithm but imagine like you
would like to implement something like
this junk in normal form where you would
have to look at the structure of your
expressions so you might want to say
okay if my expression is kind of like
the Morgan law like if it's not applied
to not apply to some expression I can
just drop the two knots okay and return
e if I have a conjunction of something
and a disjunction of something then I
may be able to may want to redistribute
over disjunction and same for the second
argument so this is essentially
everything you need to write to be able
to express this kind of nested matches
and the library will will generate code
essentially to actually destructure the
subjects and do the pattern matching on
those and and do and do this we of
course visitors don't help you with
nested matches because visitors these
just help you to uncover the the highest
level but they don't deal with with the
structure because you can start
implementing kind of like what we did
with the match function but that's
already kind of moving moving it into
runtime like this is all generated at
compile time
the decision procedure one thing also
that that we I was getting several times
like people are asking can we do
something like this on boost variant so
I was trying to to finish the
implementation of this before this but
then I had to work on slides and and
that didn't happen but check so it's
written three nothing that still
prevents me I just have to finish the
bug in it basically yeah you can you can
you you you can do this I just have to I
had to refractor a little bit parts of
the library but yeah you can take a
variant and you can do essentially a
match and then say okay if it's a double
of that variant do something if it's a
complex which has sub parts you can also
decompose parts etc and drag your
recursion further it's it doesn't work
right now in the version that is checked
in there but I'm like 99.9% sure I'll
I'll get this to work so alright so some
summary to take about the the pattern
matching so some summary to take about
the pattern matching is it's it's
intuitive it's much easier and much
easier to teach and understand it it has
a I mean you can see in the code the
direct show of the intent as opposed to
like the boilerplate and you can do
relational matching easily as opposed to
have to do like stacks of visitors the
you can do nested matching which is you
cannot do easily with visitors there's
no controlling version you get local
reasoning so all your cases are in one
place so you get all that it's not
available language feature and this like
this can be abused people can start
using this in the cases whereas they
shouldn't something where a perfect you
know like virtual function would have
been ideal maybe people can start use
mentioned well they shouldn't so you
have to realize that that the the
pattern matching in general doesn't
solve what's called the expression
problem for those of you who heard it so
it still kind of limits it to your set
of distinguishable cases in the same way
there we sorta so it's not fully open
like like virtual functions are so
that's why you still have to be aware of
when to use one and when to use the
other when when you are dealing with the
open case and when you are dealing with
the closed case this will still work
with with your multiple inheritance with
everything you know like as long as it
falls into the one of the cases or into
the otherwise clause you can have the
otherwise other white clause as you saw
in one in some of the same as far as you
can express it in that generic setting
that is that's okay but what I'm trying
to say is like this you still have to be
aware of when to use one and when to use
the other so the second alternative is
open multi methods what's what's open
multi master it's basically multi
massive plus open class extensions
multiple dispatch is essentially virtual
functions on multiple arguments so
instead of taking just the dynamic type
of one argument into account when we do
a virtual function dispatch we take a
runtime type of several arguments to
drive the same what's open class
extension is basically a possibility to
add virtual functions outside of the
class so and that that's the data
something people request a lot so so I
would say like there is way more use use
use cases for the open class extension
and for the multiple dispatch and
they're like studies
it was done on Java but basically the
outcome of this the outcome of the study
was that
multiple dispatch on two arguments is
used like in probably like five percent
of use cases or something and and then
it declines like super fast even further
like on three arguments it was probably
like like two or three percent of use
cases and then like even less so what
what you would typically care is like
three still a lot of use cases for the
for the binary multi masses and the
Equality is what we saw so like when you
need to implement like deep equality
that's typical example or something that
is on two arguments but three is already
much less so examples as a set of use of
open multi methods equality shape
intersection is always mentioned object
interactions in games like if you have
some sort of like action system like
where you have actions applies to
objects as I also ideal for that why
should you care I mean it's nice to be
able to introduce virtual functions
retro actively without having to change
and it's it's it's good to be able to do
it on several arguments at least on to
which is which is what I mean when is it
useful I would say like when when you
need to do interactions between objects
so most of the use cases for the for the
visitors for also here okay so we
demonstrate with with experimental
syntax that we did on top of EDG to
implement evolve essentially what you
will do is you will declare like it's
what called the base multi method which
is the first one and you will say that
one of its arguments is yourself so
instead of saying that the the function
is inside the class equation now we are
saying which argument should be treated
as polymorphic argument and you can mix
polymorphic and non polymorphic
arguments and then the other ones are
treated essentially as the over-riders
for those the semantics that we give in
the in the in that paper is essentially
we give the
overload semantics taken at runtime so
let's say at runtime we will build the
dispatch table and we will for each of
the combinations we will pick the most
suitable overload available at compile
time as if all the overloads were
available in one place
so this implements the entire eval using
using the multi methods if they were
available in the language you can see
that there is no need to foresee all the
virtual functions you can easily mix
non-virtual initial arguments it's still
a little bit hard to reason locally
about because technically this doesn't
don't have to be all in one translation
units they can be scattered around and
there is still kind of semi inverted
control because we spider mention like
if you are in the inside of a loop you
can you know like save some state you
know like drive something using that
state here you will have to pass that
state explicitly into the call so that's
that's why I don't call it exactly as a
as a controlling versions but it's kind
of halfway there the same saying if you
if you were to implement equality of two
terms using multi methods we will just
essentially declare an equal
multi-method equal where both arguments
are are treated for for dispatch and
then we essentially by default we say
they are not and this is a specific case
where we interested in the diagonal but
like for example in case of match
function implementation they are not
exactly symmetric because we interested
like when variable is on the left and
anything on the right so so you can do
it other ways the only thing you have to
be aware is that this is subject to
ambiguity so like like you can have
ambiguous with the overloading you can
you can get those essential and now at
length time once we try to build a table
and you will have to resolve those
ambiguities which is which is why why I
think
presence of ambiguities is can be kind
of a negative factor for their adoption
because it might be less intuitive and
some of the some of the ambiguities you
may not be in the control off like for
example if your new over-riders come
from different dll's then essentially
our choice was like to make like a
non-deterministic choice of one of them
because all but but but still type safe
choice so like all of the them will be
still type safe but we we will just pick
one without specifying which one it
works with the current c++ object model
with multiple inheritance with virtual
functions and everything so to summarize
the multi methods they provide you both
extensibility of functions and classes
they're super facets we will see in the
next slide they're easy to teach people
get this kind of I mean once people know
yourself functions people people get
this easily to general they allow you to
the relational checks as I said like the
disadvantages is the sub they're subject
to ambiguities they require changes to
both linker and loader and ya know local
resident and second birth control so
just a bit of the performance numbers I
was showing so the basically the things
at the bottom is the number of arguments
1 2 3 &amp;amp; 4 on which we are doing this
this dispatching the red one is the
visitor design pattern the middle one
the blue one is the pattern matching the
types which essentially on top of which
the pattern matching is based and the
last one is the our implementation of
the multi methods so you can see that
multi mascots win regardless of the
number of cases I mean almost always
because they essentially the the table
lookups that's why but you can see also
that
visitors are slower I mean we are
comparable to visitors like in in the
case of the single argument but we
become faster than visitors in case of
multiple arguments of course probably
the only relevant is to but still as it
gives it and if you look at the the
papers and significant presentation
where we have more data we show like in
which other cases like how we compare to
other languages like Haskell camel and
think you know it's it's actually
switched by itself what this slides
present is essentially we listed all
those nice features to have what we
would like like accessibility functions
because its ability of data with x-type
saved the support multiple inheritance
is the support relational reasoning
nesting like NASA checks is it
retroactive can you add it retroactive
Lee just have like local reasoning this
have controlling version itself has so
plus is a good - is a bad meaning like
you cannot you don't have it in that
feature so you can see that that oh the
the stores is kind of like with where do
I have this data redundancy checking ok
so functional languages have redundant
to check in which is extremely useful
but they can do it because there a set
of cases is closed here we deal with
open case because you can always add new
classes so you you can't have the exact
redundancy check you know at least like
it's not in the form that is available
in functional languages but you can have
some sort of like at least you know
check whether you whether you have
otherwise clause or whether you have
something like that but you can see
better matching handles most of those
and it's comparable those numbers
actually we spider matching like if you
just take the types which in part it's
very similar to the to the visitor
design pattern so just as a conclusion I
will remind again the dr. Strauss
replied and yeah as we saw these design
pattern unnecessarily complicate things
it's extremely hard to teach that's
expert friendly actually while open
pattern matching is key still keeps
things simple and ignore the clerks of
the syntax it will be even simpler in
the actual language proposal it does not
sacrifice the performance easy to teach
and well right now available to try as a
library solution we we compile with I I
was after cpp now I was trying to make
sure it also built with clients I would
now build his client UCC in visual C++
if you want to try it if you have any
specific compiler you want me to make it
work with just send me an email and yeah
and open multi message they're the
ultimate performance and they still
extremely simple and they integrate well
with the rest of the language and I'll
take questions
as an actor
so in the case of multi muscles of the
indicates of pattern matching or so in
case of multi methods yeah we considered
that so we talked about dynamic linking
that's why I was saying like it requires
changes also to loader because at some
cases you need to be able to to build
some of those tables at load time but
it's doable and the only like with
regard to abilities you can have to
dll's that have perfectly unambiguous
set of over-riders
but when you load them together the set
becomes ambiguous and at that point like
there is nobody to resolve that so we
essentially will pick one implementation
of the other just deterministically but
on in unspecified way the pattern
matching yeah your classes can come from
you dll's and everything it will just
work it will fall into into the case for
the most for the least derived type that
is available in the case statement oh
and the first so it still works with new
classes coming from you dll and you can
implement new functions in India a lot
so it works does that answer your
question
okay any other question
and even other use cases for
ah
you mean I have well other like other
technologies to be able to do I mean
there are dedicated languages there are
like languages that deal with trees and
to be like if you look even like it's
something like XSLT es or like x dues
those are the languages that have the
construct to to essentially deal with
trees and you can try to to to mimic
that kind of functions you know you can
build your own da cells but I know like
if there is something like you know like
widely like this doesn't come to my mind
immediately you know like what would be
the the next best hammer to deal in all
the cases with these kind of
applications any more questions
so not nothing is clear all right thank
you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>