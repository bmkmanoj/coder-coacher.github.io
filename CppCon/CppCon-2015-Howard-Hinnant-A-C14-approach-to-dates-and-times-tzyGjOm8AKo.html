<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Howard Hinnant “A C++14 approach to dates and times&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Howard Hinnant “A C++14 approach to dates and times&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Howard Hinnant “A C++14 approach to dates and times&quot;</b></h2><h5 class="post__date">2015-10-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tzyGjOm8AKo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Howard Henan I work for
ripple labs senior software engineer for
ripple labs and basically what I have
for you today is a full day course
scrunched down to one hour and really if
if you take questions during that hour
this is a two-hour talk and we're gonna
fit it into an hour so I'm gonna ask you
to just hold your questions to the end
of the talk and if you're full of that
teach logical conclusions there really
won't be time for questions after the
talk either so my apologies I will be
around all day I love to talk about this
stuff so if find me after the talk I'm
happy to answer questions if you can't
find me after the talk search the net
for my name Howard in it my email is
easy to find I'm happy to answer
questions on email this is also talking
about a github project there's an issues
list on the github project feel freed up
to take advantage of that or even ask
questions on Stack Overflow if you tag
your question with chrono I will see it
guaranteed so moving on I'm gonna be
discussing a date/time library that I've
been working on for about past six
months this this library is a seamless
extension of the existing chrono library
so if you know chrono you already know a
surprising amount about this State
Library and if you don't well learn
chrono yeah chrono itself it comes with
your your C++ compiler it's great
library this library it's minimalistic
very small single header no source so
it's very easy to install just include
the header and off you go I'll get the
bad news out of the way upfront it won't
do everything you want however provides
efficient building blocks so you can
easily do everything for yourself that
you might want to do so in the big
picture
this library sits right on top of your
chrono header
it's called date dot H oh sorry about
that I am moving ahead and back up a
little bit here too many builds never
put so many builds in your in your
slides
okay yeah I probably shouldn't use this
header this this pointer there we go
okay so we're gonna be talking about
date dot age it sits directly on top of
your chrono header date dot H does not
do time zones the reason it doesn't do
time zones is because one of the big
features of date dot H is it it is a
very small library it's a tiny library
that means it's a very fast library and
that's part of the reason that this
library won't do everything you want
however if you do want to do time zones
there's an additional library that's
layered on top of this one called tzh
I've got just a couple of slides that I
might have time to talk about on that
but I'll be concentrating on on date dot
H so date dot H is composed of basically
three layers at the bottom layer there's
date algorithms on top of that and
completely encapsulated by that or what
I call type safe objects and then on top
of that is what I'm calling the cute API
and I'll explain all these terms the
important thing to remember is that the
data algorithms although they're in the
library they're not directly accessible
you access everything either through the
tapes type safe objects or through the
cute API so just as an example here's
what the data algorithms look like this
is an algorithm that converts a
year-month-day triple into a serial
count of days and it's not important
that you understand everything that's
going on up here
there's three things that I want you to
see one it's context per at least in C++
14 - there's no loops in here and 3 you
never have to deal with this type unsafe
API where you're only dealing with
integrals integers don't really
represent dates they represent anything
you decide they represent and so this
library hides that type unsafe API from
you here's another example this this
takes a serial count of days and goes
the other way and gives you a year month
day it's big mess
but it doesn't contain any loops and it
also doesn't contain any modulo
operators either during performance
testing as Chandler if you saw
Chandler's talk yesterday modulo is
pretty slow and there's actually a
couple places in here where I had modulo
and performance tested it sure enough
little branches are faster than modulo
at least on the architecture that I was
testing on which is x86 so every one of
these data algorithms there's about a
dozen of them or so they've been tested
over a ridiculously large range way more
than it needs to be and if you're only
interested in the algorithms that's a
whole nother talk it's got a paper
devoted to it you can go to this URL you
can read how the algorithms were derived
how they're tested etc etc know no
detail left unturned there so the type
safe objects there's an object called a
point that is the the central hub of
this entire library and then around a
point are all these other types that
convert to or from are from it some of
these types are what I call field types
that is with a type called
year-month-day for example this is
literally holding just three integers
one for the year one for the month one
for the day year month week day holds a
year a month a day of the week and an
integer that means this is the second or
the fourth Tuesday of the month or what
have you
your month day and a point are probably
the two most important types in this
library as I said before year-month-day
is just a simple thing that holds three
integers that's that's what it's good at
it's all it does in de point is our
serial pace time point all it does is
hold a simple count of days since the
epoch the epoch in this case is the same
epoch as your Chronos system clock which
is unspecified but the de facto standard
on that is everybody's counting
non-league seconds since January 1st
1970 so the way you access the data
algorithms that I told you about is you
convert one type to another when you
convert your month day to day point you
execute one of those nasty data
algorithms under the
when you do the opposite conversion you
execute another date algorithm and
that's the way this entire library works
you just convert one type to another to
do your kalindra chol calculations
finally the the cute API is simply a set
of overloaded division operators that
allow you to compose filled specifiers
into the field based types for example
if I have a year a month in a day I just
used the slash operator year slash month
/ day and you can think of this as a
factory function to generate a year
month day or conversely if you know some
of these things at compile time there's
all kinds of compile time constants in
this library and you can compose
something such as this to mean the last
Sunday in March for 2015 and that gives
you a type that's a factory function for
a type year month week day last now
surprisingly some people really don't
like the cute syntax and if you're one
of those don't worry the cute syntax is
this optional layer on top of the type
safe objects everything that this does
can be done with traditional constructor
syntax here's what it looks like if you
like that API better knock yourself out
it's all there so next I'm gonna dive a
little bit deeper into the
year-month-day field type here's you is
how you would construct one with the
cute syntax there's a underscore Y
literal to change an integer type into a
year type there is constants for each of
the 12 months this one September
obviously and then 25 which means today
this is September 25th 2015 all this
does is store three integers in this
very simple struck so there's no date
computation going on when you construct
a year month date
it's got observable field so what you
put out in you can easily get out so
it's very simple very predictable and
very efficient it's it's actually doing
nothing but that's useful and of course
all of this is observable observable at
compile time if you want to make a
context for year-month-day and static
assert what your fields are that's all
very doable everything is available at
compile time
year-month-day is the the best data
structure for year and month arithmetic
so if you want to add months or subtract
years that's all very doable I in an all
type safe syntax
you never can add an integer to a year
month day or subtract an integer from a
year month day because that would be
ambiguous what it means everything is
very type safe and the advantage of type
safety is that you catch your error is
that compile time if you want to do day
oriented arithmetic you need to convert
to day point for that and the reason for
that is efficiency
if you try to dude a point or if I
allowed a point arithmetic on a
year-month-day type it would have to
convert to the serial type do the
arithmetic and then convert back and
instead of hiding that expense I'm
making it very explicit that you have to
convert to the serial type to do that
type of computation this is kind of like
the difference between vector and dec or
vector and lists you choose which data
structures appropriate for the
computations you want to do if you need
to do a lot of push fronts vector is
probably not the data structure you want
to use you would use Dec or a list or
what have you so the same sort of thing
is going on here if you need to output
these things you get simple readable
streaming all it does is output the year
month and day so you can see what you've
got this is mainly useful for debugging
purposes there's very little formatting
or parsing available in this library
that will be a library layered on top of
this so if you don't need fancy
formatting and parsing you don't pay for
it here's an example of doing that each
integral type is explicitly not
implicitly explicitly convertible to the
Year month and days and back so that you
can develop whatever formatting or
parsing you need to here if I you know I
can read in 3 inch with no formatting at
all and easily form a year
they object and if just as a little
helpful syntax sugar only the first
field needs to be explicit if you want
to get lazy that's optional if you
specify the first field as a year then
it becomes unambiguous that the next
field has to be a month and an integers
acceptable there in the next field has
to be a day if for some reason you're
allergic to the year-month-day or during
day month year is also okay as long as
you specify the first object is the day
and month day year or terrine is also
okay it's commonly used in the US now
only those three orders are okay and why
did I pick only those three orders it's
because those are the only three orders
that people actually use on this planet
tough choice exactly now if you
accidentally type one of the alien
orders or if you accidentally do
something that would be ambiguous this
is an error that's caught at compile
time and I've got complete unit tests to
make sure that I'm catching every single
combination at compare at compile time
and only the good ones are coming
through so if you write something and it
compiles it will both be correct and
readable so one of the first things that
everybody asks when they say new date
library is how do you handle invalid
dates specifically I've got the last day
in January I'm gonna add a month to it
what do you do in every library has
their own different thing that they like
to do about this and they're all
reasonable answers some libraries will
assert you can't do this or throw an
exception or some libraries like the the
boost library will snap to the end of
the month and that's fine and still
other libraries will overflow into the
next month those are all kinds of ways
of of handling invalid dates and these
are all great choices and I've chose
none of them what I'm going to do is
push this decision on to you this
library is a fundamental building block
that's very efficient on the bottom
allowing you to do whatever you need to
do you can choose any of these now show
you exactly how you can choose them
what this library actually does do is
allow you to construct invalid dates now
I'm going to show you later that this is
actually a very powerful feature it can
actually make the code more readable and
add more performance and I know that
that may be hard to swallow now but just
hang with me by the end of this talk I
hope to convince you of that so let's
say that you just wanted to add a month
and make sure it's a valid month every
field type comes with a member function
called okay and all it does is say am i
a valid date or not so if you've got
January 31st you add a month to it the
Year month arithmetic only manipulates
the month and the year fields of the
year month day and later you can go back
and say say is is that a valid date is
it okay and that will leave the return
true or false and you can assert on that
it's easy as easy as this if you want to
assert so naturally if you want to throw
an exception it's practically the same
thing you check okay if it's not okay
you can take your time format up a
really nice error message and stuff that
into an exception and throw it and and
off you go
but how do you talk this library into
snapping to the end of the month
let turns out to be incredibly easy too
if you add add the month turns out not
to be okay you can construct a new year
month day by taking the current year the
current month and appending it with this
keyword while this operator called last
and that literally means whatever the
year in the month is I want the last day
of that year month day assign it back
into ymd and voila you're at February
28th or if it's a leap year the 29th
sure so what if you want to overflow
it's a little bit trickier it's not as
obvious but it's just as easy once you
learn the trick
you take your year month day if it's not
valid you serialize it into the serial
count of of days called day point now
every day point is valid it's just a
count of days it's just an integer under
the hood and when you deserialize that
back into a year month day
you'll get a valid year month day and in
this case if you jump from February 31st
2015 that will convert into March 3rd so
you've got all your options available to
you and errors are either caught at
compile time for example if you've got
an invalid ordering or an ambiguous
ordering with the with the ymd
construction or they're caught at
runtime with ok the library itself does
not check ok at all not even once it's
up to you to decide how often and where
you want to check ok that means you you
may sometimes have logic where you're
always adding a month and you know that
the day can't possibly be above 28 and
so you might not want to check ok yeah
so you can save cycles everything here
is about safety performance and ease of
use sorry I just said that
so this library also does not throw
exceptions with the possible exception
of when you insert to a into a stream
the stream may throw but besides that
this library doesn't throw any
exceptions at all but it's completely
exception safe of course so you can
throw exceptions whenever and however
you want to it leaves the decision of
how to handle errors completely up to
you it's error neutral so to speak so I
briefly mentioned this last thing and it
turns out that wherever and whenever it
is legal to specify a day it's also
legal to specify last and you can do it
in any of the three orderings your month
day day month year month day year it
doesn't make any difference these are
all expressions that create a type
year-month-day last and the api of your
month day last is virtual virtually
identical to that of your month day it's
guy year observer a month observer a day
observer it is even implicitly
convertible to your month day so we saw
this code earlier where I jumped to the
last day of the month
we're actually forming a different type
here with the year month day last but we
can assign that back into our variable
of type ymd which had type year month
day and he don't even realize you're
changing types it's an implicit
conversion it's also a very efficient
conversion and it it does exactly what
it looks like it's doing so very easy to
use and very efficient it turns out that
wherever you can specify a day in the
year month day ordering you can also
specify an indexed weekday so here these
are three ways of saying I want the 4th
Friday in September of the Year 2015
which happens to be today the type of
each one of these expressions is your
month week day and your month week day
is a very simple field type that's just
simply stores a year a month a weekday
and an index one through five it's as
simple as that when you construct one
absolutely nothing happens but those
four fields are stored so as you might
imagine again it's very efficient you
can print it out and you can get these
four fields or you can convert it to a
year month day object and now you're
executing one of those data algorithms
low-level under-the-hood that I was
telling you about and now you can get
your month and day of the month it's as
simple as that so you've got very
high-level access to these very
low-level complicated algorithms in a
very type safe manner it turns out that
you can also index weekday with last so
here are three ways of specifying the
last Friday of September of the year
2015 which surprise is today this is
another field type it's called year
month week day last and all it does a
store a year a month in a day of the
week so when you construct one of these
things absolutely nothing happens except
storing three integers you can print it
out and find out what three integers are
in that field you can explicitly convert
it to your month day or you guys
beginning to catch on a little theme
here this library is very self
consistent you know making it its API
conceptually very very small so you
convert it
that'll execute one of these data
algorithms under the hood you print that
out and get your three fields and you're
good to go so that's a rough view
quick tour of the field types they point
is what we call the serial base type and
its serial base because under the hood
it's nothing but account of an integer
and just like it's an important for you
to understand what's under the hood of a
vector or under hood under the hood of a
list I think it's important for you to
understand what's under the hood of each
of these data structures and de Point
just holds an int it's a count of day
since years 1970 day point is actually a
standard chrono time point it's as I
said it's a simple count of days and in
the library this is exactly how it's
specified so a day point I've told you
is the central theme of this library and
it turns out that the central theme of
this library is nothing more than a type
def for a type that's already in your
standard library in the chrono header so
that's a little bit remarkable how do we
create a date point it's very easy
create a year month day and that is
implicitly convertible to a day point so
here we've created a count of days since
September 25th 2015 today since it's a
chrono time point it has this member
function called time since epoch that's
going to return the duration type within
the date point which naturally is days
days is just a type def for another type
of duration in your criminal library
happens to be defined to 24 hours
surprise and you'll get wow it's been
sixteen thousand seven hundred three
days since the epoch how exciting as you
can might imagine since all this thing
does is hold an integer inside day
oriented arithmetic is incredibly
efficient on this type if I add two days
to it all it does is bump up that
internal count by two days and it's as
simple as that
so we're talking very high performance
here for day oriented arithmetic other
date other date libraries like a boost
date/time are like the Blumberg date
library all they have is date point but
they'll call it something like date but
internally all they're doing is exactly
this and so day oriented arithmetic is
fast on their libraries too but your
month day arithmetic is slower because
there
verdun back to the ymd format to do the
year and month arithmetic so des point
is a time point just with a course
duration it is a system clock time point
now system clock time point is actually
going to be something with a duration of
microseconds or nanoseconds it depends
on on what platform you're running on
and a point is very closely related to
that it's the same thing just translated
to have a course or duration that of
days the chronal library has something
called time point casts that allows you
to convert a fine resolution day point
to a course Reza
fine resolution time point to a coarse
resolution time point and that's all
this is doing you can use the existing
time pointcast conversion function that
comes with your chrono library to
convert the output of system clock now
to add a point so if you want to find
out what day it is
call system clock now if you run that
right now it'll give you the current
time now there's there's one
disadvantage of time point cast and that
is that it truncates towards zero always
now that's exactly what you want when
you have a positive time point but for
negative time points at train it
truncates upwards towards zero and you
get negative time points when you deal
with days before the epoch that is
before 1970 so I've I'm creating a new
rounding mechanism that's called floor
which rounds towards negative infinity
so that it actually gives you the
expected results for all time points not
just those after the epoch it's just as
efficient as time pointcast in fact it
actually calls time point cast and then
does the rounding for you
and so I favor using that if you don't
like floor for some reason you can
always use time point cast and it'll
work exactly as you want as long as you
stay after the epoch but I like time
point cast I mean floor because it's
easier to type it's easier to read and
it always gives the right result
so what does this look like we call now
we look inside with the time since epoch
method and we run this today and we'll
get sixteen thousand seven hundred and
three days again it's as simple as that
so how do we deal with dates and times
well it turns out that you've already
got in your standard library a wonderful
date time type and it's called system
clock time point and date point is just
another version of system clock time
point so I'm going to leverage all of
this out of the chrono library to to
just glue all this kalindra cool stuff
and date time stuff together so in this
example I've got a time that is just two
days after the epoch and that's just to
make their arithmetic very easy as you
saw before I can create one of these
things print out the time since epoch
inspect it see that there's two days in
there if I want to I can simply add
hours to it as easily as this in c++ 14
there's user-defined literals for all
the durations hours minutes seconds
nanoseconds etc so I can take this day
point and add hours to it and all of a
sudden I've got a time point that has
the duration of hours instead of days I
can look inside of it and I've got 48
hours for the two days plus another
seven is 55 hours it's as simple as that
you can add minutes to it I can add
seconds I can add nanoseconds you can
add any duration you want to do it
there's no limit for this slide I've
stopped it seconds just in it make it
not too crazy and so and everything
would fit on one slide you can look
inside this thing and find you have two
hundred thousand seconds which
coincidentally is two days plus seven
hours plus thirty three minutes plus 20
seconds so in one line here I've gone
from six field types down to a serial
count of seconds since the epoch all in
one line and all very easy to read very
nice calendrical computations going on
under the under the hood here ok now
that I've got this count of seconds
since the epoch how do I go the other
way how do I recover these six fields
from this
200,000 seconds so you first can recover
the day point with the same way that
I've been showing you before this is
nothing but another time point with a
duration of seconds this time take the
floor of it I'll get a day point I'll
look inside under the hood there's two
days in there so that's not quite what
we were looking for however add a point
can be thought of as a time point to the
very first minute of a day so if we take
this fine precision time point TP and
subtract from that the coarse precision
day point time point DP you get the time
since midnight now you get it in seconds
but we'll deal with that but it's a it's
very intuitive once you once you know
the tricks you want the time of day you
subtract the current time minus the time
that corresponds to midnight simple as
that there's a factory function called
make time it'll take any duration you
have whether it's nanoseconds seconds
hours what-have-you and then we'll break
it down into a field type in this case
hours minutes seconds so I take my
difference send it through make time I
get this structure out now I've got
field observers for my hours minutes
seconds lo and behold I've got seven
hours 33 minutes 20 seconds just like I
had up at the start we still haven't
recovered or your month day but you
already know how to do that you take the
day point you convert it to a year month
day object and now I've recovered my my
three fields for the day so I've gone
full circle almost all on one slide I
had to scoop things around a little bit
if my slide was a little taller or made
the final a little smaller I could fit
it on to one side but I wanted to make
sure you could read it so I preferred
the sliding solution much of what I've
just shown you already comes from the
chrono header even though both the
interface and the implementation if if
you happen to be somebody that already
knows chrono
you'd be you'd be saying you're not
really presenting anything new that's
all chrono library and you would be
exactly right
so if you want to learn this library
learn chrono first and then when you
come to this library you'll just say
well yeah
this is barely even a library and it
really is this is what makes it small
this is just a very small extension on
top of fronto into the realm of
calendars mainly the year-month-day type
and these type desks for a day Point and
days is really all this is so how
expensive is all this good question
glad you asked so instead of running
timing test what I'm gonna do is show
you a couple of examples that are very
small functions and I'm going to code
them two ways in a variant I'm gonna
code them one in a very low level see
like way and then I'm gonna code them
again using this library I'm gonna
compile the code with optimizations
turned on and show you this simply and
don't worry I know everybody doesn't
know how to read assembly I'm not that
creative regen assembly myself but the
examples are gonna be short and I hope
to be able to show you what you need to
know without needing to be an expert in
assembly language programming so I'm
going to start with a very simple ymd
struct
here it is it's got a 16-bit year in
8-bit month they put a very simple thing
and I'm gonna make a factory function
for it and all it does is takes three
ents stuffs it into this thing and
returns it now how do we do this same
functionality in the date library well
as I showed earlier I prefer the cute
syntax you could use the conditional
constructor syntax if you prefer but you
take three ents you type you explicitly
cast at least the first one to a year a
month or day and then you add the others
and you can return that and that'll be a
year-month-day object so compile both
sides of this down to assembly optimized
assembly let's see what we get here we
are we get virtually identical assembly
generation up at the top you can see
that I've got different mangled names so
what and if if I gave you enough time to
stare at this you would see that the or
elles though or longs at the bottom
they're switched in order and that's it
this is virtually the same assembly
there is absolutely
no space overhead and no time overhead
for this cute syntax or for this library
at least for constructing your month day
one more example here this one's a
little bit more involved I've got a
situation where I'm measuring seconds
since a different epoch I want to
measure seconds since the year 2000
instead of since 1970 why well that's
what that's just what I want to do it's
my employer made me here's how you might
do it in Cincy or a low level you'd
store your time point and along and then
you'd go off to the side and you'd say
ok how many how many seconds are there
between New Year's 2000 and New Year's
1970 you'd go off and you'd compute all
that and you might even get the right
answer and then you'd add it to your
time point to shift from the year 2000
back to the year 1970 how do you do it
in this library it's a little bit more
verbose but it's a lot more typesafe i'm
not going to store my time point in
along not a Neanderthal I'm gonna store
it in a chrono time point I'm gonna use
system clock as the clock and say
specifically specify that I'm specifying
I'm using durations seconds so now I've
just got a count of seconds and I'm
going to add to my count of seconds the
difference in time between January 1st
2000 and January of 1st 1970 so yes it's
a lot more verbose but I've taken one
magic number and turned it into 4 magic
numbers in and all of a sudden it's a
lot more readable the four magic numbers
over here you know what they are they're
the day in the year it's very obvious
yeah well I hope it's obvious right
right so how much does this cost us
let's compile both sides optimizations
on take a look it's identical
it's absolutely identical you can even
see the magic number on both sides the
99 hundred and forty-six million seconds
or whatever it's on both sides so let's
take another look at that how did that
actually work over here we've got to
serialize both of these days convert
them
two days and subtract them to get 10,000
some odd days convert that to seconds
because the compiler knows I'm adding
days to a time point based on seconds so
it just does that automatically and it's
doing it all at compile time this is
amazing this is where Const exper really
comes in even though there's no context
per anywhere visible in this user level
code Const exper is helping the compiler
do all of these computations at compile
time creating efficiency equivalent to a
silly
well maybe not silly but it obviously
efficient C implementation of this
function so let's do a little bit of
runtime experiment to do runtime
experiments of taking chosen to other
victims the Bloomberg library and the
blue state time library and I'm terrible
at names I don't know what we're calling
the state dot H or what or whatever and
just as an example for demonstrating the
runtime performance of this library
developed a problem I want to throw a
party on the fifth Friday of every month
that has one so I'm going to write a
function that takes a years input and
I'm going to go through all 12 months of
the year and if the month has five
Fridays I want to print out that date
and send out invitations and I'm gonna
do it for each of these three libraries
and my questions are how easy is this to
code and how expensive is it at runtime
and also in code size so for those
watching this talk on video afterwards
I'm putting all the details of exactly
how I'm doing this test so that you can
go home and reproduce this on your own
computer just to make sure that I'm not
making things up on there on the sly so
I'm I'm inputting a year to this
function right here as just an int and
then for output I've just made a
homemade struck now if this were a
production code I would obviously output
this and whatever native format that the
boost that the date/time library
happened to have but so that all three
of these libraries are having doing the
exact same thing
standardizing my output and input like
this and since there's no going
be I'm gonna put all the dates in a
standard array of length five and then
I'm also gonna pass back the logical
length of this array which is always
going to be either four or five because
it turns out that there's always either
four or five fifth Fridays in a year I'm
doing everything at - oh three here is
the driver I'm using and fifth Friday up
here is the function that I'm actually
timing I'm wrapping that with steady
clock now I'm gonna read my year in from
from the terminal and the reason I'm
doing that is because I know my library
is very aggressive at computing
everything at compile time if I told it
to it would compute this whole thing at
compile time without me even blinking
and then we wouldn't have anything to
measure so I'm reading in the year to
make sure that that doesn't happen
and then I'm printing out the results
just to make sure that the optimizer
doesn't optimize everything away that
I'm trying to compute and then finally
I'm printing out my account and for my
platform steady clock now traffic's in
seconds I think that's true for every
platform I'm not positive any rate so
we'll get output that looks like this
it'll print out the days and then the
time in the nanoseconds and I also
discovered that if I read my year in
from a file that I got much more
consistent results than if the program
was waiting for me to type everything on
the keyboard so I'm I put the Year 2015
into a file and I'm executing it like
this oh and one thing I forgot to
mention on the on the previous slide I'm
actually gonna run this two ways this is
exactly how I'm running it for the first
way and this is called the cold cache
run I'm only going to execute it once
and I'm gonna run this ten times
manually and give you the average of
those ten times but then I'm also going
to do a Hut cache run where I'm gonna
put a thousand calls two fifth Friday in
between the two statements from now time
that whole thousand calls and report
back one thousandth of that call so you
can see what the hot cache results look
like because it makes quite a bit of
difference whether we've got everything
in memory in the memory cache or whether
it's got to go all the way back out to
which it's very slow as some people may
have told you in talks earlier this week
so moving on what does this look like
oh and disclaimer this is not a complete
compare comprehensive test this is just
one little small test just for this talk
so take it for what it's worth I sent
this problem off to John Lycos at
Bloomberg and I gave him code how I
thought it should be code and I said
look John I really don't want to present
your library in a bad light
am i doing anything stupid here how
would how would you code this problem up
with your library and it really got out
of hand he gave it to his engineers and
they worked on it for like two days
and I sent me back this what they did is
they realized that there's only 14
answers to this problem there's only 14
calendars January 1st can start on one
of seven days and you can have either a
leap year or a non-leap year and once
you know all those things you know you
know the answers and these are the
answers so I really didn't intend for
them to do it this way you know I was
actually trying to measure something
that was something people might actually
code up as opposed to this but it was
interesting nevertheless so I wanted to
present it and so it's not important to
understand all the details but basically
they're seeing what day of the week
January 1st is on and whether it's a
leap year or not and they just look up
the answer in the in the table of 14 and
spit that out so you might imagine that
this is very fast you really can't get
any faster than this so it gives us a
lower level to aim for so code size it's
it's about 132 K that's measuring the
entire application not just fifth Friday
and the reason I measured the entire
application is because some of these
libraries are header only some aren't
and I needed to do something that was
the same for everybody and be fair so I
chose the entire application and this
clocks in at just under three
microseconds for the cold cache run and
for the hot cache run at an amazing 100
and not 89 nanoseconds to calculate the
five Friday's in the year 2015 so very
impressive congratulations Bloomberg and
I'll just admit right up front
on the hot cash run nothing gets faster
than that you know you just can't get
faster than pre-computing all your
answers looking it up in a table with a
hot cash so they win III admit defeat
next I I sent this off to Jeff Garland
who wrote boost and he sent me back a
couple of suggestions to do it a little
better and I've incorporated those here
and I'm doing more what you would expect
here I'm simply you know you get the
year from the input you loop over the 12
months boost has this in stay of the
weekend month where I can ask for the
fifth Friday of the month get the day
out of doute now boost does an
interesting thing here what if the month
doesn't have five Fridays what they do
is they say oh you must have meant the
fourth Friday okay I can deal with that
so when I get my answer back all I've
got to do is figure out whether it sent
me the fourth Friday or the fifth Friday
and if you if you sit down with pencil
paper and a calendar you can figure out
well if it's the fourth Friday the day
of the month all it's always going to be
less than twenty it's gonna be twenty
eight or less and if it's a fifth Friday
the days are always going to be 29 or
greater so I'm using that to figure out
if I've got a fifth Friday or not and if
I do I'll push it onto my stack and
results in a move on to the next month
so boost is header only so the code size
comes in impressively lower the the cold
cash time is about twice as much that's
really not that bad it's actually
computing things that run time instead
of looking things up in a table so when
you think about it that's really a
fairly impressive result for boost and
if you warm the cash up you get down to
under two microseconds so we're doing
good there now after I sent this to Jeff
he said hey you know I'm working on this
boost date/time version two innocent
really you know close enough to test
they said well you know it's still under
construction but yeah you can test it I
don't mind if you present it so let's
take a look at that
the syntax is a lot nicer and actually
it's quite similar to what I'm doing
except with some renaming but he's got a
year-month-day object there too just
like I do the accessor for day is a
little bit different but we're just
talking syntax here
it's
has the same semantics if you asked for
the fifth month I mean the fifth Friday
it doesn't have one you get the fourth
so same logic going on here and let's
see how it did understand that this is
still under construction in fact to run
this I had to include both the v1
libraries and the v2 libraries the goods
give Jeff a break he's working on it
so the code size a little bit bigger
because I'm actually using both boost v1
and v2 and correspondingly the cold
cache run is a little bit slower
it's cashing in more code as well as
more data because it's using two
libraries and so cold cash runs really
aren't that surprising the hot cash runs
come right down to where you'd expect
even a little bit faster than boost v1
so that looks very good so okay let's
get on with it how do you do it with
this library first I form I find the
last Friday of the month just like this
using the the cute syntax that I prefer
and then if you recall I've got this
thing called year month week day which
stores and index is one of its fields so
I take my year month week day last and I
don't have to spell that ugly type
anywhere convert it to a year month week
day ask it for its index it's gonna come
back as either four or five if it's five
I've found a fifth Friday and I'll push
it on to the sec to do so I need to
convert it to your month date object so
I can get a day of the month out of it
but beyond that we're good to go
so I actually find this more readable
than the Bloomberg library believe it or
not I also find it more readable than
the boost library because I don't have
to know what the policy is here on what
happens if the month doesn't have fifth
Fridays the Bloomberg library actually
if you ask it for the fifth Friday and
the month doesn't have one it overflows
into the next month that gives you the
first Friday to the next month so
there's all kinds of policies that you
need to be aware of depending on the
library that you're using here is code
that's policy neutral you don't have to
know give me the last Friday tell me
whether it's the fourth or fifth it's as
simple as that
so what I pay for that convenience code
size tiny 15k runtime size cold cash
shit Wow think about this cold cash it
is faster than pre computing the answer
into a table and looking up the answer
in that table of 14 things how can that
be the reason for that is code size I
told you at the beginning of this talk
that this library won't do everything
you want that's not a bug that's a
feature that's how it's that's how you
keep it small that's how you keep it
fast very small code size you warm up
the cache and you don't get a huge boost
because there's not much to cache in its
there's not much difference between the
cold cache and the hot cache performance
but it's very respectable in a real
application you might not have a hot
cache real applications don't spend
their time finding the fifth Friday of
the month all the time you've got other
things to do and in a real epic
application your date computations are
just a tiny part of your real
application so I think that your cold
cash measurements here are actually very
important so this date library could
conceivably be faster than the
precomputed bloomberg solution that that
the pre computed solution that Bloomberg
gave me but I'm not quite finished
there's one other way that I want to
show you since it's my library I get to
show you two ways for my library let's
just go ahead and ask for the fifth
Friday I don't know whether the month
has the fifth Friday or not we'll just
ask for it what does this library do
it's very self consistent it just stores
the numbers in a field then I can say by
the way did I give did I create an ok
date is this valid if so convert it to
your month day store it if not loop on
around to the next month for readability
purposes this one's my favorite opinions
may vary if you like the previous one
better go with that you're not going to
do very bad ok but let's say that we
like this one how much is it going to
cost us
code size it's not going to cost us
anything
run-time sighs our cold cash run is now
as fast as our previous hot cash run was
and our hot cash run is getting
competitive with the Bloomberg solution
I think we're about 220 nanoseconds or
something like that compared to 189 it's
in the ballpark
I find that impressive I was pleased
with this result even though they beat
me I was pleased with this result
knowing the way that they computed their
runs so there's three things I want to
want you to get out of that performance
test date dot H is small it's fast and
the ability to create invalid dates
without being scolded with an assert or
a throw or with some approximation of oh
you meant the fourth or oh you meant the
fifth Friday or whatever then the
ability to create that invalid date is
both a readability and a performance
advantage so if that's the only thing
you remember out of this whole talk I
think that third bullet right there is
the most important thing to remember
let's see from the C standard if you go
to the C standard and read about make
time and struck diem and all that
they've got in the C standard this
question how do you what day of the week
is July 4th 2001 and just because I was
in a good mood I thought it'd be fun to
compare how how they present to do it
and see with how you can do it in this
library so let's take a look I'm not
going to review all this code because
you guys already know see right it's a
little bit easier with this library you
use the cute syntax you construct a
weekday you printed out boom you're done
it's practically a one-liner if you
don't count the using declaration and
they includes and if you want to show
off yeah all my inputs are compiled time
you can do it at compile time at least
in C++ 14 the library will auto port to
C++ 11 but that means erasing a lot of
the context per so you lose a lot of
your compile time computing ability I've
got since I got a little bit of time
left 10 minutes
so I want to give you just a couple of
slides about the time zone library this
isn't gonna be a complete thing
basically what I want you to get out of
this is just for you to know that it
exists and get some kind of feel for how
it might work it's got this thing this
function in it called locate zone and it
works with the ia ia in a time zone
database so it uses all those names you
send it whatever time zone you want
locate it
you take your system clock and you floor
it to milliseconds I could have taken
nanoseconds or hours or used any
duration I wanted to there you'll get a
you'll get a time point a system clock
time point but with milliseconds
duration in this example send it to the
zones to local Member function and it
will give you back in a pair of a time
point in an abbreviation for that time
zone so here I just print out both
things of the pairing I get what should
be very close to now hey I'm only a
minute off that's yeah it's not bad eh
that was that's magic so it prints out
magically now and PDT for Pacific
daylight savings time if you don't also
if you don't want to have to always
specify a time zone you can of course
get the current zone on this slide only
the first line has changed from locate
zone to current zone so and from there
on it works just the same this this is a
parser for the entire ia
in a time zone database history which
has time zone information dating back
all the way to the 1800s so here just as
an example I in this same time zone the
knows time zone we're sitting in I look
back at February 10 1942 and print out
the time for that and if you do the
arithmetic it turns out that they went
to daylight savings time in the middle
of the winter for this year and they
called it war time instead of daylight
savings time this is World War two so
might not be practical but for time
nerds like me I find
really interesting to be able to explore
the entire history of time zones not
just for this country but all over the
world this is a wonderful database and
so to give it give it what it deserves
I've made a very complete parser on it
it also includes leap seconds in the
database and there's facilities for
computing with leap seconds if you care
to do that I think one should resist
computing with leap seconds for as long
as possible because usually when you do
it it's error-prone and you may not get
any be getting more accuracy than than
you were after so use the leap seconds
with caution but it's there if you need
it in the time zone library so in in
summary I've presented a high
performance minimal API extension made
to chrono enabling easy and intuitive
kalindra cool computations it doesn't do
everything everybody wants it to this is
not a kitchen sink API but it should
enable everyone to build on top of it
and do whatever they need to without any
performance motivation to not use it at
all it's a good base to build from
there's a complete paper on it at this
URL and this paper has links to the
github URL where the library is actually
located this is just the documentation
the documentation includes a bit of a
tutorial and a complete reference of
every single type it's very well
documented and it also includes links
both to the algorithms paper I mentioned
earlier if you want to look at how the
algorithms were put together and to the
time zone library if you want to go up
the stack and look at that and finally
I'd like to acknowledge that this
library was not written in a vacuum
it's the final a listeria and john wrote
this very fine paper several years ago
in 3344 which very much influenced the
design of this library this paper is
essentially what convinced me that I
needed to provide my clients both with
the serial type and with the field types
so that they can do what they need to do
in the most efficient way possible
and also Jeff Garlin's boost eight-time
has been a tremendous influence on this
library I'm very grateful
in fact the chronal library was highly
influenced it was directly derived from
boost date time so all of this is stands
on the shoulders of Jeff Garland and the
context for work is just critical to
making this thing scream fast even
though you might not have a compile time
date that you need to use maybe you've
got a few compile time pieces like fifth
Friday
those are compile time numbers and that
contributed to the speed of this thing
because it allows the the compiler to
propagate those constants all that much
better so kudos to Richard Smith and
Gabby and bianna four for doing all that
work with constant expressions I'm
extremely grateful so we've got just a
couple of minutes left over I'm done
with my talk I'm open for questions yes
oh no I'll let you choose whoever's
going to chest can we have audio here
you may just go ahead and speak up and
repeat the question
it it has a not oh does the library have
anything for just month day it has an
object called month date yes and it just
stores a month and it stores a day and
so you can use that if you need to as a
partial date yes why is that
okay function faster in comparison I'm
curious to tell you the truth I'm still
studying up on that I've looked at the
assembly it's about 500 lines of
assembly and I haven't gotten all the
way through it and so if I gave you an
answer right now I'd be purely guessing
my best guess is it's propagating the
constants and to tell whether the month
is okay it doesn't have to do quite as
much computation and it's reusing
that same computation inside the if
we're I convert it to your month day I'm
guessing that's not a definitive answer
won't need access to what yes you need
to access the index yes back in your
slide where you showed the check on okay
to detect an invalid date and then you
make a correction to it what happens if
it's the middle field that's invalid in
other words if you don't know which
field is invalid can you explain to us
the process for checking that sure so
the question is what happens if it's not
the index field that's invalid but say
the month or the weekday that's invalid
you can get there's getters for every
field and then each of those individual
fields has an okay member function on it
so if you were paranoid you could go
through and say is the index okay is the
day okay is the month okay etc etc but
ultimately you still have to ask if the
entire collection is okay because five
is a valid index although it might not
be valid for the month of May 2015 or
what have you
have you considered submitting it as a
standard or to boost so they don't have
to come up with v2
right I am considering it I don't think
this is yet mature enough to to submit
to the standard I'm waiting on you guys
to tell me whether you like it or not
and whether you'd like to see it in the
standard so I'm glad you asked that
question and I want you guys to answer
it and get back to me hi thanks so the
UM thing it looks really really cool and
did I get it correctly that you don't
use anything like ICU for the time zones
that's correct
I'm this is going straight to the
publicly available
I am a time zone database and I'm
parsing that there's time for one more
question
I don't want to take the last question
so just be fast
I saw a floor of you know type system
clock clone clone now I wonder if
there's room for some syntactic sugar
there I mean I guess a client could
write that themselves but you know like
a today or now of this that that you
know just didn't make you write the
floor that was the one thing that looked
a little off-putting and you mentioned
it yourself
I am certainly open to discussion on all
parts of this except maybe for making it
bigger so yeah if we want to tweak the
syntax I'm very open to that all right
oh one more question okay this would be
a quickie when you said that the the
times are by default by implicitly UTC
is it are they actually eat easier just
agnostic to the actual time zone they're
technically they're UNIX time which is a
count of second since 1970 - leap second
account of non leap seconds well almost
UTC thank you as a beautiful elegant
library thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>