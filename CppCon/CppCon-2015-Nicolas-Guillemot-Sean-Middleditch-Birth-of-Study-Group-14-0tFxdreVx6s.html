<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Nicolas Guillemot &amp; Sean Middleditch “Birth of Study Group 14...&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Nicolas Guillemot &amp; Sean Middleditch “Birth of Study Group 14...&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Nicolas Guillemot &amp; Sean Middleditch “Birth of Study Group 14...&quot;</b></h2><h5 class="post__date">2015-10-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0tFxdreVx6s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everyone and welcome to our
talk the birth of study group 14 big
games and low latency group so I am Sean
middleditch I am the lead server
engineer at wargaming Seattle my name is
Nicholas I'm a student at university of
victoria i'm currently work at Intel
Jane graphic stuff worked at Electronic
Arts in past and Michael Wong is the
chair of the group so a lot of this is
put together with this hard work so
thanks to him for that so quick overview
about what we're going to be talking
about today we're going to be talking
about what sg14 is why it exists how it
fits into the standards committee we're
going to go over some it's about why
sg14 needed to exist and in our
experience and opinion then we're going
to go over a bit about what our current
efforts in the study group are what
papers were working on the kind of
things we're researching and getting
ready to propose and then we'll talk a
bit about some of our upcoming efforts
our plans and ways you guys can help out
so just kind of get a run in the mood
this is a picture from a recent release
for my company this is world of warships
for more gaming made by my colleagues in
st. Petersburg so you can get kind of an
idea as to the level of graphics going
on here and an in-game there's these
ships of huge batteries of guns there's
a whole lot of whole lot of things going
on so I kind of want want you to get a
sense of you know what exactly it is
we're doing in games industry looking
you know this amazing picture it's going
to be I think the only nice pretty
screenshot so so good another
interesting fact something that I found
kind of surprising myself is that game
developers are the third largest group
of developers using C++ regularly after
the banking and finance industry so
there's kind of a sense with some people
that games are sort of an ish and that
that's not true Oh third largest I think
we've kind of surpassed the nish
category
I'm going to begin by talking to you
about the origin of sg14 and how he got
to the point which is today thanks so it
all began at CP Con 2014 last year there
was a panel that was called grill the
committee where audience members were
invited to go ask questions to the
committee in an attempt to grill them so
at this panel I went up to the
microphone and ask them if anybody there
was representing the games industry and
there was kind of an awkward silence not
really a good answer and so at the end
of this panel at the end of the panel
there was Michael Wong who is sitting
room somewhere who's Michael oh there is
Michael long so Michael Wong stood up
and came to me and some other game
developers who were in the room and
suggested that we talk more about the
issues that game developers have with
the sequel sauce programming language so
we organized that impromptu meeting at
CP con 2014 where all the game
developers there got together we talked
about some issues we went for lunch was
good time and then when cpu con 2014 was
over Shawn miletich here created a
google group where people were invited
to come and talk about various issues in
involvement C++ so for months we talked
about various topics just pretty much
saying whatever came out of mind just
having these discussions about virus
problems and solutions relating to the
sauce programming language and finally
we decided to take a bunch of our like a
bunch of these threads on that google
group and kind of merge them together
into one paper which is an 4456 and this
document you know is it's an official I
so you know paper and it was presented
by michael wong and billy baker in
lenexa at the spring 2015 standards
committee meeting it was very well
received a lot of people there echoed
exactly was said on the paper and it was
so good in fact that it was suggested
that we actually form a new study group
study group 14 where we would be
officially talking about the concerns of
game developers and lowly NC in terms of
C++ with Michael Wong as a chair
as well as creating group we decided to
organize two meetings the first meeting
was at CPD Con 2015 so this year
actually this Wednesday and the next
meeting is going to be at the game
developers conference GDC in 2016 hosted
by Sony their grandmas in the meeting so
this is a picture from the eyes of CPG
our website it shows the organization of
the committee as a whole and you can see
here that among all the study groups we
are than us one SG 14-game definitely
and see so legit one of the main goals
of sg14 is to improve the communication
between the game development community
and standard C++ committee so you can
see here has kind of like a
bidirectional relationship we have the
industry members the game developer
begin well person etc who come to C++
events and meetings to be able to share
their opinion on what needs to change
the language and present papers to the
committee and on the other hand we want
to have standards he left us committee
people to come to meet game developers
at events such as GDC to return feedback
on the papers proposals written by game
developers and you know hopefully find
some middle ground and in the problems
let me presented pretty quick after we
started looking at this this issue of
improving see allseller game development
we also noticed that a lot of our issues
actually overlap with a lot of different
fields of C++ so this is just some
examples for example simulation and
training software it's very similar to
games if you think about it it's
basically just games but more serious
there's always an element of interactive
simulation real-time graphics Lillian
see computation this is an aspect that's
also assured by Finance and trading they
also want Lois Lindsey possible and
embedded systems which are almost by
definition a design space where you
actually have very constrained resources
and that's a very similar theme to a lot
of game development that goes on so this
is a presence on the web we have a
Google Group everyone's welcome to post
it's not passworded you don't need to
register an account or anything you can
just go there and you could just post
about stuff so
welcome to discuss problems and
solutions with the sequel's programming
language with us and create new papers
and proposals we also have a github
repository that was created by a guy
Davidson sitting over there on Skid hub
you can find the current state of the
proposals and usually some example code
if it's a proposal that has code
associated with it so check it out and
for now I'll pass to Shaun talk to about
control and reliability all right so
we're going to talk a little bit about
why sg14 needed to exist so one of the
themes in game development is that young
developers are really all about control
we work with a lot of interesting
embedded systems consoles we have a lot
of performance needs in terms of getting
our frames rendered within you know a
hard deadline to make sure we're not
dropping frames or getting a jittery
jury kind of outputs we're dealing with
good storing to memory systems so we
really need it that when we want our
code to do a specific thing it's doing
that and nothing else we got to kind of
control the bounds of our application is
going so on these themes one of the
things that we deal with a lot is the
issue of memory usage and this this has
some interesting implications that are
maybe not similar to other types of
software one of the big things we have
to run into quite a bit on the embedded
space are devices that don't have swap
space don't have virtual memory
necessary that's necessarily we have a
fixed amount of memory sometimes a very
small amount of memory and then memories
shared not just with the data that our
application wants to kind of operate
over but also all of the artistic
content that the artist put together the
levels the level designers have put
together and all the geometry that goes
into that so a very very large chunk of
our memories eaten up by content and not
necessarily all the other algorithms or
whatnot we have to write and a lot of
these platforms are also dealing with
homogeneous memory systems so the CPU
and the GPU are sharing a single memory
bank so unlike a PC where you get to
copy your textures up to a video card
and kind of forget about the memory
usage in some cases we're sharing as I
say 512 megs across everything like the
video textures
pretty much every piece of data we have
on a similar note we weren't any do
problems with computation time there are
certain aspects of C++ that really bite
game developers pretty hard or any real
time developer a favorite of mine to
pick on are the the value add that
certain compilers and implementations
have in terms of debug iterators and
features like that it can be difficult
to make a simple toy 2-d game hit 60
frames a second when you've got debug
iterators turned on and of course
turning debug iterators off is a magic
incantation that is different for each
and every compiler so it's a bit of
black magic to make sure that your game
is going to work properly on the pc
linux OS 10 various consoles without
having issues because of these extra
features that have been added a related
feature to that we run into a bit our
built-in features in C++ like rtti used
for the dynamic cast feature there's a
lot of overhead that the compiler will
put into your code in terms of data
structures and whatnot that we don't
necessarily need or want to the point
where game developers who do actually
need things like dynamic cast in some
cases will re implement it entirely from
scratch just to make sure that we have
the amount of control we need in terms
of the runtime bounds of our TTI and the
amount of memory used by it so it
doesn't make a lot of sense to us that
we have to re-implement core features of
the language just in order to get them
better than they are in the language
itself we went into also similar cases
with some of the standard containers
where the idea of Big O notation and how
fast an algorithm or data structure is
going to work with certain operations
isn't necessarily fast enough Big O of
log n is not the same if you're talking
Big O of log n spread across memory
verses an operation that uses a tighter
bound of memory and has better cash
locality of reference a really the topic
to the locality of reference with
containers are the inconsistent
allocation patterns that some of the
standard containers have and these are
issues like the standard vector standard
vector is one of the simplest containers
in the standard library but there's a
lot of open questions about how exactly
this container is going to behave for
instance the container has to grow when
you push back into it but it's not
necessarily defined what
growth factor is so if you're working on
a system that has a fairly constrained
memory budget you have to control
exactly which remember is being used you
need to go to rely on how much memory a
particular operation is going to consume
and not have it eat up you know so this
much on one platform and this much on
another platform that that makes your
portability quite a bit harder and then
there are certain containers in the
standard certain implementations that
even use this feature but they will
allocate by default you create an empty
container that you might not even use
and yet the memory allocator has been
hit and you're paying all the costs both
in run time and space for that
allocation so there's there's issues
like standard function is a popular one
I see complained about online a bit
since it's not specified whether how
much size standard function can take in
terms of a lambda you might put into it
so there are a number of developers will
avoid standard function even in cases
and they should really use it simply
because they can't depend on whether or
not it's going to allocate on this
platform or not on another platform we
need that consistency there are similar
features such as standard async one we
don't necessarily use a lot but it's not
specified if this is using a thread pool
or how this is communicating the job to
a thread so we'll reimplement things
from scratch simply because we need this
consistent behavior on every single
platform we can't use the standard is
providing largely because it's not
specified tight enough that we can
depend on its behavior we see this isn't
just a problem for games either we can
see that there is a number of
applications and libraries outside of
the game space that run into similar
problems so we have complete stl or
nearly complete sdl partial stl
replacements est-elle obviously from
games electronic arts but we see things
like stl port that was really popular in
games for a number of years we see
things like Facebook's folly library and
they are their implementation of
standard vector yet most basic container
in the standard they reimplemented it
from scratch we also get L VMs library
has a reemployment ation of a lot of
basic containers that really they should
just wait to use what's in the standard
there's also a number of features in C++
that are traditionally considered very
costly there's a feeling that some of
these might be more myths or kind of
folklore from back in the early days of
C++ not necessarily
curate with today's modern compilers so
part of what we're doing at sg14 is
analyzing these issues making sure that
they are in fact real issues today with
modern compilers we some of these
include rtti to mention previously
virtual functions the inlining supports
of c++ and exceptions so virtual
functions is kind of a favorite example
of mine because some of you might
remember back in the early days of C++
there was a lot of these traditional C
programmers complaining that virtual
functions were too costly they'd have
too much of a performance overhead and
that that's not so much true today and
our modern CPUs you know the work that
Intel and AMD are doing the in direction
of a virtual function is practically
free unless you're in a super hot inner
loop or something like that however
there are still platforms that game
developers are targeting that targeting
that don't have these hardwood
improvements some of the last generation
of consoles suffered significant
performance degradation from in
direction through things like virtual
functions and you could get David a five
percent frame boost just by getting rid
of some virtual calls that worked even
in a hot path so it is it is still an
issue that affects us today we also run
a things like the inlining support I
can't remember a single game engine I
have ever looked at that wasn't using a
custom macro for the compiler specific
force in line attribute and this again
comes back to the control aspect of the
section of the slides if a game
developer knows that this needs to be in
line this is a hot function we don't
want to leave it up to the compiler and
their heuristics and guessing we want it
in lined in line it now please
exceptions in our TTI are kind of a hot
topic or sort of a contentious topic in
the c++ community you'll hear a lot of
game developers say we don't like
exceptions we turn them off and then you
get other people saying silly turn them
on their standing part of C++ we had a
lot of great talks keynotes during this
conference from the RNA and herb talking
about not wanting to fracture the
language ecosystem not i want to have
these subsets or specialized versions of
the language unfortunately games have
pretty much since the beginning of c++
in this feature being available turned
off exceptions so the language is
already fractured this isn't a
theoretical problem
we're approaching it's already the fact
of the landscape so one of the things
we're looking at it sg14 is how do we
address this issue how do we either make
it so game developers can use exceptions
or how do we make the language less
fractured when exceptions are turned off
so one that one of the problems it comes
about from this that I've been
experiencing quite a bit lately is I'll
see a meat library and github some open
source library that maybe solves a
problem i have and i want to use it i
would maybe like to contribute back to
it be able to supply patches or use
implementation experience whatnot but in
games i can't even use the library
sometimes because maybe it uses
exceptions so it's got a try statement
or a throw statement in it and when you
turn off exceptions a lot of compilers
it becomes a compliation error to use
those those language features so instead
of having a library that simply doesn't
necessarily work fully because
exceptions are turned off we have a
library that doesn't work at all hence I
can't use it hence I will never
contribute to it or I will not
participate in that aspect of the
community and there's there's a large
part of the C++ community that's not
related games that we don't get to
participate in and the vet part of the
immunity is not getting feedback from
our expertise or are our time
investments and that's kind of a shame
it be great if we could all kind of work
together we're using the same language
we shouldn't be segregated you know by
core language features this isn't
necessarily just a problem games either
there are the very first two hits i got
when i searched for c++ coding standards
with exceptions when i was on google
were the llvm and the google coding
style guidelines which actually tell
users not to use exceptions or rtti they
even say you know these are banned in
our code base in some cases so not just
games complaining about some of these
issues so the next topic I want to talk
about our metrics and performance
specifically how we do some of our
instrumentation and some of our kind of
more specialized needs with performance
in games as compared to more traditional
software so we're going to talk a bit
about memory budgets again one of the
interesting things that we alluded to
earlier was in games we do a lot with
content a lot of artists and level
designers were putting things into our
games so what this means is with our
limited memory budget a lot of that
budget
not by the content people they need
feedback and to as to what they need to
change with their content to make things
fit in a memory budget more traditional
profilers and instrumentation tools are
very program or focused their kind of
really based in helping us find out if
our data structures are correct or four
algorithms are running efficiently and
they don't do a whole lot to tell a
designer that hey you know you can only
have four trees in this area of this
level rather than you know ten trees or
whatever the case might be so there's a
lot of need we have for not just
instrumenting our code and our data
structures for programmer consumption
but also making sure that we're
supplying a lot of user-oriented data if
we've got an alligator with some memory
tracking for example we don't want to
just tell the programmer that you know
they're using this miss many bites on
their algorithm we need to tell the user
you've used this many bites with your
content and these are the different you
know breakdowns of content trees versus
you know boxes versus enemies things
like that and what their budgets are and
where they're kind of going over those
budgets so this is a kind of quick
example it's more of a brain dump this
these aren't directly taken from any
code base just kind of a pattern I see
quite a bit some simpler patterns so you
might see games that define a group of
alligators for example or a group of
buckets for alligators these are where
all of our graphics data goes and we
break that down right into textures and
meshes and then we might break things
down to game objects and then game
automotive entities versus you know
doors or things like that and then we
might possibly start tagging our actual
classes with an alligator so in this
case this macro use allocator is
actually overriding class operator new
and delete we had a question on our
expert panel wednesday someone had
mentioned that they've been working with
c++ for years and had never seen an
overload of class operator new and
delete and that's something we use all
the time and games you know it's not
necessary the most flexible thing to say
that you know this particular class is
always used for this one thing but
realistically speaking if you've got a
class called vertex mesh it's going to
hold vertex meshes it's going to be
really related to graphics and it's it's
doing that one thing and it's just a lot
easier for us to tag up this class
especially with some of the pains of the
C++ allocator interface that Andre
alluded to
talked yesterday there are engines that
will use a more data-driven approach
kind of like the final example here
we'll say you know data loaded from
these files you go into this memory
bucket or we might do things in a little
bit more data-driven way there's
certainly more advanced ways that memory
allocation can be tracked Scott had some
great examples from the ea's profiler we
talked about earlier this week so again
this is what fits on a slide yeah so in
terms of the allocator interfaces a lot
of this was actually going over by Andre
there are certain pains with the
allocator interface especially for games
the lack of alignment support is a huge
problem particularly cuz we do we'll
simdi or certain exotic platforms we're
dealing with graphics GPU issue items
that have kind of really strict
alignment requirements and there's also
cases where because we want to tag so
many of our alligators with debug
information they need to specify the
type ends up in these like really long
things or have a standard a vector into
then specialized an alligator of ends
with you know maybe this extra tag
information and of course if it's not
just an intended specifying types
multiple times it's huge pain will
rewrite our standard library in our game
using a custom alligator face in a large
part just for our own sanity and ease of
use let's kind of cellular to do that
you know why isn't the standard giving
us kind of a better more more ergonomic
interface for alligators oh so we also
have some interesting performance
consideration I mentioned earlier about
some of the hardware we target isn't
similar to the desktop class or even
server class hardware that many of you
might be more familiar with you know
Intel it has some amazing optimizations
and their CPUs that you don't
necessarily find in all the different
embedded devices or game consoles out
there so there there is hardware that
has either no branch prediction or
really terrible branch prediction so
that kind of general advice I've removed
branches from your code goes from a nice
to do optimization to an essential
optimization that can be the difference
between a game that can ship at 60
frames a second or not we run into cases
where cash locality because the the
hardware's prefetching unit isn't as
strong so we got to be much much more
careful about how we access memory you
know where it's laid out in whether or
not we use prefetching instructions
things like that we can't rely on the
compiler or the hardware to kind of
optimize things behind our back as much
we also run into an interesting case
where performance matters when debugging
I see all the time on forms people say
you know use this abstraction and the
optimizer or make it fast for you well
that's that's nice when the optimizer
does a lot of work for you but we care
about speed when debugging the phrase I
like to use is that having a a slow
debug build can be the difference
between having a debuggable interactive
game and having a debuggable slideshow
and when you're trying to test certain
things you really need the interactivity
part up there in yet so we run into a
lot of issues where you know the memory
usage and performance are kind of
tightly coupled even more so than it is
on the PC and we need in some cases
better algorithms and data structures to
help deal with some of these issues so
on that front there are some algorithms
they're not currently in the standard
library that I see reimplemented time
and time again and a lot of game engines
and it'd be nice if it was available a
very easy example is radix sort so the
standard library of course has standard
sort which is a generalized sort and can
work for pretty much any type that you
can do you know the less than comparison
for radix sort only works for integer
keys it's much more limited much more
specialized in in terms of what types
you can sort but we can actually in a
lot of cases form an energy key for data
that isn't itself an integer so let's
see this a lot in certain graphics
architectures where we can take all the
attributes of what it is we're rendering
generate from that in integer key
different bits representing which
measure which material things like that
and then sorts off that key very very
very efficiently with radix sort and use
that for our order dependent rendering
when necessary there's also a lot of
needs with spatial and geometric
algorithms or data a lot of games are
very specialized needs here's we
wouldn't necessarily want an entire you
know geometric library in the the
standard but we're in a weird cases
where for example every engine ends up
having a point class and a vector class
and then every middleware that we end up
using has a point class in a vector
class and then we're constantly
shuffling data back and forth with all
these incompatible types you know we
have game engines that might have three
four five different math libraries in
them
and so much time and effort and energy
is just spent shuffling back and forth
so perhaps the standard could offer a
more consistent set of standard tools
and kind of ease some of our pains there
we also run into issues with some of the
math functions a lot of the game engines
I've seen will have overridden versions
of even things like square root or
certain other related math functions
where we want faster but perhaps less
precise versions of these algorithms so
perhaps are some room there for the
standard to give developers a little bit
control to decide whether or not they
want the in precise fast math of the
super precise slower math you know kind
of ease a bit of development there maybe
let the experts with numerics kind of
really optimized a nice fast version of
something rather than something to
re-implement everything from scratch and
on a related front to run into
containers we don't have that it wery
implement in game engines quite a bit
intrusive linked lists are super common
we don't want to sleep a the overhead of
say standard list where there's a
separate know that has to be allocated
and extra memory space of that and the
actual just the time to call the
allocator d allocator for things that
maybe already exists we run into case
with the hash table that's currently in
the standard the unordered map on
ordered set due to a weird quirk in its
specification it actually has to
allocate a node every time you insert
into it so there yes the overhead in
terms of the allocator there and then
iterating through the hash table if you
have to do it can be a bit slower
because things are contiguous in memory
so a lot of games will reimplement a
different hash table for speed and
consistency in less less allocator
overhead there's also some use for other
contiguous containers there's the flat
container proposal I've been working on
kind of based on boost flat map flat set
the idea being as some as you just
needed you know key look up a pair of
ordered elements unlike an unordered map
but you don't want to have to have a
tree-based node allocated you know kind
of tree structure like we have in
standard or get a standard map or
standard set there's also almost every
library of scene has some kind of step
containers so say stock vector things
like that I've seen in llvm it's google
has one pretty much every game engine
has one it's difficult to implement
those nicely with the standard
alligator pattern so we usually just
create a new class but you know there's
some work maybe the committee can do
either in terms of making standard
vector usable stack allocation or
implementing a new type so one of the
other things we run into a lot that's
kind of I feel different from what I see
in the wider programming community is
the difference between average case in
worst-case time you know we see Big O
notation a lot and people talk about
this is a you know big o log n algorithm
or data structure but they don't really
necessarily pay a whole lot of attention
to the worst-case time and so if we're
working with a game and we're just
barely fitting within say our 16
millisecond budget to get 60 frames a
second in the average case and then
there's a worst-case that can come along
we'll miss our frame and the user see
some stutter in the game and there's a
problem there so we need to make sure
that if we've got you know this budget
of 16 milliseconds we never ever go over
16 milliseconds and that means that if
we have to plant we have to plan for the
worst case and in some of these
algorithms and make sure that you know
the budget is set up appropriately so so
things will be consistent kind of a
related topic that I see come up a lot
and one of the reasons we use C++ is the
issue of garbage collection so people
will talk about you know garbage
collection in languages like Java or C
sharp ease development but then they
also bring up performance there's a lot
of research indicated garbage collectors
are faster than manual memory management
and that this may be true there's the
garbage collectors might have the
ability to localize a lot more than
memory management because you're just
doing all of it one big go they don't
have to chase a little bunch of pointers
like reference counting might and
there's you know there's there's ee some
some truth to them being faster overall
less overall time spent managing memory
in a garbage collector than manual but
the issue we're into in games again as
we've got this this consistent 16
milliseconds for 60 frames a second we
have to hit and we need this predictable
worst-case performance so even even if
we've got all this overhead in terms of
managing references it is a
deterministic predictable overhead we
know that right here when I drop this
reference that's what I'm going to you
know dereference pointers that's what
I'm going to change reference counts
that's what I'm going to deallocate
memory or put things back into a pool
whereas a garbage collection a garbage
collector kind of happens whenever I
mean there might be some control in some
garbage can
tears but not as much as we need you
also learn the cases where the garbage
collector because you don't necessary
predicted when it's going to run you
might router memory sooner than you
think because again we have very very
constrained hardware budget so we need
to know that if we're done with
something we need to free that memory
now not when the garbage collector
decides it's it's important so this
graphic just kind of indicates the idea
of throughput versus latency you know
maybe less time is taken over all inside
the GC what if it's all happening right
you know we're trying to get ready to
submit a frame to the hardware you know
to render render screen then yeah we're
going to miss that so that's going to be
a problem it's not predictable enough
and I'll let Nick take this section
thank you so I'd like to talk about a
topic that is close to my heart I would
say I'm talk about fun and productivity
because if we're going to be going to
work every day working with the same
language it may as well be fun and we're
making games this should be fun and I
think create making games even as a
programmer it's a creative endeavor and
you have to be able to iterate on ideas
quickly in order to be productive and to
make something that's really fun if
you've been to game design talks at
other conferences you often hear talk
about game feel and game peel is like
when you're playing the game it's like
how does it feel does it feel good or is
it like fun and like a lot of you know
improving the game feel the game is to
be productive is to do like a lot of
iterations to do it a lot of iteration
if you productive so people saw us have
some issues in this area one easy
example easy target is a long
compilation times so it actually in a
big team it tends to take a lot of
engineering effort to be able to compile
a game in a reasonable amount of time
for any kind of iteration to make sense
either with a distributed build system
of some kind or going through the
trouble of setting up all these like a
PM pole things to lower the dependencies
but also there's some some conflicts
with the design of a language so for
example many C++ experts will advocate
the use of the unique pointer instead
array as safer alternatives to the raw
sea versions of these objects the
problem is that when use the unique
point
turns that array this means that first
of all you have to include the headers
that define them so that's some some
code below in terms of just worth more
file i/o you have to do to be able to
include those headers but also using
these safer versions of these objects
requires you to estancia more templates
and these template instantiations you
know first of all it's more for the
compiler but also bloat syriza cuticle
so it's kind of I think it's acceptable
to say that C with classes style code
where you use less C++ features tends to
compile faster and so that's often a
preferred approach by some you know
uppers and finally here i'm just saying
out a bunch of different reasons why
bunch of reasons why sequels what's this
kind of setting pal just lots of file
i/o because of the include system
complex grammar sequence is one of the
most complicated grammars you can
possibly find out there in a production
language template instantiation of
course easy target optimizations which
is a tricky one because actually we want
you know a good static optimizations but
that comes at a cost another aspect of
productivity that I think is important
and maybe more unique to game
development is the fact that loading
takes a long time so even if the
compilation time was instantaneous the
fact is that every time you restart the
game you have to sit there and wait for
all the assets to be brought into memory
again and all the parts you know you
have to parse some data sets sometimes
and it just tends to take a long time so
this is made even worse by the fact that
in debug builds which you might be
working in to find a bug it's going to
take even longer to load level like you
can sit there for like minutes waiting
for it load because when you're working
on the game the loading hasn't been
optimized yet and you're working in
debug mode so it's it's desirable to be
able to iterate faster than this and a
lot of the time game developers will
even just not use the bug mode for the
reasons of you know slow loading or just
the game being too slow itself and this
means that you know if I spent a lot of
time actually just debugging release
code which is much trickier to do so
again we're still looking for a lot of
solutions to try to be more productive
as C++ and so edit and continue features
in ideas or game engines
are very much appreciated there's also a
lot of use of scripting languages for
the purpose of live reloading scripts
while the game is running with having to
turn it on turn off and on again and of
course also shading languages which give
you a similar ability but for the
graphic side of things all right so next
topic is talk about the current efforts
so we had a meeting on Wednesday where
we discussed a bunch of issues and what
I'm going to do now is I'm going to try
to summarize what we've been what we've
done and what's going to be done with
those things that looked at so one of
the main proposals we were looking at is
fixed point numbers so this is an effort
led by lounge crawl and John McFarlane
who I think our drama phones over there
is Lawrence here I know okay so this is
kind of an overlap with numerics with a
numeric study group so we have these two
different puzzles here we have one by
John which is our proposal I guess and
we have the proposal by a crowd with it
I think is from the numerix group so
there's some pretty compelling uses of
fixed point numbers in game development
mainly on platforms we're floating
points its support is either
non-existent or very slow on those
platforms it tends to be that for
example if you if you do a bit of
floating-point operations back weight
actually gets compiled into hundreds of
lines of assembly to stimulate it and
that's just not acceptable so there's a
lot of games out there where basically
instead of using floating point numbers
for all their math they just type def
like a real class or something or real
typedef that just uses a fixed point
class and then just use that everywhere
and hope that the precision is not going
to be a problem I think also there's a
lot of good uses for fixed point in
terms of just places where it actually
logically makes sense to have a uniform
precision on a data set so here's one
example from my domain which is graphics
where if you want to be able to refer to
specific sub pixel locations like
locations within a pixel you generally
want to use fixed point coordinates just
because then you don't like then you
don't like favor the particularly the
first pixel at the top left of the
screen to have all the precision which
doesn't make sense so this proposal is
proposing sted fixed point class and
makes make fixed to be able to create a
fixed point number with a specific
number of bits for the integer and
fractional part and these people are
going to be proposed that are going to
be discussed at the Kona meeting later
this year so next proposal is the ring
buffer which I think maybe has a
different name now this effort is led by
gay Davidson if you're sitting over
there it's a continuous fifo buffer so
basically the idea is that you know able
to push things on one end and pop them
off the other end pretty common but
there's no good like built in class for
this purpose yet and the standard
basically leading to people using stuff
like deck or linked lists which tend to
have the problem of being discontinuous
in memory so the idea of this proposal
is to create a container that is
contiguous memory to get that better
locality and usually easier to work with
other kinds of interfaces so some
examples are feeding audio samples to a
DAC or queuing up network packets in
general this is useful for communication
between threads of some kind and there's
two basic classes that we proposed hear
the static and dynamic ring where the
static ring is is similar to a standard
array where the size is fixed at compile
time and the dynamic range which is
backed by a dynamic container such as a
vector to allow you to resize the ring
at runtime oh and this is going to be
looked at kona later this year there's
been some proposals to just patch up the
interfaces for working with raw memory
and effort led by Brent Friedman who is
in the crowd today over there so these
are kind of maybe obscure but actually
pretty useful if you're writing custom
allocators and such for example ross
storage a trader allows you to it
creates an output iterator that actually
is able to work on uninitialised memory
and the problem is that it's missing the
movement in place kind of functionality
there so it only does copies right now
so we're going to improve that then
there's a bunch of algorithms here stud
destroy an uninitialized move initialize
value construct etc which are just
useful for when you want to do a
construction on a range of unanalyzed
memory for example or call the destruct
iran a range of memory and then we have
unstable remove which is kind of
interesting where the current like stood
remove function
if use it on a vector for example the
elements your move will not disturb the
order of the rest of the elements in the
vector and that's done by removing that
element and then like shuffling
everything down a linear operation what
we're suggesting is to make a remove
where it doesn't have that linear
overhead and what we have doing that is
to just and I don't think it's the best
proposed but one simple way is to swap
the current element or the ailment you
want to remove and the last element and
doing pop back so it's just a simple way
to do it so you lose the stability of
the order of the elements but it's a one
so awesome and this is also going to be
discussed at kona later this year
another effort is the flat associated
containers Shawn here is is leading that
effort and he talked about earlier in
this talk basically idea here is just
that containers like stud map instead
set tend to have very poor memory
locality and also very unpredictable
memory access just due to the fact that
individual nodes are created and so what
we're trying to do is create containers
that store the equivalent of a stud
mappers that said but contiguous in
memory as shown in the picture here
there's some trade-off here for example
the fact that if you have an iterator
and you insert or delete that area will
make sense anymore so that's one of the
main motivations of stead map is that
said having individual nodes but we're
ready to accept that trade off for our
uses there's also an interesting effort
in trying to make a DST my thread safe
this is still very early effort and
we're going to look more into it but
bread seals is on this so is written in
the crowd no okay so another interesting
idea is to think about the thread stack
size so this is patrice who's been
working on this Patrice is over there he
suggested that maybe the stead the
standard thread class should be able to
specify the size of the stack that
you're going to be using for that thread
at creation time so this is kind of a
tricky issue because some people might
suggest that you can just get the native
handle and do whatever the problem is
that by the time you have the native
handle that thread was already created
it already has a stack size so you can't
control it using that and so what we
need is actually an extension of the
the thread creation interface that lets
you specify if possible exactly the
amount of memory you want for your
thread because this is actually a
requirement of game developers do we
have to be able to create a thread with
an exact memory requirements and not any
more or less so I think Patrice is going
to present that chrono himself since I
think you might be over okay so they'll
be discussions in cournot about this
another interesting afraid is as also
led by Patrice here is the exception
cost analysis so like Sean was saying
like exception cause it's been
historically expensive but there's a lot
of folk folk or about it like is it
really true that it's still slow or
maybe the new exception models are
faster and we want to make sure that our
concerns are actually true before we go
further with this so Patrice did a very
interesting post on a mailing list where
he did a bunch of tests kind of mec you
know artificial its micro benchmarks but
still very interesting where he tried a
budget for combinations of using
exceptions in different ways and seeing
the effect of performance on different
compilers so far the outlook is mostly
bad and like exceptions seem to in
general make it slower but still this
some cases where it's actually faster
because of not know we're theorizing
because it doesn't have to do as many
checks and doesn't have to return things
as much if you use exceptions just let's
return code so it's still you know a
slow for debate and to be interesting to
have if possible some cases that are
more realistic in terms of how games
work so assuming this is a real problem
like this is where the Assumption we
went with that exceptions are real
problem and like what I'm saying it's
like it's not even an option we're like
even if you manage to argue that that
exceptions are somehow faster or better
or equivalent the truth is I game
developers right now don't use them and
the platforms they work on discourage
using them to the point of either not
supporting them or just like turning off
by default or etc so basically at this
point we've got no choice but to try to
figure out how we can work these two
dialects of the seals let's language
together where one has exceptions and
one doesn't and we thought of watch the
different ways to address this problem
still very early but we're looking for
help in this area so if you have some
expertise
be very much appreciated all right we
have some other some other work being
done that's not really part of sg14 but
is relevant to us to proteins interest
for example is co routines and effort
led by Goran davydd this is actually
like I've had AI programmers comes me
personally and say that they'd love to
have co routines because the tired of
writing behavior trees so it seems to me
like this is actually a very relevant to
our interests and we should make sure
that even if this is an effort led by a
different group that whatever is going
on there is going to be not in one way
or other in a shape that is not
acceptable for games another idea is to
take functions in a standard library
that currently throw on failure and make
them instead return an error code like
offering two different versions of the
same function for example just to make
it so that we can still use the standard
library without having to worry about
exceptions being thrown in a bunch of
cases of course simdi is very much
ingrained in the culture of game
development it's been there for a long
time ever since people I've been doing
transform and lightning transfer man
lighting on the CPU a super teen
Schlemmer the involve yet but this some
papers on this topic like I see a bunch
of them you can go look them up so I'm
suggesting like a ray obstruct design
where you have a vector of T of size n
or something and other ones where it's
more like instruction level parallelism
but you know it more like parallelism
way where you have like a for Cindy
thank you more about the control flow so
interesting topics that we need to look
more into explain what what's Cindy so
simdi for anybody is not familiar simdi
is a kind of a general term for a single
instruction multiple data which are
instructions on your cpu that let you
operate on more than one operand at a
time so for example normally when you
add two floats together it's just one
float plus one float equals one more
float but with simdi for example one of
the common uses is the streaming simply
instructions are streaming Cindy
accessions instruction set which lets
you take four floats for other floats
and add them in parallel so you get like
this parallel to 4 4 4 combinations or
flows being added in one instruction so
that's it
the answer your question okay so I'm
gonna do it up the Shawn to talk about
the future all right so now this is part
of the talk where we enter the future
all right so there there's some other
current work that folks are looking at
as part of sg14 or interested in looking
at as part of SD 14 we've had or some of
these or none of these yet have papers
or have been discussed by the group as a
large as been maybe post on mailing
lists kind of expressing interest but no
no serious discussion as of yet so one
of the cases that Matthew Bentley
brought up are some containers that he
calls plf colony PL enough stack these
are these are variants to certain
containers that are you know already
represented in the standard library that
but these have different different
memory allocation patterns kind of
different growth patterns as things go
in them and have you know pretty
significantly different performance
characteristics okay you know kind of
important to us there's further work on
the intrusive-containers that's being
investigated I mentioned the intrusive
linked list before but there's possibly
some interest in trees of trees
intrusive map or even you notice the
getting the intrusive linked lists
itself in so this is something that's
being looked into as to how we can do
this and kind of based a bit on boost
for initial investigation there's also
the GPU accelerators support so today if
you are working with the GPU you have to
use some external library you've got to
drop out of C++ and go to open CL or
khuda aur OpenMP open ACC there's
there's so many different variants of
this open or C++ amp so what we'd like
is perhaps a way that we don't have to
rely on third-party libraries or
completely different languages to do
what is becoming an increasingly common
operation of modern computers so much of
our computing is done these days on
these big giant math coprocessors we
call GPUs so be nice of C++ kind of had
a more direct and usable way of
interfacing with these these external
systems there's also you know directions
that we would be interested in going but
we don't everyone signed up for the work
yet no one's expressed interest in some
of these specific topics there's new the
new containers and auger
I mentioned previously erotic sort we've
had Nolan kind of step up to write a
proposal or really see that through so
lets you know something we could use
some help with there's also a need for
possibly some refinement the existing
containers other stricter requirements
like the growth patterns I mentioned
earlier or small tweaks that could make
containers that we can't really use
today maybe make them usable in the
futures and have to keep re-implementing
things over and over again and
fragmenting the community so again no
one's really signed up to really
investigate any of those particular
problems and there's some there's some
smaller miscellaneous issues we've got
the algorithm header and c++ which is a
bit of a monstrosity it's pretty much
every algorithm in the language so you
might want you know stood min stood max
this tiny little one liner and then
you've got to pull in you know thousands
of lines of algorithm and tens of
thousands hundreds of thousands of lines
of dependency on some implementations
and then you get all the problems that
Nick mentioned with a compile-time
overhead and again just for a one-liner
likes to admit it's kind of extreme and
there's there's some other overhead
issues with exceptions of so we started
looking to that but we haven't started
looking into rtti yet and what the
overhead there what the overhead is
there and whether or not that's
something that's still an issue today
with modern compilers or you know kind
of rule out if its folklore or still
issues that need to be resolved and then
what those resolutions are so as far as
where we're going next that's a large
part where you guys come in both you in
the audience today people watching on
YouTube stuff in C++ happens because
people are passionate about C++ and do
the work to investigate the issues write
proposals discuss the issues and bring
it to the committee to talk about the
the committee isn't just kind of sitting
there designing things behind you know
behind curtains closed curtains it's all
pushed by people who are writing
proposals and writing papers and
discussing things so there is definitely
room to have more people contribute we
always use more people contributing and
sg14 is a great place I mean we're
really open we've got the public mailing
list we're going to have the meeting of
GDC so if you're a game developer and
you're interested in improving C++ you
know this this is the place to do it
this is the group to get in contact with
and start talking start writing
proposals
and start making awesome games with C++
so thank you that's better and everyone
has questions and now it's time to meet
to keep the bill troubles in terms of
time you guys use unity bills as a top
so the question was to improve build
times to be used things like unity
builds and I mean the actual specific
way that the promise solve depends a lot
on the specifics to do but definitely a
lot of people use unique builds saw that
problem ? all right so the question is
about the topic I mentioned with the
standard vector and the allocation
patterns and whether or not we think we
need a new type or change the existing
type and so I don't know this is kind of
an open question that we need further
discussion and you know people who got
to know this topic pretty well to get
involved it could be a new container it
could be you know a tighter
specification of the current container
that says it's always 1.5 and it never
allocates when it when it's empty maybe
or it could be you know a new policy or
template parameter there's a lot of
there's a lot of ways of solving some of
these problems there is discussion needs
to happen about what is what is going to
be the best way that has you know the
best the most forward-looking solution
the most you know least least impact on
existing users so yeah open question
another question over here
yeah so that's a that's one of the
solutions we brainstormed is is there
perhaps a way that we can make it so
instead of being a compile error oh
sorry yeah the question is uh if we
looked at terminating terminating a
process when an exception is thrown
rather than going through the whole
handling you know chain so yeah we
brainstormed a lot of solutions so one
of the current issues again is that
right now it's just a compile error to
throw so a potential solution is instead
of making it a compile error we kind of
do what game developers do anyway which
is just crush the Borg and there's
questions obviously there's a lot of
discussion there there's libraries that
perhaps rely I'm throwing exceptions for
control flow which I think we all know
is a terrible idea but people do it so
you know this is this a fragmentation
issue of the community and there's
there's just there's so many different
solutions and a lot of thing and open
questions there so we've got a paper
we're going to be working on to float
some of these suggestions passed the
committee and kind of get some more
feedback from from them but there's
definitely further discussion there so
yes that is one of the solutions we've
looked at and that's pretty close to
what game developers do today another
choice is a just like an ad quick exit
function that lets you specify a
callback for when the program gets
terminated so those would be a good
opportunity for placing some code to
clean up things if necessary at the end
because of the big problems of
terminating right away is that no
disrupters get called so that can cause
some problems if it's actually important
for things for this directress we called
it for the program closes right
Anna stuff for the video the comment was
that one of the other solutions we're
looking at our marking up kind of
regions of code is being no except so we
can go to control where the cost of
exceptions are happening so the question
is about the flat containers the boost
flat containers are implemented a server
to raise and there are some other
algorithms that can be used for a
similar purpose with a flat container
and the answer is yes so the current
paper i have is more of an exploratory
paper about the open design design
points and one of them is that backing
algorithm and of course there's
trade-offs there so using say the level
ordered way gives us much faster look up
insert and delete because it the items
are hotter in cash then they would be
with a bio research but now 80 reading
through the container is jumping back
back and forth and so that's not as good
when doing you know algorithms like set
union or set difference which are one of
the primary reasons you might want a
flat map instead of unordered map
because you need it for those algorithms
so there's there's some performance
there's some further benchmarks when you
do in kind of analysis of actual use
cases you know what people actually need
a flat map for and you know what would
trade off is most appropriate there and
then if if the trade-off is kind of more
even than do we have a like policy or
going to make two different containers
or two different adapters and kind of
good users both choices so yeah the
current paper I put together is again
asking the Committee on feedback because
there's a lot of they have a lot of
opinions on these things so we'll find
out what they say
all right thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>