<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2014: Jens Weller &quot;0xBADC0DE&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2014: Jens Weller &quot;0xBADC0DE&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2014: Jens Weller &quot;0xBADC0DE&quot;</b></h2><h5 class="post__date">2014-10-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JE2WO0G3nCQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is a bad code talk I've gave it
previously as C++ now I had to cut a few
slides I didn't cut so many as I thought
I would so I think I have to speed up on
a few topics but in general as we
already later just start that's me
that's what I do I organize speaking C++
and around the platform behind it but
sectional topic now is that code so my
first question to you is set valid C++
if you think it's valid C++ raise your
hand okay so two people are right those
are digraphs and this pattern is known
as the Barrett lambda and it's just an
empty C++ 11 lambda basically so not
everything that looks like that code
must be bad code that's the point which
I'm trying to make here but also you
know we had the experience in the spring
that innocent-looking lines can be quite
fatal and so we had to go to fail buck
and this pattern directly or quote twice
first we laughed about Apple and and
looks at the same problem that should
not have been happening but it did it's
a back and about can result from byte
code but it doesn't mean necessarily
that right and go to failures red code
in the first place we're using code
rolls you can have no opinion on that
this is actually bad code but if you
don't see that's probably nasarah
happening again the classic way to use
go to and in some places where C is used
and just as we thought it wouldn't come
worse we had the worst back probably in
history at least in my opinion heartbeat
was just as this spring also so again
one single line in the wrong place
really you know being responsible for a
lot of headache for a lot of people so
this bad code may be bad code is your
own code because you know we all learn
and the code we have written for 10
years ago or some of us have written 10
years ago probably would today not be as
clean and you would have to refactor it
and there are also other options like
you know maybe the bad code is written
by the person next to you you don't know
that there's a few other combinations
most the worst I think it's if it's your
boss then you have you know some order
code piece which is perfect and you have
to use it because it's a cold piece of
your boss and it probably is the things
that's perfect I mean you cannot
refactor it because either some
companies don't do refactoring so I did
that presentation and spring in my user
group and I know now one company who is
doing the refactoring OSN and there's a
back report because they're internally
forbidden to do refactoring so they
always hope for having a box somewhere
those I can refactor a part of their
legacy code nice so yeah you see
weeks of coding cancer few hours of
planning mmm which brings me to what
actually made me start to think about
the whole topic I also work as a trainer
for C++ I've been various years in the
industry as a freelancer and as a
freelancer you see all kind of code
bases and you usually call it in because
something needs to be done quickly or
something needs to be done where they
don't have the knowledge for so you know
how is needed to end that makes you see
a lot of code bases which are quite
different and not of all of them were
beautiful so for me this poor man is a
person who's the main concern is not C++
for those kind of category C++ is just
filling the role of a tool and if it
gets the job done that's basically what
they are willing to invest and if their
code is already getting the job done
even if it's maybe getting better or
more performant that doesn't matter so
much for them it costs maybe they can
drink a coffee more of the corner store
so as I mentioned it's just one category
particular category scientists can be in
that area also programmers from other
programming languages also i've made the
experience man let this poor man's c++
that the person that serves that surface
it's not poor they're just not in super
sports expert but they're often experts
in a different field for example
scientists physicists chemists for them
c++ is just a tool to calculate
something and
but they want basically the results and
seekers process the fastest and best
tool in some cases so they've said and
so as I mentioned that those people
might be producing or writing that code
as not off no no not even their own oh
it's just the way it is for them and it
works too so a critical thing I've often
seen especially also as the freelancers
but you have a certain solution being
copied and pasted in a different
solution than mutated and so in this
pattern old code can live very long and
you have kind of an evolution with that
code being you know hopefully deleted
often interests commented out future use
and so this can end up in a very bad
state at the end so typical typical
problems I found in this domain are poor
design knowledge mixing or techniques
and ciento C++ serious classes one big
problem I think or would C++ books that
still people which come to the
department and learn and read those
books so and also my opinion memory
leaks are a big problem and you have of
course the current clash which we can
see is this loops versus algorithm style
that there are some people who think
that we should do everything and then
there's some other people which are just
used to their loops and they always
stick to their loops usually because
they're just doing that for years and
can be very hard to
get some people to to switch from loops
to algorithms for example and yeah but
there's hope as they're experts they
usually are willing to learn and hence
they can be educated but a critical
problem and that is that the workload
and the industry is such a high workload
that of very you know reaching them can
be really hard and again sometimes we
fancy attitude that works and why fix it
if it ain't broke she brings me to the
next part I have a few examples of
different cases of bad code mm and in
the details first I'd like to talk about
memory leaks which my open you know
still a big problem then I will talk
about something called layers of
engineering it's a I gave it then a bit
about classes on what's the classes I
think most of those problems
most of us I think I've already seen it
at some time in our patterns and last
but not least I'd like to talk about
money so there's a certain overuse of
new especially but people coming from
other languages especially Java
programmers sometimes most especially
char programmers the problem is also
that if you have a memory leak through
that that's not always a showstopper if
you have a memory leak your programs
they were wrong there this of course
the possibility to to address the smart
pointers or object hierarchy is like
shooters doing that but also I think
that writing news seems to give some
people a satisfaction we don't
understand her C++ programmers so I have
us prepared a small code example to show
how difficult it can be to to deal with
this problem for some people this is an
example taken from cute so we have
action richest quadrants and button is
pressed and the first approach is just
to call you and the first is zero
actually should be a null pointer in
this example so that's basically the
parent so this is a free pointer which
will be a memory leak after many is a
function and so then we can fix the
memory leak and put this pointers
there's all that so main will do now
owns that dialogue and some people we're
not here we're not realize that they no
have major resource week because each
time this function is called this
dialogue will be created and hence
there's that button is pressed how many
times on a day we have a hundred
dialogues opening and that's a little
problem probably then especially if
you're running an embedded system or
something so this is a classic way to
fix this to just put the dialogue itself
on the stack which has the advantage
that was the stack and exception search
that are everything it's going to be
there it's cleaned up and the parent
will outlive the dialogue usually those
it also the destructor then again
it's the deletion of the dialogue from
the parent the problem with this is when
the parent does not outlive the dialogue
if you would instantiate here not
dialogue that is modal then we would
have to use new and also then we would
have to take a little different approach
but also when when the parent dies in
the dialogue is still running we would
possibly execute a delete on a pointer
which is on the stack which probably is
not a good idea so problems the parent
elite and practice that won't play a big
role but then you could address that
using glitch later and using new then
the dialogue would be the return later
the exception problem is not solved you
could address that tooth itself does not
use exceptions so you're just using cute
that's almost fine you could address
that with a boost library called scope X
that you could just wrap that in a code
exit block and then delete later which
we call it once
this action is finished
so memory leaks are quite easy to fix if
you use smart pointers but I'm not
really a fan of using smart pointers I
think that REI this very good concept
which is sadly still not very known in
some areas I found out what surprised
that a lot of C++ programmers to not
really understand what it is and if you
explain it they often have a similar
concept already just to be undefined in
Germany made if they have a German word
for it but the bigger problem for me is
actually that if we carry over this
pointer style we we have over using
pointers as a first problem and then we
have overusing smart pointers and as a
lot of people have started using smart
pointers before C++ 11 we have the
Chef's contradiction that for everything
a shared pointer is basically in the
program running which is also for the
performance not the best so in general
you should from my point view prefer the
stick if you have to have an occasion
with new use a smart pointer and roaming
pointers you shouldn't use anymore so
short word under a factoring here
introducing smart pointers into a legacy
code base can be quite hard through
interdependencies so that you don't know
you always have to have to very very
carefully test if you introduce smart
pointers which are not shared if you
don't destroy some dependencies which
were they have a false or deletion or
something and again you have this
problem that you get from a pointer over
used in a smart pointer over use the
trace for fixed memory deletion problems
but also
not really improve your codebase in my
opinion except that you have less memory
leaks which was a good thing I once had
a cataract case was delete that I
couldn't get the written as commit from
an import program because the deletes
were causing the program slowdown and as
what was justice in portfolio management
argued well if you're slow over said
deletes we just did he thought it was
running for years without it and it was
more important for the client to be fast
brings me to layers of engineering I've
seen especially in bigger products and
in the industry which run for several
years that you have several layers of
code which usually wrapped into each
other and it's not totally clear where
the boundaries are um
typical typically for such code bases
are that you'll find Collins that you're
certain certain code base shouldn't
place should not be touched this you
know they don't understand anymore how
it works and maybe it's just you know
code to to interact with certain part of
the hardware etc of such a thing so
that's in mock there are critical code
areas was commented you shouldn't be
refactoring that because that's a
critical point and if it works fine and
change it so typical forces is rather
adding a new layer and doing a proper
refactoring and also of source code
bases are fully documented I assume your
as documentation in us problems with
that in my opinion are usually the new
fect new features in social environments
are often more important than bug fixes
and bug fixes are more important and
refactoring and refactoring is more
important than documentation for what
I've seen over the years this how some
problems in the industry a hundred
again my experience that's mostly in
Germany I don't know if the second
variant it says differently but in such
environments you you often have sisters
versus chakra that you know people are
very busy with implementing new features
and fixing the box which though it
features now have so it's another
example in a short a few words on truss
design stick we all seen monster classes
that you know classes over time cruel
setting you know every time a new
feature no refactoring so the truss
escrow functions grow you end up much
also as dependency her in some places
you have a certain over usage of object
orientation and one thing I've saw this
you know code bases in or in example for
interface versus implementation so first
somebody started designing interface and
we end up with two very date functions
the one takes an int ago as an ID and
the other one just string which is the
Fiat name in the database and most times
function will basically validate a
parameter which is in this application
kind of important and the implementation
then there's something very implement
interesting the copy/paste
Methodist's approached and then the
validation is only taken for the ID
because that's um basically what they
then use better later in their code base
but every function that is every
parameter class it is actually existing
returns true on the validate if you give
it a few name so
if us a new developer maybe some more
development mechanism the error to call
the field name was a string the object
would always be valid that's an any
problem so fix is quite easy you need a
function which will give you the name
from the field ID from the name and of
course you also don't need to fix the
code base and then that buggers fixed
also but I've also seen there is a
pattern and object orientation quote
normal virtual interfaces I think it's
for object orientation not the worst
pattern but I've seen it really an
application quotient or so I don't know
a lot of thing of such a can use it for
example she was not using a Tobias which
is not using it ready and contrast
design of course to mention shorting
patterns
I think pattern is a good knowledge um
I've seen it rarely use an application
code but important is that parents of
course need to be used correctly and
also implemented correctly few words on
on Monster classes and methods the
previous mentioned layering can be a
cause that just new features get applied
refactoring is not properly done and so
classes just grow over time and become
monsters same thing goes for monster
messes and functions and sometimes it's
also the problem that switches occur and
hence the functions are very long
because there are many cases to test for
and in general I'd love to get a tool to
see from an unknown codebase how to to
get in over you how the median of
method links and line of code s and as a
presented at C++ now I had such a tool
mentioned but I haven't seen the
recording yet and of course in that case
refactoring helps again so one
particular thing which are also often
seen is that this unit pattern is
applied which I think is especially bad
if you misuse that there's few good use
cases where you can do it used but often
I've seen it it's used to call virtual
functions for the initialization next
problem of Necedah valid object must
call unit after construction but you can
construct an invalid object without
calling init example is a bada SDK from
Samsung from a few years ago there is a
mandatory function to call which is
construct in that case called and they
of was for the synonyms industry used in
my opinion the pattern can be quite
easily fixed what what your function
calls especially for initialization of
objects and use constructors properly if
you can't force to make functions or
factories make your constructors private
and don't forget according you know the
operators which also can construct
objects and spend a thought on the rule
of zero or five defaults especially in
C++ 11
in the last example what I found us
especially one thing which some people
don't really understand us that people
use float for their money and
applications and they don't realize that
they lose money through that or
often hurts argument that it's that's a
plus on the negative arrows were zero
it's out and then it's okay again I
don't know about that
and my opinion money should be a type
it's a classic value type for me and
yeah it's an example you should put
store sense and thousand units and use
some second long room or something
depends on how much money you have to
store in such a type and yeah
my opinion you know that doesn't make
sense makes no sense and short again
back to patterns there is a very good
book on the one patterns which I hope
everybody knows about it
and anti-pattern says also book on anti
patterns the opinions on that book quite
different I have mr. just a few known
anti patterns and a thinkin super sauce
1114 we can say that you delete is
becoming more and more an anti-pattern
and there's always also an anti-pattern
catalog and mock receiver or we seen
that in the keynote that C++ thought
wasn't tough
and more examples probably at the code
base near you and maybe in your next job
of you currently have a good code base
and next job could be different which
brings me to lecture part of the
presentation how to deal with bad code
and how you actually know can handles
and proofing that in your job this first
of course I think you should always try
to fix bad code if you can but not
always that's option and also for me as
I thought about the promise that bad
code might be only a symptom maybe it's
I mean of course it's also a problem but
it's also a symptom and fixing it always
is a good thing to do but we have to ask
ourselves why does that code exist and
why do we have so often the exporter to
it as especially like for me as a
freelancer because usually every place I
have seen good developers so actually
you should be able to have far less bad
code in this world which we actually
should have then we actually have so how
how is that coming and you know code
hectoring are always easy and it's
always not always possible and I've seen
a very good slight and spring a little
conference this was a keynote on
refactoring that you should argue for
refactoring always west economics and
your team not necessarily with technical
terms which your management might not
understand
so but before before we actually can fix
bad code we have to understand if we
have the deal this was the actual
problem and as always said refactoring
or rewriting is not always an option as
the code my code base might be too big
for that and also new or unknown parts
of the code base you know can be
classified as you know potentially bad
code so how to deal with those things
first and for all very important there
we have today a lot of tools for static
code analysis so if you have a new job
on your project and you don't know the
actual code base then you should use
those tools simply check as a free tool
which does fairly job to give you a
first overview the blank static analyzer
is supposed to be a lot better but might
also depends on your platform there are
commercial tools which will do a very
good job for you to which my opinion you
should use it's not always possible to
get them in all instances they're not
that cheap of me and often this will
give you the first list of things to fix
and actually to refactor in your code
base also on that part to mention is
claiming more analysis program an
instance of clang which can go through
your codebase and change it into a more
modern style automatically so
if you're having a new co-pays or you
trying to modernize your own code base
can be very good to to take a look at
clang whirring noise it's a very
professional tool and of course for
documentation there is oxygen and
kravitz which can also do wonder for
documenting a new and unknown codebase
that as I said is the biggest problem
which which exists as if it cannot fix
it because just off time is years so you
know maybe the code which we think is
bad code is written by somebody else on
the team and so what to do then first I
think we should of course you know try
to not infect ourselves with it or our
code base with it so if you can contain
it safely and try to fix it later
it would be first a very good approach
but of course I think very much much
much much much much more important as
prevention that the code which this bad
code or becomes bad code does is not
getting written so in my opinion
education of your team and co-workers is
very important but much more important
in my opinion is also to educate your
management because what what I've seen a
lot of hierarchy is the problems which
lead to bad code which lead to code
written and under time pressure and you
know being not as good as it sure this
of through management pressure so in my
opinion we really want to fix that
problem we have to educate not only the
team teams who actually write code but
also those people responsible in giving
the workload to those teams and I've
already mentioned or C++ books so you
might want to update them now the C++ 11
available on almost all compilers and
don't reinvent overuse libraries that's
I think also important point there's a
lot of places where the not invented
here syndrome is very very common so
libraries can save you a lot of time and
improve your code quality and while I'm
at libraries I think it's a good
practice to develop modules slash
libraries or modules are not quite here
C++ 17 hopefully brings us at least some
in version and I think that even
application code should be written in
library code and this was for me at
least a thought
I mean how to define an interface and
not just to write the code in the
library and not to drive it in the
application so we basically would move
then from this model to this model and
OH suddenly we also have unit tests
there's another experience which I met
how many of you read unit tests for
their own code okay as a freelancer in
the industry I have seen it about 40
percent of surprises so this approach
makes your own young Corp is much more
testable and will automatically lead in
my opinion to force people to think
about their interfaces and improves the
code quality a little bit and with
education and proper training probably a
lot also back to hierarchies I think
what I've seen in some places that
typical thing is that we have a product
manager on
project manager and they talk to each
other and then the project manager of
gives timeframes for a certain problem
to fix
and our certain problem to implement and
this can be quite fetid so I think that
communication is one of or Nick officer
of communication as one of the origins
of that code for me and hierarchies
definitely and yes so there is a certain
bad code culture which I've seen in some
places so you know it's not always the
fault of the programmer if you if you're
under time pressure we all know this you
will not write the good the good code or
as good if you had time to think about
it and testing is not an industry
standard I have not seen in most places
I've been there's a lot of places which
think that they test but their code test
coverage is not really good and also
what I want to criticize I said not all
IDE some tools which we have for C++
today produce good code or also often
don't really have a good integration
with tests or default projects for
examples are usually without tests so
again back to the Slayer of
engineering's the cycle wants a client
which from my offer had test testing
separately to the software development
and they basically blocked that out and
said well that's that's an effort we
will not pay you it's testing this is
something which we think it's not needed
and then I didn't
um yeah as I mentioned I think that
there should be more tests written in
C++ it's good if you do and yeah there's
test lab result there are lots there's
even yeah supposedly Evan has brought in
few new test libraries one of them a
sketch and basically yeah you're free of
choice what kind of test library you
want to use for C++ is definitely there
and out there as I mentioned mentioned I
think there's a certain dragon audience
the testing is not supported properly
default projects of or don't include any
tests and some places those default
projects are basically the route which
is used for their projects and also in
books and tutorials test coverages of
Mirada poor and so again I think tests
should be more common in the industry at
least in Germany I don't know how you
ask maybe in the u.s. you are already a
bit more into a better direction there
and also you know the if you're working
in a better environment think about
changing your environment if you can't
change things you maybe want to change
before the things change you doesn't
know the IT industry if you're honest
it's not very healthy and at least I
know through through running a meeting
superfast platform there there's a big
need for engineers so if you're in a
better environment get out and get a new
super space job somewhere else because
you know a hamster we can look like a
carrier from the inside
and also when we look at the bigger
picture
we're moving towards newer standards not
all code will be rewritten as a code
base for C++ is huge and was newer
standards refactoring so to come off and
so the problem this bad code is not
going to go away we we have more code
which you might want to read
rewrite in the future or write in a
different style we see it was the
purpose 14 we have a lot of new things
receivers were 17 we have concepts
probably hopefully and then mobile
modules coming after this or with that
even so the whole problem of that code
will not be solved by C++ 11 because we
don't stop the standardization we go on
and have better newer things so it's a
problem through the Commons a few trade
more more more more urgent I think and
also the purpose education I think is an
important thing
there's you should of course for
yourself no never
stop exchanging learning C++ fixing bad
code does not prevent it in my opinion
education and reaching more people who
write C++ code achieves us and if you're
looking for letter in your own team
training is nice training such trainings
are but also expensive my opinion not
that effective one very effective way to
improve your own call it code quality
and to train your co-workers code doors
there is a website called cyber dojo
comm you can run your own tools for free
and can so also it's probably a bit
easier to argue as a management if it
does not cost anything you just need
maybe you know half a day for this and
the week to do an internal training
Lescott doors
and I run several user groups and we
also have done that in the user groups
also quite fun so you probably get
people to engage more easily than they
would do this training and yeah of
course there are books I mentioned box
before Thor one book which i think is
very good this app is designed for C++
from Martin ready just it has a very
good overview its style of C++ it does
not go too deep it's probably for
Advanced C++ developer so the wrong book
but for a lot of other C++ programmers
it could be very very good book because
it covers a lot of area it covers
testing you to cover scripting card that
covers RP design and so it's a very very
good book to refresh knowledge and to
motivate people again I think then also
I would speak tomorrow first talk about
a strong core at nine o'clock about C++
user groups and I think that also super
cross user groups can have their share
and getting bad code a bit less urgent
and this course was that we could create
local code me we actually are creating
local C++ networks shavon again serving
the purpose of Education exchanging jobs
so people bring people from bad to good
jobs and exchange of knowledge and of
course I think it's also important to
find more C++ talents and torture to
keep them in our community and not to
lose them to other language communities
and so for me it's a basic building
block of the C++ community which in my
opinion should
yeah seen as a global community which
should also be better and interconnected
so which brings me to my conclusions for
this talk my goals for this talk were
first for all make you think of a
solution that fits your needs because as
a freelancer I've seen that a lot of
environments are very very different or
there's no global solution is really
possible that will always help
everywhere and bad code in my opinion
can mean a lot of things and especially
it often also depends on your viewpoint
and in your knowledge this looks versus
algorithms a good example for that point
as you know loops are not that I see a
lot of people write code which they
think is good but when you and you have
a different when you when you're more
advanced you see that loops also have a
disadvantage and you probably should use
them algorithms and of course yeah
prefer library of application code
dealing with bad code just is a repeat
fix that if you can don't spare if you
can contain a need to and of course let
to except you like static code analysis
toxigenic for documentation and clang
modernize can do a very good job
automatically refactoring your
application code and your library code
and improving your own code base and
play more notes for example also fixed
memory leaks etcetera and as I mentioned
I think that fixing bad code also starts
with prevention and fixing the problems
which may be existing on your team's
communication etc that and of course I
couldn't resist I organize one
conferences awesome
conference and I've been visiting quite
some other conferences so I think that
exchange with the community on controls
and user groups also enhance your own
experience with C++ and that's the last
part from me be engaged in the community
share your knowledge not only this was
your college but also as opposed to my
friends etc and one point which Eric
nibbler
which is not at the conference pointed
out last year it is key not admitting
C++ said it's a good thing to commit
code to source projects once a year as a
practice and yeah as C++ and super
positive evidence if I was 14 or know
basically final we move on to a better
word and so we should try to you know
create a better word with those
standards and my opinion more in C++
which sauce both standards are based on
already prevents and fixes a lot of bad
code which we had before so any
questions
you uh you talked about C++ IDs not
having very good test support did you
try the C++ beta for resharper or the
betas or alphas for sea lion which is
the other jetbrains C++ IDE which became
available recently no but I don't think
that those are these are really fixing
that problem because I just don't think
that they were written in a way that you
know I know Visual Studio has if it's
rightly done in good implementation for
that I'm using a lot cute so cute
creator can be forced to do it but it's
not certain by default and I know that
there are new IDs which often half a
better support but I also know that a
lot of people in the industry will take
years to see any of those so it's good
that's a new IDs catch up in that part
and I think that's a good sign
but it does not really solve the problem
from people which are in the industry
which has to you work for years on on on
the same compiler though Microsoft
rejected its 2012 over 2010 or the six
subversion and same also was rescued
creator is that some some teams just
they start with a version and they will
never be upgrading quickly so if you can
upgrade your compiler if you can upgrade
or change your compiler to a better
version and your IDE which brings you
more and more receivers pass the pass
was 11 etc that's a very good thing to
do but
in the industry I doubt that a lot of
people are able to do that essence of
the decision phone again a management is
the decision and that's that's also a
point that it's very important to
actually educate your management so that
they understand why you now need to
spend money or to to have an effort to
to bring your project from one IDE to
another to improve your own work and
make it easier but not always understood
by the management it is the main crux
tariff that year if I'm trying to
understand you is is that visual studio
the idea is coupled with the compiler
version and in the case of QT creator
like it generates code or parses you
know parses your project files and
therefore like changing those is quite
difficult as a result but if you're
using a decoupled IDE like vim or Emacs
or Eclipse CDT for instance and it's
decoupled from your tool chain and
decouple from your code generators is
that a lower barrier than is the barrier
that you're saying is because in Visual
Studio and QT creator or like either
either bound to a compiler or a code
generator that's kind of tightly
integrated with the IDE and therefore
like it's not very versatile and that
makes it a harder sell or even something
that you even would even have to
convince anybody of sometimes everything
sometimes yes okay you spoke a little
bit about sharepoint or addiction can
you elaborate a little bit and
specifically do you see problems with
share pointers other than performance
the problem with SharePoint I see is
that checkpoint is basically a new which
also will always allocate a little
little bit more so he has the biggest
problem the SharePoint has performance
but also I think that and often often in
the cases in the corpus I've seen us if
you need shared pointer for sharing the
pointer than SharePoint is correct and
if you need shared pointer because you
don't have a better access to to to a
version then SharePoint is also correct
but what I have seen is that people are
not aware that they might be maybe you
know should start using the stick
instead of that so for me it's clear
that if you're refactoring a codebase
there is this there are code bases which
are very very Syrian titedent which are
not really haven't have moved on into
C++ and there of our lot of pointers
used and then you place those pointers
with Chef pointers which are objects so
in my opinion you fix maybe the memory
leak problems but you introduce much
more problems which come from shared
pointer if you overuse it and my opinion
yeah it's just people need to understand
that they should rarely use the delete
and rarely use new and that they are
often should you know be more on honest
I can be more safe this was a code a
right
yes I found that the question that goes
along with that is that white the data
needs to be shared in thinking how how
independent he finds it makes threading
harder sharing yeah
it breaks value semantics it was just
you know they're they're wrapped up as
you go along it's kind of a bad moment
yes I agree
any more questions
thank you for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>