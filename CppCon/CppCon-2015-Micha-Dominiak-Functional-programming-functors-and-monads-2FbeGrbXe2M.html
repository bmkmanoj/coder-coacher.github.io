<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Michał Dominiak “Functional programming: functors and monads&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Michał Dominiak “Functional programming: functors and monads&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Michał Dominiak “Functional programming: functors and monads&quot;</b></h2><h5 class="post__date">2015-10-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2FbeGrbXe2M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone my name is Mohammed Amin
yack I am a student at Brussels
University of Technology and I also work
at NACA networks and this is your crash
course on functors and lowlands okay so
we are going I am going to say something
about noticing patterns there will be a
mostly wrong analogy for our funders and
we will go for functors
go take a quick path without mentioning
something we thought we will talk about
monads and some and I'll tell you
something about the two notation okay so
this is a slide straight from my
previous talk so some types have common
operations and it's useful to be able to
do those common operations the same way
for those types and people tend to focus
too much on patterns they were taught so
patterns they they read about in one
particular book and they tend not to
notice patterns in code as they are
writing and rather trying to force a
those patterns they were taught into
code even when it doesn't make any sense
so I will try with a and out analogies
here so a functor
and okay so whenever I say a functor do
not confuse that with the common c++
meaning of the world of the world and if
i
the way I will refer to the C++ functors
is function objects okay so if I'm
Teresa box in that box is a value or no
value or many values today keep the same
type I don't know if it's a box so it
always you to look into the Box call a
function on the value or not there is no
value or call it multiple times
all right well the inference functions
so we have something that wraps a value
and allows you to call functions on it
and there is a particular class of let's
say monad tutorials that I tried that
are trying to explain the concept with
an analogy one most known is probably
this one
a monad is a burrito someone wrote some
text about how a mole that is like a
burrito and someone else tried to figure
out why it's like a burrito and
apparently he was wrong so trying to
find an analogy is not really very
helpful and at some point I found a
tutorial that was like ten parts blog
post that was showing use cases of
various types and how they are common
and that was actually useful
and that went for examples you didn't
try to start with an abstract definition
I expect most of you are familiar with
the emo net is just a mono eight in the
category of and the factors what's the
problem so this is not a correct way to
explain this and anymore that is not a
relative okay and the factor isn't
really a box okay so we have this
beautiful type called optional attic
there is one in boost there's one
proposed I think accepted first and ER
so it contains either no value or a
value a you can check whether the value
is there not you can create an empty
optional with the default constructor
you can create an optional containing a
value that make optional you can call a
function on the value inside although
that's not a functionality that's really
given out of the box and it looks like
something it looks something like this
so we check whether the optional is
engaged whatever is the current that in
the sender and if it is you call the
function of the dereference optional
otherwise your return nothing and okay
so this is pretty nice you can call it
the best way to use this is actually
wrap it in a function that takes an
optional and the function it's pretty
handy okay so next we have a vector
piece and in fact it contains zero or
more values you can check how many
values order
you can create or create a vector of
arbitrary number of elements and you can
call a function on all the values and
that looks something like this I hope
there is no type of it there so you
create a vector you probably want to
reserve some data for it in there some
space for it in there
and you call a standard algorithm so
that's pretty straightforward
again it's good to have this in the form
of a function so you don't have to do it
yourselves every day there is this type
called a future of T it contains a value
that may appear in the future or is
already there
whatever you can check whether the value
is there not and you can create a ready
future we make ready future also
creating it right now without the
addition of my credit future
it's kind of hard and painful and it's
pretty much similarly painful for
exception but you can do it it's level
and you thought you can call a function
of the value again with the with yet
proposed additions so if we don't want
to care about the exceptional case just
want to if a value passed and call a
function on it we can do something like
this it was called then unwrap the
future oh sorry
get the value from the future because
unwrap means something else and that's
it so those are those are functors
and I'm not trying to give him a
thematic all definitions I could but
that's not that it's not really useful
for grasping the concept for use for
everyday years okay so it's a type it
wraps order type and it exposes a
function and implementations of the that
function were the snippets on the
previous three slides so that's F map
optional for vector and for future so
why is it called F map because we're
clearly just mapping about a function
onto a by audio or more values it's
called F map because Haskell doesn't
support overloading and in very early
versions there was a function called map
that was basically f mapped on lists but
since that was shipped they can they
couldn't change but I will keep using F
map since it's easy to distinguish from
standard map okay so the type of f MA
and Haskell notation because the
superclass notation isn't really a very
useful in general it looks something
like this so it's a function that takes
a function from A to B a and B are types
F is a particular vector a particular
factor so f map takes a function and
takes a functor and returns a factor of
the same type so the arrows are there
written this way in case you don't know
the Haskell function type notation
because all functions
Haskell our parrot so every function in
Haskell this takes one argument so this
is actually a function which takes a
function and returns a function which
takes a functor and returns a factor
that's why it's out that way oh so
generic way isn't to write that in C++
isn't really nice let's not go there I
can show you some implementation of it
for particular types later but in
general to write to write it in C++ for
all possible types that's not nice
okay so we have seen those F maps before
so parent variant so a type which can
hold a value of one of multiple types
just once away it's like an Union but
only tagged so you always know which
type actually is in there can be a
factor in Haskell is kind of not written
because Cosco doesn't have function
overloading
so in Haskell there is something called
by factor and the equivalent of F map
looks like this so it takes two
functions a functor and returns a
function in C++ this is actually pretty
map pretty prettier okay that's how I
wanted to say so you can just take a
vector a overloaded function sorry a
variant and OH
the function and visit the functor and
return new new variant of proper types
okay so f map is great and it's really
useful it may not be completely visible
that it's really really useful right now
but think of every time you wrote
standard transfer creating the vector
first probably preserving the memory
calling the algorithm with iterators
that's nice
so f map is really really nice
especially when you want to write even
more generic code you cannot for example
call a standard algorithm or optional
you can call a solution and it returns a
functor so it returns a value in the
same category sorry I lied to you so
that was fun those factors for that
implement F map in this way or in the
functors so they there is a mapping from
a factor to a functor the same type
that's the that's probably the most
complicated part of the bone at least at
108 in the category event the factors
per the definition what's called okay so
I like again so oh sorry I lied again
because I am going to mention
applicative but just for completion it's
yeah it's a factor where the function
itself can be a factor so you can have
optional function
and that's from our value and you can
just call it so it's something like this
it can be useful times but it's not
really important for the later part of
the talk recently in Haskell there was a
proposal to bank or monads automatically
be applicative functors
and I think that was accepted so there
are some mappings between the functions
defined for applicative bank tour and
monette let's not go there right now
okay so monads so there is this magical
function although all the fun stuff
happens it's called going and it
flattens this is again a drunken ology
for most for most lowness it makes sense
for example for a list for a vector we
are flattening it but there probably are
some cases where this a neurology makes
no sense so we have got no optional
optional optional of T and we want to
have an optional of T so if the outer
optional is engaged if there's a value
in it we just return that value if there
is no value in there we return nothing
so if in either of those optional there
is boost none instead of a value we get
boost now otherwise we get the value
from don't be long so that's that's nice
for vector it's not not as pretty
because we have to again flat and
flatten it so this could probably be
written in several ways including
different kinds of slopes different
algorithms but the idea is the same so
drawing is a function where we have a
monad inside which is a monad of a type
and we return like single level movement
yeah this is different for some factors
I couldn't really find a factor for
which this makes no sense
but whenever you encounter a functor
when where this makes no sense
and automatically it's not that you own
it it's just a factor but otherwise we
get a minute so there we can define a
function which calls F map then call
story the idea is that we are f mapping
a function that again for optional
returns an optional so that's F not just
F map with we would leave us with
optional finality but we want just a
single level of optional okay so let's
call it M by n so monadic bind so in
Haskell this is done with an operator in
fix operator and in it looks like this
the X a monad it takes a function from
the value into the same phone app and
returns a bonus okay make sense and it's
define like this so X and bind F is
calling join on the result of calling a
flop with F with
F and X green are the arguments in C++
we cannot just do that because the
associate has so CATV T is wrong so we
wouldn't get bizarre results I don't
know what's the best operator to use
here so I really don't know and calling
it like a function usually makes the
code not readable enough but I guess
whichever operator your truth for this
it will be okay it will work so in C++
and bind it pretty much like like this
one after sometimes it's easier to
implement and bind and not draw in and
make join just work by using identity
function for example for optional it
might be easier to actually implement
them bind instead of instead of join but
it doesn't matter all the end result is
the exact same thing so a monad is a
factor every Monat is a factor so there
is a value in there or more values or no
value a monad can be used to represent a
sequence of steps of computation so when
talking about optional we have an a
computation that can fail or a sequence
of computations that can fail at any
given point if we are talking about a
future we have a sequence of Iceland
asynchronous operations that are to be
called Amanat are sometimes called
programmable semicolons because monadic
bind is kind of like
a semicolon that but you can control
what exactly it does okay so do notation
you probably heard about it at least
once and it probably was like haha C++
doesn't have do notation it's not nice
so it's a shorthand for phonetic bite
for example do something becomes
something like this okay so make slash
something means a lambda which a lambda
and names its argument something so
later we can use that in function calls
the underscore basically means we this
is a lambda it takes a value but we
don't care about the value so this up
there calls foo saves is resolved
Jenkins bar then calls bus something
unless there was a problem if this is a
an optional or maybe so it is pretty
much makes sense right and yeah if for
is successful then we call bar if very
successful also we call bus but that
reminds us reminds you of something
right that's like kind of like this this
is pretty much the same or or the almost
exact equivalent of that this right
so if that if that moment here was an
optional or rather something that saves
the information about why the
computation failed and this is decided
so people say that there's no due
notation in C++ and there is no try
it's just ok so during my previous talk
I said something about not liking the
idea that pure functions as proposed for
C++ there was a proposal for attribute
pure and it defined those functions as
not throwing I couldn't throw and I just
cannot like agree with that approach
because throwing an exception is pretty
much the same as returning an error
monad
exceptions are monadic we can convert
them into values that are being returned
so I do not see a reason not to allow
exceptions to be from from your
functions okay and that would be it any
questions a kind of yes yes
it's a guru so introduction to category
theory okay so there is a C++ / Haskell
programmer for whose name is Bartosz
Milewski
he has a blog and on that blog he posted
some some posts about category theory I
think it was titled something like a
category theory for C++ programmers or
something like that so I can say I did
read all that but from the first few
posts it looked like a nice gentle
introduction to this yeah yes yes you
are I think you are all right it's
working on a book
so would you say that multiple return
points from a function is a staple the
stateful thing so you do not like
multiple like having multiple return
statement in the I like like I like
early returns from function where I this
is a condition I know I won't do
anything else here everything else in
this function happens in the exact
opposite condition so I return from the
function instead in the other case I
would have to make like one indentation
level more so either it would be if
level of something else or if not
something and that makes the code like
wider I don't like that when I just
return I can omit the if/else block and
does right
okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>