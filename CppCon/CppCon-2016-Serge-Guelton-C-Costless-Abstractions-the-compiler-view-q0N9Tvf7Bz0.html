<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Serge Guelton “C++ Costless Abstractions: the compiler view&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Serge Guelton “C++ Costless Abstractions: the compiler view&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Serge Guelton “C++ Costless Abstractions: the compiler view&quot;</b></h2><h5 class="post__date">2016-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/q0N9Tvf7Bz0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so for my first talk at CPP corner with
a riser at a smaller room with a more
intimate a lot of people but still I'm
glad you are there and thanks to the
channel guy I was able to relax
listening to a French film music so
that's okay we are gone for one hour
speaking about compilers zero cost
abstraction and what you can tell about
it so first let me introduce myself so
I'm Serge and I'm working as an ad
engineer at wax lab boxed-up is a
security firm small one based in France
and I'm basically building obfuscating
compiler for C and C++ based on LLVM
there and I also happen to be an
associate researcher in a French
University or and the author or Python
to C++ compiler called Python but who
cares one thing when you're working in a
security firm is that you're surrounded
by reverse engineers which is not
something I was used to and when you're
surrounded with reverse engineers you
happen to look at a lot of binary codes
this guy are reading the binary code and
trying to reverse it without having the
source code and I am writing the source
code and so in the end they happened to
develop some more C++ skills and
happened to look at more at the code
generated by the compiler and that was
one of the origin of this talk looking
at what the compiler is really doing
from our eye level abstraction another
reason why I'm giving this talk is I
happen to be the peon for elf I cool
when he's teaching C++ in France
sometimes and every now and then he says
at that point the compiler will do this
and while he is talking I just verify
and sometimes well you know everybody
knows that the compiler is doing
something
but everybody knows that a sentence that
begins with everybody knows does not
always and the way you want so there is
this famous quotes c++ generates so
little garbage well it doesn't really
give tribute to the important guy here
because the language is not responsible
for generating anything it just states
the grammar the things you are supposed
to to do but there is nothing that
states from this specification you must
have efficient code right so C++ is a
nice language because it makes it
possible for a compiler to generate
little garbage you can compare this to
Python Python is my favorite debris
garbage collected language because it
makes it very hard for a compiler to
generate no garbage it's still possible
but it's difficult right and it's easier
but still difficult from C++ and the
thing we like one of the thing we like
about C++ is it is cost less abstraction
zero overhead we've been here hurrying
this a lot you can build complex
software and in the end still have
efficient assembly without adding cost
now there is no free lunch so there is a
cost but the fact is that you don't pay
the cost at one time because you have a
bunch of people that are paying the cost
writing the compilers and those people
suffer so that your code don't suffer
right so you don't pay it in the
execution time but you pay it in the
complexity of the language right
and you pay it in the complexity of the
compiler but who cares because you're
not paying it yeah
a good example about this is context so
great you can write this completely dumb
code with recursive function that will
be computed at compile time and it's
perfectly okay right the static asserts
make sure the constancy is respected and
if you compile compile this with version
of clang you get almost one second of
computation time right and then you
remove the Const and the static asset
and you just print the output and then
you have an execution time of three
seconds so Fibonacci executed it's three
milliseconds and compiled with
constructs is almost one second so this
means that the compiler is paying the
cost in computation time and you don't
pay it at runtime but it is paying more
compelling than it would if it had
generated the binary run it and then get
the result because if you have a look at
how constructs tree is implemented you
can for example try to change here's a
twenty six value to 27 and if you do
this because this is a recursion of
Fibonacci you end up doing a lot of
thing you got an ero not because the
static assert is false but because
evaluation it maximum step limit is rich
what does it mean it means that clang in
that case is in fact an interpreter for
the C++ language that interprets the
world stuff so that you can have your
fancy context to thing so the cost for
so a compiler guy is just rewrite an
interpreter for the C++ language and
that's huge but in the end you don't pay
the cost because you have no execution
time okay it's either balanced so in all
this example I will be using clang as of
the front end and LLVM at the middle and
if you fold several talks this week
you're already used to the 11 bit code
if you're not well you can see it as a
decorated
say sing code that's ready an
abstraction and here a disclaimer all
the things I've been using in I've been
tested on my laptop with a rather old
client version on a Linux laptop on AMD
64 and there is absolutely no guarantee
that this will be reproducible in
another compiler in another target on
anything which leads me to a very bad
property of C++ there is no guarantee
that you will get optimized you just
post fingers that the compiler will
understand what you want you can check
but there is very few guarantee in the
standards right so here I will not be
giving any golden rule you have to do
this because these can be optimized by
the compiler because it would be lying
this compiler can on this configuration
can optimize things right and what we
are going to see in the rest of the talk
is just hints about what kind of
situation what kind of abstraction a
compiler may understand but it's may
it's not a missed
so first abstraction functions very
important piece of any code so it can be
used for various stuff giving a name to
block of codes just as some piece of
documentation avoiding redundancy
abstract some behavior with respect to
the types francs to overloading still
we're using it a lot in C++ but it has a
price because when you do a function
call the first thing you do is save all
the register and then jump to the
function code perform your stuff and
then jump back and restore so it costs
you something and it's really used a lot
in the STL for example when you do STD
copy so that's for the GUI STL one
possible call stack would be to call
copies and copy move a to s and copy
move a
copy/move and then in the end the
built-in move depending on the tray
depending on the kind of pointer you've
been using depending on the size also
but this is a possible call stack and
you don't want to pay the costs every
time so one of the most useful
optimization I think that if I had to
code to optimization of compilers that
helps in C++ it's inlining and constant
folding so in nineteen everybody knows
you've got here a bunch of functions a
member function a function and they are
just adding one here adding one here and
then they are cool here and if you call
it with a decent compiler in the end the
bit code you will get is just an ad from
the parameter with a constant all the
caustic has disappeared and that's what
you expect without this you would not be
able to do this specialization stuffs
that end up there calling built-in my
move when you are calling a CD copy very
important piece of optimization but then
how do you control this because you
can't trust the compiler you have to
take control there is this inline hint
in nineteen tis an int so it's not do
this may be please do this the only
guarantee you have is linking parts when
you do it in 1901 diffusion will apply
but then you have no guarantee if you
want to take some more control you can
place it with the flag so it's compiler
specific but in clang you can pass this
two flags saying that if this threshold
is higher it should in line more
functions and here you can see that the
int is still useful because it has a
different flag specific flag but if you
really want to take control then you
have to rely on non-standard extension
but this is supported by GCC and clang
and you mark your function always in
line and it will try it but it's best
but if it's a recursive function it will
not in line in it's always in line if
it's possible but without any cost
related thing
so so far so good for inlining then I
will run through a bunch of small
function related code so here at the
values semantics stuff you have two
different way of updating f you can
either pass it as a reference here or
return the new value and manage the
updating as a call site two different
way of doing things
some people we say the golden rule is to
always pass by value and the golden rule
is always to pass by reference I will
just check on my setup I have I write it
the important part the first function
here is the reference and you can see
that at the LLVM label there is no more
any reference I have been removing some
extra attribute so that it's easier to
read but you have some guarantees that
this reference actually is the reference
your goal for eight bits but that's not
the point of this example you will do a
load to get to value into the part from
the pointer and then the store to update
your reference right so that's different
from the scalar version where you just
add in return right so there is an extra
memory manipulation when you do
reference so you could remember
reference do have a cost that's an
abstraction you get but they may have a
cost let's go on this is more realistic
come straight for nutkum strips here
it's an int and sometimes people say
always some stripe so that I don't have
to think which usually is not a good
thing but and here I've just marked it
as no in line so that the compiler will
not do something I don't want it to do
and I'm calling it from a column
function note that here our function is
mark static okay there is an importance
I compile it with - OH - and well not
that surprising I still get my pointer
so I have to load the value and then
return it and for the value semantics I
just get the value and return it so
construct or not construct but with - or
free I end up with the very same
function because I realized that's the
pointer stuff is not useful here but
there is an issue I have changed the API
of my function and I'm not allowed to do
this because someone may be using it in
another translation unit oh no it's okay
it was static because that may be one of
the hint I would give is when you put
something in a and animals namespace or
when you put it not in a private
namespace or if you put your function as
static then you are giving more
information to the compiler and this
information can be used to perform more
optimization so on that example well
construct on that construct doesn't care
but well usually you're passing
high-level packed object structures
classes as construct to avoid the cost
of copying the wall objects there so
here I have some things that could be
your LGB structure and I'm performing
the average and passing in as construct
which is something I'm supposed to do
and here it's static and just to show
the difference on the second function
I'm calling the previous one but this
one is not static right and there is
several interesting things that happened
so first but we are now used to this you
say okay it's static so I can manage to
change the layout or the number of
arguments so there is no longer one
structure type but it has some kind of
inlined
the structure into the parameters which
it's okay because I don't have to load
from the from the structure because it's
already loaded at the call site and then
I can perform my computation
this looks a lot like passing by copy
instead of passing by constructions and
if I have a look to the assembly code
then a lot of thing happened that's the
second hint looking at the bit code is
not always enough because something can
happen at the back end I have my to
function this one is a exported one and
this one is a static one so you can see
here there is a bunch of instructions
that are related to the original one but
from the previous one I am first doing a
bunch of move so that's loading from the
construct but I have to load them
because I can't change the signature of
this function but once I have load in
everything I'm jumping so I'm not making
a call the function was marked as in
line so I'm making a tail call which
basically avoids copying registers
before doing the jump and then I do my
regular function so a lot of thing had
happened there so thanks to the compiler
another abstraction you get is or
technique you can use this tag
dispatching that dispatching to a
different behavior depending on
parameters that is not actually used in
the computation but just use to change
the signature of your function so
different behavior different types but
you could say well I'm using an
additional parameter so maybe an
additional register maybe it will
increase the register pressure and maybe
lead to register spilling or whatever
this may sounds like less optimized so
let's have a look to what happened again
my function were marked as static it's
static what the parameter has
disappeared but that's the same name if
you don't have different parameters and
that's the same function name no it's
not because
mangling so the difference between the
two function is already done here at the
name level so we don't really need to
type the extra parameter anymore so
there is no cost in using type
dispatching for static functions then
this ma flows from does I'm not quite
sure I'm supposed to write something
like this during lambda in a pointer but
it actually works here because I have no
capture two different way of declaring a
function one good way and one that way
but who cares about this the interesting
thing is that I have the very same code
in C and the only difference is that
problem that doesn't have a name but it
needs to have a name at the compiler
level so there is this generated name
with magnificus dollars that just wrecks
a box in the highlighting of the code
but that's the same function so could
say there is no hover read using an
image function in place of named
function or in the other end I think the
name to a function doesn't have any
overhead but lambda are really
interesting for they are capture feature
so I'm doing something I've I have some
difficulties to explain the generated
bit code but I will try this is a
function that generates a function sets
perform an addition with the captured
value or a multiplication with a
constant what would you expect as a
signature for bar from a compiler point
of view my first guess was well it
returns a type related to the function
and for foo it will return some kind of
structure like a structure function and
that would work but actually that's not
the case at all Bar returns point so
like my lambda eyes disappeared it
doesn't return the function or what
but if we have a looked at foo then we
begin to understand who returns an INT
and that's exactly the closure so
captured parameter so what it does is at
the call site the function will be there
it's a return function but it's just a
type it's not a value the value it's its
state so you return the state and at the
call site you know that you've got your
function and you can use this state to
run your function but that was funny to
see how it's represented by Alabama I
don't know if GCC use the same approach
I would assume yes because otherwise it
would be some ABI incompatibility but
I'm not sure second high level piece of
abstraction and you've got your
functions and you've got your data and
data associated to strengthen classes so
they are used to box faint box values
into types that you can associate some
processing to your type
assessing procedure to the data manager
lifetime and so on well that's a piece
of abstraction we are relying on so we
are boxing value there is this famous
test Stepanov test that gave its name to
a famous password and I will just check
what happens here we've got two kind of
boxing boxing for structure of
inheritance and here I'm allocating a
new object and I assume that it will
create this open G scope let's have a
look first it's allocating some raw
memory the interesting thing here is
that you get to understand how our
constructor is called that's a bit cold
level so get first to get your raw
memory and then you do yours this kind
of placement you like I'm storing some
value into this memories because I here
to manage the raw memory converted to
the real types and then assign the first
character and then the second character
with some memory moving this one I can't
really explain because it's storing
first to zero and then on that very
place story in this character and the 8
bits afterwards this character quite
strange if we have a look as you
generated assembly there is still this
at a very same location first during
zero and then not storing the first
character and the second but storing the
packed value so maybe someone in the
audience knows why we have to store this
here maybe to zero because our ace can
hold more than 16 bits so maybe to 0
this and then store but I'm not quite
sure so I would tell some more boxing
and unboxing here you have a strict with
a strict with a strips or nested
structure our key hierarchy and then
individually setting the values what
happened you would expect something like
setting the first value setting the
second value as in the previous example
but in the end you realize that these
all are integers so instead of using
this complexed type we can just use an
end of 48 bits and begin to store value
but instead of storing value in the
first bits and so on we can do some
computation just to avoid storing too
much and that's why you've got this
shift left and or operation instead of
just moving data because computation is
supposed to be less expensive and memory
operation so it's not only unboxing
stuff it's also merging representation
when it's possible then you've got
memory functions member functions are
they're a good abstraction should you
write functions that take the structure
as first parameter or not
well surprisingly enough a member
function is very platonic because the
compiler sees this as a function with
the Z's parameter as first parameter so
there is really no difference between a
member function and a function that
takes your J as first parameter and then
you call your staff that's right it
doesn't matter so just like the self in
Python makes me happy this example tries
to showcase what happens when you do a
copy that's a default copy constructor I
have a very large object here I first
initialize one global one and then
perform a copy from the parameter to the
global one there's no point on you do
things is in real situation before click
right here it's okay first this is a
global variable so it's default
initialized with a bunch of zero and
that's flagged here and then whoa wait
the SI guy would be happy because I
didn't write anything specific here but
something that looks like a mem copy
happened so that's not the CMM copy
right that's a hell of a bit built-in
that abstract the mem copy behavior with
respect to different types that I don't
really understand by the way here and
then it's up to the backend to select my
guess
during the lower range to select do I
have to call mmm copy can I just use an
unrolled loop but the copy constructor
happens to be recognized as an idiom
that can be optimized later so that's a
good new that's one exception to the no
standard no guarantee in the standard if
I'm not mistaken copulation is
- happy happening it's written in the
standard so copy Allegiant is that here
I don't have to copy my object as a call
sight I can just use the ones that I
returned and to version here it's
returned without giving it a name and
here I give it a name as and I return it
and in fact by design copulation is
respected because when you return a
value that is not a scalar but a complex
object then instead of passing it as a
return parameter you pass it as a
function parameter with a special
attribute here so a threat which flag it
has this is a return value and so you
don't have to care will there be a copy
or not because the object is already
created at the con site and you just
fill stuff in right so copy illusion
works by design and if you use a
temporary well it just doesn't matter
you've got the exact very same code then
virtual metal goes hot topic so here
I've got my interface and I implement it
in hey and for the purpose of this
example I mark to do its function method
here as final and i'm calling this do
its method either foods interface or
through the actual object so my foo and
bar function are not static so the
compiler can't make any guess so not
very surprisingly there will be a cost
here and you've got this V tables that
happen well here instead of first here
it's final so I know that this will be
this function that is cold and it gets
in line and everything works and here I
have to look into the internals of my
structure to get the V table pointer and
then
access to the actual function pointer
which is why here instead of calling a
function I call something that is in
your register so I have an indirect call
and I do pay for this but there is
nothing the compiler can do here because
well as their interface has no reason to
be implemented only by a so I pay for
the table but in some simple case and
maybe in more complex case but I have
not explored this here I'm telling the
compiler well I have my origin object a
but I see it for its interface before
calling it right and as its food
interface so the table may be involved
but hopefully it's not because well it's
just in the scope I can know the real
type so I don't have to perform a
dynamic look at photo type and so it's
divert realized and it can be in line
just one word what costs here is not
only the fact that you have to look for
the function but the real cost is that
as you don't know the function you can't
inline it and remember inlining is one
of the keystone of optimization for c++
and me table just destroy this but
sometimes it doesn't matter then I have
this free fall section where several
stuff from the C++ language from the
standard template library some
controversial one and just have a look
to what happens from a compiler point of
view initializer list that's a global
scope and I have created two objects one
is an STD array and one is a STD vector
so I initialize the same but they may
have a different life afterwards in
which section what you think this goes
to the text section the code section the
data section is a read-only section same
question he
in the final binary let's have a look
first as LLVM sees this this is my array
it's a global and it's initialized
statically so there is strong chance
that this will go to the data section
speaking about the L format house that's
nice
there will be no operator at startup
because everything is already in in the
binary it's a good section but things
get worse with vector so global value is
zero initialized don't care this is an
extract from the Alpha constructor so f
constructor is the function that gets
initialize that gets called before the
main or if you're using a shared library
when your library is loaded first all
these things happen and then you
actually run your code so before your
the main you will initialize your vector
which is what you expect because it was
global
but you initialize it by storing every
single value one after the other
so here the loop has been involved maybe
with a larger initializer list one thing
I would expect is maybe put this data
into the data section in their aero data
and do a copy but that's not what
happens so there is a slight overhead
using a CD vector there because you pay
at runtime for the static initialization
of your vector then this auto some CGI
would say hmm
Auto looks like magic so if I want to be
sure I write my indexes so the things
that happened is what I have been asking
for let's have a look
that's a bit complex cause that's a
inner loop you've got some things that
takes care of the injection by a ball
the free stuff but you just have to
count that's one two three four five six
and the branch that the auto Russian and
here one two three four five six seven
plus a branch so the index loop indexing
loop indexing flow scholar actually
generates one more instruction at the
Elven bit code level then zero to one
why because of the highlighted stuff
here when you iterate with Auto you're
iterating four with the iterator so
through the pointers and so the
induction variable of your loop is also
the place where you will store the data
but when you are using an additional
index then you still have to move to the
pointer so you still have this pointer
that does the induction plus one integer
that's also perform the induction so you
have to two variables that do basically
the same stuff right so this may
increase I don't know maybe to register
pressure
it certainly doesn't have an impact on
the performance in the end but still
high level low level but low level does
not mean you're doing it good low level
means that you can do at the low level
everything that you can do as I level
but you can also do bad things that you
would not do at high level because you
don't even think about this then
indexing a vector very simple you just
call the interpreter compared to
indexing a pointer I'm not advocating
for using pointers everywhere instead of
vector right it's just a matter of
comparing the stuff and not very
surprisingly there is an additional
instruction when you index for a vector
because you first have to access in the
vector it's a pointer and then from the
pointer you
you can go index the real data while if
you only have two pointer you access the
data so you have an extra indirection
that says from my class I have to go to
the actual pointer but most of the time
if you're indexing your into the loop
and this extra differencing will be
moved outside of the loop or might be
moved outside of the loop and so you
don't care you you end up with the same
loop body but still there is from a
compiler point of view this extra small
overhead that doesn't matter most of the
time I was very surprised by the
behavior of trying on this one can I
remove the new delete spare yeah oh no
what's what's a job of a compiler
generating a code that has the same
behavior semantics as one explained if I
run out of memory here and I do a new
what the behavior I've got an exception
or a crash depending on setup but if I
remove the new then I no longer have my
crash and that's something that's an
observable behavior a crash and actually
clangy removes a pair just doing the
regularization but GCC doesn't right so
I don't know about the stone that I just
find it funny a few were the Box
exceptions there is no except keyword
does it help if I don't put it
everywhere what happens here I'm
cheating a bit because there is no
static
so I can't change the signature of the
function but say also I am trying to
call both I know nothing about the code
because it's not in this translation
unit and I may happen to catch it to
just refer them information first thing
you just have a look at the Declaration
of the function bar and who both have
some attributes I removed all the
attributes on the previous example but
here it's important because this this
extra attribute no unwind
no except means no unwind which means I
don't have to register my from shown in
a special place so that the unwinding
stuff can go well and that's not the
case for the second so there is an
impact I will not be registered in this
special variable and when I do my call
so first function remember no except
there is a cowboy it happens to be a
tail call that's a regular call for foo
it's not a call it's an invocation like
Magic the Gathering you are invoking
something and which basically mean call
this and if everything goes well go to
this level but if something goes wrong
and we don't know because we don't have
any exception specification then begin
to in mind and then that thing may
happen well in fact I have never
understood exception on Ling in LLVM I
just try to avoid generating this kind
of setup but it happens to be processed
differently by the compiler and it does
generate a bunch of code so it's not a
myth that if you go this way in the wine
unwinding then you're paying a lot right
because there's code executing a final
one in my one of my previous life
I'm not old I was doing HPC and there
was this number crunching routing and
you don't use C++ pulses because well no
C++ you don't control anything I've just
been writing the outer product the very
dumb way even using indexes right and I
compile this with - oh free - arc equal
native and I will spare you all the
outer loops but in the inner loops LLVM
does recognize that you can use a sieve
the instruction because you have this
vector form of the floating point
multiplication does that good news I
don't have to care on simple example
about vectorization I get a free
abstraction of my ad where the compiler
happens to to understand it or in real
life like signal processing the
automatic vectorizer accounts do its job
on many algorithm but on this one it's
okay
so the bring home message the only thing
you have to remember because I told you
that there won't be any golden rule is
that we do love compiler compilers
because they are responsible for free
abstraction they do their jobs and so we
can do ours which is just engineering
software engineering and not compiler
engineering but as they help us when
someone helps you you have to
communicate with them right so have a
look to the info page of GCC have a look
to the manual help of clang and there's
a plenty of flags that you can use to
tweak the way you communicate with him
most of them some of them are portable
some of them are not but still it's
important and then you don't you can't
trust really trust a compiler it's not
because I've showed you that inlining
works at initialize our initializer list
with SDRs that it will always be the
case right it's it should be the case
but there is no guarantee so it's nice
to be able to verify the code generated
codes in generating by code the assembly
when you are in doubt the source is just
the input you have to have a look to the
generated part and then a bunch of
thanks because for the the people that
helped me to improve on the high-level
joelle empiric and the friends from
quacks labs that helped me improve at a
lower level and all around forms from my
firm from letting me talking here and
cpp comb for making it possible to talk
I guess we have plenty of time so plenty
of time for question yes I think so the
question is I told you that if you don't
use no accept then there is some
registration of the function in a
particular structure and what is this
cost I think it's a compile time it's
the function is register in a global
variable and so that there may be space
costs but not a runtime cost yes so if I
understand well the question the
question is should you just remove the
inline keywords everywhere the only
place where I've seen inline useful is
ready for this one definition rule I
mean if you put a function in the header
then you have to mark it in line so that
you don't get a linking issue but as an
int like you're in the you have a static
function in your translation unit I
generally don't put it in line and it's
always
so repeated question yes anyway there is
link time optimization so are all this
in line static stuff important so first
link time optimization from what so
there are in all of them to kind of link
time optimization there is a you paper
hole and thin link time optimization
that only takes care of some
optimization like in lining and constant
folding and that gathers some summary of
each function before doing the actual
stuff instead of load because the link
time optimization that cost you a lot is
you take all your translation unit put
them in a single big translation unit
and then run so if you do this and there
is a main so it's not and if it's not a
shared library then you know that no
symbol has to be exported so everything
is static and at that point I think that
in line is not relevant and even static
and then you don't have to worry that
much about things being static or not if
you're in your shared library then the
static keyword is still important
because it controls what you exports but
I would be more worried about static or
not with respect to linked I
optimization than inline or not yes I
think the difference is so the question
is any difference between static and
animals namespace and the difference is
that in an anonymous namespace if you
declare a class with inline methods then
they get static and you can't put this
in for static function I think there is
not
and is a question yeah in what situation
can a call back that you be optimized in
what situation I think that class
members are not static at all static
like local to the translation unit so
you have to put them in a private
namespace in anonymous namespace and
otherwise are part of the API but may be
that if your type does not escape from
the translation unit then it's okay but
I'm not sure what I'm telling you I have
to check which is to all point of this
talk yes so the question is somehow
related to previous questions that do I
have any experience in hotels link time
optimization effects any of the examples
I have shown where static where I had
two marks function static or not and my
guess about this is that if you're
compiling into a binary and not into a
shared library then you can assume that
everything is from a from the link time
optimizer it's and everything is static
which means that you don't have to worry
anymore about respecting the API except
if you have taken the address of the
function and pass it but and if you are
building a
library then the API staff are still
valid and then it's still matters okay
in other question so let me thank you
again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>