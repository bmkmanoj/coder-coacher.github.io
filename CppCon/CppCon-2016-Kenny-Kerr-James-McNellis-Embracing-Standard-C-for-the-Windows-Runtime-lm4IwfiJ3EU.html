<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Kenny Kerr &amp; James McNellis “Embracing Standard C++ for the Windows Runtime&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Kenny Kerr &amp; James McNellis “Embracing Standard C++ for the Windows Runtime&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Kenny Kerr &amp; James McNellis “Embracing Standard C++ for the Windows Runtime&quot;</b></h2><h5 class="post__date">2016-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lm4IwfiJ3EU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right great thank you all for your
patience all right well thanks for
coming now let's begin my name is Kenny
Kerr I recently joined the windows team
and this is James McMillan
he's from the visual C++ team we're you
were here together because this has been
a pretty big collaborative effort
between our teams to build something and
really modernize the the experience for
the C++ developer on Windows prior to
coming to Microsoft I created a new
standard C++ language projection for the
Windows runtime so the windows runtime
is the technology that sits in the heart
of the universal Windows platform the
the API surface for the Windows
operating system and Microsoft created
various language projections for the
Windows runtime so this one for c-sharp
and JavaScript and so on but there
wasn't one for a standard C++ and so
that's what we're going to be speaking
about today so let's let's begin with
the hello world app why don't we do that
so here's a great little Windows
application there's an on launch method
now this is a sam'l application so it's
really Windows here there's a text block
we're creating here we set the font
family font size and even a lovely hot
pink foreground color we align the text
within the block and we give it some
lovely content we then get the current
window set the content and activate the
window and we get a great little
application ready what do you think
that's that's a very nice app I have I
have just I think there's just one
little problem at at that yeah I think I
think that might be c-sharp oh yeah yeah
yeah this is CP pecan oh I'm sorry
yeah I'm sorry do we have the wrong deck
yeah maybe yeah okay yeah well can we do
this in C++ we can actually okay yeah
here you go show us the way so I'm going
to show you now C++ is a very advanced
and powerful language gives you great
capabilities and so we're gonna see how
you write this same app using C++ so
when we're using C++ we have to actually
use use it at the ABI layer so you know
calling interface functions calling C
functions so there's not going to be any
exceptions at that layer and so we're
gonna need to check status codes and so
in order to do that we have this little
helper function check age result and
we're not actually going to do any error
we will leave that as an exercise to the
attendee so we're going to write the
exact same app that we had from c-sharp
so we're also going to have an app class
but we can't just derive from
application like we did in the c-sharp
example because application is
implemented in some operating system DLL
we have no idea how big it is we don't
you know we don't have its
implementation here in C++ so we can't
use the normal C++ derivation so instead
what we're going to have to do is we're
going to have to implement this I a
plovers interface and what this will do
is it will allow us to implement all of
the functions that we might want to
override from the application class
we'll then construct an instance of that
application class and tell it by the way
we're derived from you and so anytime
that you want to call one of these
override functions call our
implementation first and then do your
thing
so in our constructor here we're gonna
do just that so in order to construct an
instance of the application we actually
need to get what's called a activation
factory in this case I application
factory and this is an interface that
has all of the function all of the
constructor functions on it so these are
the functions that construct application
objects and we use this get activation
helper function in order to actually
construct the application factory we
pass in the name of the application type
which is in this case windows UI zamel
application and this runtime class thing
is just a it's a string constant and
then we get the factory back we'll then
go and call create instance on that in
order to go and create an instance of
the application and you see that we pass
into this pointer to say hi this is the
derived class instance so when you need
to call overridden methods call me so my
application overrides has a bunch of
member functions and the only one that
we actually need to override is
onlaunched but since we're implementing
this interface we have to implement all
of these thankfully we can do that very
easily we just need to write you know
return success for each of those
functions I'll leave it as an exercise
to the audience member to actually go
and do that for all of those but we'll
just focus on the on launch function
because that's where the all the
interesting stuff goes on looks real
simple yeah so far I mean this is easily
as good as the C chart yeah yeah
so we're gonna implement that on launch
so we're gonna do everything in it that
we did in the c-sharp example so the
first thing we're going to need to do is
we're going to need to construct a text
block in order to do that we need to
call this row activate instance function
in order to construct an instance of the
text block but that gives us an eye
inspectable pointer and so we actually
want to get a text block a you know the
text block thing and so we'll have to
convert it you know basically cast it to
the eye text block interface pointer so
we're gonna set the font family this
should be relatively straightforward so
here we also need to get the activation
factory for the font family because
we're going to need to construct it
using this string and then we'll create
an instance of the font family basically
we just call this create instance with
name function on the factory and then
we'll put the font family on to the text
block alright we're gonna set the font
size this one actually I it's just one
line alright here we go we're we're on
par now okay but to make up for that we
need to set the foreground so to do this
the first thing we have to do is we
actually have to get that hot pink color
so hot pink is a property it's a static
property of this color structure or
class or I don't know what runtime class
in c-sharp it's so in order to get that
we actually need to get the activation
factory and we need to get its statics
interface which is all of the static
functions that we can call on it so once
we have that we can call a get hot pink
which will give us the color for hot
pink we'll then go and we'll construct a
brush factory that will allow us to
construct solid color brushes and we
will construct a hot pink brush by
calling create instance with color on
that in order to get a brush that will
paint hot pink and then finally we will
use that brush and we will set it as the
foreground color hmm yeah all right well
we're getting there yeah but always the
p.m. so we're gonna set the vertical
alignment and there we we have to
actually call that on a different
interface we can't use the I text block
we have to call iframe work element put
vertical alignment so we'll do the cast
there again and we'll call put vertical
alignment and we have to do the same
thing for the text alignment and then we
can set the text
hard work here so now we've got our text
block yeah okay we just need to set it
as the content great so yep so we have
to go and get the statics interface for
the window class right and then we're
gonna go and get the current get the
current window we'll go in we will set
the we will set the actual content to be
that text block that we had and then we
will call activate on the window and
that's it it was easy so yeah here's our
hello world in standard C++ yeah Fitz
all right yeah and you'll see we get the
exact same result yeah
so yeah we can do all of this in in C++
it's a great language yeah is there an
easier way is there an easier do you
think it needs to be easier I mean these
are C++ there's very advanced very
knowledgeable people
I understand about job security but I
mean I see let's let's try and make a
little easier yeah so we recognized four
years ago when we shipped Windows 8 that
that would not be an ideal development
experience like nobody wants to actually
write all of that code and deal with all
of that you know it you just shouldn't
have to do that and so what we did is we
came up with a set of language
extensions called C++ C X that wrapped
up all of that logic that wrapped up all
of those implementation details that you
don't want have to deal with and try to
provide a fairly natural c++ ish
development experience and so to
demonstrate that here's our C sharp code
example again again it fits nicely on
one slide you see I put some special
spacing in here and you'll see why in a
moment this is the C++ C X version so
effectively you can see some of the
keywords moved around right we had to
move the protected up above the function
and we had to move the override keyword
to the other side we have these funny
ref new keywords in order to construct
instances of objects we have these
pointers now we use the arrow instead of
dots but otherwise you know this is
about the same as the C++ or this the
c-sharp code and their heads too yes
there's also hats so the text blog is
wearing a funny another funny little hat
yes so this is you think this is better
it's bitter yeah a lot better put some
slide yeah but there's been some there's
been some challenges
this right and so the first challenge
that we've we've kind of run into with
this is that memory management is not
customizable so you saw those ref new
operator in order to construct instances
of these runtime classes
none of the allocation is customizable
there it's effectively going to call
operator new and then call into malloc
but if you wanted to use like a memory
pool to construct your own objects
there's no way to do that yeah so none
of the more of the problems we have with
it is that you know and we saw in that
earlier slide where anyway you know you
were just going to terminate and in
reality when you do a little bit more
work in terms of grabbing the when when
our TR information and making that
available as an exception and so it
turns out the way the CX compiler does
that tends to introduce a lot of code
bloat on the cool side and so that isn't
ideal and because it's compiler
generated you don't have a lot of
control over that experience so that
isn't very it doesn't work very well
mm-hmm another place where we ran into
some difficulty is with Interop between
standard and WinRT types so in the
windows runtime interface we want to be
able to pass things like arrays of
things and vectors of things and maps of
things but we can't actually use stood
array stood vector instead map because
you can't name those types in C sharp or
in JavaScript right so we need something
that is ABI safe and so Windows runtime
defines its own interfaces for array and
vector and and generates map string and
so you have to use those when you're
actually crossing the ABI boundary but
these don't interrupt particularly well
with C++ with the C++ types vector and
such and so you know we tried to provide
some bindings to that but the general
advice has been well if you're using
those types use them only on the on the
actual boundary and use standard C++
within well this has turned out to be
much more difficult than you might then
you know it initially seems because you
have to worry about things I mean
effectively then you have to copy
anytime you want to cross the ABI
boundary and so there's a substantial
performance cost and we actually vast
slide on that a bit later
yep so one example of that is array
performance if you have a Windows API
that accepts an array as an input
parameter by default instead of default
code you might write for CX which
wouldn't even bind to us to defector
stood vector to begin with but by
default is going to give you incredibly
poor performance because it's going to
make a copy of the array so you know
there's ways to work around it but it
isn't obvious
it is an ideal certainly the amount of
code you need to write for such things
is is quite prohibitive another problem
is that there's no visibility into those
abstractions so as we saw this a lot
less code but the compiler is actually
generating a lot of boilerplate behind
the scenes and it actually generates you
know real C++ code and there's a way you
can get the compiler to print out what
is generating but the problem with that
is is you still can't debug through it
if something goes wrong and oftentimes
it's opaque if you're trying to debug
exactly what went wrong
sometimes that compile time sometimes at
runtime it can be difficult to figure
out exactly what what has gone wrong and
so you know that's just a general ya
issue with compiler generated code like
that yeah debug ability as you mentioned
it's a problem it's not a standard
standard library you know header only
library perhaps that you could actually
step in and look at the code and even
customize tweak put up you know printf
statement in there put breakpoints in
it's just it's just not accessible to
the developer yeah certainly syntax
differences as you've seen it's it's
it's something to get used to for sure
it's not standard C++ it isn't you know
so a lot of us here you know if you come
to C be pecan you love the beauty of the
code you love looking at code you like
writing code that looks beautiful and
certainly it's a struggle if you have to
decorate your code with things that are
not part of what we like to call model
or standard C++ mmm-hmm and these are
just the big things so that's kind of
kind of unfortunate I guess we're stuck
with that that low-level ABI programming
yeah no I think we can we can do better
do can't wait yeah I think excellent
yeah let's say let's take a look so c
plus plus 1 or T in a nutshell this is
so as I said before this is a new
standard C++ language projection
specifically we're focused on standard
C++ so we're not going to introduce new
language extensions to make this work
we're all about driving forward with
standard C++ and you know taking
advantage of everything that's new and
great about C++ 1114 and so on provided
it's a compile time feature for the most
part it's a hitter only library which
means that this isn't the DLL you need
to download or link to there's no issues
in terms of building it you simply hash
include and off you go
it's a the classy type system so the
windows runtime even though it's based
on comm it's its front and center it's
the idea
types strong types clauses with methods
and so we want to project that into the
language in a way that's natural for the
C++ developer so if you want to
construct something you call a
constructor you want to call a method
you call a method you want to return
something you simply return it you don't
have to deal with all the overhead of
comm and that's that's the way we'd like
to program that's the programming
experience we'd like to bring to
developers and so yeah it's it's gonna
be natural productive and safe the
programming model should be familiar to
the C++ developer it should give you the
productivity of c-sharp and bitter so we
don't wanna be that guy that says all
you know we can use you you know C++ for
performance but you really want to want
to go there if you want to get work done
we want to be productively won't be as
productive as the competition and we
want to give you the safety that you get
from modern C++ so you don't have to
deal with pointers and references and
all the all the things that make C style
will come style programming difficult we
want to make it safe and easy and
reliable by default yeah so taking those
things combining them with standard C++
allows us to give you the best possible
performance we we get to we get to or
you know give you some code that you
have to include into your application
and we then pass it on to the C++
compiler any standard C++ compiler they
can give you know the full power of the
optimizations that are available to that
compiler to the code and get the best
possible performance and the smallest
binary so we'll get into some numbers on
that in a moment yeah so really this is
the language projection for the systems
programmer not many of us in the room
here and at CPP count of systems
programmers you know that means we like
to go a little deeper and the average
app developer we need to understand
things a little bit better you know
whether you're writing a Windows
application the console app part of the
operating system this is the thing that
you want to use because it's it gives
you the control you need over all the
things that matter to the power
developer whether it's allocations
whatever it might be you can get in
there and customize and tweak as you
need to and of course it's full for the
app developer you want to get the
productivity of the you know writing
your regular everyday application this
is going to be for you as well and
finally it's a sing to wrapping all that
up and saying the code you write should
be as simple and as direct
in terms of mapping to the the the API
model that the API designer had intended
should be well reflected within your
application those are some modest and
lofty goals you've got there yeah yeah
well hopefully we'll get some traction
yeah so here again is the c-sharp
application and that we looked at a
moment ago and now let's look at the
standard C++ equivalent in C++ 1 or T
and as you can see it actually hey it
fits on one slide and it looks like
standard C++ you can notice an immunity
so there's is a there's a parameter then
that's construe so that's a good
indicator here there's no hat there you
know we you know if you want optimize
passing some some object around you
might use a reference standard C++ we're
creating a textbook here it's a local
variable we're constructing it as you
might do with any C++ object you'll
notice again though that standard C++
has no properties in the language so we
translate them to methods though the
language projection does the job of
mapping the Windows runtime in the most
natural way to the language that you're
targeting in this case it's standard C++
so we're not going to introduce some
crazy extension for properties rather
we're gonna say they're they're
projected as methods now if the
Standards Committee would like to add
properties hey we'll adopt that in the
future but today this is what we have
yeah so and we get our where we know
that's the application I might have been
the slide behind ok and then we get
application and it works just the same
it fits on one slide so let's build
something a little bit more interesting
so let's say we have an application that
we want to pop up a file picker and
allow the user to pick an image and then
we'll take that image and scan it for
some text and then display the text in
the window of the application so how
would that work
well in c-sharp what you might do is you
create an application we'll have an on
launch method as we did before we might
then want to separate the work for
foreground and background
so we'll have some foreground work
that'll be creating a file picker and
then updating the text box we'll do some
background work that'll be doing all the
IO that we might need to do loading a
file doing some OCR work eventually
getting the text back and then
forwarding that back to the applications
text box so within the on launch method
for the c-sharp application it's fairly
straightforward you create your text
blocks
font family font size all their regular
settings the main difference here is
that we're not actually setting the
content of the text block other than
that we're activating the window and
we're calling that foreground a sync
method with the text block as a
reference to get the job done
for got a sync it's an async method we
create a file picker we set some of the
properties on it and then we await the
pick single file async method which will
return eventually a storage file for us
to pause through the background async
method and we then await the background
async method and that's where it gets
interesting see what we want to try and
do here is we want to build a background
async method that returns a WinRT async
operation so that we can conceivably use
this later on in the component shared
across our applications and so how would
we get about doing that well the first
thing we need to have a method that
returns that type that WinRT async
operation type but more than that we
want to get the work on the background
thread so the first thing we need to do
is we need to create call toss that run
and what that does is it takes that
lambda and sticks it on the thread pool
so that's drove them one of course
that's a c-sharp constructor or net
construct so we need to then have a
second step where we actually turn that
into a winner t async operation that we
can actually pass across the ABI to
conceivably another another language so
those are two steps that's an extension
method that's provided by c-sharp for
doing that but it gets the job done and
eventually if you can figure all that
out then you know you get your
application and it looks pretty good
what about CS can we do that in CS we
can do it in C X I was actually going to
show you all how you do this in standard
C++ today yeah but it literally took me
my entire flight out here to write the
the hello world example so we didn't
have time to deal with the complexities
there so yes we can do this in c++ CX
and it actually looks a lot like the
c-sharp code did so here's our C++ C X
app we have the same onlaunched event
and then we have the same foreground
async and background async functions
that we had in the c-sharp the
foreground async returns a task of void
which is from the ppl library that we
have for Windows for development on
Windows and then the background async
returns the windows runtime ie sync
operation and then we have the same main
function that goes and starts the
application or on launched again is very
similar it just it does exactly what we
did in the hello world we just don't set
the content and said at the end we call
this foreground async function
the foreground async function is
effectively the same as the c-sharp
there's just a few syntactic differences
we have to say koa wait because that's
the sepals plus care routine keyword
instead of the weight which is used in
c-sharp right and it's in the background
async again where things get very
interesting so here we again return the
eye sync operation with a string inside
of it
and again we have to do the exact same
two tasks that we had to do in the
c-sharp first we have to get work onto
the thread pool and to do that we call
this create task function which goes and
takes this lambda packages it up and
then schedules it to execute on the
thread pool will then have to use this
create async function which will convert
that into a I sink I a sync operation
suitable for passing across the ABI so
we have the same two steps just a
different syntax because we don't have
the extension methods in C++ it's a
little bit more a little bit more
verbose a few more braces but otherwise
does the exact same thing and indeed
we've got this but this slide says
there's a better way and so I'm hoping
that Kennedy can even do better than the
c-sharp yeah I think we can't let's take
a look so here's our application again
and you've seen the outline there's a
normal answer method we're adding a
foreground async that returns a
fire-and-forget that's just a very low
overhead her routine type and then
background async
again returns an is Inc operation that's
altima key what we want to figure out
here on launch does the same thing
creates a textbook set some properties
it doesn't set the content and then
calls for grande Seng foreground async
again does the same thing we create a
file open picker we set some properties
and then we Co wait on pick single file
async it eventually will resume and
return a storage file which we pass to
the background async method and this is
where it gets interesting so here we see
that we only mentioned the is Inc
operation once and that's how we produce
an I think the compiler combined to the
library will take care of actually doing
that work for you there's nothing else
you have to say and then to get the work
on the background fade all you have to
say is Co wait resume background and you
await on that on that object and you get
to work on a background thread and
that's it you're basically declaring the
behavior you would like to have and you
get the job done in the most obvious and
simple way that we could imagine
yeah so this this resume background is
actually pretty cool and if you want to
know how its implemented it fits on a
slide and we're going to be presenting
about that tomorrow just one slide so
please do check that out so let's talk a
little bit about interfaces James you
want to give a torturer so as we've seen
the Windows runtime is basically class
oriented right you want to be able to
construct a text block and you want to
be able to use the text block as if it
was a text block object but under the
hood there's no real text block
we're restricted to see api's and comm
AP is at the API boundary and so all we
actually have our interfaces so those of
you who've done any comm programming
will know that the base interface in
comm classic comm and in the Windows
runtime is I unknown and I unknown
provides two basic capabilities the
first is it provides lifetime management
so it provides these a breath and
release functions that allow you to
increment the reference count and
decrement the reference count on the
object and when you call release and the
reference count goes to zero the object
is responsible for destroying itself the
second is it provides a dynamic cast
like functionality called query
interface or Qi often for short so each
of these comm interfaces like I unknown
or others that we'll look at have an
Associated gooood and so you call now if
you want to know does this object
implement this interface you call query
interface and pass in the the gooood and
if it implements it it'll return you a
pointer to that interface for the object
and if it doesn't implement it it'll
return you a null pointer so the the
nice thing about AI unknown is that it
provides you a language neutral way of
managing lifetime and dynamic casting
and so all that any language actually
has to deal with is it has to deal with
you know the basically a V table and C
api's so you don't have a whole lot of
burden in trying to you know use these
from other languages whether it's dotnet
or JavaScript or other things Windows
runtime
adds a second interface derive from I
unknown and most of the windows runtime
types derive from this and it provides
three functions the first is get I IDs
which is not frequently used but you can
use it and it will return you all of the
all of the goods for all of the
interfaces that the object supports so
if you want to do a little bit of type
querying and find out what are all the
func all the differ
pieces of functionality of this type
supports you can call this this is
usually this is used by debuggers in
some cases but otherwise it's not
frequently used the second is get
runtime class name and so with this one
if you call this it will give you the
actual class name of the class of the
object so for example if we call it on
text block it'll give you the fully
qualified text block named windows UI
zamel controls text block I think so
this is used for in for example by the
dotnet runtime in order to identify the
type of the objects that I can go and
load up the appropriate metadata to find
out what it can do with that object it's
used by other it could be used by other
dynamic languages the third function
here is get trust level which isn't use
we won't discuss it so in the Windows
runtime
all of the interfaces derive from these
so we can consider for example a text
block which is the main interface for
the text block type and it has a lot of
functions but we will show just two of
them here we have a get font size and a
put font size so you'll remember that
font size was projected as a property in
c-sharp and in c++ c acts so you could
just use it as a property but there's no
properties on the ABI so we just
implemented using two different
functions two things you'll notice about
these functions the first is is that
they actually return H results so H
result is the status type for comm and
when and the windows runtime and so it
returns zero on success or some other
error code on failure the other thing is
that because it returns an H result the
get function needs to actually return
the the result via an out parameter so
it's not a particularly modern C++ way
of programming but it's what we're
restricted to at the ABI layer and it's
one of the reasons that programming in
just standard C++ using the ABI layer is
not a particularly fun experience right
but we can use these interfaces at the
ABI layer and we saw this in the in the
hello world example where we use the
double URL library for a little bit of
help but here we use with no library
support so if we get an ITEX block
pointer somehow we can call it get put
font size on it to set the font size we
get the status code back we check did it
succeed if it didn't succeed then we
have to go through the pain and
suffering of you know doing whatever we
need to do in order to recover from the
error and at the end we have to release
the point
so that we don't leak the reference to
the object and eventually leak the
object but of course no one wants to
write code like this even in you know
normal C++ and so for a long time a TL
has had a smart pointer called C
competir and the WRL library that I just
mentioned has this company it's a lot
like shared cutter in that it's shared
ownership so when you make a copy of it
and you have two of these competir
pointing to the same object they both
hold a reference when you make the copy
it will call add ref when you destroy an
instance it will call release it doesn't
provide any weak pointer like behavior
as sherab cutter would but the advantage
that it has over shared footer is that
it can take advantage of the intrusive
reference counting that all of these I
unknown derived things have so it
doesn't actually need to go and allocate
a control block for the object the other
things that computer provides is it
provides some help to wrap up query
interface so you don't need to deal with
the gooood z' and the raw pointers so
with c++ WinRT it's a lot simpler so
here for example if we get an i text
block it's just an object and it will
refer to the text block and if we want
to call you know set the font size we
call font size to pass in the new font
size if an error occurs internally it
will detect the failed age result and it
will turn that into an exception for you
so you get to write just normal C++ as
you as you would really want to do and
then when the I text block object the
block here goes out of scope it will
automatically call release for you so
effectively it wraps up all of that
reference counting just like competir
did but it does so in a way that's a bit
more natural in C++ and it also
encapsulate saal of the functionality of
the types and does the error handling or
error transformations for you so
interfaces are also at the heart of all
these classes so as we said there's no
text block type at the ABI layer like
there's no physical text block type that
you can talk about it's basically just a
collection of interfaces so for example
if we have a text block object we can
actually assign it to a I text block
thing and this will refer to the
block parts of the text block now you
actually wouldn't want to do this and
the reason that you wouldn't want to do
this is that text block implements other
interfaces and so when you do this you
still have the whole text block object
but you can only call itex block
functions on it and you would have to
cast it to another type in order to call
functions from another interface
reference counting is automatic with
these so for example when we construct
it constructs an object that has a
reference to it already we can move it
into a local variable we can make a copy
of that local variable which we'll call
add ref and at the end of the function
both of those will go out of scope
they'll both be destroyed they'll both
call release and then the object itself
will be destroyed similarly it works
well with move semantics so in C++ you
can say stead move and so this is the
exact same example but we use move here
and after that the original block object
has no state it's moved from you
shouldn't touch it and then there's only
one reference to the block so we've
avoided an extra call through add ref
and release and we only have to call
release once at the end of the function
so as we said all of the WinRT
interfaces are derived at the API layer
from I inspectable and then I unknown
and so you can actually rely on this
inside of C++ WinRT so for example if
you have an eye storage file you can
convert it to an eye inspectable and
when you do that that will actually
cause an ADD ref because now you have
file and in both referring to the same
object similarly if you want to get the
eye unknown for it you can do the same
thing and that will be another add ref
and then when all of these go out of
scope they'll each call release and then
the text block will be destroyed
you wouldn't particularly want to do
this like as local variables because
since the file is derived from eye
inspectable you can certainly get out
all of its eye inspectable functionality
just through file but this would be
useful for example if you have a
collection of eye inspectable things or
if you have a function that takes an eye
inspectable as a parameter similarly you
can use conferences and so for example a
file is implicitly convertible into an
eye inspectable and so in this case
there's actually no add ref you the
references give you the reference
behavior that you would actually expect
so all of those have been implicit those
conversions because they're guaranteed
to work but explicit queries so for
example
down casting is not guaranteed to work
and so you actually have to call a
function order to do that and so we have
this function as so for example if we
have an I unknown and we want to convert
it to an AI inspectable we have to call
as which we'll check is this an AI
inspectable if it is then I'll give you
the you know the AI inspectable for it
it's effectively just like that dynamic
cast and each of these do query
interface under the hood the way the
query interface works is it will return
you an already a draft pointer so you
don't have to call EDF and so when each
of these goes out of scope they'll
appropriately call release and
everything is yeah just as it should be
great all right well let's look at a
concrete example in so here we have two
interfaces we have ice storage file and
ice storage item they're completely
distinct interfaces with our env tables
you'll see the methods on the left for I
storage file and on the right for I
storage item if you have a nice storage
file you can call those methods
obviously but there is a there's an
interesting relationship between them
the I storage file interface requires
our storage item now some language
projections might project that as an
inheritance relationship so in c-sharp
it'll say i storage file actually
inherits my storage item but we know by
now that all the interfaces actually
inherit from i I inspected well directly
so that isn't a physical reality it's
really an abstraction provided by the
Windows runtime so we need to somehow
model that within the projection to make
to make sense for the C++ developer
while honoring the the semantics of the
API designer had intended so for example
we look here and we have a nice storage
file which we then assigned to an AI
inspectable
so as James mentioned that's going to
introduce an address there and that
makes total sense but over here are we
going from a nice storage file to a nice
storage item and here we're getting a
query interface and it's implicit
because it's guaranteed to work in terms
of the the contract provided by the AI
storage file interface so that's
injected there for you that leads us to
the idea of implicit queries leading to
implicit methods so again we have a nice
storage file we then assign it to a nice
storage item it's implicit it will work
it'll give you a query interface call we
can call the name method on that ice
storage item and it'll simply be a
vehicle a virtual function call under
the hood
however if we try to call the name
method on the ice storage file
the compiler will inject a query in a
phrase call before that vehicle to make
sure we're actually pointing to the same
feet to the right vtable
and so we need to fix that up somehow
calling file type not file type if you
remember from the previous slide is
actually a method on the ice storage
file interface so that's just going to
work it's just going to be a vehicle and
off you go
however file type is not a method on the
ice storage item interface and there's
no relationship going the other way so
that simply won't compile the languages
prediction is not going to give you code
that is not going to work at one time
but all of the checking is done at
compile time we have the metadata and we
can do that for you so now let's look at
methods themselves and how do we
actually make that work you know at a
compile time into in terms of the
knowledge of that information and how we
can actually produce the correct and
most efficient code so here's an example
of a nice storage item interface there's
the arrow operator which returns that V
pointer that pointer to the V table for
the I storage item interface so that's
the ABI for that interface and then we
use that arrow operator within this
projected name and methods so there's
that getname method that we're calling
internally but we projecting that as a
named method that returns an age string
the virtual function will have to
somehow figure out which V pointer to
use to make that call but remember if we
actually holding on to a nice storage
file this isn't going to work because we
have the wrong V table so this almost
works and it looks pretty good but we
need a bit of extra work so what we end
up having to do is we need to add a
conversion operator for every one of
those required interfaces that's where
we get that as method that James
mentioned and that's where that query
interface call is injected then we have
to have these forwarding functions like
named over here which first calls as and
then calls name to make that work so
that works but it's not great because
you know we could have conceived of the
many required interfaces and many more
required you know methods as a result
and so the problem with this is even
though we're generating this code for
you as part of the projection it ends up
being a lot of source code that we're
generating and that isn't great in terms
of build throughput and so on so we can
do a little bit better but what we need
to do is we need to take a step back and
think about consumption and provide
what is the experience we're providing
here and we want to make sure that we
provide the same experience but both for
consuming an interface like I storage
file as well as implementing that
interface we don't want you to have to
go to you know calm or WRL to do the
implementation story so we have this
notion of consume and produce those cost
templates and then we partially
specialize them for every single one of
the interfaces in the windows API so
here's a partial specialization for
Kaseem for the I storage item interface
and you see the name if then we have the
same thing for produced so you can
naturally do that as well so we get a
sense of symmetry between the
consumption expense which you see here
as well as the implementation experience
now take careful note of the method
signatures they are identical the same
experience for regardless of how we're
looking at this so you get to call these
methods and you get to implement them in
the same way you don't have to worry
about H results exception handling it's
all taken care of for you and it works
perfectly across the ABI so in the real
world so this is the code we'd like to
have and certainly that's what I've
described described so far there happens
to be a compiler bug in Visual C++ today
which doesn't allow us to do that so the
code you might see in the feet in the
near future might look a bit more like
this we need to turn every one of those
consumed partial partial specializations
into one of these in pull classes so you
see in Pillai storage item but the same
shims are being there and it works
effectively the same way we need to
introduce a little bit more traits magic
just to bind it all together and we have
a type alias rather than a class
template but the end result is largely
the same in the future in an upcoming
update of the compiler we should see
that fixed and we can go to a simpler
model so this is now let's now focus on
the actual shims and you see here that
this should almost work so the first
thing we do is we do that static cost we
have our pointer this is in an empty
base class so we want to get to the most
derived so d stands for derived we're
going to get to the most arrived type
and so we you see our TB to do that
naturally and then we try to make a
vehicle so the problem again as you
should have gathered is that how do we
know we're actually have the right
vehicle in our hand so what we need to
do is we need to add a touch of compile
timing direction so the air gain is off
típico we get the most arrived type and
then we introduce a potentially
redundant static cost and finally we
have the vehicle so why is it redundant
the issue is that if you actually have a
nice storage item you already have the
right feed table the type of Dee's
already I storage ID and the compiler
things are you're being silly here but
that's fine we'll just get rid of that
for you however if you have a nice
storage file
that'll call that conversion operator
which will make sure you have the right
V table through which you can make that
call so this is what we really need this
is what we actually need to get this
working so the rough assembly looks
something like this you have a nice
storage file we keep the eye and we get
our ownership from AI inspectable we
then have the default experience for
that interface through our storage file
itself that's we're inheriting that
consumption experience and then we get
the required interface so we also
inherit from eye in pole or the consume
specialization in the future for eye
storage item and we have the conversion
operator so that more or less works but
again we have the problem as a lot of
these required interfaces so that's a
bit of a drag as well so what we need is
a little very attic scaffolding the
first thing we do is we use a bit of
glue to get it all working there's that
consumed type alias in the future again
that's going to be a just a consumed
class template and then we have the
require one class template which
basically inherits that API surface and
we finally use a bit of a code generator
very attic template here to actually
expand it out for you and this ends up
saving hundreds of thousands of lines of
code in the resulting projection because
we're able to do this all at compile
time so you know it's just one slide but
you know factor this out to all the
interfaces there I don't know where's
the to 9000 interfaces now the windows
API it's a fairly big deal so the end
result is something that is rather
elegant and it's easy to read a nice
storage file interface derives from my
inspectable the consumption experience
is provided by a storage file itself and
it requires these three additional
interfaces the compiler at compile time
will now thanks to the library bring
that all together and give you a single
experience that gives you access to all
those interfaces as if
were simply inherited from my storage
file pretty straightforward now what
about one time tosses James do you wanna
talk about that yeah so as we said
though you really want to be dealing
with classes most of the time and so you
know not just interfaces and so classes
actually work in exactly the same way so
here for example is the definition of
the storage file class in the projection
so you can see here that it gets its
ownership and default interface from I
storage file it then passes itself for
CRT P into that require class template
and then it says that it also implements
all of these additional interfaces which
it's specified in the metadata as
implementing so it's guaranteed that if
you have a storage file implements all
of these interfaces so let's look at how
class instances get constructed so as we
saw in the in the standard C++ example
we had all the way at the beginning we
had to call one of two things in order
to construct an instance of a class we
either had to call row activate instance
or row get activation factory and then
once we had the factory called one of
the factory functions and it works the
same way here inside of the C++ WinRT
projection so here for example we create
a file open picker by using the default
constructor and in here we call this
activate instance function template
function template which calls row
activate instance under the hood now
you'll note that activate instance takes
a type not a type name and so this makes
it a bit more convenient for you to
actually use in the in the code it makes
it more convenient for us to code
generate for and we'll show in a moment
how we do that binding from type to type
name and then we basically use a
delegating constructor to pass the
object that was constructed there into
the move constructor of the file open
picker so that we construct the file
open picker with ownership of that
object we have to do something similar
for constructors that take parameters
for these we actually have to get the
activation factory and so we have a
function called get activation factory
which we'll call row get activation
factory and it'll pass in the particular
factory interface that we know that we
need and then we'll just call create
hostname on this which will you know do
the creation return the object to us and
then again will delegate to the move
constructor and you can do all of this
yourself in your own code if you want to
so for example
here you just call activate instance and
it will construct a storage file this
will do it with the default interface I
storage file being the owning interface
similarly if you wanted to you call I
activate instance and request a specific
interface that you wanted if you wanted
to call a lot of functions on that
interface and you can go deeper still so
for example here we can get the factory
and we can call create hostname directly
on the factory so we don't need to keep
going through to get the activation
factory over and over and over again
that we'll see in a moment that there's
actually an optimization there that we
have so that that might not be as bad as
it looks and if you want to you can
actually go all the way down to the ABI
layer so for example if you have the
factory you can use the arrow instead of
the dot and you can preface the function
name with ABI underscore and with this
you're actually calling the actual ABI
function on the actual interface and so
here we have to do a little bit of
marshaling of the parameters to get the
right types we need an H string not us
not a string literal and so we construct
that but basically the point is here is
that you don't need to give up using the
projection if you want to get all the
way down to the ABI layer like you can
just pick the places where you actually
need to do that and you can get at the
layer that you need so you can write
code at whatever layer is most effective
at each point in your program so this is
to show how we actually do that binding
from the projection type to the ABI type
so we have this traits class and it
specialized for each of the windows
runtime types and interfaces so this
first example is the special
specialization for ice storage file and
you can see that it provides the ABI
type that is the actual ABI interface
type the second example is the definite
is the specialization for storage file
and here it also has the ABI type but it
also has a name function that returns
the name of the type so that we can pass
it to ro activate instance or ro get
activation factory so we can actually
construct it and so this is actually
used in the factory acquisition so that
activate instance function we actually
do not call ro activate instance instead
we actually get the activation factory
call activate instance on it
which will give you the the instance of
it and then will cast it to the
appropriate we have arrows and then
they'll cast it to the appropriate
interface the reason that we do this is
that in the get activation factory we
provide caching for the activation
factories so that we don't have to call
row get activation factory every single
time you want to construct an object so
in the Windows runtime
some objects are agile so they can be
used from any thread once you get it
some objects are not agile so you can
think of like a button is bound to the
UI thread in which it was created and so
if the activation factory for the the
type is agile then we cache it in a stat
magic static variable if it's not then
each time we'll have to go through and
query for the the activation Factory
there was one more thing we wanted to
say about this and I've forgotten oh
that sounds good yeah okay excellent
perfect I bet all this is really slow
you know because of all that overhead of
the objection you know it actually isn't
yeah let's take a look see you know it
would be enough for me if I could just
write an SD bus Boston and write the
beautiful code that I want to write but
actually we actually get performance
winds from actually switching to
standard C++ so to begin with we get the
smallest binary in practice this is an
example of the application we wrote
during the course or talk or the one I
showed to you the USTR one specifically
so all that async work all the rest of
it with C++ one or two creates an
application as a whole of 53 kilobytes
the 594 days the visual C++ libraries
c++ c x86 kilobytes and of course
c-sharp is a little bit heavier as an
MPEG as application and then there's the
dotnet framework and not the other
dependencies that it has so forgetting
about everything else you know size
really matters especially with you
within the operating system you really
want the smallest binary it does impact
performance in a big way but let's
ignore that for a moment and look at
actual performance numbers so this is
calling a static method so you know
think about what James was saying or
what we were saying about calling a
static method you have to first get the
activation factory and then you can make
that call through that interface that is
returned for those static methods we
because of the agile factor caching that
we introduced
we actually get dramatically better
performance than C++ C X now C X
actually does some caching of its own
but it this works very well if you
didn't stand in C++ as it turns out
calling required methods
similarly there when you have a method
on in here I'm sorry when you have a
method on a on a required interface it
means we need to switch V tables so we
had to do the QI getting injected there
and make that mythical again there we
have optimizations by the compiler
that'll make sure that that is very
efficient for you one more example array
so if you have an API that expects an
array as a parameter by default you can
simply post at a stood vector and we'll
make sure that no copies are created so
you get incredible performance by
default with the simplest possible code
collection that's another great example
collections are one of the hardest
things to optimize in the Windows
runtime but this is Stannis C++ and
combined with some of the smarts we've
got in the compiler and some of the work
we've done in the library we get
incredible performance and it's the best
possible option for you so just to
overview this is essentially how the
process works the windows api is
described in a set of winabi files which
is the metadata format we we use for
describing the api service we then pass
that to the c++ 20 compiler which parses
those and produces a set of header files
now these are just straightforward
standard C++ header files which you can
then hash to include into our
application there's nothing special
about them standard C++ library and then
you pass that to your favorite compiler
to produce your application of course
you could also use client that works
just as well this works with clang it's
right at standard C++ after all so it
works pretty well
does C++ C X work with clang no okay
sorry yeah but this works all right so
we have a number of optimizations which
is more reason to use Visual C++ the
first of which is the empty base losses
now it's somewhat ironic but since the
dawn of time the visual c++ compiler did
not support this optimization and it
finally does now falling it's it's part
of it in limit cases yeah yeah yeah yeah
that's true
there was some limited cases where it
did work but it turned out the way that
we do our required interfaces in the
windows in the CPP C++ one ot projection
we end up getting
many many many empty based glasses which
really aggravates this problem so the
C++ team stepped up and finally got this
working which really changed everything
for us yeah it's important to know that
that's an opt-in per type so you have to
actually annotate the type because we
can't just break the ABI yet yes so the
second one is actually an implement is
actually an optimization the compiler
has supported for a lot of time a long
time and I expect most compiler support
and that is if the compiler knows that a
string you're passing to sterlin or WCS
Len is is a string literal it will
actually just replace it with the
account so it's intrinsically known to
the compiler so you don't have to you
know worry about the function call
overhead which is relied on extensively
in the projection right yeah so many
libraries today continue to use various
template tricks to actually figure that
out of compile time but all of the major
compilers now do this so there's really
no need so this is just a little advert
for that yeah so magic status you know
so we demonstrated how we do I add all
factory cashing and that relies on magic
statics and the C++ compiler is getting
even more optimizations for that to make
it scalable in other ways in terms of
the size of the image gets reduced and
so on so it's getting better and better
this is a new optimization that Kenny
was telling me he's gotten us to
implement is we're adding the ability to
actually annotate functions as being
pure functions so if you pass in a
particular set of arguments you'll
always get the same result back now this
is extremely important for functions
like query interface which is a pure
function if you call query interface for
a particular good on a class you're
always guaranteed to get the exact same
result back the but there's no way for
the compiler to know that because the
implementation of query interface is
going to be in some other DLL which has
no chance of seeing and so this new
annotation will allow us in the
projection to actually allow the
compiler to hoist out query interface
calls so for example we had the example
where if you wanted to construct 10,000
text boxes you might want to get the
activation factory first and then in the
loop construct all of the the instances
using that factory but with this
optimization that probably will not be
necessary because the compiler will
automatically be able to
sit out because it knows that that
function will be pure yep curtain so
yeah we'll talk about this more tomorrow
but the winners one time has a deep
investment in async operations and so we
we've been heavily on kuru teens as the
way to express that most succinctly
within the projection and modules yeah
so modules will help us to substantially
so today if you include these headers
and you build your project it may take a
little bit of time to build but modules
will substantially help that and enable
us to you know provide a much better
developer experience yep yeah so with
the tomorrow for those of you who don't
know we're hosting a little mini
co-routine con we have three talks on
co-routines tomorrow at 9:00 a.m. I'll
be giving an introduction to C++ code
routines going over all of the language
details how they work in the language
how you would implement a KO routine how
would you you would use one then at 2:00
p.m. one of my colleagues Gordon a
Chernov is giving a talk C++ care
routines under the covers in which he's
going to talk about implementing care
routines and optimizing them and then
finally Kenny and I will be back on
stage to talk about putting co-routines
to work with the Windows runtime in
which is basically going to be a case
study if you will to show how we took
the co-routines feature and we used it
to make this library substantially more
awesome and you know the experience
we've had in doing that yeah so thanks
for coming uh feel free to reach out to
us and come again tomorrow we'll have a
lot more detail about that
so we are we have three minutes are
there any questions yes I can just
repeat them if that'll yes sure there
are some teams internally we're starting
to use it for various projects which
will be released in the future so
there's not there's a lot of people
using it today it hasn't been released
yet so there are no bits available today
but we hope to have something available
for you soon okay yeah so the question
was C plus well CX added language
extensions to make this easier and then
we've implemented this with no language
extensions the question is are we
planning to do something similar for a
C++ CLI and the answer there is no we
are continuing to maintain C++ CLI it's
obviously a very important you know
thing that many people rely on but we're
not we're not doing new innovations
there and they're given the extreme
differences between the the dotnet type
system and the the C++ type system you'd
have a hard time I don't if you remember
the original managed C++ extensions you
know tried to be a little C++ ish like
they still use pointers stars for
pointers and it was not having done some
development there it was not a fun
experience so I think C++ CLI is
probably the best you can get for doing
mixed C++ net development
is this considered to be a replacement
for c++ CX
we're going to continue to maintain C++
CX and this is intended to be better
we're hoping that it becomes really
popular and that when we ship it it's
going to be awesome and effectively
we're you know we're just gonna have to
see what happens I mean let me rephrase
we're just gonna have to see how people
you know what people like sure it works
with today it works with everything from
the Windows Update with anniversary
update so that's sort of what we're
targeting so Windows 10 anniversary
update and beyond I mean it's been
running for a long time already on
earlier versions but that's sort of what
we're thinking of supporting well as we
said with the optimization slide we the
main blocker for us was the MT based
optimization so a visual c++ update to
was the point at which we can officially
say yes it's working there are there
additional optimizations coming in the
in an upcoming version of Visual C++ but
certainly it works today and because it
is a header only library it's not you're
not tied to any specific compiler in the
same way you might with CX but you like
Visual Studio versions of Visual C++
prior to 2015 would not work right
because of that great thing yeah it's
update to and beyond alright one last
question
okay so there's two questions there the
first is what about the compiler and the
signaling is with classic comm and
DirectX yeah so in terms of the compiler
we spoke about the C++ 1 or T compiler
that takes the metadata and produces the
header files yes we do plan to release
that hopefully soon we don't have a
schedule for that but yes there the plan
is to release that so that you can take
your own one of these for your own
components and produce your own hitter's
you're not dependent on us doing that
for you classic comes a little harder
because there's no metadata there the
classic on AP eyes are defined in all
arbitrary ways and so it's a little
harder to solve that problem in a sort
of general way this so the windows
runtime really gives us the solution to
that problem which is giving us the
metadata that fully describes those
types awesome if you guys have we're
being told we're done so if you have any
questions feel free to find us anytime
today after conference whenever yeah
thank you for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>