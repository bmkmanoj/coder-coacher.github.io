<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Robert Ramey “C++, Abstract Algebra and Practical Applications&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Robert Ramey “C++, Abstract Algebra and Practical Applications&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Robert Ramey “C++, Abstract Algebra and Practical Applications&quot;</b></h2><h5 class="post__date">2016-10-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/632a-DMM5J0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Robert Ramey and the title
first of all I'd like to thank you for
coming the title of my presentation is
C++ abstract algebra and applications
I've been a active member of boost since
2003 I'm my claim to fame and boost is
large part the boost serialization
library I'm in the designer maintainer
of the booths library incubator and
those are that's how I spend my time is
related to C++ that other people would
know about so I'm here to talk about C++
abstract algebra and applications let's
look at just a simple program here how
can this thing fail that's okay
interesting I have to be able to see it
so this is a trivial trivial program
it's it's a one-liner so it's it's it's
hard to imagine how somebody could make
a mistake with this program and yet it
happens all the time somebody might have
fed in values for L and W length and
width if somebody had chosen one that's
a negative value then the product of
those is going to be a negative value
and you can't have a perimeter of a
rectangle which is negative value you've
got it could be if somebody fed you a
value which is not a floating-point
number an an then the result is going to
be in there it could be that somebody
fed you values or this is part of a
subroutine that takes arguments and one
of the arguments is in meters and the
others in feet so you're thinking well
that's kind of beyond our scope I'm
going to argue number one that it isn't
and that we do have
we can we do have methods that can
address these kinds of errors I also
believe that many of our what we call
our debugging situations are not really
arcane issues like we got our matrix
inversion wrong often times many times
they are have their origin and questions
exactly like this so the question is how
can we as programmers make progress on
this so first I'm going to there we go
talk a little bit about what it means
for a correct program there's academic
definitions and there's been a lot of
discussion about it I'm not gonna get
there quite yet I'm going to talk about
what happens when you program an ABS
system and somebody gets killed with it
I'm talking about when you talk to your
boss and then you deliver the product
and it doesn't work the way he thought
it was gonna work in that sense the
program is incorrect and I've defined a
couple different levels and starting
level zero it's does the thing really do
what everybody agrees it should do and
I've given a couple examples a heart
pacemaker has to keep some guy's heart
beating and f-35 fliter a fighter jet
has to shout to the pilot if he's in the
stall there's all sort of these this is
really a criteria whether the program is
is working or not and proof at this
level means that there has to be an
agreement ahead of time what the thing
is supposed to do it's amazingly common
that we start work and we don't discover
until we're 60 or 70 percent through
that actually we weren't on the same
page as far as well what it what it
takes to call the thing working
and it's extremely common it's so common
that people don't even realize they're
doing it they call it the it's a
programmer level they say they change
the spec on me and at the management
level they say they're a bunch of yo-yos
but what it really means is we got
started before we're gonna really decide
what we're gonna do this is not a
mathematical question but hopefully if
you if you can get that squirt away or
if you think about that next time you
talk with some higher-up
or at least somebody has paid more than
you that about what the job is you can
get past that and get a succinctly take
the description that you're that that
you've been given or you've agreed upon
and cast it into some sort of formal
model if you're in a finance environment
you might talk in terms of an accounting
system debits credits balances reports
etc that are based on this that's that's
really kind of a language if you're in
the engineering world you might talk in
terms of differential equations or
solving for differential equations or
approximating functions or whatever you
have a language you're not even to the
computer programming part yet you're
really working with a formal model of
the phenomenon which you've been started
with and and as I say this goes beyond
math it goes for example if if you're
working in a place like a place that's
making tax preparation software you're
going to have some some model or some
description of the tax code in some
formal way that you can actually talk
about it and that you can actually turn
that into some sort of computer program
might be a list of rules it might be
just list of rules in your own native
language but are restricted to a set
that resolves the ambiguity if you start
programming without that then you of
course you will be in a cycle because
you again you'll be in the situation
that you'll program something and we
won't be agreeing on what it is but
we're actually quite familiar with this
and this
usually the case in the scientific area
this is very very well known we know how
we get code that inverts matrices and
solves differential equations and this
is the the algorithms can be pretty
complex but they're all agreed upon at
the next level we we take that formal
model and we turn it into an
approximation of the formal model for
example if we're looking at an
engineering problem we describe it in
differential equations limits real
numbers things like that in our
computers we don't have real numbers we
have floating-point numbers but they're
really only not only an approximation to
real numbers the whole area of numerical
analysis addresses this problem that
when we actually try to use these
approximations to a real number we get
things like roundoff error error
accumulation and precision evaporating
and there's a whole branch of applied
mathematics which is numerical analysis
which is dresses this I'm sure I'd have
to think about a little bit more but
well in the in the accounting field I'm
sure that somebody's made an accounting
system and they determined that well you
know a billion dollars is going to be
enough and wait a minute of course since
we're suffering from at least a thousand
years of chronic inflation they
eventually get it wrong so they're
mathematic or they're computerized model
is that a variance with the reality and
it eventually may come up and I'm sure
that this we could find similar
situations for the other examples that I
gave so at this level if we want to get
a correct program it's we're going to
have to generate an approximation to our
formal model which actually actually
reflects that formula
and I'm going to argue that it has to be
able to detect when our informal model
breaks down if we want our program to
correct to be really correct it has to
think like detect overflows that's
nothing wrong with it that's nothing
related to the base algorithm that's our
computer implementation and so are we
can't really consider our program
correct if some guy pulls a stick on his
fighter jet and nothing happens you can
say well hey it overflowed not my
problem it is our problem so in the
final level
I say program code and program code is
basically he write the code and I'll be
damned you can write the code you think
understand the problem you think you
understand the formal model you you you
you take into account the the the
realities and vagaries of computer
hardware and you still make a mistake
you might put parentheses in the wrong
place you might implicitly promote one
variable from one type to another you
might do all sorts of things of that
nature
and it's easy to say that it's your
responsibility to know enough not to do
that it's extremely easy to do we do it
all the time and a large part of our
debugging effort is also spent on
chasing down almost trivially trivial
area errors of that nature so if we want
to get a correct program we we've got a
big job here so the history of program
correctness really I in my view started
with a paper written by Anthony Harr
called I'm gonna straight is anyone how
you wouldn't really pronounce that guy's
last name to avoid creating some sort of
scandal okay I call him Anthony horror
and the idea was to take the techniques
of program proving in a
applying them to create a provably
correct computer program this was a
hugely popular idea it's probably
spawned a thousand papers it spawned
things like go to considered harmful it
spawned structured programming it's
spawned designed by contract and so it's
been tremendously influential to this
day it's not really disputed as as the
way to think about approval II correct
program and let's just take a look at
and the way this works is he defined I'm
not going to go through this in detail
because you could do it on your own and
I don't have time and I think that I'll
give you just enough and what he did was
he describes certain logical rules about
that how a program changes the the
situation of the program State and I'm
gonna just describe one rule and that is
composition and what he said here let me
I can't see the slide here is this rule
basically says if I have two statements
which are correct if I compose them
together then they'll still be correct
and he formalized that idea by the first
statement we start with a certain
proposition which is true we execute a
statement to one and then that results
in a result a new proposition which is
true so for example if I say a plus B
equals C then I know that a and B is is
a valid are valid arguments if I add
those together and get a result then
that will also be a valid result and he
said okay and if I take a number X and
multiply and then the second proposition
might be something like if I take a
value like X and multiply it by 4 and
then X is a valid number the product
will be a valid number so if I compose
those two statements in
to multiply a plus B times four then by
this line of reasoning then I will
guarantee that the final result will be
correct so what he's done is to say I
make up a logic rule and if I apply it
to demonstrably or provably correct
propositions the result will also create
a new fact and that fact will be a new
proposition that I can use subsequently
in the program now that's kind of a
crude explanation because I'm not a
mathematician I'm kind of a crude guy
but I think that we can see that how
what this this idea is how we sort of
already applied intuitively and how this
could be built upon and expanded to
cover a much an arbitrarily large
program he's in the original paper which
in my view is still the best on the
subject he stated I think either four or
five rules one was composition that's
this one another one is assignment he
did do one on iteration and then there
was some other one and if you're
interested when you get the slides you
can look through it but it's basically
this is pretty much all there is to the
method and there's a couple things that
come out of this program correctness and
the program itself are not the same
thing or what I mean to say is program
proof and the program are not the same
thing in the literature there seems to
be the idea sometimes that if we write
the proof then we can turn it into a
program in a mechanical way and I don't
believe that's the case there's some
kinds of proofs that definitely can't be
done a proof by contradiction can't be
turned into a computer program to
generate a result you would you'd have
to live and limit yourself to
constructive proofs in any case what we
see here is we don't really see the
progression of the proof we do see
progression of proof but it's in
parallel
to the expressions were executing so
we're generating results on one side of
the tea and we're putting the
justifications on the right side of the
tea
there are different things and they it's
better to not get them confused so now
once you've got this idea and we've got
in C++ the concept of subroutines or
functions and if you have a provably
correct function module then of course
that's really a long composition so now
you have what really is analogous in the
math world to a theorem where see if you
start with some true propositions you
invoke the function you get a result
which you know has got to be true and
when you use that in some other level
then you can look at that level just at
that level without having to go back and
check this other one because you know
either you or somebody else has proved
it this is the idea the idea is
basically sound in I'm gonna say in
theory but that's a little unfair the
ideas is described as quite sound it
also does one great thing it changes our
thinking from what they call
operationally to to logically in the
sense I'm not really thinking once I do
this I'm I'm not really thinking about
all the details of how the result has
produced once I've once I've
encapsulated that I'm really thinking it
is just a single transformation and I
can abstract away a lot of the detail of
my program in his examples that he used
he only addressed immutable functions in
this particular paper he and that might
not be quite true but it's it's almost
true and he so he kind of failed to
address a lot of the things the problems
that we create for ourselves these days
so in in his world or the world
described in this paper we're mostly
making functions which start out with a
value go to the end producer produce a
value and they don't have any side
effects
our outside influences and things of
that nature
this subsequent to this paper other
papers expanded upon this to make it
more widely applicable but it's still
basically a variation on the same idea
we don't have to go you one if one has
nothing else to do he could track this
down and spend a lot of time doing it
but I don't think it would be that all
that productive so it says so let's go
back and look at our original example so
here's our program that we've attempted
we're C++ programmers we're attempting
to take hores idea and realize it in
terms of the tools that we have at our
disposal well I made a function I called
it perimeter oh okay and so we start out
with the two values L and W well right
away we we verify that the the
proposition that we want to start with
is that these are values that actually
reflect our idea about what length is
this means that they have to be valid
floating-point numbers and they have to
be numbers that are not negative so we
apply that to the first one to the
length value and apply it to the to the
width value and then the actual
perimeter calculation we don't have to
do anything
because that's actually the definition
the mathematical or geometrical
definition of perimeter that if we start
with valid length and valid width and we
apply this formula that there's no that
that's since where we can then plug in a
mathematical definition we know it's
correct by definition we assign that to
the perimeter but now in order to to
verify that that our computer didn't
fail mathematically that's never going
to fail
but remember we're working in the real
world we're not working in the in the
horror world where he just talks about
the the values he doesn't consider
things like overflow and stuff like that
but we're gonna expand and broaden our
criteria for a correct program so at
that point the final result we want to
verify we know it can't be negative
because that's the way our hard work
works but it is possible for it to
overflow so then we would have to check
this so now we would have a function
that we have or I would submit we've we
proved that it produces a correct result
so let me take a drink of water did I
did I make the slide wrong now that's
actually a really good point and I'm
sure I made a mistake but you caught it
just by looking at the code that's what
it's all about here I'm trying to write
code that is visibly and demonstrably
correct by looking at it so I guess
you're backing me up here huh well it
was it not just a comment ah yeah so
you're correct but what compiler would
have caught that that's good but anyway
certainly that wasn't my intention but
anyway well now I believe that the
floating point the infinity is a
particular type of man but you might
correct me if I'm wrong no it is okay
it's not a number but it's invalid
number is that is that changed since
1970
yeah okay well there you go
now that's kind of an interesting side
issue as well by actually making our
propositions visible in this way it
becomes clear that I have a mistake here
which normally wouldn't occur all right
now this theory or this idea got caught
on Big Time in the whole academic world
and they flogged it for many years
without much success for people like us
and to the point where the academicians
got pretty frustrated with us I'll let
you read this for yourself I don't have
anything to say for it except it didn't
help me much so we're not on the same
page here right guys that's that's the
source of our problem they have a good
idea but you know for whatever would I
try to apply it it's it's not gonna work
out and we can see from the previous
example that if we coated everything
like that we would never accomplish
anything so now we're in this quandary
we're writing code that we know can't be
Crower we know is likely got a lot of
bugs in it it's just a matter of fact I
couldn't even write the code according
to the prescription here without putting
a couple bugs in it so anyway that's
where our bugs come from that's one of
the places where our bugs come from
so eventually and this was in nineteen
nineteen eighty-five ish somebody came
up our Bertrand Maher specifically tried
to throw us a bone and he I don't know
if he would see it this way but in my
view it's it's a direct descendant of
the horror proof concept where you start
out with initial propositions you as you
proceed
through the execution the program you
develop a new set of true propositions
which can be used subsequently and then
finally you know that at the very end
you end up with a a true result and the
this turns out in the C++ world to be
the assert statement and we've got it in
the standard and people use it people
don't use it it in order to get over our
complaint that this takes - this is - to
intensive cost too much resources
executive execu
define this in such a way that these
checks are only done at on a debug
release and not on a release release
so this was a compromise okay we're
going to give you the method to prove
that your functions are correct and
since you're complaining about the
performance or we're gonna suppress them
when you release the code well you know
that wasn't a bad compromise it was only
realistic thing to do if you wanted to
get some program correctness but still
for whatever reason I think it had some
success I don't know I've never I'm a
freelance programmer I've never walked
into a company where I saw them use
designed by contract but there may be
may be some out there so but now it's
nineteen twenty sixteen we can we can do
better we have C++ and we can address
some of the issues associated with
trying to make a correct program one
problem with the Bertrand Meyer approach
are the design by contract and actually
the horror one as well was that every
time we call a function we'd be
repeating the same checks on the same
parameters if we factor it out a
function or a split it or divided into a
couple then we end up doing all the
checks all over again on the next
functions the next level down and so
the better code we make the better we
factor our code the slower it's going to
be and this is kind of unattractive but
C++ gives us the tool of the type system
so when I can define a length type
before I was using floats but I'm going
to define here a length type and that I
think it's pretty apparent what this
does
once I initialize it it's guaranteed to
be correct I've it's generally not used
in such a way there are no functions
here which can mutate it so anytime that
I create a length then I know at that
front when I use that I don't have to do
any precondition checking because it's
all checked and it can't change so when
I go when I then start using this let's
have a look here ah and we got an extra
bonus to these days we can use the Const
expert functionality so it gets all done
at compile time so where we have a zero
runtime overhead proof that this vet
contains a valid number if we insert a
literal it's going to be all checked at
compile time it's zero run time cost if
we use if we in if we create this thing
at execution time this particular
instance needs to be only checked when
it's created henceforth and forevermore
it never has to be checked again because
it fits our concept or idea about what a
length is so now what happens when we
look at our our program again the we're
given a rectangle with the dimensions
lnw
this time it's passing arguments of type
length it could be constant references
they could be values it doesn't matter
preconditions well we don't really need
any because we know that the values
we're passing are correct because the
way we define them and the way we
constructed them the
the actual calculation we don't we know
is correct by definition I did have to
factor it sir express it slightly
differently because the original length
type that I created only to find one
operator and that was the plus operator
so I can't multiply a length by anything
which is probably a good thing because
if I'm multiplying two lengths in the
idea that I'm going to get in another
length I'm probably making a mistake
somewhere
I've restricted the the legal operations
to those that I know I'm intending to
have four lengths to have in this
context so if I just write by accident I
mistakenly put an asterisk instead of a
plus sign
whoops gonna get a compile time error
there too so and then I return the
perimeter now the sum creates when I
when I do the addition there of the L
plus L plus W plus W that that returns a
new sum and the the function that
creates that some checks its result so I
know that the result of that is is
actually a legal length and then when
it's copied over or assigned to a
perimeter it doesn't have to be checked
the assignment operator doesn't have to
do any checking because it only works
with a length an instance of type length
which is already known to be correct
so anybody like to ask a question about
that because that that that's that's
quite a mouthful yes short could because
the context Bert is kind of how should I
say if I I can if I use context / then
everything it calls has to be context
birth and this I could just as well make
context for because it depends only on
one thing or actually two things the the
length constructor
which I can make Const exper and this
arithmetic operation which actually have
the syntax might different I might have
to put content context / before it and
then I probably have to put context / on
my parameter function but I mean that's
good thinking then you're seeing well
since we know we're gonna exploit the
immutability and the restrictions we've
we placed upon ourselves in order to to
get more free stuff okay so this is this
is the thrust of in my view the modern
situation towards program correctness I
think if we use C++ and we think about
our types and that's what I'm going to
talk about now we can use our type
system to to make progress towards
proving our programs correct
all right so here is our I'm gonna make
an identification here we have our C++
type length which we defined but we can
look at this and we can step back a
little bit and look at this in a
slightly broader way or I'll put a
different way if one of us was a
mathematician which is probably not the
case except for maybe a couple unusual
examples there there you go I rest my
case they would think in terms of length
is not a C++ data type because they
don't understand C++ another exception
of course but they would say well wait a
minute as the this concept that you've
designed is really a set of legal values
you've designed an idea which you call
length and really what it corresponds to
it's a set of legal values which are
real numbers and which are not negative
and that's a legal length if you if
you're talking about lengths on the
planet Earth they might say well but the
length has a it's the Li the real
numbers between two ranges or whatever
but for now we'll just we'll just see
the
fact that a C++ datatype corresponds to
a set of values that value is all the
the the possible instantiation of our
C++ type so when you're write a C++ type
you're actually writing a statement out
of set theory about and you're defining
a set of values and the values is that
set of values is all the values that
your C++ type can can take on so that's
pretty much all there is about that work
every time we create a type we're
creating a set of some sort
now I'm there's an as a rabbit hole I
could go down to it which is really
interesting which I'm not going to do is
what happens when you in have composed
types and things like that
that's for really another discussion so
before anybody asks that which probably
won't happen that we're gonna focus on
just one narrow aspect of what this
means so I'll go over here this time I
have to go over here because my machine
shows my notes it doesn't show this so
we've got the concept of a set our
length we also have another thing we
have the concept of addition of two
members of that set to create a third we
create we've added a our far plus
function takes any two values of length
adds them together and produces a third
one this is a binary function it it
takes well I just described what it does
and it's it turns out that when you have
a set unified or paired with an
operation such as this this binary
operation which returns a value of the
same type that constitutes a well-known
structure from the air branch of
mathematics called abstract algebra and
the it turns out that mathematicians
have taken the idea of a combination of
a
and operation and decided well that's a
mathematical entity and I can say
something about that in a general way
whether it's the operation is plus
whether the set is the number of atom is
the number of different people in the
world or whatever there are certain
things I can say about that and it leads
to a whole interesting area of
mathematics which we're not going to go
into here but it's still it's still
interesting so but for our peep for us
in the real world we're going to confine
ourselves to relatively small subsets we
start with a set it conclude a plus
function and that becomes what they call
a semi group
and it's a semi group because the
function is associative even that I'm
not going to touch upon here because I
don't want to get bogged down but in any
case if if you start with a set and you
add a function to it then you get a semi
group if you say besides that group
besides that we're going to add an
identity function the concept of a zero
so that a plus 0 is equal to a not every
set has that property if you take zip
codes well there's no concept of a zero
zip code or there's no concept of even
adding zip codes so zip codes would stop
here at being a set another operation is
the inverse so if I take for example
prices and I have a price list on my
menu menu is not a good example let's
just say a price list in the supermarket
I've got apples oranges those constitute
a set of values of prices I can't add
two prices together and get anything
meaningful so if I made a type 4 prices
I wouldn't include the addition
operation but on the other hand somebody
comes along wait wait a minute here
price not really what I want I want I
want accounting values so you can have
a debit or a debit balance and you can
add zero to it I mean somebody could
have a transaction where you give
something for free and they they debit
your account zero and then the value
stays the same so a an accounting world
this would if you follow the the tree
down here you'd start out with a set
which a set of values you would say it
has the concept of an addition operator
so it's at least a semigroup then you go
down and say ah it has an identity value
because you have a zero and oh by the
way it has an inverse operator because
you can taste somebody could say you
know you don't have a you don't have a
positive balance you have a credit
balance on our books so you've got a
negative value now when you learn this
in school about math they talk in terms
of real numbers and all of that that's
not bad in a sense it's simpler but the
reason I'm talking about using the
examples I'm using is to relate it about
stuff that we're doing every day so if
you're working in a financial industry
or something like this and you're
creating a somebody's balance well one
thing you probably don't want is to
multiply two balances together because
all of a sudden we're outside the realm
of what what we're talking about we're
doing an operation which isn't defined
for balances for accounting balances
they're both numbers so if I tried to
explain it in terms of numbers you can
get really confusing to say well some
numbers you can add but other numbers
you hear it well let's think about what
we're really talking about and now you
can already kind of see or hopefully you
can see how this impacts upon the
concept of your your correct program you
get something it starts to get fairly
complicated and you start throwing these
formulas all around and it's extremely
easy to get confused and scale something
wrong or do some an operation that
doesn't make sense
instead of writing the expression seeing
if it compiles moving along and then
wait until wait until the company paid
out 100 billion dollars we're gonna say
no we're going to
ahead of time what everything we're
going to restrict the operations it's
only that which makes sense so the
minute we try we accidentally break a
rule we're going to catch it right on
the spot now this happens it all
compile-time in C++ so it's free no
audience reaction from that I guess I'll
take that as a good idea then yeah huh
it's you know yeah I'm wondering if it
sounds like when I explained it it seems
so obvious maybe it does well that would
be a surprise to me
correct but remember if we're doing if
we have our type which is implemented in
terms of floating point it will crack it
will check the error either at the first
or second addition in in the example
that I wrote for the length it doesn't
if if you break the rules doesn't return
any value at all it throws an interrupt
so now that's you touched on an
extremely interesting point
I'm not going it much into that here but
what I've defined all the a valid
operations so that at any point that
becomes invalid the the program bails
with an exception so I've kind of
skirted the issue on the one you just
described but now you provoked me and
I'm going to talk just a little bit
about that if I have a zip code class
well ahead we can also imagine what a
legal zip code class is going to look
like it's going to have an integer and
it's going to have some form of every
time we initialize it with an integer or
create a new instance of it's gonna
check the list of legal zip codes right
we're all going to do that and now all
of a sudden somebody comes along and
says hey wait a minute guys you've
really dropped the ball you're requiring
a legal zip code here we
sure we are because we want to sort it
and this intends and who know but some
people come in here and they're from
foreign countries or they fill out the
form and they don't that we it's
illegible so then we say oh no okay well
we're gonna fix that we're going to
create of our zip code is going to be a
variant and the variant is going to say
illegible or foreign country or a legal
zip code but now when you define the
plus operation you have to really think
about what the heck we're gonna do when
somebody tries to compare a legal zip
code against one of these other things
maybe we decide you know that's that's
wrong I mean there's no way we can
recover from that indicate somebody
dropped the ball somewhere so we're
gonna stop there and we're gonna throw
an exception right there we won't even
permit the thing to be sorted when they
when you invoke so it's not going to be
an ordered set so then we're then we're
then we're bringing our our whole
discussion back to the framework of
abstract algebra instead of having an
argument about what's supposed to happen
I mean it's not a it's a it's it's not a
specialized arc it's more of a general
argument how are we going to handle
things that don't make sense because
here we built in the concept of what it
makes sense for zip code so but you you
hit a very interesting point is I've
defined my operation they're gonna bail
anytime it's invalid but you can also
define them in such a way for example a
floating-point number you can add to
Nan's and depending on the compiler
Flags you won't get any interrupts and
you can say actually it's invalid it's
it's valid to have an an as a result
and then you can create your algebra in
that basis but you won't get the benefit
I'm hoping to promote here because then
you'll have to check it every time but
it's a decision you can make and you'll
be able to make it consciously instead
of on an ad-hoc basis all over the
program because we have the checking in
one spot or we don't have the checking
in that spot and everything will be
consistent and it will be thought out in
terms of what it really means if you
prevent Nan's will Raymond it can't be
ordered
anymore because or what does an an is an
Ana value we don't know or is it a value
that's the result of some invalid
operation you have to think about that
any case all right I got carried away
sorry about that
all right so our type length if we
really fill it out and if we want to
make our type length fulfill the
requirements of that the the the
semigroup demands it needs to support
the Equality operator it needs to
support the plus operator and I've also
added another requirement which is
really outside the scope of abstract
algebra itself of the set being ordered
in order to support that it should
support the the for C++ operators for
comfort comparison so that's what our
length would look like if we flushed it
out and we'd be in business yes so the
question is when I make a when I make my
new type and I want to verify that it
fulfills one of the nodes on that tree
of valid objects then I created a header
file which has some types traits to find
in it and verifies the existence of
these operators so it's if it's equality
comparable verifies the existence of the
equal and not equal operator the is less
say oh let's take another one is
additive it verifies the existence of
the addition operator so if I want to
make my type and fill it out and then
verify that it fulfills or it has the
operator or if I include a function and
I want to include a precondition saying
AHA this function really
only makes sense if you're calling it
with a type which models a Mon oyd then
it should support the identity operator
and you can put a static assert right
there and verify and prove that your
function is being called with a correct
parameter at compile time so that's one
more way we can put more information in
our program to verify that the function
the parameters being passed or actually
fulfilling the requirements we
anticipate but that's still slightly
annoying because I wanted something that
was just slightly better and I can I can
construct very simply with a c++ 11 or
whatever it is
alias to say i've defined an ordered set
if the following two type trades are
true so i basically can say an ordered
set is any type which is both equality
comparable and is ordered so now i have
a new concept which i've defined or a
new type rate which is an ordered set
and i've easily defined it this way it's
just an alias and it's it it's it's
exactly what i want in order to get what
i want next
so this same header algebra then now can
if i'd make a type and i want to say i
wanted to model a mono
well all i have to do is include a
static assert in there and said is it if
it's say additive mono it is león if I
put is added to my enoyed length and in
a static assert that static assert will
pass and will not will not trip a
compile time if I overlooked one of the
key functions for example if I were to
overlook the the plus function the
addition function then I would get a
compile time error right at that point
so we have a mechanism now to recap a
little bit the theory is we have
way of proving programs which is
impractical
we now have tried to make that practical
by including the checking in the types
we tried to regularize our type creation
by borrowing from the concepts of
abstract algebra we've added then type
traits that we can use to verify in
compiled time that our types actually do
model those concepts that's where we are
now and that's how we got here
so still our length is let's have a look
here
hi-yah here's our length and it's still
a little bit of a pain to specify all
those functions so we're gonna make it
easier by using a little template
metaprogramming and the the what's it
called commonly recurring curiously
return we recurring template pattern and
those of you who can say this better
will recognize it right here and I only
have to define some basic operations and
I will derive I can do I can use private
duration derivation to derive from the
additive Mahanoy to of the length and
the the ordered implementation and so if
I even though my type it's it starts to
kind of elaborate it's also would be a
source of error for one to try and
specify all the functions for the length
type when they're actually all related
to each other here in this case what you
would do is you just have you just
define the less than and then this class
will generate for you the definitions of
the less than or equal the greater than
and the greater than or equal etcetera
so this is a convenience to eliminate
the tedium in the source of error of
creating types to model any of these
concepts or any of these nodes on this
tree of algebraic
of abstract algebra types so all right
so actually I kind of jumped ahead and I
kind of summarize where we work because
I was afraid I was gonna run out of time
but fortunately that seems like it's not
going to happen I propose that this
method of using our types to implement
these ideas will detect conceptual
errors much much sooner than we normally
do
I believe it's easy to include this
information when we build our program
including this information we build our
program requires us to discuss among the
other parties exactly what our types are
really going to do rather than waiting
for us to code it and for the program to
crash it implement and I also contend
that it implements program proof in a
practical reasonable in a practical way
that has relatively little or no either
no or reasonable impact on the execution
time I and of course the diba diminish
this debug time and I also believe that
a deep it diminishes maintenance effort
by a huge amount when somebody else in
goes and makes a change the original
assumptions are already all checked in
there by static asserts and so that's my
theory here and I'm gonna say one other
thing that this has only scratched the
surface of what I believe that this can
do
I had to fit it into an hour this
extends to other aspects of C++ which I
have not addressed here in in and in in
a more powerful and useful way than this
and that's all I'm gonna say I'm working
on a book on the subject which hopefully
will come out next year and this is just
one small part a part of it and I think
that sums it up and I'm really happy to
see so many people here and I'm
available for questions if anybody has
something to ask yes sir
speak up please what do you mean by unit
aha
that's actually it's interesting you
mentioned that that was a subject which
was addressed oh yeah
the question is how does this relate to
the concept of dimensional analysis and
units that's right now a separate boost
library Barton &amp;amp; Nachman who wrote the
book that inspired me on this and this
was written in 1995 ish I believe they
had a section on this it is related but
it's kind of it's related in a way
that's slightly and obvious so I don't
feel comfortable answering the question
right now but you are correct in that
they're wrestling with the same problem
here and in fact we haven't touched upon
what happens when you want to create an
area where you need to multiply two
lengths well that doesn't fit into the
abstract algebra scheme but it does fit
into the mathematics that deal with it
so this would have to be extended a
little bit to address that but that's a
very good point this is the boost units
library it's a I gave a talk on it last
year it's a it's incredible piece of
work and it's totally inscrutable so
it's a two-edged sword
it makes your program rock-solid but
it's it's agony to figure out how to use
it right any other question yes the
question is
let's suppose we overlooked the required
operation of plus and in expected the
the code to generate our missing
operators and the question is would that
provide a warning no it wouldn't it
would actually stop the compiled and
provided with a compile time error
because it refers to a function which
should be member of the class and
doesn't is not there so it could not be
resolved bingo not only do you get an
error you probably get 50 lines error
messages to help you out yes Tim I I
maintain that it can it's hard to
demonstrate in this forum but there's a
couple things that very much relate oh
the question is with is this really
applicable to really worl world complex
situation is that is that a fair
rendition yeah I maintain that it is I
maintain a lot of take cases we're
actually kind of doing it by accident
already resource acquisition is
initialization is really a similar idea
in lots of ways and we like that idea
it's just not related to abstract
algebra so it's kind of like ad hoc on a
case-by-case basis but the idea of
making provably correct demonstrably
correct variables that can't be changed
is in matter of fact that's even invoke
the idea of immutable types is now a
very popular idea which people are
exploring in immutable functions also
for the same reason and so if we start
it this really encourages you to
thinking like this to factor your code
into mostly immutable immutable types in
which case like most your problems go
away and then we're in the C world we're
not in a Haskell world we're probably
gonna have mutable types somewhere but
we're not going to have them all over
the place because this kind of this kind
of thinking kind of discourages you from
doing that I don't know if that's a good
answer but that's the answer you're
getting tells me the session is over I'm
gonna there's no more questions it looks
like so I guess we just perfectly in
sync I thank you everybody for coming
and I hope you enjoy my talk</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>