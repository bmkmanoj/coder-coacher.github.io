<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Bjarne Stroustrup “Learning and Teaching Modern C++” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Bjarne Stroustrup “Learning and Teaching Modern C++” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Bjarne Stroustrup “Learning and Teaching Modern C++”</b></h2><h5 class="post__date">2017-09-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fX2W3nNjJIo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- I want to get to introducing
our opening keynote speaker.
I want to say just a few words about him.
A lot of you know that Bjarne
is the guy that created
C++ but what a lot of people
don't know is that he is very
very interested in education.
When he left his position
as a corporate researcher
to become an academic researcher
he also took on the
responsibility of educating
undergraduate engineers in how to program.
Not in how to program in C++
but how to program using C++
and he took those insights
and those lessons learned
and turned them into a very
very successful textbook,
again, on how to program
using C++ but how to program.
And so I think that when
we think about our role
as engineers on a day to
day basis, we spend some
of our time as students and
some of our time as teachers.
And if we are going to
be successful engineers,
we are going to be successful
as students and successful
as teachers and so I'm very
interested and very excited
to hear what Bjarne has to say.
I did say, however, that I
have a special announcement
for you today and I want
to put that in, I forgot
to cover that, we'll be
announcing a lot of winners.
I will announce the SCM challenge winners.
We're gonna announce the
Microsoft drawing winner
and the poster competition winners.
There's another winner I'm
going to announce right now.
This is announced today.
It's not us, it's the Institute
of Engineering Technology.
Engineering and Technology.
This is the oldest professional
engineering society
in the UK, possibly in the entire world.
And they've announced today
their Faraday award winner.
The Faraday award is the
most prestigious award
that they give from the oldest
professional engineering
society, previous winners
have included Maurice Wilkes,
Tony Hoare, Roger Needham, Donald Knuth.
Today they've announced the 2017 winner,
who's Bjarne Stroustrup.
(audience claps)
So we thought we'd ask him to
come up and say a few words.
- Thanks, thanks, thanks, thanks.
Very honored about that
award and very pleased.
If you read the list of people
who have gotten that award,
mostly they are not computer scientists.
You see it's downright intimidating.
Let's see.
Am I pumping bits here?
Ah, yes.
So when I was asked to
give this opening keynote,
which I've done before,
so I had a problem.
It is what can I talk about?
That is important to most of us,
and that I know something about
and that we haven't heard a
million times at this conference
Most of the time, we do what we always do.
We do the reasonable rational thing.
We don't fight any fights
that can be avoided
because we're busy.
This is the way the world gets stuck
and no progress happens,
so I picked this quote
from George Bernard Shaw.
About how you have to do
unreasonable things sometimes.
And that's what lies behind
a lot of what I'm going to
say here, I mean, what should
we do, what's not right
and what can we do to fix it?
This is in my opinion an
immensely practical talk.
And basically, I'm going
to talk a little bit about
teaching programming and
then I'm going to go into
something slightly more technical, not
teaching technical, not how
you organize a classroom or
whether you, what particular
tools you use to grade
your students or find
cheaters or things like that,
none of that, that's not
what I'm talking about.
This is not really an education forum.
This is a forum of professionals,
people who develop stuff
with a few teachers sprinkled around.
So, then I'm going to go into some details
about what we teach as
opposed to how we do it.
And we're all teachers,
and we have some fundamental questions
which is what do we teach and why?
Well, what is it we want to
achieve and who do we teach
and how?
Those are key questions
and we're all students.
The world is moving on.
It's moving very, very fast.
It's moving too fast for any
of us to keep up on everything
and so ...
We have to be students,
basically all the time,
at least a little bit of
the time all the time,
otherwise we fall behind,
and then we become
part of the problem and
it's a huge problem.
If you've ever had a piece
of 20 year old code dumped
on you and had to look
at this horrible mess
of say, overgrown
illogical class hierarchies
littered with ...
memory leaks and ...
pointer spaghetti and such,
you can usually thank
some teacher somewhere.
They don't get it right all the time
and if you've ever
gotten people in from ...
a university, good university course
and they couldn't program
their way out of a paper bag,
again, that's part of the problem
and so I'm going to
try and do a little bit
of rabblerousing about
we have to do better.
Not because I'm criticizing
anybody in particular,
but I feel not only do we
have to do better, we can.
We're not all professors,
as I said, and teaching
occurs all the time.
We have a colleague dropping
in, talking about it
or we give a little local
course about the latest features
and such, basically we ...
We give advice.
That's teaching.
We better give good advice,
we better give useful advice,
we better give advice that
brings the world forward a bit
instead of stifling yet
another innocent novice and ...
One of the things that
bothers me a lot is that
sometimes people have the
weirdest idea of what C++ is.
I'll get back to that.
But basically, when you're giving advice,
when you're giving a short presentation,
when you're giving a course,
think about what it is
you want to achieve and
work backwards from that.
Don't start with what have we always done
and what is easy to get started
or if you are a professor,
what's easiest to set tests for?
I mean, anything that can be
tested by a multiple choice test
is usually bad.
All the interesting stuff
is the stuff that is ...
Sort of more real, harder
to quantify specifically.
And ...
So who do we teach?
Depends who we are, of
course, there are students
in which case you have
some chance of knowing
their background, though
I've taught freshman
and they come in from high
school and they're all
over the place.
When I started teaching
freshman, it was 60% electrical
engineers and the rest
was computer engineers.
Computer science was being
advanced and doing Java
and I got the electrical engineers.
Two years later, when
my electrical engineers
significantly outprogrammed
the computer scientists
the computer science department changed.
But basically you have
to look at the students,
the people you talk to,
the people you change
and try and understand them.
What's their background,
what is it they know,
what is they don't know and
what it is that will do good
for them in the future, and
of course what do they want
which may not be the same.
Industrial programmers,
again the same thing.
Background, aims for the future and ...
There's a lot of
professional nonprogrammers
that are using C++.
People who are physicists,
biologists, historians,
they have a totally different
view of what is important.
A lot of them go for the thing
that's easiest to pick up
which these days usually is
Python and then they run out
of CPU power.
I heard about a biologist
that was running three
month runs to get his data.
It could be done in just over 10 minutes.
We know that because that was
done when he couldn't do it
in three months anymore.
We have to help those.
There are so many in the
world and they're doing
so many important interesting things.
They deserve our help, and
basically the most fundamental
thing about teaching I think
is that the students are
by and large not like you.
On average they are not
like you and on average
we assume they are just like us.
Hey, we've all been to
school, so we know what it is
to learn, right?
We just do what we did 20
years ago in kindergarten?
No, you have to think a
little bit harder about these
things, and you have to learn.
Learn about the students,
learn about their needs.
And I think we did a really
lousy job teaching C++
before the first standard and ...
Not much better later.
We, that definitely includes me.
Basically, the message about what C++ was
was hijacked by everybody that
wanted to hijack something.
C++ wasn't supposed to succeed those days.
There's always fashions and they will ...
determine what people think is right.
A lot of C++ got hijacked
by people who thought
it was C with a few knobs
on the side and others
got hijacked by people
with the oh, rah rah rah,
everything is a member function,
virtual member function,
preferably, and everything
should be dynamic somehow.
We have gotten a lot of
really bad code out of
that kind of stuff, and
it's partly because ...
me and others did not
articulate clearly enough
what C++ was and how
it could be used well.
And this got amplified
through textbooks, through
conferences and things like that.
We just have to do better.
People talk about getting
the message out, messaging
and all that kind of stuff.
I used to think it was rubbish.
No, it's right.
You have to phrase the
message, you have to repeat it
and you have to get it
right and then you have to
get it out there, so I want
to teach good modern C++
which leaves us with a little
problem of defining &quot;modern&quot;,
but I'll get to that.
So I have a background in this.
I hate talking about things
that I don't know anything
about and by and large
don't know anything about
I define as having not done it for real.
One of the problems with
education, by the way,
is that the previous
occupation of most professors
was student, and that, I don't think,
is just the right background
for teaching people how to do
good stuff in, say, industry.
Fortunately, this is
again, it's not universal.
When I'm criticizing
something with a broad brush,
it's not because I think
everybody has that problem.
It's because I have to be brief
and if I put all the caveats
and exceptions in, it
gets a little bit wooly
but a lot of people have that problem,
a lot of people don't.
So I still teach.
I give a course every spring at Columbia
and I ...
I talk to a lot of people, give talks,
interact on specific projects
so I do have some ...
Experience in this.
And I have ...
I have written a couple of
books that are in wide use.
I think one thing you should
note there is that they are
different, they aim at different things.
The swan book is aimed at
people just learning to program.
The tour book is meant for
people who may have fallen
five, 10, 15 years behind
with C++ and need a refresher
and are so busy that they
only have a weekend to do it.
That's the design criteria for that one
and the thick book is well
for people who need to know
everything in quite some detail and ...
Well, the standard is not a tutorial.
So basically when you
teach, figure out what it is
that you want to achieve,
work backwards from that
and write it or say it
or something like that.
So ...
Once I decided to give this talk,
and promised to give it
and still having no idea
what I was going to say,
I asked a few people
and I got some responses.
The thing that first surprised
me was the industrialist
ones, it was uniformly, great,
we want better developers.
Give 'em hell, this is good.
Now the teachers were ...
Different.
Yeah, that's great, it really
really needs attention,
but you know, it's hard, I
mean, we've failed so often.
And what can you say that's
in any way new or interesting?
And I'm not sure, I'm trying.
If nothing else, you are
not the standard educators
or audience so maybe some
of the things I say are new
and more helpful than they
would be if you were worn down
20 years veterans of the education system
and me, I think it's very
important but it's practical.
It is not education
theory or language theory.
It is something that happens
whether we want it or not
every day in classrooms, in
labs, in sort of development
floors and we have to do
it and we need to balance
two things, principles, ideals,
things that we would like
to see done right, remember
George Bernard Shaw?
And then the practical
skills that it takes
to make positive change.
You can't just go and talk about it.
It has to actually work and
you have to build it so ...
That gets back to what we're doing.
What do we teach?
There are many, many ways of using C++.
I mean, there's people going
around saying things like
C++ programmers do this
or this is the way C++
is written, and they're
usually so darn certain.
I'm not, I have seen enough
C++, I have seen enough
C++ programmers to know that generalizing
over the whole group and
then simplifying it to
this is the one true right
thing is just ridiculous.
Nobody knows enough, nobody
can be precise enough,
nobody can give brief
advice that is wide enough
to actually help everybody
so we must choose.
We cannot just teach everything.
There's too much, and anyway,
we don't know everything
and so one of the things
that I recommend anybody
who is in a position where
they do teaching, advising,
mentoring, such, is to
think a little bit about
what are your aims and
try and write them down.
I find writing things down
is really really helpful.
It's one of the things
that makes us honest.
And especially if you show
it to some of your friends
and victims or whatever, you
can get something that is
better than what you first
thought of and you have
to remember that the students
will choose what's important.
They will tune out a lot of what you say.
They will listen to people
who say exactly the opposite
and they may believe them and
they may not believe them.
That depends how well
you're doing the job and how
convincing people on, say, Reddit is.
And so ...
You must choose because,
well, everybody does,
and so here, there are lots
of aims, very reasonable aims
for what you teach and
from there comes some of it
how you teach it.
There are a lot of people
talking about let's get people
really excited about coding.
That's very important,
especially for the young ones.
But it's not my main focus.
Somebody else is better at it than I am.
Not that I don't sometimes
go and talk to high school
students and middle school
students where that's my job
but it's when I talk, it's
not what I'm thinking about
most of the time.
I'm thinking about how do
we lay a foundation for
careers in system development,
whatever you want to call it.
And also how do you ...
How do you ...
talk to people who are not
actually going to be full time
developers, full time computer
scientists but are going
to use a lot of that?
Those are my two main focuses.
There are people who say,
well, let's get them to write
a simple program and that's their aim,
that's their whole aim.
I think that very often
leads them to teach things
that convinces the best and the brightest
that computer science is boring,
that system development is boring because
they can do simple things
easy and then that's it.
I worry about that, and then of course,
there are people who just
want to enroll more people
so that they can get more ...
funding for the teaching
and that very often leads
to bad teaching and to spoonfeeding.
Okay, so have problems with C++ textbooks.
They very often don't focus
and if they do they don't say
what the focus is supposed to
be so it's hard for teachers
and teaching assistants
to actually know where
to direct things and very
often they are slow, bottom up
focused on what can be
tested, and teaching ...
1990s C++ with C++ 11 syntax.
If you find a book like that,
I am not going to mention any
but you will know them, that's not right.
So basically, we have
to teach programming.
It's not just language features.
It's programming techniques
and it's not just what
is valid, I mean, the tests
are like how weird examples
can you come up with for the
conversion of an unsigned
short to an signed int is
basically uninteresting.
That is not what the thing is about.
That's debugging and reading the manual.
You can do that once you
manual but you have to
give some advice about how to write code
so that you don't get that question.
If you write good code,
if you have that question, you
probably are doing something
wrong, and we can't try
and teach everything,
at least not at once.
We start from the beginning.
There's far too much
stuff we have to choose
and we need great libraries.
I think one of the things
that's wrong with a lot of
early C++ teaching is that
they teach the language
in isolation, you get to
page 697 and you get vector
and sort is mentioned 100 pages later.
That teaches students that
the standard library is
boring, uninteresting,
advanced, difficult stuff.
Whereas it teaches them
that if you write your own
linked list, you're cool, if
you write your own hash table
it must be better than
that standard stuff.
This is wrong, wrong wrong wrong, exactly.
So we need great libraries.
There's nothing much to do with C++ there
but that's a great library,
that's Trinity Library in Cambridge.
So another thing is
when you teach, try not
to be too clever.
People always want to know the latest
and we love to tell people the latest.
The problem is that most
people who ask for this
haven't actually learned
the foundational stuff
so we have to sort of ...
pull back.
Teach people how to do
basic things, teach people
to do simple things.
When you're illustrating
a technique, don't use
the most advanced algorithm you can find.
I wouldn't pick bubble
sort, but I wouldn't go
to the full generality of
everything the first class.
And simplify things.
The best example is the simplest example
that illustrates a technique
or a feature or something
like that, simplification
is a really important thing
in teaching and always give a rationale.
Don't just tell people, do
this, it's good for you,
it builds character and you might get an A
if you answer it just right.
Those are very short term ...
Silly arguments and we need
to do better than that.
You have to say why people
should follow the rules,
the suggestions you're making.
And the purpose of good
teaching is to get ideas
into people's heads.
Sometimes you forget that.
Teachers forget that.
They focus on grading,
they focus on techniques,
they focus on the detailed subject matter
and they forget that it's not
just to show them something.
They actually have to understand it.
They have to explain what it
is, why it is and what it's
good for, not just one of the
things and don't show off.
I mean, it is so tempting to
show off to our colleague,
to stand in front of a group of people
and show them something.
Look, this is clever,
you don't get it, right?
That means I'm smart.
That is not good teaching.
It is really ...
When you do it right, people
come out and say, yeah,
what's that, eh, simple, yeah.
You've gotten it into their heads.
Brian Kernighan had once told me, you know,
if they notice you slip the knife in,
you haven't done it right.
(audience laughs)
He's a superb teacher.
I wish there was something
like egoless teaching
but I don't think there
is but we have to keep
our egos in control,
remembering that the purpose
of the exercise is to teach
somebody else something useful.
I mean, yeah, we learn
something when we're teaching,
but that's not the main point.
By the way, that's William
Occam, he of the great razor.
Very good for use in teaching.
So basically we have to use tools.
We tend to focus on just
the compiler and a few ...
sort of statements and a very
limited number of libraries,
especially in early teaching.
And then people are
thrown into the real world
where they drown in complicated
tools and libraries.
I do not know how to do this.
There are so many things
and so little time.
But eventually people will
learn about all of these things
and it's a good idea
if people at least knew
what they didn't know and had some idea
that someday when your program
is more than 1000 lines long
you may actually need
some of these supports,
and not just to make it
easy to do simple things
but something that scales to ...
larger things.
And again, principles and practice.
You can't just lecture about programming.
It's a practical skill.
I mean, I sometimes say
you think you can learn
bicycling from a correspondence course?
Do you think you can learn
design without designing things,
programming without writing code?
Programming without reading
somebody else's code?
People do believe those
things, and that's wrong.
On the other hand, you
shouldn't just hack.
There's a lot of people that
just learn from just looking at
from what other people are
doing and what other people
are saying and they just
throw code together.
Cut and paste is the ultimate of that.
Don't just hack, you have
to have the principles also,
but you have to have hands
on thing, and it's not easy.
It's not quick, nobody can do
everything, but do something.
I mean, throw in a robot
or get people to use
a Raspberry Pi or something.
This is probably obvious here.
It is not obvious to a lot of universities
at the first couple of years.
And complexity is the enemy
of just about everything,
including good teaching.
Try and keep it simple,
focus on simplicity,
and don't throw all of C++ at people.
They won't be able to
understand it anyway.
Basically, we tend to ...
Focus the students on a few things and ...
A lot of courses doesn't have
graphics, GUI, web, email,
database kind of libraries,
that's some other course
which most of them never take
and they come out believing
almost because they've almost been told it
that there is no graphics,
no GUI, no web, no email,
et cetera.
The fact that the whole
world is run by C++
using those features is completely missed.
In the classroom.
When I was teaching, I tended
to use the first five minutes
of every lecture to talk
about some application so
what does the software on
the Mars rovers look like?
And how do you think Google works?
And things like that, good
stuff, motivate people.
Personally, the thing that keeps me going
is the applications.
And so ...
Don't think there is one way.
I really fear monocultures,
single language,
single operating system, single curriculum
when everybody copies from each other
and gets the same things from the web.
There should be many ways.
The argument, that's not
the way other people do it
or if they do it at
Harvard, it must be right
is not conclusive argument.
You look at what others are doing,
you try and learn from
it, but is there an angle
of your own that you can use?
Are you a university next
to a tractor factory?
Maybe programming tractors
would be a good idea.
My hometown was into wind
turbines and so there's
an example there, something
that can inspire people.
And don't hype.
I was criticized a lot in the
early years for pointing out
that in my opinion C++ could
double your productivity.
Everybody else promised
orders of magnitude,
transformative change.
How do you get a transformative change?
Little step at a time.
I don't believe you have this great genius
that just solves all
your problems like that.
That's not engineering, it may
be certain branches of math
but it is not when you have
to actually build a large,
complicated system, have all
the pieces work together.
So don't hype.
And don't let people believe in magic.
I mean, friends don't let
friends believe in magic
or something like that.
I really try to explain
people how it works
so you explain the
library, then you explain
the techniques that the library is using,
then you explain a little
bit about how it interacts
with the hardware and if
you are really on a roll
you can tell them a little bit
about how the hardware works.
I mean, it's abstractions all the way down
and people should understand this.
I meet too many people who ...
Do one level of the system
and then aren't interested in
how it is really done.
I mean, I'm frustrated if
I don't understand what
the next level down in
the abstraction stack is.
I can't not know everything,
but at least I feel bad about
it, if you feel proud that
you don't understand hardware
there's something fundamentally wrong.
If you feel proud that you
don't know how your library
is interacting with the
operating system and how often,
one, you shouldn't be proud of it.
Two, you will not write
low latency software
or high reliability software.
This is practical.
And basically we have to succeed.
The main argument is that
we will depend in our daily lives
on the code written by the
next generation of programmers.
So if we screw up, we'll pay for it,
some way or other, so we ...
We should focus on this, and
a certain amount of idealism
is necessary, if people
just have the attitude
I do my job, I do my
job in the simplest way,
let's not rock the boat.
Well, a lot of people do that.
For some people that's the
only strategy that makes
any sense, however, some
of us have to rock the boat
and we have to make some change.
That requires idealism, it
requires you thinking about
what you want to do, what
would be good, what change
is necessary and sometimes
a lot of work on it.
I have an idea along the
lines of you know doctors
have certain professionalism,
there's things
they just don't do, and if they do
they get into real trouble.
Same with engineers.
We build things that are at
least as essential for our world
as the hardware engineers
and the medical doctors.
After all, what tools do they use?
And we should hold ourselves
to a very high standard there.
So we have to do it better.
And we have to start out
right and then keep doing
the right thing.
Yeah, Lego's programming C++.
So let's try first a
little bit by analogy.
How does other fields
deal with the problem
of getting people on board and ...
Appropriate levels of complexity for them?
And I like cameras and
photography so I'm going
to do an analogy with photography.
Remember, proof by analogy is fraud
so this is just an
illustration, nothing more.
You can't just copy it,
but basically there are ...
There are very great similarities.
Results depend on the
equipment we're using,
it depends on the user, it's
not an automated process
that just runs.
That means you need teaching,
training, experience and such
and there's lots and lots
of components involved
in both software and in
photography and users differ
dramatically, I mean, my
main weakness in photography
is that I never have
the time to take the ...
To take the necessary
effort to learn my equipment
and to spend the hours necessary
for the light to be just
right, I mean, you can't
just pull the sun up and down
as needed, you have patience.
That's my weakness, I
have it, that's what ...
People have different
skills, people have different
course factors, individual
needs, tastes and skills
change over time, this is true for both
photography and programming,
this is why I think
the analogy might be enlightening.
And needs differ
and a system, there's lots of parts to it.
If you're programming in
a programming environment,
your libraries, language
features and such is one system
and you can't just start using
something totally different
similarly with photography.
So basically, there's a
professional level camera.
It weighs a ton, that
disqualifies it for me by the way.
I like to travel light.
It takes superb photographs
if you know what you are doing
and you take your time,
I don't have that time,
I don't have that patience.
Furthermore, you can
completely drown in equipment.
Boy, I mean ...
If you're a gearhead,
there's no end to the number
of gadgets you can attach to your system
and similarly, there are
people who never saw a library
or a language feature that
they didn't want to use
in their latest project.
Now.
There are things that are geared
for people with less skills
and less ...
Patience.
A lot of work has gone in
to designing these things
so that ...
Mistakes aren't really ...
Disastrous, I mean, a
slightly blurred picture
is still a picture and
a slightly off program
is a good start.
And they tend to be self contained.
That is, you get a
package, you use it, and
we're not good at that in programming.
I mean, people get the C++
compiler and then where's
the GUI, where's the graphics library?
The greatest problem when
I was teaching undergrads
was to get the GUI library installed.
This is where the real world hits.
It's painful and it doesn't integrate well
and my students were
using Macs and Linux boxes
and Windows boxes and it's all different.
Same library, all the code is portable but
just getting it installed is painful.
These packages are done to
basically have everything
in the box and it works
right out of the box.
And I think I would like to see that,
but there's another aspect
of these things is that ...
The various manufacturers,
Sony, those were Canons
or some Olympuses, some
Nikons, each has a system where
you can learn and then
upgrade to the next level,
not totally painless but less painless.
The user interfaces are sort of standard.
I can pick up any camera and
do a simple point and shoot
kind of thing, it's
standardized across there.
And each has a way that
makes it easier to go up
if you need more or to
go down if you are not in
a professional mood.
I mean, I make better pictures
in the first two days if
I use a point and shoot
but if I have a vacation,
the first two days
I will screw up with the
more advanced equipment
but then I'll get better.
You can move up and down these levels
so I think we need a system.
One system does not fit all.
If we give the professional
camera to an amateur,
one, they won't be interested,
two, they will make
really bad results and we
need some kind of idea about
interchangeable parts
and things like that.
And there should be distributions.
I should say, give me the amateur version
and I should basically
not have to say much more
than I just did there, give
me the enthusiast version.
I come something with 10 times
the number of knobs and dials
and if you are a professional, you ask
for the professional, it's
going to be more painful
but you are going to beat all the amateurs
if you know what you are doing.
And ...
So why three?
Why can't we just say
here's the perfect system?
Because there's no perfect person,
there's no one person that ...
Needs all of that kind of stuff.
We have a tendency of
throwing everything at it.
Look at teaching, look at
what you get out of the box
with a standard, you get
everything that you need to write
the kernel of an operating
system, more or less.
And 99.99% of people don't ever see that
and shouldn't see it because
they're doing something else
so basically we are doing something.
We are doing something.
We are moving in the right direction.
Modules will help.
This is the way I would
like my code to look like.
Give me the entry level bundle,
that's all that's needed,
and if I want the enthusiast
level bundle, I want that
instead, so I have the choice
and it's a coarse granularity.
Maybe I want to say give
me the basic games package
or something like that,
but we have to limit
the number of things
that people can get ...
So that they can not
get lost in the details
and then you can add
things that's not part
of the foundation, 2D graphics,
3D graphics, da da da da.
Okay, and we need a better
package and build system.
There are package systems out there.
They're improving, thanks
to all of you that are
working on that, but the average student,
the average user gets lost
in how do you download
something, how do you install something?
How do you know it works with
the stuff I get from over
there plus the stuff I'm
getting from over there?
We need to do better.
I really want my operating
system to say give me
the GUI from XYZ, install
it, and then I should be able
to import it.
If it's more complicated
than that, it's probably
too complicated.
This is not just for the novices.
It's not just for the first year students.
It's for all of us when
we're entering a new field
that we're not experts in.
I have this distinct
feeling that in most fields
I'm not an expert.
In most fields I do
things, I'm not an expert
because I'm learning new
things and I'm getting into
new things and so I'm
an amateur and I need
all the help I can get.
So ...
Let's go to slightly
more philosophical thing
and then to some code.
There's no value neutral teaching.
When we teach, we say what's important
and explicitly or implicitly
we condemn something
as bad, we decide what we would
like the students to learn
and if we teach well,
they will believe us.
If we teach badly, they won't.
But we have to decide what
it is we want people to get.
In particular, if we are
teaching C++ at some level,
what is it?
What's good about it,
where do we want to go?
What would you like your code
to look like in five years
or tomorrow?
Do you want to write 1980s C++?
Some people do, but I
don't think they should
so my primary interest, again, is ...
Get a professional attitude,
dependability, maintainability
Performance is important
in most of what I'm doing.
It's not everybody's essential thing,
but it's important in
C++ and reasonable cost.
These are sort of engineering
concerns, not science
concerns as such.
And so ...
Here's my summary of C++, as ever.
I like static type safety,
precisely specified interfaces.
I need resource safety.
People have to understand
constructors, destructors, RAII.
What is the value of
abstraction, how do you use it?
How do you do generic programming
and use templates well
as opposed to just use templates?
And simplicity for most developers.
This, I think, is key.
I did a small survey of ...
Textbooks about C++.
While writing this, and
it's a sorry result.
Do you know a textbook that
emphasizes these things?
I think a lot of them
don't even mention it.
It's outside the scope
and that's pretty bad.
And change is hard.
Modern C++ is not sort of in particular.
It's the most effective
way of using C++ today
given the current standard,
which is now C++ 17, it was
formally approved a few days ago
and inertia is the enemy of good code.
I mean, professors, eh,
that's not the way we do it,
it doesn't fit into the curriculum.
Maybe we can make a
change in five years when
the data structure course is willing to do
a more modern thing, and students ...
They reject what they didn't expect
and they expect from the strangest places
or from the web or from their friends
and a lot of students,
I find, are convinced
they are smarter than their professors.
And, you know, sometimes they're right.
Especially a lot of high school
teachers have been smarter
than their high school teachers,
especially in computing
where computing has not been ...
A key thing, where we don't
have a good solid curriculum
like they've got in calculus.
Quite often the teachers are
not as smart as the smartest
student, so if you get
the smartest students
into a university course or into a job,
they may have a slightly jaded opinion
about their teachers.
That will apply to you
to because you are now
in the role of the teacher
and I have definitely had people,
repeatedly every year in the course,
freshman coming out of Texas high schools,
who are absolutely convinced
they're smarter than I am
on the topic of programming.
In this particular case, I'm
reasonably sure they're wrong.
(audience laughs)
But ...
It is something that has
to be taken into account
and dealt with.
They don't take it just because you say it
and we have to worry
about current practice
because it's very often
what was fashionable 10, 20,
or 30 years ago.
By the way, this year,
similar is 50 years old,
so object oriented programming
is now 50 years old.
For somebody who thinks
it was cool and modern,
just remember, 50 years,
we're that far into it.
So modern C++.
I define it as the best practices
using the current standard
possibly with two S's.
And basically I aim for
completely type safe
and completely resource safe code
and there's a project which
I launched here two years ago
about the C++ core guidelines
that basically tries to codify this
as a set of rules.
This is not what C++ is.
It's a kind of way of saying ...
What are the good practices?
How do you get started into this?
I mean, it's not something
that it's enforced
by the compiler or everybody
has to do just like that,
but you really need a good
reason to do something different
is the way I define it.
It's a very active project.
There are ...
Dozens of contributors every
month and it's a very wide ...
Sort of ...
Set of contributors, I
mean, where else do you find
Microsoft and Redhat doing
something together regularly?
The world is improving.
So ...
Code examples.
Programming has to do with code
in the end, so good examples
are key.
I sweat blood trying to find good examples
and I'm never as successful
as I would like to be
because they have to be simple,
for teaching to a class,
it has to fit on a slide
or a couple of slides.
If people show me this
much code, the ideas
are going to be lost in the code.
You can't get the idea there.
Yeah, if you're in a work environment,
you can sit over a screen
with a guy that walks you
through it, great, but ...
In many, many cases
finding simple examples
is really really hard
and also the big examples
sometimes aren't the greatest examples.
They have all the warts that was necessary
for compatibility, for
the way we usually do here
and the conventions that
have grown up since the 90s
so finding small examples are key.
And don't separate code from explanation.
If you just show the code,
people will not get the idea
and they will invent reasons
why it looks like that
and those reasons are
sometimes seriously weird.
If you give them just the explanation,
that's sort of the standard
lecture of what is good
and proper and people go to sleep.
They don't get the idea,
so a tight integration
between examples and
explanation is essential.
I learned that from Brian Kernighan.
If you haven't, read the
introduction, the tutorial
the first chapter of KNR again.
It's a beautiful example
of how you can get ideas
into people's heads.
C would have been among the
dozens of failed attempts
to do what C did, if
it wasn't for that book
and that style of teaching.
It's very important, Brian is,
by the way, a really nice guy
The fights between the C
community and the C++ community
did not happen between me and
Brian and Dennis, that's fact.
So let's look, I can't
give a talk without code
so I'm going to show you a
few examples of what I think.
So here are two ways of writing a loop.
The first is the good old
way which we have written
more or less that way since the early 80s
and then there is the new
fancy way with the range for.
And why is two better than one?
Basically, two states what I
want to do for all x and v.
There's no i, I didn't need an i.
There's no separation
between finding the limit
of my data structure and the ...
Use of that variable, constant,
whatever you want to call it
so I can't make a mistake
about getting the size wrong.
And ...
You can explain this, this is easy.
So it's shorter, less
opportunities for ...
for mistakes.
And you know, yeah, one is more general.
You can express more cases.
But that also means you
can make more mistakes.
So remember, goto is the
simplest and most general
control structure, at least non concurrent
but you can't implement
concurrency with a goto anyway.
So basically just because you can do more
doesn't mean it's better.
Sometimes it means it's worse.
The fact that goto can do everything
is the fundamental reason
why we don't use it.
Except in machine generated code and such.
Yes.
Here's some example,
slightly more modern example.
I am ...
Going to blink some LEDs and
there are two ways of doing it.
I can give an integer, and it blinks,
and I can give ...
A millisecond argument that
says how many milliseconds
that can blink.
Now if you use integers, you
have to guess about the unit.
And so if you have blink
number two and you just give
it something without a unit
the compiler says, well ...
You didn't tell me what the
unit was, so I won't compile
this for you, this is good.
And the reason it's good,
my best example is that
little spaceship there, the
poor little Mars climate orbiter.
It was sent up to Mars.
And it was doing the
final course corrections
to get around Mars in a good
orbit and it disappeared.
My favorite theory at the
time was that it had been
kidnapped for ransom by the Martians.
There's also people that claim
it was a Yankee go home thing
We don't want any
stinking earthlings here.
However, what happened was more relevant
and less interesting.
There were two groups of engineers
and they were transmitting a power reading
through an interface that took a double.
On the one hand, they had SI system MKS,
on the other side, they
had the imperial system.
As that double passed
through the interface,
it changed its meaning with
a factor of exactly 4.65.
And we never saw that
little spaceship again.
That means that about the
lifetime's work of 200 good
engineers just disappeared, basically,
they'd all worked for nothing.
They got the salary but didn't
deliver anything of value
to the world.
All the scientists that
were waiting for the data
had to wait, lots of
promotions didn't happen,
lots of students didn't
get their degrees, and ...
Yeah, basically, we lost
about 600 million dollars
and it took 15 years more to get one up.
That was the bug that you see there in ...
The first use of blink_led2 1500.
Some bugs can be really
critical and we can do better
than that, and if you want to be generic,
you can do that too.
Modern C++ is very flexible and
you can use that flexibility
to gain precision, so here we
have some of the rules from
the core guidelines,
make interfaces precisely
and strongly typed,
that's an example of that.
And we can go further.
Always initialize an object.
This is a saying that people
break again and again and again
They are so smart, they know
they are going to initialize
but they declare it up here and
they initialize it down here
and they get it right all the time because
they are good clever programmers.
No.
Even if they get it right, somebody else
is going to write code in
there or you have handled
all three possible cases
and somebody invents
a fourth case, so one of the
rules is always initialize
an object, and that
always has some pressure
because people have had
other ways of doing things
over the years, like I
like to define all of my
variables up top in the program
and then I initialize
them the way I always did
in Pascal and other
languages further down.
After all, I would like to see
what all of my variables are.
That, by the way, is a
sign that your function
is too large, which is another rule.
But here, always initialize the object.
Now sometimes you can't do
that, so you have to deal
with exceptions like input
buffers, and in particular
multiple out values have been ...
A problem over the years
because, well, if you have
to call a function to
calculate the initial value
of two or more ...
Variables, then you end
up having some things like
that error code there.
You call the channel, you
pass the error code in
uninitialized as an out parameter
and you don't say so,
the reader can guess it.
No, and then you have to chase
it, so in C++ 17 we have ...
We have ...
structured bindings where
we can say I want to break
the result of the channel
open into its component parts
and so we can now return
n values and use them
as individual variables
instead of having them into
an object and accessing
the object in certain ways.
So always initialize objects
and return multiple out values
as opposed to using out parameters which
is a known bug source.
One of the ways when we are
developing this is to look at
bug logs, what do people get wrong?
What can do we do to fix it?
Again, we are not trying
to be clever here.
We are actually trying to
find out the least clever ways
that work.
Basically.
Develop an error handling
strategy early in the design.
That's a rule, it's sort of philosophical,
you can't have a static analyzer
find it when you haven't.
Some rules are high level,
some rules are low level
and checkable.
Throw an exception to signal it.
Exceptions are for error handling only.
So if you look here ...
I have gotten too far down
here, yeah, I showed you ...
No, I did not show you this.
So first we start out with
a classical style without
parameters, then we use ...
Structured bindings and
finally we can start discussing
should it have returned two values?
Should it have thrown an exception?
And this is where, the
tricky bit is to say,
when do you throw an
exception, when do you have
an error code?
Is it normal to fail?
Is it expected to fail?
Then it's probably an error code.
If it's considered a design
failure of an extremely rare
event that fails, it should
be an exception is the answer
in the core guidelines.
And basically don't be too clever.
In the context of using
C++, clever is a swear word.
Don't be clever.
So here is some code, slightly simplified.
It's got really bad bug in it,
I don't know how many of you spotted it,
how many of you would have spotted it
if it had been in code that
was a couple of screen fulls?
It is trivial for the ...
for a static analyzer to catch this.
The problem is that people
are messing with resource
management, and there's some rules.
Don't leak resources.
Don't call new and delete
explicitly in application code.
It should be encapsulated
into a resource manager.
And a raw reference is
non-owning, in other words,
if I return *new of
something as a reference,
don't do it.
Because not only have you
now sent something out
so that you know that
it has to be a delete,
but there's no pointer out
there that gives you a hint
that you deleted so a lot
of the guidelines have to do
with resource management
and the analysis software,
actually, the existing stuff
that's shipping from Microsoft
is actually catching this and
I believe that other efforts
are in place to catch
things that has been ...
Specified in the core guidelines.
Lately I have found
that people have learned
to express things directly in
code a little bit too well.
I see a lot of code that
has no comments in it
because in the old days,
people wrote comments,
pages and pages of comments
and they tended to be
out of date and unreadable
and imprecise and in
a lot of places, people say,
no, no, comments are bad,
we won't have them, and
now I can't see what it is
you're trying to do.
I can see what you do, but
I can't see if you meant it
and so basically the rules in the ...
Core guidelines example here.
You express things directly in code.
But there's things you can't
express directly in code
and that is why is it there,
what is it what you are trying
to do, so basically intent
should be in the comments and
comments should be crisp,
not hidden in sort of
somebody trying to write
War and Peace because
they really wanted to be an English major.
So things like that matter.
And the old rule is if the
comments and the code disagree
both are probably wrong.
And I actually applied that
rule when I wrote the ARM,
the document that started
the standardization.
I tried carefully to say everything twice
because then if I screwed up,
there was a high probability
I would be caught.
These days, when people
write specifications,
they try very hard to
say things once only.
Which is sort of fine except
that I can't see if they meant it,
so if I read a
statement in the standard,
I don't actually know if that
was what they meant to say
and I didn't quite understand it or ...
They didn't quite understand
it and I can't see it
so comments are important.
So there's a fair amount
of philosophy rules there.
I have chosen to illustrate
this with Archimedes,
arguably the world's greatest architect,
sort of a philosophical
view of things, a framework
for your design, a set of
all our rules is important.
I'm not going to go into the details.
I encourage you to go on GitHub,
find the core guidelines.
Look through it, if there's
some you like or if some
you don't like, send me an
email or put in an issue
or something so that we
can improve these things.
And basically, my aim is very simple.
We can write type and resource safe C++.
My first step is to make sure
that I can do that reliably.
That requires tool enforcement.
The tool enforcement is incomplete
now but we're improving.
But basically, no leaks,
no memory corruption,
no garbage collector, no
limitations of what you can say.
No performance degradation.
This is after all C++
and write in ISO C++.
I am not a fan of proprietary extensions
so this is happening and
I think this is part of
what it takes to teach.
You have to figure out what is you teach.
You have to articulate why
that is a good thing to do
and so teach for the future.
You have to live in it
and the world shouldn't continue to accept
sort of unsafe bloatware
and probably won't
and if we don't improve, somebody
else will try and improve
it for us and we may very well not like
what they come up with.
So the proof of the
pudding is in the good code
and there's a lot of practical
stuff that has to be done
to do this, correct,
maintainable, appropriate.
Efficient is sort of my
version of Vitruvius there
and we need to work on
curriculum development
if we are in the education business
and learners should build
a portfolio, not just go
for the grades, it's
really, really hard to get
current day students to
learn as opposed to swot
for the exams.
Yes, it is ...
So ...
I come to the question area
and I'd like to point out
I know very well that I
have not said everything
that should be said about these subjects.
There are several other
things to do with learning,
training, teaching at this ...
conference, you can go
there, there's in particular
a panel tomorrow evening
where we are talking about
C++ in academia, I am
a panelist and so are
a couple of other people.
Okay, questions.
(audience claps)
We have microphones up here, right?
Is there one on each side?
Please use them because I
really can't hear if you don't.
This is an awfully large room.
There's so many more people
than there was last year
and last year it was large already, so ...
- Hey, so the core guidelines,
you mentioned them,
you mentioned about teaching with them.
They're quite large as they are
and that can be quite
overwhelming to students to take
a look at the core guidelines directly.
How would you recommend
approaching teaching
the core guidelines and
getting students to take
a look at them?
- First, I suggest that
you read the introduction
to the core guidelines that
says what's there and why,
to have the rationale.
Then look at the philosophy sections.
Pick a couple of those and
then pick some relevant rules
to focus on.
As ever ...
You can't teach everything.
The core guidelines were
not attempting to be ...
Everything for everybody or to be minimal.
They are orthogonal, that
is, if you look at a certain
section, that section
is reasonably complete
for a lot of people and you
have may have repetition
on another area.
I don't mind that, if we are inconsistent,
which we have been repeatedly,
people find it and tell us
and we clean it up.
Now ...
Your colleagues or students
will not need everything
so you have to make up your
mind where to focus them
but begin with the philosophy
that the general understanding
of what we are trying to do
and then focus on something
important.
I don't think we are going
to be really successful
on sort of a worldwide scale.
Till we have better static analysis.
I want to eliminate dangling
pointers, full stop.
I want guarantees that
there's no dangling pointers
in my code.
After that, I can give you
code safety and resource safety
and things like that, but
first we have to eliminate
the dangling pointers.
That is a thing that
takes static analysis,
some coding discipline,
which is in the rules
and some support libraries
including the parts
of the standard library
and so as it is now
we're still working up to that,
but I want to scale this out
to sort of four million programmers
and you don't do that without tools.
You cannot talk your way into that scale
and currently I am doing
more talking than deployment
of tools, and that's
unfortunate but we'll get there
eventually.
The team at Microsoft that
started out with this is
in a way, I think, I see Peter
sitting down there in front.
Are your guys getting on to this?
Yeah, yeah, see?
Other places are catching up too.
I know some projects in China.
I hope to see some more in Clang Tidy.
So ...
We need tools to get there
and that will answer your question.
People will not have to
find the rule, the rule
will find you, you give it the code,
and it will drop you on the rule which has
what is the rule, why is the rule there,
what is an example of
why the rule is there
and what do you do instead?
That's where I want to go.
- Thank you.
- I should take one
from there.
- All right, so in general,
some people would like
to see in the standards
some solution that works
better for beginners, I'm
thinking for example of generating
random numbers.
The solution we have in the
standard library is great
for me, an expert, who can
use them, but some people
would like just a simple
function and usually
we can't get those in the
standard because there are
different, you know,
needs for different people
so do you think C++ could use ...
Just a separate library that
just adds some of these ...
Simple solutions for beginners,
new string formatting,
new ...
- Do you know the concept
of a violent agreement?
This is when people keep
arguing long after they agree
because they have to be so
keen on saying that they agree.
That's what I feel like now.
I have been arguing for that for ages.
I mean ...
&amp;lt;random&amp;gt; is the random
number library that every
random number library wants
to be when it grows up
and as a result, people use ...
rand, and they get really bad results.
And I think, one, the standard
committee would do well
to remember that they should
make simple things simple
and they should put things in the ...
Standard that help this.
A very simple random number
function, something that can
compete with rand,
should be there, and ...
so should, say, split, not
because I like split most
but that's when people
come in from Java and C#,
that's what they try for.
They don't understand how
to get it out of iostreams
so things like that should be there.
Similarly, for the beginners,
I think we should have
a guaranteed range-checked set of containers
and I want that portable
across all implementations,
by the way.
And you can take the ...
training wheels off later.
That has something to do
with the idea of a package
for beginners.
When I was teaching
undergrads, there's always one
smart aleck-y guy.
It's always a guy.
The women are smarter.
Who wants to tell me
and all of his friends in the class
that really you don't
use vector and string.
You have to use pointers
and malloc because it's
more efficient.
No, you shouldn't do that,
and I would like to stop them
from doing it because then
they spent their nights
debugging stuff that they should
have finished at dinnertime
and usually I find this guy
and ask why are you doing this?
Efficiency.
What optimizer options do you use?
And usually the answer is, optimizer?
(audience laughs)
Okay, so which system are you using?
Let's pick clang.
Which optimizer option do you use?
I don't know.
Do you use -O2?
What's -O2?
You are talking about
efficiency and you haven't
switched on the optimizer.
Okay, so things like that
is important, but I think
we need a package for beginners
and it should definitely
have the random numbers.
I love random numbers for
getting semi-realistic programs
to run.
There are a few little things in the GSL,
the guideline support library, that helps
but we hope to put that out of business
by putting it into the standard
and that really is help for professionals
as opposed to beginners.
It would be nice if there
was a beginners' library
and by the way, don't teach,
don't try and teach people
today in high schools and ...
early university without
a little bit of graphics.
They don't believe it's real computers
and it's hard to do because
we don't have that package
that's just install
this one, use this one.
Random is a relatively easy example.
I have a support library for my course.
It has random like that in it.
- [Man] All right, thank you.
- Yeah, about those packages, the bundles
that you proposed for
beginners and intermediate
and advanced, those libraries,
I mean, they would get
some extra standing as
compared to other libraries,
so is that ...
Do you think that should
be part of the standard
or should be just libraries
that are developed
by the community and elevated
into the status of being
part of a bundle or how
do you see that working?
- The standard is and should
be tiny compared with what's
available in the greater
world, so the way I imagine
this system would be
not the standard but ...
packages that ...
educators or ...
early developers, junior
developers, could use
and I would hope that it would
come out of the community.
And there are two things
we need for that to do.
We need better package and build systems.
I know they are being worked on.
I'm putting this in to
encourage people to do more.
Not to criticize unconstructively
and we need modules so
that I can just grab things
and be sure they don't
interfere with each other.
I mean, you have some things
and you include a file
and some ...
Some idiots ...
10, 15 years ago, defined
a macro called min.
(audience laughs)
And your code stopped working
and you of course will say,
oh, God, not again.
A novice would be completely floored.
It comes out of nowhere, so I
think package built systems,
packages with related
build systems and ...
Modules are very essential
for doing good teaching.
They're essential for other things too.
I don't see the standards
committee doing it.
The standards committee is a
little bit too expert friendly
in my opinion.
You've heard me go on about
making simple things simple.
It's not the main focus of
most people in the committee
and so community.
- [Man] So you would see
there being options for, like,
different bundles for, say
graphic libraries, or ...
- Something like that, yes,
yes, but this is sort of ...
I'm waving my hands here.
It is not a precise specification.
- I had a very specific
situation not too long ago.
I was working on a
project with my daughter
who has a very good aptitude for coding.
But doesn't know C++.
We were working on a thermostat project,
has a little graphics, little robotics,
kind of stuff to keep you
interested, good stuff.
I did what I thought was a good thing.
I created a little abstraction
for getting the temperature
off the temperature sensor
and I gave her a task to do
with this and I found that
the amount of C++ I needed
to teach her was beyond ...
And she's a college student,
so it's not like she has no
attention span, but it was
beyond her attention span
and I was wondering what
your thoughts are on that
in terms of getting started with something
that's gonna do something concrete,
it's gonna click some relays,
it's gonna show something
on a display, but ...
It seems like even the simplest
thing requires the first
entire semester of C++ to do.
- That is a major part of the problem
and if you tell them to download
the library that makes it
easier to use and install it,
that's beyond them too, so ...
That's actually the deeper
reason I was going on
about packaging and modules.
We badly, badly need modules
and we badly, badly need
modules that can do the
simple clean things simply.
- [Man] Right, but I'd even
gone beyond that because
we didn't need the
modules, I already had ...
- Wait, wait, wait, I'm
just getting warmed up here.
(audience laughs)
Then we need libraries
that are actually aimed at
people who are not CS majors
and a lot of our libraries
are aimed at CS majors,
written by and for CS majors,
that's very, very limiting.
You need things that go beyond that.
I know that's a session at
this conference on Friday
that I would have gone
to if I had been in town,
but I have to be somewhere else.
I think that addresses something.
The people that are
starting with young kids
are actually getting some
of the ideas that will apply
to novices of all ages,
and as I point out,
I'm a novice in many fields
most of the time, so ...
I'm not being ... (sighs)
Patronizing here.
And ...
For some people, something
like Raspberry Pi is just
wonderful.
And that's an adult thing,
too, not just for kids,
so we need to do more and
better, but I can't be concrete
on your example, it's ...
You're touching in the middle
of a very hard problem.
- Hey, there, I'm gonna
switch gears a little bit
from what we've been talking
about, although I think
you just touched on it.
At the very beginning of
your talk, you talked about
how your aim is mostly
towards students who are going
to be professional software
engineers in some sense,
do some software work professionally,
but how do you feel about programming also
just as a way to teach
rigorous critical thinking
to anybody, like how we
teach math to everyone,
not just people who
are gonna be technical,
and how would that change
your aims as a teacher?
- I think that's important.
Traditionally in our culture
we have used mathematics
for that, and ...
people aren't getting enough
mathematics in my opinion.
You can do programming
as a far more concrete
and instant feedback form of
learning critical thinking,
learning precise thinking.
Code is very good at
hitting back where you are
thinking in a wooly manner and for that
I think the most important
thing is that you don't make it
too easy and in particular
you don't make it fuzzy.
There are a lot of work done so that ...
If you say something,
it'll do something and ...
It's not too fuzzy about what it is.
If what you are wanting
to teach is precise,
scientific thinking, precise things.
The reason I focused more
on the software developers
was that's what I know best.
I'm very reluctant to say precise things
about things I haven't
actually tried myself
and so I mentioned it as an important area
but I think it's an important area
that takes some serious work
by somebody who isn't me.
- [Man] Thank you.
- Yes, two comments, one is on the ...
the guidelines themselves.
I think that's probably one
of the best things I've seen
toward the language in
the last two decades.
A problem, though, is that ...
I was trying to encourage
a section of my company
to use it and they happen to be in Germany
and they didn't really
understand the preamble.
They didn't get the joke,
actually, about it being
incomplete and such ...
- [Bjarne] Oh, that
one, yes, yes, we're ...
Okay, I mean ...
There's a joke about Germans lurking here.
(audience laughs)
But the ...
Yes, maybe it's time
to take that one away.
It's a saying that we're using
in some of the drafts at ...
In the standard documents
and in the proposals,
yes, you're right, that may
have outlived its purpose
and jokes don't travel culturally.
I know that, and I think I
slipped up there, thanks.
- And the, one of the
difficulties is that ...
I work in a highly regulated industry
in the medical devices industry,
and getting GSL to be
used as the library is
difficult because there
doesn't seem to be any
stated direction as to when
it's going to be proposed
or entered and so having
that guidance there as to ...
You know, at what level it's
going to be proposed into
the main standard library or
what track it's going to be on
would be nice, especially
since some of our code is ...
vintage.
- Yeah.
There's always the inertia
of old code and old think
and that we have to
fight in every industry.
I work in a highly regulated industry.
Well, people don't die if
we screw up but they may
jump out of windows with the same effect
when they get ruined, so we
have some of those problems
and we have gotten permission
from our regulators
to use things like that so it can be done.
But ...
I hope I said it somewhere in
the guideline preamble that
we need specific guidelines
for specific areas
and we just haven't gotten there yet.
It is still the core guidelines, but ...
If you look forward 10 years
time, I would expect there
would be the medical appendix
and the financial appendix
that has specific rules,
supports and restrictions
suitable for an industry.
I know most of us have
to worry a lot about
the next release and the next quarter.
I try reasonably hard to think
about sort of five years,
10 years, out in the future
because it is going to come
incrementally from what
we are doing today.
The core guidelines is good
and it'll be much better
in the future but boy, do
I wish it was moving faster
and we had better support
and better enforcement
and things like that.
I guess I'm somewhat impatient
with a lot of things.
- [Man] The one from Microsoft
works for most things,
but it's also nice that
there's a single header
GSL light one that actually
goes back to more ancient code.
- It's ...
A lot of these things work together.
I can't wait till I can say without ...
Caveats ...
Use concepts for all of
your template arguments.
If you want a fully generic ...
piece of template argument,
say so.
Like ...
Define the concept takes everything
and use modules to make
sure that you don't get
infestation from other
people's macros and type defs
and that works together
with the views in the ...
Core guidelines.
There are things that
we can do much better
with what in my opinion
should have been 17,
but not everything can
be 17 so let's go for 20.
And the guidelines will be better for it.
And from my perspective, it's
the same kind of thinking
for getting us to the future.
- He was talking about how
using libraries is important
and how writing around
linked list is probably not
the best idea and I can't agree more,
but, say, like 10 years ago,
when I was writing my first
application, I invented my own atomic,
so the bad news was it was
actually used in production
but the good news is that I
learned a lot while doing this
and you might have heard
they say that you're not
a real programmer if you
didn't implement your own
string class, so the question is...
If we have a generation
of software developers
who didn't implement
most of basic constructs
but they already learned
to use ready abstractions
and libraries, should we
miss something or maybe this
is the right way to go?
- If we don't teach people
how to do lower level software
we get a generation of
programmers that only know
how to use a library and that's wrong.
When I teach people,
when I teach freshman,
I teach them how to implement vector
because they need to know
about pointers and freestore
and they need to screw up
so that they see it's good
to encapsulate it and those
problems don't happen anymore.
When I teach ...
Later on, I ...
Very often have people
design implement a string
so that they can see how it's done
and so I can show them how
they could have done it better,
so yes, we need to get
down to at least the C++
memory model at some point.
Otherwise we teach people magic.
So you have to get down there somewhere.
I thoroughly agree with that.
On the other hand, I don't
think everybody needs to write
a lock-free code.
If you are a computer
science major and if you are
specializing in sort of engineering uses,
yes you must do that, but not everybody.
But yes, you have to reach
some level of abstraction
that is good for what you are doing
and for computer scientists I really think
they should know how vector is implemented
in some extent
and how the string is implemented.
They should know how to do
the short string optimization,
for instance, then they understand.
- That is great when you
teach your students, right,
and imagine that you have
a junior, for example,
in your company and you see
that he's trying to implement
some basic stuff, and you
tell him, don't do this,
it's already done, yeah, that's great.
But perhaps he was trying to implement it
because he don't actually get how it works
and he don't want to be using magic.
So from a practical point
of view, I don't want him
to write it, but from the
education point of view it would
be convenient to do this.
- In a concrete way, look
at chapters 17 and 18 of the
swan book.
I have done that for 10 years.
That's the vector implementation.
It's a way of trying
to address your concern
for first year students,
people who have never seen
a line of code before
they started chapter one
so I don't drift into
just the stratosphere.
That's not what I'm recommending.
- So for, you're talking
about Raspberry Pi.
I ended up doing a summer project on one
and I ended up doing it with
Python, which was nasty,
but so with your talk of modules,
for the Raspberry Pi
there's a lot of stuff
with setting up I2C connections,
for connecting different components,
setting up the different PWMs on the pins
so would you have like a
module for Raspberry Pi
that's specific for the Pi or ...
- I think when you get to real hardware,
you need dedicated facilities
to make that hardware
reasonable to use, yes,
and so I would expect
once we get modules in
the language, C++ 20,
that was not ready for 17,
I would hope that Raspberry
Pi would have a basic
Raspberry Pi support module
or something like that.
- [Man] That'd be great
because it's another thing
like you said where it's good
to have interfaces and stuff
which Python has a very
simple Windows 98 one.
- I know, I know, I know,
hence the talk about
photography, I wish I
could have done that talk
for C++, but I can't, later.
- Thank you.
- Hello.
So I volunteer teaching high school kids
and there is always the
question, I'll give an example.
For example, when I teach
operator overloading
or stuff like that, so and
I'm teaching them, like,
copy constructors and operator equals,
there will always be the
student that will ask about
move semantics and stuff
like that because they are
sitting with their laptops
and they'll google it
so how would you go about
finding the golden ratio
between what's essential to ...
Like, teach them modern stuff
but also not overwhelming?
- I mean ...
That's a very very hard question.
I don't really know.
I can point to the swan book.
When I had the concrete
problem, not for high school
students but for freshman,
that was my solution
and I think ...
Some of that is pretty fundamental.
If you are dealing with
people who want to be
software developers,
you have to go through
the usual stuff, you have
to show them what a loop is,
what a function is, how to build a class,
how to use a class and
you will eventually ...
Think it's chapter 10, get
to move semantics and such.
For high school students,
you can't quite do that.
One of the problems is that
people always read ahead
and they want to try something else.
That was what I said
these people that decided
that pointers and malloc were cool.
And they wanted to be the
cool kids and corrupting
the others.
That's always a problem and ...
I think a good teacher
will find a way of handling
the students, knowing
the students and such.
What you can do in preparation
is to have a curriculum
that provides abstractions
that's relevant to what
they're doing so that you can
say, yeah, you can do that
but if you use this one for now,
you'll get to bed at a reasonable time.
I mean, do you really want
to stay up past midnight
debugging all the time?
And sometimes when this happened to me,
somebody heard of move
semantics just when I'm trying
to teach them how to
write a string out to ...
to output.
I say, well ...
We'll get to it.
They don't like that answer
but sometimes it's the only
answer, otherwise you
end up doing bottom up
and with bottom up you never
reach where you want to get
there, all the time is
spent inventing macros
for hiding malloc so that
you can catch errors
and things like that.
You don't want to go there.
So ...
Try for suitable
abstractions for your people
and try and deal with what's ...
What then happens.
We are over time.
So ...
Maybe we should stop.
I will be around today or
tomorrow so try and catch me.
There are people
streaming out in the back,
which is fair, since
we're 10 minutes over,
so I'd like to cut it now.
Sorry for you standing
up there, thank you.
(audience claps)
- Bash Films can shoot your
event with multiple cameras,
link to presentation slides, add titles
and edit your event live for
a full broadcast experience.
- How is this even working?
So this is an even more
interesting program to, you know,
look at in a lot of ways.
So let's profile it.
Give it a little bit of
time to do a profile for us.
See exactly what it is that's
making this faster or slower
based on the different inputs.
You can really gain a
lot of insight by looking
at the profile like this.
- I worked at Sesame Street.
I got brought on to be
a writer's assistant
on a show called Sesame Street English,
which was to teach English
to kids in China and Japan.
It seems very simple, the
shows that they put together.
But it's actually really
hard to design a show
that is not only for young
kids but also the parents.
- Confession like this is therapeutic.
I hope you all get something
out of this, but if you don't
the therapy will have been
good for me, so thank you.
(audience laughs)
Seven years ago I was working,
I wasn't working at Google.
It was for my previous
employer, which was a large
multinational investment bank.
I had what was up to that point
the worst day of my career.
- And then came the anger.
Anger at ourselves because
we knew we were responsible
for America's first space disaster.
We wrote two more words
into our vocabulary
as mission controllers,
tough and competent.
Tough meaning we will
never again shirk from our
responsibilities because
we are forever accountable
for what we do.
Competent, we'll never again
take anything for granted.
We will never stop learning.
From now on the teams in
mission control will be perfect.
Because as a team, we must never fail.
- One other thing.
We're all in a very fortunate position,
we've been very lucky in
our lives and so forth
and I think as part of the
mission it's also good sometimes
to take that fortune and give back.
(audience claps)
To make sure that we take this platform
and use it towards worthy causes.
That's good karma.
That's good stuff in the universe.
- We understand that your
event will have needs
that are specific to your organization.
Please, email or call
us directly to discuss
your particular event.
We look forward to discussing your goals
and helping make your event a success.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>