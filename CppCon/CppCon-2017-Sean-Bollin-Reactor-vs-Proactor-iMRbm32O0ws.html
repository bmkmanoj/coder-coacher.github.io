<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Sean Bollin “Reactor vs. Proactor” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Sean Bollin “Reactor vs. Proactor” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Sean Bollin “Reactor vs. Proactor”</b></h2><h5 class="post__date">2017-11-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iMRbm32O0ws" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Hi everyone, my name is Sean Bollin.
And at work we use Twisted,
which is a Python library.
And this reactor, and I got
interested in, you know,
what is this reactor and
proactor design pattern,
so I started to dig into it,
and I'm just going to show
you what I came up with,
and what I learned along the way.
So, the reactor and proactor patterns are
event-driven programming models.
Patterns that you'll find in Boost ASIO,
and Twisted Python library.
You can do them on the server
side or the client side.
There's not too many
resources online about
what the difference between the two are.
The one book where it's
pretty well codified
is &quot;Pattern-Oriented
Software Architecture&quot;
by Schmidt, Stal, Rohnert, and Buschmann.
So, the reactor, it can
wait for multiple requests concurrently.
And once it has some
requests available to process
it'll dispatch them to handlers.
Both the reactor and the
proactor are primarily
single-threaded models.
You can use threads to kind of help you
facilitate different things, but the idea
is getting out of the thread
per connection paradigm
and focusing more on asynchronous actions.
So, a super simplified approach would be,
you have this reactor,
and you can add handlers to it.
If anybody can figure out
how to get GitPitch to stop
converting my lambdas into
HTML links, let me know.
I spend a little bit too
much time on that one.
So the oneSuccessHandler,
and twoSuccessHandler,
those are just call-backs
that you get after
like a one-event was received
or a two-event was received.
So the reactor is based
off of an event loop.
Typically reactors are
implemented using system calls
with select or epoll.
So what this loop does
is, it's just gonna loop,
and it's going to wait
for the system call epoll
to let you know that some
events have occurred.
So those events could be like,
a couple clients are trying to connect.
So the epoll and select
calls are C-level calls,
but it can be nice to
create, like, some basic
abstractions in C++ for these things.
One of the limitations of a reactor is,
let's say you have these handlers and
a few different clients
connect simultaneously.
Well, if one of your handlers
is a long blocking operation,
an operation that takes
a long time to compute,
your client will definitely
have some performance issues
with that, because they're
going to be sitting around
waiting for this operation to complete.
Typically when you use a
reactor, you really need to be
cautious that the code
executes quickly enough
to return back to the other
events waiting for it.
The proactor comes in and tries to solve
some of the issues with the reactor.
It's a bit more complicated
than the reactor.
It's fully asynchronous,
and they can rely heavily
on operating system functionality, like
Linux Asynchronous I/O, and
Windows I/O completion ports.
Another aspect of the proactor ...
So there's two words,
there's reactor/reactive and
proactor/proactive.
Reactor is just waiting
for things to happen and it
reacts to them, whereas the proactor,
you can eagerly fire off some
of these asynchronous calls
before a client even requests them.
So that they're more
readily available to serve.
Using the proactor, you can make use of
Asynchronous I/O calls,
with Linux you can link to
the RT, real-time libraries,
and the Asynchronous I/O reads ...
(buzzer)
(applause)
Thank you.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>