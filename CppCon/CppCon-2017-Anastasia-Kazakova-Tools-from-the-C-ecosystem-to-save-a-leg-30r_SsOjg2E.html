<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Anastasia Kazakova “Tools from the C++ eco-system to save a leg” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Anastasia Kazakova “Tools from the C++ eco-system to save a leg” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Anastasia Kazakova “Tools from the C++ eco-system to save a leg”</b></h2><h5 class="post__date">2017-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/30r_SsOjg2E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Hello, everyone.
So, I work in the company named JetBrains
but sorry if you came here for learning
a lot in details about our tools,
I'm not gonna do that.
I'm gonna talk about the tools in general.
We'll be mentioning our tools for sure
because they're, luckily,
the part of the eco-system.
But if you would like to learn in details,
come on Wednesday and
Thursday to our booth
and just ask whatever questions you have.
So, I work for the
company named JetBrains.
Previously, for eight years I was doing
C++ development in the
embedded networking area.
And then I moved to
JetBrains working mostly
as product marketing manager
and doing some evangelism
around the tools.
And so I'm here to talk about the tools.
Yesterday I talked about
the view and the language
from the point of view of the tools,
and this will be a little bit connected,
but I will be referencing
the talk a little bit.
So I was planning to start with a quote.
Actually that's a quote from Bjarne.
It's a little bit scary
starting with this quote
since Bjarne is sitting over there.
But still thank you,
Bjarne, for this quote.
I have one slide done
because of you, thank you.
This is a very famous quote about C++.
I hope you all at least
have heard about it.
The story is that on his own site Bjarne
is trying to explain that this is actually
true for all powerful languages.
But I must say that from my experience
this is the most true for C++.
Because I was interacting a little bit
with iOS development
and the story is there
completely different if we talk
about the code qualities and the tools.
Because they have Apple behind them,
they have a lot of standards de facto,
they have a lot of
tools provided by Apple,
and that actually makes
their life much easier.
So, I would like to tell
you a small story here.
I was working for a company,
a very big network operator,
who was doing first time in Russia
LTE and WiMAX provider.
So we're doing very cool stuff
and we are doing it in C++.
But to be honest, each time someone
was leaving the team,
I mean the developer,
we were completely and aggressively
throwing away all code of this person
and rewriting it from scratch.
Why?
Because we could not maintain it properly.
We had a very small team,
each person was like
responsible for one particular area,
so we not passing the bus test at all,
and so that was the reason.
And, from my point of view, that was bad.
That shouldn't happen.
But that was life and I guess we all have
such stories in our past.
I have another story.
That's actually a story about Apple
and their iOS update, like how often
do you read the release notes?
Sometimes we do and
sometimes we could find
a very interesting thing there,
like once they issued an update,
and you can find this little line there,
like &quot;Impact: an attacker
with a privileged
&quot;network position may
capture or modify data
&quot;in sessions protected by SSL.&quot;
Wow, that's a huge breach!
How did that ever happen?
Luckily, the code was open sourced and so,
for the history, looking how we managed,
the whole community
managed to find the reason.
That was this double goto fail line.
There was a huge
speculation in the community
how the error managed to
get into the code base.
Like there were huge discussions,
they were blaming old
style goto statements
and talking about changing
the error handling idiom
to something more reasonable.
There were talks about just switch on
your compiler warnings, get the warning
that the code unused, like who actually
gets the compiler warning turned on
when they are turned off by default?
Like really, we mostly skip that
when we have deadlines,
big projects, whatever.
There were some more speculations
on proper indenting or whatever.
Actually the tools could
capture this problem
in many many ways and we
could find the indent,
we could eliminate it.
But still the story was
that we got the problem,
they got it fixed, everything is fine.
But still we have now a very famous thing
called goto fail.
Another example here is we got used
to think about C++ like about the language
where we always have types.
But do we always for now?
And the example shows that actually no.
Because to get the type
of the operator variable,
operation variable here, you actually have
to calculate what's going on there,
so what's the actual usage.
So here it's float.
If I use doOperation from,
and pass the integer
there, it will be integer,
so it actually depends on the usage.
And that means that the code in C++
getting more complicated, in
terms of reading the code,
and actually the problem
is that we are getting
more mathematical and functional concepts
and it sometimes makes
it even easier for us
to make a mistake.
But we have some things that are here
for ages with us and that actually
makes us a huge field for mistake.
This is example that
shows that to understand
what is written in the last
line of this test function,
you actually have to know
the value of the magic macro.
Because depending on the magic macro
x is either type or an integer.
So it's either a type or not
depending on what is provided.
Somewhere, maybe in the header file,
or deep in the hierarchy,
we have some magic context variable,
some magic context macro value.
And that means that decoding this line
completely depends on this thing happening
somewhere in the library or whatever.
And that's a huge room for
making a bad code actually.
So what I'm gonna talk here is which tools
do we have in the eco-system that help us
to provide C++ of better quality.
Some of them are new,
some of them are old,
some of them are just appeared,
or some of them are with us for ages,
and some we're still lacking.
Let's try to overview and to find out
what we're lacking and what we have.
But before we do that,
let's first talk about
what's the code quality?
If we are gonna talk about the tools
with the code quality, let's find out
what the code quality is actually is.
There are lots of definitions
for the code quality
and these are maybe two very famous,
this is just the collection of words
like the code should to be easy to read,
actually because you need,
if you need to maintain it,
if you need to support it,
you have to read it to some extent.
It should be easy to use
and should actually work.
That would be good enough.
Here, if we talk about the efficiency,
for example, there's IT
software quality consortium
that issued the right
definition on the slide.
And efficiency in their
definition could be whatever,
like it could performance,
it could be human resources,
so efficiency in terms of human resources
for all these tasks.
But I personally prefer another definition
for the code quality,
and I guess this is it.
This is the code quality.
Originally that was the
picture about the code review,
but it's not only about the code review,
it's about everything.
It's about using your code,
it's about testing your code,
it's about maintaining your code,
moving it to the production,
like deploying it, whatever.
The code quality just
measures by this number.
Okay, let's guess that for now we have
the definition for the code quality.
Now let's talk about tools.
I will again reference Bjarne here.
So, in 2015, when introducing
the C++ core guidelines,
he talked about tools, and I guess
that for the code quality
the tools are essential,
we can't do anything with the code quality
without the tools.
Because we could keep a
lot of guidelines in mind,
we can do whatever until we have
our deadlines back yesterday.
A huge team, something happening,
our manager is just jumping around us,
and at that very moment either a tool
is throwing something in our face
to protect us from the bad code,
or we just completely forget about it.
So talking about the tools.
I will go for these five categories.
So I strongly believe
that for the code quality,
the people sometimes think
about the code quality
as about the code analysis tools.
But that's more.
So, I will talk about the
code style and code formatter.
I will talk about code generation.
Code analysis for sure
will be here in this talk.
Refactoring and unit tests.
And I have some bonus in the end.
Let's start with the code style.
Code formatting.
What's the problem in C++
for the code formatting?
Let's look at this example:
test function with two
lines in the end, a and b.
And what's actually the problem
with formatting this code?
Like these two lines in the
end of the test function,
are they something similar,
or are they different?
If you look for a while, you can find
that one is a C-style cast
and one is just an expression.
And that means actually that you have
to format them differently in many cases.
Like that's a very common style.
Like when you have a cast,
you have this kind of space
before the value you are casting,
and if you have an expression,
you have all the spaces.
A very common style.
But to format in this way,
what does it mean for C++?
You need to parse the code.
I hope you're starting getting the idea.
To format the code, you can't just
like read it as text,
you have to parse it,
and that's actually the thing
that is very much different for C++.
Like there're a lot of languages
which you don't need to
do a full parsing for
just formatting the code.
If we talk about the formatting,
actually there are more things
that are making it tough
and because we have
a very long story with C++ here
that's existing for many years,
we have a variety of standards existing.
Like there are Google code style,
there's LLVM/LLDB code style,
GNU, Qt, Chromium, whatever.
There is also some custom code styles
that exist nearly in every company
that is doing development in C++.
The problem is that sometimes
these styles are different in essence.
I mean not that this
is just a different set
of parameters, like how
to set spaces or indents.
Sometimes they are just about
completely different things.
Some are talking about
the name conversion,
some are talking about spaces or braces.
So you can't easily convert them
because they are talking
about different things.
Okay, so this is the reality
of the formatting for C++.
Next question: when to reformat the code?
Actually there are lots of ways to go.
You can format on file saving.
You can format on the
fly while you are typing
the code on your laptop or your computer.
You can do a pre-commit hook.
A very popular thing.
And you can use some kind
of an explicit action
like select some piece of code
and call some kind of formatting.
External tools, they are usually doing
this kind of file on save formatting,
or explicit actions, or you can put them
on pre-commit hooks.
IDEs are mostly about
on-the-fly formatting.
And there's actually good and bad point
for IDEs in that sense because good point
is that IDEs are mostly having the results
of the parser and so they could format
using these parsing results.
The bad point is that
quite often they have
to deal with the incorrect code,
and you don't want your
screen blinking completely
while you are typing just
because the reformatting,
it's happening on the
fly so they have to wait
at least to some expression
ends and then reformat
or do some more stuff like that.
Okay, if we talk about
the formatting tools,
I guess everyone here is
aware about the Clang format.
That's nearly the kind of a standard
that we have for now in C++.
That's the Clang family tool.
And it's actually a command-line tool,
quite easy to use.
So you could do many good stuff with that.
You could put this kind of commands,
like Clang-format off/on, to tell it
that please don't reformat
this piece of code.
There is a very good
thing about Clang format
that I'd really love is that it has
these kind of library profiles.
So what's the problem
with the reformatting
the whole projects with
all the libraries included?
You don't want actually the libraries
to be reformatted in different styles
because they could be
written in different style,
different from what you
use in your project.
Clang format actually
allows to different profiles
and to different directories,
and you could just like,
even some good library developers,
they provide their file for a Clang format
along with the library itself
in any kind of git or other repository.
That's actually great and Clang format
is integrated in many many tools for now,
so the basic things like,
there is a Vim integration
that provide you with the shortcuts
and you could select a region
and the Clang format integration
then will do a very smart stuff.
It will find the next
bigger syntactic entity
that it actually could
reformat and reformat it.
Or it could do some kind
of safe hooks formatting.
There is integration in
Emacs, also that provides
the shortcut to reformat the line
or any kind of a selected region.
There is VS Code integration
for reformatting on save and even type.
And there is ReSharper C++ integration.
It's different from
others because the guys
suggest converting the settings
to their own formatter tool and then just
formatting with their own formatter tool
but with the settings
from the Clang format.
I know the guys from
NetBeans who are working
on some Clang format integration
and doing some both
formatter like Clang format
when you call it explicitly
and their own formatter
with boarding the settings
when you are typing.
But you see these are
like good things in green,
but there is one thing
in red with Clang format.
The Clang format, while it's a part
of the Clang family, it's not using
the proper Clang parser.
It's using a fuzzy parser.
And this is reasonable actually
because therefore performance
of the formatting,
they don't want you to wait for ages
until the code is reformatted.
So they are using a fuzzy parser
and the problem with this parser
is that it actually doesn't
go into header files
so you could confuse this
parser actually quite easily.
But that's the solution they have taken
to provide something quick,
but that could be actually confused.
But you should know and be ready for that.
As I said, IDEs, on the
contrary, they are usually
doing this kind of built-in formatter tool
that is working on the fly
just formatting the code
while you are typing.
And usually the biggest
issues for all IDEs
are this kind of
import/export/converting issues
of different styles, exactly because
they are all about different things.
So the IDEs should provide the whole set
to know how to convert
all the settings properly.
Talking about formatter
I would like to mention
one project that we
actually did in GetBrains
for Hackathon in 2015.
That's not a production solution.
I hope it could be but
still that was a task
that the guys just coded at Hackathon.
The idea was to extract the style
from the actual code
formatted with some settings.
So you took the code
formatted with some rules
and you ran some algorithm
that just extracted
the settings and get some
kind of a setting list
that more or less
described this code style.
There was a genetic
algorithm working there
with some fitness function
that was the modified function
of lexical distance between texts
and some optimizations
to make it work quickly.
The good output was that this algorithm
actually helped us to extract Google
and styles and to use them in
as the pre-defined styles.
So we made some of concept.
And I really hope we could make
this kind of tool working for everyone
because that's really cool, like you could
just feed some kind of
texts formatted properly
to this tool and get a style out of it.
Talking about the code generation,
let's first think about
why to generate the code.
Actually quite simple.
Because the code generation is the way
to easily keep to some kind of guidelines
just to force them on
just so make the code
to be autogenerated.
So to force some common patterns
and to avoid some typical
errors that could be there.
You could generate
actually lots of things.
You could generate file templates,
at least some kind of a comment
in the beginning of the file that's just
describing that this file was created
by some person for some project, whatever.
There could be some comments,
for example Doxygen style stops
that you could generate for functions
and fill with proper
information and then get
the whole documentation for your project
generated with Doxygen.
There are lots of different code snippets
generate like for
constructor or destructor
function implementation stuff or whatever.
So, if we talk about the IDEs, they have
lots of things that they
usually allow to generate,
like I guess every IDE for now has
some kind of a code
snippets that you could use
and you can actually add your own
and that's great because
you can add some patterns
that are typical to your
project and your company.
The example here, this
very long piece of code,
but actually only the class human
and three floats in the beginning
were actually typed by hand.
And all the constructors
and all the operators
were actually generated
automatically by the tool.
And that's actually the good thing
so you could just generate
all this piece of code,
quite a long one, and actually just get it
10 seconds, and you can provide
some interesting settings
generate for example,
if to use STD type for
compressing operator or not.
So, talking about code generation,
there are actually some
more specialized tools
that are there for some
specific tasks like protobuf.
that actually is some
kind of an extensible way
to serialize data and
provide getters and setters
to take care of writing
and reading operation
like hiding some implementation
details from you.
There is some transformation
tools like cog
that some people are still using.
And there are of course Clang-based tools
and I'm actually
surprised that I don't see
a lot of them now on the market
because the Clang, if
it could provide in AST
then it's quite easy to generate
from this AST whatever you need.
And if I'm talking about
generating from AST
I couldn't just mention
the metaclasses here,
because that's exactly
the code generation.
that's exactly the thing that helps us
to avoid boilerplate code and to keep
to some conversions, to
force these conversions,
and to get some more types
and more flexibility.
This is just the example from the proposal
for the interface shape that
is in the top right corner,
and the code for the metaclass itself.
Then what we've got, what we are getting
the end of the compiler
in the bottom right corner of the slide.
But what does it mean
actually for the tools,
this is the code generation
but to implement it
we'll have to first of all get reflection
and compile programming and the standards.
Hopefully we could get it
in some reasonable time
and then we could get this
kind of code generation,
the tools could support us.
So we'll see.
That's actually some kind of bright future
for the code generation that I see
that's a huge step forward in comparison
to what we have now, just
generating some getters
or setters, or implementing
some functions.
Okay, that was about the code generation.
Now let's talk about the code analysis.
Talking about the code analysis,
there are actually two big groups.
There is static code analysis,
there is dynamic code analysis.
And talking about static code analysis,
there are actually also
two big groups inside:
there are just compiler warnings
and there are extra checks
that the compiler can do.
Let's see what tools we have for now,
at least some of them.
So we have the Clang analyzer.
That's a very powerful tool.
That's just a part of the Clang,
and that's actually great.
So you can just your
current Clang compiler
with some -analyze options
and provide some checks
that you would like to
be checked in your code.
And there are actually
about 40 checks available.
There are some core checks,
there're some new/delete leaks,
there're some dead code, nullability,
and security checks, like for example
using float as a counter in loop.
And this is actually cool,
like the core checks,
they include something
like division by zero
or to null dereference checks.
So there's some kind of basic checks
that you could run on your project.
and that's not only in Clang Analyzer,
there's also another
tool in the Clang family
that you're probably unaware
about, is the Clang-Tidy.
And Clang-Tidy actually could be called
with analyze option and the Clang Analyzer
will be called from the Clang-Tidy
and all the checks will be there.
But Clang-Tidy is much more.
It's actually more than
200 checks on board.
I'm especially mentioning
the modernized checks here.
Because this is really cool, like this is
how to make your code more modern,
how to force you to use the new features.
And that's actually what
the tools are here for.
Forcing you to use new language features
while you're a little bit apart from them
and saying okay, I'll wait for others.
But the tools say no,
please do, please like.
Replace std::bind with lambdas,
please use auto in some proper places,
please replace C standard library headers
with their C++ alternatives, whatever.
So, I'll try to run this demo.
So that's just a Clang-Tidy
working on this piece of code
and just checking and adding
their fixes to this code
so this is just the
integration from our tools
but just to show you how it looks
just not to run from the command line,
but you can run Clang-Tidy
with -fix option
from the command line
and get the same result.
But again, like Clang-Tidy is much more
than Clang Analyzer it has started
some work in the direction
of the C++ core guidelines.
There are not that many,
I guess around 16 for now,
but still they are evolving
and moving forward.
There are some Google checks there.
The good thing is that you
could add your own check.
Imagine you have something
specific to your project
so who is checking that?
No tool, no general market tool is doing
some check specific for your project.
But you can just add
your check to Clang-Tidy,
it's quite easy to implement one,
and then just get it
work with a Clang-Tidy
and all the rest of the profiles
that you have in Clang-Tidy.
Talking about the code analysis, of course
I have to mention the core guidelines.
So as I said, for now, if we talk
about the tool support, so the Clang-Tidy
actually got around 16 checks on board
from the C++ core guidelines.
Of course that's just a very little part
of the core guidelines but still.
So most of the tools on
the market currently,
just there are actually two ways.
You either use the Clang-Tidy integration
and then you get the C++ core guidelines
for the Clang-Tidy.
That's the way taken by
Eclipse, CLion and NetBeans.
Or you do a native support
for C++ core guidelines,
like CppCoreCheck in Visual Studio,
and Cevelop has their own implementation
for some C++ core
guideline checks as well.
So, more or less we are moving forward
to getting these core guidelines checks
on board of our tools,
to make it actually work.
There is one more tool on the market
that I have to mention here specifically,
that's the CppCheck.
That's quite an old one even
it exists for 10 years already.
But still the latest release
was in July this year,
so it's still evolving.
It has approximately 170
checks and they cover
pretty much good list of things,
like check variable scope,
out-of-bounds checks,
some exception safety, some memory leaks,
some mismatching
allocation/delocation things,
some size of arguments checks
so that you are not
providing negative there
or something more than
a type, and some others.
The good thing about CppCheck is that
since it exists for ages, like 10 years,
it's quite old, it gets lots of plugins
for various IDEs.
Like there's a plugin for
Eclipse, Visual Studio,
Creator, or Clion.
And it's still evolving
so quite a nice tool.
Maybe not checking that many,
especially for the modern C++,
but still can do some
general checks for you.
There is also a tool called Coverity
that is used by many people here I guess
but mostly because it's a very good tool
for some bigger companies
because they have
a very good integration with the CI.
So with the continuous integration.
I know that some people even use Coverity
in the way that they just somewhere
the checks are running and
they just get the outputs
so they do not interact
with the tool at all,
they just got the result and like see
what they got in the end.
So it's not like many
checks approximately 80
but also some basic
coverage for C++ is there.
There are actually much more.
So there's the PVS-Studio that's doing
lots of checks for C++ that's paid tool.
There's Infer from
Facebook that seems to me
very interesting because
they got this idea
of formal verification behind the tool
that some kind of different
from the general static analysis tools.
And they actually have that tool built
into their code review
system and that's a thing
that we really like because we do the same
for our tool for our outsource
tool for Java and PHP
like we are running the code analysis
and the code review tool
so that the code reviewer
could benefit from the
code analysis as well,
could see the results of the code analysis
in the code review tool.
And there are actually
lots of other things
like I guess all the big IDEs now have
some kind of a code analysis implemented
on their own engine, like
I mean the NetBeans has,
there is a coding engine in Eclipse.
Clang actually doing this job in Xcode.
And in CLion we also have this thing
that is called Data Flow Analysis
that I would like to
specifically mention here.
Because I guess it's very cool.
It actually checks how the data flows
for your program and try to make a guess
if something might be wrong there.
That's not the thing that
the compiler could check
because that's some
kind of a runtime check,
but it's done as a static analysis tool,
like it's done inside the static analysis
engine in the tool.
In these two examples it's showing
some condition is always true,
or an unreachable code example.
So data flow analysis could be actually
quite difficult in C++.
So this kind of things will infer
all possible paths but still if you run it
in the background and once you could get
some reasonable result, then cool,
you just catching some possible bugs.
Okay, that was about static analysis.
Now let's talk about the
dynamic code analysis.
Actually there are lots of tools we have.
I would like to mention
two big groups here.
One is Valgrind and one is sanitizer,
and the reason I mention these two groups
is because they are completely different.
The idea of the Valgrind
and that it's running
just your code on a kind
of a virtual machine.
So it doesn't require recompiliation.
It doesn't matter which kind of a compiler
you were using to compile the executable,
and even whatever, which
language you were using,
whatever architecture you were using.
So it just provides a
kind of a virtual machine
to run this code.
That means some problems of course
because that means that
the slowdown will be huge
from 20 to 50 times, and actually Valgrind
is also running one thread at a time
which also makes the process quite slow.
But it can detect several
interesting things
like uninitialized memory and other things
that I'm gonna talk further.
Sanitizers are different.
They require the recompilation.
But once you've done that, it actually
could just run your
executable in the usual way
and then get some information after that.
And that actually means that the slowdown
is much less, so it's
from two to five times,
but it requires some particular compiler
so sanitizers appeared in Clang first
and then GCC later so
there were some delay
with appearing in GCC
and it has some limitations
for architectures.
And unfortunately, none of these tools
are working in Windows.
So there are some tools for Windows,
separate tools, but I'm not
gonna actually cover them.
So talking about the Valgrind,
this I have already covered
so I will jump to next thing.
So the first thing that
comes into people's mind
when they think about the Valgrind
is actually the memory check.
Like when they ask for the Valgrind
quite often they just want a memory check.
So just a tool that will find out
some illegal read/writes
and frees operation,
some uninitialized values or some derived
from uninitialized
values, some overlapping
of some destination
memcpy and other functions
which can be critical,
and some other checks.
And the memcheck exactly the tool for that
so it provides the output in the way
like that in the slide.
But Valgrind is much more
than the memory check
and that is really cool about the tool.
Because it has the cachegrind
that is a cache profiler.
It has some accuracy points actually
because that's the simulation,
that's not taking the consideration
any kind shadowing done
by the operation system
or any kind of external
process or or whatever.
But still you could get
some general understanding
from the output.
And it comes and very often used
with the tool called Callgrind.
That's also part of the Valgrind.
The tool that actually recalls the history
in your program, and
there is Kcachegrind tool
that's some kind of a nice viewing tool
for the output from the Callgrind.
And you can just look
how it was going there
and what happens.
It has some problems with recursive calls.
By default it just provides information
like cycle there, and you could put
some additional settings
to skip some function calls
or just distinguish the recursion level
and stop at some point to make it work.
There's actually more inside of Valgrind.
So there is the Hellgrind, the massif,
and the Hellgrind is a tool
for thread error detection actually.
So it's catching the
things like the misuse
of the POSIX thread API,
or inconsistent log order,
or some data races.
So you see there's like that's not only
about the memory checks,
that's actually much more.
So talking about the sanitizers,
I'm not sure, maybe that's the only thing
that is still keeping
Google and Apple together
because that's the Google code
but it's implemented in the LVM.
So the sanitizers are actually supported
in Clang from quite an
old version from 3.1,
and some sanitizers started with 3.2,
and GCC starting from 4.8.
So if you use some old
compiler like, sorry,
you are not aware, you
can't use sanitizers
with the old compiler.
but if you use some versions
like that you are fine.
So, there are lots of
nice tools there as well.
So there's basic things
like address sanitizer
where you just recompile your program
with -fsanitize address and start
catching this kind of things
like out-of-bound access,
or use-after-free/return,
or use-out-of-scope,
and some double-free errors,
and all things that you could,
crazy thing that you can do
with memory, C++ program.
Like this is just example of an output
so also you are provided
with the stack trace
so all the information about address.
Very similar to what actually
Valgrind does in essence.
There is a thread sanitizer
that's a data race detector.
So actually it can catch some really good
data race issues
and like the two threads
access the same vaiable
concurrently and one is right
and so that's an easy way to
catch this kind of problems.
There is memory sanitizer.
The memory sanitizer is
supported only on Linux
and I'm not sure about GCC thing
GCC support for memory sanitizer.
The things that I really
like about the sanitizer
when I first heard about it is
they only find here sanitizer
like C++ and some kind of unsafe language
in strong sense because
the compiler allows you
this kind of undefined
behavior to make a job easier.
The undefined behavior
means you know nothing
about your program running in the runtime
and so have some tool that is available
of catching some at
least general undefined
behavior cases is actually very good.
Sanitizers also provide some API
for data flow analysis
and some coverage API.
So that's not a tool that just trying
to provide output that just API
that you could use to build
your own tool with that.
That's about it then.
There are also this kind and tools
and others, but they are
just falling into one
or another group, like either
running a virtual machine,
or just recompilation of the program.
Okay, let's move forward,
let's move to refactoring.
I would divide it into two sets
like there is a basic set of factorings
that we all expect from at least
all the tools that are working
with the language for us,
some of rename, extract
function and inline.
And there are some more
profound refactorings
that actually could be done.
Some kind of a change signature,
or extract whatever you need,
like constants or a parameter,
or pull and push members
for the hierarchy of class,
maybe some modernized things.
And I would say that actually
IDEs are trying to cope and
doing a pretty good job here.
We want what's emailed by guy
called Richard Thompson who implemented
this nice testing suite.
This is the GitHub where
testing suite is available
and it actually runs a set of test cases
on various IDEs to check how they are good
or bad for factoring.
So he has hundreds of test cases there
covering lots of things
like changing signature
and various tricky cases for C++,
or extracting, or inlining
macro, or whatever.
So he actually checked
CLion Clang Modernize
that is Clang-Tidy Modernize,
Resharper C++ Visual Assist
in Visual Studio 2015,
and he has some more
plans for other tools.
And he has all the results logged there
in this GitHub repository
so you can just compare
and see how the tools are doing.
What I love about this
guy is that actually
after writing these test tools
he actually filled lots of issues
in our issue tracker for each
case linking to the GitHub
so he is really cool.
But that's very interesting
at least in terms
of comparing how the tools are doing
with the C++ and doing
some tricky cases for refactoring.
I also have to mention
here the Clang-rename.
The tool is actually quite often mentioned
by our users so that's why
I actually mention it here,
and it's a Clang family tool,
and it's integrated in
many editors for now.
But it's just renaming
inside one translation unit
so it doesn't cover the whole project.
But still there are
interesting things happening
with refactoring and Clang.
For now there is Xcode
9 who is first time ever
implementing refactoring
for C++ on top of Clang
and the guys are not
showing the whole code base
but still publishing actually
quite a lot of code in the open source.
So that's really just in time now
and it's interesting to
see what they've got.
For now they have some just basic things
like renaming and
extracting and I'm not sure
about the inlining, don't remember.
But still that's an interesting thing.
It works not on the translation unit,
it works in the whole project,
and this is actually a cool one.
So talking about the unit testing,
why I talk about the unit testing here
is because you can't do
any kind of refactoring
or modernizing stuff or changing your code
after code analysis without unit testing.
Because if you don't do
that, how do you know
that you haven't broken actually anything.
And we did a kind of
research for the developer
like a system in the
beginning of this year,
and we're covering not only our users
but some external users who are not using
GetBrains' products,
and we got some results
for C++ as well.
so there were more than
5,000 plus respondents
and not a surprise, the Google tests
are on the first place with 45%,
Boost tests coming next with twice less,
and then comes all the rest.
But that's like quite expected I guess.
The Google Test is the
very widely used for now
and the only maybe issue with them
is that you have to
download the Google Test
and to link them, like
to compile them properly,
so they do not advise you themselves
to use the pre-compiled
version of the Google Test
because you can have
problems with the settings
with which the pre-compiled
binary was built of course.
So you have to download the Google Test,
you have to build them with your project,
with your settings, and
then you can use them.
But most of the IDEs for
now supporting Google Test
out of the box and that's good,
so they provide some build test runners
or some information to help
you with the Google Test.
Google Boost tests are
also quite popular for now
and they can be used actually in both ways
like header only or
linking with the binary.
For a big project I guess
it's not recommended
to use the header only
way because it increases
the time quite heavily.
But still, like others are catching up,
so we'll see what unit testing framework
will have left in five or 10 years.
And actually promised a bonus here,
and the bonus here is a package management
that we are talking a
lot at this conference
and I'm actually for
one side I'm surprised,
on the other side I'm quite happy.
So what's the problem?
We are in C++ and what's the problem
with package manager?
The problem is that we
have one definition rule,
so it's not that easy just to use
a pre-compiled binary
because we can mess up
with the compiler flex
and compiler versions.
So the usual way how
it usually works for us
to get a library into your project,
you have to find the sources somewhere,
and it's usually not a very difficult task
but still you have to download them.
You have to build them,
and that could be trickier
because who knows what build system
the library authors using
for building this library,
which scripts they have,
which dependencies they have.
It's good you have an instruction
provided on the GitHub, like
how to build the library,
but sometimes you're spending hours
and trying to build the library
getting all the dependencies,
and then you have
to include this library
into your project build.
And that's even trickier because
you may be building
with for example CMake,
and the library is building
with something other,
and it's good when the library offers
that kind that they are
providing special CMake file
that's possible.
even if the library is
not built with the CMake
they could provide a special
file that you can use
to build this library into your project.
But what if the build
were completely different
so they were using some
completely different
procedures there, it
could be a tricky task.
And actually for C++ we have
a huge variety of the build systems.
That's good from the practical point
but that's bad from the
point of a package manager.
So if we talk about the
package managers solutions
there are several
different categories here.
So it could be language level
or it could be external.
It could be build-system
agnostic or it could be
built into some particular build systems.
It could be a source-based
or a pre-built binaries
which is impossible
just in that way for C++
or it could be combined,
which is more reasonable.
And it could be system
or language specific.
And if we talk about the
system package managers,
the problem here is that
there're lots of them
and they are different, and so
it's completely impossible
for library vendors
to pack their libraries
for each system manager
that's much different from each other,
and system managers,
they actually quite often
system-wide, but maybe you want
a project-wide package manager.
So if we try to look for this group
and to see what we have,
actually I'm not sure
if you all heard about it but there
a very much surprise when I heard
that there was a proposal
for a packaging system
in the language.
And it was done a year ago by Blizzard.
And it's completely language
level packaging system
for C++ proposal, so
it's providing this kind
of using key words, this
manifest for libraries,
this options for the
packages, and all the rest.
There was even that Clang trunk
where they started implementation.
The original Clang trunk
actually didn't get
that much attention but there was a fork
from another guy who implemented
nearly half of the proposal.
So that was quite cool.
But still there are a
lot of work to be done
in this trunk still so there is like
no models, no versions supported,
so lots of things to be done still.
And there was like some
bright future described
in this proposal, like you first starting
getting the packages from the cppget,
then you have a default public repository
with all the libraries, with everything
just placed, and you're
just using the language
to get the packages and get the libraries
in your project.
That's a bright future that
didn't happen unfortunately.
But from my point of
view, that's a good thing
that that didn't happen
because I personally
don't want a package
manager inside a language.
We have so many things happening
inside the language already that please
stay apart from the package manager.
If we talk about other
options, so there is a conan
and I guess Diego delivered
bright talk yesterday
showing how the Conan works for the whole
artifacture infrastructure
that they got from the JFrog.
And that's a very nice thing
like the nice package manager.
So it's build-system agnostic.
It has some predefined
helpers for the CMake still.
And so it can work on many platforms.
It can code with several languages.
It's not only about C++,
there is also Python, Go and Fortran.
And it can download binaries
or it can build from sources.
And you can have
repository or you can have
some local repository, for
example set in a company.
That's like a very good tool
and so if you miss the talk from Diego
just catch the recording
because he was like
showing a very nice
workflow, how it all works.
There is also Hunter.
That's a specific
CMake-based package manager,
also working on several platforms,
and it has this nice HunterGate,
like a description that is the whole list
of URLs of real packages and you can just
tune it and map some
version to some other URLs.
And so that's quite a nice thing
that you can play around.
And they actually have
lots of packages supported
so more than 20, including
all the famous packages
like Google Test and
Google Mock, and Boost,
and Catch, and Android, LLVM, whatever.
This is the different ways
of how many package manager for now,
and I guess we'll have more of that kind
and I really have big hopes
for package management,
and we'll see how it evolves
and which actually
solution wins in the end.
So that was it about the package manager
and actually that was it about the tools
I wanted to talk here.
I would like to draw up your attention
to some references here.
IF you're interested in
some particular links,
they will be on the slide
so you could catch them up later.
And now time for the question
I think we still have two minutes.
(clapping)
Okay, any questions?
Yeah, just come to the mic
so that everyone could hear you.
- [Man] CLion, as I understand,
it's written in Java.
Is there a plan to provide
a C++ implementation?
Like to boost the speed and performance?
Good question for the booth.
Yeah, it is.
So CLion is on top of
intelligent platforms.
It's part of Intelligy family
and it's written in Java Orbit.
You know we don't see
big problems with that
like we're doing tools in
Java for 17 years already.
We are good at that.
Believe us.
More questions here?
Yeah, so we could like talk later
so just don't be shy, come.
So if you're shy to
come to the microphone.
Okay, so thank you anyway!
(clapping)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>