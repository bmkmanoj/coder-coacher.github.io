<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Michael Caisse “Using Spirit X3 to Write Parsers” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Michael Caisse “Using Spirit X3 to Write Parsers” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Michael Caisse “Using Spirit X3 to Write Parsers”</b></h2><h5 class="post__date">2015-10-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xSBWklPLRvw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome see some filling room familiar
faces I guess two days wasn't enough and
you get me for a third alright right now
we're gonna talk about spirit and in
particular we're gonna talk about spirit
x3 it's the next generation of spirit
spirit is a parsing and generation
library in general the v2 version of the
library has both parsing and generation
where you can parse into an ast and then
you can later take a data structure
describe a grammar and then output that
ast data structure into a stream of some
sort supports both text and binary type
things this discussion will be primarily
about x3 which only has a parser and the
parser only not the generation inside
the library is a boost library it's
written by Joelle de Guzman Joelle works
with Kiera Consulting and we obviously
then spent some time supporting this
thing let's talk about why we have an X
3 so X 3 is the next generation of
spirit it's using modern C++ 14
constructs internally that's given us
some things one thing is hackable simple
or internal design we're worried about
trying to keep things easy inside and
and v2 has become kind of a monster it's
a minimal code base very few
dependencies compiles faster like a lot
faster if you've ever used spirit v2
expression templates can really cause a
lot of compilation headaches and the
instantiations of all of these things
will will eventually slow your
compilation down we use some different
tricks where you're using a DL tricks
this time and we'll see that in a little
bit better error handling a lot better
error handling for plugging in your own
error handlers and we have an optimized
attribute processing so before attribute
processing was pretty good I'm actually
really good and now it's even better so
let's look at some concepts
it is a domains
cific embedded language that is what it
is the domain is parsing the embedded
part is within C++ via expression
templates and the language is peg which
is parsing expression grammar so it
implements peg if you don't know what
peg is that's fine if you've seen an e
BN F type grammar before really only any
grammar definition if you kind of squint
your eyes they almost all look the same
right and so this is this is gonna be
for pig this you just give you give you
some ad hoc parsing things how many
people have code that might look like
this somewhere in your codebase yeah
everybody it's always everybody so yeah
this is this is pretty normal right and
and it starts off innocent typically but
at some point it just falls apart and
you're trying to you're trying to track
down all kinds of state without a state
machine using things that just really
really aren't the best way to to take
care of this type of a problem so
sometimes what you do is you say oh this
might be better I'm going to use a reg X
reg X is like the most innocent thing
when it starts because it's this long
and you can read it until you realize it
doesn't cover the things you want and by
the end of like the first week you're
the only one who can read it and next
month you can't read it anymore
so reg X is bad for journalized parsing
right it's got its place it does its
thing but it's not a partial so we would
like to do something else so here's a
peg grammar for email it's not really a
peg grammar for email but it's gonna be
for us we're gonna deal with it as what
email is so a name letters A through Z
there's one or more of those and then
there's a dot with more letters A
through Z one or more of them and there
are zero or more of these things that's
going to be the name part what is a host
same type of pattern dot and followed by
in our case it will be either a comm or
an org or net and what is an email then
an email is a name at a hoe
this is easy to reason about easy to
understand and it would be nice if we
can write our code the same way
underneath we have now the spirit x3
version of this we're not able to put
the operator plus at the end we have to
put in the front and so in order to take
care of some of the rules within C++ we
move some things around so we have
characters a through z one or more of
those followed by zero or more dot
that's followed by one or more
characters this is a name looks a lot
like this what is a host well same type
of thing we use a bar and sub slash comm
org net and then what is an email an
email is a name followed by an @ sign
followed by a host this is readable I
know what it does and the idea of
writing you know having a good parser
and specifically if you're going to
write a DSL domain-specific embedded
language is to write one where you can
be declarative right and so now we have
a declarative statement of what an email
is it's this thing this now has created
a parser for emails this is what we want
to get to so let's talk a little bit
about what parsers are parsers for us
take some stream of values in in this
case we have a float parser it will
parse this if I give it it foo it will
not parse that because the float parser
doesn't like foo I can compose these
using what we would call a rule so
literal sized parser followed by a float
parser would be able to parse size space
42.5 so these compose together we refer
to these as rules rules in this case we
have size followed by big the float
parser portion of it fails rules can be
composed with more parsers and more
rules to create other rules the idea is
that we want to create rules and
and they composed those and continued to
compose them into larger and larger
things so now we have the original one
that we had which was a literal size and
afloat parser followed now by a comma
followed by color and a string it would
be able to parse this
alright so parsing things is interesting
but typically when we're parsing
something we want data back out we would
like to do something with with the data
that came in and put it into a data
structure that we can deal with so 42.5
we parse this we would like to get a
double that is 42.5 this thing on the
way out is called the synthesized
attribute this parser has synthesized
this double for us feel free to ask
questions any time ok this rule that we
had before it's parsing the literal size
followed by this float parser we would
like this rule to also sent the
synthesize a 42.5 and so we want to be
able to explain to our rules what it is
that they're going to synthesize what it
is that they're not going to synthesize
all right if you've used the two before
we don't have grammars anymore we just
have composition of rules grammars were
kind of a wart that was added in order
to take care of lifetime issues with
composing rules and and keeping some
things around due to the way that the
internals were formed previously we
don't have this anymore and so grammars
you can just not think about if you
worried if you've worked with b2 before
you can just compose rules compose rules
compose rules it's a lot nicer to deal
with alright let's take a look at some
parsers so the idea here is we're gonna
take a data stream we're going to bring
that in and parse that into an abstract
syntax tree but that's the goal we want
bring stuff in and have a data structure
back out that we can deal with and work
on inside of our code so inside the vex
3 what 2 parsers look like well this is
a parser that will parse in it this is
one that parses a double here's one that
parses a literal foo we can use parsers
with the x3 parse API so I have an input
of 1 2 3 4 and I can say parse passing
it a begin and in iterator and then I
can pass it the actual parser that I
wanted to use and so this will parse the
the 1 2 3 4 or any int if I wanted to
parse doubles then this is a double so
what kind of parses exists there are a
lot of canned parsers these are some of
them we have ones that can parse things
like n2 and double full the different
types of binary things of word types we
have literal parsers this will parse a
negative 42 or an unsigned 82 this will
parse true or face or dead beef the the
literal parsers all form the same type
of thing where you have the parser that
will parse anything and then you pass it
actually the value they don't want to
parse and now you have a literal parser
instead they follow the same pattern
here's some of the character partials we
have so charm score will parse any
character here are the literal versions
or just bar will parse the bar so parse
a through Z this will parse a through Z
the number 8 and then capital A through
Z
parsers have a special knot so this will
parse everything that is not a and it is
more efficient to use this than some of
the other constructs that you might want
to use
so let's look how we combine parsers
because parsing and ant is not very
interesting so if I want to combine some
parsers here I have a t6 and a space and
then one two three four point five six
I can parse the int here's the space
here's my double and we use the right
shift operator and when you see that you
read inside of inside of the language
you you read it as followed by and so we
read this as I'm gonna parse an INT
followed by a space followed by a double
yes so the question is does a space here
match literally a white space or the
space and it does in this case where
we're parsing and matching just a space
in a moment we'll talk about skippers
and how we can skip and to find skipping
of for example white space alright so
there are a variety different type of
operators that we can use in order to
compose parsers together and these are
the operators the first is sequence so
sequence we read as followed by a
followed by B it looks like this inside
a peg and the a followed by the B in
this case int followed by space followed
by double which we saw before I would be
able to parse this or char followed by
the colon followed by ant would be able
to parse this we have alternative either
a or b are allowed and they're evaluated
in list order this is this is one of the
things about peg versus some of the
other types of definitions of grammars
that exist so it gives us a
deterministic behavior in peg so we're
gonna parse alpha followed by digit
followed by punked any of these things
will
work this is going to fail the parts
because it doesn't meet any of these
zero or more the clean start
instead of putting it after what you're
used to seeing it goes in front because
of operators for us so zero or more
alphas followed by an int would look all
of these reparse fine one or more alphas
followed by an int this is obviously
going to fail I don't have any alphas in
front this is optional so an optional
alpha followed by an int and so this is
going to fail because this is not an
optional alpha this is a whole bunch of
alphas that were followed by an int so
the question is would you do plus minus
alpha for optional one or more and
optional one or more is basically saying
zero or more so you just leave it use a
clean star trying to trick me
it's okay I cut up and sleep last night
all right
the and predicate basically provides
look ahead we can look ahead into the
stream without consuming it very
convenient thing to be able to do and so
if a matches without consuming any then
the parse is is good and it can continue
on to the next step and in case it
wasn't clear yet
a and B's up here are parsers or
combinations of parsers or composed
parsers right there there the thing and
so here an int followed by and then this
is the and predicate a semicolon this is
going to actually be okay but this is
going to fail to parse because it wasn't
followed by the semicolon
not protocol is just the opposite so for
followed by not an alphanumeric or an
underscore this will pass fine 40 will
not alright we have a few additional
things that come up a lot when we're
writing grammars and I'm we leave the
realm of PEG and there's no peg
equivalent for this but on there handy
so we've added a min one is the first
one is a difference and so the idea is I
want to match a but I don't want to
match B I'm trying to parse comments
these style comments so this followed by
zero or more characters that are not the
ending thing and then followed by the
ending thing that's a pretty common
pattern where you need you to do this
and so here's a nice and easy way so
this would always fail literal ob
Watanabe
followed by our less the ob wah well
there's no way to do this and so I'm
just kind of be careful as you're
writing your your difference that you've
made something that makes sense
well actually parts okay expectation is
is also something that is very different
the idea of an expectation is that
you're saying a is followed by B and it
has to be followed by B always there
will be no backtracking to find
something else if you have an a there
has to be a B right afterwards
internally an expectation point gives us
a lot of a lot of advantages with inside
of the parcel we know that that's
basically a point in which we can flush
any backtracking we can remove memory
that we've been scrolling along and keep
being there's a lot of things that we
can do internally as soon as we see one
of these they also are ways for you to
say that every time I see a particular
thing it's got to be followed by the
other and if it's not it's an error and
I would like you to say that there's an
error and let me know parser and and
provide some information
like you can get out where you are if
it's a if it's a file you might want to
know what line you're on or what
character you're in things of that sort
so expectation are there really great
things so in the case they here Oh
followed by K time we've got to have an
okay we can't have an ox and when it
says throw an exception internally
throwing an exception we'll look at some
of the error handling mechanisms how you
get those back out so the difference
between sequence and expectation is that
a sequence is a followed by B and if you
don't have a B you're going to backtrack
and see if there's an alternative that
might match it you might have an a
followed by a C and so that would be
fine right but with an expectation if
you say a must be followed by B it has
to be followed by B all right here's
another one list it's it's super common
to have lists of things that you are
parsing and so it's really just a
shortcut for a followed by zero or more
B's followed by A's so here would be an
example of an int and there's a list of
ents that are comma separated and so
this right here would parse nice and
easily and so lists of things are a very
common construct and so we have the
percent that we use for that again a and
B are any parsers or compose parsers to
do that all right so far good great so
let's take a look at at some information
here and how to how to put these things
together we've got some input string
here in which we've got some values
characters followed by a colon followed
by some more characters and their comma
separated so it kind of looks like we
have pairs of things the right-hand side
we might have quotes it quoted thank
Joel felt cool by the way is the crazy
Frenchman and he's just proving it by
the way because he's doing three
hours of lecture right now I don't know
so here is our input string what would
it look like to parse this well we want
to parse a name a name followed by a
semicolon sorry a colon I want to call
him a name followed by a colon followed
by either a quote or a name and this
thing well it's a list of these so I
have a list of these things now I've
swapped some things out for you instead
of parse we're using phrase parse and
down here I've added this thing called
space what I'm telling it is that now
I'm doing phrase parsing and I have a
skipper and the skipper is a white space
skipper it'll automatically skip white
space until one of these other until it
can't skip white space basically until
the skipper fails and at that point when
the skipper fails then the grammar that
I provided to it kicks in skippers or
interesting things they're just grammars
you can supply your skipper to be
anything you want just by supplying a
grammar another rule yes Wow I'll give
you a buck later so the question is how
do we define the name and the quote
space things like that we're gonna find
out right now so uh so let's look at
some rules rules allow us to be able to
do some things in particular they allow
us to name parsers so we can like reason
about them as named or quote things like
that lets us read our our grammar in a
reasonable way they allow us to specify
an attribute we would eventually like to
synthesize probably something out of
this and attach it to the rule it allows
for recursion you know it's pretty
pretty
in my world lease it's very uncommon to
have a grammar that doesn't recurse so
we want to be able to refer to the rules
again allows us to provide error
handling on error what is it going to do
an error would be for example an
expectation point a followed by B
and I didn't get a B what is it going to
do we can attach custom handlers when a
match is found so here we go
name is alpha followed by zero or more
alpha numerics alpha and l num are built
in spirit parsers so we're just using
two spirit part series that's what a
name is a quote a quote is well the
beginning quote character followed by
zero or more characters that mmm
that should say tilde and latex of
course ate my tilde and it made it a
space there's a tilde there followed by
a quote so we're going to basically grab
all characters that aren't quote and
then quote we only use auto for non
recursive rules we'll see a little bit
later this is like a shortcut to write
all this and just get up and going right
away yeah so in order to make the slide
nice and easy to read there are some
explicit usings in here in this case
this is inside of the X the boost spirit
x3 namespace
yeah so the shift operator eventually
this is going to get tainted by a parser
by a type that is inside of of the
spirit namespace and and then all
expression templates from that point on
work nicely for us so let's take a look
at what we do with rules here so here
I've got alpha followed by alphanumeric
oh good I got my tilde back and here's
our quote version and I'm going to add
this little thing in here
this rule is x3 rule and class name what
this is doing is creating a tag for us
that we'll never see again but we need a
tag that's unique and the tags are as
we'll see in a little bit later the tags
are the things that are going to allow
us to use ADL in such a way to pull a
bunch of things together and relate them
so we can have some lightweight objects
to talk about recursion with and things
like that that are not the definition of
our parser they allow us to look up the
definition of our parser later on
internally we really don't have to worry
too much about it as a general rule what
you do is you just like create a tag
name that's probably the same as your
your name here okay so this is how I'm
going to write my x3 rules yeah the tag
name I just talked about so let's take a
little closer look now at what we're
going to do yeah so the question is
the tagname need to be unique in what
namespace the technique needs to be
unique within the namespace that the tag
is defined and and that's what's going
to get us the ADL lookup yeah all right
so here we have getting a little closer
to what we want our name is followed by
our alpha followed by zero or more alpha
numerics our quote is getting a little
more complex now this lexeme we as soon
as we have the quotes what we really
want to do once we get quotes is we want
to shut off the skipper because we don't
want to skip whitespace anymore that's
what what it meant and that's what
lexing does it turns this off everything
inside of here it's a directive
everything within this directive then be
these skippers turned off and then as we
leave that then the skippers turn back
on and so now this will parse this thing
for us we've now got our rules in here
we know actually what name and quote our
name followed by and so bam look at that
so this is a lot more readable I hope
you think this is also a lot more
readable
it's declarative then that first
craziness that we saw of trying to grab
single characters out of a string and
figure out what to do with it right
alright so we've combined some parsers
we parsed a little something here let's
take a look at attributes so eventually
you know getting yeah it was good or no
it wasn't isn't interesting for most
people they don't want to just know that
the parse was successful they want
actually the data out of it so how do we
get the result of this parse into a map
of string string wouldn't that be nice
I'd be really nice so we have this key
value map and now we do something clever
and bam are key value map is filled in
it so let's figure out what the clever
thing is that we need to do
so we've been talking about parsers
parsers have associated with them an
attribute type the thing that they're
going to synthesize naturally literals
will not actually synthesize anything
they have no attribute that they'll
synthesize primitives will synthesize
the thing that makes sense when you look
at it it's pretty obvious that lols will
synthesize a double and so forth non
terminals like rules will synthesize
whatever you tell it it's going to be
synthesizing so this non-terminal is
going to synthesize an A how about these
operators what are they going to do for
us or to us so an a followed by a B is a
tuple of a and B an alternative they
boost variant it's either this thing or
that thing how about these so zero or
more one or more or a list of things is
a vector of the type of that thing
whatever a is synthesizing it's a vector
of that will get a boost optional and
predicates obviously have no attribute
that they're going to synthesize all
right so how do we now get that value
well it's actually pretty easy so here I
am I have a parser that's an int and
I've got an int I'm going to feed it and
I simply provide a reference to the
thing to stick it in so this will parse
the int into result
okay I'd like to parse pizza into an STD
string and I can do that and the reason
that this works is we talked about
compatibility and while we say that the
the clean star or the one more the list
all going to an STD vector the reality
is is that they go into the concept of a
container as described by the x3
specification of what that means and
anything that is compatible with that
concept then therefore will work and so
a string is compatible with the STD
vector of char so therefore a string is
just as valid as anything else right
here that could look like one of these
container types
how about cosmic space pizza well I
could do this I could have result 1 be
cosmic and result 2 will be pizza but
that's going to become pretty
unmanageable pretty fast so it ends up
that that looked like a tuple right and
that's the same thing as a pair that
works for me and so result here of a
pair of strings and I can put it here as
the reference that I'm going to parse
into and now cosmic will go into the
first of the pair and pizza will go into
the second yes questions yeah
so basically the question is is what
happens when you have more stuff
continuing on and what happens is the
parse is fine there's no error in in
completing the grammar however if we
looked at it err and inner end they're
not equal right we didn't consume all of
the input and so that's different than a
failed parsed
we might receive back out of the parser
yeah so the question basically is what
would you do if you want a vector of STD
strings if you just had a bunch of these
and they kept going on then that would
look like a clean star of this thing
right and this thing would no longer be
a result here but we're gonna see in a
moment maybe something else that we
might want to do don't ruin my next set
of slides visual all right so attribute
parsing is where the magic lives in
spirit and that's enabled through the
fusion library so at some point if you
decide that wow that's really pretty
amazing you want to go look probably at
fusion which is pretty darn amazing so
let's take a look at some of these
things here I have a string that's going
to be what my name is going to
synthesize so my rule for the name is
going to synthesize a string and my rule
for the quote is going to synthesize a
string and my item now I'm going to
actually parse this as an item well that
is basically two strings I know how to
do that that's a pair of strings right
name followed by either a quote or a
name so let's take a look at these in
detail alpha is going to is going to
synthesize a character and the b-side
which is one or more sorry zero or more
alpha numerics that's going to be a
vector of character and how this works
out right is this is a followed by B in
which these are compatibility rules this
is an alpha character this is a standard
vector of care
and therefore that could be quite
compatible with just a standard vector
of characters it can cook it can
collapse if the attribute provided to it
would allow it to collapse how about
here
well literals are unused so here's an
unused and here's the unused for here
and the center this is easy enough this
is a vector of characters and a vector
of characters is definitely compatible
with the string so in essence a tuple of
an unused followed by this something and
followed by an unused is just the thing
in the middle right quote is a string or
name is a string so a string or a string
would be a pretty useless variant at the
moment we're not going to talk about
variants of the same type okay and
therefore this could look like just a
string that now brings us down to we've
got this as a string and this is now a
name followed by what works out to be a
z' a string and unused in a string and
that just looks like a tuple of a string
in a string because this was unused so
this looks like a pair of a string
string great because I would like my
items to be a comma separated list and a
standard pair a list of standard pairs
looks like a vector of standard pairs
which is basically a container of
standard pairs which really is just a
map and therefore this thing is just a
map and so the magic is nothing the
magic of what do we do that's special in
that spot is we just give it a map a
reference to a map because of reference
to a map is compatible with the grammar
we had already written not quite
well in this case a map holding pairs
it's a compatibility thing right and so
the pair is of string and string and
therefore a map is just a container of
two strings all right it really is a
multi map is the question let's let's
continue on and we've got a bunch of
slides to get through and run with kind
of low on time and I'm here all week so
the rules attribute type is optional if
it's not going to synthesize something
you don't need to put it and then you
wouldn't have a rule attribute so let's
look at at an example here before we get
to the example just a couple little
guidelines how many people here have
used spirit maybe we'll start with that
okay how many people here have used any
library that uses expression templates
or other boost meta programming
libraries of any sort so okay good there
that's the whole room at that point so
you will you will already be accustomed
to the fact that the compiler is going
to spit out copious amounts of cred that
you don't understand and eventually you
will hunt through it and you will find
something that's useful but you probably
won't do that you probably give up so
spirit uses static asserts all over the
place when things are bad and it tries
super super hard to tell you what's
going on but unfortunately you have to
find it in the compiler spew and how you
find it as you search for for asterisks
in a row and it will have a line number
along with the static assert and the
file and you go there if you're in an
IDE or Emacs or something like that you
can pull up the file and there will be a
narrative that tells you exactly why the
compiler was static asserting at that
point and what you probably need to
change in your grammar so as opposed to
just throwing up your arms and saying I
have no idea why did I ever start this
project
all right so things are hard concepts
will make it better there we go that's
my so start small alternatives in your
grammar are a natural place to break
things up just start with like one of
those and work on it and then add
another one and then animal or just work
on each alternative at a time to make
sure that they work start small and
build up until you get experience using
spirit so you're gonna start from the
leaves and work your way up compose and
test compose something test it compose
something test it do a lot of that don't
write your whole grammar that's pages
and pages long and then like wonder why
it doesn't work that's just you're gonna
be sad test early and often nobody ever
listens to this fungus aid anyhow deal
with parsing first and then deal with
attribute synthesis a synthase ssin hmm
synthesis ii alright so you want to
worry about the parser first and then
worry about the attributes next don't
try to do both at the same time until
you get you know some experience with
this stuff allow the natural ast to fall
out your grammar has an AST don't don't
fight it it wants to generate some data
structure for you let it do that let it
make the data structure you can already
see that we're we're gonna be able to
manipulate the container types all we
want within certain bounds but don't
fight it beyond that instead what you do
is you have an ast that comes out and
you transform that to something else
that is so much easier and more
efficient than putting in semantic
actions everywhere when the parse is
true do something action why's that now
no longer is a nice declarative grammar
that's like procedural stuff crammed
into a declarative grammar it's nasty
and then refine your grammar in you're a
st so let's look at a JSON very quickly
parser there
there are nice and easy so if you're not
familiar with JSON I would be surprised
well tells me that everybody and their
dog is so and JSON has objects there
within curly brackets they the object
has basically pairs in which the first
is a string and the second is a JSON
value thing JSON values can be strings
or they can be objects so they can be
boolean's or they can be numeric or they
can be with the brackets and then lists
of things that we know so the idea is
you can see very quickly of course a
list would be a list of or JSON value
types this is a recursive data structure
not a complicated one but one that we
can actually create some amount of
detail with a bit of type information
along the way
what would an ast look like well is that
one potential or possible ast for this
we're just going to say that a string is
an STD string and a double is a double
and a float because we're going to
somehow deal with those differently has
a double that when we're dealing with
integers with inside of our JSON thing
it's an n64 boolean types of bool null
is just just an empty strike I'm going
to pre define what a our preacher of a
value and then I'm gonna say an object
is a map of string to value and an
object member therefore is the value
type the thing that's inside here and an
array is I'm going to use a boost stable
vector for a reason that doesn't matter
for this talk of values this could just
be an STD vector by the way for what
we're doing right now all right so you
can see the recursion is starting to
begin right now so what is value value
is an x3 variant and x3 variant you can
think of it I like a boost variant
except a boost variant is a is not a
it's not an object we don't have an
object we have a type def which is super
annoying because I I can't actually
say this with the type def and then use
it but here I can and so how this works
out is now I can inherit from x3 variant
and now value is going to be able to
contain either a null or a bull type or
a string type or an int type or a double
type or an object type or an array type
okay it's one of those things that's
what this value holds I'm gonna pull in
some I'm gonna pull in the the
Constructors and assignment operators
from the base so that I can just assign
one of these and make it work if I it's
default constructed it'll be null a
little bit of trick in order to make
this work for doubles for any floating
point type and then a little more trick
in order to make this so that if I have
any integral type or an enum it will
work out to be an int type when I create
one of these it's kind of is all kind of
unimportant stuff in order to to
construct them yeah some he was he was
listening really well yes so the the
question oh the the comment is didn't
you just say that you should like focus
on the parser first yes I did but we
don't have time to focus on the parser
first and then the attributes we're
going to do it all at once and this is
what falls out naturally by the way of
the parser so good catch
so at the top level of value is going to
be a variant of one of these I want to
deal with grammars because grammars are
just like nice packages they make me
feel good but really at the end of the
day a grammar is nothing more than a
bunch of rules composed together to make
some higher-level rule that I can think
about and so this is what I'm going to
do in the code here is that tag that I'm
going to use it's a JSON class so in my
rule JSON class and it's going to
synthesize a JSON value
that's this thing it's gonna synthesize
one of these a variant of any of these
things
booth spirit declare so how x3 works and
in order to speed up compile time just
greatly
it uses a DL for lookup for things that
it used to use for making instantiations
of stuff all over the place and and as a
result we have to tie a bunch of things
together and what holds the stuff
together this is probably detail that
you don't care about for using it what
holds the stuff together is this tag so
JSON class is the tag that's gonna hold
all the things together here it is here
it's gonna show up in some more places
and if you say boo spirit declare JSON
type this expands out to be about like
three or four lines to care of some
stuff for you you can look right those
three or four lines so you can just type
that in the declare so here are the
naming conventions if you want to just
use the nice macro your identify ur your
your ID is going to be identify your
underscore class your rule is going to
be identifiers who are tight the
definition of your rule is going to be
identifier in Urfa sky underscore def
and then you're going to just refer to
the rule in general as identifier so
that's what we had right here so here's
our JSON type this is the rule type all
right so we're also gonna have a value
class an object class and a member pair
these are the things that we saw a
little while ago and now what are they
here are the rules well the value type
rule is gonna create a value for us an
object type rule is going to synthesize
an object the member pair an object
member pair and array is gonna
synthesize an array I can now create my
my rules which is of the type of the of
whatever the value type value the object
type object and so forth and I'm giving
them this string and the string is just
I'm in debug mode you can actually have
as its parsing spit stuff out of what
it's doing where it's backtracking stuff
and now you know where it
these are going to be the lightweight
things that are used in the system this
is what we're going to use in order to
refer to these rules from this point on
and here we see the first one the
definition of a value is it is a null
value or a bool value or it's a Unicode
string or it is this is an integer
because it is not followed by one of
these or it's a double or it's an object
or it's an array so what is a null value
well a null value in JSON is literal
null so and when we see the literal null
we would which as you know literals do
not synthesize an attribute we would
like it actually to create an attribute
for us 18 X 3 attr when this will parse
or consume nothing out of the stream but
it will generate the attribute and so
this is going to generate a null type
out we saw an int what is an int it's
gonna be an n64 parser and bool is just
going to be the bull-type parser what is
an object definition well an object
definition is a curly bracket followed
by an optional list of member pairs that
are comma separated and then ending with
a curly well what does a member pair a
member pair is a Unicode string followed
by a colon followed by a value right so
we see our first bit of recursion right
here what is an array well an array is
simply a left bracket followed by an
optional mm comma separated set of
values right followed by a right bracket
all right we just defined null the int
type the floating point type we dealt
with the bull-type we've dealt with an
object
arrey the only thing we haven't dealt
with is the stream so if we weren't
being fancy in trying to deal with
unicode strings we would just do what
we've been doing for Strings which is
zero or more chars right and we would
call it good and we would have a grammar
that everybody could read and would be
done with and it'll just work for JSON
with you know some caveat of we don't
like Unicode I mean you know they did
put spaceships up on the moon without
Unicode it happens alright so when you
get to this point here you can say boost
spirit define and list your rules within
the namespace and this does that pulling
things together with the tag for you
because we're gonna use the naming
convention right and it does a little
bit more work for you and and call it
good alright let's look at what the
unicode string looks like the same type
of stuff and a spelling error
interesting so here is the unicode
string kind of weird and it is let's
start with this double quoted what is
the double quoted thing it is shut off
the let's shut off the parser I've seen
it shut off the skipper it is a quote
followed by zero and it's notice we are
using expectation point at this point
followed by zero or more escaped
characters or it's one of these and ooh
what is this weird thing here well if
you see something in brackets out at the
end this is a semantic action it's the
things we want to stay away from
generally when we're writing grammars
until like it's last resort we don't
know another way to do it at this point
what we're saying is when this parse is
successful execute something what is the
something well that's this lambda and
the lambda is receiving the context of
the parse at this point in time and
within the context of the parse there's
this thing called Val Val happens to be
the current at
tribute that you're in the middle of
parse of the parse and we're just going
to stick on the end of it the attribute
of the context so this is the value of
the context it's the things coming out
of here and the attribute is the one
that it just succeeded on what is escape
escape our carts chart scape is the
escape followed by whatever this escape
thing and the escape thing is going to
be a you followed by a hex for well what
does a hex for we're gonna define a hex
for as being an unsigned int parser that
is unsigned characters 16 of them 4 4
and we here we also have decided to
stick on to more cemented actions to
take care of this the first one is this
push escape which is going to take and
look what is it that we've got and push
back the appropriate thing into the
utf-8 thing that we're building up and
then push utf-8 is going to take care of
sticking it sitting in the rest of the
way so occasionally you will end up
possibly with semantic actions but it's
only in really really weird odd cases
most of the time you will end up parsing
without any weird odd cases at the end
how do we parse this thing out well we
call phrase parse we give it the begin
in the end we give it our grammar that
came out of here and this is space type
and where we want it where we would like
to parse it into we can catch any
exceptions at this point for failures
and then handle them appropriately so we
wrote a JSON parser with really very few
set of lines and it is probably pretty
understandable yeah what's the question
this one this one that would be that one
yep so you would check parse except to
see whether or not your parse was
successful and you can then check the
iterators and compare them to see
whether you consume the whole thing now
the time that you throw is when there is
an expectation point that you didn't
meet and then at that point bad things
occur right and you can deal with them
whether there's a non error there's a
non error handler you might want to
print out the line number or such or
store that somewhere
we've got just five minutes and and I'd
like to just do one thing here this
question comes up a lot and and might as
well deal with it a little bit this is
just a quick overview of a bit of stuff
about spirit right but a lot of times
what we're trying to do is parse inside
of your own data structure you know I've
got my own data structure that I'd
really like to parse this information
into how do you do that well if you have
your own Struck's
remember spirit wants to be able to
parse things like this followed by that
into a tuple of something and if you
could figure out how to make your struck
look like a tuple life would be great
and it ends up that fusion does that for
you in all kinds of different ways and
you can say boost Fusion adapt struct
the struct I would like to adapt and
which of the elements within the struct
you're adapting or the members so sign
is got this signed
it's a char type and an operand which is
an operand and so I can say fusion adapt
struct
the thing I'm adapting and and each of
the members I want to adapt you don't
have to adapt all of them and which
order you would like to adapt them
you can even adapt them multiple times
if you wanted to or leave some out or
put some extras in and the really what
it's doing down underneath is it's
creating a tuple of references to that
type of whatever the member type is and
that tuple that it's creating of those
references is getting tagged in such a
way that at compile time it can find it
when it sees one of those types it finds
the definition of what it is and it
plugs that in so what do you do you
adapt it and you just give it a
reference to your datatype and bam it
fills it in and so we've only dealt with
so far when our in our little bit of
JSON parsing a variant or containers
things that it already understands but
for your own types you can adapt them if
you have an own type your own type that
just has methods to get to private data
not a problem
again fusion can adapt getters and
setters for members so that when it sees
those it will actually do that too
clearly not as efficient as being able
to directly access and parse into your
data structure but it's still pretty
good
all right um we're basically on a time
oh I have two minutes oh my goodness
what am I gonna do with two minutes okay
I'll take I'll take a few questions and
so that's a great question how does this
JSON parser perform in regard to other
parsers there are a bunch of parser
frameworks out there are a bunch of JSON
parsers out there and there are a bunch
of benchmarks and if you go to the thing
that fell off the end that it's horrible
Kirra labs if you go to kara labs and
github the json parser is on there along
with some benchmarks and you can take a
look at those the generally speaking we
actually haven't ran it against x3 the
v2 stuff not so much it didn't perform
really great and the reason it doesn't
perform super well how
to do with the internals of how variant
works and recursive variants in
particular and the way move works with
recursive variant things which is why
there's an x3 variant now because we
have a different idea of what it means
to do a move and it's made for
performance
so we'll rerun those we'll have an idea
the JSON but J something that is there
is really interested in trying to figure
out how to make JSON objects look like
they would in Python or JavaScript
within c++ and so you just deal with
them which that's a harder problem than
parsing so the question is is the whole
parser generator at compile time it is
so the whole parser is generated at
compile time what you're writing our
expression templates and so at compile
time it is taking those types and it is
generating things and combining things
and generating things and combining
things until at the very end BAM you
have your parser generated great
question so it is x3 is being shipped
with boost since one five six it has
been in as a separate line and you can
look at the spirit documentation to see
how to enable it and to use that so by
default you'll get be too if you want x3
you can enable x3 wise are not a Unicode
parser there may be a unicode parser at
some point the the reason that there
isn't a unicode parser is there's
currently a belief to try to keep
everything as thin and slim as possible
and be to kind of got out of hand and we
would write like x3 not 2 but Unicode is
one of those that were thinking that we
probably should just write one and have
one so we're out of time for the session
I'm happy to take questions feel free to
come on up but I've got to start
shutting things down
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>