<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Michael Mehlich “Transforming C++ Code with DMS” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Michael Mehlich “Transforming C++ Code with DMS” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Michael Mehlich “Transforming C++ Code with DMS”</b></h2><h5 class="post__date">2017-10-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/86fwuXSz7lQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Michael Mehlich from Semantic Designs,
Principal Engineer mostly working
on DMS and applications.
Which essentially analyzes
the transformation of code with DMS.
So, we have lots of C++ programmers here
and I'm gunna assume most of you have used
standard template library or Boost right?
So, how many of you have
actually transformed source code?
And, did you use any
infrastructure for that?
(inaudible audience member)
So, that's where DMS comes in,
because that's infrastructure
for building transforms.
Oops.
So fundamentally DMS is
a generalized compiler,
you can parse source code,
you can analyze it, you
can transform it to create
some output, which you then form out and
off you go.
The difference to a normal compiler is
that the output is not
just your object file,
but you can actually output
the original source code
with your modification in
or an output in a different language.
And in order to configure
this piece of infrastructure
we have used some Wolfe compiler
which can be initiated
with virus languages.
Which includes your
favorite language, C++ but,
I'm sure we have some fans here for
mainframe assembler right?
And if you do that you can
actually parse those languages
to name a solution on
it and if you add some
task definitions you can
achieve certain things like:
computing matrix, detecting clones,
translating to a different
language or defecting in C++.
So, sounds great hmm?
Now let's switch back to Clang
because I know it's your
favorite infrastructure.
We can have a simple
transform like a + = b.
We want to translate it to a = a + b.
That's how it looks like in Clang
if you want to use Tree
transforms in Clang.
I stole that from some slides
that had been presented
by someone else in the LLVM conference
in 2013.
I think everyone here has a tough time to
try to figure out what that code does.
It's essentially navigating
the syntax tree by hand,
trying to extract some information,
copying some things, reconstructing
some tree, and finally
replacing something in
the original syntax tree.
Pretty hard to follow.
No one can really
understand it, no one can.
And it's hard to maintain.
Now, the same kind of thing
in DMS looks like this.
You just write something
that looks like C++
except for a few backslashes,
which are kind of escapes.
And for those,
essentially representing
variables, or placeholders
in the things we want to rewrite,
which we just have some type
information for which we
steal right from the
grammar in the C++ manual.
Your favorite bible, appendix A.
We throw the rule just in to
rule set and then we apply
our transform and we
fundamentally get the same effect.
The difference being that
here we see clearly what we are doing.
Some of you might not
use, like any parenthesis,
so we throw in a few more
rules, and eliminate those.
So, now...
C++ is a fairly complex language,
complications can have side effects.
And if you just use the
rewrite as we just defined,
we get a result we don't really like.
Because we duplicated our
side effect and so we get
undefined behavior for what
was originally a correct program.
In order to deal that,
you essentially can add
a condition to the rewrite that says,
this rewrite only applies
if something else is true.
In this case the something
else that may be true is,
that we kind of apply some
other rewrite set to A
and compare that with our, to A itself
and modify it.
And we define essentially
a rule that eliminates
our side effects in our syntax tree,
and we can use it as a
test and now that rule
does not apply anymore.
So, if we would just deal
with C we would be done now,
unfortunately it's C++ and
there's some more problems
for us.
For example, we might have
defined a + = operator
in for our special class, but
we didn't bother with a +.
We can not rewrite it or our
+ has a different semantic,
and we can not apply our rewrite.
So, in order to that we actually
have to prevent the rule
to apply when we have a
user-defined overwrite.
We do that by essentially
adding another condition,
in this case, whether,
the condition checks whether a + = b uses
the user defined operation, and if so
we do not want a write, rewrite stuff.
And we do that by essentially
creating an external
function we are clearing
and we are pretty much done.
Alright Michael thank you.
(clapping)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>