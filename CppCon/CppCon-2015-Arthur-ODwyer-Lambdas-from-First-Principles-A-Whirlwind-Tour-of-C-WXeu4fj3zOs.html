<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Arthur O'Dwyer “Lambdas from First Principles: A Whirlwind Tour of C++&quot;” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Arthur O'Dwyer “Lambdas from First Principles: A Whirlwind Tour of C++&quot;” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Arthur O'Dwyer “Lambdas from First Principles: A Whirlwind Tour of C++&quot;”</b></h2><h5 class="post__date">2015-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WXeu4fj3zOs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right welcome again everybody I'm
our throw dryer and this talk is on
Landis from first principles this is
designed to teach you all about lambdas
and and what they are and how to use
them and that they are not in fact big
scary lispy functional programming
things they actually interoperate really
well with C++ and here's how you use
them
I like to be a little bit interactive
but also not super interactive with
questions because we do have all 68
slides I think to get through in an hour
but basically for for questions if I'm
going along and you have a question
about something and it's a question
about like I don't get what you just
said or doesn't that contradict what you
just said please do raise your hand and
and I'll try to clarify if you have a
question like okay I see how that works
in that case but what about the case
where it's a very attic template
please don't ask those questions ill the
ends because we also we probably will
get to that in about five slides so no
questions that complexify things
yes questions if you're confused about
the concept because the point of this is
really to to explain the concepts
okay so whirlwind tour of c++ let's
start really simple plain old functions
because lambdas are kind of like
functions right so a yes all right
plain old functions here's a function I
named a plus one what it does it takes
its argument and adds one to it over on
the right I'm showing the disassembly
I'm gonna be showing some disassembly as
we go along this is what you would get
if you compile it with clang on I
believe this is a oh s X just because
that's my platform of choice so x86 64
with the clang mangling scheme yeah how
many people are familiar yes with like
name mangling and C++ Bunch it's okay
good so you all know what that means
okay so that's easy right it's a it's a
function it's a named chunk of code the
name is some mangled form of
function C++ lets us overload function
so I can have a function named +1 that
takes an int I can have another function
also named +1 that takes a double and
then if I call +1 with an int I get 1
version if I call +1 with the double
like a different version and this is
indicated at the Assembly level by a
difference in the name mangling of the
function name so two blocks of code both
callable has +1 in your C++ code but of
course they have different name angles
so far so simple we all know this
function templates says C++ also lets us
write templates so when we want to stamp
out copies of a function that all of the
same behavior right and in the previous
slide I have these two functions one
adds 1 to n s-- 1 adds 1 to doubles if I
want one to add 1 to complex numbers or
long double or whatever I would just
keep adding overloads and overloads and
overloads but we have the function
template which allows us to stamp out
copies for any type that we want and
again the those are instantiated on
demand they get named mangled slightly
differently yet again notice that the
template +1 instantiate it with int is a
different entity indicated by a
different name mangling then in the
previous slide the +1 overload the token
it thinks about template I'm gonna go a
little bit in templates and we're gonna
drop of templates for a bit and we're
gonna come back to them later let's go a
little deeper into into templates so
when I call plus 1 of 42 we're 42 is an
INT the compiler can use type deduction
to know that ok you want the plus 1 that
takes an int and well one doesn't really
seem to exist yet so I'm gonna stamp one
out for you instantiating this template
when we call plus 1 of 3.14 well that's
a double so you must want a plus 1 that
takes a double I'll stamp one out for
you
on Stan cheetah
we can also tell the compiler explicitly
even though I'm passing 42 which looks
like an INT I do really want the version
that takes it as a double and my please
convert 42 to a double I can explicitly
say I 1 plus 1 of double in angle
brackets providing the T explicitly and
vice versa
there are a couple contexts which are
not function calls where the compiler
will do type deduction for us which is
actually really handy for example I can
take plus one here just the name plus
one without saying plus one of the nth
or plus one of double and as long as I'm
storing it into let's say a function
pointer that takes an intern returns an
int the compiler can say oh well you
must want plus one event it is smart
enough to do that you might say well
what if I what if I took this plus one
and assigned it into like Auto then how
does it deduce what what the type of T
is and then how is it to do switch plus
1 to use and the answer is it doesn't a
function template is not the same thing
as a function right the function
template is a source-level sort of
construct and if you use it in a context
where it's ambiguous the compiler will
give you a diagnostic of some sort in
this case client complains about
incompatible initializer of type and
then just in brackets it just says
overloaded function type because the
type doesn't have a name it's a template
alright one more little thing the first
puzzle there are three puzzles in this
talk one more thing about templates
before we move on here I have a template
function template named kitten it has a
static local variable of type int
initialize to zero and every time we
call kitten we're going to plus plus
that variable right I call kitten of one
where T gets instantiated this int and
that's gonna print two
okay and then I call kitten again with a
3.14 this is even harder math I know but
it's gonna print 4.14 yes not 5.14 yes
even though the end was static because
it is a different static nth here's the
code Jen we have two overloaded or I'm
in two instantiation x' here with
different name mangling x' and different
code you notice that the one for INT you
know it's involving lots of sort of inti
operations and here's the one for double
in it well it does some stuff with the
xmm registers with the double registers
so they have different code gen and
going along with that each of them gets
its own set of static local variables
and so on here here we have this is the
X for the double version and this is a
the X for the in version they don't
share memory they're two completely
separate variables because we have two
completely separate instantiation of
this template this has made a little bit
clearer like you might say well that
just seems dumb like why did the
Standards Committee make that decision
why don't we have one variable X that's
what I want right well not really
because what if instead of int right
here we made it type T we made something
template dependent you can do that right
you can have a local variable of
template dependent type and for example
in this case when I have a kitten of int
t is int a nexus of type int when I have
a kitten of double well my teeny now
need my X now for this function needs to
be of type double so it it's kind of
obvious at this point that well we're
going to need two different variables in
the int variable for the inversion the
double variable the devil's workshop
so templates and statics little pit the
little sneaky sneaky there alright we'll
come back to templates later let's go
back to what other crazy things can we
do with functions in c++ oh you can make
member functions like an have a class
I'm going to call this class plus it's
going to have
some a member variable named value you
can instantiate it or you know get an
instance of this class by calling its
constructor and it's gonna have a member
function which one just gonna call plus
me if I have a plus object I can call
like my plus object dot plus me give it
an int and it gives me back the sum of
the ends I gave it and the int that was
given in its constructor another little
digression
I love digressions when I call plus dot
plus me of let's say 42 how does the
plus object know to go call this code is
there some like that this object has to
know oh yeah when you call plus me on me
that means this code here is there some
sort of pointer to that code somewhere
no sequel plus is not Java thank God
the job approach there would be right
there every object is allocated on the
heap and has a V pointer that points to
a table of here a role but behaviors for
this object that's nice and that we can
now pass a pointer to this object around
and the object knows its own behaviors
it is not so nice and that well now
we've got like one two three pointers
here that you have to follow whenever
you want to do something with this
object C++ lets you do this via virtual
number functions which we're actually
not going to talk about surprisingly but
of course in C++ it'll just looks like
this right on the stack we have our plus
object just sitting right there it
doesn't need to be on the heap we don't
want to use the heap we don't want to
use dynamic memory management and the
the function the implementation of the
function is just sitting there in the
static code and there is no linkage at
all there's just sort of a implicit like
you just know the compiler just knows
that when I'm doing something on a plus
object
of course I'm going to use pluses member
function okay so so yeah C++ lets us get
rid of all this dynamic memory
management and whatnot that you have in
Java and so but you knew that because
you're here
alright so class member functions
now this member function I just named it
plus me but let's say this was the only
thing that I could do with a plus object
C++ also gives us the ability to do
operator overloading so I could actually
overload the function call operator on
my plus object right exact same code
genna's before the only difference is
the name mangling has changed a little
bit
this name mangling right here has
changed from being the name of the class
and the member function to just CL which
stands for Cole
so let's say so I can I can overload an
operator and then when I call it you
know as we the call changed from plus
dot plus may of 42 now I can just say
plus and a pair of parenthesis and a
note and the compiler will know oh okay
you mean to call the coal operator here
and of course that it puts the call to
call operator in there statically
because static typing now we can do come
something kind of nifty all right we
take this code I just wrote where we
have this class and the call operator
and the constructor and we create
objects of this type using the
constructor and the syntax highlighting
that I've used here is in red in bold
I've put the irreducible complexity the
stuff that well this is just what it
does right I can't get around the fact
that there is a member named value and
that my operator friend friend takes an
in another int and that what it does is
add them together right that that's the
semantics of my class but everything in
the in the light green there is just
boilerplate
I don't want to have to write that
that's a lot of boilerplate so let's
just get rid of all the green okay all
the green is now gone except for a lot
of brackets actually one of each kind of
bracket it's a very fair language and a
little equal sign there so now we're
saying very succinctly what we want to
say about this entity in our code we've
thrown away all of that reducible
complexity about what is the name of the
class and the fact that you have to
write out its constructor and now we're
just saying it's got a member named
value here's the initial value for that
value by the way we're gonna pass in one
but we could pass in any expression that
we wanted of course and it has an
argument and we have to get the
arguments type and we have to give the
argument a name because we're gonna
refer to it later right so we give it a
name X and then we say here's the
behavior and that's it and we wrap that
all up in that that is a lambda
expression and we use it exactly the
same way you know that the assert down
at the bottom that's checking me the
behavior of our object plus where before
it was constructed explicitly as a plus
object now it's just constructed as a
lambda expression which produces one of
these anonymous class objects behave
exactly the same way and the code jet is
exactly the same same implementation
except that now of course we don't have
a capital P plus object anymore because
we just removed that name from our code
there's no more names in our code so the
compiler makes up a name for this class
and at least in clangs mangling scheme
just says dollar sign underscore zero
dollar sign underscore integer is the
the naming scheme for these temporary
for these anonymous objects so let's see
so now on the stack instead of having
plus a plus object by a plus a dollar
sign zero object and instead of calling
the plus call operator it's calling the
dollar sign zero call operator and
by the mangling down there in the fine
print that I don't know if you can read
in the back and the coach n is exactly
the same awesome oh by the way I do want
to point out that that this value equals
one this is c plus plus fourteen
generalized lands of capture
also known as init capture I like it for
reasons you're about to see but be aware
that if you're in C++ eleven you don't
actually have this index you just
assumed you didn't know everything about
lambda as well haha you don't anymore
yes for almost two years now you don't
know everything about lambdas before
that you did though and so this gives us
the ability to to have sort of Lisp
style functional programming style
closures without heap allocation and
without garbage collection because you
saw we just built that out of the
building blocks that already exist in
C++ right and we all we can all write
code that uses classes and so on with
you know allocating them on the stack or
III we know how to write that kind of
code without invoking the heap and and
garbage collection and dynamic typing
and so on and so forth so since I can
then take that code that we had and
remove all the boilerplate and get a
lambda obviously we can also implement
lambdas without garbage collection and
dynamic typing and so on and so forth so
those two things do not go hand-in-hand
as you might think if if you look at
that
you know C++ oh three versus like scheme
and said oh I wish I had lambdas but I
can't get them without this other
baggage well yes you can
here's an example of how to use them
let's say that I want to did sort this
vector of objects by some property I can
make myself up a little closure object
here as a lambda expression I'm going to
take this prop that was passed in by the
user and yeah I'm passing things around
by value yeah
that's probably okay move semantics
right I'm gonna capture that property
I'm gonna make a copy of it inside my
closure and now but I've cat captured
that thing which I'm naming P here if
you're gonna be an says prop outside but
P inside just to make sure we know what
we're talking about inside I can say you
know I'm given two objects and I compare
that field of them and then I can take
this P less object and I can pass it to
States or against it sort of will sort
things based on this predicate that'll
make sense I think we're about to see an
example of that we are okay so here's
what we might have coming into the
function I have this I've my prop which
is a stood string and so it controls
some you know hello world out there on
the heap which is the name of the key
I'm sorting by so maybe hello wasn't the
best example and then I make my closure
object so that's gonna be a dollar sign
something I'll assign one object and it
is going to have inside it captured it's
gonna have a member variable which I've
named P that's that P right there and
it's going to be initialized to a copy
of prop so it's gonna copy out the hello
right there and that that's what I'm
gonna look that's what it's gonna look
like so again the the lambda itself is
not living out on the heap anywhere
there's the heap in vault in this case
because we're controlling stood strings
but and again there's this sort of
magical compiler static typing linkage
between these things that is not
represented in the the runtime at
runtime okay so let's see some some
other alternative syntax is for this so
I said this this was the C++ 14
generalized capture in C++ 11 you have a
more restrictive version you can't give
things different names but you can say I
want to capture the local variable in my
outer scope named prop I will capture it
with that same name prop inside but
notice that prop inside refers to that
pink prop that I captured not to the
prop in the outer scope
so you can write that in C++ 11 also C++
11 and of course it's also in 14 you can
continue to do that but I don't really
think you should I don't know I like
explicit names so we can also just say
I'm gonna capture every everything I use
inside that you don't know what it is go
look for it outside and make a copy of
it please so you can give a default
capture semantics this uh many people
consider to be a bad idea in general
that it's certainly good it's in the
language there are things you can do
with it you can put it inside macros and
so on that makes it very nice to have in
the language but probably not something
you should do a lot ok and then oh and
the other thing going on here by the way
we were talking about doing all of this
without garbage collection you can see
that once I've made this coffee I can
then have the original prop can even go
away and I just passed my lambda around
and it's like there's no dangling
references or even reference counting
going on it's just well I made a copy
now it's mine so I can get rid of the
original if I want but what if I want to
capture a reference because this prop
that I'm making the copy of this is a
really big box I'm making this big
coffee I don't want something this heavy
weight I want a nice lightweight pointer
so I want to be able to capture a
reference so what do I put in my capture
list here if I want to capture a
reference well I could do that yes yeah
see you you could do this but you
shouldn't do this what you really see
since the built-in syntax for it is put
an ampersand in front of the name of the
thing you're capturing and that
magically the compiler that's like it's
not magic but it's a special case where
the compiler will say Oh
okay now you want a reference to it okay
I'll give you a reference hopefully it's
the same question Oh what is stood ref
stood ref is a function that gives you
back a stood I think a reference wrapper
a reference wrapper is a yes it is not
an actual reference it's not an actual T
ampersand a reference wrapper of T is an
actual value type that you can like copy
in the sign and whatnot but it behaves
like a reference so that when you use it
it basically just has an implicit
conversion to to ref I think there is an
implied auto in front of the P equals
yes basically yes however if you think
of it that way then you'll start
thinking oh well I should be able to put
like double ampersand P equals prop and
that should capture in our value
reference no that doesn't work
I should be able to put star P equals
profit that should capture an auto
pointer no that doesn't work it's a very
special syntax that means if you don't
put anything it captures by value if you
do put a single ampersand to captures by
reference and that's it those are the
two kinds of things and similarly a few
we saw that you can capture everything
by value by putting the equals sign you
can also capture everything by reference
by putting yeah just the ampersand and
that means anything that I use in my
inner scope that I haven't defined in my
inner scope go look for it in the outer
scope and if you find it there captured
by reference and I also skipped over the
slide where in C++ 11 you can capture
names local variables with the same name
inside by reference as well
all right but beware of dangling
references right if you capture
everything by reference and then you get
rid of the referred to stuff then you
have dangling references dangling
pointers which we all know from this
morning's keynote are terrible so be
very careful when you do this yeah that
problem is solved yes so don't worry
about it basically capturing everything
by reference is really really great and
convenient for lambdas that you know are
only gonna go sort of down your call
chain and never escape upward into your
caller right then capturing byra
everything by reference is just the
simplest thing to do and if you're not
doing that you probably shouldn't be
using a default capture mode at all you
should just spell out exactly I want to
capture this and this and this by the
way if you literally capture this by
let's say copy what are we capturing
capturing a pointer by copy yeah so it
will look as if you're capturing it by
reference basically and it will do this
even if you are referring to if you're
not writing this in your code but you
just say I want to capture everything by
copy and then I refer to a member
variable my member whatever it will say
oh well how do I get my member well
that's really disown my member so I'll
capture this by copy and you'll think
you're getting a copy of my member when
in fact you're not you're getting a copy
of this pointer I wish I had a slide on
that
okay so just the sum of default capture
modes here I have a fact a couple of
factories called increment by you pass
in one integer this is this is basically
a factory for our plus lambda right you
you pass in the the number you want to
add two things so for example I can call
increment by of five that gives me back
a lambda which I'm naming plus five and
then if I call plus five on two I get
seven the good increment by captures the
Y by copy and it all works great
bad increment by captures that why by
reference so that the lamb that I'm
returning back out of my scope has a
reference to a local parameter local
variable returning a reference to local
variable obviously doesn't work all
right another couple other grab-bag
features of lambdas they are convertible
to raw function pointers as long as you
don't capture anything that's super
useful if you do capture something then
of course you can't because you can't
turn like an arbitrary going back to our
original capital P plus object I can't
turn a capital P plus object into a
function pointer because where do I put
the data but if I don't have any
captures then my plus object is
basically just a a handle to its
operator print Frane which takes a at
this point here but it doesn't do
anything with it cuz that this doesn't
control any data so really it's just a
pure behavior it's just a pure function
and so in that case the language
actually allows us to convert it to a
function pointer variables with global
scope are not captured there's a puzzle
about this later this is the spoiler and
lambdas may have local state but not in
the way you think here's a puzzle
alright puzzle number Tim what have we
got here we got a global variable G
which I initialize to 10 and then inside
main I'm gonna set G to 20 and then I'm
gonna call my two lambdas here with
which in the traditional style and
naming after cats we have kitten that
captures everything by value and we have
cat which captures only G by value what
do we think this is going to print
I heard 11 and 11 I heard one in 11
I heard 21 and 11 I also heard 21 and 21
okay I think is that all the okay I
think we've completed the square 21 and
11 and here a color code at what's going
on so if you can read my mind with the
color coding so the global G which is
purple here Global's are not captured
right because why would you need the
capture a global its global everyone can
see it because he told it to um well no
I just pulled it by default if there's
something in my scope that you don't see
outside just assume that it's in the
outer scope but the G of course I know
what G is G is the global variable G so
kitten doesn't need to capture anything
it uses G but doesn't need to capture it
its global it knows its address its
address is never gonna change so kitten
is actually going to basically track
updates to our G as we make them so
that's why it gives us 21 by the time it
actually tries to use G G has already
changed to 20 a cat on the other hand we
explicitly told it I want you to have a
local you know a non static data member
in this understand this dollar sign one
class I wanted to have a non static data
member whose name is G and I want its
initial value to be the result of the
expression G the result of the
expression G is 10 right now when I
create cat so it gets a local G
controlled by the cattle object with
value 10 and 10 plus 1 is 11
yep C++ 11 either doesn't have this
problem or has it worse depending on
which compiler you use in C++ 11 if I
use the the format where I don't have
the equal sign that just say please
capture G that is a constraint violation
and should be diagnosed as of this
writing clang diagnoses it with an error
GCC diagnoses it with a warning and
keeps going and I do not remember what
it does so be aware that if even if you
name the global if you use C++ 11 style
a that is a constraint violation and
requires a diagnostic and B you may not
get a diagnostic same thing if you
capture by reference well in that case
like it definitely wouldn't matter right
I mean if you're capturing it by
reference you know you're not getting a
copy so yes it would still be a
constraint violation but I can't imagine
anyone thinking that they were going to
get any behavior different from what
they got so alright time to revisit
statics here I have a kitten factory you
pass it in a value that you would like
to add at the the actual behavior of
this lamb this is gonna add up a bunch
of stuff right two of the things that's
gonna add up or the value you pass to
the factory see and value pass to the
constructed lambda D also to that we're
gonna add the values of two statics
which we're going to be plus plus saying
every time you call the lambda one
that's static in the factory and one
that's static inside the lambda itself
and now we're going to make two kittens
one without you one one with about you
two and we're gonna call them we're
gonna call the first one twice we're
gonna haul the second one twice and the
question is what does this print and I
don't even want to think about
this but if someone out there does just
shout out the answer and I'll tell you
what you're right here's the answer
all right so what's actually happening
here well we're making a kitten of one
so we're gonna come in here in the a
inside make kitten he's gonna start with
value 0 and it's going to return a new
closure constructed from this lambda
expression so it's gonna be an instance
of $1 0 class for some value of 0 and
the call operator of this class is going
to have the following behavior it's
going to it's gonna have a copy of see
because we're copying everything like by
copy capturing everything by copy we're
going to increment the a which is just
global like there's one of it inside
make it right we're gonna increment the
B which is static local and inside this
scope and then we're gonna add the C in
the detail this is already confusing me
too many variables do also post
increment why did I choose post
increment but the gist of this is that
of course there's only one static a
right because it is in the scope of make
kitten and there's only one make kitten
but how many bees are there we have one
bee or two bees the answer is we have
one B because b is static in the scope
of this anonymous classes operator print
R in function it has a static local so
it's gonna it's gonna look kind of like
this oh and if this doesn't show up the
same way is it showed up before we just
pretend this is all in one line so we
have a single static a and we have a
single static B whose name mangling
the gates that it's the B that belongs
to the call operator of dollar sign 0 I
wish I could just whoops get rid of that
to make that name mangled of thing
clearer we have our kittens k1 and k2
they each capture to see and they're
aesthetically through the magic of
static typing they use this code which
refers to the a inside make kitten and
the be inside the coal operator but
there's only one B and that's why they
see each other's updates to be because
there is only one coal operator yes the
dollar sign zero class has a single call
operator which has a static local B that
it refers to but only one of them so
statics inside member functions
you know behave the way that you might
already know they behave it's not gonna
create a different stamp as you called
it just because you called it akin a
little bit later right so it's the same
one as it was stamp once at compile time
and sleekest I mean that those calls are
the static call they're not dynamic we
figured out some detail like previously
so they're just yes I mean I would I
would go with that but I want to say
that it's not super obvious that that's
what should happen right because the
this this lambda expression here does
have this like we say very explicitly I
want there to be a like static in named
be inside the scope and the the
committee could have decided ok let's
let's make it so that when you declare a
static locally inside this lambda thing
that that really means that we get one
per closure like each one gets their own
and it's initialized to 0 why didn't
they do that you might ask ah because we
already have a way to do that so here is
a situation we
have now right where each of them gets
their own see because they captured it
but they share a reference to be because
there's only one B and then if one of
the modifies B the other one sees the
update and that that's not what we
really wanted in this case let's suppose
that's not what we want in this case
what we what we wanted what we thought
we were getting and it turns out we
weren't is that we thought we were
getting a B in each of these closure
objects so how do we actually achieve
that what is the syntax provided for
that well it should be pretty obvious
that the what we're doing with B here
putting one in each closure object is
exactly the same thing that we had done
with C right so we should be able to use
the same syntax that we use to get this
C to also get a B right
so all we need to do is just capture
something and we'll name it B because
why not we'll initialize it to zero and
because we're going to modify it we'll
have to add the the mutable keyword
let's make sure our lands I can modify
its captures but there you go if you
want some some extra state per closure
object you just you know stick it in the
capture list because the capture list is
where your member variables of this
anonymous class go could you also have
declared it inside the braces without
the static keyword yes but then it would
be a stack variable it wouldn't hold it
state this B is not on the stack this
well that's well I mean yeah okay that's
back but
they're inside other things that can
then be copied and put somewhere else or
past return values or passed up or down
but you but you can't do this with C++
11 syntax as written what you would have
to do is create a local variable name to
be initialized that to zero and capture
it by name
yes it's ugly but that's why I love the
the generalized capture syntax yeah
could be be something other than an
integer yeah it could be you know it
could be a student string it could be a
arbitrarily complicated class do you
need to say the type of B no in fact you
can't the only thing you could do there
is say B equals and then spell it's like
I'd say B equals int of zero or B equals
stood string of hello world that this is
a similar to I know herb slaughter has
this idea of almost always Auto which is
catching on to a certain degree and this
is one place where it is always auto you
don't get a choice there's no way to
specify the type on the left-hand side
of the equal sign you if you want this
to spec type you you must either write
an expression that gives you that type
or write an expression that gives you
that type
okay so there we go program the mutable
state so I just snuck this mutable
keyword in here
if we're gonna plus plus B we need to
say mutable what is that actually doing
notice that mutable is not going on B
itself and there's no way to do that
it's going on in the same position that
you would expect to find the like the
Const qualifier in a member function
right I say operator paren friend Const
and in lambda I say something print bran
mutable the reason for this is that
lambdas by default their operator / n /
n is always Const it was decided that
generally speaking you don't want to
modify your captures if you are
modifying your captures that's probably
a bug you would really like us to warn
about that so your operator print print
on their anonymous class dollar sign 0
whatever is always Const unless you say
mutable and that makes it non Const so
everything has shifted one level down
Const word from what you would expect
so saying mutable gives you an operator
print ran on this anonymous class object
which is not Const and therefore it can
modify the captured member variables how
come a wasn't captured by coffee right
and we said capture everything by copy
if you can't already see it right we had
the capture C by copy because there's no
C in the scope but there is again only
one a Global's and statics in general
are not captured by copy because we
already know their address
when you say a we know you're talking
about this a we know we don't need a
copy of it it's right here his name is a
and so that's why it wasn't captured all
right so generic lambda Stan Eric
lambdas from scratch that was the whole
point of the talk right ok let's go back
to the beginning class member functions
class member function templates let's go
back to our plus with a plus me member
function let's now make that a template
now instead of taking int X we're gonna
take T X for any type
and we're gonna return a tea really I
guess we should be returning auto and
just let type deduction sort of figure
out what the type is well T plus scent
gives you tea right okay so now we have
a template and we can instantiate this
template we can say once I have a plus
object like plus of 1 I can say plus
stop plus me of 42 that will instantiate
plus me with int and we'll get something
that name angles to something like this
and those integer operations I can say
plus me or 3.14 type deduction will say
AHA t wants to be double here I want
Stan shade stamp out a instantiation of
plus me for a double I won't get some
double code gen okay looks great right
good okay okay what did we do the next
that call operator boom all right
replace plus me with operator print
print now the name mangling has changed
a little bit we have a CL there or
before we had plus me the way we call it
has changed a little bit okay now we
make something kind of nifty here's the
reducible complexity and the irreducible
complexity irreducible in red the
reducible complexity in green we're
gonna say make me a plus where the value
is 1 and then sort of the you know I can
do this the same thing I did before
let's take all that boilerplate in the
green and let's get rid of it it all
goes away and now I have the same thing
I had before before I had an instance of
a plus class where it's operator paren
friend was a template now I have an
instance of an anonymous class where
it's operator print friend is a template
this is C++ 14 at this point yes if you
wanted in C++ 11 you write this
and I learned too much today there are
places in boost that really expect
something that behaves like this and so
14 is great because now you can pass
them they simple things instead of
having to write your own templates so
here we go
all the same stuff is before you say I
want a I want every instance of this
closure object to have a value I will
initialize it to in this case one and I
have an operator print friend and has
one argument I call it X but what is its
type its type is Auto which is the new
magic catch tall keyword that we use
every time we don't know what other
keyword to use its replaced static in
that respect so you say Auto X and that
means this is a template figure it out
you can also you could say Auto star X
or Auto ampersand X and that would mean
this is this is a T star this is a t
ampersand figure out figure it out
but in general we either we would write
like Auto or we would write Auto ref ref
which would turn into a t ref ref which
is a universal reference or a forbidding
reference so for report perfect for
winning
all right so generic lambdas all right
here we have another puzzle I have a
kitten it's a generic lambda so it takes
auto T and it has a static local named X
initialized to 0 and I return plus plus
X plus value give it so kitten of 1 is 2
kitten of 3.14 is 4.1 for right for
exactly the same reason as in puzzle
number 1
did I forget to change that slide I did
puzzle number 1 Redux right so now we're
circling back to templates if you didn't
notice already so yeah we have one
entity here it's name is kitten
it is no longer a template itself it's
not an overload set kitten is a real
thing of type dollar sign zero it's an
object I can pass it around we know its
type but because it's operator paren
paren is a template whenever we're using
operator friend per annum we're actually
instantiating a template and every
instantiation gets its own set of
function local statics for example so
that's why we get this behavior can I
use angle bracket syntax to say kitten
of int or kitten of double I believe not
but I am Not sure I don't actually know
and if you can't it might be coming I'm
not sure seems reasonable yes but
probably not because remember kitten
itself is not a template right so kitten
of int is definitely not a thing right I
mean I could I I believe that I could
say like I'm gonna get the address of
like kitten dot operator friend Fran of
in oh yeah there's probably some syntax
to make that work but it's completely
ugly I'm sure
so in general no can auto be used
anywhere no like can you have like a
vector of auto know you can say vector
of T and have it deduce the T for you
and you can say sort of similar things
like auto star and auto ref ref but I
don't think you can say vector of auto
and I know there's been a proposal for
seventeen to let you say that but I
don't know what happened to it where it
is
factor of that cool thank you all right
so generic lambdas generic lambdas
behave in this confusing way just like
templates because they are templates
templates under the hood all right we
have ten minutes left
I think we can get through all of the
slides and maybe not the bonus material
but hey that's why we have lightning
talks right let's do very attic function
templates just to prove we can vary
attic templates right yeah okay
we have a class plus it has an int value
it has a constructor it has an operator
paren paren which is a template which
takes an arbitrary number of parameters
of types P where P represents a
parameter pack of types and it's going
to return the sum of all of those and
also the value so I want to say right so
I can say plus of 40 2 comma 3 point 1 4
comma 1 and that should give me 40 to 43
there's forty seven point one four or I
could say plus of foobar and two and
that should give me bar right because
char stars all right all right so we
take the code that we wrote before they
have the reducible complexity in green
we have the irreducible complexity in
red we've replaced all the green with
one pair of brackets each and you'll
notice that we we took the P with which
was a parameter pack capital P I mean
that disappeared instead we just say
Auto and that means I am a template
figure it out and Auto dot dot is a
parameter pack of I don't know figure it
out so here I have a generic uh very
addict lambda which takes any number of
parameters and it's going to take them
by value or by copy because I said Auto
thought and not Auto refresh
dot dot and it's gonna add them along
also in C++ 11 syntax I can capture a
parameter pen so we talked about so this
is gonna be confusing because I'm doing
them right after each other but here's
how I make a very attic template lambda
where where the argument list is a
parameter pack but flipside of that I
might want the parameter pack in the
other set of brackets right I might
actually want a non very attic lambda
that captures a whole parameter pack
that was passed to the func the caller
or to the creator of this lambda I might
actually want both that's also fine but
in this example this is going back to
our sort by properties so I have a
vector of objects and I want to sort
them now not just by one property but by
a bunch of properties possibly empty
actually but we're gonna pretend that
the empty case doesn't exist and I'm
just gonna pass in a whole bunch of
strings I'm gonna say sort by key 1
comma key 2 comma key 3 so they're my
type names captured by P are gonna be
like stood straight instead strings dead
string props is a parameter pack
representing those three strings and I
can capture that whole pack by copy in
my P less and then I can expand it back
out again when I need it
inside the lambda and look at that
lexicographic sorting and like one line
of code so that's nice
now you might say Oh what we're gonna
get to that moment slight digression
capturing by move here is our original
example where I'm capturing the string
by my copy but copies do take a lot of
memory so maybe I just want to do ass
did move I can do that in the
generalized capture init capture syntax
in C++ 14 can I capture a whole
parameter pack by move can I say this
big old nope can you do forward big old
nope and there there are good technical
reasons for this if you google it there
there's a Google Groups post but I think
Richard Smith someone who knows that
explains that while this is really
tricky because you can't have a
non-static data member that is a
parameter pack that doesn't make sense
so yeah so you can't do this
yet but maybe it's coming someday I wish
because that would be nice what you can
do instead is make a tupple out of your
whole parameter pack move things into
the tupple and then did move the tupple
into your lambda and man in their lambda
you can unpack it which I didn't even
write because I like I don't think that
that's possible one more than about ten
lines of code and a helper function so
can't do that and I don't think we're
going to talk about stood vine so you
might as well ask your questions in the
back can't you do that with apply from
the experimental extensions TS if I were
only calling a function on the the
parameter pack yes but you'll notice
that I wasn't just calling a function on
it I was taking the parameter pack and
doing a sub P for every P in the
parameter pack and B sub P for
everything in the parameter pack so I
could all I could use a ply actually
with this all I need to do is call the
stood square bracket func Thor
you know I stood less and did the did
plus there there's one of those for
every operator so I need to do is call
stood or stood index which doesn't exist
they just got around to adding unary not
in like see fossils 14 eventually they
will work their way through all of the
operators but they haven't gotten to
square brackets yet
how do I know what a bracket hello would
be well a here is a reference to object
which is a stood map so it's using the
map index operator to say give me the
value associated with the key hello and
I heard someone ask what is tai tai is
like make tupple but it takes references
instead of making copies so it
so what Tai is doing here spin Tai but
there wasn't room on the slide to write
it is basically expanding a sub X for
all X in props so that gives us a sub
hello comma a sub world comma a sub for
all of the peas that you passed in
taking references to all of those
wrapping them up in a top hole on the
other side we do the same thing for the
bees and then we use tuples less than
operator to do a a lexicographic
comparison of those two things I think
we're probably out of time well well
write one more what's it experimental
apply takes a function and a couple and
calls that function on the elements of
the Tuffle all together so it takes a
the tupple that's captured the parameter
pack and allows you to use it as the
parameter pack to the other so a
function again sort of the inverse of
McDouble right thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>