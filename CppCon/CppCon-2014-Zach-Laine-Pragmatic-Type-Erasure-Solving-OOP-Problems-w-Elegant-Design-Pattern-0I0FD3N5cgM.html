<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2014: Zach Laine &quot;Pragmatic Type Erasure: Solving OOP Problems w/ Elegant Design Pattern&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2014: Zach Laine &quot;Pragmatic Type Erasure: Solving OOP Problems w/ Elegant Design Pattern&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2014: Zach Laine &quot;Pragmatic Type Erasure: Solving OOP Problems w/ Elegant Design Pattern&quot;</b></h2><h5 class="post__date">2014-10-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0I0FD3N5cgM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm going to start with a little bit
about value types because they're an
important motivation for why I think you
should use typewriter and I'm not going
to stick on that too much because
there's been other talks and that
covered this very well in it what about
double size of my talk I'm gonna talk
about why we use polymorphism at all
from first principles what are we trying
to achieve with it and I'm gonna show
you why the current solutions that we
commonly use are inferior to type razor
and let's start with body types Jesus
really it is awesome okay so if you deal
with value types instead of reference
knives by references I mean you know
pointers and references if you deal with
value types you get nice ownership and
lifetime semantics and you get
equational reasoning and what I mean by
the first one is exemplified by this
problem right here we have a foo factory
it returns a foo T star if we use that
factory to make a food what can we say
about foo right terms of ownership like
do I delete it is it held internally by
this factory do I increment a ref count
now that I have a decrement one when I'm
done with it or something to get rid of
it how do how do I get rid of this thing
and if I give it to someone else they
have to ask the same questions so maybe
this is better right now I don't have to
worry about one to actually delete a foo
but now I have shared State in the best
case and the worst case I have global
State okay so while it's better in terms
of not having to worry about the
specific destruction of the object to
use shared pointer you're still in the
business of dealing with lots of bits of
code and trying to understand all those
bits of code and how they interrelate to
each other okay so at least we tore
equation on reasoning we've got the same
foo factory now we've got a function foo
user that uses that the result of the
output of that factory right so when
some function if I make a food tea from
the factory and then I say I want to use
that I'm passing the pointer by value so
I know the pointer value did not change
but I can't say much else about foo
it could have been deleted by that
function it could have had some mutating
operation that I didn't anticipate it
could have a non mutating operation that
influences what I do afterwards
so you know have you ever heard this
thing about how you have like seven
registers in your head or you have
basically seven bits of information you
can hold at one time well you don't want
to spend those seven registers outside
of the place you're writing code right
you don't want to have to reason
simultaneously about the code you're
writing here and then also the code that
you're calling transitively for every
function call you you have so whenever
you use mutable references you let those
objects leak out you then have to reason
about what's going on elsewhere not just
where you're writing code all right oh
and I forgot those little note I was
gonna say at the beginning all the code
you're going to see today I've slept it
up with a tool so all the code you see
compiles and runs so every once in a
while you might see something it looks
like an example it's not it's it's real
code okay so the reason we use
polymorphism is for code reuse right
here is a function that has limited
reuse because I've got an object of type
sum T the only thing I can pass to this
function is a sum T object or maybe
something derived from that if I don't
care about slicing right so I have to
use this poly nan polymorphically right
so if instead I give you a Const ref
parameter that you can pass to this
function now I can use this base T in
this case this type and then anything
derived from that and I can use this
runtime polymorphically this is the
traditional you know inheritance base
polymorphism but you have to use
inheritance and I'm gonna show you why
you don't want to do that now this is a
little bit better in a lot of cases
you've got a template now so now I can
take any type T and compile time
polymorphically I can have any such type
and as long as the template gets
instantiated with the right semantics
and without you know breaking the build
then this works the problem is that the
polymorphism that I care about for the
purposes of this talk is runtime
polymorphism so you can do this but
you're usually you're usually stuck in
compile time polymorphism land once you
do this it's hard to get out type array
sure is the way to get out of that
and this is an important point I feel
this line here where it says this year
I'm going to assert is not is not a
polymorphic use of that object and the
reason I say that is because polymorphic
use of an object means that I can
substitute this for that there's an is a
relationship there in this case I have
to I have to retain extrinsic state that
tells me that it's okay to do this cast
okay I've got this function food that
does not appear in the base class and I
want to use it and derived I have to
know that it exists because all I have
is a pointer to base and that doesn't
exist in the point of the base so right
here it's not a problem because I know
from the context because the previous
line I you know allocated this object
that it does have that interface but in
the you know typical case you will find
people doing this kind of stuff with a
static cast or a dynamic cast when they
know for some reason that that is the
most derived type of that object you can
get at that interface or in the worst
case they're doing a you know a block of
if this dynamic cast works if that
dynamic cast works and trying to find
interfaces are looking for so that is
not a polymorphic use of this object and
I'll return to that later when we talk
about benefits of other kinds of
polymorphism besides type razor okay so
as we already touched on we're going to
do inheritance based polymorphism and
template based polymorphism first you
know the benefits of inheritance
polymorphism hopefully I'm going to show
you some problems with it that most of
which you're probably already familiar
with so when we have everything when we
have our polymorphism based on
derivation we're limited to whatever
exists in that base class is API right
we have to say down in this function
some function if I have a pointer to
base and it's type most drive type is
derived I can use that in this uses foo
function because I know that that part
of that API exists in the base class I
can't use it in this you know fictional
uses Bar function because even though
the most derived type that you know the
thing at the end of that pointer has
that API I can't get to
now this is one way of looking at it
just showed before how you can do it
with a cast but you either have to limit
yourself to this or oh and by the way
the base class could be you know
multiply derived some multiple drive
type it doesn't have to be a single base
class that's not what I'm saying by this
but whatever point in your class
hierarchy you decide to pick as the type
of pointer that you're going to use to
refer to all your objects
polymorphically whatever that type is
you're limited to that public interface
or you can try to bolt on interfaces
later on so in order to do this you know
I've had to use virtual inheritance here
right this is the classic problem you
don't want to use virtual inheritance
you get this diamond to death it's
virtual inheritance and that's fear and
darkside results okay so so you don't
want to write code like that right you
don't want it to again return to the
need to extrinsically remember that this
object has this certain interface on it
and do that dynamic cast right that is
not a polymorphic use of this of this
object and you can't take different
classes from different class hierarchies
and make them interoperable in the same
set of functions that you want to pass
them to right because they don't have a
common base so if I've got this int foo
and float foo they they have
incompatible foo functions these log
functions look like I should be able to
use them in multiple places though right
but because I don't have a common base
class I'm sort of stuck so what end up
doing is writing an overload for each
one of these maybe that's a template
that generates the overloads for me if
it's a very simple implementation but in
either case I'm generating excuse me
object code for both of those when I
don't necessarily need to or I result -
I mean resort to using a base class that
allows me to do the logging and if
there's some other common operation
besides logging I want to do on
everything that I have to have another
common base than everything derives from
as well it's you know again not code we
want to write ok so for that same reason
we can't take interface implementation
to separate them easily right I want to
have a function that says this is what I
expect the things that you're using to
look like and anything that conforms
that interface I will accept it
but we cannot do that once we're using
inheritance without using multiple
inheritance to basically separate the
interfacing implementation we can't
truly have the implementations totally
divorce from one another we have to have
them with a common base so we can use
the the inheritance mechanism
alright so virtual functions are you
know tricky in a variety of ways we've
seen real problems where people will
create a new overload that is not a
override rather that's not a real
override it's just a misspelling of an
override so you get the wrong virtual
function called right so override and
final help with that but there's a
bigger problem which is that there's a
lack of consistent idiom in our industry
for what to do with the virtual function
implementation so if you get dropped
into an object hierarchy or class
hierarchy rather and you want to write a
new virtual function you have to know
what the conventions are for the rest of
the virtual functions in that hierarchy
because some places say like do not call
the super classes version of this
virtual function some places say always
do that some places say you should have
a non virtual interface and do your
virtual functions as implementations of
the non virtual interface which is the
public interface like so in other words
don't have public virtual functions
there's there's a big mess that requires
you to when you're dropped into
something new you haven't seen this
class hierarchy before you have to read
a lot of other code to figure out what
the right thing is to do and of course
inheritance imposes very tight coupling
because the need to derive from a common
base you can't have these totally
different types like you would have if
you you know you have your class
hierarchy and you want to add something
to it you're not able to do that without
of course deriving from a common base
class and that means whenever you touch
that base class header you have to
recompile the world again we want things
to be more separate than that and of
course we're doing everything with
reference semantics we don't get the
nice value semantics that I was alluding
to earlier okay so a quick mode of an
example we've got widgets and layouts a
widget is UI element like a button or
text box a layout places widgets in the
UI right that's what it does a layout
contains widgets because that's what
needs operate on but you also want to
contain sub layouts and the reason you
want to do this is
because layout code is going to be
fiddly and complicated and hard to get
right so if you've got some big layout
and it's got essentially three columns
of widgets in it you don't want to have
a layout class that says well I know
about how many columns or boxes or a
grid or something like that it's much
harder to get right than to just say
I've got horizontal layouts and I've got
vertical layouts and I can mix and match
these to make any layout that I want so
as soon as you decide that you want to
have a sub layout and a widget in the
same layout function then if you're
using inheritance you're pretty much
tied to saying a layout is a widget or a
widget is a layout or they're both some
something that they're commonly derived
from okay if you look at qts
implementation they do this right they
derive a widget from layout or the other
way around I wrote a UI library that did
the same thing and this is stupid
right I should not have done this
arguably and I've done this either you
don't want a widget that is a layout you
don't want to layout that is a widget
that doesn't make any semantic sense
right it's hard to reason about code
that has a kind of false relationships
okay so templates do solve a lot of the
problems I just mentioned but there are
a whole host of problems that go with
meta programming I won't go over these
in great detail essentially you need a
lot of specific information I mean a
specific knowledge on how to do template
metaprogramming order to do it other
people at your work maybe don't have
that same knowledge and can't maintain
or read or understand what you've done
and for that recent places simply make
it verboten to use those right and then
on top of everything else you can't get
the runtime polymorphism that I'm
talking about at least not without
typewriter so for example we've got this
function this factory function that
works great at compile time right in
terms of figuring out what the return
type of this function should be if I
give it a true type of false type and
some compile-time constant selection I
can you stood conditional and based on
selection I can either default construct
of true type or an object of false type
right that first one it works great I
have this int and this float I'm pulling
out of it and that all works just fine
now if I want to make that a run time
switch instead of a compile time switch
so I write Auto
trust me I'm going to figure it out in a
bit
and then the name of the function and
then I've got this selection so in that
part at the end I like can you see that
not really all right well right where
I've got the first set of question marks
I want to put something in the trailing
return type there in terms of selection
that gives me a return type but I can't
because that's it that's not a
compile-time constant that's a runtime
value okay so with type erasure you can
do stuff like this the examples like
this are not what I'm getting at but the
point is that once you're stuck in the
template metaprogramming world or once
you enter you're stuck there right and
so it's not even though it solves a lot
of the classic problems we have
inheritance it doesn't solve our runtime
hommerson problem right so the question
is am I talking about things like vector
having an allocator and not coloring the
type and making that type different from
another vector with a different
alligator right right vector event
versus vector event with my own kids I'm
not strictly talking about that I'm that
that is an example in addition to what
I'm talking about I think because you
could have a essentially a vector
interface which is an erased vector type
that has these different kinds of
vectors behind it with different
allocators and you use them all the same
but in this specific example I'm
specifically talking about doing
template metaprogramming heavy code to
get around all the problems that you
have with condition with a traditional
inheritance base polymorphism I've seen
a lot of people do this instead and you
end up compiling everything every time
you want to do something and you have
poor runtime polymer workers and
opportunities when you need them but did
you have something
worse than that because it's not about
recompilation it's about compatibility
it's about an interoperability between
two things it should be interoperable
because they represent the same thing
and titration is a way to get around
that right yeah no that that's that's
right so the comment was that it's also
about interoperability right using these
two kinds of vectors your vector event
and my vector event with a different
allocator using them the same way
because they conform to us the same
interface and that's exactly what I'm
getting it yeah
okay so surely we can do better right
so that is type array sure of course and
based on everything we've seen so far
this is the kind of code we want to
write okay we want to have no coupling
so I've got these types foo and bar they
both have a value a member that looks
about the same and we have no virtual
functions sort of we will see that in
the implementation details of the type
ratio technique there's virtual
functions we use virtual function
dispatch one of the covers and there's
no templates right so I've got into of
and I take some magical type object of
this magical type and then I call its
value member and then I return whatever
that is and this again is real code that
does what you think it does and then in
some function I can use these objects
around all over the place and they have
nice value semantics right so I'm
creating these things on the stack I'm
not creating them on the heap I'm
passing them by value and and
everybody's happy
okay so how do we make that magic type
this is sort of a strawman
this is anything which is very similar
to boost any or the upcoming stood any
and its best looked at from bottom up so
look at the data member on the bottom
it's a unique pointer to a handle base
we call that handle okay and that handle
base is that first struct and handle
base is very simple just as a virtual
destructor as a virtual clone function
and that's a true virtual clone function
and then it's got a anything type also
has this handle template now the handle
is just a way of saying for some type T
we want to
have something derived from handle that
will have the actual implementation and
that just has a t-value data member and
it implements the clone function and
it's got a constructor that takes a
value of that type T that it was
templatized with and in stores that
right so this is the these are the
definitions of those declarations so you
know the remove reference there is kind
of noise there's a couple of corner
cases where you need it but you can
essentially think of the first one as if
I if I give you an object of type T I'm
going to make a new handle right handle
remember is the the templatized type the
most derive type so to make a new handle
and I'm going to make it with this
optionally moved in object of type T
okay then I've got a copy constructor
that's also very straightforward the
copying constructor is just cloning the
internal handle into you when you do the
copy right so notice that we are doing
dynamic allocation just to do a copy
here and then the assignment operator
and the well both the assignment
operators the the one that takes any
object and the one that assigns from and
anything are both you know just using
the the previous two members they're
using the copy and swap idiom okay so
now this is the only other two
definitions we need the anything handle
definitions okay so one is going to take
a value of type T and move it into the
internal storage and the other one is
just going to make a new handle on the
heap with that data member copied into
it so every operation we're looking at
here where we're either making an erase
type we are copying assigning we're
always going to copy the underlying
object and we're going to do a heap
allocation in addition so if the
underlying object
you know touches heap when it's when it
gets copied that could be a problem so
we'll look at how to optimize this but
this is the simplest form of type
erasure and one you might have seen
before
sort of the purpose of the talk is that
this isn't the only way to do type
erasure in the sense that there's way
more optimal ways to do this and I'm
going to show them to you shortly so
this is what anything does for you it's
it's like I said like boost any you can
take an int or a pointer to an int and
than anything a you can say a equals
that int or a equals that pointer you
can assign a double to at a string to it
a food to it right almost anything so
this gives us duck typing like in Python
and I've actually started recommending
to people that they have something like
this in their C++ code base if they care
about scripting and they're starting a
new project related to scripting don't
bind to you know whatever language
you're using like Lua and Python
they're great scripting languages and
when you get to a certain point you're
spending all of your time trying to work
out the changes in the bindings from one
language to the other if you have a
bunch of interfaces to functions on the
C++ side whatever you want to expose a
new interface or a new type you just you
know have some string to type mapping
somewhere and then your scripting
language your you essentially have no
binding layer you have no no work you
have to do to bind one to the other
right so you can define all your
interfaces using type razor and you get
duck typing but that's happening in C++
not in this other language for what it's
worth it that's a that's a pretty nice
way to do things okay so anything cannot
actually really hold anything it can
hold anything that is copyable right so
it should maybe be called copyable for
exposition I just called it anything so
how do we get back to this how do we get
back to doing stuff like on this slide
right we didn't see any way to actually
call a value data member on some
arbitrary type that we put into our
anything so how do we get there well
it's actually very simple repetitive we
just take the value data member that we
want on the anything we put it there and
then all it does is call value on its
handle okay so then we need a pure
virtual value method on the on the base
class and then the actual implementation
on the template drive class okay does
this kind of make sense this is unclear
to anybody okay
yeah all right well so what it what is
it that you're unclear constructs for
you some dry title and turns into a rut
and volume will be played disappears and
the important thing about declaration is
that it's all contained within the same
class which differentiates it from both
the lazy worthless 98 deals with vectors
and the way we're about to move towards
of polymorphic resources so we have
three different things we have sequences
I need and vectors and alligators that
are compile-time
we have type ratio which is contained
within the class and the faculty lives
there has been an instructor as a
template instructor a third one is you
pass in the base class of the resource
which I've been doing
I'm trying to understand again I'm
trying to be clear what this is trying
to do this is similar to the way water
uses decoration okay so the question if
I can boil it down the question the
question is how does this relate to the
example of like shared pointer and it's
de litres what you're talking about
right now okay so a shared pointer has a
deleter that you can give it it can be
any old delete or anything that when you
give it a pointer it does the Belizean
is supposed to do right so it has a
member function delete or something like
that remember it's API but it's
something where it's some kind of an API
that's known in advance and anything you
give it it will be able to use that API
that object right these objects don't to
know about each other and this is
exactly what we're doing here right
instead of containing that within a
larger object we've got anything that
has a value member I can stick it in
this thing right so inside of shared
pointer there's a holder of some kind
that you're putting your deleter into
right that deleter is an erased type and
that deleter is going to call delete on
that object and pass it the pointer that
it's managing or what happened right
does that kind of make sense there's no
difference in the objective there the
objective is the same the idea is if I
have divergent types I have nothing to
do with each other want to be able to
use them with a common interface that's
that's the point underpinning this whole
thing and that is a form of runtime
polymorphism right and it's a better way
to do runtime polymorphism than
inheritance so okay all right well
okay so we can add any API we want we
added value but we could add you know
log or dump or whatever crazy thing we
wanted to put in there and it's easy to
do but it's very repetitive to do this
okay we'll get to that in a minute
so now let's let's return to this
widgets and layouts example I started
with so if we have these two disjoint
api's we need to support right we can
make these arrays two types so I've cut
out the boilerplate here right all the
the copy constructors and the the three
times repeated number function and stuff
like that so you've got the idea some
some widget type right that is can be
rendered with this render member and
then a layout abble type which has this
geometry member that gives you its
layout geometry you can use to do its
layout okay so here's a button object
that we are a button type we create and
it's got a render method and a geometry
methods got some other member functions
in here too and and that's fine but it's
got the two that we need so we can use
it as a widget or as a layout right so
with this function do layout I take any
layout of allel and I say okay give me
its geometry and then I'll do its layout
render widget says give me any widget W
and I'll say render that W and and we're
done okay so now this function down here
I've got a button on the stack I say do
its layout and then render the widget
now I'm doing I'm making a copy of this
button so it's not like I'm mutating the
button in that operation we'll get to
get to that kind of thing in a second
but this is real code and this works and
this does what what I'm advertising
alright so performance is a little wonky
for these things because like I said
before we're copying the underlying
object we're touching heap almost every
time so we can we can do better but
first let's look at what we're doing
right now so function call overhead once
you've got one of these things made once
you've gotten to race type constructed
and it's got its it's contained object
the the function call overhead the
profile function calling functions on
that thing is exactly the same if I call
value on one of those types you saw
before or the erased types value member
I get the same thing I get virtual
function dispatch it's the same behavior
but I have to do a lot more heap
allocations right so if I can
struck something with traditional
polymorphism I'm going to usually
dynamically allocate down the heap and
with this simple form of type ratio I've
showed you so far man do the same thing
but then what I also copy it or assign
the type erasure version I'm going to
have to touch heap as well and worst of
all the whole point of this was I want
to be able to use different types or the
same interface or take one object and
use it with different interfaces like
the button I used as a layout layout
able and as a widget in order to do that
every time I bind it to one of those two
I have to again touch heat so that
that's kind of a problem the reason I
put that asterisk there by the know
under inheritance and getting an
alternate interface is that you can have
these bolt-on interfaces like talked
about before and get multiple interfaces
out of something use multiple
inheritance multiple inheritance to do
that but again that's that's a non
polymorphic use of that of that type
okay so let's see how how we can
optimize this so step one we can accept
a C ref and ref and will contain a ref
wrapper okay and this is just for
exposition this is showing the
complicate the complications that this
entails I'm not asking you to grok this
it's not important they'll be code later
you can look at but it's getting
complicated enough I'm gonna stop
showing you implementation details from
here on and then you need this
specialization so that if you're given a
reference wrapper you actually hold it
as a t ref instead of a reference
wrapper so that everywhere in the
implementation we just say dot foo bar
whatever the member name is we're not so
they get and then whatever the member is
okay so for using refs instead of just
copying everything all the time the
allocation profile did not change at all
but now we don't have to copy the
underlying object for any of these
operations as long as we pass in a rat
for C ref okay and if we want to get rid
of the dynamic allocations we can try
maybe doing a copy-on-write
wrapper okay that's going to mean that
in this example we create a widget from
a button and that has to touch eat just
to construct the thing and then we have
this w2 we make from w1 and there is no
copy there but if we want Moodle
access to it by calling the right member
of the wrapper then that's where the
copy happens yeah copy-on-write has a
nice side effect that you get thread
safety in many cases for free that is
simply because when you want to mutate
an object you're never mutating the
object itself you always mutating a copy
so if you structure the code with lots
of these objects around you get to
essentially pass objects around by value
and they are ref counted
so there's atomic rough counts in place
you pass them around by value and even
though it that that sounds like you're
using a shared pointer kind of thing
under the coverage in fact it is
equivalent to a shared point of one of
the implementations I have here that
you'll see in the code online if you
look is done in terms of shared pointer
but it's a Const reference to those
things so that's that's fine to have
shared immutable references Yeah right
it just works
yeah Tony right and and it is I I stole
the copy itself has to be safe it is I
stole Shawn's Shan parents
implementation so I'm pretty sure it
works ok so now that we've got this
copy-on-write
approach we don't pay for copies and
assignments anymore in terms of touching
Heat right that's great but now we have
to touch you twice so it's due to
dynamic allocations for the construction
and binding to an ultra interface and
and in case it's not clear binding to an
alternate interface and construct for
the type ratio case or effectively the
same thing I only put them separately
because they're not the same thing in
the traditional inheritance case ok so
now if we integrate the copy-on-write
the stuff that the wrapper is doing into
our type erased type or the scaffolding
and our race types then we get the same
benefits but only only going to the heap
one time okay so now forget all about
the copy-on-write stuff we just do the
small buffer optimization instead what
does it look like well we can we can
assign a one in two
anything without going to the heat we
can assign a ref in there because you
know reference rapper is also pretty
small but if we some for some reason
need to create an erase type that's
going to hold on to this thing for a
long time it's just not just temporarily
binding to an interface with a ref or
something then of course we can't avoid
the allocation and that that's what this
looks like so again small buffer
optimization allows anything you know
small is on the Left large is on the
right for all the small objects
including references we we don't we
don't have to go to the heap and for
largest we do okay so now if we put both
of them together I won't dwell on this
because I'm just showing you things I
already showed you the previous two
slides we put both of them together we
get this nice profile we when we have to
construct something from a large object
that won't fit in the small buffer and
we're going to hold on to it and that's
where it's going to live forever we're
not just binding it to an interface
temporarily like an erase type interface
then we have to pay for heap allocation
and every time we do that binding to an
alternate interface again is the same
thing we have to pay for that if the
object is small enough that if it's a
small buffer we don't do a heap
allocation and if we're just binding to
something temporarily we don't do a heap
allocation even if we have one of these
large objects we had to copy its value
of and and dynamically allocate memory
for copying assignments or free just
like you're using a pointer with
traditional inheritance and this is
actually the point at which we are able
to beat traditional inheritance in terms
of heap allocations in some cases
because something like that button
example from before I used it as a
layout layout Abul and then as a widget
in that case I didn't have to
dynamically allocate that button and I
didn't have to use reference semantics
as I would have if that was using
traditional inheritance I would have
created that button on the stack and
then it would have references to the
widget or layout able that I was passing
references to the button as I passed it
in as a widget or allowable good
that's the scope delegator model okay
okay yeah so like I said the
implementation is kind of Harriet its
online you can look at it later
okay so what are the wins and losses of
these these kinds of approaches first
you get value semantics that that
hopefully speaks for itself like I said
you should really go see one of Shawn
parents talks online about this it's
very very important for a reason about
code you don't have to write new and
delete explicitly that's nice you can
bind to interfaces that you've never
seen before so when you write your base
class you have to know about all the
interfaces you can have to support and
you don't have to bolt stuff on later
you get a lot of nice thread safety
characteristics from the copy-on-write
approach although well I get to in a
minute and then you actually get the
illusion of heap allocations in some
cases that you would have to do with a
tradition here that's the thing I just
mentioned earlier now the implementation
is hairy right that's I'm not going to
lie to you and you get thread safety and
if you don't need the thread safe and
you're running in a single thread
context then you're paying for all these
you know atomic operations and so you
don't want to do that if you know if you
don't need that okay so there's another
option which is not rolling your own but
using boost type erasure the the best
library for doing type erasure ever made
I know them all and this is the best one
for sure it uses metaprogramming to
generate a V table that's in the object
and that's how it gets as polymorphism
okay so you give it a bunch of different
interfaces that it has to have and then
it will run through those interfaces and
make a V table entry for each element of
that interface that it needs it supports
cast directly to the held type just like
Boustany i don't have that in mind
because I consider that a code smell in
some rare cases you might need it but
the majority case is that I've got an
interface I want to support and I don't
need to cast to some underlying type I
just want to use it with that interface
and I don't need a cast it can support a
free function and operator requirements
on the types that it will bind a erase
type to so you don't have to just say
like it has this member and that member
it can also have free functions that
take an object of that type and that can
requirements you can have associated
type
I'm it's like it has to have a you know
a nested type member with a certain
certain the of a certain type or
what-have-you and then there's concept
maps that are very much like the C++ 11
precede + 11 concept proposal so here's
his example from the online Docs he's
got an MPL vector and that vector is
specifying the interface has to be cop
has to include copy constructibility
increment ability oh stream ability and
this type ID underscore thing is how how
you specify that I want to be able to
cast to this type that the casting to
the underlying type is optional so if I
create a one of these any's on the stack
and I give an int ten to it I can
increment that I can stream it out it
does what I expect if I want to use a
member function have to do a little bit
more work there's this macro that you
have to use and that defines this type
called has pushback and then you can see
in this function append many will take
and it will take anything that conforms
that has pushback interface and in this
case the interface is void int the
particulars of that pushback is that
it's void int and that underscore self
ampersand is the way to say take this
thing by reference not not don't copy it
right so that when you do the push backs
on this container its visible outside
the function right that's the whole
point this is a little verbose in for
this question and there's some other
caveats to this library first of all if
you have if you wanna use with objects
with a pretty small data footprint but
they have a large API you want to use
them with you're going to pay for that
vtable a lot right it's going to make
these objects much larger than you want
in some cases the metaprogramming can
make long compile times if you make a
mistake while you're writing one of
these types you're you're in for some
fun times looking at those error
messages and the small buffer
optimization is not supported it's going
to go to the heap every time you assign
an object and writing cost memory
function it should maybe not have said
that this is not straightforward it's
just that if you do make a mistake you
have to repeat constant several places
if you make a mistake it's impossible to
understand that that's the error that
you made
okay so let's compare that to
inheritance and the hand-rolled stuff I
showed you before so we have left as
small objects middle is
large objects and then write as
references so the previous profile that
I showed you is the same thing repeated
here for the optimized type erasure
handled stuff and then for the boost
type erasure library on every
construction copy assignment or of any
kind you're going to have to go to the
heap and copy the underlying object and
that's regardless whether its large or
small because there's no small buffer
optimization there okay so space
requirements if you care about this then
it's important to note that again the
boost type arrays your objects will grow
as their API grows that's pretty
significant in some cases and the the
small buffer optimization version of the
type razor stuff that I've got is has
that buffer and so if you're always
using it with large objects and you're
never going to be able to fit in that
buffer you're going to pay for that
buffer all the time so keep that in mind
ok so like I said the implementation of
these things a little bit hairy and
you're going to repeat the code over and
over again you've got to repeat all the
API you know all the elements of the API
three places and so forth so how do we
get away from all this cutting and
pasting all right well we generate it
okay so I've got this tool that I'm
calling them type in due to lack of
imagination and so what you can do is
you can take a file that has all your
what I'm calling archetype types right
so a bunch of struts that have a certain
name and have a certain API to them and
this thing using Lib clang will slurp up
that font that header file will look at
those types and do a bunch of generated
erase types that allow you to use
anything that conforms that interface as
one of those okay so this is just a
simple command line example it's very
straightforward all the erase types that
I use in the slides earlier is they're
all generic using this tool okay so your
input is a real header so we're using
Lib clang which is real front end and so
we can use real headers and so you can
have include guards in there they're
preserved you can have headers in there
they get their inclusion gets preserved
name spaces and the relative positions
of your types within those namespaces
are also preserved
any structure class definition gets
converted to an erase type those can
actually be templates because it was
free for me to do that even though it's
a wonky thing to do why not and
everything else goes away right lib
playing doesn't know anything about
macros and comments pretty much so
they're going away for that reason and
all the other stuff I'm just not
bothering with them okay so here's an
example of the input that you would
write you've got some include guard
you're including iostream maybe that
should be iOS forward so you can get the
stood oh stream that you need for laga
Bowls one member it's log member okay
and this is you know again real input
and this is the real output now I've cut
out all the huge spew of of stuff that
we don't care about that's all the
boilerplate stuff you're trying not to
do right but this is what it outputs
besides that so it preserved the include
iostream that that we had in the
archetypes header file the input enter
file preserved the include guard it
added these these other headers that it
needs to do the implementation of the
erase to type and there's a little dance
here because no accept is not defined
yet for Microsoft's latest compiler but
then you can see it's got this
implementation that's that's very
straightforward and looks a lot like
what you saw in earlier slides all right
so it does this based on a form file so
the form file is essentially like all
that stuff that's cut out right there
and then it's got a few tags for like
you know the name of the struct so that
would get repeated for the name of the
erased type and for all the places where
the constructors are declared and it
will also take a block of headers so if
you have a difference like if you have a
different form file you want to supply
that does different stuff in a different
way you might have a different set of
headers you want to include but the
headers only come in once you don't
wanna repeat them for each form so
they're not they're separate from the
form file and all of the versions of
type erasure that I showed you during
this talk have a form file that's
available in this so if you go look at
the code afterwards you can generate any
of the code along the lines of any of
these things and I believe that's it so
this is not live yet it will be very
shortly after the talk and you can go
check it out and I have plenty time for
questions
questions do I have let's go to the
microphones from now on actually so
that's fine so do I have an analogous
recommendation for how to do hierarchies
generally no the reason being that I
don't want hierarchies I want to have an
interface that has a certain amount of
stuff in it and if I have to repeat some
part of that interface because there's a
related type that is a slightly
different interface than I just repeat
that there is perhaps a way to do that
I'm not aware of it so anyone else all
right thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>