<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Titus Winters &quot;Lessons in Sustainability...” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Titus Winters &quot;Lessons in Sustainability...” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Titus Winters &quot;Lessons in Sustainability...”</b></h2><h5 class="post__date">2015-10-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zW-i9eVGU_k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everyone and welcome it's a
little early it's a little late in the
week
glad you were all able to make wake up
for this I'm Titus winters I'm the head
of C++ libraries at Google my team has
been Gavin Cox here you've seen C++
libraries team the kind of very brief
overview of why I'm able to speak about
these things we have about 5,000
engineers that will make a change to our
C++ code base this week our C++ code
base is somewhere north of a hundred
million lines of code and there are
files in that code base that are now
applying for college so we have some
issues in scaling and thinking about how
to how to manage all of this for the
long term so disclaimer everything in
here is based on my experiences over the
last four and a half years of trying to
figure out how to make sure that this
massive ship stays afloat and misses all
of the icebergs the comments and the
suggestions in here are certainly not
official Google company guidance because
we're kind of making this up as we go
along but they are good suggestions and
you should listen to me and I will start
with a very kind of abstract question a
sales pitch for the audience and it is
this I am in possession of a tool it is
of course clang based that if I sell
this tool to you you will have no
worries about your C++ code base in
perpetuity I will give you the following
deal if the audience pulls all of their
cash and gets me five million dollars I
will sell you exclusive resell rights to
this tool right if this is advert
working as advertised I'm
really confident that you can make your
money back on this right who is
interested some hands go up
right nope US dollars some hands go up
right the hands that don't go up is this
because of the cost that I am
advertising this for or is this because
you don't believe that such a thing can
exist I want 5 million because I can
live on a beach somewhere nice in
perpetuity for that I won't tell you
which beach because as I'm sure you've
kind of started to think like tits to
realize right such a tool can't possibly
exist right there's not a silver bullet
here so if you come to the talk like
looking for one slide that answers your
question
sorry clearly not gonna happen
first off like how would such a tool
what are you even measuring when you're
talking about sustainability and it's
actually going to take me a few minutes
to get to being able to define what I
think is a reasonable definition for
sustainability so bear with me okay the
first thing and I've mentioned this in a
couple other talks the first thing that
I really need you to think about is what
is the expected lifespan of your code
right because that is not a given that
varies a lot depending on what sort of
project you're working on alright the
expected lifespan for code on a slide
deck you know the weeks that you prepped
that talk and then maybe you polish it
up again if you run that talk again
right the expected life span of a
academic project is the three weeks that
you were assigned that task expected
lifespan of a startup you got an average
of like two years right most startups
die sorry to tell you all right the
expected lifespan for Google's codebase
right this is why I'm worried about
things on that decades sort of timeframe
right I don't think we're going anywhere
then a secondary question and it seems
kind of a non sequitur at first is this
is your codebase per project or
monolithic because this actually matters
kind of quite a lot and I'll have to
have another brief aside here on the
question two monolithic code bases a
monolithic code base that is one where
all of the projects in your organization
are checked into the same place has some
upsides you get the upside of if you're
doing it right the code base is largely
consistent right you can have policies
and practices and things to try to get
people to be using the same stuff and
writing in the same fashion and that
that helps right it reduces the fact it
reduces the potential for one lone wolf
to be the only person that can maintain
that right make sure that everyone is
working in the same sandbox you share
your toys infrastructure scales much
much better when you're working in a
monolithic code base right we have a
dedicated compiler team they are the
best right if we had a separate code
base and a separate you know for every
individual project a separate code base
for drive and for search and for ads and
for news and for all of the things right
some of the larger teams might have one
or two dedicated people unlike yeah this
is we're gonna take care of the
compilers but it doesn't scale well all
right once you get everyone in the same
place infrastructure scales write
compilers and common libraries all right
all of those things there's good scaling
properties as someone on an
infrastructure team one of the great
upsides to a monolithic code base is
that we get usage visibility right when
I want to change a common API
I have visibility into literally every
place for that API is called so it is a
doable and because we have practiced
it's fairly tractable task to
Doucette new better api change all of
the colors of the old thing and delete
the old one and this is a task that can
be done in days or weeks instead of
months and years if your deprecating
things with a traditional release cycle
but there are downsides to this
monolithic idea as well right I've
talked with people at the conference
here about yeah our organization is
getting bigger we've got fifty or a
hundred people and just sinking our git
repository is now taking too long
right it is a meaningful overhead right
when we have bring in new hires the
amount of history that is coming along
in our repository just like you have to
tell them when they show up on the day
one yeah start your repo sync let's go
to coffee and talk about fill out your
papers all that stuff because it's gonna
take a little while right
things like scaling will get work like
this type of scaling will get worse if
you don't dedicate resources to solving
those problems right by consolidating
you also give yourself bigger problems
it's just that by consolidating it makes
more sense to assign people to fix those
problems
so there's a trade-off there the biggest
con to a monolithic code base in my
opinion is that you cannot just throw it
away and start clean so look at the I'll
explain that um this is kind of
hypothetical very simplified monolithic
code base we have some utility code we
have common RPC because we're in a model
at the code base everyone can use the
common things this helps this is nice
and as you start to grow and you realize
oh we need to add you know a common
authorization system to our services
there's a common place an easy single
per single point like choke point to add
that this is nice but as you start
growing you start adding more and more
edges to this graph
this graph is always just going to be
more and more complicated and sometimes
even stop being a strict dag your builds
get weird like things get complicated
once you start having this graph there
is no way that you can say oh no
everything is gone to hell we have to
throw it away and start over because you
cannot take the good parts with you the
good parts are dependent on the bad and
the bad or dependent on the good right
it just becomes a hairball I don't
believe that there is any like
principled way to grow to this scale and
really avoid this problem and keep the
ability to panic a per project culture
means that you get the big red button
option a monolithic culture means you
have to get this right and that brings
us back to lifespan right over the
duration that your codebase is going to
live right you may very expensively push
the panic button on a per project
repo but you will never be able to push
the panic button on a sufficiently large
monolith and so that's my thoughts on
life span why do I care about life span
care about life span for your projects
because change is inevitable this is not
surprising right if you were to ask
anyone like is it safe to assume that
we're never going to have to change any
of the things we depend upon no one is
going to say yes to that it's just that
usually we are very concerned with
getting to the next release in two weeks
all right getting through the next QA
cycle this quarter all right and we lose
track of this bigger picture of you know
at some point yeah we're going to have
to update our compilers right we want
the new language features or even if you
don't want the new language features you
want the new compiler because it fixes
that miss compilation error that
keeps triggering those random bugs right
yes compilers have bugs right if you are
fighting with the completely mysterious
there does come a point where you have
to mistrust the compiler tooling changes
you have to be prepared for that at some
point bugs will happen right it was
heard of heartbleed who had a system
that had some vulnerability to that who
actually worked and made sure that it
got fixed I hope those are the same
hands right bugs are gonna happen right
even if you attempt to never change
anything at some point we are going to
have bugs like heartbleed right you
cannot pretend that everything you
depend upon is completely static for all
time not if you want to be a safe
responsible citizen of the information
technology world right you're gonna have
to be able to at least patch OpenSSL if
not update open ssl and all the
libraries that it depends upon right and
then you're changing a significant
amount of your web surfing code right
your change is inevitable and new
attacks will emerge all right I'm going
to talk a bit that kind of frame all of
this a bit in terms of things like hash
flooding hash flooding is terrifying
right who's familiar with hash flooding
not too much interesting
so hash flooding is the notion that your
hash containers your unordered maps your
in ordered sets these are supposed to
give you order one lookup all right this
is this is what's you know advertised
right what if your attacker knows that
you are storing some part of your query
in an or an ordered map they know that
when they issue a query to your service
it is going temporarily or for awhile
into an unearned map that is keyed on a
string
that they passed in right they you say
oh I need to do map storage for these
things I'm gonna take the name of the
person in this request and use that to
keep track of you know state about this
request right you're using an order to
map odds are pretty good you're using
standard hash how hard do you think it
is to find collisions that is two inputs
that hash to the same thing with
standard hash on any input on any string
all right this is purely a matter of
just burn some CPU
all right standard hash is not a
cryptographic hash it is not intended to
protect you against that so if they can
calculate a whole bunch of inputs that
all hash the same thing they can feed
all of those inputs to your system and
then your order one lookup becomes order
n lookup as they flood you with this
your nice quick I just need to go check
this thing in my hash map becomes an
order n operation and your service
crawls to a halt this is an attack on
your data structures if you are not
terrified right now you need to get more
coffee and come back okay you're not
paying attention right if you cannot
even trust the things like your data
structures in perpetuity right you have
to be prepared for change right you
cannot assume a completely static
infrastructure in the long term and I
have weaseled a little bit you will
notice usually appearing on this slide
in a couple of places there are maybe
exceptions I would say if you're working
in government contracts I think there
are some domains where it is probably
not the best plan but actually may be
legally mandated that nothing is ever
going to change in which case this is
probably not to talk for you because I
am very concerned with change
so if a change is necessary in the
lifespan of your project do you have a
plan to tackle it that is is it possible
to make a change of that sort and maybe
more interesting do you have practice in
making those sorts of changes and now
this actually gets me to I can I think
provide a working definition for
sustainability your organization's
codebase is sustainable when you are
able to change all of the things that
you ought to change safely and can do
folks do so for the lifetime of your
codebase whether you choose to do so is
your business alright I am NOT saying
that everything that goes wrong needs to
be fixed you totally have the option to
note that this is a problem and choose
to consciously take on that technical
debt those risks that annoyance that
long-term maintenance hassle and like if
you do that with open eyes I have no
problem with that I am NOT saying that
your codebase is unsustainable what I am
saying is if you do not have the ability
to fix whatever problems are going to
come up over the lifespan of your
codebase then you have an issue that
makes sense so in my experience to be
sustainable you will need some or all of
testing too if you're reacting to
something if you're making a change how
do you know that this change is safe you
will very likely need policies right you
will need policies to guide your
engineers to guide release processes to
guide all sorts of things because
engineering is not a purely technical
activity right it is also a social and
enterprise right we are people
communicating with each other
and working out how to you know make
progress as efficiently as possible
you will need some policies there will
definitely be technology that you will
want to rely upon and then you will need
to practice so I'm going to kind of
motivate we'll just start with the
notion okay so you have a problem you
need to change how you're hashing works
we'll start there for example I argue
that you need testing right you need a
culture of testing you may have been to
my talk on testing earlier in the week I
really think that this is important okay
we were talking at lunch a couple days
ago someone was pointing out you know 10
15 years ago it was not completely rare
to encounter engineering groups or
so-called engineering groups that we're
still kind of like shaky on yeah you
should be using version control right
right like if you think back like a
decade or two like you may have worked
for one right like a decade ago the
place I worked for we were using version
control it was very good but some of the
contractors that we were working with
did not and we have to get in big fights
with them about like no guys grow up
you're gonna do this I think these days
it is pretty clear like yeah you're an
engineering company you're gonna have
version control right it's anyone
disagree like is that not your
experience right version control clearly
right Marshall yeah there are small
compelling at this point culturally like
you run into small companies that don't
you're like really great like it's not
like well yeah I guess I see your point
it's like really
okay I think testing is gonna be the
same thing right I think it's gonna take
us probably another ten years before we
get to the point that it's like really
you're not testing we're you think we're
on the forefront of this it's better
over here trust me not least of which is
because tests are your first line of
defense when change is coming right
tests are your first line of defense for
enforcing the contracts of your code and
the code that you depend upon right you
being told you need to write tests is
not necessarily about I don't think your
code is correct I don't think you're
good at coding right that is not what
tests are implying tests are if you like
implying the team that your code relies
upon sometimes makes mistakes make sure
that the way that your code functions
with those dependencies in place is
working properly it's only polite for
the people above you and you get to
exert some pressure on making sure the
people below you who aren't to be
trusted are doing the right thing right
if you want to phrase it that way to
like make it feel like this isn't we're
watching you we don't trust you think of
it this way right this is I think more
palatable for some people and when you
have tests everywhere for the whole code
base it is much easier to tell like okay
I made this change did the world explode
no does that prove that change is safe
no it's at most kind of an existence
like yeah this is not provably unsafe
right it's not quite the same the kind
of web of trust by verification that you
get from having tests everywhere is not
a proof that the code base is working
correctly it is at most good evidence
kind of statistical evidence that you
didn't destroy everything but it's the
best we got I've said this in a couple
places now I will say it again if you do
not currently have a test in culture and
need to get there you're gonna have to
hold this line at some point no more
changes go in without a test and no bugs
can be marked as fixed without a test
that demonstrates the bug and
demonstrates that it's fixed right the
right way to do that is to write a test
that demonstrates the bug and then come
up with the fix so that it's nice and
quick to check to see if your fix was
right it makes all of this debugging
engineering stuff much much easier all
right at some point you have to hold
this line I will admit that if you have
a large messy code base with no tests
right now you will probably have a month
or two where it feels like your velocity
has been slowed it's a finite amount of
time I promise and in the long term you
will be much better off I have heard of
zero instances of groups that had tests
as a like part of their culture and said
we are stopping the testing requirements
so that we can sprint to this release
and that that succeeded in all cases you
drop velocity in all reported cases you
drop velocity when you stop testing and
you increase velocity when you start
testing okay any variance than that is
at most a short-term difference you will
also if you have tons of tests that's a
good first step but you also need test
infrastructure it is if it's hard to run
your tests nobody will do it and if no
one is running the tests and they're not
doing any good and no one's gonna write
tests so compare this is pretty much
what testing was like at my previous job
it's like I think that this package that
I'm trying to make a change to had tests
some some other group wrote it how do i
where are the tests I'll go check the
readme oh those require me to install
something oh but that other group has a
different oh s so I need to install
different packages
oh there's a version mismatch you burn a
couple days on it this is not the most
fun you've ever had then you finally get
to run the test the test doesn't pass
now you're not sure if it's because you
made some changes before you started
running the tests or if your
installation was wrong like this is no
fun right you can easily burn time on
this it's just it's Terry this is
roughly how testing works for us and
this is roughly what you should aim for
right your tests are built into the
build system the same thing that you use
to run the tests or to built make the
build run can run the tests all right we
open sourced basil it is effectively a
very small difference between the open
source basil and what we use internally
and this makes life much much easier
right no one has to figure out how to
build the test where the test lives any
of those things you just spin it up it's
the same in every project very very very
much an important thing because your
tests have to be quick reliable and
consistent across the organization all
right if an infrastructure team team
needs to make a change to something that
everyone relies upon it does not scale
for them to have to learn a hundred
different ways that tests get run and
projects get built right does that make
sense and you're gonna need policies my
favorite policy on testing is what we
call the Beyonce rule which is if you
liked it you should have put a test on
it
I'm not joking
it is official policy that if we make a
change to succour libraries to court
infrastructure to the compiler to
anything and your project breaks like
you start shipping on fire software to
your customers as a result of this
change if you didn't have a test it is
not our fault we will not roll it back
we are not responsible for you shirking
your grown-up duties of like yeah you're
gonna have to have a test for that all
right not our fault
Beyonce rule it's big fan and that's
kind of one of many sorts of things that
I think you need as policies for how to
guide the code base
right that one is very particular to
testing and in general there's a lot of
kind of policy and guidance sorts of
things you can do to kind of encourage
people to be moving in the right
direction all right you need ways to
guide the code base this is more
important and more easier to do in a
monolithic code base I am a big fan of
the monolithic paradigm so going back to
the hash question what if everyone wrote
their own hashes but if everyone wrote
their own hashers and what if everyone
wrote their own containers like
unordered containers right there is no
way for you to fix and defend against
hash flooding if everyone's got like
spun up their own stuff right without
having reuse and consistency the the
problem is intractable right there's no
way that you're going to be able to
track down all of the various
implementations and all of the various
containers and all the things to make
the same fix and test in all of these
different places right you want
consistency and so one of the things
that I find very valuable and
encouraging consistency is a style guide
I gave a talk on style guides last year
I don't particularly care about the
formatting stuff in a style guide pick
one and move on
better yet like pick one encode it in
clang format and move on right there are
far more important things to use up your
brain on then how many spaces to indent
or whether to use tabs don't care
argue about something important style
guides are far more valuable for things
like no in our code base because it's
difficult to gather all of the threads
and have a reliable shutdown sequence it
is super important that you do not have
namespace scoped variables with complex
descriptors for instance because you
know one thread is doing destruction of
global variables and other threads
continue like churning along right this
means that at shutdown which is a very
difficult time to debug things one
thread can be accessing a string that's
already been destructed or a complex
object that's already been destructed
and when you start accessing things that
I've already been destructed you're off
in an undefined behavior land alright
and this can be arbitrarily bad right
you can have horrible data persisted to
your database right impossible to track
down impossible to duplicate bugs a
style guide is a good place to prevent I
like to say no do not have complex
Global's S style guides should be kind
of interpreted almost with the force of
law right if you choose to violate those
things you should be doing do doing so
with eyes open and that's part of why in
my talk last year I was hammering on the
rules in the style guide should both
serve a purpose and that purpose should
be made clear if someone knows why the
rule is there then they can make an eyes
open engineering decision that that
doesn't apply or it's that's a lesser
risk than what I'm fighting against
right now but generally style guides
should be kind of
nearly law you also need code review I
said earlier probably the number one
important thing for making your codebase
survivable is testing and the number two
thing is code review code review and
take it seriously right programming is
freaking hard anyone want to disagree
with that I would actually argue that
all of the interesting software
engineering is by definition about the
hardest thing that we can do and I'll
say why the issue is everything that is
less complex like not on the bleeding
difficult edge of we're about to fail to
complexity everything that's safely back
here this is easy there is probably
existing solutions for this this has
been solved all right there are open
source solutions and there are solutions
you know just all over the place
trip over easy problem solved right
right at the boundary this is where the
interesting work is happening because
anything further out here we can't solve
all right software engineering is the
act of balancing on this edge and
software engineering practices are
everything that we do to help you lean
further out code review helps you lean
further out in a big big way right
because software engineering is hard if
it wasn't hard we would be doing
something else
since software engineering is hard it
makes sense to have more than one pair
of eyes on it and this is not a it makes
sense to have more than one pair of eyes
on it because I'm only a junior
programmer this is straight up it makes
sense to have more than one pair of eyes
on it I regularly do code reviews for
some of the very best pro
rumors in existence and it is never the
case that on a meaningful chunk of
functional change there isn't something
that I catch it could be a perform like
oh we could get slightly better
performance if you did this or that
looks like a copy instead of a move or
often you know this needs to be
documented better
like I know mostly what you're doing and
six months from now when we have to
change this code again I don't want to
have to refigure this out my comment
that right code review
like if code review works for thee and
and is valuable for the very very very
best programmers in the world it's
valuable for you to write take it
seriously
please in addition to the style guides
the force of law we have also found that
there is some need for guidance like on
average you really probably want to
avoid doing this but it's stuff that
it's a much lower bar I would draw the
following comparison we get a lot of
additional warnings and things added to
our tool chains alright we add more
warnings to clang and then make those
into errors so that the build fails but
you can only do that if you are a
hundred percent certain that that is
always an error or in the unlikely event
it isn't an error there's an easy way to
disambiguate it to the compiler right
for example if foo equals five instead
of if two equals equals five right
you meant equals equals the compiler
tells you that these days if you really
meant single equals if you really meant
assignment it says in the compiler
message just add an extra set of parens
there then I'll trust that that's what
you meant right same thing here right
the style guide is the things like the
compiler and then we have best practices
which is things like that are not quite
as cut-and-dry one of the things that i
cite a lot in our best practices series
is things like use our string view
equivalent in api's that are accepting
strings unless you're trying to store it
yourself then take that string by value
or things like don't use G flags our
library or flag library don't define
flags in the middle of library code
define flags in main because flags are
Global's and it's just not good
engineering practice to have all of your
library behavior dependent on Global's
these sorts of things you don't want
like enforced by law but they're good
advice one of the things we do is we
have a process called readability
readability started long long ago the
first non-owner employee of the company
employee ID number three made it his job
whenever a new hire came on board he
wanted to explain how Google works this
obviously didn't scale after some point
and so some volunteers kind of joined
the effort like okay we want to make
sure that you know how Google works this
is back in the days when Google was one
thing and it's made a lot of sense what
they were really doing was providing
mentorship all right we need to explain
to you this is where the utility code
goes this is where the library code goes
these are this is how the style guide
works
these are whether you like like the the
tools live right we need you not to
rebuild all of those things just because
you're new here we need you to know like
how our stuff works right and then once
you've demonstrated that you know that
then we say okay now we trust you
the way that we do this
is every change that is sent out for
review in addition to having to be code
reviewed by someone has to be someone
that has readability in that language
it's kind of a badge someone that has
readability in that language needs to
sign off on it if it's the original
author of the change that's fine if it's
the primary reviewer on the change also
fine if neither of those people actually
has the readability badge for C++ they
need to get a C++ reviewer to go to like
check no no no that is not how you use
Const or nope nope nope you are you're
dangling memory there you need a
language person to to check through
things I don't know that you have to
have something like that but I strongly
suggest you come up with some way to
mentor and on board your new hires right
and the more the more heavily you invest
in that mentorship the better your
outcomes are going to be in my in my
opinion because that like the point
where you've just hired them is the
point where you have the best ability to
bring them in to consistency with how
you want the organization to run and
then you may I don't know it's
definitely an order of importance you
may want to have some sort of churn
policy we added a rule at one point but
still we obey that the infrastructure
teams are not allowed to change things
and push the work of reacting to that
change off onto everyone else just
willy-nilly right if they're changing
things they should do the work of moving
you from system a to system B and you
may also want something about just
making textual changes across the whole
code base depending on if you're worried
about people making silly changes at
scale we occasionally have to tell
people no
I don't care if you go fix all the
British Spelling's of grey it's not a
good use of our time
oh you'll also want technology clearly
we're engineers we like technology where
do you invest for long-term
sustainability you're gonna probably
want distributed building tests right
you probably have some sort of
distributed build system if you're
starting to scale up I would strongly
encourage that you consider using the
same distributed building system to
distribute running of your tests as well
right because like I said earlier if it
takes like two hours for your developers
to run the tests and make sure that
everything's okay that reduces their
development like cycle usefulness quite
a bit if you can distribute that if you
can make the tests run nice and quick
right they're gonna be much happier
they're gonna run the tests more and
your codebase will work better for
consistency you probably want to pick a
common test framework I like G test
there are many find one be consistent
don't let every team make individual
changes to it and tweak their own copy
like use one make it common make it
consistent tests ought to be built into
the build graphs as I kind of alluded to
but your test should live right
alongside the code should live in the
same directory as the code that they're
testing and should be easy for everyone
to run in a common sort of way and you
get into things like how do you actually
generate a change at scale for hashing
this is not really an issue right we're
gonna go into the standard library we're
going to go into our hash utilities
we're going to go into a couple like
known places and we're going to make
very targeted changes there but there
are other types of changes where you
need to update the text of the code base
we had a talk on this last year my
colleague Hyrum
talked about how we use clang mr and
some other tools to generate the textual
change and figure out how to test and
get that the the massive change
submitted clang mr we could give a whole
talk we probably have on clang Ammar but
very briefly this is clang Map Reduce
and we are using the clang internals
like take the abstract syntax tree after
the code has been parsed and apply
pattern matching to the syntax tree to
find at every place where a call is
being made to this particular function
with a parameter of this sort of type
and you can express arbitrarily
complicated things in there it's far far
far more powerful than regular
expressions obviously and then once you
have identified a piece of code like
that generate an actual edit for that
call then it's just a matter of checking
in all of those 10,000 edits other
things that are gonna be very useful for
the maintainer zuv your code base are
things for code base understanding I
really really like that we have an
indexer this is a new concept as far as
I'm aware we have open sourced the
indexer I recommend that you maybe
figure out how to spin it up and index
your code because you will find
surprising new uses for this the indexer
idea is C++ you cannot run search for
get to find all of the places where a
get method is called on your class foo
but you can ask the indexer hey index I
have class foo tell me everywhere that
dot get for that class is called this is
based on we did a build last night of
the whole code base
and just remember everything about the
ast from the previous evening okay find
me
every file where that exact function on
that exact class is being called and
this will pierce through macros and
templates and all sorts of things right
to get you exactly the set of things
that you need it's very handy for
maintainer you probably also need a
proper regular expression search and
things like that
I recommend investing there and you
definitely need tooling for bug
reduction because the easiest way to not
have to like make a giant change is to
prevent those problems from happening in
the first place right you want a good
healthy code base run continuous tests
run continuous tests with the sanitizers
turned on I am also a big fan of static
annotations we use static annotations
for thread safety this is available in
clang and older GCC s I think we stopped
maintaining it in GCC and the idea is
basically this we're gonna have some
class we can say there is data in this
class that data is guarded by this lock
nice and simple and then I will also say
you cannot call the function update with
that lock held just by saying guarded by
lock it is now a compilation error if
you touch data in a code path that
doesn't have the lock held you can also
prevent deadlocks and it also enhances
the the analysis understanding of the
control flow if you tagged things as you
cannot call this function with the lock
held and you must call this function
with the lock held this is thread safety
enforced by the compiler every time that
I inherit a package kind of an orphaned
package in our code base that has any
threading behavior the very first thing
I do is go annotate just the simple
parts run the build build always fails
there are always books
all right this is super easy high-value
raise your hand when you spot the book a
couple hands starting to go up there we
go 10 seconds for the quick ones a
couple hands still haven't gone it
clearly the bug is there's a path out of
here where the lock is not released
you should probably fix this by having
REI like on your locks but not everyone
does this by virtue of just having
annotated the mutex class that
annotation the the compiler now knows Oh
unless I specifically said otherwise in
this function every path out of this
function better have the same
characteristics on the lock specifically
I took it I need to release it on every
path those are great they don't catch
everything but they certainly catch a
lot we can do more complicated static
analysis with things like clean tidy
see also tricorder there's been talks
about that in the last couple years
tricorder is our general-purpose
language agnostic platform for plugging
in static analysis tools and having the
results of those static analysis tools
surfaced in our code review tool which
is exactly the point well which is the
latest point in the development workflow
that you really want that information
surfaced it'd be nice if you had that in
your editor as you were going but
sometimes the static analysis is a
little too expensive for those things so
at least trigger it so that it's there
surfaced at code review time client ID
in particular is automatic calm polite
compiler based code understanding
looking for particular anti patterns so
you could have something like this who
sees it couple yeah correct ID sees it
and this is not particularly
revolutionary but it's nice because the
compilers are better at spotting this
than the humans right this is easy quick
Quinn right you can stop worrying about
stuff like this and just offload to the
compiler focus and code review on the
higher-level things like is this
documented properly is this a sensible
design are you doing are you solving the
right problem
compilers not as good at that sort of
thing and then this is kind of the most
important part of all of this you can
have practices in place you can have
technology in place to try to prevent
problems from coming in but you're gonna
when it comes down to it if it is a
crisis if you have to update your hash
if you have to update your compiler if
you have to update a open SSL and
rebuild and deploy and all of those
things do you have practice in actually
doing that right because it's one thing
to know in theory that you can make a
change and it is quite another thing to
know that you can actually get it pushed
all right it turns out that fixing like
doing low-level code based maintenance
doing cross-cutting broad textual
updates to the code making changes to
core libraries all of those things are a
skill like anything else it is a sub
skill of the grater thing of being a
software engineer
I put there a skill and all skills get
better with practice you will need
practice you will need some sort of
insight into like how is this all gonna
work you like off the top of your head
can anyone estimate what is the largest
number of files that you could in your
codebase submit in one change you might
want to know that you might also want to
know why not to do that right if you
submit a change of that maximum sort of
size will you be able to roll it back
will you be able to roll it back two
weeks from now without practice you will
not know the answers to these questions
and I cannot tell you the answers to
these questions because it clearly
depends on your codebase
your organization right you'll need to
figure out how to do those things on
your own and you certainly don't want to
do that while the thing is on fire I
will revise I will revisit you're gonna
need testing right you cannot know that
something is safe without tests it is
not sufficient but it is necessary
you will need policies to mitigate the
crazy because I guarantee that the one
guy on that team that sits off in his
own little corner and has built a whole
domain-specific language is making
trouble for your codebase guarantee it
right you need to have some policies to
like rain that stuff in you need
technology technology can help avoid the
necessity of like reacting in a panic
and you need practice you need practice
you really really really need practice
you cannot do this live the first time
over a long enough period change is
inevitable think about how long your
codebase is going to be with you and
decide if you are prepared for a scary
one if you are prepared for the big one
in that period if the set of important
changes that you know you ought to get
to is only growing you are eventually
going to fail if you cannot chip away at
the list of yeah we should get to that
eventually the technical debt is going
to overwhelm you on a long enough time
horizon right you might have 10 years
before it starts to matter I hope you do
good luck but eventually these things
add up there are definitely problems
that were introduced in our code base
almost 10 years ago that we are just now
getting around to like properly solving
and unfortunately there are complicated
reasons why they went from a low level
annoyance
yeah if we don't solve that in two years
it is going to be a significant
organizational problem now we have a
time line like we cannot fix it
leisurely we have to go do it now I wish
that we had planned it slightly better
technology coding standards policies
more technology will make it possible to
make changes safely and practice makes
perfect
okay good luck
hello okay um I have a question or maybe
try to get your thoughts on it you said
something earlier about how ten years
ago not a lot of startups or even small
companies use source control but was
that a consequence of it being more
difficult to set up source control at
that time and now it's very easy because
we have great tools and things that help
us out so is that why that changed and
is testing getting that way where people
don't do testing because it's difficult
to do and are we getting better at
testing I don't know that there's a
definite yes or no to that I would argue
that source control 10 years ago I mean
we still had subversion that was fine it
wasn't so bad I mean it's certainly
better than RCS like if you go back to
RCS then yeah like I can understand that
you might not want your organization to
pay that cost for source control yeah I
think some of it was advancement in
technology and I think a lot of it is
the far simpler thing of as an industry
we've gathered enough war stories and
battle wounds to realize like no you
have to do that
I suspect the same as happening in
testing I hope sorry do you have any
suggestions for convincing co-workers
and our management that testing and fast
builds are a good idea yellow that's
what I thought no like there's there's
more you should make the case you know
like if it's not you know clear by
inspection that something would have
been caught earlier start keeping a log
right keep your secret log of like yeah
we shipped this bug that bug was pretty
clear that we could have caught it by a
unit test we shipped this bug
pretty clear that that would have been
caught by a unit test shift this book
integration test would have been better
for that right and if you come to them
with probably you know three months
maybe six months worth of like log on
that write estimate like took us two
weeks to debug this right it takes a day
tops to write a decent unit test tops
right most the time is more like hours
all right like that's a pure financial
sort of trade-off right like the I think
the hard part is a little bit of that
like I certainly have met management
that was unconvinced that tests were
adding to the bottom line but I don't
think it's a super hard case to make the
thing that I think is usually harder is
the engineers who don't like feeling
like you're saying that they're not good
at their job right and it's not about
that it's about it's not about proving
in the moment that your code was correct
it is about proving for evermore so the
code stays correct because change is
coming right and without some sort of
proof that the code stained correct
in the face of change mm-hm so but it's
it's hard we're gonna all have to we're
gonna have to share stories of how we
convinced our organizations to test next
year yeah hi thanks for the talk could
you share any best practices in how to
handle avi stability or do you simply
not care because he using monolithic big
thing with everything so you could even
change to STL did you say a bi or API
well both right it's kind of related
like if you change to avi you need to
recompile everything and that takes a
long time yeah in a monolithic codebase
you worry a lot less about that
ABI compatibility you definitely do have
to work worried about because like we
have third-party vendor code sometimes
I'm like there are bits that just have
to be precompiled you can't break that
so you you will have like your tooling
teams will have to worry about things
like a bi compatibility for api
compatibility having knowledge of how
your code is being used is the big win
right like we have a monolithic code
base everyone builds from head the
indexer is just indexing it head clang
MapReduce runs basically a head right so
I don't have to worry too much about API
incompatibilities when I'm making a
change because I can see where it's
likely to break if I run it through all
the tests I can see where the build
broke or where the test is broke and
then quickly make an edit to everybody
to change them to the new thing I have
hope that going forward this will become
practical for domains that aren't
monolithic by virtue of here's the API
that you're depending on I changed it in
this release here's a tool that updates
you to use the new thing because this is
totally practical we just have to get to
the point that we trust that sort of
tooling in a world where we build
software for a lot of different
platforms we need to have build tools
that are able to handle all that you
suggest that we use blaze well basil
sorry but basil doesn't support Windows
which is a pretty important platform so
do you have any recommendation on how to
manage all those tools in a big codebase
where you have to build Windows Mac iOS
Android and everything and everyone
wants to use their own tool we have we
have some of those problems because we
do ship code for Windows and we do ship
code for iOS and
and Android and you know those things
that there's the monolithic part of the
codebase and then there's the little
bits of the code base that fall into
those cracks and mostly we're working
for that right now kind of by groping
blindly uh we actually just talk more we
find the teams that have those sort of
requirements and we ask what tool chains
are you using what platform are you are
actually building for how can we get
those sorts of things automated into our
system like either by a VMS or whatever
so that we can get them back into the
they'll be kind of a weird case but we
can get them back into you know to as
large as possible the main stream sort
of development standard and the other
part of that that's really important is
once we know what tools they're using we
have to also enforce minimum
requirements right like I will not allow
you to use a Windows compiler from 10
years ago because that's holding back
our ability to use more modern language
features usually in the code that needs
it most usually in the utility code
right and that's really unfortunate
right so getting a sense of like what
are all the things you're using and then
starting with just asserting minimum
standards and best practices and trying
to push those forward that starts to
help we we're going through some of the
same I expect that there will be there
will be work in this area hi I have a
question about code reviews yeah more so
in the area of quality of them mmm we
Institute a policy where every check-in
requires a colleague to code review if
you look at Cody views of the same code
one might say
looks great the other the other might
have a page worth of things that they
see wrong did you
experience any of that and and how do
you fix or and how did you go about
fixing that you do absolutely experience
that we do certainly have some of that
there are certainly teams that take it
less seriously than they probably should
one thing is even if you send the change
to two different reviewers and get two
completely different answers that's not
necessarily that isn't enough to prove
that there's a problem right
one person may say that is functionally
correct and you wrote some of those
things in Asian style differently than I
would have but I don't care whereas the
page of review notes may be you know
just all nits about well I would have
named this something else and we
actually eventually got to the point we
had to have policies on when it's okay
for a code reviewer to like be putting
down their foot and when it's not right
like you can request that you make those
sort of ancillary changes but if it's
not actually important don't fight and
die on that bridge the other thing like
in readability actually is a big one I'm
working on making that much more clearly
a mentoring process and I'm I have kind
of a pilot program running of a slightly
new more long-form mentoring and one
thing that I'm doing is lurking a lot of
the code reviewers and sending them
comments about oh you said this that's
actually not what I would recommend or
you said this here's a nice citation for
that in the style guide because it's
much more valuable for people when you
say this is wrong it's much more
valuable to say don't do this because
and it's very nice when you say don't do
this because and here's a citation right
and so teaching the mentors to be better
mentors scales very nicely so that's
that's
things I'm working so you gave an
example earlier of a ten year old piece
of code that that has now become
critical that you need to change in the
next kind of two years that would never
happen well it happens to us all the
time we have a very similar kind of
legacy code base which is a similar size
I guess have you developed any
strategies for influencing or I guess
relating to management the importance of
investing in core infrastructure and
modules so that we get the correct
amount of people on it let's say a
company that doesn't have infinite
resources I cannot express how much of a
failure I have been on this point so
like high fives all around like it's
it's we've had some success in the
tooling stuff especially because those
are nice easy things to kind of quantify
like when you look at here is a graph of
build times that is going in a bad
direction then they're willing to throw
some you know some effort at compilation
times and things like that when it's a
matter of hey guys these api's are bad
and everyone's complaining they're like
I don't know how to prioritize that
versus dollars or traffic or QPS or
whatever and so it is the hardest part
of my role by far is figuring out
compelling ways to make the case that no
still got to do this nope this task is
not going away
nope as we scale up we we need more
support not less so it's it's alright
please someone come tell me how to
convince management I will buy you
dinner
so the tasting is a central part of
development process and sometimes you're
faced with the problem but code base
testing becomes the overnight period of
execution how you solve this problem so
if you push something in a base coat you
need to pass through a lot of coverage
so it's may require a lot of time and
some time it's more than a day
Howie also with us kind of young you'll
note that I specifically said like work
on distributed build and test
environment because it is not gonna work
to just have every developer running the
tests locally right your tests are going
to scale with the number of hours of
effort that a suite has put into the
codebase total right and we're looking
at 30 Sui millennia in C++ or something
like that software engineer millennia
no one is going to be able to run
sequentially you've been on all the
cores on they're very nice desktops all
of the tests clearly you have to have
this distributed test environments so oh
that's a minimum first step as to it
still takes a while yeah it still takes
a while we've learned too we are always
working on probably six or seven
different things because you just have
to wait until it's done cooking and you
also have to learn when to trust that
this is safe enough in this move all
right the last question just harking
back to the previous question I mean the
one before last one of the things I've
noticed over a long period of time
relates to the role of leadership in
arranging for the kinds of things that
you're talking about to actually happen
and you alluded to some difficulties in
getting some of those to happen and I
wondered whether you had any thoughts
about encouraging and nurturing and
ensuring that such leadership and I mean
the qualities of a leader to make these
things happen
actually present in the organization or
whether it's just really the luck of the
draw
I think the hard part is that for a lot
of these things unless unless your
engineering leadership has been very
forward-thinking it is going to be
unclear who is responsible or authorized
or anything to like take a given step
right as you scale up like every way it
becomes easier for everyone to look
around be like not my problem and in the
worst case everyone looks around and
says I don't have the authority to solve
this and if if that's the case like if
everyone looks around like I don't think
I have the authority to to approach this
problem
then your organization is doomed
right and so one of the things that has
been in Google's DNA very early on is
the phrase act like an owner which is
assume that you have that power it is in
many cases especially for things like
making organizational shifts and kind of
policy shifts it is far better to
pretend like you have that power and
just do it and see if anyone says no
then to let everything go bad and you're
not necessarily going to make all the
friends by doing that but you'd be
surprised I think in practice that works
pretty well so anyway thank you all very
much for your time thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>