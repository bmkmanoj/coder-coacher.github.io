<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Edouard Alligand &amp; Joel Falcou “Two practical applications of the Brigand TMP library&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Edouard Alligand &amp; Joel Falcou “Two practical applications of the Brigand TMP library&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Edouard Alligand &amp; Joel Falcou “Two practical applications of the Brigand TMP library&quot;</b></h2><h5 class="post__date">2016-10-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ky0JdPh_LgE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning good evening for those who
are still jet-lagged
I'm Eduardo and this is aku we are the
author of the polygon library today we
are going to spend one hour to explain
to you what you can do with your library
and why we design it where it comes from
there's going to be two practical
examples of what you can do with it and
this is examples taking from thank you
very much coming from actually both of
our production code so we started to
work like something like one year ago
the reason why I started working on this
is because on the production card we had
we were massive use of boost MPL which
is boost metaprogramming library and we
were getting more and more annoyed with
the computation time a boost ampere and
the fact that he's been done in c++ all
three if you leverage the novelties of
the C++ 11 language there is a
possibility to write much more efficient
meta programming code and I have been
reading an article written by Peter
DeMuth which we was I think inspired
from something done by Eric niba and I
realize that would be very easy to easy
relatively easy to write a meta
programming library and Gerald joined me
right after because he was working
almost exactly the same thing on his own
and the source code is available on
github and it's the boost software
license so there is really no constraint
on how you can use it the question that
comes very often is why should I care
about meta programming library what
should I care about meta programming
isn't meta programming something which
is extremely advanced C++ do I really
need it and we hope that at the end of
the hour you will think that it's
actually useful
even if it were 100% useless it's a very
very very good mental exercise and it
will make you a better programmer I
believe so this talk we start then we're
going to explain the principle of
polygons what you have inside the
library how it works then we're going to
show you two use cases and then it will
be time for questions thank you so let's
see what's what's inside brilliant so as
hello says Regan is actually based on
the general principle of boost MPL which
means that we reuse a bunch of their
contexts or concepts so as MPL what we
do is you don't want to end all mr.
programming components in divide by
writing random template functions and
random temper classes you need to have
some kind of structure and the structure
we took is pacifist boost ampere one
which we which rely on this separation
between compile time algorithms working
on compile time sequence using compact
and functions so we we have this subset
of algorithmic functions that is
respected there where you we are very
well limited but useful list of sequence
so post MPA is known to have stuff like
compile time vector compile time list
compiled time ash Maps compile time set
and so on and in fact the only ones that
actually make sense those three which is
a list the settings of map difference
between this and vector are completely
well i'm confidential so we will get rid
of that so you you end all by which you
usually started writing code by fitting
something in the sequence on which you
can apply some algorithms like finding
touch in the sequence counting how many
times something is acting in the
sequence transforming it sort merge
enacted so on and so on and so on and
you can use
pre-built function
to build your your computation on the
types and one of the most fancy stuff in
Bregan is the as something functions
that connected you actually help you
turn a sequence of something into
another kind of sequence or ending up
with is okay I finished compiling
something in the sequence of times and
now I want a total of that or I want to
apply into that and so on and so on so
we have easy way to go back into let's
say a non compiled time code so the
question is what is actually a sequence
in terms of methylamine and what is what
is a core element of that so in Busan PL
a sequence was something that has a
definite tag that was fitting some
interface that's a boost template
function we're able to recognize what we
do is thrown that everywhere away and
type list in brigant is any type which
has Viaduct parameters of types so
brigand list is a list because it's
something which is also form breaking
list T dot dot and so is STD table also
is STD variant and whatnot so is this TD
vector or example XI fronting two types
of types and the allocator type so as
long as your type is a template type
with a list of something it's it's valid
compile-time list and this actually
makes a lot of things very simpler to
manipulate so we don't need anymore to
have a special MPL adapter that takes
some types and turn it into a sequence
everything that looks like this is a
sequence and a small detail we also have
way to properly end all strange types
like void or cysteine array and we don't
care about what's inside these of type
list so as long as you have a temperate
class with varrick template list you're
set you want to compile time brigand
list so what do we do on that well you
can do the usual operation in this like
adding a type popping your type finding
something
concatenating two lists see also
simplification with respect when PR is
as a fact everything is
so you don't need to do type name
something something that doctype you
just fly to meter function on the list
and you get the nose of this directly so
everything works
I collected two written on the can so
you either found this one you can pop
the front of his to you and you can
append those lists and done and the very
interesting for parts of most compile
time libraries is the fact you can
actually run an algorithm like transform
on the list of types applying an
arbitrary so called meta function or
meter function class which is some
things that say I'm taking your type as
a parameters and I'm written in your
type with some transformation so for
example if you want to go from this list
of trouble and into something which is
be the same list but with pointer
everywhere you can just say okay
transform this list and it for every
type in the lace just add a pointer to
the current type so this is also
something we take a page from NPR by
using this kind of pre soldiers that
looks like lambda placeholders can also
add stuff like to find and another set
of functions that Walker exists so fine
we give you a way to look for typing in
sequence or for the types that actually
fulfill a given condition the way boost
a Pierre was in in this was having a
concept of meter compile time iterator
which was rather complex so what we do
is actually use a range based approach
so when you find something in the list
what it does it consumes the Taipings at
least until you find something and it
will return you that this which is so
that the first element in the list is
one type we are looking for and you have
the rest of the list at your disposal
which means that if you want to well
look for the second one you can pop from
this this energy star type and find
again on the remaining of the list and
sometimes what you want to do is not to
find something you don't care if you
where is it what you want to know if is
it inside so we have a found function
that say basically can I did I find
something in my in my list that was
fulfilling some some value and you get
to
I'll tell you yes or no and finally same
way that Empire was doing this we need a
bunch of bridges to go back on the
compile time to the run time word so we
have a for each functions that take
parameters which is a compile time type
list and you can pass an arbitrary
lambda function or rentals that takes a
brilliant type of T as a parameters and
you can do whatever you want with this T
inside like printing its name
instantiating the year calling a
function and it and so on the reason we
do this with this type wrapper
especially because we want to be able to
a place that contain avoid or other
non-intentional types so this is a small
price to pay to get something which is
more homogeneous in terms of where we we
actually end those types so now it's
time for our first use case it were okay
thank you I'm going to give you some
context about the use case so in my
company we sell a database it's a client
server and so the client and the server
exchanges exchange messages and what we
want to do is to see what are we going
to break the protocol in the new version
what happens if we add a new message and
we would like to do that with the
minimum amount of effort possible every
time we do something and the idea is to
use template metaprogramming to do
compile time introspection and
generation and see if the sequence of
bytes matches the structure we have and
if the structure we have matches the
sequence of bytes and if we look at the
whole work that we have to do of course
not everything can be solved with Legon
because you can imagine there is a
sterilization there is a type inspection
we use a booth fusion for that but Vega
is going to help us in those two stages
and we're going to see that it actually
is absolutely not stratospheric code it
very very very easy and I hope you will
agree with me so the first thing you do
is you have your messages and every
message is a structure this is the way
the code is organized and what's very
interesting is that the messages don't
have to have any relation between each
other meaning that you don't need to
have any returns you don't have to do
any kind of polymorphism you can have
two structures that share absolutely
nothing and still use this technique so
personally from an algebraic point of
view I think it's very powerful but the
only thing you have to do is to somehow
have a list of all these messages
somewhere and this list is a list of
types so what we're going to use is
going to use a polygon list but we could
imagine imagine a program where you
would have let's say a variant because
let's say your message is a variant and
then you would not even have to do this
step which is we put all the command in
the list in the card we have we put in
different lists for the kind of message
we have and then we can contain all the
lists into one big list that we're going
to use to do the processing you have a
lot of flexibility in the way you can do
this you can also use the push back push
for whatever function you want the next
step is that you may want to clean up
the list imagine you have some messages
that you are going to duplicate and that
you go know that you don't really want
to test for with backward or forward
compatibility anymore the technique we
use is to have a type which is
deprecated and which is going to signal
that this message is going to be
duplicated very soon and we're going to
use that in an algorithm to remove them
from the list just after them we also
use an ID to have a unique message
identifier this is something you do we
do in our case
a very efficient technique in
metaprogramming to have a unique idea
for every message and we're going to see
at the end what you can do with this so
how do we remove a duplicate in message
again the goal is to write us little
code as possible in boost now you have
something code type
I think it's TTI's for boost type
introspection library I think so you
don't have to write anymore the old s in
a code or any trick you just do please
generate for me a meta function which is
going to be named as type duplicated for
me and what we do is we use the remove
if algorithm on our list use the
function provided and not unlike stood
bind we say will be used the Riggin
placeholder and we get the list without
the deprecated flag and it would work
for any flag let's say you have message
that works on a specific platform and
you just want to test every platform one
by one you could use this technique then
let's say you want to sort the messages
by ID
you could also want to sort them by size
again we're going to use the breaker
algorithm which is sort and the only
trick we're going to do is to write this
little function to say by the way we
want to look at the ID member of every
message and we want to use that as a
criteria to do the sorting and then we
used quote to basically say to sort a by
the way this is the functor you're going
to use for sorting this is extremely
straightforward of course here you can
imagine that you have the whole list of
messages
and once once we what superward and once
we have that then we got in the meat of
the thing it's when we bridge
compile-time code with runtime code so
the polygon library helped us to do all
the compile time code to inspect every
time make sure we don't forget any type
there is no room for typos or I forget a
message you are 100% certain that every
message you're going to get in your
functor is going to be the message you
want to test and here all you have to do
is to once you have your type you want
then you just can create institution the
type you can call your seller ization
code or let's imagine you all you want
to do is to generate the documentation
you could also here just print the list
if that's what you want this is just an
ID that we I want to give you then you
imagination can find many other
applications I'm sure it goes too far so
as a homework you can say let's detect
at compile time that I don't have
duplicate IDs this is something you can
try I can give you a hint you just need
to use the proper structure it's
something like two lines of we go I
think and this means that when you code
compiles you know you not have duplicate
IDs and if you've worked one time in
your life client-server application you
know that duplicate IDs in messages can
be very nicely but this way at compile
Pipkin correlation time you know that at
least this is correct and the earlier
you find a bug the less expensive it is
question so the question is do we have
something to count the IDS at some pie
time to increment no we don't have it in
Riga to do it it's it's funny because
I've been asked exactly the same
question by someone else I think it
would be not very hard to do it within a
single CPP file the problem is if you
wanted to do it across different CPP
files this is much harder but in our
case all the messages are in the headers
so you could imagine that you have CPP
file which is reference and that creates
the new idea every time it's in
distinction you could create a list of
integers for example and you would add a
new version every time you can actually
use a set maybe yeah so you can actually
count and detect duplicates at the same
time Bing Maps and sets so I think with
a set it's not too difficult to solve
this problem and actually we could even
add something but I going to do it for
you what do you think you Roger clay
the question is does the Zeta generator
phase at compile time all right time
it's a very good question and I fail to
explain that at the beginning the
generator creates a program which then
you run and going to generate the code
with the test and in our case it's boost
test code but at compile time you don't
do everything because in our case we
have combined time serialization code
etc but taking a structure with the
membrane utilized see realize that in
the bytes are away you can only do it a
run time sir exactly
so the the remark was you use we use
template metaprogramming to generate the
test code which is then going to be
incorporated in the continuous
integration and this is exactly what we
do no other question okay so let's go on
to the second use case which come from a
completely different type of application
so I've known scale we deal with high
performance computing tools and one of
the stuff you read quickly when you do
this is that your your data processing
code is only as fast as its cache
friendly because basically right now
what came it's a computer for processing
speed is more than memory speeds and
anything else so if you want to take
care of actually using the most of your
hardware you need to be currently you
can find fabrication in the wire that's
a path of if you don't take care of your
cache you're basically wasting 90% of
your CPU power so you don't want to do
that and one way to actually be able to
manage to to get out services of these
bugs kind of things is to manage the
data layout of your computation so you
know that whatever you do you're okay
with your cache one way to do this is
stemming from techniques to end or erase
off structure the traditional
object-oriented way want us to have
stuff like vector of some objects that
represent your your your data or your
state and whenever you want to do
computation on that you just ran over
your vector or structure and do some
and some kids years it's it's okay but
sometimes that's not what you want to do
because you may want to process data for
example we have this array of structures
or arrays square brackets the structure
is as query 1 let's say you want to do
something like I want to do the sum of
all the member m1 and divide every m2 by
this sum if you do the sum of every m1
who is this layout you will end up
wasting out of your cash story m2 you
don't care about so you may want to have
a data layout which is more like the
structure of array where you end up with
structures that contain an array for
each members so you end up with value of
all the member 1 and then value of all
the member to and in fact the correct
way to do this is a third way which is
called the array or structure of array
which is basically this use as a
structure into that where you will
statically limit the size and repeated
by blocks block size having the good
idea to be a multiple of the cache size
and so on
so you may want to test one of the other
because sometimes the application you
write one this and sometimes you want
that sometimes was the third one and you
doesn't know so we wanted to have a way
to say this is a structure she saw was a
data is layout at the I mean abstraction
level and give me this kind of data
layout piece so what we did was taking a
structure or tuple we build the proper
presentation and after that what we did
was building alligators in trailers
range that can iterate over the
structure we just build whatever the
actual layout and so what we did was
actually using bryggen with boost vision
to automate the first part which is
actually rebuilding the data structure
we use inside so let's say we have a
small structure which is a float and and
three integers for example so we use
booze vision that abstract to say okay
this this structure that contains these
four members with XYZ is actually a
frozen sequence so Fusion sequence are
made so you can actually a
by time access an element of a structure
the same way you access an element of
the tuple by playing with the fact that
this tuple and structure are basically
the same except one as member whose name
and the other does not so on so we have
that you could actually use booze fusion
at on any instance of my data to extract
the first second third or fourth element
of the data structure okay so that was
quite easy now what do we win with that
well booze fusion give us a fun emitter
function and the function which is
called as vector that takes an arbitrary
fusion sequence and flatten it into a
boost region vector which happens to be
interesting when you you end up having
computing complex tied with fusions and
you want to go to simple something more
simple and you know in case if you pass
even faster fusion adapted struct to as
vector well you end up with that so what
it is well it's a type it's a template
type with a via the number of type
parameters so this means is directly a
written list so it doesn't have to do
anything so we turn our arbitrary fusion
sequence into a vector which happens to
be compatible with brigant and now what
we do is that we can actually virtual it
the way we want so let's say we have
this ace away structure something of the
form container of some things and some
options so you can walk with list vector
whatever and take care of all the other
stuff so what we do is we take the type
T we turn it into a brigant
list by calling as breaking so either
you have something like the tuple
already or something yes and then you
get flattened and we extract the vector
from the inside and what we just do is
what we want to do is going from the
container of T to a list of container of
each member of T which happens to be
what we do is transform that ran over
the list of members base and put it
inside this template template parameters
container and put all the other option
afterwards okay
you could have so
more complicated that look what's inside
there and replace whatever t found with
a very staff and so on for most standard
container doesn't matter because if it's
an alligator
you get rebind inside and so on and so
on and on so we have that so if we pass
for example Mike data we end up with the
list which is a vector or float int int
int it get turned into a brigand list of
vector of float vector of in vector of
in vector of wind but we can do nothing
with that because I cannot instantiate a
break in list so what we do is we turn
it into a topple and SOA to SOA aliases
just give you the top ball of vector or
container of whatever you were looking
at so you pass a vector of structure and
you end up with the top pole of vector
or each members of the structure and
then you can actually instantiate that
and you get your data layout already
done in the correct way so having the
having the data layout done is out of
the jokes and the question is would you
write that which is something that say I
have a container of something and I want
something which is an iterator so I can
iterate in a you know structure with way
on every sub part of the data layout so
the idea is to do the exact same thing
and trying to find a way to fit that
into a zip iterator such with zip over
every part of the data layout so as in
terms of performances we show that
whenever the SOA representation is the
correct one you can have data feed speed
up or form two or three depending on the
complexity of the members you have cases
where just not loading data from the
third and fourth member because you
don't care of it we knew as much space
in the cache and you can tremendously
improve the performances so that's a
small tool we have that's actually very
useful and the fact that you just have
to turn it on and off by calling it or
not on the vector of your structures you
can quickly test if it's makes sense to
go to this kind of data layout law you
can stack stack with the
a simple one so there's a lot of stuff
you can do with that that's a beginning
of the of the idea people are walking on
having what we call I've ride
Natalie out we're part of the data
structure is in an area of structure and
part of it is Steven structure of array
so you can actually choose which members
of the structure you can group by into
casual not so it was actually probably
just missing a probably a couple of line
but everything was brilliant was turning
to this the the old equivalent MP and
position code was three times as big so
it was a win-win so let's conclude now
thank you so we have time then to have a
look at how the code looks because the
example they are very short the
conclusion we have is that since plus
plus eleven and even more with C++ 14
writing template metaprogramming is much
easier it's much easier for two reasons
first in the language we have features
that makes especially variadic templates
everything more straightforward you
don't have to use macros to generate a
lot of classes just to have a list of
types you even have built in in the
language now the top which is very very
powerful tool in template
metaprogramming because it's a it's a
candidate for type of list of types the
other thing is with plus + 11 + c + + 14
compilation time for template
metaprogramming is much shorter the most
freaking comment i heard about template
metaprogramming is okay sure it's useful
but before my code took like a couple of
seconds to compile and now it takes like
2 days and with Vega we we have instant
compile time and if it takes a lot of
time it's your fault it's not awful and
if I want it to actually be more mean
than that it's actually instant on file
time including on that compiler
we just did oh yes and the code we wrote
why works on Visual Studio 2013 you need
the latest update but it works and it's
in the test and last but not least I
think it's actually useful it's not just
something like you could say okay it's I
did some clever tricks and look at how
how much a good programmer I am and no
one understood my code you know it's
very useful in my case and in the case
of soil the results is that it took less
time to achieve the results the code is
more reliable and you have the feedback
about the correctness of your actions at
compile time which is as soon as it's
humanly possible because sooner than
that would be in your head but that
never happens then yes I think the goal
is to make your job easier we are very
open to comments and and suggestion as
always we already about to release
version 1.3 in our case the library has
been in production for six months nine
months and in your case be six to eight
months - and we know that other peoples
also use them in their code now we have
time for questions and we're going to
look at the layout yes just so I think
it's a good idea so we we have our D
subs there you want to get to the to the
website see other stuff I wanted to
speak about is the fact that someone is
actually playing around is you know
trying to find a rule is actually having
the fastest MIT programming library so
with John is maintaining this bench web
page as a comparable burns of which
programming libraries on different types
of algorithms and stuff
so now which one is the one we should
show and not the other one do remember
I'm just I'm just actually just picking
one at random so yeah so meter is
another methylamine library from I don't
remember his name from someone's a guy
so yeah so the funny thing is to look at
the x-axis in fact which is a number of
types in the in the type list okay so
all it's okay but I wanted to find one
with MPL actually yeah
so ampere blows up at 50 or 100
something and also all the moderns men
women library can go up to I don't know
how many times I think ordinance as a
whip I use use case with 2,000 types or
something like that
yeah at some point it works anyone
there's something interesting to say
about boost ampere is that you have to
define specific macros if you want to
have something like more than 20 types
in a list so 20 types in a list of types
can sound like a lot but actually it's
not that much it's very easy if you do
tricks like we shown like I want to have
all my messages in the list 20 messages
and nothing not in the counties in the
old version of Busia me we were using
NPL at some point we need to have we
have to have these three of types that
describe suffering over vectors and it
was blowing up after 20 except for some
cases you have like 300,000 so doesn't
work well so that's for examples timing
for transforms where we still gains at
well MPF just blow up at some point and
the modern take on writings is
methylamine a breeze can you can you
actually go far far better we also
happen to the fastest on this one just
saying that that's not okay so this is
also a very good there's a question
it's like when are we ever going to
question is is benchmarking stuff up to
500 500 something types is realistic
well the fact is we actually have people
with exactly this exact use cases where
he wanted to build a thousand types list
and soft it and find the first one that
fits something before generating a piece
of code I don't remember the exact
domain that it was to electronics device
or whatever where you wanted to
everything to be computed at compile
time as much as he can so he can you
know have the tightest buying be
possible so we we actually had people
that play with 32:5 okay now the one
criticism that Eric did on that which
was actually natural something question
which was should we benchmark stuff like
I have a list of five thousand types all
the same or five thousand types all
different because depending on the
algorithms memoization such a compiler
can kick in or not and so on and so on
that's an open problem no no great what
yeah well yeah if you have the same type
over and over actually what happens that
the compilers remembers that he sees a
type so it doesn't have to mangle it
again or whatever it does for fetching
it inside the compile time section now
well I think that testing over different
types is what happens regularly so maybe
the correct way to enter that could be
you have to say you know you you fix the
size of your template list like I don't
know like to 200 and you play with let's
say the density of types so you can go
from 0% every type has the same up to
50% every time every type are repeated
up to twice and so on and so on so you
can actually have a decent look at
what's going on benchmarking compiled
time algorithm I think is I think the
meta bench is the first kind of before
exists which is actually you know
standardized and formalized so maybe
there is you know cranking
to cook around but it's the first one
anticipation so is there any difference
between playing and the other one I
don't know what we can actually check
what happens on other one well yeah a
bit okay you can do your own work it
work yeah you see but yeah we are
speaking like tenth of a second anyway
of combined time so but if you look at
em here you see that it was quite yeah
it changed me because I think the
algorithm inside the compilers to end
other types may be different
I don't know how clean and also Valley
dicks but I know it's different from GCC
so probably that's the reason yeah it
changed but I mean the worst case we
endured was this 50-something type list
on visual studio and it just compiled
like like a normal coat so job stop but
yeah compilers version actually yeah is
important yeah I think are important the
question is 500 types are useless is not
up to us to decide we just provide the
facilities and there is no reason to
decide in advance that people should not
do it if someone comes up with the
varied use case you just give the
possibility to people to use as many
times as they want
also one minute of this benchmark is
that all library is improved by
realizing that they had for example
erratic behavior and some algorithms and
at the beginning they in polygon we have
a technique we called the fast lane and
everybody in the beginning would say
yeah it's uses technique we won't do it
and we went much faster than anyone else
and with time they just everyone
everybody does it now so it's good it's
the purpose of course the benchmark will
only tell that you're good at the
benchmark it will not see that we yes
the other funny stuff is that at some
point we decided to change the way we
will present lambda function
because it was clear that that was
something that was pulling us up upward
some other other techniques so we I mean
I think it's a st. emulation between all
of those between mid meter by Eric
ampere and the in the metal guys well
and also so yes the the goal is that
ideally the cost for the library should
be zero that it's not because you want
to use technique that is going to have a
huge impact on your code and when it
becomes you then people are going to use
it more and more and I think it will
result in better code in the end maybe
we can have a look at different
benchmarks yeah so the question is okay
so you have modern template
metaprogramming libraries they are
better in a way than boost NPL just to
be sure
boost MPL it was the huge source of
inspiration and it's a very very good
foundation we just take the logic and
put it into a new language in a way and
the question is fine I have my boost NPL
program and I want to put it to another
library how long it's going to take I
think it's very quick because especially
in Rigo you have almost a one-to-one
match up on the name so fine works
differently you don't you say goodbye to
Ritter at us but this is something you
should you will thank us for you for it
because it's much more convenient you
also change the fact that we are all
eager yes have any more lazy we have
lazy but but its explicit and you don't
have to switch everything at the same
time you can have the two to cohabit for
what
haha because subscription is where it's
an Angie's List that's because we are
dealing with pure type operation so I
think if you go to this may be so yeah
then you get okay
Thank You Louis to just blow my stuff
and I think you were okay
I need that yeah I need a proper
compiler to get another compiled so yeah
so you find an a benchmark in to see if
you're watching news tabs so he
separated the one that you which types
only in the one that is a taraji news
operation to you you get a comparison
against effusion and stuff like this and
topple their watch the other one is
basically all compiled time type
manipulation because it's completely
different piece to two benchmarks and
actually Anna and we got a very
complimentary from well they don't
really saw exactly the same problem
which from the outside sounds a bit
crazy like what I need to template
metaprogramming libraries and the answer
is no doing is not enough you need all
of them yes okay thank you again so we
can have a look at the code organization
to answer the question of okay fine so
you showed us examples have my wizard of
people not keep on master because the
keyboard is actually too big for my
hands so I called press two keys at the
same time so if we look at this you will
if you are boosting pure guy which is
for me which what I've spent most of my
time with you will find yourself in the
place where the organization looks a
little bit the same and to give credits
word use for the documentation we just
imitated whatever was the post MPL
documentation
copied the sin structure you will find
the algorithms here the names are very
explicit and we have actually
documentation and tutorials that we
wrote to to get you started like to
answer the very simple question of how
do I create tab lists how do I use
algorithms and you will find it on the
homepage and that's for the
documentation organization you will find
again everything on the home page so I'm
ready for more question so the question
is did Microsoft lemon so the question
is what what kind of black magic will do
stuff did we need to to compile on
Visual Studio that's all right
you know actually the expression Judah
is not that was a big deal we had a
fight against because we don't use much
no we don't use it at all we tried at
some point but we found that it's not
that useful for what oh no way we use it
at some point
and I'm saying I'm stupid stuff used for
said say I said you spin i but it's the
small corner of expressions you know is
that research to do is a pee-wee's so
that was quite lucky now so the main
issue with last year was sometimes she
doesn't know why you you're writing your
temper Italia series because you want
you need them and at some point you end
up with having something like using type
equal and he has one of our esq of
something something something of a yes
tree and the compiler get confused for
whatever reasons and then if you do okay
using result one is alias one of this
and result 2 is alias to of result one
and so on so you just you know piecewise
enumeration steps then
- and sometimes for completely different
areas of different complexity you don't
really know why so whenever we eat that
we just slice the mmm the computation I
think you should disable something yeah
I think I should out yeah whatever the
trick is we need to compose some of the
computation of times because just you'll
get cranky some points but it was many
SATs I don't think we had any other big
problem we crashed every comparator yes
yeah sure that's part of my job
description anyway but I see the most
frequent it's because of the tokenizer
which is like ring buffer of three
elements I think do they know no most of
the time when you get a crash in visual
studio you create an intermediate type
and then you get around the crash so you
just have sometimes if you look at the
source code of I go you're going to say
why do they have an intermediate type
then you have the explanation and we
have actually very very few if that's
for the compilers so just just for going
back on this unit stuff so that's part
of the set implementation so what set is
is you have a set of types that must be
unique so what we do is we take every
types put it into a box and we inner it
for every box of every type in the set
list of types and the box contains a
small interface smart advice for
answering question like contains gate
key and whatever which is just okay for
given types T and K U contains K or if
only if you are actually about to if you
are interacting from the next set of
everything if you does not inherit from
that that means not contained in the set
and same for I ski and same for erase
that just removes the type if and only
if it's found into the list of object
inheritance and this Decker type usage
it is OK for for visual studio and so
you
you ended up with yeah basically
building this type over and over again
until you you consume all the type into
the set we can also maybe show what the
fast lane technical question is yeah
what's a fastening technique so let's
say you have transform for example it's
transformed fast mean actually I think
everything is yeah okay so I think I've
transformed so you have transform of T
dot dot and you say just build up yet
fine define we mean why yeah you do the
stuff with dot dot but not that has a
cost so what we say that if it's empty
you return the empty list if you have
one single type you apply the meter
function to the single type once you
have two times you do it twice and so on
up to let's say sixteen and when you
have more than sixteen types what you do
is you compute the sixteen first with
the fast and one and you pass the rest
to the transform which means that
basically if you have n times in your
type list you only need at most n
divided by sixteen templates
instantiation because more than sixteen
I was bored actually copy pasting the
code so I said yes it seems enough or
maybe even eight is enough or something
yeah which one is that
it's transform there's been some other
has his name oh yeah what name is okay
there there is some other black magic
but the goal is satisfied we transform I
transferred yes
and is one root of this actually so the
first version of Vega we had very simple
enrolling and technically yeah someplace
I don't even recognize the code anyway
but yeah Odin has been walking with us
for quite a long time now
it's quite a very interesting
contributors to have around so yeah yeah
Odin's technique is basically what we
let's say audience technique has been
probably polished on friggin before he
make his blog post or whatever but yeah
it's better than what he's doing I think
at at artisan role also with the freaky
stuff yes actually it's the map which
most us to do this when we had a
discussion because basically polygon was
designed on the phone we had a
conversation and we were like okay so we
have the list it's easy now then we
reach the map that you really want to
have logarithmic complexity for the
lookup of the map and we wanted to run
on visual studio which alighted all the
advanced techniques we could use of
clang so I don't remember who said but
then probably me actually I think it's
me but I wanted to be polite
it's you just the different people to
disagree I'm not sure about that yes
even even when I'm alone I think I can i
disagree with myself I think it's the
sequences freaking GT yes yes it's
actually the basic is to say and you
have a specific technique it's a ski
awesome yes that key it's going to be in
metal
so yes so for the map you really want to
have the lookup to be very fast and some
of this is some intermediate type is
because of and so the idea is here I
don't know anymore because T I said you
seen a ski ask you where yes sorry okay
if not they're always somewhere that we
tend to say something interesting in our
head so yes I think it's Jonathan will
came up with a different idea from fast
lane but if you go back in the history
you will see that you can use this
technique any other question no question
so we wait for as well to find the code
yeah okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>