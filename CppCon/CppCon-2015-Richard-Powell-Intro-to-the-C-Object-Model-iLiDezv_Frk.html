<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Richard Powell “Intro to the C++ Object Model&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Richard Powell “Intro to the C++ Object Model&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Richard Powell “Intro to the C++ Object Model&quot;</b></h2><h5 class="post__date">2015-12-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iLiDezv_Frk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello my name is Richard Powell I am an
audio software engineer I have an intro
this is intended to be an introduction
to the C++ object model there's been a
lot of great talks here about very high
level contract concepts this is a very
down-to-earth back to the fundamentals
talk so I will intro to my intro why
this talk so I work with a lot of people
who are coming to C++ we're coming back
to C++ who are learning the language
again maybe they are work at a high
level on perhaps application code or
they're at a low level and driver code
so I put together this talk to help
people who are you know sort of not
quite thinking about the program
structure of their programs to help them
with nutri on that also this is intended
to be more of an interactive talk what
happens is if you've ever seen any my
talks at other things all tend to have a
little bit of quizzes questions for you
so if you this inquires you to think
answer questions I'll probably look for
hand-raising
not calling out individual people there
are some faces I know also all the code
here in this production is is example
code you know just as don't copy and
paste code from slides
generally I'm trying to illustrate
points so I have I have intentionally
not initialized all my variables so
we're hopefully you'll understand that
so we don't get stuck in the details on
those sort of things a little thing is I
will also be introduced what I call pro
tips these are little things that may
help you in your day-to-day work and I
find that people aren't very are very
reluctant to building code and testing
code when I'm working my office someone
will come by and say hey how does this
new thing work and I'll say I I don't
know let's build the code I reach for
make you probably have their favorite
tools I'm an old school programmer so I
will use make and make is really easy if
you have GCC or clanging tools built in
the implicit rules of make make it very
easy
to build code examples write your code
up and here's an example I've written an
intro hello world just make intro the
implicit rules will infer that you're
trying to create an executable from the
cpp files and invoke the compiler also
try to use the latest compiler
celebrated like it's 2014 the cxx flags
are environment variables that will get
ingested by the make to pass to the
compiler so it's really easy to modify
and hand options so I'm going to start
with a question of object-oriented
programming so I know there's many
paradigms when it comes to programming
in C++ you can use template programming
there's functional programming there's
great ways of doing those things but I'm
going to talk about object-oriented
programming for today I think
object-oriented lll is a very powerful
way of programming it's still something
that you should know how to do and be
familiar with so what is object-oriented
programming if I was to ask you what is
object-oriented you say programming that
is meant to model real-world objects
anything else any other things that come
to mind I know it's 4:45 on a Wednesday
maybe perhaps well I'll move on to
object-oriented programming from
wikipedia is a programming paradigm that
represents the concept of objects that
have data fields and associate procedure
known as methods another search on the
web will reveal something that says you
know object rating is data structures
that become objects that include both
data and functions and as our colleague
said here is they model real world
objects some other things that people
think of when they think of
object-oriented programming is
polymorphism virtual function
objects interacting with objects and
that sort of AI that sort of items what
do we mean when we say the C++ object
model so if you want to find out what
that C++ object model is take a look in
the standard and what it says is what in
the intro in the standard says an object
is a region of storage so it basically
is a region of storage is what the
official standard says in C++ object is
but that's sort of nebulous let's if you
wanted to if you were to design a system
that had inheritance and runtime
determine functionality so polymorphism
if you were the designers what would you
design for your language and I want to
put a couple of constraints on that so
if they'd have to be compatible with C
because that's one of the fundamentals
of C++ C compatibility and also a
philosophy of zero overhead cost so you
shouldn't have to pay for what you don't
use so those two constraints in mind
that is what C++ uses for its objects is
represented in the data so let's walk
through what that means so I'm going to
start off and going back to C back to a
beginning language and here is a simple
program I wrote up and these are this is
a struct this that contains two fields
in it and if I were to print out this
program if I was to run this program
what would I have this structure size B
what would this object take in memory
and so if the size of a float is four
what do we expect the size of structured
b8b
C say it loudly and proud B right make
sense I have two floats in memory
sitting next to each other in structure
and if we were to ask for their
addresses what would be the address if
this is the address of the object itself
where with these
addresses sit with the address of real
and where with the address of imaginary
be a right you can think of it as here's
a model my stack and what happens is I
always think of my stack moving upwards
the objects would be in the address
space aligned at a particular address
and the values just merely about each
other moving upwards on the stack
straight forward and so that was I built
that with C I built it with my students
if I moved to a C++ programming compiler
what would I get
same thing great and then also what
would I get here well before I move on
to that just a little thing that I was a
little subtle and as a tip for people
who are coming to the language I
actually going to change instead of
using standard C out I am now using a
using directive and the using
interactive will just import symbols
from that particular it controls
importing of symbols into the current
namespace you can use using namespace
standard but I would recommend good
programmers only import what you need
don't pollute your namespace you know I
guess that's up to debate if you just
want to pull everything in I find it
better just to pull in specifically what
you need I find it helps me determine
when I have symbols colliding but as a
rule never blindly use using in a header
file that can cause wailing and gnashing
of teeth so going back to where I was uh
sorry for the aside but um if this is my
struct in memory and I put on the stack
and these are my addresses where do I
expect my addresses to be a great this
is an example of a pod and C++ has a
rule that member variables declared
later in a struct must be at a higher
address when or a structure a plane data
structure and this
is actually referred to as a pod plain
old data these are the types of objects
that are compatible with the C
programming language and if you ever get
stuck wondering if the particular object
you're dealing with is a pod there's a
very simple type traits that allow you
to do it you can simply ask the compiler
is this a pod
so typed rapes are a way of determining
that type and is it conforming to some
definition and is pod will tell you if
it is uh plain old data so C++ uses
class I have change our program instead
of a struct I now have a class what
would this program print B same thing
I'm gonna get through these slides
quickly in C++ the only difference
between a structure and a class is the
default accessor values so you can think
of it as a struct is implicit implicitly
public and a class is in strict a it's
default to private members and one of
the things is you can think of a object
when is it disk laird as a class you are
exposing its interface through its
methods in general so the default is
that you would want to encapsulate and
hide its data members for a struct the
interface for a struct is its data
members so there's it's an implicit open
public availability of its member
variables so now if we imply some
inheritance so what I'm going to do is I
have my struct object and I have a
derived object which inherits from
struct or ufff sorry I have my struct
complex object and my derived object
that inherits from complex
what would this program print okay
and what would if I were to take the
addresses of this object what would
these addresses be hey
so inheritance works by extending the
objects when you have an object that has
a class you can think of it as derived
has a hidden data member as its first
member which is the object it inherits
from and if you were to look at the
compiler like if we looked at our stack
view and I enter into my stack on that
first value D the compiler reserved
space for that object on the stack for a
derived object and it will put the
complex object first followed by the
additional data members of the derived
object and when a you looked at the
object through an alias through a
reference if I took a reference see a
complex C to D you can think of it
that's the compilers view of the stack
as if that variable was a complex so it
only sees the bottom part of the struct
now you say the the original quote I
read was a combination of data and
methods so let's add some member
functions let's add some methods to our
object what is the size of my object
nothing's changed so let's walk through
conceptually what the compiler is doing
this isn't exactly what the compiler
does when it puts together an object and
compiles it but it's very it's a good
mental model so what first happens so we
start off with our here's the definition
of my member function and here is a
possible usage of my member function so
what happens first is the compiler will
introduce a hidden first data member
function of the this pointer this is
inserted by the compiler during the
compilation and then what happens next
is those cv qualifiers on the end of the
function are moved into place two
reference that this is a data member a
const object and then at the function
invocation the object is moved to be the
first argument so what happens is the
command line moves that to be your first
member argument all data members are
prefixed to you all inside the function
all data member references are prefixed
with this object including any function
calls that it would make to its own
member functions and then what happens
is the compiler transforms that member
name into a named mangled free member
function and at the same thing happens
at the column vacation is that it'll
translate that into a named mangled
version of the free function so if you
start it off here you would end up there
so that's what the compiler is going
through and telling you and if you ever
get stuck for whatever reason looking at
a aab jaao and you end up looking and
seeing all these unusual symbol names
that you never wrote down but they look
kind of similar to you functions you
wrote you can invoke a tool called C++
filt it comes with most tool chains
that'll actually D mangle your name to
give you a back your original complex
function so in that regard you can think
of it as a struct my complex truck that
has a member function inside of it
actually really is just an object that
has two native members and a free
function that's associated with it and
that's something to keep in mind with
that zero overhead cost the philosophy
of C++ when most people who are coming
the language see that there's a function
inside they think oh there must be a
pointer to that function but then if we
think about that that really wouldn't
make a lot of sense if I had a million
complex objects that means I would have
to have a pointer all pointing to the
same odd function and that would be a
waste of space why not store that
function separately and have the
compiler resolve where to call it so
that makes sense
what
all a little bit of a wrinkle when it
comes to member functions let's do a
little bit of polymorphism and this is
gets a little bit more interesting so
here I have my two mathematicians I've
chosen air dish and Fermat and air dish
is a when you call it's a member
function Who am I it'll say I am air
dish and when you say who are you really
it's a no I really am air dish and the
same thing for Fermat and then what I'm
going to do is I'm going to construct an
air dish object on the stack ask it who
it is and who is it really and then a
Fermat object on the stack and ask it
who it is and who is it really what
would this program print I've given you
a hint at the beginning I've printed out
the first object when we expect the
second object to print format Erdos
which one's c c a b c d c it prints out
Fermat and I really am Fermat how about
this so what I've done here is I have a
Fermat object on the stack and I am
going to take an air dish reference to
it and then I'm going to print out Who
am I and Who am I really
B hmm that's odd before when it was an
artist object it did air - an air dish
now prints from it so what happens here
is this is the difference between
virtual functions and non virtual
functions non virtual functions bind
statically the function resolution
happens at compile time you can think of
it as when the compiler is going through
and looking at the type of that object
and it's making a determination of the
function to call when it sees that
function
when it sees the function marked as
non-virtual it must call that function
based on the type virtual functions bind
dynamically this is how we get runtime
polymorphism the function resolution
occurs when the object itself is created
when the object is constructed through
whatever means you construct the object
if you construct it on the stack or if
you constructed it in the free space so
let's go back to that example here so
what happens is fermat and air dish
object the calls - Who am I that is a
non-virtual call and so what happens is
the compiler will generate a will bind
that resolve that call statically as we
saw what happened was it created it
modified the Who am I to put it as the F
object as a this input argument and
named mangled version and it was a
static call and it is based on the type
that that variable is so the air dish
reference is a reference to a ferment
object yes but it is still as far as the
compiler is concerned he is an air dish
object it is air dish type so it must
resolve that type call the non virtual
call statically and it will call the I
am air dish but the virtual calls are
determined when the object was created
and when was the original object created
the object was created on the stack by
that firm at Def Declaration on the
stack so that object is in fact ferment
and so when you call into the Who am I
and Who am I or Who am I really of the F
a pointer it the F object it would
resolve to what the object was when it
was created which would be I am firm at
and the same thing on the air dish it
says well well what was the function
when it was created what would be the
resolution of B I M format so that's how
we get me
and so that was with objects that were
created on the stack if I create them on
the heap well just as an aside I wrote
this but you should never ever write
that ever again so instead
use unique pointer use make unique these
are objects that are smart pointers make
unique is a convenience function to make
unique pointers it's in C++ 14 if you
don't have access to it you can still
use new inside of the unique pointer
constructor but I would highly encourage
you to get yourself used to writing make
unique these manage reach raw resources
for you and you should never write new
in your code in fact actually I would
say that if you're doing a code review
and you see new and delete in the code
that's almost reasons to fail the code
review you should just that should be a
reason not to accept the code review
unless you're down in the sticky weeds
of library library land and even still
in there I think that it's hard to
justify using raw knew now placement new
on the other hand probably makes sense
but but don't be dumb don't use dumb
pointers so going back to what I said
I've cleaned up my slides okay great
cool now that's all nice
what would this program print so I have
a air dish make unique air dish object
and then I call Who am I and then I have
a make unique fermat object and then I
call Who am I Who am I really be why
wouldn't that call
I am Fermat and I really am ferment I
mean I've made unique as a Fermat object
what was that I think
over here Who am I is not virtual and e2
is what's the type of e2 it is a unique
pointer to air dish so it is actually as
the compiler sees it it is an air dish
object it must resolve that object and
I'm calling a non-virtual function it
has to resolve it statically and there
we go and just for kicks going back to
kind of my original thing this is a what
would this program print see full circle
all right interesting now I've added
virtuals to my complex and my derived
object my heritance and I've added a
couple of things now I'll print out the
size of float and I'll print out the
size of a void pointer for assisting
people who are looking at this what will
we expect this program to print anybody
be here B I have a hard of hearing' up
here
it's very far away B this program prints
B Wow that's considerably different than
what it printed before if we took the
addresses what would we expect these
addresses to be the a yet actually I
think C although I think that this your
mileage may vary it depends on your
compiler for some reasons but in general
my compiler printed this let's walk
through what the compiler does with
virtual functions and how does it say
virtual functions bind when the object
is created how does the compiler
accomplish this feat let's take a look
at what happens so I start off over here
I have my complex object
it has some virtual functions and
there's my definition of my absolute
function and here's a possible way of me
invoking it on the stack I'll start off
with my original object I'll take a
reference to it and then I'll call it so
so what happens is a member functions
are generated as normal just like we saw
before previously a three functions are
created then what happens is the
compiler gathers up what's called
gathers up a table of pointers to those
member functions that were marked as
virtual so it creates a V table and then
what it'll do is it inserts inside of
your struct a pointer to a V table so
you will have a data member that will be
a pointer on the invocation side what
happens is it inserts an indirect
virtual table lookup then what happened
the compilers next job is determined if
you wanted to call abs where in this
table does it exist
so it'll determine oh well that's the
Nakhla 0 with entry that was the
destructor so it would be the first one
and then of course we have to add a call
to this on it so it'll be inserted as
the first data member function great and
if we want to take a look at like maybe
a visual way of this is represented in
your program we start off here and first
of all the compiler generates the in the
text field of your object file it'll
produce the member functions and then
what happens is that table is created
and that's usually placed in the Const
region of your program they're just
pointers to those object files and then
on your stack as I go on the stack and
create an object I would have a V table
pointer to my objects although like I
said your mileage may vary non static
data members and blah blah blah where
does it say about the last
implementation requirements might cause
to addition members not to be allocated
neatly after each other so requirements
for spacing of managing virtual
functions and managing base classes blah
blah blah
basically the layout of non pods is
implementation defined in earlier
versions of C++ the V table is actually
placed after the member functions so
it's was a little bit odd you instead of
having the V table first the V tables
were actually at the end of the table
which was a little bit of odd I think
though in general most compilers aren't
putting the V table as the first member
in your object and this is something
important to keep in mind if you ever
debugging your code or looking at your
code if you look at your in the debugger
and you look at the object and there's
something weird at the beginning of your
struck that's probably the V table so
and if you're looking for more
information about that you can always
look into the standard and see what a
standard tells you about this so let's
do that again instead of having my
complex object I'll have a complex and a
derived object and so what happens is
both the the
complex and drive objects free functions
are generated you'll generate the V
tables for these particular versions and
then when I have my complex object it
would be pointing to the V table for the
derived object when it was created
that's where points and what happens if
it and that's what happens when I change
it to be a derived object it would point
to a different V table well what's the
code that sets that pointer what
actually caused that pointer to point to
the particular thing a constructor so
virtual functions work by having
pointers to functions initialize to
their desired functions of at runtime
but the code that does that work is your
constructor and so for example here's a
I'll write out a complex with the I'll
give it a constructor and I've here's a
it's empty I didn't put anything in my
constructor for my complex
I didn't initialize my variables yes I
know I'm very bad I should have done
something but I'm just going to do this
for illustration purposes so what
happens is first the V table is inserted
by the compiler
then what happens is the compiler will
insert code for initializing that this
is what happened this is what your
constructor is doing and this is where
when people come into the language and
you'll say that you have your
constructors automatically generated for
you your copy constructors are
automatically generated for you there is
a reason the compact the compiler is not
doing this just to to mess with you it
is doing it for an intended reason the
copy constructor needs to make sure that
the object is constructing actually has
the right pointers the right pointer to
the vtable
the pointer to the right vtable same
thing happens a similar thing happens
with the derived object so here's my
derived object inherit from public so
first of all it well actually it doesn't
insert a vtable pointer actually there's
no reason for the struct a drive struct
to have a vtable remember you can think
of the derive struct is having a hidden
complex datum member as its first object
well the complex data the complex truck
has a V table so it's really just going
to use the same V table and then what
happens is first of all the derived
object will call down to its complex
object and have its base class get
constructed and after the base class is
being constructed it comes back and
returns and then the derived object now
finishes its construction and sets the V
table so this would probably look
something like this is first of all
derived gets called then it calls
complex it sets the V table it returns
and that sets the V table which leaves
an interesting question um let's say I
did something where I'm like I want to
check to see my air dish object I said
that its functionality is determined
time I want to do some logging and see
how this object was created I have an
air dish object I'll put on the stack
and affirm an object I put in a stack
and in the air dish constructor when
it's constructed I want to call Who am I
really
look so what do we expect this program
to print
be a e how many people for a how many
people for B it prints a pretty sure to
print a chick wait okay okay so what
happens is let's walk through what
happened here on this second one so when
it calls to firm at the firm a
constructor was called and let's expand
that constructor first of all well the
first thing that that Fermat constructor
would do is we call down to the air dish
constructor and then after the air dish
constructor is finished it would set the
bv table okay but what happens is when
it goes down into the air dish object it
sets the V table and then calls Who am I
really when you are in a base class
constructor effectively you are of that
type of that base class you switch your
type sort of as you think of it as
you're moving up the call tree for the
Constructors at each point you are that
particular type well that's not
necessarily true it's a byproduct of how
the V table is implemented at that point
the V table has been set to be the V
table for that particular object so when
you call a virtual function you will end
up calling the virtual function of the
type of that constructor of the type in
that constructor or so in this example
when I'm in the air dish constructor
even though I'm calling a virtual
function it will resolve to be the air
dish version of the function which leads
to Scott Myers effective C++ item I'm
going to guess 23 maybe never call
virtual functions in a constructor you
don't get the behavior you would expect
so right so to review here c++ object
model is a way that objects exist in
memory runtime polymorpha is
accomplished with v tables and be aware
that can dramatically increase the size
of your objects also it can affect
debugging and optimizations and do not
call virtual functions in a constructor
i have references and a lot of time for
questions sir if you don't override one
of your virtuals how does the compiler
build up that v table so right if your
and here you're overriding every virtual
so it's a straight replacement of
Fermat's all of its functions replace
air dish mm-hmm but what if you had an
extra virtual and air dish that's not
overridden in format how does it know to
grab where does it where does it build
up that B table so a couple of things
about the way virtual works virtual is
actually very interesting in that if
you've marked a member function as
virtual in a base class and you have the
exact same function signature in a
subclass the compiler implicitly treats
that function as virtual if you didn't
put the virtual keyword on it it
actually acts as if the virtual keyword
was there so it's this little so if I
had actually not put virtual in the Who
am I really infirm at it would
effectively be there unless the
signature was different if it had a
different number of arguments that would
actually be treated as a completely
different function
which also goes to another thing which
is make sure your arguments match which
can be enforced with a C++ 11 keyword
override so if you are doing anything
here actually I'm probably going to be
someone's going to yell at me I didn't
use override in here I should have used
override to signal to the compiler that
I am in fact overriding that function so
but your other question is let's say
that air dish actually had three virtual
member functions and you can think of it
as as the compiler is going through and
finding those virtual functions it will
insert those in
to the virtual vtable for you and say
that these are the pointers to these and
then what happens is when I've
constructed Fermat let's say I didn't
define any virtual functions what
happens is the compiler will first of
all take and construct a V table with
that original one from its base class
it'll just be those just be essentially
the same V table maybe even the compiler
we go I don't need to make an additional
copy I'll just keep this one to have a
point to this one if you replaced any of
them it would just now construct it
would just replace pointers for that
individual function so you don't have to
overwrite all your virtual functions you
can be selective you can override one
additionally you can add a new virtual
function that didn't exist in your base
class if you did that your derived
object the ferment object in here would
actually have a V table pointing to four
functions and that can actually give you
a lot of fun behavior if you are
statically casting certain objects that
don't intend to be there when it did a
function resolution and you said I want
you to call this fourth virtual function
and it goes to but the object actually
was a base class object you end off at
you end up calling into a function that
is off the end of that V table you get
undefined behavior you're good now
that's fun to debug where you suddenly
end up why did this crash and I don't
know what's going on here but that would
effectively be as if that pointer oh I'm
not going to go backwards through these
slides but it would be as if effectively
when it was trying to do that table
generation it went back to an index that
was non-existent so in this example here
it went to the V table entry one it did
five because you pulled it I want you to
of the fifth one oh no it's going too
fast yeah we're going back in time
slowly okay any other questions Josh
so I don't have a question I just wanted
to accentuate the importance of putting
override right or writing override
especially if you're using library code
because of the function signature
changes in the library and you don't you
didn't write override then you might
have just created a brand-new virtual
function and not even know it which
would be very difficult to debug very
important to fight over right yeah yeah
thank you for not stopping me right in
the middle yes
can you talk a little bit about how
vtable construction would work if the
one of these classes use multiple
inheritance
oh yeah multiple inheritance gets pretty
tricky and I didn't want to get into
that um I think I'm actually not
familiar enough with how multiple
inheritance works in a modern way I know
I'll just say I can't speak too with
confidence though so next year's talk
what happens if the base class has no
virtual function then what happens is
all of that stuff I said about vtable
generations happens in the subclass the
base class would be depending on how its
laid out could be plain old data that's
just a data member there and when it
goes to getting constructed it has no V
table to set and that V table actually
would come after that class layout I
believe who actually that's an
interesting question I'll have to look
that one up
static casting down to a so if you
static cast it to be your base class
oh you dynamic cos you dynamic class
downwards and static last upwards yeah
so um that's an interesting question
what would happen is it would treat it
like it's that base class so it would
view that so it wouldn't have that
object there yep
Ansel you can't dynamic class but if you
static cast you can static cast yourself
to be your base class it's just dynamic
casting the other way is not possible
because the lack of a V table there was
also one thing I didn't have a chance to
mention which was about pods and non pod
data is something interesting that is if
you have a mixture of access or
directives sort of if you have private
public private declaring your structure
layout I intentionally did not write
that into the code here if you start
mixing up your access or methods you no
longer have a plain old data the
compiler is free to take disjoining sets
of data members of the same access type
and move them closer together and then
that way you no longer have a plain old
data object so that can actually be a
little bit surprising if you're dealing
with code as it grows over time somebody
adds oh I want a private data member oh
I want a public data member suddenly you
no longer have a pod and that might be
surprising for some people are there any
other things that make a data class so a
struct or a data class as being a non
pod data that would be if you have a oh
boy you have a constructor can do that
if you have a I think if you have a
non-trivial constructor that would
then if you have any initialized data
member so if you said int a equals zero
I believe at that point it has to have a
constructor and therefore it's no longer
a plain old data object you know and
this goes to the when in doubt printed
out if you I this is what I do in my
office is I will go ahead and go is pod
and just create a bunch of examples and
just try them out really quickly to see
what I get so um I would be a fun thing
to try Jared oh yes it was 64 bits but
let me see if I can find that slide ah
right here so this is an interesting a
little example I'm surprised no one
asked about it there but this is a great
one so what I've done here is going back
this is a virtual function so now that
we know how its laid out we can see that
the complex object it's pretty obvious
that the complex object had to float
members that were moved later in a V
table was inserted and that's why I
printed out the size of the void pointer
to kinda give us a reference on the size
of it in it and you can probably see
because the size of the void pointer was
eight kind of implies that my compiler
64 bits so it would make sense that my
size of complex is actually 16 bytes
because it there though it's interesting
for derived I only add a single float on
top of it I didn't I don't need to add a
V table because the V table already
exists in my struct complex and so
that's interesting why is there an extra
four bytes what is in that four bytes
well maybe Chad over here could get an
answer I have a V pointer my V pointer
exists in my complex base class
at alignment alignment if I need to have
these objects being a struct where my V
table still has valid alignment then
what happens is the compiler will add
padding to make sure that they are
aligned so if I create an array of
complex they still need to be callable
and that means that that that requires
that that V table be on an eight byte
boundary so that's where you're struck
actually grows so it is something
interesting to lay out and keep in mind
before my complex object really only was
four bytes wide and then I added another
right now it's 12 when I add a virtual
function just a virtual destructor I've
increased the size of my object which
actually goes to one interesting point
which is there's one school of thought
that says make all of your member
functions virtual just because it's
easier to remember that way but virtual
has a big cost if I had an array of
derived data members say a million of
them I just added a really massive
amount a memory I've added eight Meg's
of memory which may not be useful if I'm
not doing anything polymorphic which is
if actually and if I have this virtual
destructor in here this destructor
really isn't doing anything here there's
no resources to clean up
I mean I've set it as default but it
isn't actually doing anything so it
seems seems that perhaps if you're
reaching for virtual that may not always
be the best thing you may want to move
away from inheritance and polymorphism -
maybe some other paradigm for doing your
design oh the Mike question in the back
not the question or March let's first
come back to what the guy at the back
said about inheriting from objects which
is a p OD with a V table that's quite
dangerous if you do in you or made
unique and you assign it to its base
class
and then do delete then it does not find
the virtual function for cleaning it up
correctly so I would suggest to always
put final at structures which do not
have an virtual destructor
okay that's a very good vise
after adding final to your code when you
have an object that doesn't have a that
did that have non virtual destructors
what about plain old data they don't
have destructors
so all pods should be all pods should be
final I don't know any other cancel the
opposing side of that is that with boost
shared pointer and I believe STD shared
pointer in that case the deleter is
bound at the time the object is created
so the destructor doesn't have to be
virtual in order to get the right
behavior mmm so be aware of the various
places where it is it is not valid all
right excellent advice I'm going to look
that up
I wonder that's an interesting thought
so it's 5:30 it's been a long day and I
will suggest that we end the
presentation there thank you all for
coming and I look forward to other
questions you have
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>