<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Andre Bergner &quot;Indian C++: Curry for your Functions&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Andre Bergner &quot;Indian C++: Curry for your Functions&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Andre Bergner &quot;Indian C++: Curry for your Functions&quot;</b></h2><h5 class="post__date">2015-10-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zVLLdGlbCSw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay the topic is here Indian C++ curry
for your functions so what do I mean by
curry so it's actually not again so it's
not it is somehow spicy C++ maybe but
not curry as you see in the background
it's like really it's named after this
guy SK Brooks curry so he's quite
impressive so here's like three names so
I mean as many Americans have three
names he's an American mathematician and
logician and he has actually three
programming languages named after him
most famous one is Hesketh and there's
also another one curry and even Brooks
is a there's a program in English and he
worked in the field of community logic
and lambda calculus and in that field he
invented a technique where he extended
actually a technique called currying so
he even made it up to the level where he
he is not just a thing is named after
his name like with a noun even got the
verb so really currying so this is like
really impressive so not many people are
able to do that it's a name maybe Taylor
did it so what is currying so I'm
currently functional program is pretty
hot so a lot of people are jumping on it
so everybody is excited about everybody
but a lot of people are excited about it
some simply because I love esoteric
stuff others simply because they know
it's important for the future when
everything gets paralyzed you need you
need a functional paradigm in order to
get to get control over your logic so
because you lose it in the imperative
paradigm so what is Korean so occurring
is an essential part of yeah all
functional programming languages and it
basically looks like this so here's an
example from Hesco so the explanation is
basically this currying splits a
function of n arguments so usually so
you have a function of let's say F X Y Z
into n functions of each one argument so
it kind of does some magic with the
functions and it does it by a technique
called partial function evaluation so
Haskell has that built in or all
functional programming languages have
that built in into there
into the language so for instance in
this Haskell example I define a
functions or a translate that for you
I define a function Plus that takes two
arguments apparently takes two arguments
X and Y and I say this function the
evaluation of that function is simply it
just adds South to argument so that what
it says but then I can create a function
plus three X so this is no function the
name of the function is plus three and
it takes one argument X and it sorry
that there's a typo that should be plus
renamed that in between so it should be
plus x3 so this function calls the other
function and and puts one one where
you're already in it so there this is a
this is one step where the partial
evaluation happens already and so you
can define one function by calling half
of another function basically and then I
use it so map that's like the Haskell
counterpart for transform in C++ so I
say map this function plus three onto an
area of integers and this will print out
four five six obviously and but I can
also just put any front a partial
function directly at the place so this
would be an anonymous partial function
so if I say map plus three so now I take
the plus from the first line and just
put one argument in it I mean the
function would take two arguments I just
put one in so basically the result of
plus 3 is a anonymous function which
takes one argument and has the three
bound already and then this function
gets applied to each argument in the
early list so that's our you work in
Haskell and this is basically the the
fundamentals of all functional
programming because you have a lot of
higher-order functions that means
functions that take are that functions
that take functions as arguments and
functions that return functions so I
mean this is already each function
inherently has the capability to return
it safe partially bound as a new
function and so this is the core of the
idea and so now it would be I think
everybody has come to that point at
least useless there are algorithms and
they
it actually would be a would have to be
nice if you have the same feature in C++
so let me give you an example so I'm I
already shortened that a little bit by
using some kind of range syntax as its
proper as he evident booze or the
proposed for the standard I just put it
into an artificial range namespace so
make it clear so I have now a I saying
if I want to do the same thing in C++
with the current the way of doing it I
would need to call I could use alumna of
course but she I didn't use it in the 98
stars then I say I bind to a source
state pint of state plus which comes
from the standards from actually the
head of functional and I bind the
argument 3 to plus 2 state plus so I
mean this is all I mean the earlier of a
lot of boilerplate if you compare that
with Haskell
so you have to specify the type of plus
of course ok the namespace you get
ripped off but then you have to call
that bind and then you can actually
apply it I mean at least I could put it
into this argument for the transform but
this is pretty awkward so what I would
like to have is that so I would just do
the same as I can do and had a scherzo I
mean this would be the wishful thinking
and C++ way so I say if a transform of a
range so in that case it's an
initializer list and then I call my
function plus in that case and plus
inherently has the capability of
returning if it's applied just with one
argument it returns a new function they
take the other argument which is now
expected by the transform algorithm so
when I set down and then thought a
little bit about it and found a way to
actually implement it in C++ so I mean
it could be in language feature but you
can still write a library code that does
that so here's some client code that
demonstrates how to how does it work so
this basically my unit tests in my
little example which I have online so I
writes up is my my curried function so I
have a function career and this curry
function takes a function and returns a
new function that is inherently variable
so a function that has
capability so in that case I take the
C++ 14 numbness so I say curry of my
lambda are taking two arguments in that
case it's a subtract subtraction
X minus y and the other example is M XOR
multiply accumulate so the common
operation in like all kind of linear
transform so that takes point since
three arguments and which is defined as
X plus y times Z and then down there you
see a lot of examples how you can use it
so I came to find a new partial function
so sup from eight would be simply sub
eight so this is now a new function that
subtracts the argument from eight I can
use that I can just call sup with two
times an argument because that's obvious
so because it's the first argument call
returns a function and then I can't call
again a function argument evaluation on
that one or I just can call it a
standard way by just putting in two
arguments and each time it will always
return the correct result five in that
case same for the other one so that one
takes three arguments you I was also
playing a little bit with and in theory
I could forbid that but you can also
import the function with no arguments
which should be recalls and returns a
function is safe again
so the last example you see like I
called with no argument and this one
there's no argument and so on so this or
Burks and now I'll show you the
implementation so unfortunately color
highlighting doesn't work highlights is
doesn't use doesn't like deca type so
but this is all the code and now I go
through it step by step so now it let's
show one first step M first just the
first example is a this function I was
calling curry is a function that takes a
function so the function which I want to
curry and potentially some arguments you
you understand a moment why I need that
and it returns a currying binder which
is a struct I show you in a minute it
does magic it just stores the function
and those arguments in that binder so
how does it look like so this is the
first part of the destruct so you see
the public interface to it and
private members so the private members
is where a function that should be
stored and a couple of all the arguments
that should be bound into into that
binder and then the public interface
where it's a constructor so you can
that's this thing it simply stores this
stuff
and then it has a call operator that
takes a list of other arguments so they
are the bound arguments arguments so two
two bound arguments are the one that are
stored internally and others which are
the one I always can call the thingis
and internally it does so this is now
the internal cord so this is where the
magic happens so it calls so I don't
know who has ever used to make index
sequence you and okay so this is a thing
that came with C++ 14 and that's the
thing you need whenever you have
arguments in a tuple and you want to
apply all those arguments that are
stored in a tuple into a function so
then the problem is you can't just do
the the tester that the type expansion
on on a topic you have to magically
force the compiler with that little
trick to get to get the argument out of
the tablet and put it into a function so
make index sequence size of bound arcs
simply creates a empty template type
that has a non type list of integers
just going from 0 to n minus 1 so it's
just index into some some some topic in
that case so it's just a helper struct
that meter programming hyper structure
came with C++ 14 in the STA and then the
second part is obvious I just forward
other arguments into that core function
so now how does that one look like so
story here the color highlighting is
broken so it's a little bit messy okay
down here you see the that's a function
I call so this function gets now okay
three means this function gets the index
equals index sequence of what the
integers are a list of integers
the other arguments and so this is not
how you get how you get the index into
the top layer because you let the
compiler deduce the the integer numbers
from the individualist and that's just 0
up to n minus 1 where n minus 1 or n is
a number of the bound arguments so the
basically the size of the topic and so
it it calls get with the expansion of
the ends and then it called simply
forward with the expansion of the other
arguments so there are two lists of so
the one that's actually arguments and
the other is an index into the store
topple so two lists two and Vario em
variadic templates gets extended here
and now there's the second magic
happenings we just try to invoke
functions so I'm using shoes who has
used expressions fine a or who knows
what expressions fine is what so just if
you want so so expressions finite is a
technique so spiny in general n states
that if the compiler and it's a compiler
tries to find so you have a template
function that the compiler tries to
deduce the arguments of the other type
of their template from the given
arguments of that function there's a
rule that if it fails for whatever
reason it it just drops that function
and tries to find another function with
the same name that also might fit for
the arguments so but there as always it
tries first try it's a perfect fit and
then it tries to next best fit and if it
doesn't find any functions and then it
actually creates a compiler error so
what this technique is always used for
creating this kind of reflection
mechanisms which is missing in C++ so
the same thing is happening here so I
have two structs one is the basically is
a more general one curry which is called
curry arguments and the second struct is
is a inherits from curry arguments on
which is called try to invoke functions
so and now I call my dispatch function
with specialized struct which is called
try to invoke function so that's the
first one up here this one has echo type
of the function which is thought applied
with the argument list supply to the
function so that means the compiler now
tries to deduce the type the return type
of that function if it would be called
with those arguments if it succeeded if
it succeeds it simply evaluates a
function and returns the arguments
that's basically the end of our
occurring if it doesn't succeed it drops
this function overload and goes to the
second one so the the Curie arguments
version because curry arguments derives
from the other class so it is a it's
implicitly convertible to the other
structure and what what this one does it
simply again calls curry with the
arguments given enter function so it
creates a new version of itself with a
new argument list and and the function
again so basically forwards that into a
new bound list so I think time is almost
up and yeah and that's how it works so
thank you at you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>