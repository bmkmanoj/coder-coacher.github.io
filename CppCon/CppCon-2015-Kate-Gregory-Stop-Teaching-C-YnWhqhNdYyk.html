<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Kate Gregory “Stop Teaching C&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Kate Gregory “Stop Teaching C&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Kate Gregory “Stop Teaching C&quot;</b></h2><h5 class="post__date">2015-10-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YnWhqhNdYyk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you thank you for waking up and
and dragging yourself in on the last day
to a morning session maybe your second
session if you went to the lightning
talks but whether this is your first
year second thank you and thank you for
coming to my somewhat opinionated at
least entitle and let's be clear
obviously if you're teaching intro to
see that's that's a fine thing my
complaint is for people who are not
teaching intro to see but who
nonetheless start their five-day course
with two days of C material so this is
my suggestion for how to have a course
that is more enjoyable and makes better
C++ programmers which is probably the
whole point of teaching anybody anything
so who am I talking to when I talk about
teaching at all
yes officially trainers people who stand
at the front of room and and pontificate
for a while something I've been doing
for decades but also people who for
example just mentor other people if
someone comes to you at work and says
how do you bla and you go write them a
little 10 line thing that demonstrates
how to blah I want to talk to you about
how you write that little 10 line thing
and what you use in there and if you
have an API and you are the one who
writes the samples Windell teamed ah
maybe maybe you could actually you know
write samples that look like they were
written in this century so it's not just
sitting down and teaching somebody C++
101 it's all of the times that you
demonstrate something to somebody who is
new to whatever you're demonstrating to
them what do you wrap around it and what
do you consider the accessory that goes
with that something that you're teaching
people and one of the reasons for this
is this concept that I talked about in
last year's talk or we said one of the
great things about C++ is that it's a
language for smart people and one of the
bad things about C++ is that it's the
language for smart people why is there
this sort of like barrier to entry that
says you have to be super super smart
believe it or not a lot of it comes from
what we put people through in the first
two days of their five-day intro to C++
course and that isn't even C++ and
that's kind of where where I'm coming
from that if you change things around
just a little
it you can actually make the entire
learning process go more easily and
produce better developers out now who
here learn C first right so there's a
very strong temptation to reduce it to
the previous problem right you know how
to teach C++ to someone who knows C so
step one teach them C step two do the
thing you know how to do I'm not saying
that that that doesn't work because it
worked for a bunch of us but personally
I learned see when C++ didn't exist can
have another hand if you're in that
category yeah
so you know that's a long time ago right
and an awful lot has changed including
the percentage of people who are just
wandering around on the street knowing C
so to try to say well I know how to do
this Delta so that's the only way I can
teach it you're actually just making it
all take longer and you're teaching
people bad C++ right a C program is a
collection of functions and some of them
have names that that enable you to know
that they belong together like all the
STR functions but that's really not what
you call object-oriented design right
when you teach people see you don't
teach them Aria you don't teach them the
same kind of type safety because those
things aren't in C you can teach people
these things on day one if you don't
spend day one on some other stuff that I
don't think you should do when you do it
C first you make it look harder than it
is and you teach them things that they
have to actively work hard to learn that
on day four you will have to try to
unten and so I'm saying like kind of
revolutionarily just don't teach them
that part and then on long before day
four they are ready for you before I
build out this slide I want you to think
for a minute
what's your answers and I know will be
more than one to this question you know
other language is not to see like Ruby
Haskell Python JavaScript F sharp C
sharp blah blah blah what makes C++
specifically and uniquely C++ yeah one
candidate you have ten candidates hold
them in your head
is that a question okay now think about
what day of the course that thing gets
discussed or what chapter of the book
that thing gets discussed because this
is what we see right I mean I did intro
to C++ the first time and I picked up
the textbook the previous University
professor had used and it was chapter 32
objects and classes because they had
just took their seat book and stuck some
more chapters on the end right and it
keeps going eventually sometimes three
or four chapters after classes we might
talk about operator overloading
templates it's pretty advanced we'll
leave that const is often even further
down the line there are some seats up
front which some of this has to do with
what order things were added to the
language right so you've got a perfectly
good thirty-two chapter book and then
someone goes and adds Kant's to the
language so did I chapter 33 similarly
exceptions the standard library because
we're all terrified of it so we leave
that till the very end and then of
course once C++ 11 comes along I have to
add some more chapters at the end but
isn't this stuff that you said made C++
C++ right so why are we saving it for
the Advanced Course right or for day six
of the five-day course you're going to
teach somebody C++ I would like to teach
them these things and not the delights
of the printf format specifiers now I
actually do have a question where are
where is deterministic destruction sure
we can put rei in here that's that's
excellent let's put all right I am here
too first thing that's right good chance
what really makes would be first exactly
but but if I were to put this in here
yeah I'd probably save me about chapter
70 right C came first my answer that is
so all right
Fortran came first also but we very
rarely say now let me just explain
Fortran to you for three days and then
we can get into objects I'm not saying
that it's not possible to teach C++ to
someone who happens to know C or any
other brace bracket language
right is it good we can skip all the bit
about if and for and while and what a
boolean is because you know all that and
we can skip the day where we do ends and
ORS that's fine but doing that to people
who don't know any C++ is I believe
actively harmful so this isn't just
about you can skip this stuff you will
be a better either teacher trainer
sample writer parent if you do skip the
C and yes parent I did teach my children
C++ to teaching people C first makes C++
developers who are not as good as they
would have been if you skip that part
it makes people who didn't like the
course you know I move in a wide variety
of circles some non C++ circles I
actually talk to marketing people and
business people and if I had a dollar
for every time I heard this sentence o
c+ pasa I took that in college man so I
did not like that and there there
looking back 20 years and they're
telling me the only memory they have is
how they didn't like it that is so sad
right because here's a room a building
full of people who love C++ and enjoy it
when I stopped teaching them the sort of
day one material and day two material
that I used to teach them people started
enjoying the courses okay so show them
what makes C++ C++ make the course more
fun get through the boilerplate intro
stuff faster so you can get to the super
cool stuff and don't set up this really
false complexity the four things I
really want to rant about I have more
than this but these are the starting
point strings haven't helped these
strings printf square bracket arrays
pointer manipulation and new and delete
by hand now a couple people have grabbed
me over the week and started to try to
stick up for printf or to tell me how
they feel about a stream performance I
am NOT here to defend stream performance
I'm not even saying that you shouldn't
use these things in your own code I'm
not even saying that you shouldn't ever
teach them in your intro to C++ course
what I am saying
is that using these on day 1 of your
intro to C++ course so that people
cannot even do hello world until you
explain and draw on the board with the
little boxes and the arrows and the
knowledge the end of the string is not
right or fair ok not on day one not on
day two in order to do CARSTAR strings
you have to explain pointers you know
when I taught my 12 year old C++ his
first program asked him his name and
when he typed it it said to him hello
Kevin 12 year olds love that 8 year olds
love that how do you teach that in C++
if you're a printf scanf person what do
they have to do to get to there right
there's no earthly reason why they need
that you are into off by one land and
all you forgot to allow for the null
terminator and no no.you we always say
less than for the termination condition
in the loop 5 minutes in and you know
what they are thinking this c++ stuff is
hard i don't care for that so instead
you should use them strings everybody
can read this code great eight-year-olds
can read this code they know that plus
means putting two things together if
you've done one where you use equals
equals to compare integers they and
instantly understand that equals equals
is fourth comparing the strings and it
doesn't take long to explain plus equals
you don't have to tell them about
operator overloading you don't have to
tell them about C++ is strongly typed
behavior you can just show them some
code and they get it they probably think
string is a built-in type especially if
they know another programming language
where string is a built-in type you
don't need to disabuse them at that you
can focus on whatever you want to focus
on whether it's ifs or loops or
something the fact that there's a string
class for them is a minor miracle to
those of us who started learning in the
80s it's not a minor miracle to the
people you are teaching today it's just
how the world is and you don't actually
need the long diversion about what it
took to get us here and all of that you
can
just show them how to manipulate some
strengths I know some people love printf
but I want you to remember the first
time you ever printf to anything
somebody got out the big table right
with the percent see the percent as the
percent D the percent of the data when
you put dots when you don't somebody
wrote a program where they said percent
C but they should have said percent s or
the other way around that stuff is kind
of gross and it's not actually key to
being a good C++ developer right like I
don't think I've ever been a job
interview where someone's like no real
sense of architecture doesn't understand
objects a little bit loose and fast on
the whole casting story but totally has
all the printf specifiers memorized so
that's higher from me and we're teaching
this to people at 10:30 in the morning
on day one and if they get it wrong
their programs don't work I just think
that's not fair or nice or rice or
useful so again doesn't mean you can't
ever use it in your own applications
should you need it so then people are
like well what should we do how about
nothing I programmed with cards I did I
went to a room I handed cards to a nice
person and about a half an hour later I
got a printout my mother put cards on a
truck and she got her print out the next
day and if you live then and for your
application to have print statements in
it is super smart useful because how
else are you going to know what the
value of AI is after you incremented AI
or whether or not we went into the loop
but we don't do that anymore and they
have to learn to use the debugger anyway
right so how about in your very first
program where you're showing them the
operators and you're showing them what
if is and you're showing them how a loop
works you just have them go through it
in the debugger and look at the values
of things instead of putting the values
of things on the screen at all and now
we don't have to argue about streams
right don't use anything if that doesn't
work for you if it's really super
important for you to be able to have
them run the program and see the output
in okay use streams that's fine you can
put in a little disclaimer here about
performance
and point out to them that if they have
a large amount of information to process
that there are other things we can do
that there's more than one way to do
everything in C++ then you can just move
right on because it is day one or if you
are an in-house trainer your training
your own C++ developers who are going to
work for you building something in a
framework then why not teach them that
framework so if it's some gooey thing
why not have all your sample apps have
like a button that makes it run and a
text area that shows the output and they
put text into the text area with
whatever way it is you do that in your
framework probably by setting some
strings with that right that's another
option there's nothing important in
printf that they need to know in order
to understand how an F works or how form
works or what the plus plus operator is
or what the greater than operator is so
let's skip that bit square bracket
arrays like CARSTAR strings and like
printf they lead people into mistakes
this is like like putting a chocolate
out on the table and then leaving a
bunch of five-year-olds there and going
out and when you come back surprise some
of the five-year-olds ate the chocolate
right you're putting this opportunity to
not allocate enough allocate too much
start at one instead of zero go too far
blah blah no bounds checking undefined
behaviors on the table and then leaving
it with a bunch of beginners and there's
no actually really good reason for doing
that other than to impress upon them how
hard this language is and how careful
you have to think if you want to be one
of our try Plus once you have these even
though you could use range four with a
square bracket array have you ever seen
intro to C++ material that uses range
four with a square bracket array I never
have they roll straight into the four
loops right and what do they implement
in those four loops most of algorithm
right let's now go through the
collection and count how many entries
have the value of three right because
nobody wrote standard count yet
sometimes this material predates range
based for
sometimes this material predates
algorithm I get that but that doesn't
mean that it should or that that's right
because you wouldn't want to hire the
guy or girl who wrote their own count or
sort or accumulate so why do we start
out by teaching them that I'm not saying
that nobody should understand the
building blocks of their language go
ahead and demonstrate a few things but
to sit there and teach them how to do
all these things because that's the way
to do it invites a belief in the
difficulty level and in what day-to-day
life is like when you finish your
training course and start writing C++
code for a living that really is not
accurate
so of course vector some of you have
heard my advice about vector if you need
a collection class use vector if you're
special and performance matters to you
and vector isn't going to work for you
no problem I totally get it use vector
even if the perf argument is the legit
argument again we are talking about day
one of intro to C++ and there is no per
farg ument on day one of intro to c++
other than you should know that there
are a variety of collections available
to you in the standard library and
elsewhere and sometimes you'll choose a
different one when you are all big grown
up and know to choose what you need
beginners whether they are 8 or 28 or 58
think of collections as things they
already do I remember being so thrilled
when I moved from peel Fortran to pl one
because I could have a two-dimensional
matrix of numbers in PL one and I could
write a equals B and I got a copy which
is totally not what I would get at
Fortran I don't have to write a loop
when we teach some square bracket arrays
first there in Fortran they have to
write a loop when we teach them vector
first or other collections from from the
standard library they're in PL 1 which I
learned PL 1 in 1984 so we can consider
moving to 1984 s what I'm saying they
already think that way when you teach
them square bracket arrays come on
you've had this thing make make an array
events called a that's got 10 integers
in it they think a is the array and
you're like no that's the address of the
first L
it's in the array and it takes you like
half a day to beat that into the last
stubborn head I'm saying let's get that
bit they want a to be the array so do I
so does everybody so give them an object
like that dirt so that a is the array
they're already naturally thinking that
way the only reason it's hard to get
people to think in objects on day five
when you get around to chapter 37
objects is because of all the time you
spent making them think in terms of
pointers up until that point so just be
object D right from the beginning and
that means using vector and is E string
and yeah the first time you toss a
vector on the screen there will be angle
brackets and you know what they don't
even care they really don't blink you go
this is to say it's a vector of int
because you can have a vector of
anything and they're like neat that's
all nobody nobody cries it's amazing and
of course this set shot for algorithm
right this sets you up for a lot of good
stuff I will say don't mention it
erasers okay just because you're using
vector does not mean you need to
immediately start discussing iterators
even when you're going to use algorithm
and call beginning end you don't need to
tell them what beginning and return you
just put the line up and you go we're
going to go from the beginning of the
collection to the end of the collection
and they all like okay I like this
language this makes sense now some
people start wait you want to use vector
you want to use string you want to use
CL what about all that stood : : stuff
you're not going to be wicked and put
using namespace as a magic directive oh
no they won't understand they'll think
this language is all voodoo say we do
your basic hello world console
application have you had that one person
in the back of the room who's like why
does it have to be called main I saw a
sample somewhere on the internet where
it wasn't called main it was called W
main or whatever was called
what's all that punctuation let's say
we're doing the one with you know square
brackets and two stars and whatever else
what's going on in there why does this a
include at the top how do you say that
symbol anyway is that sharp why does it
say sharp include most instructors can't
resist having a little speech once they
get on to include files about how our
philosophy is we only include what we
need da da da da you can easily spend an
hour on
if someone pokes you right if you're
going to have a return statement in
Maine why do we return from Maine what
does it mean what does it mean to return
zero or one or minus one
and of course explaining braces and
other pieces of punctuation whatever
your first hello world console
application is there's probably 11 lines
of trust me and one line that you
actually want to show them and you're
going to complain that I'm putting a
12th flight of trust me in the form of
using namespace STD come on right day
one there's a lot of trust me that's
okay but using namespace in there while
you're at it when you teach them header
files you can teach them not to say
using namespace in a header file if
you're going to have lots of time at the
end of the course and I put it to you
that you are somewhere along the way you
can have them do a using of just using
stood strength using stood vector that's
even better behaved than using the whole
namespace but on day one they can use
the whole namespace not going to hurt
anything so these four things alone
these aren't even by revolutionary thing
these four things alone are going to
make a big big difference you throw away
CARSTAR you teach string from day one
you throw away printf you use the
debugger or C out of your framework or
something you teach vector from day one
and throw away square bracket arrays and
you stay well away from pointers until
after polymorphism and I'll tell you how
you can do that in a minute and here's
where you get to your beginners will be
thinking object ly that's how they think
when they come in off the street that's
how they think when they're children the
only reason it's hard to teach people
object stuff is because we taught them
so much pointer stuff and then we say
now throw all that away and think this
way you think a string is a thing they
think a vector is a thing they don't
have any idea how to write operator
overloads or that they exist but they
totally understand that plus is
different for integers and for Strings
and you don't even really have to teach
them that they just get that so you've
got this foundation and you can then
start into the more difficult stuff now
let me tell you a story about me
changing how I taught things when
lambdas came out of course people were
all like hey and we need a what's new in
C++ 11 and I went out and I wrote this
stuff so you're going to teach lambdas
okay lambda has three parts there's the
square
Rockets there's the round brackets
there's a brace brackets here are all
the things you can have in square
brackets and what they mean and here's a
bunch of examples explaining it now
lambdas have a return type sometimes you
can deduce it here's an example where
the compiler can deduce it here's an
example where the compiler can't deduce
it right and I was very thorough
I had reasonable examples for all of
them and people didn't like that part of
the day because there was no explanation
why you would want a lambda or why it
mattered whether you captured by value
or by reference or really anything
there was no compelling motivation for
lambdas we just sat around and talked
about syntax graph and and syntax that
was maybe a little bit hard to remember
on first blush or that invited people to
make fun of that same syntax for being
so punctuation heavy so then I changed
my mind and I think I'm going to lay
this at the feet of Shawn parot because
I wanted to teach people more about
algorithm and hands up if you feel
guilty that you're not really using
algorithm and Shawn's making me feel bad
okay I'll tell you why I wasn't using
algorithm function pointers I didn't
care for them I didn't care for the
syntax of them I didn't care for writing
one-line functions and like having
functions called square it or double it
or is odd or whatever they were hard to
maintain and look after and where do you
keep them in all that chocolate so we
get lambdas and suddenly the doors to
algorithm open wide to me so you teach
somebody count maybe you write the lift
the loop first to count how many threes
are in this array then you show them how
they can just call count to figure out
how many calories are in the array and
then you show them with a lambda how to
tell how many odd numbers are in the
array by using count if you write a loop
that breaks when you find something then
you show them how to use fine then you
show them how to use find it a question
No start with like if you starting with
say find you don't get to choose your
parameter right it's whatever the
algorithm is going to hand you so I'll
tell them well it's a collection of its
so the algorithm will hand you and into
the times are you taking it right so
we're not writing a lambda like in space
with no constraints when you use it as a
predicate into algorithm you're actually
fairly constrained and so that kind of
leads them in and yes just say Auto sure
but you're teaching them what a lambda
is right once they've once once they
know what a lambda is then we can go on
the cook store right then we can say I
don't want to have to say int doesn't it
know because if it got wrong it will
yell at me which is my usual explanation
for auto right I do something I get the
compiler to yell at me and then I'm like
if you're so smart you do it and that's
that's also what I'll do when I want to
say I don't want to have to repeat
myself here in this lambda you know you
can use something like generator iota
where you've got some counter that's out
of scope so you have to capture it by
reference so you can kind of work your
way through that syntax tour but you
come from a place of here's a problem I
have to solve lambdas gonna let me solve
it while you're at it you happen to be
showing the algorithm but you didn't say
now we will discuss the standard library
you just show them they don't actually
have to write all of us themselves every
time and this is I think the bit that's
life-changing and credit for this has to
go to James a number of years ago now we
were asked to do a one-day intro to C++
online and everybody said you what and
so this was part we're like okay we're
not teaching any of that C stuff we
don't time we're going to jump into C++
with both feet and when we got to
polymorphism I believe it was James
although I can't really remember because
it was one of those moments where we got
really excited let's not use pointers
for polymorphism let's use references
for polymorphism and I know it sounds in
sane but it totally works and the
punctuation story is a delight because
when you start to use pointers your dots
have to become arrows everything has to
be dereferenced suddenly you get that
compiler voodoo day you know that day
where people are trying to do stuff and
they get compiler errors and then they
just start putting stars in front of
things and then they put like they write
star into a because that might work you
like no you never put a star in front of
a type that like oh whatever I don't
know you could put it at the end and
they're putting ampersands at the end in
the beginning and they just like
randomly permuting until the compiler
errors go away
usually they create right time errors
when they do that when they're working
with references it's still all just the
same as when they were solid objects so
the only thing that's different is that
there's a reference involved and the
cognitive overload of having to change
their punctuation disappears so here's
how we teach this you start with the
stupid pointless demo where you have an
integer and then you have a reference to
that integer and then you change the
value of the reference and today the
original number has a different value
and everybody everybody says why don't
you just change I directly but not
showing you how this aliasing works
right so then immediately get into a
function have that function you know
take a parameter by value change what it
gets and you leave in the temporaries
destructed and that adapt the original
still has the same value and you change
it so it takes its parameter by
reference and then it really changes it
once they get that which does not take
long then remember we already did
objects and classes set up a hierarchy
with a virtual function right a free
function that takes something from that
hierarchy takes a base and have it call
the virtual function when it takes the
base by value if you give it a derived
and we'll end up with a copy that's a
base right and it'll call the base
function and you do it with a base
reference you pass it a derived and it
will call the derived version of the
virtual function we did this on the NBA
day we did this with a rectangle and
named rectangle and you can see in the
debugger that when you passed it by
you the parameter it didn't have a name
member variable right and when you did
it by reference it did and it called the
overloaded I think it was like display
which built a display string that said
height width name no stars no points
twos just explaining polymorphism as
polymorphism none of the magic of
pointer explaining no address of no
nothing just focusing on the thing
you're trying to teach them just
polymorphism and they get it they get it
the first time because it's not obscured
by how difficult pointers are for most
people having passed anything by
reference it is a perfectly normal and
natural segue in fact sometimes someone
in the class will give this to you about
Const because they'll say in your other
example when we pass the integer by
reference and we changed it the real
integer changed so now when we're
passing the rectangle by reference so
that we can get the virtual function
couldn't somebody change the real
rectangle and you could be like yes they
totally could and you might not want
that and here's an amazing keyword right
and then you can do again that cookster
of if you put the Const here in the
Const there and the Jameses got a
constant a left constant on the right
rant you can you can play that game but
you can also like the difference between
a Const pointer versus pointer to cause
all that game if you want but you
started with a good reason for why you'd
want to mark something that's caused
so you've naturally put them in that
place to talk about Const we talked
about constant a 1 day intro to c++
course ok we got that far because not
only we skip ugly difficult hard stuff
the the stuff that's normally hard
people got in a much shorter time than
usual I normally polymorphism is a
really tough thing you have to draw all
over the board
for some reason once we switch to
teaching polymorphism with references
people just get it and you have way more
time to move on to other things that you
would like
cover and I don't suspect you
necessarily believe me so I want to
challenge you to try it because I tried
it in some other contexts and it's it's
a it's absolutely stunning phenomenon
pointers are really really challenging
and references are just less challenging
so when you teach polymorphism with
references you can focus on teaching
polymorphism where other than being all
bound up in teaching pointers and then
that puts you into Const and being in
Const you should have probably spoken
about intent already I speak about
intent from day one the difference
between a hand-rolled loop versus
calling find versus calling count versus
whatever you're expressing your intent
and that your code is as much to be read
by humans as it is to be read by the
compiler so of course the compiler reads
codes but human also leads cause so to
express to other people what is going on
in your code and to give them that
foundation from their first week of
learning C++ that this is a good and
normal behavior you were writing code to
explain what you want to explain what
you mean and to help the person who has
to edit this code twenty years from now
to know what you were thinking when you
wrote it you're now in a good place to
talk about scope you've done objects and
classes you dumped polymorphism
we've done some Const we pass things to
functions by value and had those
temporaries go away we've passed things
to functions by reference and had there
not be a temporary so we're talking
sculpt at this point we might as well
stop take a big breath and put up a
slide on the screen that says scope and
of course that naturally brings us into
our AAII and we haven't been near the
heap yet so we are presenting the normal
and sort of default lifetime as being a
stack semantics lifetime and in today's
c++ that is the normal if you think
about advice to use smart pointers the
smart pointer itself is on the stack
sure it goes and do something up
whatever you know so does vector so does
string I don't care
that
the hard thing for us to accept if it
was our job to care for a really long
time right and if you're a library's
writer of course you care but if you're
somebody who's being hired to write or
maintain modern C++ code your default
thinking should be a stack thinking so
they don't even know there's a heap yet
we haven't told them there's a heap
we're talking about scope we're going to
talk about lifetime when we talk about
Rai and we're going to talk about non
memory resource management because in a
garbage collected language you don't
worry about memory and the the rack on
C++ is that you have to worry about
memory and if you want them to dislike
C++ and think it's hard then go ahead
and focus on memory the minute you start
talking about life time but if you want
them to see where C++ can be good focus
on the deterministic destruction of non
memory resources on closing the file on
releasing the lock on closing the
database connection and having those
things be done for you when objects
leave scope not having to remember to
call close if you are feeling Maki and
you know your audience you can point out
the languages that have added constructs
to try to get them some form of
deterministic destruction for non memory
resources like using write in so and
c-sharp you have a using block that
calls dispose at the end because they
missed having that natural and automatic
lifetime management the classic demo
here is a class with a whole pile of
constructors that say copy constructor
went off default constructor went off
and so on and a destructor and then you
run a bunch of things and people can see
things being created and destructed
right just be careful
you don't want to be six Devils in and
then have some like return value in
needed and so those things that oh I
thought there would be a pair there all
right Artie okay so make sure you know
what you're showing and what you're not
showing but squawking and destructors is
a pretty good way to show people what's
going on or of course the debugger is
tell your friend with scope with
destructors it's okay now to talk in
intro to c++ about exceptions the idea
that we leave scope for a different
reason than returning for a different
reason than reaching the brace bracket
but that the same thing still happen if
you want to talk about what motivates
exceptions about you know I don't think
most people greteman really think
running out of memory is a thing anymore
but you know files not being found that
someone just browsed to then when you go
to open it it's not there that kind of
thing and give them some examples of
what exceptions might be caused by and
the disruption if it comes right after a
discussion is scoped there's almost no
disruption at all okay you can just
present it as a benefit of not having to
check a chain of return values for
example does that mean you should never
teach pointers no does not mean you
should never teach pointers you don't
need to teach pointers for the usual
reasons that we get stuck teaching
pointers on day one and day two don't
need to teach them so that you can
iterate through square bracket arrays
you don't need to teach them as pointers
because you're passing by address
because we're going to use passing by
reference for that capability and you
don't need to teach pointers so that you
can teach polymorphism because the later
you teach pointers the better when
people are working deliberately or not
with pointers on day one they are doing
that voodoo stuff they are just typing
stars and ampersands in the hope that
their code will compile when you teach
pointers on day four or five they kind
of feel like they beginning to own this
language beginning to understand what a
lot of the punctuation means they've
passed some things by reference and by
value and they are understanding where
what it means to put that punctuation at
the end of the type and they're kind of
ready for this idea of decorating types
and they are more comfortable and more
confident and less likely to say I don't
know what I'm doing the compiler knows
everything I'm just going to randomly
try stuff and they're more likely to
feel like I get this language I have a
little bit of master
I'm going to listen when it's explained
to me and so they can actually work
properly with pointers at that point so
the number one reason to use pointers is
of course because you put stuff that on
the heap and the number two reason is
because you either want to have null
pointer available or you want to be able
to repoint it all right because you
can't riraf er a reference but you can
repoint a pointer
fine so you know you say here's your
basics but when you write a real program
sometimes a person opens a bank account
and that bank account object needs to
sit around you know for for quite a long
time that brings you to the heat so I
spend a very short amount of time on new
and delete and then basically tell them
that they're soaking in it because you
use objects that do the newing and
deleting for you and remember they have
now been handed hand with vector and
string since day one so you can tell
them that in fact when they make a
vector of whatever's the whatever's are
on the heap when they make a string and
don't talk about short string
optimization when they make a string the
characters are on the heap it's just not
their problem because they trusted the
object to do it for them and then that
puts a smart shared pointer and unique
pointer in exactly that category yes but
do you really need to teach you now that
we have make unique sure so I don't
think it's fair to call someone a C++
programmer who's never seen the word new
but I really when I say five minutes I
mean five minutes right like a show it
to them and then say but we don't do
that
it's dad that's upper library writers
you know and move on if you're scared of
templated classes including vector and
you don't teach them until five days
after new then you can't count on their
comfort and familiarity and trust a
vector to make them feel okay with smart
pointers doing their allocation and
freeing for them but if vector is an old
friend and string as an old friend
then the smart pointers they're just
that they're just cousins right to these
useful working classes there we go the
hard part the really hard part is coming
up with a good use case for shared
pointer we are lazy
we like using shared pointer because
then we don't have to move right you
just copy the thing around all over the
place and everything will be fine if we
make a unique pointer we got to remember
when to call move and I go to a whole
one-hour talk about when to move and
when not to move so we just use shared
pointer which is really wasteful and
I've said don't care much about perf but
if you were to teach a bunch of
beginners to always use shared pointer
because it's easier you really would be
doing the world a disservice so present
a unique pointer as kind of your go-to
pointer and come up with a use case for
shared pointer and I so a little bit of
a challenge actually to come up with a
good use case or share pointer go ahead
the fact that share pointers have weak
pointers is actually yes that's a very
good because it doesn't keep them alive
you just want to be able to cache the
pointer the example I gave and it may be
a little bit out of date already but the
last time I did this I was using a
Twitter client that had multiple columns
and I said imagine that there's like a
picture in a tweet and that tweets in
multiple columns ones everyone I follow
one is like the CP pecan hashtag and one
is mentions of me and you don't
obviously want three copies of the
pictures so you want each one of those
columns to have a pointer to it and you
don't know at what rate the columns are
going to be scrolling off the screen
right so whoever Scrolls off last that's
when we can throw the picture away and
that you need to come up with it with a
case like that that makes shared pointer
seem like the exception not the norm
because it should be the exception not
the norm so don't just teach them that
this is easy just use SharePoint ease
you can pass them around and the last
one out turns off the lights
you're not making good C++ programmers
if you do that so have them always use
smart pointers but have them use the
right smart pointer oops
null pointer you do need to talk about
null pointer it is stolen out of a
signal value right and in order to pass
pointers ruff address of pointers not
things you got back from knew you got to
teach them the address of operator and
and at this point and you have to
practice this sentence so you'll giggle
right you can say pointers are kind of
like references
and the kinds of things I've shown you
that you can do with references and
polymorphism you can also do with
pointers in polymorphism and it is
really tough to do that with a straight
face the first couple times but they get
it okay and now you can repoint the
pointer and there's nothing wrong with
Raw pointers if they're not owning raw
pointers right so if you've got some
hierarchy where every customer has a
whole bunch of accounts those should be
some kind of a smart pointer to an
account so that when the customer say
stops doing business with the bank all
their accounts will go away but it's
okay for the accounts to have a raw
pointer back to their customer that they
can use to god you can do good examples
anymore because there's no such thing as
a printed statement but you know
remember printed statements so you need
to ask the customer for their address to
print it at the top of their statement
feel free to bring that up to the 21st
century but there's no raw pointers
aren't bad we kind of over swung for a
bit we were never going to have a raw
pointer again in our lives a raw pointer
from new is bad a raw pointer from
address up that's only used for finding
your parent or container or owner or
whatnot so that you can ask it to do
something it's not that at all and in a
case where for example an employee can
move from Department of Department you
obviously need to be able to change
their department pointer to now point to
their new department right so having
sensible examples that you can present
worked out that show the motivation for
why a pointer is a better plan here a
raw pointer absolutely nothing wrong
with that so if you toss the see stuff
on day one and if you teach polymorphism
with references and wait as long as you
possibly can to do pointers you will be
able to cover all of this objects and
classes inheritance polymorphism they'll
certainly see operator overloading you
may have time to teach them an operator
overload they'll know about scope and
destructors and are aai they will be
comfortable using templated classes and
functions and the standard library will
hold no fear you'll have taught them
const and exceptions
and lambdas in a beginner course because
you will not have covered the delights
of printf format strings it's a great
place to show off how smart you are and
it's a great way to use a pretend of
time but not doing it doesn't really
hurt much
you will not covered what I like to call
STR Starr right and I don't just mean
Stirling stir coffee stirrer compares
blahblah when do you need stirrer in
whatever when do you need the ones with
the underscore S on the end
what's the special prime missile you
don't need the ones with the underscore
S on the end let's have a half-hour
discussion about buffer overflows while
we're at it on day one because we wanted
to stir copy the person's name into the
name variable right skip all that all
this stuff about not allocating enough
allocating too much looping too far not
looping far enough less than versus less
than or equal to oh you need to stick a
plus one on the end of that oh you need
to stick a minus one on the end of that
which is another set of do Dunas right
I'm getting a runtime error let's let's
put minus one here and see what happens
you can see skip all that and not only
is that freeing up time for you to talk
about important things like our AI it's
taking away the bit where they go I took
C++ 20 years ago and it was awful
they're that awful doesn't come from it
being C++ I mean okay yeah if I show
them very attic templates you know or
speedy or something then then they could
fairly say that you know it was scary
and awful and difficult and hard you
have to be super smart but the fact that
they're saying is scary and awful and
hard you have to be super smart because
sometimes you have to add one it's like
really unfair of us to set that up and
we don't even need to because there's
nothing to be gained by doing one and of
course the magic I don't see cargo cult
anymore
this doesn't fit in this talk but we can
talk about cargo cults which I learned a
lot about this summer and people who say
cargo cult are actually doing what they
think the cargo cult people are doing
but I will say Robo typing were you just
randomly stuffing punctuation in the
hope that the compiler will grant you a
build succeeded the longer we put off
talking about pointers
the less of that we have and that's a
win for absolutely everybody and of
course yes question I say that you
cannot copy a unique pointer you can
only move it here's how you move it yeah
eventually we're going to have to talk
move constructors we might even have to
talk r-value references but I'm not
trying to make library writers I'm
trying to make library users ok it's
alright if you're going to be inducted
into the tribe of library writers for
someone to pull back a curtain and show
you a lot of stuff a lot of punctuation
dot dot says andre is where the fun
begins um that's that's ok for the
people who are going into into that
tribe right but for the library users
you would be amazed the power of a
teacher confidently saying that
something is simple
you can't copy unique pointers you have
to move them here's how you move them
moving on and then they're like ok the
same is when you just say well a here is
a vector and this is a vector so if I
say a equals B what do you think happens
yep that's what happens moving on it
only seems a miracle if you remember the
old way yes do you ever talk about
regular types you mean like what makes
an ant different from a string no like a
type being regular so it can be default
constructed it when you assign into the
so it is a copy it didn't work yes
um usually not in an intro course
because again when does that matter
yes right maybe when you're writing a
template and and I don't want to suggest
that everyone writes a template as a
wizard it is in a different category but
they don't need to understand all
everything all the way to the metal in
order to write successful code
matter when you write templates that
matters when you write user-defined
types at any point when you write
user-defined types you should be trying
to make them regular so that they behave
like actual regular things right so
let's say I write a class called
employee and I don't write any
constructors I can make a vector and
employees right then I decide I'm going
to add a constructor that takes out a
know a name and a birthdate and suddenly
I can't make a vector count employees
anymore right because I don't have a
default constructor that I have to
explain what compiler does for you and
all that but that's a different
philosophy which is different from the
stop teaching C philosophy which is that
I try to let the problem naturally occur
and then show what to do about it
and so that's that's when that would
come into play and if you want to give
it a name and say you know this this
collection of statements about a class
has this name that's an also good place
to do because what I found was that my
students often don't think about the
fact that oh this class is holding some
kind of pointer to a resource that
they're not copying when the Col class
is being copied and there's introducing
a whole new class of bugs by not
thinking about not synchronous coffee
relationships right so that's about
again if you're using a raw pointer for
ownership and then you have to write the
code to do the deep copy so this is the
rule of three seven eleven fifty to zero
right and I like the zero version of the
rule the best and so this part of it
right that if you if you follow this
certain set of ways of behaving then you
live in a rule of zero that you don't
have to have the talk about don't forget
if you write an operator equals you got
to write a copy because like all of that
you know I'm not saying that nobody
needs to know that but I am saying that
if we live our lives in a way that we
have to teach them that on day two of
intro to C++ we are making the language
harder than its rules that's kind of my
point I'm not saying don't do these
things and saying don't set your course
up so that you have to teach these
things in order for people to finish the
course
fair right misery confusion swearing
skipping that stuff makes people like
your course people tell me stuff like I
thought C++ was supposed to be hard I
hear that a lot
I love getting those emails they told me
I had to learn C++ at work because this
new project we're doing and everyone
else step backwards and I was standing
forwards and so now I have to go on the
six plus course tonight I took your
course and ha joke's on them
turns out it's not that hard my favorite
why does my boss think I cannot tell you
why your boss thinks that C++ is all
about pointers that C++ is all about new
and delete that C++ is all about bitwise
manipulations and bit twiddling z' I'm
not responsible for whatever childhood
your boss had now it is fair in certain
work environments people who go through
this experience will be deficient in
some things right they will not be able
to read that si compiled with a C++
compiler stuff you know I I'm worked on
modernizing a bunch of code where the
guy was moving the null around inside
strings so that he could use stir
whatever so he had like 100 character
string but he squirt a null in where
there was a space so that he could use
stir copy and then he put the space back
and of course all this done with some
giant loop that was going P plus plus
and P minus minus and stuff all over the
place and those people who spend the day
or the week or whatever learning modern
C++ without learning C first when they
hit that code they will be
deer-in-the-headlights okay so if you're
teaching people in house and you know
there's some of that code scheduled a
day called how to read the old crap
that's fine there are some idioms if P
is equal to some function that returns a
pointer not equals equals right assign
right so that if the function returns
null we don't go in and do things with P
if that's an idiom that's throughout the
code base that you believe these people
are going to go when you do pointers
when you talk about null pointers show
them that idiom okay don't show it to
the Monday one when they don't even know
what a pointer is or the difference
between the two kinds of equal signs and
if you are going to teach people that
idiom you need to live on a warning
level that warns when you do that wrong
when you stick it in integers and stuff
right I also no longer do how many bits
bytes are in an into car a blah blah try
to explain that when you type quote a
quote you don't get a car all that I
just don't even do that
it puts way too much strength and
importance on fundamental types and and
sets up a dichotomy between fundamental
types and user-defined types that's less
true in C++ than it is in any other
language so I literally don't even worry
about the fact but on day one some of
them think string is built-in like int
like I don't care in fact I think it's
kind of a feature that they think string
is built-in like int like that means the
string was written well right that's our
goal that's what we want our classes to
be when they grow up
and so tables of these are the
fundamental types which you can memorize
and everything else is not is working
against that spirit and the same with
operator precedence tables just have
lots of brackets or don't use so many
damn operators you're teaching them
overall it is my position that you will
have a win-win that they will enjoy the
training more and be better we can be a
little bit masochistic as a tribe if
it's fun you're probably not learning if
it was easy then you probably didn't end
up smarter and I want to say that that's
not true that it can be fun and easy and
make better C++ programmers because they
think object ly they think ra íí-
they're using the standard library
they're using lambdas they understand
the punctuation that they're typing
these are all good things they are
happier but they are also better and
that is why my plea to you is to stop
teaching I have six minutes or question
yes do you think the first language and
also at what age do you start teaching
kids kids selves and then also how would
that compare with other languages they
don't have to deal with a lot of these
issues maybe Python for example
I did not used to think that C++ could
be a first language so when I taught my
own children to program I didn't teach
them C++ at first however I was asked a
year or two ago to write a C++ as a
first language course and I was goaded
into doing it so I did it and it can be
done and you can take someone who
literally you have to say sometimes you
want the computer do to the same thing
over and over again we call this a loop
you can do that and show them a C++ loop
you can do it because you don't start
with how many bytes are in an int and
whether along is really longer than all
of that you just don't do it for kids
the the big benefit of other languages
is not about the language it's about the
library it's about that they can write
hangman on anyone right if you find a
library whether it's cinder or whatever
that you can play that with and they can
be writing hangman or exploding the
asteroids or whatever on day one then
there's no reason why you can't the
semicolons are not or not that okay in
fact I mean when I first met Python I'm
like was this person scared by a brace
bracket as a small child I don't
understand
there's nothing intensely difficult
about brace brackets or semicolons as
ways of showing that you're done
compared to a textual spacing like we
had in Fortran which I thought we'd left
behind so yeah you could teach it to
kids you can certainly teach it to
beginners in some ways having experience
with a C is now a detriment to being a
good C++ programmer as compared to
having experience with a more object D
or a more functioning language
I don't know ordinary children I just
know my children and we're seriously
talking like 10 12 when they still think
you know stuff that's a good time back
here so build testings unit unit testing
build systems source control work atom
tracking process it's all super
important but to me that's orthogonal to
language depending on the platform
you're on you're going to go a different
way for testing you should be testing if
you're teaching your own people then
write unit tests on day one
when you're writing a hello world thing
and say and I will test it that you know
the the sample I like to write it ask
you your name and if you say Kate it
says hey I know you and if you say
anything else it says hello whatever you
said right and so you could write a test
for that and you could do that right
from day one there's no reason not to I
think that anytime you wait and bolt
something on at the end you send a
message that it's not really important
but I think it's orthogonal to language
choice do you ever go into you know pure
functions passings thing is either by
value or con strap returning multiple
values in the tuple and so again when
somebody has a need for it
it's true you can only return one value
most people just accept that right then
somebody comes along and says ah but
that one value doesn't have to just be a
an integer it can be a thing and then
offering them pair and then tuple is a
natural way to tell them they don't have
to write classes if all they really want
to do is tie some things together but
that that happens less often than you'd
think in wild code when you're not
writing a library so a lot of times I'll
write a tuple to hold three strings and
then after a while I'll be like you know
what I really should call this employee
right so in production type code there's
not a lot of information in tuple
compared to writing a class let's
doesn't often stick with you yes
whatever whatever the compiler usually
people have to learn in an environment
okay so if it's if it's an in-house
course that's what what compiler does
this company use if it's a university I
have to first persuade them to come up
to a compiler from this century and then
so I'll take I'll take the absolute
latest that I can get but even then it's
like well what machines are they running
these on you know do you guys have like
a MSDN academic or am I am I not going
to do to do any Windows work like those
are your choices right so it doesn't
really matter as long as we at least
have 11 I'd like to I like to have 14 so
I can have make unique ok I'll grant you
that but if I can't have make unique
then I can just wave my arms and say as
soon as you get out of this room and you
can get a real compiler
have mechanic and I'll show them like
any kind of slot could that not be
introduced as it trust me
about the code trust me on this magic
yes I'll or may be all right one that's
not the stud name space right it's not
exactly a long function yeah
for me the key is that they understand
that it is a language of changes and
that grows and that they can't just put
a tick next to learn C++ so I don't want
too much diversion about oh now this was
not a few puerile not on the latest
version blah blah but a little bit of it
is good so they understand they are
living in a dynamic environment I'm
going to selfishly grab the last
question with less than a minute left
when is your college level textbook B
here's the deal with books
um I grab not about money I can only
make three dollars a month for so long
making a world better
yeah so I am trying to make the world
better but I'm trying to do it through
leverage and indirection so go forth and
make the world better please
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>