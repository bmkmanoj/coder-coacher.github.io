<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Joel Falcou PART 3 “Expression Templates: Past, Present, Future” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Joel Falcou PART 3 “Expression Templates: Past, Present, Future” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Joel Falcou PART 3 “Expression Templates: Past, Present, Future”</b></h2><h5 class="post__date">2015-10-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/A9trwnv6k-w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">ok so it's boost ionization every time I
use as a cold I mean also egg is it
working you know and and some corners of
booze photo he does it is the same it
what the heck I'm looking at okay let's
put some batteries inside this okay
great so I think everybody see there so
arm onto the last vertices of these
sessions so we speak about that so okay
so the question is I got all these nice
cooking stuff just after work if you
just scream too so you can see 10 and I
probably need to put my microphone on so
last session of this stuff so as I said
so we have all those nice tools okay we
just paid it very very few bit with I
would go over an example just after that
so we can see what kind of really kooky
stuff we can do with it so those traps
okay and those traps for some are
actually okay and for some are actually
real traps you don't see coming so
basically you are combination of
expression templates and auto function
returning some expression that may or
may not contains temporary terminals and
of course completion times okay because
well it's it's rather as you could have
so it's it's a bit easy so once the
risotto and by auto I mean actually all
the automatic type deduction into the
language including templates okay so
look at the code I've wrote there you
are let's say you have an array classes
which is actually a expression temperate
seminole okay so you have some stuff and
you say Z auto z equal X plus y times
three question is once the type of Z we
saw it it's not an array it's whatever
the underlying expression template
systems give you as a tie for this kind
of expression ok so this
a certain is safe should have been a
static assert will fail because it's not
an array well actually logically it is
it's like an array except it's not
physically okay and Otto doesn't carry
this information so that's something you
can actually live with it's not very
very you know leave dating where it
falls more issues is there so let's
let's have a look at the function bad
double question is why is it bad it's
bad with respect to use it with
expression templates of course what
happened if X is some expression types
so x is for example a section for
example let's say it's our binary expert
we saw a bit before and we return X plus
X which will be a binary expert of +
between the type of X and the type of X
which is clearly not T it's not tit
something else and you don't really want
to care about that it bad double works
if you pass into regular types okay well
a regular types that which is the output
types is the same as an input eyes when
you call plasma you see what I mean and
what you should be doing is what God
ball does you just return 0 2 and then
you get the correct types I don't say
you get the correct results you get the
correct types more on that and the other
issues is a sometimes you do something
which is completely you know logical but
you will lead to crappy performances so
let's let's look at through so you run
your listen in your return auto okay but
something is still wrong there what if
you pass a regular types you compute X
plus X once put it in 2d and compute Z
times D ok so now imagine that plus for
your touch is very costly ok for
whatever reason and you pass an
expression templates expression as X ok
so you will be the expression
X plus X and you store it in 2d as a sub
expression and you put it two times and
you end up with the expression which is
X plus X times X plus X and you do twice
a computation of X plus X because you
store it into auto so you have to be
careful with automatic tax deduction and
expression templates because the
language does what it should be doing I
give use the titles of stuff you asked
at all what do you want me to do anyway
okay so a lot to be careful with that so
I don't know different solution exists
actually so is there you know what
you're doing which probably means you
are not into a very January context and
so you just put them actual terminal
type where they should we do it be done
okay except that means that you cannot
write functions that just take whatever
and do whatever so we ended up with this
viral contamination application or photo
everywhere which solves the outgoing
issues but doesn't solve the issues
inside so some libraries based on
expression templates provide the
function or meta function that is rough
record value of our terminal from
something like this second expression
and give you the type of the terminal
that should be able to contain it and so
you can locally decide but you are still
into a generic context and the other
stuff will be speaking about later is
there is a proposal absent are pretty
Gaussian and myself wrote which is
basically provide a way to overload auto
forgiven times more on this later so
it's not trivial you have to be careful
as soon as you have automatic type
deduction and expression template in the
same box okay so that's the most
communicated stuff you have to be
careful with this it's bad somehow
because we really all really really love
auto but not in this case okay other
issues is just what I call what I call
the sub expression issue I spent quite a
lot of time on this trying to fix it
properly okay we speak about Morgan's
that later but one trivial stuff is
usually
as soon as your terminal is more is
bigger than the simple values that is a
table or something that allocates memory
you want to store your sub expression by
reference because you don't want to copy
your terminals okay wait okay fine but
what if I do this so I take something as
as X could be an expression and for
whatever reason I know that I need to
evaluate right now because I read the
slide just before I will evaluate the
sum of two times X plus 3 into a my
terminal which is array so this allocate
some memory and do the operation inside
okay and what I return is the
expressions two times t minus 1 over T
which is the reason I evaluated
everything in the narrow because T was
twice into the sub expression okay so T
got some memory allocated what should i
do for this code to work when I returned
two times t minus 1 over T what happens
if I store everything by copy inside my
expression i would probably duplicate
the memory of the far too much probably
three times okay because you will copy
it into the divisions copy it into the
multiplications or four times and copy
both again into the minus so if array is
like one gigabyte you is not gonna fly
okay okay so just take everything by
reference right so what happens well bad
story for you I will have a reference to
tea in my 1 over T same for two times T
and I'll go out of the function and t
get dis allocated and I got nice tending
references to memory that not there
anymore crap so what should we do there
but goodies solution boosts proto is
very adamant on this by default
everything in booze photo is taken by
reference because most of the time what
I disagree with that sorry Eric that's
the correct thing to do and if you want
to do this you have to call a function
called boost jeep
copy with as name implies perform a
reclusive copy of everything in the tree
into another one so it sure that
everything outside is still there but of
course it's very costly and as again
that was pre night it's simple since 98
so we didn't have move semantics so one
way to do this is if I could find a way
to use move semantics into the situation
so I can decide if the steps that coming
in as to be copied or not and so I
decide which kind of storage I need to
have could be ending but it's not that
trivial so this kind of stuff for just
for the gigs okay this exact same kind
of bird took us something like two
months and a half three people okay to
find it when you saw it it's obviously
obvious that you did something wrong but
I can tell you that when you are writing
your code and everything worked because
of course of tests pass and why does a
test pass because well you get for you
you get flushed by Z in line in your the
compiler when you're joining you in
release mode and everything get in line
and the reference never exist actually
and as soon as you go somewhere else and
the guys actually using your code in the
client and comprising the low level of
optimization everything blows up because
the reference are there and not in lying
anymore so that's a very crooked bird
okay don't do that oh do it correctly
and the other problem is combination
time so if you do a small scary dsl eyes
the first part probably fast enough for
what you want to do and the problem is
that you remember this symbol names that
grows up exponentially oh not
exponentially I mean probably oh well
far too fast okay and though several
names that something I suspected and
Jordi Guzman actually suspected to and
actually I mean demonstrated that it was
the case first sources of compile-time
issues with the slc symbol names because
contrary to rig record said it just
takes a human goose amount of space
compared to what they encode and the
other problem usable
and other seminar systems is the
complexity of the transform your pride
in the tree not to come out the
complexity of what you write in the
booth photo transfer what is actually
does and are you have to actually
explain what you should be doing in
terms of tax computation so the solution
is simple as do the simplest version of
extra interpret you need who doesn't
need to put proto full-fledged stuff
don't use it take it like like a
grown-up and write your small-scale
stuff but if you need something more
complex you probably need booze brother
well good luck back in the day first
time I used booth Prado was in 2003 oh
no six no 3306 I don't remember
somewhere 2005 ah i was working in a
very very very small system with like
1gb bite of ram and mostly 1gb Earth's
of CPU power and I was trying to write
booth photo transforms that transform
you know change of matrix multiplication
into the optimal forms okay and the joke
was as soon as I had more than five
matrixes into my expressions I could
launch a compilation at eleven go to
lunch go back at one and then I get the
result so well so actually the real
problem is that we do the compiler we
further compiler to do is damn job at
least three times so what it could be
cool is if we double a language support
to say okay you take this expression and
please give me these three and I need it
for doing something else and the
compiler just okay this is a 3 I just
passed so a bit could be far far far
more efficient ah well that's the
complicated and one thing we cross
discovered so me Jorge Guzman Lewis for
computers of stuff is that you can
actually use see precipice 14 lambda in
the perverse way to write something that
looks like expression templates i will
show you that a betrayal
so combination time is fully currently
the most biggest problem and it's very
complicated to get something that come
by fast all the time that's such a big
problem so before going to the next
level stuff let's have a look at what
kind of cookie finger we can actually do
with with Prado I won't go into the
details just so you can scheme and you
can actually look at the complete code
into the github was that something I was
doing when I was making a five hours
tutorial on Prado and you actually have
to write it by hand from scratch so this
is what I want to be doing okay I have a
bunch of terminals called XYZ and so on
that represent arbitrary abstract
variables and you can use them to
actually build arbitrary analytical
functions with Rita / viable okay so you
can actually do stuff exists okay so i
will do it so you can write that and
pass it through variables and we come to
the function on the two points for x and
y and what we wanted to be doing is I
want it to be able to say oh I am each
time why compute the derivative of this
function with respect to X and give me a
function I can call with some values so
i can ever range the derivative of this
function at this point and also do this
what you want to do is what about having
the nth derivative which is basically
the recursive application of the
derivation function n times ok so you
can actually write code like this so you
can also have support for course and
sign ok and you just walks and others it
works well when you compute the
derivative of function what do you get
as a result a function so what we do is
we take a proto tree representing your
initial functions and the transformed
with right just take the function and
say oh I have a plus note i need to
derivate it and
deviation of plus a plus B is derivative
of a preservative of be so I computer to
derivative of my children and I bid a
new tree with this and you just
enumerate all the derivation rules for
plus/minus divisions and so on and so on
and as the output you get is a tree in
the same domains and the one before you
can just pass values for your Bible and
you just compute and all those the
matrix computations are done at compile
time actually so you get a new
analytical three and large functions
directly at compile time okay so you can
have a look I mean really when we want
but this is the main idea so so we have
a grammar so to something I didn't speak
about it so what we call a switch
grammar so issue is or is that it's
linnea of time to find the rules you
want to match there's the first one and
then the second one and so on and so on
when you have more like I don't know
between eight and ten rules it start to
be very very slow to impart and then we
switch with something which is called a
pro to switch it says I'm taking a
structure which contains all the cases I
care about and these cases can be
declared externally to the grammar so
because the first case is if it's a
terminal okay so it's a bit more complex
at what we saw for terminal ok this is a
terminal if it's a terminal of something
and only if the value of the terminal is
convertible to boo me between bull and
floats basically okay so we can write
that we have a proto if you can use for
taking decisions and I will say yeah I
can negate I can do plus I can do my
nurse okay and so on it's all enjoy so
it's like or except it's done externally
and as I say you can do function so
although you do functions you need a
type which would be
bag and say oh I am crossing this note
ok so that's the name of that's a reason
to have this kind of straw stack and we
say i can compute caused by taking some
value in that and calling STD calls for
example sense same stuff for sale and
what you write is something like this
edgy stuff you say i have a function
called cost taking something out 0 and
what I return is an expression of course
tagged as a tag that contains arc 0 by
constant by reference to a constant and
we just call this see ref stuff to store
it ok so we have this Mac expert
function in produce it just build an
arbitrary tree with an arbitrary tag and
stirring every child I will travel as a
value or as a reference or reference to
prompt ok so when you the only color
function you just say ok I'm just giving
you Z so node with colic tag and
whatever childhood ok that's basically
was the operator does except it's hidden
ok and same for sinners and then we do
the grammar for for cause when I have a
course I mean that I am a new nary
expression of cos tag applied to
something and when I match that I have a
cross oh and we may want to know what
what I do to evaluate them because all
zeros operator we know that we have
these otherwise default mode and for
customers and sinus what I do is
whenever I have an expression of cos tag
I evaluate my child and I pass it to
compute costs so it's so part of my
French as they say but it's not complex
is complicated because you have a lot of
bookkeeping to do but every of this book
keeping our rather simple just that you
have to go through all those rules so
when you write it once I mean it starts
becoming you know some kind of reflects
ok but you have to go through this once
actually ok
I so this is enough for building oh no
it's not in the factory but this will
add plus building the regular expression
so what we do is that we have an
expression types like we saw with the
domain and so on such as do whatever
except we can call this up to three
variables so we have three operators
function call with one two three values
and what we do is that we store
everything into an array and we pass
this area as a second parameter to the
variation and we will have access to
this array through the up proto
transform as a state we can read and
write from into that is it an ever wait
where is it ever I just say okay it's
the same stuff you use cases it's a
switch over each cases I will go on that
I mean if I'm returning all of the
proper type I'm just giving you my value
classical okay and if not the default
case is just the fourth case we saw
before another question is all these
derivate stuff works well that's a bit
more complicated but not much still
again we have a switch base grammar but
we don't have any default so what
happens when I will keep that one for
later yeah what happens if i want to
dairy rate minus x whenever i have minus
x i build a node which is Magnus
something with derivation of my children
okay functional make negate of the rate
of my child and I pass that to another
function which is called simplified I
will go on there to be later but what
would simplify does well let's say you
have x times X times X and you want to
compute the second derivative of that
you will end up with something like X
plus X times X plus X plus X plus X we
have a very complex 3 because everything
get to know and backed when you do the
derivation and you want to simplify that
to be X plus X
plus 2 times X and so on and so on so
simplify just limit the size of the tree
and we just enumerate all the cases of
the derivatives plus is a plus between
two derivatives same for my nurse a
bitter price is a bit more a bit more
complex but because the rules is more
complex and so on well sorry devices
Awards actually I think it took me 5 to
15 minutes to get it right but whatever
and course is basically Magnuson and
scene is basically minus cost and what
does n for the innovative does it just
called derivative on itself n times ok
and what happens when I want to derivate
a terminal how much cases do I have if
it's a constant i get 0 oh wait now if I
derive against X and it's not x it's 0
including the constant so what we do is
if I have a constant I just return 0 ok
if I have a constant like constant 0 I
just returned constant 0 ok and if I
have viable XYZ each viable as an index
0 1 2 and you derivate against another
one so if the value of the terminal I am
looking at is the same that the 1 i'm
derry writing against so I have an ex
and I derived against X then I returned
one if not i will turn 0 well why didn't
return is to you with writing it is
another issues and so that's what that's
probably what this one is a bit big but
it's less than let's say it's about I
would say a bit less than a thousand
lines ok probably around 600 or
something nothing exactly complicated
it's more like syntax issues and getting
the algorithm right and you get this
derivative stuff walking not just that
was what
and when you look at the genetic code
you just get whatever you need and I
don't think you can get better interface
and that the more clarity of what you
want to be doing well we can't we can do
stuff like this you can actually do far
more so boost MSM is actually something
that builds state machine from from
operator overloading and generate the
perfect autumn a ton for doing it it's
quite a bit impressive there is a bunch
of magic linear algebra matrixes basic
question templates they are all get very
nice features I mean you can basically
do whatever the question is I mean it's
like in spider-man you know right with
red power comes great responsibility
that what do you want to do with it okay
sometimes you should be just not doing
it because you may find them far simpler
design without any lazy stuff inside if
you can't do it okay but sometimes you
really want to access okay so what does
it imitation and we so and there is some
work being done try to into to finds us
um so the other one okay so first
question is should i still doing this as
i said we have mu cementing web copy
additions we have a far more better
compiler than before and yes most of the
time if you are only looking at
performances is probably not what you
really want to do because the benefits
risk analysis is not in favor of this
kind of stuff but what you really want
to do is write intentional code and that
you cannot do using the compiler so you
want to make your library as intentional
as possible and efficient Empress is
just writing for that you can extract
information the comparator can't even
see and you can use them at compile time
to decide outright your gold and out
generate the stuff and you can actually
rise and we benefit from a lot of very
very abstract I level optimization
opportunities I was speaking in the
break about facts are to collectively we
can actually wrote a signal processing
library when you have signal and you
have nose classes and you know that if
you want to come you ate the signal with
a noise which is white you don't have to
do to your
food combination for rehab of simple
algorithms okay and so you can detects
act and generate the proper algorithm
but the compiler can't with that i mean
it's it's human level information okay
so you want to perform domain-specific
optimization because if you just want to
generate the perfect for loop with
vectorization and whatnot is probably
overkill because most of the conveyor I
probably do it right right now except
for some kind of cases when you need
this but as soon as you want to read
benefit from higher level optimizations
that what you will be seeking with a
fusion ten things so I'm going back to
auto so I was speaking about n 4235 so
the idea is to be able to write that
soul of a product expert which is some
kind of you know lazy nodes that we
wrote that captures matrix project okay
and what we want to say that oh wait if
you use auto on that I don't want you to
give me product expert giving mattress
insane instead so this this notation
just say whenever you use auto on that
give me this instant that means that you
can actually wrote code exists so this
Auto Z or a times B uses using auto
record notation and that's basically
matrix Z equal a times V which is
exactly what you may intuitively want
but if you really really want the lazy
expression you can just write x fish it
auto w equal a times B and you get the
real auto behaviors okay so that's
something we're still working on it yet
somehow we're received so we are still
up to get true but that's some
interesting texts and one thing is that
ok it's useful five different templates
but not only it's actually useful for
any kind of proxy times where you don't
really want to store the proxy type in
October the real actual type speed so
that's something we can actually walk
with its mo generals and expression
templates and my actually my secret
agenda is trying to find the most the
biggest amount of generically applicable
such as
languages so some was a problem are
solved and I can use it into expression
templates related problems okay just
don't just kids answer to video please
but so unless the stuff i try to do
recently is so for for the people that
doesn't know so I mentored with the odd
for his work on booster for two years
now and looking at what we did in Anna
will say okay we have all these cool c
plus was 14 days tricks that give us a
very lightweight and very interesting
way to write the flag topple in sin and
phoenixes and shouldn't we be using this
kind of tricks to rewrite something
which is new plugs booth prado except
probably come by faster and with less
code okay so i started working on that
and the idea was to do what I know Cole
well it was not there Matt with it well
again we we have sister with calling
recently which is a we want to have a
sustainable library sustainable library
means that it's easy to use for the
users if not you kind of faded doing it
okay but the inside of the library is
also simple to look at and understand
because you don't really want to have a
lot of language lawyers like Beyonce to
2x venue was going on in to the library
this need actually raised from the fact
that when you work with people with
different level of C professed knowledge
and you and your job is actually like me
writing libraries is very complex to to
get everybody on the same you know level
stuff so the simplest called advises the
library level as the whopper of
libraries but it is as soon as we keep
the same level of usability so we want
it to be sustainable so the trick is to
say are we use what I call similar in
compression too fast and too many times
by reducing the amount of text into the
same own name of the expression and this
is done by actually using C++
polymorphic lenders to generate the
expression note so I will just show you
that and so it still not complete I
still have to write to work on the how
to actually add semantic to the stuff
but the idea is this one
okay where is it so just a blue cat but
going on so we have we have an
expression class okay so it's a bit
rough the idea is that we have an
expression class that contains a tree as
a type like night before but this tree
is actually not another expression
another classes which is recursive
Oliver it's actually and I think we saw
it there the tree is actually a lambda
and what does Islam the dots well it
takes a visitor as a parameter and the
visitor will be applied on what the
resin lambda contain okay and all it is
this lambda build so this is a bit off
okay this is basically what happened
there so I have a bunch of types values
i want to put as the children of my
expression and what I do is I built this
lambda their tree which is taking a
visitor v and what does it do when
whenever you passively talk to my lambda
i called my visitor function cooperator
on what on a value which is a tag of the
expression i'm currently building plus
minus extra and all the children of this
that get captures x value automatically
okay and I just build an expert of type
of these three these three okay so what
I say that sub tree is no more than a
closure that will accept the visitor
which is coming from the transform when
I go down to three and at every level of
this I know where I'm I am because I
cause visitor with my tag so the visitor
knows what's going on okay it may it may
not care about my time but if it does in
know where where and I can match on them
and surprisingly it was by surprisingly
i mean really surprisingly and one
interesting point is this is a kind of
type you get I know if it is it but why
I don't have anymore ok so do them I is
a zoom okay for the text or not maybe I
can actually probably get better five
seconds okay oh well where is it look at
that that that's the output I just build
an expression and I print the type name
okay using Domingo okay and that's
compiled with visual studio 2050 which
suppresses 14 supports so exactly
comprised on reserves to you so I have
an expert look at that I'm an expert
that contain what a lambda of this type
lambda and the scroll aaf 19 rubber blog
which is probably a ash or something can
I actually get everything just in case
we may need agree so this lambda and the
score 42 characters which probably Sasha
one or or some other ash that's
basically the type automatically
generated by the compiler for the lambda
and good news everyone on user studio is
a fixed size idea of identifiers the
first one is a plus B the second one
same time is a plus B plus a plus B and
so on and the third one is a + b + a + b
+ a + b + h + b and the last one is that
again which itself so it's like about 16
symbols and it stays the same size
roughly 40 characters or something okay
well it's not dimmable I mean well
that's very beginning when I am a bug
somewhere inside the lambda you got
message like okay I cannot find this
angie's in lambda 1 2 3 4 5 6 okay great
so don't do birds looking hot choking so
I think that Georgie Guzman newest I
think at the exact same idea for spirit
tree and discarded it because of the
difficulty of debugging I'm still
thinking that the benefits outweigh the
risk because we basically get constant
time computation time with effective the
complexity of the three yes I want to
drink in that so that's sucked through
on msvc on the other compilers you still
carries is the name of the function the
lambda was built into into the name so
it's a bit longer and if you do the
tricks on Jesus your can you see that
the symbol names grow linearly but by
probably eight or ten characters at the
time instead of the huge mess you get
with the regular one so I still think
that as GCC and claim combined fascist
and wizards to do one in the others is
basically as fast as if on both sides
now I don't know if there is anybody
from GCC are playing there or we watched
video please to whatever msec does when
they named their lambdas please thank
you so that probably the best idea the
visual studio implementers add on this
point it's a very very interesting
techniques and the other funky stuff is
that we also find a way to say okay now
I know if I need to copy or not so by
default this library take everything x
value my reference sorry except when is
he knows he's dangerous and so what we
did is a natural that I I actually have
to st. Louis for that because I was
swamp it by a lot of time in this so
what we do is this kind of thing so when
should i store a sub expression as value
or not well if the stuff you give me is
a value that probably means that is
lifetime is bigger than the lifetime of
the expression so i will just take a
reference to it and if not
if it's ever you i will save it into a
value by doing a copy oh well sorry by
doing a move assignment or something so
that was the storage type t does i mean
if i were you i just decay everything if
not i'm keeping it as a reference except
there is a problem you have no way when
you define a lambda to select for each
captures which one will be stored in
your world another I think that's fix it
in 17 or something but it's still
limited so what we do is it's like pool
win over you you cannot go to the or
directly so you do a band you know so
what we do is we build a lender that
captures everything by reference this a
right stop stop and inside you build a
regular structure that uses storage
types on the types of whatever its
capture okay to decide all to store it
and you just forward the value to it and
this lambda just returned a new node and
much you return is an expression
containing this node so you have a land
are building the small scale structures
from either inside that as access to
everything from outside by the capture
which means that if not in his own type
there is no template site something
there that's where the magic is there is
no relationship between the node name
and the whatever contents of the time
and what I learned is this evening that
you can actually put the strap them
inside and other locally inside the
function I didn't know the answer so you
do this and you can actually change
whatever you do this so you can do for
one you can do it for two or you can do
it for three and so on and you can when
you have too much you can just put
everything into a top pole and sleep on
it okay and you can forward precisely
everything the way you want into each
sub element of three and so how does
this I will screw myself by computing
something in the temporary in the
function and i will get dining reference
get solved it yet solved
where we call which is natural where is
a function okay that's that's a very
rough example but this is what we were
doing there is a let's say that track is
something that is costly to do okay
that's our local value that may contain
you pointed something well if you want
it to be copied into your tree you just
move it inside which is something which
is looked like something makes sense in
the language itself even if R is not if
it was not expression template okay have
something there I want to move it into
the outside I don't want to copy because
I knew it we die okay so just use move
whenever you make sense so it doesn't
have to rely on the knowledge of what is
going on into the expression template
system if I put this there but I just
move it and if we do what you want to do
okay and you don't move it who blows up
so just move it so the only limitation
of that is that you have X and you want
to put it twice into the same
expressions you cannot move it twice so
you probably want to make a copy first
and copy the other one or something like
this but that's the only I mean weak
points we found of these techniques and
the rest just walks perfectly just copy
if you want to copy and move you want to
move and everything is logical as if it
was regular cool and so the example
actually do this Lucy so i have f of
copy F of F F of F of F and so on and we
take care about almost move and copy
with us and actually we do the exact
amount of movie and no copies each time
so we know that we did the correct so
we're still working on that all right
somewhere on github on my on my account
it's not complete yet but trying to get
something done with this I got rough
computation time numbers it's far better
up to two to three times faster there
are still some kruky cases where it just
blow ups but it looks nice so probably
more than later sober let's go radical
what if you can actually change your
language is so
to make sense to write excellent embrace
us as a first-class citizens so if you
look at other languages like template
ask you know me talk mo there are two
functional language with sort of support
for introspection the average concept of
code fragment a code fragment is a piece
of code enviable okay and you can create
some you can build the bigger one by
concatenating those code fragment and
when you are p with it you can just bang
it and you get the value okay so that's
the example I got there with the that's
metal chemo so I just beat the code
containing one plus two and the type of
this is a code returning in the end so
that's this dot bracket stuff that do
this you have a dot T let's say that
could piece of code and expanded inside
another one okay so you can combine
piece of code and when you don't Doug
bang it takes a fragment of the code and
just compile it and get you the result
at one time okay so the idea is can I
actually do something like this in C++
and does it make sense okay actually and
how can we do that properly that's
that's not problem I don't know how to
do this volunteers were calmed the other
idea is that we have size of we have
data type what about adding an iced tea
off taking a bitoni expression and give
you three and do something with it but
the problem is all do you want to use
that to pass the lazy version of an
expression to a function without having
to write f of iced tea off and that
quickly escalate into all that means
that I need to write f of lazy tea or
some stuff exists and you start to be
ugly okay so that's that's not that
trivial matter so let's conclude that so
what is a deposit okay so why did we not
actually so expedient templates we can
actually write the main so main stuff we
have to remember is that we are not only
there for performances that's a side
effect we use expression templates to
build intentional code with cold clarity
as as a first goal okay
we saw that if you really want it you
can actually write a very small scale
and made extra 10 / 10 join for very
very limited scope and if not you have
tools like booth Prado that actually
simplify such needham by providing all
the boiler plates already there and we
have some gotchas especially with
automatic deductions and move semantics
you have to be careful which probably
means that the tools us to be updated
like what we said so what to do so you
are designing a library that's the main
first point and see if your design of
your library can actually be turning to
the designer for language more than the
library and if yes then you can actually
play with education template as a way to
increase so-called intentionality that's
very important the library should be as
intuitive as possible and expression
templates LP you doing this and then
actually you can rely on to like go
stroller or staff can actually see you
can actually I mean proto is called
further because it f you do prototypes
okay so prototypes is in provo see what
kind of feelings you want to give to
your library and then fine tune it and
it doesn't work just complain to your
fabric compiler vandals okay so that's
what we want to do we want to be I mean
we have to actually template that as a
technique as to move from oyin that
these tough people does when they end or
bigger race okay know that not just that
it's the only way we have to be
libraries with an eye level of
intentionality that Steve give us the
opportunity to get cross function or
cross expression optimization at a very
high level because we have everything
under the eyes and we can take the
decision about what is important at this
level of optimization so that's what we
really want to do so as a crossing point
I want to sense a lot of people so join
the Guzman which is probably the one guy
that brought this lambda DSN stuff first
before me I don't remember but I
remember discussing it with it at some
point Louis for fixing my crappy
implementation of the same concept every
KIBRA for booze Prado which is actually
a great piece of code
a and urban pr4 for the kanji what we
work on 40 35 so thank you for attention
I I offer i didn't eat too much people
okay but don't say I can't eat ten
percent of the audience or probably okay
if you have any question gladdie answers
and thanks again for your attention yes
okay so the question is I also chose
between using boots Prado and doing the
old fashioned way by doing it by n what
should be the choice when should I chose
from experience I would say as soon as
you have let's say a decent set of
functional operators like more than
three or four I don't know very very
small numbers you really don't want to
get all the boiler placed on that very
time consuming and you will get it wrong
so as soon as you need a large selection
of operators functions with Frodo it
just it just everything just they're so
cool stuff with boot photos that you can
also prototype quickly something that
getting any of the grammar of random
stuff just play with the syntax look
watch this expression tree looks like so
you can see if you can actually manage
to process it easily and when you are
set on your sin tax and grammar where I
so you finish the work with booze Prado
then you know what you should be putting
into your end fashion stuff we had a
situation with recursive not recursively
we're currently sorry with eric is that
okay I deserve that I could have been
doing the other way around yeah but you
know that you could do it now because
you played with the stuff so sometimes
you just pray with Frodo and you know in
what I call the immediate mode just
right stuff with operators and see
what's going on and when you know
exactly what your language should look
like and what these logical for
transformation is just write it by
but sometimes is so much easier than say
okay I would just keep proto because I
need a special semantics I need to have
mutiple transforms that do this and that
I need to regenerate 23 from a tree from
a tree and so on and don't really want
to do this by n so is there you have a
very small amount of stuff or the
transform is very trivial and then you
do it by N or and if not I will just say
go with this problem or whatever similar
tools but you you need to be able to say
something like well now I know what to
do and and playing with loose Prado is
often enough because just right with the
stuff and you see okay I should be doing
this disease because like the trees this
way this way and I can't process it but
I mean we we are living with booze Prado
in alpha dozen of rivalry and we are
just now slowly moving to you know
removing proto and doing it by hand
because we know where the spot out now
but it took us years to do this because
you're just there walking come by ten
was ok so just let it there was a
question ok so these are free to go I
guess thank you again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>