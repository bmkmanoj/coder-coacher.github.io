<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2014: Jason Lucas &quot;Polymorphism with Unions&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2014: Jason Lucas &quot;Polymorphism with Unions&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2014: Jason Lucas &quot;Polymorphism with Unions&quot;</b></h2><h5 class="post__date">2014-10-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uii2AfiMA0o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is actually a surprisingly good
turnout for polymorphic unions at nine
o'clock in the morning on the
second-to-last day of the conference so
that's that's our topic today so I'm not
my name is Jason Lucas and I'm not a
real big fan of slides so we're just
going to be looking at code this is kind
of a Cody subject so we're just going to
do it that way
so what we have here is a fairly simple
short class hierarchy describing
two-dimensional shapes I don't think
there's anything here that requires all
that much explanation its structure but
no behavior so you're very much as where
objects light if we want to add various
behaviors we can look at doing that the
C++ wave that is to say we will put some
pure virtual functions in the base class
and and start filling things in the
algorithm spread either anyon throughout
the entire code base when we add virtual
functions everybody breaks until we fill
them all in your dips will sprawl over
all the files in which these are
implemented which should be separate one
would think it's hard to see the
parallel isms and implementations
between the various places are your
filling things in if you have
intermediate classes in the hierarchy
between the most derived ones and the
least derived which this does not those
are going to group your behaviors in
ways that are great for some of your
virtual functions and maybe not so great
for some of your other virtual functions
and that's just the way it rolls but on
the good side the hierarchy remains
open-ended even across API boundaries
so if we
want to add more classes or more you
know more bits and pieces we're free to
do that we want to add more virtual
functions however we can't right then
we're gonna have to recompile so so far
what it sounds like I'm telling you is
this this is the visitor pattern which
should be familiar by now if only
because of the number of people who have
spoken out with great hatred for it
so visitor groups your concerns together
so you know we have only one virtual
function which is the visitor acceptor
and then all of the algorithms group
their bits together so they behave more
like type switches your diffs are
definitely more focused so this is nice
we can work on individual algorithms
we've got a team of people you can have
people working on structural changes
which will require updates to all the
algorithms but at least the compiler can
tell you and when you're people working
on the algorithms they pretty much work
in silos the grouping of the leaf
classes the most derived classes can
vary from algorithm to algorithm
behavior can change so that's nice we're
not locked into the hierarchy in any
particular way and the hierarchy is
sealed we can't extend it across API
boundaries but we can add algorithms so
this is the opposite we can extend the
behaviors but we can't extend the types
and the other kind of annoying thing
about visitor is either you have to
declare everything in an extremely
specific order if you notice here we go
the area the visitor is for declared and
then all the finals are declared and
then we can define the visitor and then
we can define the visitor acceptors and
then we can define the algorithms or if
you're not the move to do that you can
just sort of jumble it up in which case
everybody knows about everybody else and
you have poor isolation and those are
kind of your two choices and either way
there's a lot of boilerplate code here
it's not particularly easy to read so
yep variant we go back to our where we
were with the first version we've got
nothing behavioral in structures
themselves and then we after we define
all of these finals we decide those guys
collectively are a shape variant
collects them post hoc into shape and
then we can define our behaviors like
this looks a lot like visitor without
the visitor so it's much more terse the
algorithms have the advantage of being
able to group the members of the Union
any way you like just like visitor
except we now we can use generosity to
actually group them together into single
handlers which would be harder to do the
other way we're using overloaded lambdas
here instead of explicit visitors so
it's nice and terse and it's kind of
nice that the right function can just be
easy insertion operator well I think
that's kind of nice so I wanted to start
with this example before we backed off
into more abstract discussion of what
visitor what variants are so now that
you've seen it let me get a little more
abstract about so boost says that a
variant is a type safe generic stack
based container offering a simple
solution for manipulating an object from
heterogeneous types in a uniform manner
whereas standard containers such as
standard vector may be thought of as
multi value a single type variant is
multi type single value so I don't know
why we have the rest of this hour to
talk that pretty much sums it up
the we'll put this another way the
number of states a data structure can be
in it depends on what it's got inside of
it and in the case of Union the number
of states a Union can be n is equal to
the sum of the states that its members
can be in as opposed to a struct where
the number of states is equal to the
product of the states that its members
can be in so if you talk to formal
language people they'll refer to this as
a sum type as opposed to a product type
then they will talk to you about Haskell
and you should sprint away so this will
go by many names you're gonna hear it
described as discriminated unions tagged
unions some types variants it's
sometimes just lumped in with general
type eurasia which it is this is not a
new idea
Alexandra skew kind of brought this to
the public for back in 2002 and dr.
Dobbs with an article series of articles
about discriminated unions Friedman and
manaan contributed the boost variant to
the boost library at about the same time
shortly thereafter and if you google for
discriminated unions or variants or any
of those terms you're gonna find lots
and lots of implementations still it
hasn't got a whole lot of traction why
I'm actually asking
Oh
hmm how interesting
um maybe but we have I mean C++ you know
revolves around its its class hierarchy
so saying that C++ doesn't have this
kind of polymorphism it's true but C was
suppose that's polymorphism and and what
I'd like to demonstrate today is that a
union is actually a class hierarchy
collapsed into a value type it's exactly
the same polymorphic behavior it's just
nicer in some respects to work with
there's a know what I think has been an
issue has been that the boost
implementation was suffering from having
been written in 2003 when we didn't have
a bunch of language features that we
didn't have Lando's we didn't have our
value semantics we didn't our rate
references rather we didn't have very
otic templates basically you know trying
to do this with the 98 standard was like
going to the moon with stone knives and
bearskins so the boost one also made
another choice which is something called
the never empty guarantee the if we have
this union of circle and triangle and
square what happens if we default
construct well that depends on who you
ask what is the correct thing to do
Alexandra skews implementation would
default construct an instance of
whatever the first type was otherwise
known as surprise
it's unclear what the correct thing to
do is it's also therefore unclear what
to do when you have a moved out variant
if I move from a variant to another one
what am I left with
so the implementation that I'm going to
show you today which was written by me
and my colleague here Michael Park wave
there's Mike
we decided that they never no guarantee
never empty guarantee is nice sometimes
and sometimes it's a pain so what we did
was say that the variant if it includes
a null type and it's list then it's
allowed to be null if it doesn't then
it's not so and we have some enable if
you do in the definition so that certain
things are not there if it's not allowed
to be no so it won't default construct
wake up okay well better
it won't default construct it doesn't
have a reset method if it can be now
than it has operator bool cast to find
so you can test it for an illness in
other words if it can be no then it
behaves almost exactly the same as a
pointer to a base class and you do
everything you normally do with it
except that it's a value type so the
code that we're going to show you today
is on github feel free to go there and
play with it I don't think what you have
today is as it stands a strong candidate
for the standard library but I kind of
hope that the standard library will have
a variant and if you like some of the
semantics of this one then we can talk
about maybe moving this this thing
towards some kind of a standard so I
want to take a little bit of time and
walk through how this is actually
implemented because I think demystifying
these kinds of type erasure containers
is a worthwhile thing
so in this case okay future-proofing
pulling some stuff that's going to be
this way shortly anyway and that this
compiler just doesn't happen to do it's
not very interesting anybody need to go
over the stuff yeah if you see something
on the screen then you're not sure what
it is just put your hand in there
alright so here's where we get into the
thing this is the type that we use to
say if this is included in the list of
parameters for the variant then this is
a nullable variant we actually had null
pointer T here I'm I still kind of think
maybe it should be no pointer to Mike
doesn't so he got the last edit on this
file so he won yes we are secretly using
the visitor pattern it's really not a
secret you should have been able to see
that but the visitors being defined with
very attics with a recursive pattern
here again this isn't totally surprising
and then this is overload overloaded
macro or overloaded lambda rather which
oh did I skip it okay where are you
this is actually a little harder
position than I was hoping for so this
is overloaded lambda did you know you
could inherit from my enough and even a
very adequate of lendeth so the result
is a function object with operator
operator paren friend defined for all
these overloads and then if we then have
a dispatcher that can bridge us from
variants pure virtual dispatch to one of
these things we're golden and that's
basically what we're about to do
so variant itself okay so a little bit
of preamble a little bit of I'll show
you so if we can the question is if we
can do overloaded lambda why do we need
the visitor the short answer is we have
erased the type so we're going to need
to do a runtime type check to know what
to do but you'll see it's a little more
clear in a minute so yep which one oh
yeah I guess so I'm afraid I'm gonna
have navigation problems without it let
me see how it goes I can turn it off
and the code is actually on github so
right like right this second so if you
just go to github calm Jason Nell 9,000
CPP 14 or CPP con 14 you'll see
everything you can just follow along
anyway so there int is a very attic
template it has a little bit of preamble
stuff going on here for deciding a few
things some basic stuff like a union if
nothing is not fair don't do that to me
define our visitor and then you'll see
here the default constructor is
available if we have known in our list
otherwise it's not and then you'll see
the actual trick and I'm not going to
get too much into this if you're really
interested go read Alexander rescues
articles because he spent three issues
going through this in extremely hairy
detail but the basic idea is we're going
to create a poor-man's virtual table so
that's what this tag data structure is
and this is the when we talk about a
tagged Union
we mean that the union has some kind of
piece of data following it around that
says what's currently in it and in our
case well the way we do that is with an
instance of come on this data structure
so it's a data structure full of
pointers to functions in other words
it's a V table so the constructor
functions that we use for it get tag is
templatized get tagged as a static
constant a constant instance of it and
just fills it up with some lambdas that
do our work for us there's also the null
version which doesn't actually do very
much and then here is our tag and here
is our storage so all we have is a blob
of bytes that is big enough to hold the
largest thing and aligned to whatever
the strictest alignment is in the set of
types and then if you look inside of
they these guys they work with that to
do whatever needs to be done after going
through the virtual dispatch to get this
far so this is where the type of ratio
kicks in or the onion ratio in this case
the type real and these guys are used to
force the blob of bytes to behave as
whatever type the tag discovered they
really work so you can go through here
it's probably exactly as you expect at
this point the destructor for grant
hands off to the destructor here the
copy for variant hands-off to the copy
here all of that stuff so at that point
we're kind of done with variant the rest
of this is all of the stuff and this is
one I'm not going to get too terribly
into because it is a little bit more
template magicky how to define this
visitor for us automatically that will
dispatch from the virtual entry points
to whatever the functor object has that
matches us for an overload magic going
on I'm happy to sit with anybody later
after the talk that would like to know
more about exactly how this part of it
works but the practical part that you
need to understand or would be useful to
understand is that when we accept a
visitor where is it tempted come on all
right and get type in to accept your
people of that and all right
there it is when we accept a visitor we
asked the tag to do our accepting for us
we pass the information through once
we're inside a tag we have the right
information to dispatch to the correct
overload of operator primp ran in the
visitor object which is a pure virtual
and then it jumps into that big
complicated applier thing which hands
off to the functor object which is the
overloaded lambda so there's a lot of
extra dispatch going on we're going to
talk about performance later as I just
heard everyone in this room think out
loud so any questions about the variant
before we move on the actual
implementation oh good I knew that was
gonna be simple so why would you do this
so I have a few things I would like to
talk into today variants can be more
flexible than hierarchies variants can
be easier to maintain than hierarchies a
variant with a null state is like a
superset of optional variants can do
dispatch tricks that you simply cannot
do almost any other way in C++ and it
gets you out of a lot of complicated
situations a few of which I talked about
so getting back to the top of those
variants more flexible than Americas we
talked about how intermediate classes in
the high bumps are good
so the question is when we're defining
behaviors if someone comes along and
adds something to the Union which means
the Union type is changing do all of the
the behaviors break or do we have to can
we handle the addition separately and
the answer is it depends what I'm about
to show you is that you can go back to
generics inside your handlers so that
you can get multiple kinds of dispatch
going on within a behavior so that you
might be agnostic about a lot of changes
to the union's membership if it's not
then you get an error that says
something along the lines of this case
isn't handled here so it's not a
terrible error and it's essentially the
same error as I can't instantiate this
object because because there is a pure
virtual in it so you're not actually any
worse off this way I think then you have
at least a chance to do better
now they can be convertible to each
other that's what I'm about to explain
so I talked earlier about the idea of if
you have intermediate classes in your
hierarchy by the way I woke up today
with a cold this is a little rough
please excuse my voice the the groupings
of the intermediate classes might work
well for certain behaviors and not so
good for other behaviors one of the ways
in which class hierarchies are
classically brittle is that they're
designed around some set of behaviors
and then new behaviors come and it's
just not well laid out for them or and
this happened to me while I was working
on MSI L and Microsoft we had two
perfectly good ways to layout the class
hierarchy depending on which set of
functions were your favorite so if you
have that situation you choose one or
the other it's almost always the wrong
thing to do you should really choose
neither of them or both of them but
favoring one over the other for no
particular reason just will eventually
bite you the problem is when you need to
do that you need to now talk about
virtual inheritance and establishing
diamonds in order to not favor one over
the other and that just gets horrible so
dispatch goes down in terms of
efficiency and it becomes hard to
maintain you can't do complicated
constructors very easily it's just a
mess so in this case what you can do is
in your overloaded lambda you can choose
to use generics or possibly even
concepts to group your handlers such
that they will handle the members of the
Union differently for example
so we have some simple ones and here I'm
suggesting that these are actually on
separate header files because this would
be the way you would roll in a large
project so that you could work on your
finals as separate modules their own
unit tests all of their stuff belongs to
them and they don't know anything about
each other so we've got dog
we've got cat leave that verse and then
we decide to make animal animal depends
on them and then creates the Union and
we could add behaviors now about how we
like to group virtual behaviors out of
animals so animals all make sounds
animals all interact with people how we
group these classes to do that would
depend so we might have like we want to
deal with the dog and the cat together
as house pets and the horse separately
for some things because it's big we
might want to group the dog and the
horse together for some things because
we like them and the cat separately
because we don't like the cat so the
individual algorithm decides how it
wants to handle things by creating its
own generic projections at that point
okay so this is that was what I meant by
variance can be more flexible than
hierarchies variance can be easier to
maintain than hierarchies as I said you
build all your final types first just
like this they don't know about each
other they don't share concerns your
designs flow from the specific to the
general instead of the other way around
right when you're designing a class
hierarchy you start with this most
general thing and you start drilling
down to the specifics and you might know
that would know very much about the
general when you start and you may
change your mind later about what the
generalities really are and kind of like
jacking up the entire class hierarchy
isn't any fun
we're talking about sorry well templates
are great so we can use abstract lambda
we can use a generic lambda rather so
for example the the mechanism the
question is about how to use the
mechanism of the lambda to do the
groupings so the simplest case is use
Auto basically you'd written default if
you do have hierarchy you know
membership they can be nothing but tags
right the type is transparently
convertible into a group you can add it
later it does nothing it doesn't hurt
you and then you can transfer you can
behave off of those if you wish you can
also well it's also possible to use SMA
if we look up something in the dependent
scope and then we will either specialize
or not
so our instantiate or non rather sorry
but that was that's a little trickier
I'm not sure you would do that for
example if you're super interested in
job security well that's why concepts
are coming so we can do stuff like this
and it does we've tried that it does
work pretty well so easier to maintain
working from the thank you working from
the from the specific to the general
also grounds your initial work in the
problem space most of the time right dog
cat and horse are things we can compare
them to real things in the real problem
space and decide if this is a good
representation of a dog or a cat or a
horse and then when we move toward the
abstract we move toward the abstract we
do it by collection it's it's better
better match for the way human brains
generally work by cognitive clustering
it's also possible to do this so here we
have car and plane and horse and we
collect them into transport the same
same idea except that's the same horse
so this is the equivalent of multiple
inheritance without the possibility of
the class hierarchies poisoning each
other right nothing is leaking back and
forth the horse is horse of course
design the whole talk are on that line
in in either case and it would be
possible even to do a transfer from one
and this is something we'll show you
possibly later if you have time
it's a run time type check to move from
one variant family to another if they
have states it in common if you're
moving from a subset to a superset it's
not even a runtime type check that's
just okay if they don't have states in
common then it's a static error because
it's clear that that assignment that
know would never make sense so it's much
easier to work with these guys where a
horse or whatever your final types are
being reused in various groupings than
to try to figure out how to make virtual
based classes work properly in multiple
inheritance I think so I've said a
couple of times that if you use the null
state this behaves the semantics are
virtually identical to carrying around a
base pointer into the class hierarchy so
if I can have car or plane or a horse or
nothing
then I'm actually it's like this is
transport star and you just have to have
one additional Handler and all your
algorithms for the null case
you can also check for the null
explicitly because we added methods to
the interface of variant that only show
up when null is there the difference is
this is a value type so you're not
carrying around a base pointer you're
not doing a heap allocation right you're
not in general doing anything that's
involving and directing it's a value
type it just has the semantics of a base
pointer so if we have this possibly
nothing state then the simplest case is
we have something or nothing so we could
have a template of a variant where
variant is T or nothing which would be
optional it has basically all the same
semantics is optional it's just a little
bit more general so we could be a T or
ru or nothing for example in the case
where we are bool or nothing then we are
actually tri-state booth where you can
interpret the nothing as I don't know
for example and we could overload and an
or and not to give you tri-state logic
that works across this perfectly well
and because we know null isn't the same
null across all the different unions
then we could do comparisons that give
rise to tri-state pools that just work
and so for example if we're using
optional int that's the same as a
database nullable field so we pull in
someone's age from the database maybe we
don't know it we get optional int or int
or nothing and then we compare it to
some number we get optional bool and we
can then do that with an and of some
other comparison where we get another
optional bool and it all just sort of
percolates up and it just works and then
of course when you actually try to use
that and if for a while you get their
own type but at the top you have to
check what it really is
the boost version of variant explicitly
doesn't do this they said if you want to
be no you should define your annul I I
didn't really like that very much I
think having a single definition of null
enables what I just described with the
contagiousness of null when you're doing
operations across multiple nullable
types another interesting point here by
the way is if we replace null with an
exception pointer so it's T or exception
pointer then this is another Alexander s
Q special expects so we can implement
expects as a variant and it just works
I generally think it would be better to
implement these guys as variants rather
than reimplemented type erasure behavior
over and over so on to the next trick
so let's go back to our shape example I
like shape I want to function takes two
shapes returns bool true or false do
these two shapes intersect
can anybody immediately see why this
problem sucks uh-huh yeah so
intersecting a circle with the circle is
easy or a circle with a square or a
circle with a triangle or a square with
a triangle or as long as you know what
both of them are we know what to do but
we have to know what both of them are
being polymorphic on one of the shapes
still leaves us with the damn shape that
we don't man we don't know what it is so
this in general is the multi method
problem and there are a handful of
languages that solve this tidally for
you Oh camel cielos end of list
I think C++ and not so much
this is one of the prettiest things I've
ever seen so you can dispatch
multi-method on variance so we will be
polymorphic on more than one thing
instead of having this you have an array
of these and we will work out what all
of the types are of all of these before
we dispatch to the correct Handler and
this is another case where you can
collapse you can generally collapse a
lot of cases because intersecting left
circle with right square is the same as
intersecting right circle with left
square that cast off so you don't
actually wind up N squared most of the
time but it's nice that you can and the
entire algorithm is right in front of
you all of the dispatch machinery is
just locked away inside of a variant and
you never have to see it so I just kind
of like to soak that one in for a minute
because I think it's beautiful
no I'm glad you asked the question is
are we limited to two era T - no you
know as far as you want in practice I
already one common already two common
and then there is a sharp decline and
let me explain this whole thing comes up
because I'm a compiler guy and when I'm
trying to figure out the type of an
infix operation and I need to know the
type it's based on the types of both
sides
he's one of these it's so good the
number of ternary operators in C is
small and the dependence of the output
type actually doesn't care about the
first one so we're hard-pressed to
actually come up with a true ternary
operator where all three types matter
possible there are cases I bet but one
thing that would be interesting to note
here is this is shape shape you don't
actually have to be homogeneously
multi-method if you need to take your
animal for a ride we need to know about
your transport and your animal at the
same time so this is Mike's example I
think it's really cute any of these
cases we have problems of course won't
fit in the car we can't put the animal
in the plane putting a horse on a horse
is dumb and that's possible because
horses in both right and everything else
is fine and the auto just eats the other
cases I think that's really sexy so this
this code uses c++ 14 require c++ xiv
for a very small number of things we
could do without
in particular when we're doing the apply
inside of the the applier the thing that
inherits from the visitor and does the
dispatch we use tupple apply in order to
unwind to the thing which uses the trick
where we're going to expand a parameter
pack of integer indices so you know the
the index sequence stuff that's in 14
but you can write that in 11 it just
didn't make it into the standard library
just like we're using some 17 things in
this head etre in this header you know
you could we could make this whole thing
work with 11 very easily I just mmm
yeah but the way this works there are a
few cases where you might not want to
use overloaded lambda anyway where you
have a functor object that does more
stuff that entry point is actually still
here
so if you just want to define our own
functor and fly or if you really want to
use your own visitor you can't but
dispatches the same times so one one
cautionary note about multi dispatch
this is not the fastest horse in the
plane you are going through multiple
levels of dispatch in order to unwind
this operation as we discover what type
is on the left we cache a reference to
it discover the next one cache a
reference to it build up a couple of
references to everything and then
eventually push it through it's a lot of
steps so in general this kind of
dispatch is no faster than half as fast
as a virtual function and in general is
somewhat worse than that however if you
turn on like full buggy optimization
whole program optimization D
virtualizing in a lot of cases we know
what these types are so the first level
of divert realization goes away or the
first level of a virtual function goes
away so it's not horrible this is not
what you would do in the tightest of
loops where you have extremely tight
performance considerations
all right so when do we do all this
stuff why would we use it and so I've
ever tried to create a pure virtual
templatized function boy that would be
nice when of course we can't do that
because the vtable needs to be a finite
size so the trick is that we use a
virtual function but we pass unions
variants or we we return variants or
both so we solve the generousity first
all right by taking whatever the type is
stuffing it into something that makes it
homogeneous and then we dispatch
polymorphically on that and on the other
side we visited with a functor so you
can for example create meta access
functions for your data structures to
say like I want to access a field by
name at runtime like the cool kids over
in Java town you can do that we don't
know what the type of the field is so
we'll have to return you some kind of a
union we can take a regular container
and turn it into a generic container by
having a contain unions for example
what's the difference between a vector
of unions or a tuple
ordering so what's the difference
between a map of string to Union and
struct
thank you yeah so speed you the the
tupple and the struct our results
statically we're going to resolve some
things dynamically in the case of the
containers full of unions but you get
you know something a little closer what
a scripting language can do it's not
always what you want to do you know
where C++ where systems programming
language but it's nice to be able to do
script D things without having to bleed
out the eyes for it
like everything else we do in C++ so in
this case for example if I have a config
file I can read in my config file very
straightforwardly make a dictionary and
mapping of named values to unions of
their possible actual States and just
fly with it all right so these are it's
really handy for processing things from
the outside world it's also handy when
you're going over a string based
interface and string based API like a
rest interface because we're going to
parse a bunch of stuff find out what the
types are and stuff it all away into
some kind of container that associate
associate some values with their names
and dispatch it into a handler that will
worry about it all later so this is
handy in general you can do this
anywhere you want to do type aeration
anywhere you would use any any is I
would go say I would say any as more
than type erasure any is type
obliteration any is almost a void star
so I think of Union as please step away
from the void star think about it decide
what your finite universe of types
really is and then use a union instead
of just leaving the entire universe open
with any now there are a few cases where
you really do have an infinite universe
of types by all means use any
but most of the time you know so I think
variant deserves more love I think it's
a good model for future proofing your
code because when we make the changes in
17 or 20 where the build model will
change and we'll be able to do whole
program compilation and things like
partial classes then this jazz becomes
real vtable
right because I can take tech switches
and as I reassemble the whole program I
can put all the pieces together and make
one big retail level so right now this
cost you extra dispatch right now this
is convenience to the programmer that
cost you runtime when we change the
build model that might not be the case
anymore so it's alright I'm done
it makes your projects easier to design
easier to maintain it does sophisticated
tricks like multi method while remaining
very terse and very readable our
implementation is certainly not the only
possible one but it's short and I think
it's we wrote it so that it was actually
be comprehensible it's by which I mean
it's not written like anything in boost
okay I'm done I'm not gonna be mean to
boost down that need to be backward
compatible to the universe and portable
and everything it's just like makes code
really hard to read I think this isn't
like that so even if this particular
implementation is purely a teaching
experience and you guys go implement
your own and until the standard one
comes out I still think it's a useful
idea so anybody that's kind of it
questions
github jason el 9000 / CPP con 14 on the
on the performance issue if I I knew it
if I implement a a sort of variant based
design and I discover that you know I'm
doing I I wind up having you know a
multi dispatch inside the a hot loop or
something like that do I have any sort
of localized options for improving the
performance of that without tearing
apart my my whole design uh yeah you can
fall back to what we do with any which
is go fish there's a try as interface on
variant thank you where you can say like
well if this one actually is a strength
that I'm just gonna NAB it and go off
and do stuff so if you can early resolve
the type there's another thing to the
lambdas don't have to be short and by
short I don't mean lexically short I
mean their stacks don't have to be short
so once you resolve what the type is you
can then go jump into a whole separate
module whole separate library that just
deals with dog or just deals with horse
and the virtual dispatch is over right
the other thing we're not showing here
is it doesn't have to be a constant
reference you can have a mutating
visitor so that's really comes up when
you do have long lives visitation so and
at that point you really absolutely no
worse off than any other technique you
paid the price exactly once Thanks yes
sir
aha
so boost it uses a separate type for
recursive Marines sort of the poster
child for this is expression so infix is
a kind of expression and expression is a
union of a bunch of other things
including in fix and in fix has two
expressions in it left child right job
so we solve this by going back just
recognizing that the union with a
nullable in it is the same as a base
pointer so what we aggregate in in fix
is pointer to expression pointer to
expression right and we can have a
forward declaration of expression at
that point that we finalize eventually
with the Union so exactly the same thing
you would do if it weren't Union yeah we
do in fact so my my backups live if I
had slides here's an entire language
interpreter written with yeah simple
calculator written with a union for
values and union for expressions and it
actually works so and it's actually
pretty short considering yeah well I
didn't have as much time before this
conference as I thought I was going to
huh I try to remember to go in and
comment things and so I leave nag
messages for myself so for example
sir yeah I have a question if is it
possible to start by type I mean I
wanted to deal with all the dogs at once
in order at once in order yes so you can
define for example a strict week
ordering operator like less than on
variant and then decide that all dogs
come before all cats come before all
horses and then among dogs you sort by
breed or whatever so you can you can
impose all kinds of collective behavior
thank you are there you need to speak up
a little
the question is are there tag index
unions instead of type index unions I
don't know what I'm not sure I
understand
at construction time if they have a
default constructor it would be possible
to do that the problem is I need some
state to copy or steal to initialize the
variant so if you create a dog as an
r-value reference I can move it and then
it's my variant dog if you just say I
want a dog by name then I need some kind
of a factory so we could build a factory
pattern around this as well it would
just be something that sits on top it
wouldn't really change this at all I can
talk to you about it afterward if you
like anybody else I think okay
the question is whether it works like
pattern matching and is therefore not
order dependent it is not order
dependent it works like pattern matching
wasn't in the wrong position we were
showing that you can do multi method
dispatch across heterogeneous sets of
variants transports right it was kind of
a you know not very meaningful example
per se but if the point was they can be
different only horse the example right
because horse lived in both unions so it
you can't violate the type rules it is
still strictly typeset
hmm you can actually mix inheritance and
unions it's it's doable the point is
sometimes you're going to do inheritance
for classification for behavior and
sometimes you're going to do it for
construction of the type basically it's
a form of aggregation so you're going to
stick things in but not be them for the
purpose of an algorithm that's fine you
can you can certainly do that and then
those bases later you could match on if
you wanted to with the with an
overloaded lambda but you could overlook
you could do the overloaded lambda on
anything that would be statically
discernibly different about the type
absolutely so for example though the
right like I want to stream this variant
out the simplest case right you just
have a single auto that whatever it is I
shove it onto an out stream and it's
fine right because they all they all
provide their own overloads for doing
that but then you could also use binding
strength rules and say well in general
I'm going to output them this way but if
this is dog I'm going to do it some
other way right so you have the option
to break out of the default behavior any
way you want
like it's no faster than one half as
fast as a virtual function and some of
my examples actually we're going it is
slower than a virtual function is
between half as and in some of my cases
one-sixth as fast as a virtual function
but it's not a hundred times slower than
a virtual function it's not a different
world of badness it's okay
and actually I'm not even sure why that
six happened I believe we were messing
around with some of the performance
testing and it was kind of jittery so
these are not numbers that I necessarily
stand by but we are close to not quite
as bad as half as good
the intermediate applier data structures
are tiny you're pushing stack frames in
order to resolve resolve resolve so
you've got stack frame size and you've
got a little intermediate object that's
done as a local it's not very much I
think we're officially out of time thank
you all for coming I hope you play
around with variant and feel free to
grab me a few questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>