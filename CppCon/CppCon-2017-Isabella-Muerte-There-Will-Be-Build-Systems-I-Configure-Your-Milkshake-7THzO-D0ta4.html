<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Isabella Muerte “There Will Be Build Systems: I Configure Your Milkshake” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Isabella Muerte “There Will Be Build Systems: I Configure Your Milkshake” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Isabella Muerte “There Will Be Build Systems: I Configure Your Milkshake”</b></h2><h5 class="post__date">2017-10-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7THzO-D0ta4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Alright, lets get buck wild.
I just want to set some
audience boundaries real quick.
Leave all corrections,
comments, any questions you have
til the end of the talk.
If you have one, note the slide number
in the bottom right corner.
Very large number, you can't miss it.
You can also tweet your question to me
with the hashtag #123GottaCPP.
And I'll just look for that tag afterward
so if you have like questions that
we couldn't get to, feel free.
And this is also for anyone
watching this at YouTube
at home so you can actually
tweet at me long after
this talk has been done and I'll try
to answer your question if I can.
Some more boundaries.
Any question I ask is
going to be rhetorical.
Don't answer them.
Don't interrupt me to correct me either,
this is a common thing that happens
at CPPCon where someone says,
&quot;Well actually, I want to
be pedantic right now.&quot;
Don't do that, because if Git and
the Texas Board of Education
can rewrite history, so can I.
And for the viewers at
home, if you could please
take your hand off of your face.
Don't take weird dutch angled screenshots
of your monitor while you're watching this
and tweet them to me.
Don't take pictures of your favorite candy
and tweet them to me.
And don't build a digital
altar to chorizo in VR
and send me a itch.io
link to that or a picture.
And definitely don't do any of this stuff
while listening to Rage
Against the Machine.
So just a quick overview.
I'm not gonna rant about build systems.
There's almost no code,
absolutely no graphs.
So if you're here for like
this hard crunching numbers,
you're in the wrong place.
Build systems are a lot like
the best weapon from Turok 2,
they're a cerebral bore.
And so this is not a talk
about how to use modules,
every existing C++ build system
because I don't want to be here
until the heat death of the universe.
It's not about which build system is best
because they're all garbage.
And every build system not
written by me is garbage,
you can quote me on that.
Several recurring themes in this talk.
There's this thing I like to call
the Project Layout Ouroboros, which
is a snake eating its own tail.
I'm also gonna mention how
build systems are affecting
the design of C++ and how that's
not how it should be going.
And we're gonna talk
about the sweet treats,
the milkshake if you will,
of other language ecosystems.
We're gonna hit a huge
number of subjects though,
there's a lot of intersectional stuff
that comes into being with this stuff.
So some opinions or
options might be skipped
so I can't really get to everything
because this is like a
two and a half hour talk
that I had to condense
down to like an hour.
Generating discussion is more important
and also I'm not gonna
rant about build systems.
(It's Always Sunny In
Philadelphia theme music)
(record scratch)
Alright so who in the Sam Hell am I?
Hello, I'm Izzy Muerte.
I'm a C++ Bruja.
I'm a build system trash goblin.
A little bit about me, I'm self-taught.
I care a lot about build systems.
A lot about build systems because
I taught myself to program
by writing a build system.
I don't recommend that you do this.
You will be punished for
your own hubris if you do.
I like burritos a lot.
Just a lil tidbit.
Anime was a mistake.
And I watch it all the time.
So that's my Twitter, that's my github,
and this talk is really
about build systems.
Hail Satan.
Alright so a little bit of history.
In the beginning there was Make.
There was other stuff
too, but there was Make.
Right?
And it was...eh, fine.
But if you used the original Make,
you're like, &quot;Oh no, this was cool,
why did this get upgraded over the years.&quot;
And the problem with modern
Make, there's quite a few,
it's which one are you using?
Because there's GNU Make, there's NMake,
and by N Make I could mean AT&amp;amp;T's NMake,
I could mean Microsoft's NMake,
I could mean Nokia's old NMake,
there's a lot of companies that like to
name their thing NMake
and I don't know why.
This complexity of Make files,
because our builds get complex
and you wanna do things and Make
is just a simple task run
with commands it's checking.
It always leads to these configure scripts
so you end up having to write
and maintain two systems.
No one is satisfied with just Make
and eventually everyone tries
to reinvent it, eventually.
You've probably like see like Cake
and Bake and Yake, or whatever,
something ending with an A-K-E, right?
And 99% of the time they fail miserably.
That other 1% by the way is Ninja.
And it's like, &quot;I'm not Make,
I'm my own original build system, Blake.&quot;
How embarrassing.
So Make's biggest problem?
Tabs, obviously. Duh.
It's like every episode of
Mobile Fighter G Gundam.
A mistake.
My shell is calm, this build
system of mine is burning red.
Shiny Make file.
So Make's actual biggest problem
is that it assumes and expects
a C style compilation model
because it was written
for those types of tools
back in the sixties?
Seventies? I don't know.
I was born in '89, I'm
way younger than that.
And so tools are written
to be used with Make
and they mimic this
approach and it's usually
a huge detriment to the tool itself.
So lets get into the
current C++ build ecosystem
because this is, there's a lot here.
So there's all the Make replacements.
Ninja, Scons, Bazel, Buck, Shake,
which is written in Haskell and
uses Haskell definition files.
So if you don't know Haskell,
you're not gonna have a fun time.
But it can execute Ninja files.
There's also a Wu-Tang build
system that's being worked on
but I will never reveal
the Wu-Tang secret.
So there's meta build systems.
CMake, we all know CMake, there's Meson,
which is actually the least terrible,
and, actually I was
mid-tweet before this talk
about how I was gonna talk
about how build systems are bad
and the author of that responded
with, &quot;Challenge Accepted,&quot;
so that's gonna be a
fun conversation later.
There's PreMake, which was written in Lua,
so we're not gonna talk about it at all.
And there's Autotools.
Autotools, the Mitch
McConnell of build systems.
(audience laughs)
That man is a turtle
wearing a human skin suit.
Alright, so like the problem with
these meta build systems that we have
is that they're typically undebuggable.
They have this domain specific language,
that's what DSL stands for by the way,
if you're not familiar with that TLA.
And TLA is a three letter acronym
for &quot;Three Letter Acronym.&quot;
They assume you know
what you're doing and,
lets be honest, you don't.
And they're filled with
esotericism and black magic,
which is fine if you're a witch like me.
But if you are one, you're
not gonna work in tech
and you're certainly
not gonna touch CMake.
And so the typical meta
build system experience
can be summed up I think with this image.
Building intensifies.
But then eventually we all
learn to accept our fate, right?
And we're just kinda,
Call for help, you know, whatever.
So just a quick overview
about package managers.
This talk isn't about package managers.
That is a nightmare I don't
want to talk about yet.
But we've got Conan, they've been here.
They gave a couple talks, I think.
They've, you know,
they're fairly well known.
Spawned from biicode, rest in piece.
I like anything that uses B's or hexagons.
As you can tell from my mass of tattoos.
And there's Hunter, which is Cmake-based
and that has a majority of upgrade issues
because if you want to upgrade Hunter
you have to go through
all of your dependencies
that are using Hunter
and upgrade it and, like,
I've heard some people say,
&quot;You know what would solve this?
Is if we had a package
manager for CMake scripts,&quot;
and that sounds like the
worst idea in the world.
There's also build2s, b package.
I didn't mention build2 earlier because
it is also a package manager system.
The author, which is
here for the conference,
and I've spoken with him face to face
so I feel like really intimidated
about shitting on his work.
However, I think he
does some things wrong.
But that's because every build system
does some things wrong, and
we'll get into that in a bit.
So the Project Layout Ouroboros,
I mentioned this at the
beginning of the talk.
So I'll just give you an example.
So you've written a build system.
And it's good, it can build things.
Because a lot of build systems
out there can't build things.
It's very strange.
And it's like, congratulations,
that's really hard.
It's difficult, I've done it, twice.
And I regret the decision both times.
But you have a great change
of making a movie titled
&quot;Steve Buscemi's Antifa Rodeo.&quot;
Bash the fash my fellow cowpokes.
And so you want to tell the world, right?
I'm gonna post this on the C++ subreddit.
What's the worst that can happen?
Careful, Icarus, because
the first comment reads,
I'm actually gonna have to
look at the computer for this
because it's gonna be a lot of text.
&quot;It doesn't support my
current project layout.
I won't use it unless it does.
Also, why is it written in language?
Why isn't it written in
a different language?
Seems like a waste of an opportunity
to get more people to work on it.
There doesn't seem to be more than one
developer working on it either.&quot;
Because you've been working
on this on the weekends
and, y'know, when you have spare time.
&quot;What assurance do I have
that you won't drop support
for this build system if
something better comes along,
or if you have a kid, or get a new job,
or just get tired or you die?&quot;
That's one thing that
people never talk about
with opensource, like
what happens when you die?
What happens to the
copyright of that project?
Not part of this talk, just
wanna put that out there.
&quot;This tool is bad and you should feel bad.
Everything you've ever done is garbage.
No one will use this tool because
no one is already using this tool.
And you need users to get a
build system off the ground
and you can't stop CMake
because the community
has chosen it as the best
build system out of necessity,
not because CMake is good but
because everyone uses CMake
so you should just give up now.&quot;
I do briefly want to
state, this is paraphrased
from a bunch of comments that people made
when Meson was first announced
on the C++ subreddit.
&quot;9/11 was an inside job.
Obama turned my frogs gay.&quot;
And this is someone who's never
going to use your build system anyway.
So it's like three days have gone by,
you're depressed, it's on the
fifth page of the subreddit.
Imposter syndrome is
setting in, you're like,
&quot;Oh my god I'm a fraud.
Why did I spend so much time on this?&quot;
This is a thing that happens;
you put a project out,
people shit on it, and then you
feel like garbage afterward.
Unless you're like, you have
a huge ego and you're like,
&quot;Nah, I got this.&quot;
But then you notice someone
made a second comment.
Because they're ready to troll you
but they also want to give
constructive feedback.
&quot;Bounced on my boy's build system to this.
11/7 will use again.&quot;
This is posted by
xXx420LoneWolfBuilder69xXx.
But this is good news, right?
Someone used your build
system and they aren't you.
You're Tron now, you're
fighting for the users.
So you're like, I need more users.
You don't want to just have one user
for the rest of your
life, that's just weird.
So you redesign your build system
for existing project layouts.
Careful, Icarus.
You just committed the
cardinal sin of design of
engineering, be it software or otherwise,
architecture, everything,
anything that involves design.
Because the function of your build system
follows the form of existing projects.
I don't know why this is not working now,
but it was working earlier.
Your build system needs to
be like the baseball field
in the movie &quot;Field of Dreams.&quot;
I'm gonna say this right now,
every build system, you
need to treat it as if,
if it's good enough, people
will use your build system.
Don't, I don't know how
to pronounce the word
because I've only ever
seen it written down,
I'm one of those people.
Kowtow? Kowtow?
- [Audience Member] Yep.
- Thank you.
So don't kowtow to their demands
if it's like you're
sacrificing the form of this.
I'll give more examples
of this later in the talk.
So we've covered the basis
of like what that is.
Because this is the
Project Layout Ouroboros,
you need to support
existing project layouts,
so you have to support
every project layout,
which means your build
system has to be able to
build every possible thing, which means
if you write a new build system,
you have to support every
possible project layout,
which means we're just in this
endless loop of just hell.
And so build systems also
reflect our work flow.
They effect how we get stuff done.
Chandler Carruth actually made
an interesting comment last night
when we were all kind of talking
in the hotel and he said,
&quot;When my engineers get
a better build system,
it doesn't improve their performance,
like getting stuff done but
there's a small implicit thing,&quot;
because this is something that people
like to apply to a lot of things.
It's not, &quot;this is how it is,&quot; like
every developer team will work like this.
It's, for Google, using a
newer or simpler build system
is probably a detriment to their needs.
Because Google makes billions
of dollars every year.
And I doubt that everyone
here works at a company
that makes as much money as they do
or uses as much data as they do
or has a monolithic repository
as large as they do.
What our build systems do
is effect our workflow.
And our projects, right?
Because if our build system says
you can put your stuff anywhere,
then you're gonna put your stuff anywhere.
You'll put it like three
or four directories in,
you'll have source,
then inside of that you'll have project,
then inside of that you'll throw
all the .h and .cpp files because
you're using Qt and you're also a monster.
But there's some language features
that build systems don't take advantage of
or they prevent us from
taking advantage of.
And one of these is extern template.
So it was added in C++11.
It existed as an extension between GCC,
which was a studio for years.
By the time Clang came around it was like
this was already added to the standard
so it didn't really matter.
It had been voted in in like,
I think, '07, maybe even earlier.
Someone can fact check me, I don't care.
It's extremely useful when used correctly.
And it's really hard to use it correctly
because the whole point
of extern template,
which I'll show, is that it prevents you
from instantiating the template
every time there's a template.
And it's basically a way
to help the linker speed up
and it's super useful for LTO or LTCG,
whichever link time whole
program optimization
thing that you use.
Oh, I put that in as a bullet point,
apparently, and I forgot.
But it's fairly advanced, right?
Like it has a very specific use
and it's super limited in
what you can do with it.
And it's also not publicly
used or discussed much.
Like, I went on github, which is like,
that's like the Facebook of
opensource code at this point,
and I just did a search
for extern template
all as one string because they've
kinda fixed the search engine, finally.
Or you can search for, you
know, multiple words in a row.
And the only projects
that used extern template
were either small weekend projects
that had been abandoned five years ago,
which meant that a little after 2011
that person would have gotten
access to a compiler
that supported C++ 11,
and tried it out and was like,
&quot;Okay cool. I guess that's useful,&quot;
and then moved on with their life.
Or it was just like a
project with one star
that hadn't been touched in three years.
I didn't see any big name
C++ projects using extern template.
And some people have been like,
&quot;Well, we actually tried that out
and we didn't find a
useful performance boost.&quot;
But it's actually mostly for optimization.
The most important thing is
that in our current ecosystem,
because models aren't here,
is that they're best used
with precompiled headers.
Everybody loves
precompiled headers, right?
No?
Okay.
So they're not part of the standard,
they're never gonna be
part of the standard.
Bjarne would probably like flip
a frickin table and
just be like, &quot;Get out.&quot;
But it's supported by the
compilers that matter,
you know, Visual Studio, ACC, Clang,
I think Intel's compiler supports it.
It's extremely useful
when it's used correctly.
And it's poorly understood
and also not perfect,
but it's not great for every organization.
By organization I mean every company.
If you have a huge code base where
you're constantly
modifying O level libraries
that everything depends on,
yeah probably not a good idea.
But if you're using third party binaries
or libraries that you're
not gonna touch often,
probably use a precompiled header.
The problem is that no
build system uses them
or supports them correctly.
None of them do.
All the big ones I mentioned earlier?
None of them support this stuff correctly.
Meson gets kinda close
but it doesn't support
more than one PCH.
And no build system lets you
choose when to include them.
Meson force includes it into
every file in your project.
You're probably like, &quot;Wait a minute.
Why would I ever want more than one PCH?&quot;
Well, you get better organization
of third party libraries.
Sqlite3 is one of my favorite libraries.
It's small, it's
condensed, it's two files.
But those two files are an
almost two megabyte header file.
And a like four or six megabyte C file.
I'm probably wrong with these
numbers but they're huge.
And if you're not using Clang,
you're gonna choke on that header.
And every time you have
to include that header,
it's more cost.
So if you want to just
precompile sqlite3, great.
And do you really want to have
it available in every header?
Because what's happening is,
if I want to use sqlite3,
I have to put it in my precompiled header
for the project where I'm also gonna put,
probably at least, a vector
and string and memory
and all the other single library stuff
that I'm going to be using.
Do I really want that to
be available everywhere?
No, that's dumb, right?
You want it only inside of your CPP files,
not inside of every header.
So a smart build system
can also technically
generate your PCHs for
subprojects or dependencies.
But that is a super advanced thing
and we don't even have our build systems
able to do that in the first place,
so I'm not going to give you an example.
We'll never know.
You know it's like the old
Tootsie Pop commercials.
How many PCHs does it take to get
to the root of the Tootsie Pop?
Three. We'll never know, y'know?
So, I'll just give a quick example of it.
This is the only code you're going to see
in the entire talk.
So we've got file.cxx and, oh
that's very small, I'm sorry.
But there's a reason for it.
It's because when you do extern template,
you can't rely on what the actual
declaration that you're using is.
I need typedefs, I need template aliases.
It basically says, &quot;No, you have to
write this out the whole way,&quot;
which if you're using stuff
like meta template programming,
and you're using it as like
conditional inside of a class,
you have to write it out
for each possible instance.
This could be better, but no
one wants to make it better.
And, honestly, people
don't use it that much
in the first place.
Maybe if our build systems
get better they will,
then we can improve this.
But in file2, we physically
instantiate this template.
So inside of file.cxx, this
is for std string by the way,
in file.cxx, I say I'm going
to be using std string.
It's able to still check to make sure
everything's kosher with
its like command line,
sorry, with it's command line,
with its function parameters
and the types of scenarios like that,
but it doesn't actually generate
any code in that C++ file.
It's going to create a bunch
of stub functions that say,
&quot;We don't know where this is.&quot;
This is actually a more efficient way
of doing inline functions, effectively.
What you're saying is, instead of saying,
&quot;Here's ten inline functions
that are all the same,
link or choose one and
order this the best way,&quot;
you're explicitly stating, to
the linker and the compiler,
&quot;This is the one instance
that we want to use.&quot;
And you do that by just removing &quot;extern&quot;
from the front of the class.
And this generates every
possible member function
inside of this .o file.
So if you're doing this
for DLL, maybe don't do it.
But if you're doing it for
static library, super useful.
If you place the extern template thing
over and over and over,
it gets really exhausting.
And putting it in just a
header isn't really useful.
So we're gonna place this into a PCH.
So inside our PCH, we've got
the good ol header guard.
Pragma once in there so that
people that complain about,
&quot;Oh pragma once is
faster,&quot; can just shut up.
We include a bunch of
standard headers including
ciso646 because in this
the year of our Goku 2017,
Visual Studio still does not permit
&quot;and&quot;, &quot;or&quot;, and &quot;not&quot;
as keywords by default.
And they're defined in that header,
which is technically against the standard.
I'm not bitter.
And then we have our extern template here.
And we precompiled this,
like we have a pch.cxx file,
and we've placed the template
class substantiation there.
This works perfectly
fine for Visual Studio,
where you need to include
your PCH into a C++ file
so that it actually compiles it.
And if you're using Clang or GCC,
your code base doesn't really change
because if you're using
GCC, Clang, and MSVC,
you're get the same
behavior, more or less,
on its command line parameters
between all of them.
Your precompiled header, your
.o file, everything's good.
Problem is, if you want to start adding,
oh, did it die on me?
There we go.
The problem, is that our build system
has forced every file to depend on our PCH
because no build system lets
us choose when to include them,
which I mentioned earlier.
And any changes that we
make to add extern templates
require changing this file.
So if we want to improve our linker times,
we have to modify this PCH.
And we're constantly
recompiling everything.
We cannot make multiple PCHs,
where we can say we
only want to instantiate
these templates here or here or here.
And so control has been
taken away from us.
And if there's one thing
that C++ programmers hate
it's being told what to do.
There's a reason I was playing
Rage Against the Machine
before this talk started.
And extern templates, and
this one PCH approach,
is a huge pain to use
so we don't use either.
So I'm gonna just switch
targets real quick
because I also just want to, remember,
there's a lot of stuff here
and I need to get you all
caught up to speed on, like,
a lot of these problems.
So we're gonna get started with C++.
You've got a brand new machine,
or you're coming from
another programming language,
and you wanna get started with C++.
Or maybe you've been writing C++ at work,
you're on C++ 03, you don't
really use it at home much,
and then you're like, &quot;I wanna
learn these new features.&quot;
So this is the hill I'm going to die on.
The massive fragmented ecosystem is
what makes C++ a so-called
&quot;expert's language.&quot;
This causes more pain and suffering
than the actual language itself,
I will argue and die on a hill for.
Because there are seven year
olds writing and using C++.
Sara Chipps is here at the conference
and she's giving, I think she may have
already given a talk on Jewelbots.
Tomorrow, thank you.
So there's a talk tomorrow
talking about Jewelbots,
which she made for kids so they
could learn how to program
and they're children.
And they are writing C++, using C++,
and, very recently, I saw some of them
giving a presentation on C++.
So whenever I see comments on Reddit
of like, &quot;C++ and I don't
get it,&quot; I get concerned.
But it's because their
ecosystem, these kids,
their ecosystem is taken care of for them.
Like, they don't have to worry about
what compiler they're using.
They don't have to worry about the IDE.
They don't have to know
anything about Make files
or CMake or any of that garbage
that just pollutes everything.
So, here's an example.
Lets get started with Haskell.
Alright, I don't know
Haskell, I don't care.
But to get started with it, you
download the latest version,
you install it, and you
can start writing Haskell,
right then and there.
And if you need to use
stack, you can use stack,
it used to be Cabal, I guess?
Again, don't know, to compile your code.
I did a quick Google search and
this is how I found this at home.
And you can use it to
manage your dependencies.
So lets get started with Rust,
everybody knows Rust, right?
There's Rust programmers here too.
Rust is what made me
want to write this talk.
It made me depressed after this happened.
You download the latest version,
with their tool called rustup,
you install it, this is
all in one step by the way,
and you start writing Rust.
And then you use cargo to build your code
and manage your dependencies.
So lets get started with Python,
which is a dynamic programming language,
it's gotta be different,
different steps, surely.
You download the latest version,
install it, start writing Python,
and then use setuptools
to compile your code.
Ah, it's different,
because they also have pip
to manage the dependencies, but setuptools
is actually just a library that pip uses.
Lets get started with Node.
I think you all know where
this is going, right?
You download the latest version,
you install it, start writing Javascript,
or, if you just want to write Javascript,
you open your web browser,
and you start writing Javascript.
They do have a bit of
a fragmentation issue
at the moment though, because you
use npm to compile your code.
I say compile because the
browser does it for you.
But I guess you can also use
yarn or bower, webpack I think?
I don't do frontend development,
I don't know any of
this shit, I don't care.
But lets just go with npm because
having a default is better
than having nothing.
So lets get started with an
international standard language:
Ruby.
Did you know it was international
standard? Probably not.
You download the latest version,
install it, start writing Ruby.
And you use gem to compile your code.
And manage your dependencies.
I'm a broken human being
when I see these slides.
Like I got really sad as I wrote them,
I had to take a break for a few days,
from writing these slides
because I was like,
&quot;Holy crap, it's worse
than I even imagined.&quot;
Because you all know what's coming.
Every single person in this room
is here because they write C++.
And for you, the viewer at home,
maybe you don't write C++, but if you do,
you know what's coming.
I see you.
Get your hand off of your
face, I already told you.
You can't stop this, like
this talk has to continue.
We can't just go like,
&quot;Welp, that's it I'm out.&quot;
You can all leave, but I have to stay here
and go through this.
Lets get started with C++.
What compiler do you want?
Sorry, excuse me, what
operating system are you on?
Lets assume that you're on
the most popular operating system.
Haiku, I'm kidding, Windows.
Because that's the most common one
and, while many of us might be,
&quot;Well I got my start with Linux or Mac,&quot;
most people are on Windows.
And many people that are coming from
a lower social or economic state,
are probably going to be using Windows
because that's what
everything frickin comes with.
They can't afford Macs and
they don't know what Linux is
or how to install it.
So what compiler do you want?
Well, if you spoke to Chandler Carruth,
or anyone else really,
I would honestly say
start with Clang, right?
So Clang for Windows has a
problem because, to use it,
you have to have Visual Studio installed.
And if you don't know how
to install Visual Studio,
you're gonna have a rough time.
The Clang install is really easy;
you double click it, it installs.
Simple.
Visual Studio, you have to
sit there and wait for it.
You have to choose between three editions,
community, enterprise, or
professional, not in that order,
by the way, for the cost
of each of their skews
or whatever they're calling it over there.
There's also a secret hidden fourth one,
which just says &quot;buildtools.&quot;
That one's my favorite one because
it doesn't install all the other garbage
like .net or the javascript stuff.
I don't care about any of that.
So we're gonna go with GCC.
Well GCC on Windows is
also a desecrated land
of just, like, pain and suffering.
So we've got the STL distribution,
from Stephan T. Lavavej from Microsoft,
he runs it all on his website.
That one's the best, but it
comes with a lot of stuff.
And if you get used to that stuff,
you're not gonna be able to
move to other environments.
There's also the problem of course that
his choice of error handling
and threads affects it.
There's TDM-GCC, which
is always out of date.
I put sometimes; it's
always been out of date.
I went back and used
the web archive thing.
And then there's also a zip file and
some random personal directory
for the mingw64 project,
and you're like three
or four directories deep
until you find this thing.
And then when you get there,
you're presented with some options.
What exception handling do you want?
Do you want structured exception handling,
which is what visual studio uses
that GCC was able to reverse engineer.
But then Clang had to
also implement their own
implementation because they don't
have the GPL code in LLVM.
Or do you want to have sjlj?
Sjlj, by the way, does not stand for
Social Justice Lich Jezebel.
That was a stretch of a joke
and I searched for hours on Google
to find a word that could end with J.
But we're gonna go with SEH, lets say.
Sjlj, by the way, is setjump/longjump.
So basically, x86 style
exceptions on Windows 64 bit.
What threading API do you want
because there's Win32, POSIX,
which is POSIX-tively as good as this pun.
(audience laughs)
And so the problem is that
if you use POSIX, right,
it's gonna be slower because
POSIX is a wrapper on Windows.
And if you use Win32, you can't
use things like std future
because they didn't implement it.
I'm not gonna implement it, screw that.
But all these decisions affect
how your Clang install will go
because, when you install this,
if you chose the wrong options,
Clang won't build
because libstdc++ will
have options disabled.
Or its error handling will work
a different way than is expected.
So you're gonna have to recompile Clang.
We haven't asked what standard library,
which, it's gonna be libc++, right?
I hope you aren't gonna be using
Clang with libstdc++ on Windows.
You're asking for trouble there.
So you're like, well what build
system do you want to use?
Well you go and you ask on Reddit,
and you're like, &quot;What build system
can I use for this stuff?&quot;
and someone says CMake,
and the comment underneath it that says,
&quot;Hahahahaha.&quot;
(audience laughs)
Because you asked, &quot;Is there
something like harder for C++?&quot;
So lets get into it.
So you install CMake and you're trying to
learn the CMake scripting language.
Now I'm aware, yes, you
could be using command line
and compiling like one file at a time
but at some point you're going to
have to use a build system.
So you start learning the
CMake scripting language.
A few hours have gone by.
I'm sorry, what language
are we working with again?
Because this is like four slides in
and all the other ones
were just one slide.
And this is a colossal
frickin' disappointment.
This upsets me.
Because these other languages
are drinking our milkshake.
This is the whole pun
the talk is built around.
Because if someone said,
&quot;Hey, I've been writing dynamic
programming languages for a while,
I want to get into systems programming.&quot;
I would not say, &quot;Well,
get started with C++.&quot;
I'd say, &quot;Go use Rust because you're
going to have a much easier time
and also if you ever
decide to move over to C++
you'll understand our values
and moves, more or less, and RAII.&quot;
I don't know how to pronounce,
&quot;rye&quot; does not work for me,
because that's a bread.
However, Haskell is not
drinking our milkshake
because they're obsessed
with burritos for some reason.
Monads aren't a burrito. They're a sandwich.
But C++'s complexity is further compounded
by every tool that distracts
you from writing C++.
If you're new to C++, you
shouldn't have to know
the command line flags for a linker.
You shouldn't have to know
the command line flags
for your compiler, especially
because you're like,
&quot;I don't even know what this means.&quot;
And doing it copy/paste
saying, &quot;Don't worry about it,&quot;
doesn't always work
because when you look at it
and you get an error and you're like,
&quot;Why did this happen?&quot; and
then you have to go ask someone
and they're like,
&quot;Oh you used the wrong
command line options.&quot;
And you're like, &quot;But I was
told not to worry about that.&quot;
And I did hear someone say
something about an IDE.
IDEs are great if you're
targeting one platform.
But most of us, if not all of us,
are writing cross-platform C++.
So a machine that squeezes bags of juice
gets more time, money,
development, and news
than any of our tools.
Juicera just closed down and they had,
like, what, $400,000,000 in funding?
God can you imagine what we
could have done with that money?
Instead of selling it to a bunch of
rich Silicon Valley-ites,
or whatever you want to call
people that live in Silicon Valley.
Nerds.
But no one cares how
the sausage gets made,
what's in it, and if it's even edible.
We're told to accept the state of things
and focus on what really matters.
If you went to your boss and you're like,
&quot;I want to write a better
build system for C++,&quot;
they'd tell you to shut up
and get back to work, right?
And what your work is is to
stay late to fix the build
instead of maintaining
a work-life balance.
&quot;Sorry honey, I can't come home
even though it's 3 AM. CMake's acting up.&quot;
&quot;What in God's name is Cmake?&quot;
&quot;The reason I'm not home
at 3 in the morning.
And it's also why I drink.&quot;
So instead of fixing the build system,
we're expected to fix the build.
But how can we fix the build
if we can't fix the build system?
It's the Sunk Cost Fallacy.
Our build tools are missing
the mark by a wide margin.
This is the mood of the talk here.
Lets hit the mark.
Fix the build systems.
So modules.
Everyone's excited for modules, right?
This is not a rhetorical question.
(audience cheers and groans)
Okay, so if people on YouTube can't hear,
there was like a groan of
disappointment across the thing.
That's probably because you know
that you've been, as you've
been looking at the models,
you've just been like,
&quot;Uhhhhhh, wait a minute.&quot;
And we're gonna be talking about
modules as they are in the Modules TS.
They are a game changer,
they change a lot of things.
But not in the way that most people think.
They're not a pan-see-uh. Panacea?
I was gonna make that cross itself out
and say, &quot;Panera Bread&quot;
because I literally
have never heard that
said out loud before.
And it's like, why?
Why are these not out?
Well the build order is not
automatic or well defined.
Yet, I had to put a &quot;yet&quot;
there after I asked Gabby
that question on the girl
committee where I was like.
We have to manually define the build order
with the current limitation
of modules that are out there.
And his response was, &quot;Well we'll make
the build systems understand that.&quot;
And then didn't elaborate on it because
Jean Paul said two sentences only.
But also there's no
hierarchy for these modules.
And that's a huge problem.
Python, guess what, there's a hierarchy.
Rust, hierarchy.
Notice how I'm not saying &quot;hierarchical&quot;
because it's really hard to say that
multiple times in a sentence.
Haskell, hierarchy.
They didn't used to be, someone
told me that they were not
in 1998 but it's 2017;
that was 19 years ago.
Ruby, hierarchy, sort of.
C++? Shrug emote.
YOLO.
You only link once.
So let me give you just a brief example.
By the way, I lied, there's
more code, I forgot.
So, this is not valid syntax
what I'm about to show
because you can't actually
save modules multiple times.
But you'll notice these are
the five modules that
Visual Studio gives you.
Filesystem, threading,
memory, regex, core.
Core is literally everything that
is not mentioned in these previous four,
which seems like a lot, right?
And you're like, okay, std.filesystem.
Std.core, I'm coming from other languages
and the dot is used as
a separator, of course!
I know what I'll do to get all of this,
I'll import std.
There is no std module!
Everything you know is a lie.
You flew too close to the sun, Icarus.
Hahahahahahahahaha.
Okay but really.
Project Layout Ouroboros
is responsible for this.
This is how build systems
have affected C++.
And, as a result, that's going
to affect our build systems.
Projects have these numerous
file layouts, right?
Which means modules have to be
quick and painless, more or less.
So modules can't enforce a hierarchy,
filesystem or otherwise.
Even just like in a name spacing manor.
And, yes, I'm using name space here
but not in the sense of C++.
So build systems have to
support all project layouts
which means build systems can't
assume anything about a module's location.
Which means modules are only for improving
compile times and not reducing file count
because, if anyone's
been paying attention,
you actually have to
have an interface module
and then you can have your
actual instantiation module.
Scott kind of spoke, Scott's
right here by the way,
I'm pointing to him.
He gave a talk on Monday
about the stuff at EA
and it was like, mmm not good.
Oh no.
I should've checked the sizing here.
Anyways, modules won't
break the Ouroboros.
But we do have this rare
window of opportunity
where we can fix our current build system
so that this won't be an issue later on.
So we can fix the way
we interact with them.
We can change how our build
systems understand C++.
But it requires radical changes
to our workflow and tools.
And I'm not talking about
a 360 Indy Nosebone off your Makefiles.
I was really hoping people were
actually gonna laugh at that joke
because I spent a lot of time
crafting that, I'm sorry.
I'm just disappointed.
What else is new?
So we need to change the status quo.
And the first way we do this
is with data over directives.
This is really important;
if there's anything
you take away from this talk, and
you are a build system
implementer, please do this.
Build systems are designed
by programmers, right?
I would be very concerned if one wasn't
designed by a programmer and
it was designed by marketing.
So as a result of this, because
programmers like to program,
they make it so that our
build systems have to program.
And we get these domain
specific languages,
some which they're trying to complete,
which makes no sense to me because
why does my build system need a wild loop?
Why?
It doesn't.
And our build system file
consist of us directing
build run time to do fairly simple tasks.
Take this list of files.
Put this through the C++ compiler
or the generator or whatever it is.
There's no reason we can't
give the build system
metadata and then rely
on directory layouts.
&quot;Where is your include files?&quot;
&quot;They're in a directory named 'Include'.&quot;
I would hope that that makes sense, right?
&quot;Where are your source files?&quot;
&quot;They're in a directory named 'source'.&quot;
Oh, well there's this problem
about globbing and whatnot
but even then json, yaml, toml,
which is the least worse of those three.
You can have lists in those.
You don't have to manually
specify with a set call
and then set that as a variable
for another function call.
There's no reason for this.
Rust cargo does this really well.
Of course, they have a module system
that's got hierarchy and also
the whole thing is treated as
one massive translation unit
but I digress.
And if they need any conditional logic,
they just put it inside
an actual Rust program.
You may say that that sounds terrifying.
I mean, downloading someone else's code
and then I'm running it.
Yeah, you should be auditing
your packages though.
Well the best thing about this
is that even though it's
not the best approach,
and they know this because
you can't do post-build steps,
you can at least debug your build.
&quot;Oh, this build is failing, why?&quot;
Well, lets run it under the debugger.
Oh, we're missing an
environment variable, whoops.
Perfectly fine.
And some people are probably going to say
don't do that with C++,
it's a terrible idea
because if you do it's like, well,
are you saying that because C++ is bad
and it has problems, to
which some people will say
yes, obviously.
But I think it's more of
because there's no ecosystem
existing already to do that.
But you can use an actual debugger.
Like you're not using Python's debugger
to like hook into Python and then
not actually get a good debugger.
But using data definitions
over a domain specific language
allows better tooling because
if it has a specification
it means I can write a tool
that's not connected to your stuff at all.
If you have a metadata
layout that's documented,
I can parse these build files,
I can do whatever the
heck I want with them.
Oh, we need asm files?
Great, I'll run this script that
automatically adds them to this file.
Now I don't have to open up
a file to start editing it.
And we don't end up with
these walled gardens anymore!
If you use CMake, you have to use CMake.
Calling out to other build systems
is a huge pain in the ass.
Because if you've ever
used internal project add,
you know that it's
better to put that inside
of a separate CMake file
and then run Cmake-p?
Dash e? Someone help me out here.
Dash s? I don't know.
But you run it as a separate script
so it downloads everything first
and then builds it and then
your actual CMake gets run.
It's a two-step process.
We're late? Shit. 15 minutes.
So information about a
build can be extracted
without needing the build itself to run.
This would also make
inventing better tools
and switching to them a whole lot easier
if you actually had an upgrade path.
So this is a small suggestion,
I feel like skipping it honestly.
But basically, build systems
want us to list stuff out.
Some permit globbing, that's bad.
It's very divisive though.
List directories at the most, right?
The idea is simple.
Every OS directory works the same.
When an item in the directory is updated,
the directory's timestamp is also updated.
So it doesn't walk up the tree recursively
because that would be a bad idea.
So we use a non-recursive
glob in a directory.
Check if the file names are the same.
We don't actually have to check to see
if the contents are the same,
we just to hatch like a list of files.
If they are, then you just
build the changed files.
If they don't match, then
regenerate the build.
What about performance?
Yes, scanning directories can be slow,
especially if you have
like 100,000 of them,
but why would you do that?
Don't scan a directory if its
timestamp is unchanged, first.
And also, which is slower,
editing a file that adds several files
to the list and saving it or
letting a tool do that as part of its run
for like, n plus five seconds.
No build system currently does the latter.
I'd love to see some numbers, but y'know.
Globbing ends up with a
lot of these &quot;what ifs&quot;.
What if we have 100,000
files in our directory?
What if we use 10 different
file extensions for headers?
What if we add and remove a bunch of files
in our directory a lot?
Why are you doing these things?
Don't prevent corner cases.
When people act weird,
I'm like don't suck then
because you get these &quot;what ifs.&quot;
What if a user pulls in a
bunch of whitespace changes?
What if the user touches every
file in our build directory?
What if we use it as a monolith repository
for millions of millions of files?
If they have that, they
probably have a compiler team
to deal with that shit.
And then there's that.
It's like a slippery slope, right?
Scons uses MD5 hashes of a file content
to see if they've changed.
That's super slow.
Like what cost?
Correctness means nothing
if speed is sacrificed.
But they're protecting against
incorrect timestamp changes.
Can't fool that.
But this leads to more &quot;what ifs.&quot;
And you start doubting everything.
Wait, if my files timestamps
have been compromised
then what if my compiler's
been compromised?
Trust in trust.
What if your meta build
system has been compromised?
Wouldn't be hard, have you ever looked
at the script files for CMake?
What if you system make, or
ninja, has been compromised?
What if you docker
container's been compromised?
And it starts to escalate.
What if the CIA is planning to kidnap you?
As you fly to Auckland
from LAX on December 4th.
What if Ted Cruz really
is the Zodiac Killer?
Oh shit.
So what if someone does
have a corner case, right?
If your user interface isn't
that great, make a better UI.
They need to organize
their code? Change nothing.
A small hack, once given,
cannot be taken back.
Your build system does not have to
adapt to someone else's worldview.
This is how we get
Project Layout Ouroboros.
And just because something exists
doesn't mean they have to use it,
which happens a lot in
opensource when someone's like,
&quot;You need to make this change,&quot;
and you're like I don't
want to and they're like,
&quot;How dare you sir. This
free tool you've given me.
I demand more from you.&quot;
It's ridiculous.
These are the questions you need to ask.
Will this corner case require
form to come before function?
Will this enforce the Ouroboros?
You don't want to be part
of the problem, trust me.
Will this improve existing users.
Not potential converts,
people that don't exist yet.
Will it improve their quality of life?
And does it reduce the
workflow overhead of users?
So daemons, we're
actually gonna skip this.
It isn't that important.
And if you want to ask me about this,
I will show these slides later.
But basically, build systems shouldn't
run as build systems in the background.
They should run as
generators in the background.
However, if you try to save a file
while a build is running, you deserve
to be punished for your hubris.
And we're also gonna skip this
because this is like real quick.
You have differing CPU
architectures, aka -march madness.
I'm glad, okay, thank you.
Someone told me that wasn't funny
and I was like okay, you
just don't watch basketball.
But yeah, no, with these ABI issues.
If you're like trying to
worry about exceptions
and stuff like that, it can be a problem.
And then there's incompatible
code generation options too.
You have a cc library,
you have dash rig too.
Bet your butt they are using &quot;because&quot; -03
is going to enable optimizations
that remove undefined behavior
and everything's broken and they're like,
&quot;Well, 02 works. I guess
I'll just ship it.&quot;
And you end up with undefined behavior
breaking your code generation options.
There's also transitive
linker and compiler flags.
I will show you an example of
how we can possibly fix that.
And there's a lot here, right?
Every build system has to know
how every single compiler works.
I realize I have to run through
a bunch of slides in five minutes.
It's what we'll do.
Reproducible builds with this issue,
this is, we'll get to this in a hot second
because this is technically a pipe dream.
This tool doesn't exist yet.
And I haven't had time
to actually write it
because of other things that I
don't want to talk about right now.
Dependency management.
Without package managers,
a lot of build systems
would start using pkg-config.
Meson uses it, build2 uses it,
they all generate them too.
It's insufficient for the needs of C++.
What is up with this formatting?
It was working fine earlier.
Put that in quotes and
then quote me on that,
because that's like Lil Wayne software.
So what's pkg-config?
It's an opensource tool.
With Windows support as
of like a few years ago.
People don't know this.
There's Windows builds and it can interact
with the Windows file system and
support spaces in the file
names and directories.
Like that's a really big deal
for a Unix shill, trust me.
It's written in C and it's written for C,
and this is a big problem because
C and C++ are not the same language.
But it provides an
interface for your compiler
and linker flags for the
library that you've constructed.
So what does it do?
Well, I just mentioned it, but
what it actually does in operation
is it searches a directory
for a file named libname.pc.
It opens the file, it reads the values,
if they're just key
value pairs more or less,
and it prints them to stdout.
It's super simple but it
has a guaranteed format.
It's part of the whole free
desktop specification thing.
Well why is this a problem then?
Doesn't support multiple
versions of the same library.
Do you want to have gdk 2.0 and gdk 2.1?
Yeah, go screw yourself.
It's not gonna happen.
And if you wanna have
like a debugger build
and a release with exceptions and
a release with debug symbols without rtti
all on the same system.
Nope.
Can't do it.
There's no virtual
environment path setting
so you can't say, &quot;Look in this
specific directory for
all of these files.&quot;
And it wouldn't matter either because
if you had multiple libraries
and you needed to depend
on the different versions it
doesn't solve the problem.
There's no protection against
incompatible compiler options.
So if you wanna use -march i7
and you wanna use -march,
I don't know, Adam.
Why would you do that?
If you wanted to, I won't stop you.
I don't know if GCC actually
errors on that, but it should.
Probably.
It doesn't.
But we can solve this.
It's the same problem as
before, but we'll get to that.
So how to fix it now?
I definitely do have to call
this something on an HTML file.
Now I'm being rushed for my viewers.
So we can write a better
tool than pkg-config.
Oh.
That still happened.
This is embarrassing for me, I'm sorry.
We can write a C++ aware pkg-config.
I would actually
recommend against this but
there is a comedy option.
We can move to the
desert and grow cactuses
for a living and give up entirely.
So there's this concept
of option comprehension.
Build systems don't know
what a compiler flag is.
They're all strings.
In every build system,
it's always a string.
You think your compiler, or
rather your build system knows
what -march means?
It does not.
So what, real quick,
what is the compiler flag
to enable all warnings for Clang?
It's webrethink.
For MSVC, it's actually /wall.
For GCC, they don't have
one and they don't want one.
For some reason.
Because what if they add new warnings.
What if?
So here's a harder one.
That one's really easy to find out
because you can find
it in a Google search.
What's the compiler flag to enable
warnings for virtual function hiding?
For Clang, overloaded-virtual,
with the dash over your file.
For MSVC, I don't know. It's like 4307?
It's got a number.
It has a number, good
luck finding it though
on a quick Google search because
I actually couldn't find it and I believe
it's actually like four or
five settings altogether.
For GCC, it's the same as Clang
but it works a little differently.
This is the problem.
Every build system has to either
comprehend every possible flag and
provide semantic
understanding for each option
for each compiler it supports.
Or treat compiler and
linker flags as strings
and hope the user knows
what they're doing.
Which you don't. I guarantee it.
Because it will always get messed up
and you'll be like, &quot;Why's our compiler,
oh forgot. Right. This isn't supported
by this version of GCC. My bad.&quot;
But the burden of incompatible options are
the responsibility of the user.
How do you let the user
know they've built something
with exceptions enable and a dependency
that has disabled them?
You don't!
There's no build system that does this.
But we can solve this.
And if fact, this is the
easiest problem to solve.
This is the pipe dream.
We need the universal compiler interface.
This sounds crazy, right?
You're like, hold up, a compiler interface
that wraps every other compiler?
Yeah okay, like anyone's gonna use that
because now build systems no longer
need to support every compiler.
You have a defacto CLI
for tools and users,
you have cross compiler support,
you don't have to worry about
if it's a monolithic compiler
where I have to make one for each
target that I'm targeting
or is this just a compiler
that targets multiple platforms.
Supporting new compilers
can be a configuration file.
&quot;Aha!&quot; you say.
Build systems will have
to support your interface
in addition to other compilers
so you've solved nothing.
Allow me to link that XKCD
comic about multiple standards
or whatever so that you
may wallow in despair
as you pay for your hubris.
No need, that's entirely false.
You're not building a new standard.
Nothing stops a build system from
hiding this from the user.
With defacto CLI, you don't have to
memorize flags for different compilers.
Enabling any language TS becomes the same
where it's enabled.
The tool knows what these
options mean for each compiler.
We could do overload-virtual=true
and then file it past that to this
universal compiler interface
and I don't have to care
what MSVC's flag says anymore because
it's just a look up in a dictionary.
We have better cross compiling supports.
Some compilers have multiple
instances for each platform.
Some compilers are always cross compilers.
Why should anyone have to care?
Adding support for new compilers.
Handwritten configuration file.
Or you could do automatic
compiler detection
which every build system
has to do already.
Autotools, Meson, CMake, they all do this.
We probably need an automatic toolchain
manager of some kind.
Manually updating GCC or Clang
outside of your package manager
is a huge pain in the ass,
as I demonstrated earlier.
Creating nightly builds of
Clang or GCC is even worse
if you want to have like a nightly update.
I don't even have words.
There's no reason we can't trust someone,
like Google or Facebook or
Apple or Amazon or Microsoft
or, like, Qualcomm, I don't care, someone.
Anyone that we can like moderately trust
to not screw this up.
Which, alright fine.
And checking Stefan's website
doesn't count as like,
&quot;Oh, lets see if the HTML file's changed.&quot;
Don't do that.
I don't have any suggestions
for this other than
don't make it bad.
Quoted.
So some takeaways from this topic.
Remember, build system's for
must follow its function.
Modules are for you, not
for your build system.
At least the modules TS.
Your user's hubris should punish them
and it's not your fault.
It's like the Good Will Hunting scene.
&quot;It's not your fault,
Will. It's not your fault.&quot;
Our ecosystem is garbage, but
we can make it much better,
we just have to try a little harder.
I wanted to talk about
an actual build system
and package maker combo.
But after Tidus's talk yesterday,
I wanted to reevaluate that and
maybe there will be a
sequel to this next year.
So, we're at the end of the talk.
I think we're almost out of time actually.
Yeah, where're we at?
Two minutes?
That's enough for one question.
If you have it, please get behind the microphone.
- [Audience Member] Don't make it bad.
Not a question but okay.
No questions?
- [Audience Member] Is there hope?
- Yes, there is hope.
- [Audience Member] I don't see it, where?
- It's in you, it was
in you the whole time.
(all laugh)
(applause)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>