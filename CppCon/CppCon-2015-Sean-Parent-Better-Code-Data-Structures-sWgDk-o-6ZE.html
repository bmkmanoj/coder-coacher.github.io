<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Sean Parent &quot;Better Code: Data Structures&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Sean Parent &quot;Better Code: Data Structures&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Sean Parent &quot;Better Code: Data Structures&quot;</b></h2><h5 class="post__date">2015-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sWgDk-o-6ZE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Shawn parent I'm a principal
scientist at Adobe Systems I've been
there now just over 20 years so I've got
a lot of things there lately I've been
working on mobile digital imaging and
some web-based digital imaging is pretty
interesting work I gave a talk at the
going native conference two years ago
now that was entitled C++ seasoning how
many people have seen the talk either
wow yeah so lots of people have seen the
talk it's like a hundred thousand views
on them on the website now which is
pretty stunning so it was very well
received and a lot of people suggested
that I write a book based off that talk
so what I've done is I've started a book
and I outline the chapters and each time
I get invited to go give a talk I flesh
out one of the chapters for the book so
hopefully eventually this book will get
written right now we are here now for
people who have followed any of my talks
I've done talks after this point and
I've done talks before this point I
haven't given this talk so I didn't I
give the talk in the middle well it's a
bridge talk kind of ties the start of
the books towards the end of the book
and I didn't think there was anything of
particular interest to given this talk
but last February I got invited to give
a talk I gave a talk on concurrency as a
keynote at meeting CPP in Moscow and
after that John asked if I would repeat
the talk at C++ now in Aspen I agreed
and then a couple weeks before he sent
me an email and said Shawn were short on
tutorials and give that keynote as a
tutorial so I obliged and I did and it
worked out pretty well I got an award
for best tutorial and most useful talk
so then John asked could you give a talk
at CPP con and I said well since they
worked out for a tutorial this chapter
would make a good tutorial talk so I
proposed this talk and I get an email
from John
said we're very excited about your talk
we're going to make it a keynote so
thanks John so each chapter in this book
to be written has a goal and the goal
for this chapter is no incidental data
structures and the word goal here is
chosen very specifically this is a
little different than guideline or rule
or what you know what we've been talking
about at some of the other keynote talks
here in that a goal is something that
can be very difficult to achieve right
so if you've seen my C++ seasoning talk
I have goals like no wrong lubes and all
pointers you can go watch the talk if
you want to know what that means okay
but these are things that you strive and
that you don't want to put down as a
hard rule they're things that by
striving to achieve them your code will
get better so that's why I use the term
goal but what is an incidental data
structure okay to understand that we
need to understand what is a data
structure most of us have a pretty
decent idea we're like well it's a list
it's a vector it's a map I looked up the
definition that's always a good thing to
do if you want to know what something is
definition is a data structure as a
format for organizing and storing data
I'm not sure that I agree completely
with the and storing data part right a
data structure can be just a format for
organizing data you don't necessarily
have to store the data inside the data
structure but that's not a bad
definition but in some ways it's a
little unsatisfactory because it really
doesn't tell us what we mean by
formatting and organizing to understand
that we need to understand what is a
structure okay we can look up the
definition of it right
a structure is basically things that are
related to other things okay so how many
people here have architect in their
title a few yeah software architect some
way right what an architect does is an
architect designs structures right so
what that means is an architect is
concerned about the relationships in the
software from one component to another
that's what an architect does and
there's a problem here the problem is
that computer scientists are very bad at
relationships
we just are okay so
this slide represents nothing and I mean
literally nothing it's wait there is no
dimension here there is no width there
is no height there is no time this is a
dimensionless space if there could be
such a thing right it is a mythical
Haskel space okay within this space we
have four bits
those bits have always been there they
will always be there and those bits
represent four bananas that's what they
mean or maybe they mean the color blue
or maybe they just mean for an abstract
for okay the reason why they mean that
is because I said they mean that because
I think they mean that okay that's a
semantic relationship okay
those bits have a relationship with the
entity of four there's another
relationship here okay those four bits
collectively have a form a type they are
related to a range negative eight to
seven I bet a bunch of you thought they
were unsigned right yeah but they're not
why not because I said so okay this is
my universe these relationships are
incredibly important when we heard talks
earlier and we were in herbes keynote he
mentioned type safety lifetime safety
bound safety what we're talking about
when we talk about those things is
maintaining this relationship okay if we
lose the semantic relationship on our
type
the universe unravels missiles launch
it's really bad okay we also have a
notion of value safety right which is
whether or not those bits zero one zero
zero represent our four right if we lose
that relationship right then we have
lost value safety so when we lose that
we say our value became invalid now the
standard the C++ standard actually uses
the term valid in two different ways
okay in the first sense is talking about
iterator validity so if I have an
iterator and it points into a vector and
I do a push back on my vector the vector
might move and my iterator becomes
invalid okay that's what the standard
says the bits in that iterator didn't
change what happened is the relationship
that that iterator has with the vector
was severed its meaning was lost it's
now an invalid object the only thing
that you can do with that invalid object
right the type does not invalid it's
still an iterator but its value is
invalid the only thing that you can do
that an invalid iterator is either
restore meaning to it by assigning a
value into it or letting it go and
destructing it now the other way that
the standard uses the term valid is in
talking about the state of an object
after it's been moved from or with the
basic exception guarantee after an
exception has been thrown and there the
standard says that the value within the
object is valid but unspecified that's a
contradiction okay if it's unspecified
it has lost its semantic relationship it
is no longer a valid value
okay it's type is still valid but that's
a given just like an iterator type is
still valid okay so these are somewhat
contradictory senses so when we say with
the exception basic exception guarantee
or the state from a move from object
that object is now invalid okay because
it's lost that semantics relationship
and the only thing meaningfully that we
can do to it is we can establish a new
value in its place with meaning or we
can let it go and destruct it if you're
familiar with the book elements of
programming for malloc Stepanov he
refers to an object and such in such a
state is being partially formed so these
are very important relationships right
so when we talk about safety in
programming what we mean by a safe
operation is an operation that maintains
the semantics relationship an unsafe
operation is an operation that may sever
the semantics relationship okay when we
talk about invariants on a type what we
mean are the properties that must hold
in order for this value to remain valid
to maintain its meaning okay everybody
following that now we can have two
objects within our universe here that
have the same type and map into the same
space and that allows us to establish a
value relationship okay this is another
type of relationship between those two
things 4 is less than 3 that's a
mathematical structure right it's a
value-based structure we can also
establish a relationship on just the
representation right we just have these
bits in memory we can hash the bits and
we can talk about the bits being equal
or not equal the reason why hash has
meaning is because of the relationship
that if two objects have the same
representation then they represent the
same value okay so we are now
associating a representational
relationship their hash with the value
relationship and that's how we get
meaning on hash now the converse is not
necessarily true just because the hashes
are equal doesn't mean the values are
equal but we don't live in this mythical
space we live in this space we live
within an address space and what makes
the four zero one zero zero in the
middle they're different from those bits
at the top is that those bits have no
semantic meaning because I didn't give
them any okay so if I have an integer on
the stack and it's uninitialized right
that is an object in a partially formed
state it has no meaning the only thing
that I can do to it is assign a new
value to it to give it meaning right or
let it destruct now my object within a
space has a relationship with the space
it's the address of the object and
that's both spatial and temporal
relationship right this object is here
now okay so where did John go John in
the audience here John's back here
I think where's Marshall Marshalls back
here so John and Marshall are involved
in a relationship okay normally you
would call this a structural
relationship but since we're defining
structure that's a bad term for this
talk so I'm going to call this a
physical relationship
so John and Marshall are involved in a
physical relationship see I'm getting
back at John right apologies to Marshall
now you guys laugh but you're all
involved in a physical relationship
she's a little scary okay that
relationship has no meaning
okay okay for some of you maybe it does
okay these two items are involved in a
physical relationship the address of the
first object is less than the address of
the other object that in and of itself
has no meaning okay but we can ascribe
meaning to it by sorting our objects and
now what we've done is we've established
the correlation between the values and
between their physical location and that
lets us associate meaning with their
physical location okay this is an
important property of having objects
within an address space this is
something that we can exploit when we're
building software right there's a lot of
languages that would like to ignore the
fact that objects have physical
relationships right we refer to those as
the puritan languages right right we all
know the physical relationships exist
but they're being ignored
now there is another possible
relationship here if we take one of the
mathematical relationships associated
with our value and we associate it with
a function we get a functional
relationship okay so here we can add our
two numbers we get seven as our result
so that's a functional relationship
functional relationships form dependency
graphs and if you want to know more
about that a little bit more anyways
look up my concurrency talk I'm not
going to talk too much about dependency
graphs in this talk but I will mention
that if we were adding two values that
overflowed right remember these were
signed values my result is unspecified
right right what does that mean it means
that my value in my result has no
semantic relationship so this comes up
over and over and over again right
there's one more relationship that's a
particular interest that I want to talk
about and this is the whole part
relationship this is defined in Chapter
12 of yo P okay the whole part
relationship is what allows us to talk
about composite objects a whole part
relationship has four properties to it
the first property is connected and what
that means is that if I have an object
that's a part of another object that I
can reach that part from the whole okay
so if you have an automobile like a
Honda Civic and you have a part of your
Honda the part is connected to your
Honda the second is non circular and I
don't mean in the sense that back
pointers are disallowed I mean that
something cannot be a part of itself
either directly or indirectly okay so no
circular part relationships
the third is logically disjoint again
what I don't mean is that I
can't have an object that is shared by
two other objects but what I mean by
logically disjoint is that if I change
one object it cannot change the other
object okay
so there's kind of no mutable sharing
that can be allowed so we don't have
that and the third relationship third
property of this relationship is
ownership and what that means is that if
I make a copy of the object it makes a
copy of all the parts and I get two of
them and if I destruct one it gets rid
of that object and all of its parts okay
those are two distinct disjoint objects
if you've ever heard the term
regular-type these are the properties
that allow a composite object to behave
like a regular type okay all the
standard containers vectors lists things
like that are composite objects so let's
go back what is a structure right so a
data structure is a structure utilizing
value physical structural and
representational relationships to encode
semantic relationships on a collection
of objects and the choice of encoding
can make a dramatic difference in the
performance of operations on these
objects right and we know that right we
know that that if I have a linked list
that iterating over the link that
indexing into the linked list is linear
time and inserting into it is constant
time and if I have a vector it's the
reverse of that iterating over it or
indexing into it is constant time
inserting it into it is linear time
right right and we know that I can have
a map where I can look up
long again and we know that I can have a
closed hash map and get something close
to constant time on a lookup we know
these things something that I think a
lot of people don't realize is how big
of an impact these days the memory
memory hierarchy has on the performance
of data structures so I stole these
numbers they actually come from Jeff
Dean but I stole them out of a slide
from shandler Jeff Dean also has a talk
that's available online so these are the
times on a typical desktop machine to
access different pieces of memory
there's basically an order of magnitude
difference between each level in the
memory hierarchy okay so by the time you
get down to main memory it takes you 200
more 200 times as much time to get to
something as it does out of l1 cache
that's huge when I started programming
this was not the case not at all it was
much more one-to-one on a modern machine
Ram behaves much like a disk drive ok to
put this in perspective log of a
trillion is 40 ok so an algorithm that's
n log n versus an algorithm that's
linear ok can have can be more impacted
on its performance by locality of the
objects than by the Big O notation on
the algorithm so locality matters use
arrays use vectors when I was
researching this talk I stumbled across
an old post on lambda the ultimate that
was citing the talk the person who
who wrote this piece said it was either
a talk that I had given or that Chris
Cox who's a member of the Photoshop team
had given I don't recall saying that in
the talks all attributed to Chris but
that the Photoshop application the
number one data structure used in the
application was vectors and the person
on lambda the ultimate concluded that
Photoshop had no interesting
relationships within the application
this is not the case okay the case is
that the team understands performance so
I want to give some examples here first
example is utilizing parallel arrays
with algorithms okay
if you saw my C++ seasoning talk there
was a I gave an example of an algorithm
called gather which comes from Marshall
Clos
they uses two instances of stable
partition in an interesting way I gave
that talk and after that talk I went out
to dinner and I was chatting with
somebody at dinner I'm sorry I don't
recall who it was who said I really
liked your talk but you really cherry
picked that example I think somebody
here repeated kind of the gathering
slide algorithms from from that talk in
one of their talks and I said what he I
said you know it was a talk so certainly
I cherry picked but I didn't it wasn't
that big of a stretch and he said well
algorithms in real life are very
complicated okay and I said for example
he said for example you can't write
stable partition simply yes I can okay
so so what's stable partition right
stable partition is you take all the
good guys all the selected guys you have
some predicate that Marx guys and you
move them all to the front all the good
guys go to the front and all the bad
guys go to the back
and it's stable because their relative
order doesn't change okay so that's
stable partition so we're going to write
stable partition okay anybody know where
to start Wow standard library we have
stable partition but we're going to
write it for a reason okay so what if we
cut our space in half
and somehow magically we were able to
stable partition both of the halves we
still don't have a right stable
partition but we're just going to assume
that we could do that okay by just
calling stable partition two times we
still need to write stable partition oh
but this would work if we could do it
okay now what do we have to do to get
the good guys to the top and the bad
guys down to the bottom right that range
in the right order
anybody know there's an algorithm for
this rotate this is rotate my favorite
algorithm so we rotate
okay okay so we can do that and rotate
is going to return the new midpoint
that's our partition point so that's
very handy okay so we can just return
that out of our function so now all we
need is an inductive basis where does
this thing bottom out if we just
recursing down just keep recursing down
okay we can purse all the way down on
tree what we're going to end up with one
element which is either selected or not
selected okay so we're going to apply a
predicate to it and we're going to
return I are there if it's selected okay
so we're going to move F down or we're
just going to return wherever F was
right right so we're just going to add a
zero or one to our location and that's
our inductive basis okay so now we can
put a little boilerplate around it we
need to calculate how many elements we
have we need to handle the zero case and
we need to divide to get our midpoint
and that stable partition we can execute
that and it will do that okay people
following that okay so it's pretty
simple okay and in fact if you look at
all the stl at the actual
implementations what you see is pretty
much everything in STL is a building
block to build one algorithm just stable
sort okay so rotate if people aren't
aware the easiest way to implement
rotate is three reverses okay
so you can right rotate there's enough
is an interesting thing there which is
you can also write reverse in terms of
rotate and if you do you get you can get
an N log n version of reverse that works
on forward
generators that's left it as an exercise
to you guys now there's something very
interesting here in this piece of code
the only place where our predicate is
applied is one time to each object
before that objects been moved okay so
we're going to go all the way down to
the bottom of our tree read each object
exactly one time and then put everything
back together how we wanted that's an
amazing property and you probably
wouldn't suspect that if you didn't know
the implementation of stable partition
okay and what that means is that we can
get an interesting algorithm out of this
algorithm by just removing that star
okay so we can call this stable
partition position right what this
allows us to do is our predicate can now
be a projection based off the position
okay so let's call it let's see what I
mean here right so I've got an array of
integers at the top 1 2 3 4 5 5 4 3 2 1
and I've got a boolean mask underneath
that that happens to have a one true bit
underneath every even value okay those
are two parallel arrays and what I want
to do is organize a so that all the even
guys all the selected guys are up front
maintaining the relative order and all
the odd guys are at the end maintaining
their their order and I can do that with
the stable partition position okay so
that's what it will print right I
stopped in the middle there to put it
out so the result what is in our a after
we execute that is 2 4 4 2 1 3 5 5 31
right my predicate there is a projection
from a
position in a into a position in B okay
so if you saw my talk on what you can do
with stable partition as far as gather
within a UI I can have a bunch of
selected objects and I can move them
into one location now I don't have to
keep the data about where my selection
is in the same data structure with the
rest of my data it doesn't have to
pollute that and slow down my access
times on that rest of the data when I
don't need my selections I can keep it
as a parallel structure it also means
that I can take my my selection vector
here my array of bits and I could encode
it in a more efficient manner right
maybe I could encode it as a set of
inversion points to represent ranges
that are selected and I can project into
that okay so just changing that one
character just removing the star the in
stable partition gave me a new algorithm
so another example algorithms in minimal
work like stable partition a lot of
algorithms in STL work in a
divide-and-conquer fashion not just an
STL a lot of algorithms in general work
and divide and conquer
right there's kind of two ways that that
can happen you can as we saw with stable
partition we can go all the way down to
the bottom and then put everything back
together on the way up or if you are
doing something like a a quicksort you
would pick a pivot element and you would
partition at the top and then you would
go down the tree doing partitions until
you got to the bottom and then your
whole thing would be sorted okay so
there's kind of two approaches that you
can take both of these approaches lend
themselves to pruning the tree right if
you've got a tree structure a lot of
times you can figure out that you don't
need to go all the way down to the
bottom and we can utilize that to get
performance so let's take a problem here
okay I've got this time a vector of
numbers okay the numbers I think here go
from
one two sixteen and they're randomly
shuffled in there and I've got a range
within that vector SF to SL that I want
the values within that range sorted as
if the entire vector were sorted okay so
what I want is six seven eight nine in
there okay but I don't actually care
about anything outside of there okay so
I could sort the whole thing and that
would give it to me just wouldn't be as
fast as I would like it to be okay
where do we start writing this anybody
partition yeah one vote let's see
I got Marshall back there in the back
did you would be tempted to start with
partial sort partial sword is part of
the answer right I can't just use
partial sort here because partial sort
always works at the beginning of a range
what's that n that thank you okay so
there is an algorithm in STL called n
element so we can start with just the
first guy in this SF and we can call n
element and what that's going to do is
is going to do a form of a partial sort
that just pins the element at our
iterator sf with the right value right
so after I do this this is what my data
is going to look like right the stuff
above and below is still scrambled but
six is where I want six to be right so
you want to calculate a medium quickly
with STL and element is how you can't
calculate a median quickly okay okay how
many people knew that yay no your
algorithms okay so from there now it's
pretty simple if we know something a
little more about an element an element
doesn't just pin the one element it also
partitions our space
specifically everything between F and s
F is going to be less than or equal to
the value that's at SF okay and
everything down there is going to be
greater how many people knew that Wow
a few so about half as many people who
knew what nth element was so now to
complete things here we already got that
guy in the right position so we can just
skip over them and then we can just call
partial sort okay so both nth element
and partial sort are tree pruning
algorithms okay so that's going to give
us those guys in the right range okay so
I can put a little boilerplate around
here I want to handle the empty case
right I don't want to call tenth element
when there is no element there and I can
just skip the whole nth element thing if
I'm all if my range is already at the
beginning and now I've got a very
beautiful little algorithm called sort
sub range if what I need is to sort of
sub range and I might do it because I'm
doing something like taking an average
around a median or I might do it because
I've got a view into a large collection
of records and I just want to see this
or the user told me to print page seven
of 1,000 for my document okay there are
many reasons by my point monthís data
in practice this is going to be
somewhere between about two and eight
times faster than sorting all the data
okay because we're cutting off the leaf
nodes of the tree our sort sub range
also inherits the same properties that
we had in n element which is it also
partitions the space so everything from
F to SF is less than SF and everything
from SL to L is great
greater than or equal to the last
element within our range and so if I
need to extend it right down to NL I can
just call partial sort and I can extend
it okay so what I'm utilizing here is
I'm establishing spatial relationships
on my object that capture semantic
relationships about their value ordering
and I'm exploiting that to speed up my
algorithm okay so this is a data
structure this is structured data right
so what is an incidental data structure
well an incidental data structure is a
data structure that occurs within a
system where there is no object
representing the structure as a whole or
put another way its structure formed in
the absence of a whole part relationship
it is not a composite object so why
don't we want them they cause
ambiguities in our code right structural
ambiguities which is a little different
than value ambiguities they break our
ability to locally reason about code
they break the notion of value semantics
within our code and they happen all the
time okay
they happen when we create delegates
they happen when we have message
handlers and the big biggest culprit is
self referential interfaces right I
remember when I was first learning C and
I discovered this amazing thing where I
could forward declare a class or a
forward declare a struct and then within
my struct I could have a pointer to
myself and that's the basic concept with
which I make a linked list and I thought
how that's just amazing right right that
that even works ok this API is also self
referential API this is pretty much the
API for UI element out of the windows
API right stripped down and C++ I is dry
they got rid of kind of the manage C++
issues here ok so what have I got
I've got elements I've got an element
collection to which I can add elements
I've got a panel which is an element ok
and my panel has a bunch of children in
an element collection which are elements
and people tell me well what's the
problem with this it's a hierarchy right
I mean it works ok I put an object in
there is it a hierarchy right what if I
do that if I put the element into the
panel again hmm ok well it's a dag we
can deal with the dag it tags ok well
what if I do that ok it's a dag with two
routes or that
okay my API doesn't constrict those okay
you might think this is silly
but I've actually seen people do
horrible things like this in code okay
with sometimes interesting results okay
what's going on here we have managed in
those four lines of code to violate
every property of a composite type every
single last one our panel is a part of
itself right so it's circular okay so
it's not just joint we have two panels
they're sharing the same elements okay
so we violated ownership if we
destructed one the whole thing did not
go away and potentially we have a retain
loop on our panel and that would violate
connectivity those four lines of code we
violate every principle for a composite
object so forests and hierarchies are so
important because they appear in code
all over the place and they had to add a
huge amount of complexity to the code
we've all gotten used to writing linked
lists and vectors and things in terms of
containers and yet for some reason we
persist in writing forests and
hierarchies as intrusive data structures
where we embed the information about the
structure into the structure itself and
besides the structural ambiguities that
I pointed out this leads to all kind of
algorithmic ambiguities when I iterate
over the children okay with
and my panel am I just did a rating over
the children or is that a pre-order
depth-first search or maybe it's a post
order depth-first operation right
because I don't know as I call each of
those children what they're doing with
their children right right and a lot of
people tell me well this isn't too bad
because hierarchies tend to be log n ish
actually is really bad hierarchies in
real life tend more to be like and over
to ish right right
they don't fan out like that if you look
at view hierarchies I have like a bunch
of deep containers and then a bazillion
children okay go like down and out that
tends to be more of the structure right
right they tend to be a very inefficient
way if I want to do something like very
quickly determine where a mouse clicked
within a view hierarchy I don't want to
go walk down my hierarchy and say say is
it in you yes okay we'll check your
children bonk bonk bonk all the way down
what I want is something like a quadtree
right where I can very quickly navigate
to exactly the object I don't want the
containment hierarchy
I want parallel data structures to keep
that information people tend to do event
dispatching in these things where they
keep throwing events back up to the top
when really what they want to be doing
is just calling another object directly
a little over in the tree instead of
percolating event up and down this
hierarchy okay and forests are somewhat
difficult structures now if I talk about
a sequence how many positions are there
in a sequence okay anybody I have a
sequence of n elements how many
positions in a sequence of n elements n
plus 1 there are n plus 1 positions
right right there I could go between
each of the guys in the element those
are all the places where I could insert
some
how many positions are there in a
hierarchy anybody what does it mean okay
first thing you have to define it is
your hierarchy ordered or unordered
right that makes a difference and what
do you mean by position it's a difficult
thing so a story here years ago I'm
sitting on the floor with my youngest
son and he's got a little fine motor
skill toy
it's just wooden beads and shoelaces
right then you string the beads on the
shoelaces how many people know what I'm
talking about
everybody good okay so you can do that
put two beads on a shoelace now this is
a pretty decent representation of a
linked list and that tells me how many
positions are in the linked list
what would the corresponding structure
be for forests right people are thinking
probably a bunch of strings with a bunch
of knots something messy okay so I'm
sitting on the floor with my son and one
of the shoelaces is tied into a loop
it's tied at the top okay and the
shoelace was fine enough that you could
put the loop through a bead like that
you couldn't pass back through the bead
because it completely filled the bead
that once you put the loop through the
bead so you could only put a loop
through the bead once okay so you could
build a list this way okay but any place
where you could pull out a loop you
could put it through like that and
create a forest or higher
I was very excited by this like I spent
four hours playing with this shoelace
and beats anybody understand why I was
so excited and no no something is it is
a sequence okay so it has lots of
amazing properties okay it is a physical
model of a hierarchy and the only thing
that you can build with this as a
hierarchy okay the invariant that this
thing stays as a hierarchy is part of
the physical model of it you cannot
build an on higher key this way okay
there is nothing that you can build with
this physical model except for
hierarchies it also has some amazing
properties in that right it's a little
bit more complicated direction okay so
we have the knot at the top that's the
piece that we hold on to that's our
forest okay we can add a directionality
to the string as far as how it loops
around okay each position here
represents a position where we could
draw that out and insert another node
right we can tree parent things but we
can put leaf nodes anywhere okay just
like on our original string if we were
just putting be done to form a list
I can't move things further up without
splicing okay but I can keep that
ordering in a similar way I can always
add leaf nodes to my tree but I can't
reparent things okay every position
within this list uniquely identifies a
location within the tree without keeping
a stack of information I can have an
iterator that points to a node and I can
just remember it and pick up from there
and keep going in a traversal right
if I give you this definition that says
we have a leading and trailing edge on
our nodes okay then if I mark off the
leading edge where I come in on the top
that is a pre-order depth-first
traversal and coming up from the bottom
is a post order depth-first traversal
okay if I want to know what it means to
erase elements from some point in my
model to some other point in my model
okay what I do is I grab those two
locations on the string and I pick the
whole thing up and the beads that fall
off are the ones that get erased okay so
above my fingers going towards the knot
nothing can come off below my fingers
things might get stuck if I grabbed
along the same edge I might end up with
a list of parents that I didn't fully
select something asked the string has to
go through twice for it to fall off
between my two fingers okay this means
that if I take this structure and I
flatten it out and I encoded at within a
UI it means that I know what it means if
I click here and shift-click there and
hit the delete button okay and the
algorithm in the code for this actually
works out to be see what beads fall off
right it's quite a beautiful little
thing okay so there's a force data
structure that's in ASL that's been in
ASL for years Adobe source libraries if
you don't know what it is it's decaying
a bit the source libraries are but I
keep this up-to-date on github so you
can find the ASL repository on github
and this will build and this is what it
looks like to insert things and in my
opinion this is a really beautiful data
structure it's not a particularly
efficient data structure it's a
node-based data structure but that's
what you would probably create anyways
but it has this wonderful safety
attribute
that I can't create a non hierarchy okay
so it has these wonderful attributes
that I can remember positions into it
and deal with that that when I iterate
arrange I can see what it is exactly
that I'm iterating okay I'm not calling
each node and saying you call your
children somehow okay and I know if I
want to do a pre-order or post order
that becomes immediately apparent within
the code so two weeks ago a little side
story here my wife was babysitting my
younger son whose beats I was playing
with he's now 26 so my wife was
babysitting and she keeps a box of old
toys from when our kids were little and
she took it out and she was babysitting
and then that was a bag with the
shoelaces and the beads the actual
shoelaces and the beads and I had this
very humorous thought that it's like
well someday maybe in Computer History
Museum next to Martin Newell's teapot
there will be Sean's shoelace but I was
surprisingly excited to see these and I
was like ah I remember those beads and I
asked my wife I said do you mind if I
take those to the conference that I'm
going to give a talk at and she said why
would you want to take them to the
conference so I tried to explain that
you know this shoelace in this bead was
a beautiful representation of a higher
and that it maintained all these
wonderful attributes my wife's a nurse
and she wasn't looking at me like
quizzically or with awe she was looking
at me with something that was closer to
discussed
and she reached out and she took the
beats back and she said that's what you
remember so computer scientists were bad
at relationships okay
so conclusions understand the structure
is created by relationships okay if you
want to improve your code encapsulate
structure and very mints in composite
types and learn to use the tools that
are already at your disposal and how to
create new ones right last time I
challenged you guys those who are here
two years ago learn the stl algorithms
right now I mean really learn them okay
so don't just read the interface and
learn them learn how they're implemented
right learn how you would write your own
ok STL is intended to be an example an
example of how you code so not a
beginning not an end it's an example
right so no incidental data structures
composite types and better code and
that's it for my talk
I've got plenty of time for questions
people have any a question over here you
might want to come up to the mic yeah so
you mentioned we can learn from the STL
and the implementation of the STL I'm
also wondering and I guess we could
start with ASL also could you point out
some examples of C++ libraries today
that best showcase the properties that
you have thought about that we could
also learn from by example right I mean
I certainly think you see them in boost
and then you know the common libraries
that you would think of looking
unfortunately STL itself the typical
sources that are on your machine are so
munched and so optimized that they can
be very difficult to kind of plow
through and learn from reading the
implementation a lot of times I'll go
back to Alex's old SGI implementations
which are still online to actually read
read the algorithms and what's going on
there the other thing to keep in mind
when you're going through this if you go
through this exercise is I think there's
a lot of opportunities where we could
improve on things there's things like
like rotate has an implementation for
how you do a forward rotate and a
bi-directional rotate and a random
access rotate you know depending on on
the concept satisfied by your iterators
those are three different algorithms and
I don't know that anybody has ever gone
back and revisited I would almost guess
that the forward iterator implementation
for rotate beats the bi-directional
iterator which is running backwards on
our disk drive of memory and it might
even be to the random access
implementation right so so kind of keep
the history in mind there as you go go
back and look at the algorithms the
other great resource is alex has course
notes online which are a little more
approachable than something like AOP
right-eo P is a brilliant book so
actually I have also a follow-up
question do you know anything like notes
on programming by Alexander step enough
you're perhaps plan to write something
because I would be very interested well
as I said yeah maybe I'll write a book I
keep telling people people are like how
where's the book and I'm like well the
only thing I have left to do at this
point is write it but that actually
means I've done a lot of work right
right I've put together talks and notes
and I've taught the class and so I have
a big pile of material but anybody who's
written a book I haven't but I've worked
with people who have it's a lot of work
so so yes I would like to get a book out
right question over here hello I would
like to present a hypothesis to you and
get your opinion on it I think a common
thread among your recent talks can be
demonstrated if you consider code itself
to be a data structure whether it's call
graphs or a sequence of instructions or
what have you and when you think about a
raw loop and all of the pieces that go
into making a raw loop you have
iterators and increment operators that
can be seen as an incidental data
structure yes do you see a relationship
here between how we craft good code and
how we craft good data structures I do
the the term incidental data structure
was actually coined by echo yarv a who's
a professor at Texas A&amp;amp;M it occurs in a
paper I co-authored with them on on
property models which is about
dependency graphs and and flow of data
within an application and that that
creates a data structure if you want to
know more about that as I mentioned see
one of my concurrency talks or you can
look online we've got a number of papers
published published on the topic but yes
absolutely in a more general sense like
I said it's all about relationships and
the structures formed in your code and
to understand a large system you have to
keep looking at how are the components
connected and they're connected in a lot
of ways right there's different types of
relationships there's the functional
relationships there's the value
relationships there's the structural
relation
chips there's a representational
relationships and we exploit all of
those right and then we have
higher-level relationships like
whole-part relationships and we exploit
that so as you're looking at your code
what ultimately what we want is the
ability to reason about a piece of code
locally so if you look at every single
chapter in here what the punchline is is
how do I get my code in the point where
I can sit down with one function and
read that function and understand what
in the world is going on with my code
okay so it's all about understanding
these relationships so that you can
reason about your code locally and know
that as a whole if it works locally it's
going to work at scale so yes I agree
so you shown the importance of data
locality for performance reasons yes and
as far as I understand the forest
implementation that you've shown was
note based so how do I do you actually
suggest to implement something like a
hierarchical structure while having
contiguous memory to benefit from cache
locality so the question here was my
forest implementation is node based I
mentioned that and yet I already talked
about the performance that you want by
keeping locality so could I recommend a
structure for for a forest that would
keep locality no I haven't written one
yet I think somebody should maybe I
should I think it's doable there's some
hacks that you can do I think our forest
like actually accepts allocators so you
can pull the same trick that you do that
can have a serious performance impact on
I saw delete in dark so I I don't know
what's that I saw a delete keyword in
there so in the forest source code I
delete keyword so I don't know if that's
doable with the forest into my station
ass yeah maybe not maybe not I I would I
would have to go back and look but you
know you could retrofit it for an
alligator if it doesn't already support
one I thought
but I could be wrong old memories but
yes I think that you could you could
build a structure that exploited the
same properties but had better locality
for operations thank you yeah so one of
the more well-established incidental
data structures is that of iterators and
the various containers that they iterate
through have you given any thought to
how we might sort of break that
incidental data structure set up that
permeates a lot of our code so I think
most of the issues there come from
misusing iterators I think you really
want to to keep your iterator usage
encapsulated right right the very fact
that they can become invalidated means
that that they they are in some sense
unsafe and must be used in with care
unsafe doesn't mean bad and recently I
wrote a little blog post about move that
you can find online that I think has a
beautiful little proof that says that
there's a fundamental trade-off between
safety and efficiency and provably you
cannot have both okay so that doesn't
mean necessarily that that's a horrible
state of affairs it just is the reality
now there's a lot that we can do to to
improve safety we've heard a lot at
about the libraries that herb and in
Viana announced where we can improve
safety without a cost of efficiency and
I think Eric Kneedler is going to give a
talk on Friday about the range library
and that gives us a higher level
abstraction to deal with iterators to
improve the safety around iterators but
physicians exist
and you know an iterator is just a
position into something and positions
are fragile and it's unfortunate but
it's the reality and sometimes you need
them right it's very difficult to have
something like a a safe rotate operation
where where you you don't just have a
ROM midpoint that's required to be
within a range so so there's trade-offs
there right we can do better
any other questions good okay so this
was the very first time I've given this
talk so I apologize for running a little
short I actually thought I was going to
run a little long but I think I talked
faster than I expected to but you know
if you have any feedback about it
approach me afterwards because I'll
probably repeat the talk at some point
so I'd like to get your actual feedback
in if you saw a typo on a slide or
something to that to me but otherwise
we're going to break for lunch or later</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>