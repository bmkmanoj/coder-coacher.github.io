<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Jackie Kay “Lessons Learned From An Embedded RTPS in Modern C++&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Jackie Kay “Lessons Learned From An Embedded RTPS in Modern C++&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Jackie Kay “Lessons Learned From An Embedded RTPS in Modern C++&quot;</b></h2><h5 class="post__date">2016-10-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mresWGsVHj0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone my name is Jackie Kate for
those of you who don't know me I'm a
software engineer at a small stealth
robotics start-up called Marble for the
past two years though I work at a
company called the open-source robotics
foundation it's a very descriptive name
we make or I used to make open-source
software tools for robotics including
Ross which is an open-source networking
framework and gazebo which is a physics
simulator for testing robotics
algorithms before deploying them on a
real robot
so one goal of that organization is
making tools that are accessible and
accessibility also involves
cross-platform compatibility which is
not something that those tools
previously really succeeded at so what
I'm going to talk about today is some
some lessons I learned from looking at
implementing a a cross-platform version
of the RTP S wire protocol with a
partial implementation of DDS I'm gonna
get into what exactly those are and
because you know this industry is full
of acronyms that don't really sound like
anything and a little bit but again
we're gonna kind of do some high-level
stuff here and talk about one of the
many problems in robotics which is
communication communication is really
hard and you may not know this but in
when dealing with robotics there is a
lot of computers involved and not just
the computers that are onboard the robot
and yes there are multiple computers on
board the robot so you're gonna start
out writing your code on your developer
environment your laptop might be a
MacBook Pro whatever might be think pad
running Linux like me you're gonna
compile it you might cross compile it
for a target for an embedded target or
you might compile it for an API
compatible Linux machine depending on
what you're gonna run on the robot
you might also talk to a cloud server on
stores offline data and the cloud server
might also talk to the robot taking data
or sending commands via a tell operation
interface so so this is kind of
important it's three node communication
three or more
really because you might have more
robots talking to each other and you as
I hate to do before you're gonna have a
lot of computers on the robot of
different classes those those computers
have a lot of different roles really
what a robot is is a intelligent
interface to sensors and actuators it's
any way how I conceptualize it and a
sensor is taking in analog data from
from an analog circuit and then
translating that into some digital
representation and a microcontroller is
is doing the reverse operation of
translating from information from a
digital interface to an analog
representation so so why am I getting it
why is this important how this is
relevant to what we you came here to
talk about well there's a lot of
embedded systems and and a robot is
gonna include you know maybe a couple of
these and what these are are are
different classes of embedded systems
and I wanted to just you don't have to
get into all the details but I wanted to
throw up some numbers to give you an
idea of the the diversity in the
spectrum of computational power that we
see these days so so when you think of
an embedded system you might just think
of a computer without a screen
I find this not a very useful definition
because there are computers without
screens that are as powerful or more
powerful in the laptop year you might be
using right now during my presentation
for example the Intel nook is a small
form-factor
intel x86 risk whatever device with 16
gigs of ram and when you compare that to
the bottom cloth on this table the
msp430 which I actually changed this
slide after Jason's talk I want to call
it the msp430 because he gave it as an
example of something that's roughly
computationally equivalent to the
commodore 64 and that's the kind of
device that we'd use in a wireless
sensor network when you need a really
low power device that might spend most
of its time sleeping and then collecting
data and then reporting that data back
to a central server so anyway we're
going to focus on one of these classes
today and it'll be this one so that's
this I think if this is maybe you you
have an MCU that has to talk to a camera
or some like non-trivial sensor and then
there's a driver that that then relays
that information to a central core
processing unit on a robot so this is
just kind of filling out some some
details you have operating systems you
have your you have text and you have the
Apple whatever I you know I preferred
the penguin over here too but each each
to their own and we're gonna focus on as
I said before the the classes that will
be associated with sensors and motor
controllers so I think this this outline
slide is like really common at cpp con
again this was in Jason's talk but just
with fewer details and I swear I made
this before I saw his talk the this is
roughly you know the layout of of your
computer there's the the CPU there's a
memory and that's connected to the bus
and the bus is connected to peripherals
and and your operating system serves
between the CPU the bus and the
peripherals and it provides really nice
things things that make coding a lot
easier it's gonna manage your processes
and threads your control flow it's gonna
allocate memory from the heap to
different processes and it'll provide a
unified interface for things like your
monitor and your keyboard your Ethernet
whatever things you interact with a lot
and when people are afraid of bare metal
development they're talking about not
not having any of that they really it's
it's what we saw in Jason's plenary you
know it's technically plenary it's when
you want to access these peripherals
you're just directly setting values and
registers
there's no abstraction so um I know I
think in the abstract I mentioned bare
metal development the abstract of this
talk did drift a little we are gonna
talk about working with an artist today
our real-time operating system I look
for to seye artists rtos is like way too
much of a mouthful so a real-time
operating system is
I like to think of it as a small
operating system with components that
you can can grab and put into your
embedded binary as you pick and choose
it is I'm graphically representing it as
a thin layer of operating system that
you can you can put on your device and
and what's cool about embedded
development is because your cross
compiling for a small target unlike when
you're doing desktop development when
you compile a binary and then you when
you execute the binary that gets loaded
into memory when you when you compile
for embedded you're actually flashing
the the device the computer with the
startup code and that kind of the sole
program that's going to run so you're
it's kind of like you're compiling your
own operating system but like everything
- so so most real-time operating systems
you can select some kind of sub
component of operating system
functionality that you need for your
specific application and I'm explaining
that because I'm gonna show you just a
really quick size comparison to show how
how thin a layer of real-time operating
system we're going to use rather than
using Linux so we're going to use the
size command size of the UNIX command
that gives you the size of a binary and
it gives you three outputs the text is
the instruction tape essentially of
assembly instructions that you're going
to use data is the see if I get this
right be initialized before runtime
variables in your program and BSF is the
the area of memory dedicated to
uninitialized variable stack allocated
variables so I'm gonna compare yeah
we're comparing here the size of the
Linux kernel to a test binary so the the
test binary is essentially using most of
the threading capabilities of free our
toss which is a particular real-time
operating system we're gonna use today
and we'll just the takeaway here is that
it's it's literally an order of
magnitude lower than the Linux kernel
and that's important because of the tiny
sizes of things on this previous slide
yeah okay so and just to keep things
really kind of specific when it's
relevant to talk about specific hardware
and a specific artist today we're going
to talk about you know CMS is or CMS's
wrapping free our toss on the arm
cortex-m seven and just like to expand
that out that's this like in this
wrapper around different real-time
operating systems that that are made up
for the cortex and family and as I said
we're going to focus on that class
because it's useful for robotics so um
now we're gonna actually talk about how
we're going to design a library using
modern C++ to implement this particular
networking protocol but I mean I'm gonna
kind of shy away from talking about the
specifics of our DPS and DDS today in
case you're really curious about
learning more about that I can just find
me afterwards and I'll tell you more
about it and give you some resources but
I think it's more interesting for this
audience to talk about C++ specific
problems so this is you know an overview
of what you know what you might get and
then complete set of what you might get
if you use C++ rather than C and you do
embedded development and and the reason
you know I I sort of vaguely ordered
this so that things that are considered
somewhat harmful or on the right and and
you've probably heard a lot of reasons
why these things are considered harmful
because they they incur a cost that that
you might not have asked for right and
that's what what we're really concerned
about is incurring a cost of something
that's not in our control STL containers
you can choose not to use those and the
reason they might be considered harmful
is because of dynamic memory allocation
but exceptions in our TTI
if you don't turn our TDI off you're
gonna get a cost for it whenever you
have classes or types in your program so
so you know we have some tricks we have
some compiler tricks for for reducing
code size so that the size of your
compiled binary can fit on this
relatively small space
the first two I think are
self-explanatory then they're kind of
some maybe one that I had no idea about
until I started putting together slides
actually is short younam's which chooses
the four freedoms that where you don't
specify the underlying type it chooses
the smallest underlying integer type for
enum storage and then there's this kind
of catch-all compiler flag you can pass
I think these are will work with both
GCC and clang yeah I only need
I only need one of those so oh s is a
maybe maybe you didn't know about this
it's rather than then optimized for
speed optimized for space because that
trade-off can actually be that that can
be a trade-off between those two so so
you know unlike maybe game development
we're not going to be optimizing for for
speed keep in mind and another so I
mentioned dynamic memory allocation and
I just want to say we're not gonna go
over all the the details of how you set
up your embedded tool chain today
because there's a lot of you know much
better resources online that you can you
read about and and sit down with and
like kind of tear your hair out over but
I wanted to give you as a taste of of
the fun that's involved in doing things
like modifying your own linker script
and and modifying vector interrupt
tables so so one thing is that that's
cool is if okay so whenever you interact
with a C++ program or when you when you
compile one and you you interact with
the linker you probably aren't writing
your own linker script but if you want
to limit if you want to set a specific
heap size and stack size then you may
want to probably modify an existing
linker script that's suitable for your
instruction format so this is an example
of how you would use the linker script
syntax to do that these are variables
that are set somewhere higher up in the
linker script and you also
probably very rare that you on desktop
computing that you're going to modify
vector interrupt tables but in case you
wanted to do that here's an example of
some assembly you can write to load
registers and memory to again limit the
heat memory and stack memory used by
your binary so now that we have some
tooling out of the way let's let's talk
about actually some some sepals put C++
code you can write and patterns employed
in this particular domain that I'm I was
interested in covering in this project
that I over take over oh I overtook yes
so at the very core of it the design of
a networking library I think is
serialization dealing with concurrency
and sockets and this is a very
simplified view of what might happen you
have an in-memory representation of a
struct of a message that you want to
send and then you serialize it to some
byte format that is agreed upon by the
two endpoints of communication and then
you have some function that stuffs that
serialized byte stream into a socket and
then that socket does some magic over
the internet or whatever networking
protocol you're using it sends it to
another socket which was previously
configured to discover the sending
socket and in this thread of execution
this this process represented by this
block has been sleeping or whatever it's
been doing it's been waiting for a
packet to receive a serialize with the
the byte stream contained in that packet
and then it gives the the process on the
other end
some nice in memory struct
representation of that message so DDS
stands for data distribution service it
is a distributed networking protocol
which means that there is some some
extra stuff on top of this to enable
those two discover each other on the
network rather than something like MQTT
where you'd have a central broker that
basically all nodes are configured to
listen to for internet for network
information so rather than having a
central broker all the nodes talk to
each other and it's kind of messy and
you get this weird mustache pattern I
don't know how that happened so we're
going to ignore those details in today's
talk because they're kind of out of
scope and talk about really common
patterns that might be more useful to
anyone who's implementing not just an
elaborate never eating library but you
know serialization happens all over the
place what I'm trying to say here so uh
here's kind of an old-school way of
doing this you you have classes and
naturally classes have a serialize and
deserialize message and maybe these
serialize and deserialize messages look
really similar so so what a lot of
people like to do is have a code
generator and this code generator takes
takes some agreed-upon IDL format IDL
standing for interface definition
language and maybe it uses some other
language or you to generate C++ sources
that have an agreed-upon API design and
maybe they inherit from some generated
message superclass that provides some
functionality so okay I really like
audience participation I should've
started doing this earlier who has
worked in the code base with code
generation okay so who has worked in a
code base with code generation that's
not you can see how someone would twist
this that's not like you know generated
by the compiler okay okay cool just to
get that out of the way so um so I
skipped ahead a little bit there there
there's a way of doing code generation
in C++ and it's I'm gonna try to show
that it's pretty simple and can be done
really really easily with existing
libraries and the idea here is that you
use define a serializable concept
and you provide template functions that
that describe how to serialize kind of
the the primitive types of your
serialization strategy and then you
basically use metaprogramming to iterate
over the fields of a struct and and
syria serialized those subfields of your
serializable message and then you do the
same operation on the other end with
deserialize as you read bytes up from
the byte stream so this this you know I
don't have syntax highlighting on these
slides and this is also complete
pseudocode this is like not
syntactically correct at all this get
fields of thing you're it's it yeah it
looks weird so I'm gonna show some real
code here and it might be too small so
to give you a point I am gonna present
some benchmarks and I'm gonna use an
existing well-established serialization
library which is the Google protobuf
library which was I I don't know much
about its history but I think it was
designed pre 11 so Jeff is nodding he
used to work there so maybe I can I
trust you I don't know so so this is an
example of some of the header that that
Google protobuf will generate and
actually realized I should show didn't
have this ready in my okay so I'll show
the IDL that you provide to generate
this it has the you know it has this
external format I've defined some fields
that are very creatively named and then
it generates like four hundred lines of
code to do some operations on it and
this is I'm scrolling through it very
fast I'm sorry but I just kind of want
to give a point that it's it's it has
generated a lot of code so this is the
first approach that I mention of code
generation
the second approach this is kind of one
way you could implement it using
to existing libraries basically we're
going to use boost Hana for limited
interest spec type introspection and
providing what we're gonna kind of
co-opted is the serializable struct
which is not going to be represented
using proper concepts sorry guys
and we're going to use a library called
serial which is a C++ 11 successor to
boost serialization which kind of has
its own problems that we'll get into
more later in the talk so this what I
like about this class is that it's both
it's kind of like its own IDL and its
own in memory representation or a C++
native representation of the type so you
don't have to have this type definition
redundancy that exists in this other
style what I also like about this is
that it's because it's c plus was native
you can do things you can you can define
your own kind of interface to this
Strutt while still conforming to the
serializable concept that we mentioned
it might be a little bit out there but
what I'm trying to say is if you make a
more complicated message type and you
have template parameters to it then you
can understand things about the message
through its template parameters that a
googol protobuf type will not have
because it was constrained by this code
generator that someone else designed
again we're using externally defined
libraries that we didn't make here but
we have a little bit more freedom okay
so for anyone who's confused about this
syntax
I'm using a macro that's defined in this
other library Hana that essentially
makes this message or this this struct
iterable if this too small can people
see it okay
it makes this struct iterable over the
its fields and and you can actually
define it externally so you can call a
different macro on the struct unlike a
normal looking struck
you don't so which which i think is cool
because that means you can you could
then externally make a class someone
else defined conform to my serializable
concept okay so so that's how you define
the IDL for this scheme and this is how
you implement serialization over types
that conform to what we're calling our
serializable concept really here again
I'm stealing the Hana struct concept and
that is this thing here basically I'm
saying only enable this function for
this this template specialization for my
serializable structs what we're doing
here is we're providing load and save
functions to serial our serialization
library to guide it to know how to
archive our structs into a serializable
byte serialized format we're invoking
this kind of like static port each over
the over the fields of our struct and
it's kind of silly because there's
serial actually already understands how
to serialize pod types or plain old data
structures so it doesn't know how to
serialize what's essentially a tuple
which is like a list of types which is
what we've turned our struct definition
into so what we need to do is tell it
how to iterate over those fields and
then it actually then knows how to
serialize the rest of our message and we
do a for the inverse operation of load
which is essentially deserialize our
message from a a byte stream and you'll
notice here that the
the type of the archive which is what
you can think of as the object that's
saving our serialized byte stream or
actually realized bytes about the stream
so load is basically taking its doing
the inverse operation of accessing into
the the kind of map like structure of
our Hana struct and I want to point out
that this is a really small file
I really didn't need to write a lot of
code and and this my serialization
system can now serialize and deserialize
any struct that is that conforms to this
concept let's see okay yeah so I think
that was like a lot of meta programming
and I glossed over a lot of the details
so for anyone who is not familiar with
these kinds of libraries you should
definitely check out Hana or MPL is the
kind of pre 11 where we did this I I
wanted to show you a benchmark over some
various file types using these two
different styles because I guess I think
it's common that people don't use this
kind of meta programming on embedded so
and and I wanted to just show that it it
can indeed fit in this limited space we
have for code size and it actually does
like a lot better for these particular
message types than the code generation
example yeah so yes it's always going to
be in bytes so the you know this is
order of kilobytes for all of these
these benchmarks and the benchmarks are
really just at this point saying you
know instantiate my my type stuff some
fake day
into it and deserialize that with some
extra stuff to make sure that the result
of D serialization doesn't get optimized
out by the compiler because that would
make for a really lame benchmark so so
that that's the actual process of
stuffing your user-defined when I say
user I mean user the library user
defined types there there's another kind
of tricky thing here which is that when
you are getting a packet off of a socket
you don't know what type you're gonna
get you do know but you it's it's in the
header of the packet usually and it it's
you know there's some clear mapping but
the point is that you don't know what
type you're going to get at compile time
you you have to do something to get the
right type at runtime and the reason
this is like might be like for some
people is that it it I think people will
probably immediately think you have to
dynamically allocate something in order
to make this happen
sorry so this is like again some
pseudocode saying what we need to do is
mean to fill in this magic comment
because i want to stack allocate my
message that is coming out of my socket
that produced some binary blob from a
socket and I want to deserialize it and
you know stuff from the stack allocated
message the data that was gone from the
socket now when I execute a callback
I don't execute some behavior that
operates on that message that we got on
the other end so this is one way of
doing it
basically you it's very straightforward
you
kind of there's some stuff missing here
but you know take the the star quotes
the start the commented outline here
place it with this you switch on the the
header you know you translate whatever
you got in the packet to an enum type or
some identifier you deserialize it and
then you know call back and and this
will work pretty well if there's no no
arguments that you have to return out or
no result that you have return out of
the callback and this is like really
straightforward because you know you
have a function the the type is known
the result of your DC realization is
known whatever but this isn't very
scalable and the reason that this isn't
you know generic is and the reason I'm
concerned about that is because I used
to work on a middleware where you would
provide user with this library and then
they would plug in their own types and
they can't just you know modify this
critical section in the library with
their own switch statement obviously so
so we need some kind of callback
registration and here's another you know
pretty naive way of doing it is you have
some callback map type and and it stored
somewhere maybe it's global or maybe
it's passed around to the the like
socket deserialization thread and then
the the user has a function pointer or
the user provides a function pointer to
the map based on some identifier and
we've switched from using enums to
strings here because I was kind of lazy
so you then when you you reach you have
to identify in the package structure
that you have a user defined to type and
then when you're in your switch
statement you have to say alright I'm
gonna look up my in my callback map what
what the function was and call it and
I'm huge disadvantage of this approach
is that the user has to basically
provide a some deserialization mechanism
if they're in the using this pattern and
they have to call deserialize themselves
they're they're providing the type of
the thing they're deserializing here
which is kind of nice because we can
still stack allocate the message but
there's a lot of room for error it's not
very it's not Ted constrained and and
that kind of bothers me so so I was like
I really like metaprogramming this is
fun
so can we make something that's that's
more generic and that works kind of well
so I thought a little bit about it
another really cool tool that that
everyone should use is a compile time
map so I thought oh we can you know we
can like match the the types of these
messages to a call back and then call
the call back
whatever it's gonna be great there's a
disadvantage of this that and we'll get
more into the code there's a
disadvantage of this approach that you
can't define the call back map that
registers are callbacks in a separate
translation unit from where the user
will register the callbacks and the user
will probably register the callbacks in
the main function well or in their own
user provided like library but I
actually decided this was like totally
fine because when you do develop
embedded development you basically you
need to statically compiled everything
into one binary so maybe it's okay if we
provide the user with tools that are all
like our header only so this is probably
not very clear so we'll do another code
example am i doing on time oh my gosh
okay so let's see this is one
implementation of the non non generic
approach I described where let's see
yeah it's you know very straightforward
it's almost literally what I wrote on
the slide this is
some attempt to implement the compile
time or the metaprogramming approach of
what I described so we have a we have
some some map structure that we can
iterate through and we okay so we store
the types of the messages we're going to
deserialize and map them to functions
that the user can register and then we
search through that map we haven't we
have to match the the type keys of that
map to runtime values which are the the
string identifiers or the but encoded
identifier for the message type that we
decode so the the user has to provide
the type that's the thing they're
deserializing the identifier to match it
to which is probably going to be defined
by our protocol and the callback and so
what we do is we store those in a
compiled time map and we also store a
sequence which matches a run time string
identifier to a type and that type is
actually a type value as defined by our
meta programming library and we do
something that is like you know kind of
questionable which is a linear search
through the map when we receive the
packet on D serialization and that's in
orbit so that we can then match the
header of our packet to the correct type
so this is like it's like fun to write
this is some syntactic sugar to build up
the the callback map and what it looks
like in the wild is like a really nice
API
you this is imagine the user is
registering their various callbacks and
they can basically pass in a lambda and
then they can find anything they want to
the lambda this is a benchmark so I'm
doing like some naive thing to make sure
that that the the inputs to the are
deserialization callback doesn't get
optimized out so and then because I want
to write fewer lines of code I decided
and I happen to have a latest and
greatest clang compiled on my computer
we're using destructuring I suppose with
17 in structured bindings here if
anyone's not familiar with that syntax
yet so so this looks really nice and
this is like maybe preferable to this
other approach I came up with which is
probably you know very low overhead but
has more room for for error on the part
of the user who writes these callbacks
that are provided to a map unfortunately
things didn't go so well when I actually
benchmarked it so I think thank god i
bench marked it and again this is a like
back of the envelope calculation the
number I wanted to see how it scaled in
the number of callbacks I didn't go up
to like 100 callbacks realistically I
think in a library like this you would
expect like around 20 callbacks but the
generic approach that I that involves a
compile time map it actually ends up not
scaling as well as this like all static
callback approach so that's like a a
valuable lesson at the very least I
think the lesson to be learned here is
you should just just benchmark things
and it's it's really obvious but I think
there's a there can be a culture of I am
going to write something that
I think will be that will work really
well and like pushing a lot of logic to
compile time obviously means things will
run faster but that's what I run or
compile down to a smaller code binary
size which is our goal here and the
other the other caveat here is that I
was using this library serial to
implement serialization that works
really well and it can actually be
extended to other serialization types so
it by default it uses its own binary
encoding but you can write your own
stuff to serialize to XML and JSON or
your own encoding which is what I do if
I'm implementing at a networking library
what I actually ended up doing is right
basically writing my own CDR which is
the art EPS spec serialization format
another acronym I wrote my own CD Rd
serialization format for this because
serial uses both are ttin exceptions it
uses exceptions it just as an error
handling mechanism and it uses our TTI
to as a part of its I believe it's as a
part of its encoding function so as kind
of like it as as a type identifier
because that's what our TJ's and so so
it's it's really not it's not gonna
scale well to small embedded devices but
it's a really nice interface and a nice
paradigm because of what I showed you
with you you can externally define
serialization mechanisms for structs and
I think that is a it's either there's a
library that is open source and nice
like that that is is it might exist but
I'm not aware of it if anyone is then
please raise your hand and mention it
now okay so that kind of covers part one
of what I mentioned are it's it's a
taste of what I mentioned goes into
implementing a networking library
sockets and threads is is
kind of a lot of stuff a lot more
acronyms so this is comparing how
different operating systems are gonna
manage threading standards and sockets
because actually all POSIX generally
refers to P threads and and Linux you
might have Berkeley sockets whatever and
and and the interfaces to sockets and
threads are gonna be different on
different operating systems in the arm
world which is what and in the arm know
OS world which is what we're talking
about today there is as I mentioned
before this abstraction layer between
different real-time operating systems
and those different real-time operating
systems provide thread threading
abstractions and there's also an
interface to this library called
lightweight IP which I've pronounced in
my head I'll whip every time sounds kind
of weird and you know this is like kind
of another abstraction layer for for
nice operating systems things that we
want but unfortunately there's not all
of the things that we want are
accessible and and that's why embedded
programming is hard right so we we have
some nice ways of dealing with
concurrency and threading in the desktop
computing world which includes standard
thread which we all probably really
appreciated when xi came out and then
this library called SEO which is the
kind of the de facto standard or that
the proposed standard for that the for
c++ and the the design of of SEO is
going into the networking ts so
unfortunately the the C++ standard
library provided by arm does not include
thread in fact this is a direct quote
from their user manual which is great so
and and this makes sense if you think
about it they don't want to impose a
an artists implementation on users of
the arm C++ standard library for
embedded no OS systems because the the
operating systems abstractions are like
a choice that you compile into your
binary but and also as a point threading
and concurrency is built into the
architecture of Ezio it basically I am
yeah I'm not a developer on as you but
I've looked a little at the source code
and there were basically wrappers for
different platforms for Windows and for
POSIX and before 11 they had you know
their own threading abstraction and and
the only requirement which seems like a
very permissive requirement is that you
need to implement thread join when
you're blocking on another thread for it
to finish execution so I thought you
know okay a fun example to show people
yeah so so wrapping sockets
is like yeah that's probably just mostly
API wrapping not so interesting but how
how hard is it to compare the
concurrency primitives provided to us in
you know this abstraction layer with
that abstraction layer which is
dependency of this abstraction layer so
that we can just like throw in Osseo and
standard thread and have super
cross-platform clean C++ code yeah so
that's the point
I just made and this is gonna be another
code except water
has this font size give me better okay
there we go
so the the CSS interface to concurrency
primitives gives us signals threads new
Texas event queues some kind of nice
stuff and and the way the API works is
through these things that look like
functions but are actually macros this
OS thread def thing yeah so it's
actually a macro and I was confused by
that initially because it's not in all
uppercase as some people like to do it
but it defines a another function using
the name of the function pointer that
you cut up you have passed to it which
was like not the most intuitive API at
first so I decided to wrap that in
something that looked a bit nicer which
is a thread that uses our III to take a
function and run run and then manage
signal handling so that any threads that
are blocking on it can can block
accordingly and then clean up
accordingly based on the necessary calls
that are needed by the artist to signal
to the kernel that it's done so this is
um this is a pretty standard and you
know short way of doing this there's
let's see you kind of step through
initialization I didn't make this
default constructible you what you could
do is have another state where you Divac
instruct a thread and
and once you pass it a function you
start running the function here what I
do is I use a lambda to wrap the given
function and type erase it to a
different signature basically the
threading library we're dealing with the
CM suspending abstraction it requires
you to start threads with a function
signature of boycotts are or contoured
star depending on where you like to put
the const which means you you can't you
can't modify the arguments which is
pretty important here and i kind of a
type of razor makes me sad but this is
just a it you know a requisite for
working with this library so you pretty
straightforward you you know recast your
thread argument you if it was null you
do something which might be thrown
exception but also right now it's just
terminate you call a function and then
you signal to any argue threads that
were waiting on you to stop and so
unlike POSIX where you can repeat
threads where you can interrupt threads
using like a particularly predefined
signal I actually define the custom
signal up here so so when when when you
call join on a thread object what you're
doing is you're you have a handle to
another thread and you're you block
until the thread represented by that
handle is done so the you the thread
handle that you have has a storage for
the IDs of all the other threads that
you're waiting on so to implement join
we want to check first that we were an
action weren't already signaled to
terminate because if you're if you block
after a signal has been sent
then you will probably just block
forever because you've missed the signal
you notify the thread handle that you
are blocking and then you wait forever
on that thread ID to the the other
basically the other threat of control to
send a signal to you and in in a more
complex situation and something that's
not just like a canned example I would
probably have more logic to handle time
outs so rather than actually waiting
forever I would wait for a fixed amount
of time and then do something after a
timeout but this is a minimal example
you might also want to handle other
signals but this is that's a I think
that's yeah it's an application oriented
thing and that's you know that's it I
think again this is a naive
implementation but I think joined is not
that hard to implement and our
implementation did introduce some
overhead so I basically compared you can
pull up another thing that I forgot to
this is gonna be great you can see all
about the monolithic directory
structures I went into this yeah okay
great so this is a can see example that
was again this is like showing the ship
an example of the the c style c emphasis
api yeah okay
and then the kind of you know cleaner
see postmodern c++ style implementation
of it so as you can see here the
callbacks or the the thread functions
are provided basically without the in
order to bind arguments to this you
would have to define global variables oh
no you you you would pass arguments when
you call the OS third created macro but
again there's a more kind of tie barrier
and casting involved to pass arguments
around so that's what i'm benchmarking
and and there is overhead in the Super
Plus wrapper but that overhead is kind
of expected because we've added run
obviously we've added runtime logic to
handle the threat signaling at the point
I'm trying to make here is that join is
is not hard to implement but I still see
why the thread abstraction was left out
obviously because the compiler
implementing lib C++ doesn't want to
impose a threading paradigm or or an
artists library on the users who don't
want an OS so then the artists
implementers would have to provide an
implementation of thread mutex condition
variable etc but they usually don't
in fact they usually don't have much C++
support and that's kind of rough because
these are nice abstractions that we'd
like to be made available to everyone
and I'm seeing into the future here
seeing that the networking TS depends on
threading abstractions and I so because
I've I know that I already feel as if or
have a feeling that the networking TS
will not be provided by the maintainer
zuv arm no ABI
live super flows and and that makes me
sad because really the what makes
innovation and and technology move
forward faster is if people have nice to
use abstractions in their hands that
that are fun to use and powerful and and
there's a bit more overhead that goes
into wrapping all this really huge
variety of libraries that are available
to us but but the point of finding the
abstractions in the right place is that
we eventually get rid of more overhead
that the users have to do and as I kind
of wrote here the text on this slide I
find really important that and I think
this is a really important distinction
between desktop and embedded development
is that the the the compiler is kind of
like tightly coupled to system calls in
a lot of places in the CFO flow standard
and system calls I mean operating system
API and
on embedded that's intentionally a
really loose connection or no connection
at all and I think kind of the language
designers are standards designers have
to think carefully about that
relationship and to me as a user I'm not
really sure that was kind of fun all the
way through but again I'm a user and not
a maker of these standards so who knows
so another point I kind of wanted to
make about my adventures writing this
library is that one one one thing about
this the specification for this protocol
is that it's very object oriented and by
that I mean the the language describes
objects hierarchies are kind of UML
diagrams between objects and it provides
this API that kind of looks like Java
and says you know you have let's say you
have a custom publisher that that
publishes type foo well you're obviously
going to call it food publisher rather
than saying you have a concept or you
have a you have a template you have some
generic thing that has that acts on data
in this particular way and and I kind of
think that in order to make these
standards and protocols easier to write
then people have to take a different
design paradigm what I find interesting
about DDS is that it there's there's
some places in the spec with like C++
specific language in some places with
Java specific language and then it's
kind of like well if you're gonna give
me a code example why don't give me a
full code example then actually give me
pseudo code but again this is kind of
all out of scope and if you have
thoughts on this then totally hit me up
after this I kind of already made this
point but this was a this is really fun
undertaking for me I'm
actually a hobbyist on this project
right now it's not my day job but I I
really strongly believe that if we're
going to make c++ on embedded happen
because this is like the year of CL also
embedded kind of like you know desktop
on Linux on we're gonna make that happen
then we need better libraries and we
need good libraries to keep in mind the
limitations that embedded system
developers have I want to be able to use
cereal for civilization without
exceptions in our TTI I want to be able
to use a lot of boosts libraries without
the kind of weird design gaps that
taking out those parts of the language
introduces but yeah questions yeah I've
never heard of but whether it's useful
or not is the separate question right
it's just should this new future be
freestanding of limitations and then so
to to repeat that it wasn't really a
question it was more of a point of
information some some people in the
committee and the audience have pointed
out there's language and the standard
for free standing start free-standing
implementations okay which I was gonna
ask is the the difference between a
free-standing implementation and a TS
hosted version okay
we should talk later but that's an
interesting point okay I can't read them
okay
more questions yeah I could I could sort
them lexicographically and then do a
binary search can they can the keys be
runtime determines yeah so when you say
extra luggage you mean
code size or just general resources or
oh this is most uh yes why did I say
this is the year people's well embedded
I also wanted to make the Linux on
desktop joke but seriously the this I
think this is like set by the CPG on
organizers one of whom is in the room
decided to have a keynote from Dan sacks
who's also in this room and a plenary
session by Jason who was writing code
for the Commodore 64 which is
essentially you know in the class of the
some of the tinier embedded devices you
can have so yeah I'm just observing that
there's like this agenda that the
conference organizers are pushing I
don't know if yes let's take more
questions thanks
yeah I would have to bench um he asked
have I considered using brigand which is
another TMP library yeah I would have to
do some batch more comparisons the so
like Louie put out those comparisons of
different TMP libraries first of all
have I would have to check that which
ones provide the functionality that I
need for patterns that I actually want
to keep because we showed it that at
least one pattern I was interested in
was not as good as yeah and and then I
would actually have to do like code size
analysis because I think his benchmarks
are just compiled time analysis so other
questions yeah okay
well we're better</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>