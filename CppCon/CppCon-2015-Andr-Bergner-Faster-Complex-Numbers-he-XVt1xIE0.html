<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: André Bergner “Faster Complex Numbers” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: André Bergner “Faster Complex Numbers” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: André Bergner “Faster Complex Numbers”</b></h2><h5 class="post__date">2015-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/he-XVt1xIE0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I have half an hour we need to talk
about complex numbers in C++ my name is
under Beckner and from native
instruments from Berlin Germany for
those of you who don't know how to
rebuild the music software so our
businesses sound it's like they're of
course so in so complex i was not
directly a topic but it could be if that
would be better implement at all you
would know more about that my background
is also a physicist so I broke it off
with this complex numbers in while doing
my studying and also we American
simulations but I come come to the
applications in a moment so I assume
everybody in the room knows what complex
numbers on but more this anybody who
doesn't know what a complex numbers
anyway say a just for the case i
prepared a quick summary so complex
number is just a composed number of
which is illegal in the negative part YG
converse of two real values and the
layers level we are two imaginary unit
the purpose that will property that we
have its minus 1 or the square root of
minus 1 and following from that property
of i we have the following algebra that
basically comes just falls out from that
property so adding two complex numbers
is like adding real American imaginary
parts respectively and multiplication is
a little bit more complex or complicated
operation due to the I squared you get
the minus here and little bit strange
behavior so it's but but still religious
again a complex non-muscle and so just
as a summary if you in case you didn't
remember so also just just another
picture so complex numbers usually if
you draw them you of course since it's a
real imaginary part you have offices
really access in the military near
excess or that's a complex plane and the
complex number is basically kind of a
vector in that plane which has like an
absolute
you in the face or angle so that's
another way of seeing complex numbers
and then you all know that like eddying
and multiplying then there's certain
properties so if you multiply two
complex numbers you multiply their
absolute values if you at the angles and
things like that so and you quickly have
depending on how its set up you can get
cut can get rotation in the in the
complex plane for instance so before I
come back to that and few words about
application so there's a big so actually
it's applications are basically
everywhere in any kind of engineering
and scientific fields so most obvious
one the signal processing electrical
engineering that's they are just
ubiquitous so there are complex numbers
are just fundamental so every kind of
process you model there it's that you
don't use if you don't use complex
number of you you it's everything gets
much more complicated physics of course
so unlike the Schrodinger equation in
phantoms or the base of quantum theory
is based on complex numbers so this is
like it's just fundamental there and in
many other processes they practice a
little bit esoteric so the Mandelbrot
set for instance is just an iteration of
complex of a map of complex numbers and
you just met ala Yeppoon of exponent and
then you get that nice picture which is
basically just a stability map of that
complex equation then falling from that
you have like chaos EU complex system so
that's a field I work in and there you
have a lot of complex numbers as well
and then also I found something like
radar system optical systems they use
complex number so it's just everywhere
and it's and as soon as you have
software and you work and maybe one of
those fields so in my case it was like
koce complex systems physics and now
it's mean it's the more less signal
processing in the case of audio you it's
pretty nice if you have if you can give
as complex number in the streamlined and
easy way so if you so if you do kind of
that stuff you are usually interested in
speaks so because you do you do numerics
and you want stop fast so because if you
do number crunching and usually when you
do number
if it's if it's really like stream
processing already out throughput is
important either you lose big
simulations and you want to have them of
course the costs for your simulation is
it's expensive you want to minimize set
on our case we do audio you want to hit
like the user should be able to run as
many synthesizers on as computer as
possible for instance or there should be
this should be possible so the slower
the whole thing gets the less so a
factor of two already means you can only
run twice as many twice as less than
their applications for instance on one
system so there is the standard so the
order sta i'm not i'm not sure quite of
it's really part of the stl or it's like
beyond the STA so I don't know with Alex
put it in or beyond and put it in or
somebody else but there is still complex
so this is a less little class that
comes bundled with the standard library
basically since back in the days at
least 98 I don't know when it came in so
couldn't find anything about that and
this gives basically access to wire
operator overloading somebody is a
classically C++ where you have a you
have a complex number and you can deal
with it in a streamlined fashion so
that's basically almost it so in the
mean usually if you do c++ I mean many
people used to do and when still do for
trend because everybody says for tennis
affairs and blah blah blah I mean this
is not really true to some extent it is
kind of true but you can get of course
the same performance with C and C++ but
you have to know what you are doing but
unfortunately a lot of stuff is just
filled in so but nowadays of course
Fortran is the sides of number-crunching
photons are pretty ugly language and so
a lot of modern scientists and engineers
switch to c and c++ which is basically
the only alternative out there if you
leave on speed for number crunching and
but then you're on your own soul c++ by
default only basically brings its stead
complex and there's valer e that most of
people don't know this is like a vector
of it which you can add and then there's
a numeric header and that's in the mass
and that's about it so there's not much
so a lot of stuff is developed like like
or the linear algebra numeric stuff it
comes from outside and there are many
many implementations or what they
actually have nice to at least that the
stuff that is here there should be a
little bit more in the standard and this
stuff should be at least working I come
to that later so M so that's how you use
it so for those of those who didn't know
that there is a complex number in the st
am so it looks like that so it's you
just include header complex and so even
see gotta some complex numbers now I
think it's C 1999 as a template
parameter say can specify float a double
in theory it should be possible to add
like also fixed point numbers there you
initialize with your wheel imaginary
part and there's also like a function
constructor that constructive complex
number from polar coordinates so from
the radios and anger which is specify
and it returns the complex number and
then you can just work with them in in
the mathematical way in the convenient
way you just multiply and Adam so all
the operations are overloaded so what
can you do with it so the like a nice
way to create a oscillator so really if
you need an oscillation so you'll be
really just a sine function for instance
it would be an oscillator just like the
fastest where you can write an
oscillator and C++ using this complex
class so yeah so a little oscillator
class has like two complex numbers which
is one is a state and the other one is
basically the updates or the speed of
rotation and then you just set your call
operator and just simply updates the
state by multiplying it with the
rotation and returns the rear part so if
you case your own interested in the real
valued oscillation and yeah and the
important part is the polar coordinate
is like the absolute value as 1 and this
would be the frequency so in the
property of the complex numbers is that
they start rotating the angles get edit
under the multiplication and the radius
get multiplied so the radios in that
case or the absolute value is once or
one times whatever the other one is
Stacy value of the other one and the
angles just get
forwarded by that amount this just gets
added to the angle of the state so
that's why it's rotating it's you little
picture Antonio sorry that has moved a
little bit anyway that's it just
illustrate it again so they physically
the complex numbers rotating in the
plane through that operation and the
real part would look basically I guess
so you get the sinusoidal output yeah
also just for the fun of it I add also
using C++ 14 you don't even have to
write a class anymore you can just write
a little function that returns a lambda
and using those initializers here you
can put the values right in there and
have just a lambda that computes the
complex numbers is just a nice little
even more compact way to write an
oscillator and C++ so that would be
actually pretty neat if you could just
do more mess that we compact and
streamlined fashion and just hope that
it's fast him so ok let's just think
again a bit more complicated so another
really interesting example I want to
give you is the complex or complex
resonator at sometimes called the Vedic
is the simplest possible way to
construct a bandpass filter so for those
of you are not known so much about
future theory and then filters ventas
rates are simply a filter it means or
when in engineering the defeat that
filters out all the frequencies except
for a certain band of frequency range
which you can specify for the filter
everything edge gets figured out so the
side is typically radio effect for
instance like old radio effect that
would be a band pass filter so let me
know kind of how it sounds like and the
quickest way again is using state
complex so you would basically the same
as oscillator before oh yes your state
and your rotation and now you simply
have an external state that would be
your input signal it creates the output
signal and the way it works is simply
you still have the same update but you
just add the input signal and just
naturally this event has returned your
perfect control over it so because the
radios kind of controls your bandwidth
of your band pass filter
the center frequency basically courts
and control it's a position in the the
frequency range so this is like this one
this one is also a nice property of that
band as without also that very stable so
it you can go down to very low
frequencies and you can easily modulate
it because it only depends on its last
state and not the second to last usually
if you go if you use like those stenner
GSP features or recessive also not one
history step more and then it gets
unstable under modulations but this one
returns stay stable so it's also why
it's nice to have complex numbers
because it's real not only that it's
that it's more streamlined it's also
pretty it's more stable and easier to
write so I had now coming to the
actually part so about performance I had
a little bit more complicated problem I
was just working on some time ago a
little side project of mine we're like a
filter bank and a bunch of those
resonators they were coupled with each
others and it was a little bit more
complicated expression so I thought hmm
because I had other problems before way
I'd like a little matrix vector
multiplication in the friend of mine who
so also of boost orient I told him yeah
I would like to use expression templates
here but he said no it should was just
work out of the box and then I I tried
it and it worked pretty fast but then I
changed it in a bit and sandy was much
slower and then I used the expression
templates and was fast again so I
certain I checked that I mean they are
simpler than just the matrix and vector
and maybe the compiler somehow knows
about them and so I just checked if I
just double checked with a head
corrected version so let's play review
so this is the same thing again as
before almost hidden numbers a little
bit different but this is basically what
the compiler should create for us so
this is how it should look like in
theory I mean I happen in the in the
example before I create a complex number
here and then a signatory assigned I
have to assignment operations now i have
only only one saw their own only one
temporary and then the direct assignment
so there should be maybe one move less
but that's about it so that's what I
would expect from a compiler that this
version should run at all just slightly
bit slower and but what I have seen is
this so the red one is step complex and
the yellow one is the hand crafted
version so i actually started out at
claim originally because i always use
playing i have a lot of templates
usually my code and clang is still the
best when it comes to optimizing
templates away but i know of course when
while preparing all of that i also
checked the other compilers and did some
more research how they perform what what
are the problems there so the we see
protein sources or run on this machine
basically so I just sent that resonator
you just saw was a whole big big signals
or adversary just Nyquist frequency so
alternating values and just measure the
time sort of timeless blocking your
milliseconds and of course that's
averaged over many many runs um so the
interesting thing is now a GCC the
handcrafted version is still I mean this
kind of the gap I would have expected
maybe a little bit less patent claim is
almost a factor of 3 and 0 to vc 14 is
still slower compared to claim so i
don't know which so it was run by a
while so i don't know which kind of
overheads it's eerie wine is not an
emulator so it should be as fast so it
should just wrap the cord to the win api
but i don't know so there might be some
overhead but my in my experience and
it's anyway that i haven't seen the
microsoft compiler perform very well on
performing numerical things or usually
has really a lot of more memory transfer
operations then required and especially
on recursive operations like the onion
so doesn't surprise me wouldn't surprise
me if it's really as fast as playing on
GCC what would surprise me that with the
fs so but yeah there's a big gap so what
i am didn't originally I did okay I
always wanted to do a little bit more
this expression templates instead of
looking into the details because I
thought our they must have done it right
and the
it's probably X to the expression
template from that the compiler just
cannot optimize it so who has worked
this expression templates okay so are we
half of this so just to give you a quick
summary of that or recap so expression
templates is it's a technique a very
common technique especially if you are
doing your break stuff so if you want to
have fast or if you are building an
domain-specific language so you want to
embed a customer language in your port
and that does computations at compile
time so it's one of those hardcore meta
programming techniques and the core idea
especially AI mean this was a think of
originally also meant it for like linear
algebra somewhere in the 90s so the core
idea is that instead of computing so the
idea is you don't compute the others I
eagerly you you compute everything lazy
so the other operations are overloaded
and instead of returning the result
immediately they return a proxy object
that encapsulates the operation and the
day reference to the operands so you
don't so if you call the multiplication
operator you don't compute the result
you just return a in a proxy to the
operation and the arguments and then if
you put that together with the next
operation you have a proxy to a proxy
that has all the arguments and
operations and it can be get very
complicated if you have pic expressions
and then they are collect a lot of meta
programming techniques to the leg speed
the whole thing up to make so to prune
the tree and then filter that and all
kind of sort of basically the technique
to help the compiler streamlining
operations or especially getting rid of
temporary variables and also like
getting rich unrolling for loops or just
having one for loop instead of many and
so on so for linear algebra usually
still gives you a lot of performance for
that I wouldn't have expected that the
performance is much better actually so
just a quick sketch of how that look
like for those who don't know so the
core idea is you overload the operator
star for your here for your left hand
right hand side so that with your
complex number for instance and now
instead of returning the results
immediately you turn a expression that
Slate's a somehow a tech or policy that
describes the operation and then the
left and right hand types and it stores
the references to the type so that the
expression could be as simple as that
it's just holding references and then
you have you need those three things you
need their variation of the expression
which called the operator on the
evaluated left and right hand side and
then you have a for beg for non
expressions which does identity function
and then your multiplication would for
look for instance look like that so that
has a member function apply whatever you
call it to apply its coil here so those
that apply which returns the actually
multiplication so and you stick that all
together in this you would overload your
assignment operator of your complex
number type so that if actually the
assignment would then call the eval and
the vibe will just go down the tree of
operations so we cause evolved on you
are in use of the left and right hand
side so if those are numbers numbers but
if left or right hand side is an
expression again it before the eval of
that expression and so on and so on
until you reach the Leafs and then you
in the end you get to pull result so
this usually makes makes it for the
compiler easier to get here to speed up
the computation just for the sake of it
i also thought okay of course I look in
the headers but I didn't scan really in
detail and usually they do a lot of
stuff so in the header so it's hard to
see what actually is happening sometimes
so I thought okay just let's make it
really simple naive so I called it a
naive implementation but which would be
the straight forward eagerly evaluating
implementation so that means either a
complex number of course I'm this
trivial or your real and imaginary part
the member functions to x sm and then
your for instant again the
multiplication operator would look like
that you just implement the algebra of
complex numbers or real part and just
computer so now measuring those results
it looks like this so this is all so
much it's very interesting so obviously
in the case of the Microsoft compiler
expression templates head
we needed compiler so this is the
greenish one is the naive implementation
which is still a little bit faster than
the one from the stip complex for some
reason and the expression template
version is almost twice as fast or
two-thirds maybe it's basically on
parvis head corrected version at least
for the Microsoft compiler the
expression templates really hip and to
speak up the optimization for the
compiler and of course still I mean the
obvious thing is if the stick complex
and pretty slow and clang basically as
expected would be the expression
template and that youth implementation
they are basically the same speech so
there's no different but still both are
slower than the and corrected version so
still the hand crafted it cannot compile
a doesn't quite get performance of the
handcrafted version interesting the
hosel at least the clang and the GCC
handcrafted version they are same speed
so at least though these are identical
so you can get the speed of of GCC with
splenda but you have to basically write
it out so you don't can use abstraction
but be one you're using sleep especially
because we want abstraction so compiler
should get better than that and even
expression template maybe I thought
about even overloading the assignment it
says so that you have a ternary operator
and then you could like the trick I was
doing with the temporary though it's
something like that maybe they are
something i could assume that you can
write some custom kernels for your
expressions that maybe get to the speed
but i mean then you start really lot of
engineering for actually very simple
problem so compiler should be able to do
that and you basically coming to the
next slide you will see that actually
compilers can do that but actually only
GCC has still again the best performance
so basically it's always this case from
my from my experience that if you want
performance and you have the choice to
choose a particular compiler and
platform always use GCC because it's
still the best so you see in that case
but of course you still see that gap
here so
I also looked a little bit in the
assembly output this is the assembly
output of GCC left hand side step
complex and right hand side a
handcrafted so it's basically the same
amount of operations but if you look at
the details you have just plain assembly
instructions and here is giving one that
they call it with some more dc-3 so this
is like really that is basically the
reason why at least also in the GCC case
it's slow on if you look at stood
complex from clang basically similar
things so this is basically your for
loop now just a bunch of operation and
here inside yet also again little call
and now this is really insane so that
function that gets called as this
function yeah what is it doing that's
the header so that's from the header so
that's when the standard header so this
is operator star yeah all right a star
in the header and you see it's like
training a lot of temporaries and then
it's checking branching a lot so of them
if none and left hand or right hand side
or both yeah and then it's infinite and
copy signed is now and again copy sign
again yeah it's really yeah exactly so
that what I found out so it's full I
Triple E compliance and for instance
then I was also searching little bit in
the web so it princes for trend doesn't
do that so then people were comparing
like c++ best Fortran and then again for
trend is much faster and blah blah blah
and but the point is that for trendy
stuff is not i triple e compliant so
they just do it as you would do it I
mean I I don't actually know about the
background of that so I mean in reality
from what I'm looking I can see there if
my number is really infinite or not a
number I I mean I'm screwed anyways and
then I don't care about it if they're
the sign is still correct or whatever
that thing is doing so I just want to
reside so I mean I have to take care of
myself
and also this is not in the idea of C++
so that I don't pay for stuff I don't
want so this is really not C++ mindset
if you Pro it like that just a quick
summary what I found in GCC saw this
little coin GC basically was a call to a
function it from the library of GCC
which is doing the same so then I found
out that they say actually there is a
little option in CPCC which you can
enable which called bath mats but only
GCC has this option and actually if you
enable that you get same performance for
all of the implementations so at just
one moment and so GCC fastest basically
now whatever you do save complex naive
expression template interested it's all
the same so GCC is stirred it was the
one that can can reach the perfect speed
and so you should see without meds we've
seen before and the other is like deep
for so there is not such an option but
just to get an overview of the
comparison so yet your your question
okay yeah yeah I would have checked that
if I had it so I when I was working on
the new site yeah yeah okay
yeah yeah the point is it's not I mean
this is it is kind of known it's for
porting okay yet so I the question was
there or the remark was that there is a
option in this the c-in-c that you can
disable enable that option by default
and into compiler is it enabled by
default so but the point is is all it
first of all it's not really documented
it's also not not you don't have that
option in the compiler me some sound do
it I'm down so it's you really have to
pray and hope that it works and plus the
overhead off I mean even if you're me
that if you enable it the handcrafted
version should be basically on purpose
no there there's a naive version or the
expression tablet version should be on
par with this is an crafted but we don't
get it speed unfortunately so okay no
basically my conclusions so standards so
on generate standard library is not
cream lined for a number crunching code
so you can do that but usually you have
to do it on your own so for clang there
is no such option I also from from the
code you see there was no if there for
anything and basically my room if you
using complex numbers on Clank don't use
that complex so if you want speed forget
it so this is like not not use a bit GCC
if you have GCC use fast math there's a
compiler flag then you get pretty much
really the best performance you can get
of course you can always do this the
next step what we doing simplifying the
whole thing but I mean I didn't want to
look into that just makes everything
gets more complicated and complex form
dependent and so in general also GCC
state produces the best code especially
if you enable that compiler flag and
yeah for cross-platform basically do
Burke your own so because and you and
probably even using expression templates
because if we have see as we have seen
and Microsoft comparable still benefits
from expression templates in general I
would say the standard should be
extended the i did with so the you don't
pay for what you don't use so state
complex should get like a little policy
that you can specify you
I tricky compliance or not and then you
enable it and it should be this
everybody for them just my point for
that and yeah that's very good so thank
you more questions I didn't show that
it's so the question was um you didn't
see where we're I took the advantage of
the power expression template i mean
what i thought was just a snippet of how
you would implement it and my
implementations like many many pages
long so i also i had a boost proto
version and then I had a handcrafted
were in order just to see how that so my
hand crafted expression time this way
slightly faster than the proto version
but basically both we're kind of
performing the same but I didn't show
that so this is really just if you are
interested and can give you the code
foot summary of what operations you
combine yeah I mean I what I did is more
or less a naive implementation of the
expression temperature I didn't do any
common just really come computing the
real at once so if in the end I call
real and then it computes the real part
of the whole full expression in one step
and then imaginary in one step instead
of having all those intermediate real
and imaginary parts in between so that's
main difference there yeah another
question okay then
yeah yeah that's right so and the
question of the remark was that it
actually doesn't bring much in that
example for that example actually the
difference was wasn't that great but I
didn't put it up maybe find that some
number of summary so they actually had
another test we had a much more
complicated expression and so this is
like the second row this is likely
expression template column and there you
see like four depending on the compiler
you see actually a lot of benefit also
for expression templates so twice the
speed or seven times the speed or two
terms so the if the expression gets even
really more complicated so this was a
really complicated expression there
which I was testing and that then you
get more benefit from the expression I
so the question was around for what what
did I try to be better and handcrafted
handcrafted was just really as a
benchmark was just a comparison so i
hope the compiler should be as efficient
as a handcrafted so there I didn't try
to improve anything no no I didn't use
any assembly at both the handcrafted
basically is the C version kind of so
how if you will castrate if you don't
have here if you don't have if you don't
have any kind of abstraction mechanisms
in the language you would write it that
way basically yeah so yeah okay learn
one the one last question
yeah I know I mean I didn't measure the
very ends and odd compared all that kind
of stuff I just did a lot of I but at
least I bootstrap the the test so I was
just running for the first and the
second and the fourth I was like
building a collection of all the tests
and I was bootstrapping them and then I
run them in different order and
collecting the results and then I
computed to the median and the mean from
that so no no I really i changed the
change of randomly choose at least get a
little bit better statistics it so i
would say then making space for the
second speaker thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>