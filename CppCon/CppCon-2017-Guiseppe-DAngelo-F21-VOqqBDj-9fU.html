<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Guiseppe D'Angelo “F.21” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Guiseppe D'Angelo “F.21” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Guiseppe D'Angelo “F.21”</b></h2><h5 class="post__date">2017-10-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VOqqBDj-9fU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Hit it.
Okay, thank you.
Okay, so my talk is about F.21.
Do you know what F.21 is?
Of course not, right?
- [Audience Member] A core guideline.
Yeah, something like that.
No, it's the core guideline
F.21, which says this:
To return multiple &quot;out&quot; values,
prefer returning a tuple or a struct.
Reasons about that are a return
value is self-documenting
as an &quot;output-only&quot; value.
Note that C++ does have
multiple return values,
by convention of using
a tuple, including pair,
possibly with the extra convenience
of tie at the call site.
And with C++17, we should be
able to use structured bindings
to declare and initialize
multiple variables.
For instance, like that.
Right?
I hope we all agree that returning
multiple &quot;out&quot; values is bad,
unless we return like that.
But my point is that, to me,
this rule, this guideline
should read like this:
To return multiple &quot;out&quot;
values, return a struct.
- [Audience Member] Woohoo!
(scattered applause)
Oh, thank you.
However, okay, I know
what you're thinking,
Footnote: Unless you need
to return a variadic struct,
for which we don't really
have a good syntax.
I'm sorry, you can't define
a variadic struct in C++,
so use tuple in that case.
Right.
Thank you.
(applause)
Wait, wait, wait!
(audience laughs)
Okay, sorry.
Wait, wait, wait!
(audience laughs)
Sit down, 3 minutes.
I have bonus slides.
Let me elaborate.
What's wrong with tuples?
There's nothing wrong with
tuples, seriously nothing.
If you need to pack multiple types,
multiple values, just use them.
However, my claim is that
tuples are to hammer,
like multiple return
arguments are to a nail.
I think they are wrong tool for the job.
In particular, why they are
the wrong tool for the job,
it is because they weaken the type system.
The other day Scott Meyers said,
&quot;What is the most
important feature of C++?&quot;
He said, &quot;It's the
terministic destructors.&quot;
Good.
The second most important feature is
a strong static type system.
If you start using tuples,
unwarranted tuples,
around your code base, you are
going to weaken type system.
For instance, now we've got two
functions, calculated sides,
complex number, those
true functions in tuples,
those two functions are now returning
the very same data type.
Not two different.
So, now you can compare a side,
to a point, to a complex number,
to a pair that contains
brightness and contrast
to your monitor, anything.
Yep. That static_assert holds.
And what's worse,
if you start collecting these
values of these data types,
now you start in getting
also the operations
that tuples defines between them,
even if they don't make sense.
So now I am able to compare
two complex numbers,
so perhaps they make sense.
But now I am also able to
compare a complex number
to a sides, which does not make any sense.
And I'm also able to
compare complex numbers
by using a less than,
which makes zero sense whatsoever.
Yep, don't do that.
So, what about structs?
If you use structs,
everything is fine, right?
You've got distinct types
every time you use a struct,
even if the contents are identical.
The small problem is that in C++,
they're still slightly
more tedious to use.
Why is that?
Well the problem is this.
If I'm using a tuple as a return type,
I just want to add,
like, a throwaway type.
I don't want to think about it.
Just aggregate these two
things together, I don't care.
Well, in C++ I cannot still do that.
And I think it's a mistake,
I think it should be fixed.
Because we have a perfect
workaround in case
the function is inline like that.
You just define the struct
inside, rather than outside,
with an auto, and everything's fine.
I've got an anonymous
struct that just works.
But if the function that you're trying
to return multiple values, is not in line.
then you can do that, you
need to find a good name
for the struct.
And finding a good name
can be problematic.
There's also another reason
why structs are kind of boring.
It's because not only you need
to give a name to the struct,
you need to give a name to
the members of the struct.
Right?
What I give for the foo-zo in there?
Well, (loud buzzer) oh
sorry, that's not an issue.
F.21 tells, use tie, use
the structured bindings.
Perfect!
When you use a structured binding you are
going to give names to
the members of the struct.
They're right there.
You just spell them out.
LastValue, offset, success, whatever.
Yep?
Now, for real, Thank you.
(applause)
No wait, wait, wait!
Bonus, bonus slides.
(audience laughing)
Still 30 seconds.
So, C++17 example.
Look at that.
That's standard from-chars,
it returns a struct,
and also it returns an out parameter.
Perfect.
Both? Both.
Yeah, perfect.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>