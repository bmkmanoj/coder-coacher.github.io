<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Viktor Korsun “Enhancing STL containers&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Viktor Korsun “Enhancing STL containers&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Viktor Korsun “Enhancing STL containers&quot;</b></h2><h5 class="post__date">2015-10-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/u-7DJb7hQqc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody my name is Victor Corson
I'm working for settle up currently I am
ahead of glenside development we create
computer games and i'll be talking about
enhancing estelle containers actually
I'm surprised that at least somebody has
come here because it's widely believed
that standard template library
containers are absolutely polished and
they are edl but I think that there are
some signs of that developers need some
more for example our company is always
in play implementing our own containers
constantly if we take a look at any big
project we can see that many companies
implement their own solutions and all we
must have got a USB Drive with the flash
drive with an a library and inside this
library there is on the implementation
of container store so people implement
containers and why why do they do do it
who try to implement their own container
programs you see almost everybody why
didn't you like standard to play it
library containers for example for
instance yes you like them but I needed
something with character 60 wow what did
you need basically a villager arranged
and value yes isn't you know when I
insert something with an overlapping
range the last rider always win
it's kind of like a set but there's it's
ranges of values with ya could you get
this behavior if you were added some
functions I lay it over yeah i think
that sand art library containers are
great really and they are good enough
for many employment for many situations
but sometimes we face situations when we
need something more and sometimes also
happens that we misuse standard template
library and dinners so here i would like
to show a few quotes from interview of
Alec stepanov initially author of stl
and then like I will speak further Alex
upon have said that standard template
library isn't object oriented and after
that he says that object oriented
development isn't that good and if we
get into details we can see that we can
seek a strong attitude towards this
so there are two ways two general ways
to design a program the first one is
object oriented design and the second
one is a generic programming and in our
company we create computer games so here
is a screenshot and what we can see is
greatly decomposed into object because
objects have similar features similar
behavior and generally the program
should be object oriented and everything
here is an object obviously and object
oriented development basis on these
principles let's take a look if I stand
at the plate library containers satisfy
these principles what's what
abstractions are they abstract yes
what's about encapsulation yes they do
what's about inheritance yeah but
generally not generally they don't have
virtual destructors and that's why
polymorphism is on the compile time and
what's about elements for containers is
it possible to implement abstraction on
them now
it's possible to implement encapsulation
definitely inheritance through pointers
and polymorphism for pointers but not
directly either raw pointers or smart
pointers never mind so is object
oriented developers what we need we need
just to insert an object into a
container to address it to work with it
obviously to remove an object and
ideally we want polymorphism out of the
box I mean not through smart pointers
not through double storing of something
and addressing through pointers and
whatever and that's why we want to
support all my freedom out of the
container so as I think an ideal syntax
as for me will be like that we define
Class A Class B and create permit Erised
container end at this subject is
possible with C++
any ideas how to open at that I'm sorry
Tina well we don't work with pointers
here where is a little bit yeah for this
game yeah because if we have a pointer
then we have to store this object
somewhere and how we can expand or
shrink this container dynamically how
can you achieve polymorphism pointers
that's a point but we could achieve a
polymorphism without pointers through a
reference to base class and if we
returned object B by index we could
return a reference to object a so it is
possible I won't dig into details but I
will briefly just explain one of the
possible implementation how to do it we
can implement a template method pushback
allocate memory and then add this
subject obviously but the interesting
point is how to access the object and
how to resolve the type without runtime
type information it is possible if we
create an additional storage of
accessors and while we add an object
into this container would eat and gather
for the subject so at the moment of
addition to know a type of the object
that's why later we can get this type in
runtime so this in text is possible and
in the model that I will show later I'll
explain how to do it but what we don't
need is to rely on objects layout and
memory because well we must to decide
either we do generic programming or we
do object-oriented programming
if we do object or event oriented
development then we don't need to know
where the object is in memory because
what we need is only to access it to
modify and we rely on abstractions rely
on interfaces for objects that's why the
container ideally has to decide by
itself how to store them so here is how
many programs use a regular vector it
has objects inside that are boxes here
it has iterators that point to this
object and free store by priests or I
mean an allocated store for following
objects inside vector so this is how
basically many programs use containers
in more than fifty percent I'm sure
because we need to store similar
entities and access and change them and
sweat them and we can use in it in our
game for example so what we do here is
we create a lot of animations a lot of
objects and then we have to slap them
change their order and here is a problem
because when we change the order of
object injector for example if we sort
objects and vector as you could read
from the description to this meeting the
complexity algorithmically should be n x
logarithm and in the goal notation right
but let's not draw because this
complexity multiplies by the size of the
object because when we sort objects will
not only change their indexes but also
will change their location in memory
but as object-oriented developers we
don't have to change objects in memory
we simply don't have to do it we eat
vector wants it well let let him but we
just didn't ask that that's extra
computations so if we create a vector of
objects and then sort them by any per
decade will lose non-performance is it
clear for everybody who doesn't tell y
ok and a possible implementation of a
more effective solution is usage of
pointers so pointer obviously can some
less memory than a usual object and
while we change their order I like bite
swapping in memory occurs less but there
is a problem here the problem is that we
have to start this subject and have to
maintain their lifetime so if we create
some container like game container
probably a character and we add a gay
ahead a gun something to inside it to
create a vector of pointers to the
subject this would work but if we want
to create these objects dynamically this
won't work because we again we have to
store this object somewhere and the
solution of this is what how to how to
control lifetime automatically of this
object
any ideas of course the reference
counting smart pointers surely yeah this
works almost as we won't accept one
thing and the thing is that if we take a
look at the position of objects in
memory that I shown like not natural in
a realistic way but it reflects this
situation we can see that these objects
are located somewhere in memory and when
we address these objects very often well
we miss these subjects in portchester
cash so these objects not necessarily
get into a cache line because we can't
guarantee where these objects are surely
on this machine for example with enough
memory this will happen not that often
because usually allocations will be like
adjusted to each other but that's not
guaranteed and the solution could be
either our own memory manager for this
like collection or for the whole
application but we don't need it what we
need is a simple collection of objects
and we want to address them and work
with them like in a dynamical and
polymeric polymer fiquei so this works
but this is not ideal and I suggest this
thing I suggest
storing objects internally and storing
indexes of these objects internally so
when we address an object we resolve its
address inside a container and then
address it but if you want to sweat
these subjects what we do with swap
indexes this should work much faster and
it does any questions about that that's
a simple idea but what we also want is
to support like the knowledge of C++
society I mean use libraries like
algorithm for that so if we want to do
something like sort or reverse who have
to implement it writers and as we have a
extra layer under our object we will be
having to implement an extra layer off
on like regular iterators like that so
it will be look like following our
iterators show two indexes of the object
and after the referencing these situate
errs we have some rappers that can give
us an access to object because by the
referencing iterators will be having an
internal offset so that it would be
possible to swept these iterators and by
sweeping traders will be sweeping
indexes rather than objects in the
storage provided that algorithm
functions will be working like like we
expect them to do so standard sort will
be fast reverse will be fast and
what we want actually we can even work
with the iterators directly and here is
a short demo I'll try to duplicate this
displays okay mmm lot of good let's give
it a try
better so the best way to demonstrate an
idea is to create an synthetic test and
i did that i created a object t actually
it's a structure with the 10 kilobytes
not 16 and 4 zeros kilobyte bytes of
memory and here's a predicate for
comparing comparison and here is a
vector of this object so what I do here
is reversed this vector then sort it
using this predicate and do 10 times and
the length of the vector is like 10,000
elements so let's start
compelling let's start I wrote that
started to make it obvious that program
is working because it works not very
fast actually it took almost 40 seconds
to do these computations so I don't want
don't know to what to do these 40
seconds let's stare at the screen yeah
I'm sorry yeah it's the bug man but in
release mode it's not much faster the
code is pretty simple the most
complicated thing is to measure time
using more than C++ wow it has finished
so it has taken 56 seconds the question
is which piece was disclosed I'm sorry
which piece in the code was the slowest
which piece of the code was the slowest
one right I think I not only think but
I'm much sure that this one so if I
comment these two lines about reverse
and sorting will be working much faster
let's give it a try four milliseconds so
now what I want to do is to substitute
vector with my vector that is meant to
be object Lecter it's not permit Erised
because it's in development state and
the I include after definition of the
structure T because later it will be
parameterize but now it's easy to
debug obviously while it's not and all
the other code will be the same except
the predicate who can we tell why the
predicate is different predicate is
different because our iterators after
differ the referencing return not value
but a iterator wrapper for getting value
so I call it subah traitor and after the
referencing this habit writer we
eventually get out early and let's start
it yeah thank you it's good ok so I'm
crossing my fingers again
well as you can see it's almost 50 times
faster and if we well we can check it
what's going on inside but I promise
that everything is underst I will show
the implementation of this class now so
the most interesting thing is
implementation of standard swept
function that is specialized by sub
iterator as usual we create a position
temporarily then we store it and then we
change indexes using this super traitors
also we define start operators for
iterators to make algorithm working the
same logics for iterators and here's the
implementation of this library I wanted
to show how to change elements by
traitors but I'm afraid we can't get it
in time so after presentation who will
be interested you might be directly and
now I'll show you a few slides
so here's another question and answer
for Alex deep enough if you told that
generic programming is good and
object-oriented isn't but i think that
object oriented library for objects
shall be designed in object oriented
manner like having regular virtual
distractor like having virtual operators
to give us opportunity to override them
and also it must be having a regular
object-oriented syntax rather than
global functions because I don't think
that working with object-oriented in
generic way a good idea and here is an
example of like it's a short short quiz
which code will be faster this is the
first one this is the second one so what
we have here is a set of strings and
then we just look for a specific string
at the set and we don't even compare
result with something so the question
what will be faster the first one it's
it's like Alex depan have suggested use
a global function and the second one is
a object-oriented one
what is faster there are obviously three
note for answers the first one is the
first example is faster than 200 the
second is a move faster the third answer
is they are the same and forth answer is
there is no answer surely he a second is
faster because for the first one we do a
regular search like with random access
iterators but we don't use benefits of
this data structure so I strongly
believe that an interface for
object-oriented library for
object-oriented container should be
object-oriented and without generic
element and this means that we won't
have to use algorithms and this implies
that we don't have to implement
iterators so an ideal object-oriented
library as I believe is a library with
object-oriented syntax and as I said we
don't have to rely on objects location
and memory about like the adjacency
because the object or entity actor
should store it by itself and the quiz
is how to make the code faster
what's happening here is feeling an
array of characters and we want the
final code to do the same but be a
little bit faster how to do it faster oh
you didn't tell us anything about
Fibonacci function yeah but lamented we
know how efficient is it yeah you didn't
tell us anything yeah it doesn't matter
because it's because we don't have
ability to change Bonacci function it's
inside Sam library and what we can do
with it is like to improve the
efficiency of this code what I mean mean
by this is that even regular arrays can
be faster in c++ if we don't rely on
adjacency of elements in memory so it
can be faster if we use the linemen
because addressing every single
character will be faster without
additional machine instructions and here
I have to switch this place again
so that's the code how it could be and
if you test this code if we align
characters with four characters in
memory obviously compiler will generate
less instructions and here's the output
so we can see that the second case there
is a one instruction less and this will
reflect in tests the second example will
be working approximately twenty percent
faster yeah destro but actually we do
mobile games and more mobile games
performance of every frame is much more
expensive rather than memory because
well most of memory in our programs
resources comes concern and some and
logics concerns much less resources for
example if we have 50 megabytes of data
of textures and sounds than only 50
kilobytes of data well it will be not
fist about 60 or 70 or even 200
so I shown this example to say that if
we don't rely on object's location in
memory that vector does then we can get
additional benefits from almost
everywhere from getting indexes from
storing objects using better alignment
and so on and we have some time I could
answer some questions if they are yes
yes yeah yeah the suggesting was to
assassinate fine function for every
container so that the function will be
instantiated with the most efficient one
and this will be more in terms of
current estelle library with with modern
start
so obviously a good implementation of
object-oriented library is a big way so
to make this library supported by every
compiler it should be like done a lot of
work and yesterday surprisingly we
implemented a very good solution a best
solution for c++ properties on workshop
so i couldn't find more something more
efficient on the internet comparing to
our solution and i think that it's
possible to implement a good
object-oriented library for like
containers that will be used by
object-oriented developers and i hope
that the amount of in-house
implementations of containers will be
decreased so here's my email and i'm
going to start this project and if you
want to participate with right and we
obviously will do a great thing
that's it thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>