<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Ben Deane &quot;std::accumulate: Exploring an Algorithmic Empire&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Ben Deane &quot;std::accumulate: Exploring an Algorithmic Empire&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Ben Deane &quot;std::accumulate: Exploring an Algorithmic Empire&quot;</b></h2><h5 class="post__date">2016-10-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/B6twozNPUoA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning I have 9 o'clock so let's
get started so apologies for the
grandiose title but it worked wonders
with the program for me to hear from
that apparently so this talk came about
I gave a talk turn this on
I gave the talk at work maybe a couple
of years ago now and it was based on it
was very much inspired by seán parents
seasoning talks and I had a slide in
that talk that said my claim is that
this is the most powerful algorithm in
the world and at the time I said but
that's another talk so this is the
result of that this is that talk so
still accumulate on talk about
accumulated will things and start off
fairly slowly gently so here's a
cumulate we all will know it and love it
perhaps one thing I found one thing to
notice here is that it looks like this a
lot of kind of value semantics going on
and perhaps you might think of other
copies but I in my experience I found
that compilers are pretty good at
optimizing those copies away I took a
look at this with an instrumented class
that you know counted copies and moves
and and compared to a version that I've
accumulated that used to kind of
explicit moves and I found almost no
difference the only difference was in
the very first input parameter pass to
the posture the function itself so you
know these are typical users and where
this is not what you're here for this is
this is kind of like what you think of
when you first meet the cumulate yes we
can compute you know triangle numbers
and factorials and this is very boring
but what else can we do so so something
else very simple we can do is compute a
maximum value again you're all here at
CP con so you all know this I hope
everyone's convinced this will find the
maximum value by the way ask questions
if you have any gender talk I'll try and
answer them or tell you that I'm about
to answer them in the other slide so we
could write min element in a value-based
sense and do something like this we can
also do things like accumulating boolean
values
and this is very similar to the the all
of any of a none of in the library
except without the nice shortcut
behavior so you might think why would we
do this
it isn't very interesting as it stands
but things become a little more
interesting if we look at the signature
of the function that gets passed to
accumulate so it had these types you
know perhaps we used to think of these
types of being the same but they can
vary so let's look at things when they
differ so here's a simple example a more
interesting case again accumulating
bullying's but in this case it's sort of
inspired by hopes of his favorite 10
lines of code we've got some kind of
weak point a cache here and we've got a
function to load you know we're asking
for a bunch of a bunch of things we want
to load into the cache now because
because get thing returns a shared
pointer which we can treat like a
boolean we can accumulate across the
things that we pass in and we don't
actually want the shortcut behavior here
because we're asking for all of these
IDs some a little bit some will be in
the cache some won't for the ones that
won't we actually do want to service all
of them and ask for all of them and get
back what we get back is whether we need
to service the requests or not so here
you can imagine making make async
requests actually doesn't work and kind
of presumably pushes a request on to
some other queue and then we know from
the result of accumulate whether all the
things are cached or not and we can call
a service service async requests so note
that so we don't want a shortcut here
and you'll note the order of arguments
to and here so we're not so where the
cached argument comes second and we're
always calling get thing so this kind of
pattern can be useful just because we
use many function results as if they
were boolean values in control flow
sometimes it's actual boolean's
oftentimes it's pointers could be zero
results of you know
compression tracheotomy is like a stroke
amp and you know we write boolean
operators for you in conversion
operators for our classes a lot anytime
we want to write if X and that means we
can use accumulate to collect those kind
of function values and again it's
similar to the standard library the new
algorithms but where we don't want the
short-circuiting baby ok so so we can
accumulate boolean values there's a
bunch more things we can accumulate and
all of these things have something in
common so joining strings we can
accumulate into one big string this is
very similar to building requests from
key value pairs if you think about an
HTTP request the headers or the
arguments merging JSON objects you can
imagine that we could accumulate a bunch
of JSON objects into one big JSON object
multiplying matrices is also something
we can accumulate so the question is
whether all these have in common and
what they have in common is that they're
all mono it's which you probably
remember because it's been talked about
a lot in conferences so basically a
monoid is a set of objects and an
operation such that the operation is
closed over the set it's associative and
there's an identity element and this is
exactly kind of what we need in fact a
little bit stronger than what we need in
some cases to accumulate things so
here's an example I was talking about
HTTP headers here's an example of
rewriting something in terms of
accumulate so we've got a we've got
headers here as a map of key value pairs
and we're just with you know this is
curl I don't know if you're familiar
with it but it's a C style interface and
we're just building up a list of headers
by appending a string of our on to our
header list so this is a raw loop and we
could rewrite it in accumulate style
here the we're just going through the
headers again and appending to the list
and we're accumulating list of headers
and the result here is that
it's it's one expression there's no
declaration and initialization split I
feel like here we here we you know we
declare curl headers and then we mutate
it here we just declare it and
initialize it in one line so this this
allows us to if we like to use almost
always Auto style so once you start
looking for mods they turn out to be
everywhere and any mode can be
accumulated so some examples just a few
examples additional integers
concatenating strings Union sets merging
objects of all kinds what we've seen in
the boolean cases housing is Aman ID
applying AI behaviors could be a monoid
composing images you know set
intersections optional is Aman ID and
once you realize that what you're
dealing with is a mono
ie that you can compose you have a
binary operation and then you can run
accumulate it can simplify your api's
this happened when I was at work and I
was and I was looking at a friend's code
and he was wondering how to he had
actually he wasn't even working in C++
he was working in JavaScript and he had
a list of objects and he wanted to kind
of merge them all into one object get
all you know accumulate all of the
effectively key value pairs in the
JavaScript object it all he had was a
binary function to merge two and I
looked at it with him and then I
suddenly realized well you know all you
need to do the binding function is all
unique because you just reduce in
JavaScript across the across the
collection of objects and that is
exactly accumulate so a type can be a
monoid in more than one way and the
obvious example of this is integers they
can be a monoid under addition they can
also be a monoid under multiplication
and the identity for addition is 0 and
the identity for multiplication is 1 as
I'm sure you know also any function that
returns a mind we saw the functions
returning she had put a which we treat
this boolean any function that returns
an one ID
can itself be treated as I'm one-eyed
because you can just aggregate the
output of the function and saying the
same thing in a different way map so if
if the value in a map is a mono forms
amyloid then the map itself is a mod
because you can imagine so so that's
really the same thing as the function
claim because if we think of functions
as regular functions that don't depend
on any external input then you could
implement
I mean theory you can implement any
function as just a map from inputs to
outputs alright enough of the abstract
algebra so why would we do this and why
wouldn't we just write a loop well one
thing I've mentioned is that when we do
this we we don't have a declaration
initialization split which is it is good
it's often easier to write the binary
function than to think about summing a
collection of things I'm gonna say
something for you know aggregating it
and it simplifies an API if you can with
your writing an API and you can identify
that a type you're providing to your
users form zaman I'd then all you have
to do is provide them with that merging
function that binary function and they
get you know accumulate for free
effectively and you also get incremental
computation because you can take you can
accumulate that parts of it where you
can take the result of accumulate and
keep on accumulating things into it of
course also we get the potential for
parallel computation if if we can use
something like ok that you know the
parallel can't part of cumulate perhaps
in in in the in modern c++ will be
reduce and its friends and if our types
are right then we don't have to just
accumulate things linearly we could you
know but since the mono da per ation is
associative it means you can accumulate
a bunch of things of
bunch of things over here and when you
accumulate the results you get the right
answer okay so this is sort of what
accumulate does it turns binary
functions into enery functions because
it allows you to operate over
collections with binary functions it
collects as we've seen the results of
functions whose outputs are monoidal and
in some sense because it's it offers us
this incremental ability it allows us to
treat part-whole hierarchies uniformly
so you can you can keep on folding
things in and that that in it's that
also allows us to do parallel
computation so a little aside about
parallel computation monoids you can see
here basically why parallelism works on
the more laid you've got identity this
is the identity doesn't matter if we
have anything here because we've got an
identity which is zero this is just
adding up numbers and you can see that
we get the right thing because the
operation is associative
here is another example of computing an
amine and this just involves keeping
track of the pair of thinks the count of
numbers and the sum and they keep track
of those separately and again we get the
right answer because the operation is
associative and we have an identity and
so reduce which is new in super 17 it's
really the same as accumulate except
that the sequence can be processed in
any order perhaps according to policy
and it works because of T but what you
get is you gain the parallelism but you
lose the type variation because to have
parallelism I think you need you know it
basically assumes that you're you're
doing a generalized sum of things at the
same type but if you're if you're
actually using things of different types
then there's probably a linear
computation required to keep folding
things in if you work in big data then
model is really are everywhere some
examples of that you've got regular
indicate averages top top end
calculations histograms
is just the bucket of you know a bunch
of buckets of values you can imagine how
to combine two histograms you simply add
the buckets together you know bucket
wise a bunch of probabilistic data
structures are also Mao's things like
bloom filters distributions hyper
log-log is a a data structure which
allows you to count uniques
probabilistically and again this is so
this link this is just a screenshot from
a good site which allows you to play
with hyper log log a bit the basic of
hyper log log is that you're keeping a
register file here and each one of the
values in this register file is computed
with a max operation according to the
observable bit field you've seen and so
it's trivial to merge multiple register
files you just do a bucket wise max and
that itself is monoidal and so the whole
thing becomes accumulate able but that's
beyond the scope of this talk so you can
end up it on your own time so mano the
semigroups semigroups are more nodes
with the relaxed with you don't need no
identity to be a semigroup you just need
associativity but they're the key to
parallelism and the other key is the
ability this ability to combine summary
data so for example with the
distribution stuff if you've got
district distributions can be combined
so if you if you've done expensive
training on your data set to form a
distribution let's say you you used you
have programmer salaries in Europe and
programmer salaries in the US and you do
training on both of those sets and you
you form two different distributions you
can you don't have to in order to
combine the distributions you don't have
to redo the training on the combined set
you can just combine the distributions
because that's what this that's what
monoids do for you anyway so that was a
little aside now let's get on to some
some C++ and look at accumulating other
things so right now accumulate works on
linear sequences
how could we make it work on
multi-dimensional structures so one
thing we could do if we had a binary
tree or something is just define the
linear traversal on it in the usual way
and this would work if we could do that
the nodes of the tree are still
homogeneous what if the tree was a
little more complex like let's say a
JSON object is a familiar example of a
of a tree a tree based structure that is
fairly heterogeneous so so here's
accumulate the cincture of accumulate
now the insight here is that the initial
value T is really dealing with the case
when we have an empty sequence and the
binary operation deals with the other
case when we have a non-empty sequence
so we really have two things we're
dealing with and this is similar to how
vectors and sequences of defined in
functional languages we can think of
sequence accumulation as as these two
cases so either it's an empty vector or
it's a vector consisting of you know
element plus vector so this is kind of a
recursive definition and if we think of
accumulate in this way it's the key to
accumulating nonlinear data structures
so here's an example of the accumulate
that we know kind of written in that
style so if we think of the initial
value not as a value but a function to
call in the case of an empty vector and
and the binary operation is of course
the other function of call then
accumulator looks something like this
now it's recursive we wouldn't use this
but this this is the key to getting to
accumulating on things so here is a
simple JSON value there's a variant and
if you're familiar with JSON I mean it
can just be these these six things ball
number string know or an array of array
of JSON values or a object which is a
set of key value pairs where the keys
are strings and the values are JSON
values so in order to
to accumulate this you know so in the
vector case we had or in the sequence
case we had we had two functions one to
deal with the empty sequence I'm going
to deal with sequence with something in
it because we have six options for the
JSON value here we need six functions
luckily these functions are pretty
simple so let's look at just
accumulating rendering a JSON data
structure with an accumulation so we
know how to render a ball a doubler
string and the null these are all
trivial we know how to render an array
all we do is render square brackets
either side and we iterate the array and
we render each value in the array I
didn't put up the code to join here but
you can imagine what it does it just
joins together the strings with with the
comma in between and similarly for the
JSON object how we render an object is
very much the same we render the the
braces either side and we just iterate
through the effectively the map and we
render the first the first the first in
the map is the string and the second in
the map is itself a JSON value which we
make a call to render okay so these six
functions I hope you agree are all
simple to write and then in theory all
we need to do is call our call our
multi-dimensional accumulate which I'm
just calling fold a shorter word and we
pass it these six functions to deal with
the six cases in the JSON value and JIT
and we pass it the JSON value obviously
so there is a way to write this function
all that I'll go through this is one way
to write it it involves a little
template or e so we've got it takes a
variant of some size in this case a JSON
value is a variant and it takes a bunch
of functions one to deal with each value
in that's possible in the variant and we
just delegate to this fold that function
which we which we call the which we call
with the the index is actually active in
the variant so in this case
remember that we're not providing an
initial value here effective it's
implicit in in dealing with each of the
six cases okay so this fold at is itself
a function which ends up now in my
formulation here I have a recursive
template definition coming up there may
be better ways to do it but basically
we've given six functions were given a
variant and we know the active index in
that variant and so my basic what I
basically do here is form the index
sequence for those for those of size six
and step through until I hit the one
that's equivalent to the index so that's
what this is doing so this is my
function list I'm effectively coming
down the function list here's the head
and the tail of the functions and I'm
saying if actually I'm not forming an
index sequence if someone has a
formulation that does form in a sequence
it might probably faster than the
recursive template definition but so
this is the variant index and we're
saying if if this is equal to our
template parameter then we must be at
the right function and so we just called
the function on the and getting the
value either that there int otherwise we
brokers and we just go to the next
template and the final you know the the
end case is that this actually never
gets called but if we run off the end it
never gets called because of the static
assert saying that we must have enough
functions to deal with the things in the
variant but if we run off the end this
deals with the recursion this deals with
the termination of the type recursion in
particular because the return value R
here is is needed
because it is computed from just
assuming that these things over sir or
return the same type
I just compute it from the result of the
first one
yes F and F F F F s are cool objects you
know not storing them yes oh so there
yes that is their advantage to
forwarding rather than conference right
so yes i'm using i'm using forwarding
references here the comment is that
maybe constant references could be
usable but then if the thing doesn't
have a Const operator a call operator
then that would work so yes and it would
be a compile error indeed so basically
this this little bit of code is just
saying at the end of the day
take your variant take a bunch of
functions and whichever value is active
in the variant called the appropriate
function on that value and then write so
because it's recursive now presumably
the function itself then ends up
remember the recursive definition of
like printing the array or printing the
JSON it would then result in rehearsing
and accumulating the variant so when you
look at the sink of this function it
looks a lot like visitation and it is
fairly similar so I mean from that sense
accumulation is perhaps not that far out
of our everyday you know experience
so this this is a generic accumulate for
variance or at least one formulation of
it and but if you don't if you don't
have a variant if you just have a
recursively specified data structure in
some way you can still accumulate that
using the same the same idea basically
you have a function for each possible
sort of in functional language they're
called constructors but each possible
thing that you could have in your in
your data type and use this kind of
visitation pattern to accumulate the
thing recursively yes yeah right right
so the comment is yes you need n
functions for your n possible values and
so your visit your recursion here the
way I've formulated the in terms of
recursive template is order n I'm not
claiming that my formulation is the best
I'm just saying here's what's possible
with accumulation so I welcome anyone
who has better ideas to make this faster
okay so so Vinson has the experience
that a similar thing he used actually
was well optimized by the compiler to
something like a switch statement
okay so you think why would we do this
because it separates the traversal of
our they structure from the operation
that we need to do on it and as you as
you could see writing those rendering
functions were as trivial and having the
way to just run them over the data
structure allows us to you know separate
out what we're doing from the traversal
and so we could do lots of other things
so we saw like rendering the tree as a
string we could compute things like
depth resort depths or fringes of trees
we could you know looking further afield
we could do things like lighting
contributions maybe and if you have a
quadtree our NOC tree something like
that you could do sing graph operations
and the list kind of goes on you know
these are these are typical recursive
data structures in my line of work I'm
sure you could think of your own so this
this technique is useful when you have a
kind of a heterogeneous hierarchy that
might be difficult to define a linear
traversal for you know if you have a
plain binary tree you might still want
to provide a linear traversal of it you
know depth-first or whatever but but
this is a heterogeneous way to do that
so we've seen how to accumulate you know
a cube a gives us accumulation over a
sequence that that's it gives you that
technique gives us accumulation over a
heterogeneous hierarchy let's look at
heterogeneous sequences okay tuples if
you like
so this accumulate again so type 1 and
type 2 here - the binary operation might
be different so what this is saying is
that we know how to fold values are type
2 into type 1 so what if we just allowed
type 2 to be different every time and
the accumulator accumulator stays fixed
but we know that this is saying we know
how to fold all kinds of things into the
accumulator and there's one obvious
example of this which is practically
ubiquitous and it's just outputting to a
know string effectively this is saying
we know we now have to fold tons of
things into a no stream we know you know
we write these functions every day and
so if
had something like this a fold for
tuples then we could expect output like
this so in this case there's a generic
lambda which just says you know we know
how to fold a ton of things into an ova
stream and there's a tuple and we we
call fold and we pass it the tuple and
then our initial value here is actually
C out and then and then it just ends up
outputting all that stuff to see out now
this is possible as well in it and and
one formulation of it is very similar to
the the variant thing that you already
saw now one one thing providing C out
here I had the thought that I could we
could structure this function to to take
in some sense the empty tuple rather
than you know what we saw before with
variant was we didn't have an initial
value because we effectively that was
implicit in dealing with every case that
the that be some type the variant could
be in in this case there's a choice
between either providing the initial
value the initial oh stream here or
somehow you know making that function
deal with empty tuple and that would be
the case where we provided effectively
the initial value either way as possible
I think this way for this use case is a
little cleaner and and the fold for
tuples look something like this
I'll leave the implementation that's
next size to you guys it's quite similar
to that to the variant style it's not
too difficult but actually dealing with
streams you know because they're non
movable does take a little tricky Ness
and that's the reason for the deco type
although though they had to have in
there okay so so what we've seen so far
so accumulate gives us you know one
function and we can relate over a
linnaeus a linear homogeneous structure
if we do the the nonlinear that only the
linear tree traversal just on our
homogeneous tree structure we get
something very similar
if we have a accumulate over a variant
then we need to provide n functions to
deal with the N values that could be in
the variant but it allows us to
accumulate the multi-dimensional
structure and the heterogeneous
structure and then a tuple is itself a
linear structure but it's a
heterogeneous structure also so again we
have effectively n functions although it
might be a function template like like
the Alpha things in the iostream so this
is the Empire that we've got so far and
all of these could be parallelizable
given the appropriate semigroup
structure you can imagine that you could
break off parts of if you had a JSON
object a very large tree or something
you could farm out sub trees and
parallel ice those operations and then
you know given those results you could
accumulate those results back up on that
on a different process okay so naturally
the question arises at least to me if we
have accumulate what's the opposite of
accumulate so if accumulate is somehow
folding up a data structure to produce a
value then the opposite would be
unfolding a seed value to produce a data
structure and this is something we don't
see much in C++ yet parsing yeah but I
mean a lot of these things can be viewed
if you view it through one lens they
look one way and if you view them
through a different lens they look at
another way and which he chooses is down
to you
so if accumulate looks like this then I
think perhaps unfold as I'm calling it
looks something like this so it takes a
function and it takes an output iterator
which we're going to write to and it
takes some kind of seed value the
initial value and the idea is that we're
going to call the function repeatedly
with this initial value that that
reduces over time I'm going to write the
results to the alpha iterator
so so the question this what should the
signature of F be and how do we know
when we're done right so these are two
questions that arise so f is going to be
the opposite of the binary operation
that we pass to accumulate so if we kind
of just invert that it means that we
return the pair the result is going to
be the thing that we write into the
output iterator and then it's going to
return the new value of our seed that
we're going to pass to the next
invocation of F and in general the
result to write to the iterator could be
a range or a sequence of values so it's
not just necessarily just one value but
it could be you know it might not just
be a char for instance it could be a
string to write into the the string that
we are unfolding to so there's a few
choices over how to define F choice one
or house--it so I should say how to the
other question which is how do we know
when we're done right one choice is to
say well we'll we'll have some sentinel
value of of the same type as the seed
and when the seed reaches that value is
returned by F eventually then we're done
we could also say we have a sentinel
value of the the other type that the
function returns do you know that the
second part of the pair which is fine
but both of these choices involve having
a sentinel value inside the type and
from my talk yesterday I don't really
like that the obvious choice to me in
this case is to use an optional because
that provides you with a sentinel value
which is outside of your type so if F
returns an optional we can simply
terminate when it returns no opt so this
is what unfold might look like the
function so we're taking the seed value
and we've got a full loop initially
we're calling the function with the seed
value
oh here is an optional and you know it
has a conversion to boolean whether it's
a null opt or I should say that that
fails when it's a Mel opt and we know
that we can we can keep we can move the
second of the pair that was returned
assuming that assuming that F returns
something it was a pair of range to
write to our output iterator and new
seed value and so inside the for loop
we're simply moving the range to write
it to our output iterator and the for
loop terminates when we return null opt
and you know each time round it recalls
with the new seed and finally of course
we return the iterator the output
iterator because the law of useful
return makes us do so that we should do
that otherwise the caller wouldn't know
where the outputted toreador was so
here's a very trivial example this is
this is a function that we might pass to
to unfold and this is a function written
to turn a you know an Arabic number into
a string of the Roman numeral and you
can see that although you know Roman
numerals aren't that great
hence this function has a lot of if
statement but this function I hope you
can see is fairly trivial to write you
just you just go down and down and down
and you're reducing the seed each time
and you're just outputting whatever you
need to output and then you're calling
code just looks like this you just
unfold that function over you're over
your seed value and what you get back is
the string so that's a that's a you know
fun little formulation so you know
Marshall I said when I said about
unfolding Marshall said he call it he'd
call it pausing fold and unfold really
are the same if you if you kind of look
at them through different lenses so you
know or accumulate
we're conventionally we're taking a data
structure and we're reducing it to a
value and and unfold we are taking a
seed value and expanding it to a data
structure but really the seed value
itself is sort of you know decreasing
each time so you could say we're taking
one data structure and transforming into
another with either of these
formulations
and you know which you choose to use
it's really a matter of convenience as I
say structures are themselves values in
this view of the world so between them
you know accumulation and unfolding
allows you to do generalized sort of
data structure transformations yes yes
oh right right right yes so parsing
thinking about the Communists if we
think about a JSON you know the JSON
thing we'll be talking about the example
I presented was was accumulating a JSON
value and producing the string of course
going the other way is exactly pausing
the string to produce the JSON value so
that's the end of the main part of my
talk but I have this PostScript which is
kind of so at this point does anyone
have any questions no great well alright
so I have a postscript which is kind of
how this talk came about which is titled
the fruits of algorithmic perversions so
I woke up one morning and as you do I
thought to myself if I was stuck on a
desert island which algorithms would I
take with me what are the building block
algorithms in the STL now I've watched
Shawn parents talk so like it like we
all have and so you know maybe it party
we talked earlier about partition rotate
reverse these are all building block
algorithms in the STL if you know maybe
there are some others so I thought which
algorithm is the most powerful and what
if I couldn't write any loops except for
just one to implement the one algorithm
and I was stuck with that and which one
would I pick and so that was what led me
to to try out accumulate so I so I did
so I looked at all the algorithms and
here they are the the priests 2 plus 17
this there's 90 of them I believe now
some of these we can just remove
straight away swap an ear to swap they
really aren't loops so so get rid of
those one these in particular Stefan
would make an angry face at me if I
implement it so I got rid of random
shuffle and then of the remainder some
are sort of binary search style things
which aren't really amenable to linear
traversals and some are heap operations
which also involve jumping around inside
your sequence but of the remainder there
are 77 that remain these are basically
plain loops and with a bit of
jiggery-pokery and bending the rules I
was able to implement all of them in
terms of accumulate how long did it take
me you know probably a few weeks maybe a
month of evenings something like that
just just on the off you know sort of
thing so one of the key things that
unlocked it was so so of course the
cumulate does work on iterators but the
one thing I so we dereference the thing
that we passed the binary operation here
and if we don't do that know that I'm
suggesting that you know the SDL should
be updated at all but but just
reformulating humilate in terms of in in
this format allowed me to treat
iterators as accumulator with values and
that's what allowed me to implement all
the rest of the algorithms
so now I'm the first to admit that some
of these some of these things are little
abusive using exceptions for control
flow it's not something I usually like
to do but you know for things like find
which have the early-out
I did do that reverse reverse I was
particularly pleased with it involves
accumulating a function and as you as
you step down the forward iterator you
wrap the previous function that you've
accumulated a new function and then at
the end you call the whole stack of
functions and it unwinds the sequence in
Reverse so the point of this really is
to say that when you do kind of
algorithmic perversions like this
interesting alternatives can arise you
know I'm not suggesting that we should
ever actually use those formulations of
reverse or use exceptions for control
flow but you know with when you start
looking at accumulate you you realize
that you can do other algorithms like
find all you know parallel find if a
parallel adjacent find might be possible
min element that returns an optional
value might be an interesting
formulation and all sort with forward
iterators in fact there was a I think
p227 was a proposal that that proposes
weakening the iterator categories of
some of the algorithms like sort and I
think what do you remember the others
Marshall okay great okay so that so
there's an interesting paper that
proposes weakening the iterator
categories because right now sort
requires a random access iterator and
you know we know algorithms that can
work with forward iterators so that
would that would be an interesting thing
perhaps
so the really the conclusion of this
talk is that I would I would suggest to
you that almost everything can be
expressed as some form of accumulation
when I when I go hunting for raw loops
in my code base I I found increasingly
that I was you know as well as saying oh
that's a that's a find that's a
partition what that's a rotate kind of
the overarching thing would be that's an
accumulate that's in the cumulate you
can do that with accumulate that could
be in a human later now these should
everywhere that's for you to decide but
when you get used to seeing these
monoidal patterns and things that can be
accumulated they end up everywhere here
are some links which you can peruse at
your leisure
they'll this will be in the slides of
course so oh you wanna take a picture
okay so so really so anytime you write
an API look to see if any of the types
you're providing are more noodle or or
under any operations you provide because
if you can identify that and document it
then you open the opportunity for your
for your use of your API to get all this
stuff for free look for opportunities
where you're applying a function in a
loop if the output the function is a
monoid it could be a place where you can
use acumulate moloids are everywhere of
course and think you know consider
folding over heterogeneous sequences and
multi-dimensional structures using
formulations like the ones i've shown
they can be useful too and what that the
use they give you is effectively
separating the traversal from the
operation you can go ahead and define
multiple operations and treat them the
same way in the traversal and then
unfolds are another way you can think
about things and you can combine them
out with folds to produce arbitrary
transformations and finally algorithmic
perversions I highly recommend looking I
highly recommend looking at the STL
and trying to write your own algorithms
and Marshall has a talk about that later
and in the end accumulation is not just
for the boring stuff so thanks very much
okay so Marshalls comment is that my
algorithms are more interesting than his
I'm not sure that's fair but anyone have
questions yes okay
so right so you can't always use so the
comment is the comment is sometimes you
have you try to use accumulate but you
can't because you don't have iterators
so the the non iterator accumulate or
the accumulation over things other than
iterators is pretty useful and worth
generalizing you think okay so other
examples of unfolding actually I
so unfold this is a it's a thing that
happens in in functional languages and I
went to a friend who's a pretty is a you
know pretty of a with with that kind of
thing much more up-to-date than I am and
I and I asked him you know at a
functional meetup group I said it looks
like unfold is very similar to fold what
where would you use one and where would
you use another and in typical fashion
he said well they're both you know
they're both sort of implicit things you
can do on a sequence or they he he gave
an answer which wasn't terribly
satisfying I think it makes sense
maybe it makes sense just by convention
for thinking about the either reducing a
date structure to what we might think of
as normally a value or unfolding a seed
I mean it's similar in some sense to
generate or generate n when you're when
you're but then you're you know you're
using a seed value you're calling a
generator function to fill in the
sequence I don't have a hard and fast
rule to say you should use this unfold
here and accumulate here but they are
quite similar yeah you'd call it Factory
yeah so so unfolding pausing making
objects in some way Deepti serialization
right in the back there so factoring a
number could be viewed as unfold in a
highly unperformed as they come in
yeah I have a feeling that when you fact
that you know factoring a number is a
pretty well well well understood and
attacked operation and I doubt that
unfold would be that's true a new
approaches new approaches and as they
are rhythmical versions a good thing
yeah
so the comment is that the folding
heterogeneous things looks really
powerful similar to composing functions
yes
function composition is a mod so so you
could you could do that and well yeah
maybe I mean as STL 2 is you know coming
perhaps write a paper yes that's true if
there's an implementation which which
you can show that the committee is being
used and solving a problem that that
does a lot to to gain their attention
yes yes the the searching stuff that
Marshall did for 17 is an example of
that also I would say the special math
functions are an example of that there
was already you know special math
functions aren't something that I'm
likely to use him every day but there
was already you know there is a
community that wants them there was
already a high quality implementation
and on the reverse side you know the the
the implementation thing is there one of
the reasons why concepts aren't yet in
the standard but still in the TS because
there was not enough implementation
experience yet yeah
right so the observation is yes
enclosure if you've watched Ricky's
torque on transducers and followed that
stuff you'll know that transducers are a
a similar thing where that's sort of
teasing apart traversals from from what
you're doing to the data structure and
in similar fashion everything can be
implemented in terms of fault and
transducers yeah this is this is very
much
you know I'm cribbing everything from
functional languages here so but
hopefully you know giving it a C+ spin
and and showing where it might be useful
was there a question over here okay so
yeah that will be interesting so so the
idea is if you formylated unfold in
terms of a pull rather than a push you
could have well the example given was an
MPEG decoder pulling frames off a cue
that would be an interesting formulation
all right well thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>