<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: John Lakos “Value Semantics: It ain't about the syntax!, Part I&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: John Lakos “Value Semantics: It ain't about the syntax!, Part I&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: John Lakos “Value Semantics: It ain't about the syntax!, Part I&quot;</b></h2><h5 class="post__date">2015-10-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/W3xI1HJUy7Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay I guess we're about ready to get
started I'm getting a little bit of a
late start because Andre was very
enthusiastic about what he was doing and
so was I and I'm probably part of the
reason why he ran over anyway my name is
John Legos and we're gonna be talking
about today sort of basic material on
value semantics and then in the next
session which I strongly encourage
people who believe that they know
everything that I'm going to talk about
in this session come back and tell your
friends because that stuff is really
cool now about the same time as
Alexander stepping off was writing this
book I gave a talk at the ACC U does
everybody familiar with the elements of
programming this is an interesting book
about 2011 I started reading it and I
got all the way to halfway through page
two and got stuck and the crazy thing is
I carried it in my bag for three years
saying I'm gonna get through this I'm
gonna get through this it's not that bad
you know and then finally Pearson asked
me to do an interview on Alex's second
book so this is for Alex stepping off
here's the plug from mathematics to
generic programming and in order to read
this book because I'm a kind of a
bottom-up guy I had to go back and read
the other book which is part of the
reason I accepted the challenge so I
went back and read the other book and
strangely enough the first chapter of
this other book says almost exactly the
same thing that I came about from a very
very different perspective which is
quite heartening so even though it we
arrived at the ideas from very different
places they are the same ideas - within
Epsilon so there's some goodness here I
take it a step further and I'll try to
let you know where I take it a step
further and not to say that I do more
it's just that it's it's it's a little
bit of a different perspective it comes
more from a software engineering
perspective than it does from pure
mathematics so with that said I'm going
to get started here's the required
copyright notice here's the abstract but
since you guys are already here I
probably don't need to sell you on this
so we'll skip over that this is an
outline of the talk now because I'm
short on time because we know why the
introduction in background is is really
just a branding so let's go to that
what's the problem well you know I'm
about large-scale software design have
been for a very long time and want to
just point out that this is the notes it
involves a notion of logical and
physical design classes are logical and
functions are logical and files are
physical and libraries are physical and
this is what a component looks like
component is the fundamental unit of
logical and physical design it consists
of an implementation file a header file
and a test driver what does this have to
do with what we're talking about today
nothing but it's here because it's
branding so we won't be talking about
that the next thing we won't be talking
about is the relationships between the
logical functionality embedded in a
component and the physical dependencies
that result from implementing it there
so you can see that I have a physical
hierarchy of physical components that
contain logical content the next thing
that we're not going to be talking about
is how we describe the logical behavior
within components in English contracts
and again being mindful of the physical
dependencies that result so here's an
example of a component class diagram
with a bunch of logical relationships
that in turn imply physical dependencies
this is really good stuff
but we're not going to talk about it we
really do need to pay attention to the
different class categories because there
are a few that we use all the time and
in particular this talk today is about
value types so how many people feel that
they have a good grasp on what a value
type is be honest because I don't want
to pick on you excellent okay that's
good remember this session is just about
getting a feel for what we're talking
about and then the next session we're
going to really apply it on some fairly
interesting problems so this is a taxon
I mean if you go to our
hub repository this this kind of thing
exists and it shows how you navigate
across class categories and these little
bubbles that I'm putting up here are the
main ones and you'll see that there's
something called a utility a protocol a
mechanism and a value semantics type so
those are the primary things but we'll
get to that that that's this is the
emphasis but we're gonna get to these as
we go through the talk alright so that
was the introduction next so we're gonna
answer some key questions about value
hopefully somebody's gonna get me some
water because my throat is very dry and
I'm going to oh there it is okay thank
you that's that's non-causal all right
very good okay so I put this up here
because we're gonna go through these one
by one but just to give you a little bit
of an overview of what we're going to
talk about so getting started
interestingly enough the previous talk
was about allocators well I'll get to
that in a moment so not all classes are
our value types but still value types
are a very important category allocators
of course we'll see are not value types
let's begin with an understanding of
some basic properties of value types and
then we'll contrast them with non value
types to create a type category
hierarchy so that and then finally we'll
dig further into the details mostly in
the next section this is more of a value
types one-on-one talk so now to my story
so that the data is October 5th 2007 and
is my second attendance of the Standards
Committee I think was it the second or
possibly the third I think there was one
way back in 2004 where we went to talk
about allocators and it was well it was
a lukewarm greeting let's put it that
way but by this time we had gotten to
the point where we were proposing a
different kind of allocator and and and
and unfortunately
it made it all the way to the full
committee and then because of this thing
called Fudd fear uncertainty and doubt
it didn't make it through it was
deferred till the next meeting so to put
it mildly I was disappointed
so I'm sitting in a room with a bunch of
very smart people and they're talking
about a defect and it happened to be
defect number 684 of the working paper
what what do we mean by stating the to
match result objects were the same what
does that mean so the two objects are
identical same address same properties
at the same time or they're distinct
objects but they have some properties in
common so it turned out to be the latter
so the meaning was clear or was it and
then the discussion continued and I'm
sitting here and I'm going darn these
people they did accept this allocated
proposal left to wait till next time and
they're talking about this and of course
you know I might my tolerance was
reduced
whatever the copy constructor preserves
or as long as the two are equal and then
someone said no as long as they are
equivalent then someone said you know
what I mean and at that point I was like
a good thing I didn't say anything
anyway but since it was purely a wording
issue it was left to the editor to
figure out and it's not just an
editorial issue and what it means for
two objects to be the same as an
important pervasive and recurring
concept in practical software design and
it's based on the notion of
value so what do we mean by value what
does a copy constructor do after copy
construction the resulting object is
substitutable for the original one with
respect to some criteria what criteria
think about it is it the same object are
the addresses the same or if we do
something to an object and if we copy
constructed and then do something to the
copy constructed object does the
original object change and I think the
answer is no not the
same object and certainly this isn't
Java so no to that - in general that's
not what C++ is about so it's not that
none of this is what we mean so now what
about same state would it be fair to say
that the definition of value is fully
delineated by saying two objects have
the same value if they have the same
state how many people buy that how many
people think that's a false statement
how many people are still waiting to
hear the answer
excellent good I don't you guys are in
the right place okay so let's look at
this here's a string class and look at
this data member now the bits in that
variable that data member variable
represent an address how bad would it be
if we did a bitwise copy of a string
when we did a copy construction that
would that would be bad right okay
what would happen to references right
exactly so the problem is when one gets
destroyed life is still okay but when
the second one gets destroyed it's all
bad so we know this isn't good enough so
we need to take another step how about
the same behavior two objects have the
same value if and only if they have the
same behavior how about that one anybody
willing to go out on the limb and say
that's good enough I'll take that No
well alright so I'm claiming for now if
if we apply the same sequence of
operations to both objects to both
objects the observable behavior will be
the same okay so here's an example I've
got this function that takes a bool for
now we'll talk about why and the first
thing it does is it creates an empty
vector a and then it reserves some space
on it and then it does copy construction
so now I have a question tell me is the
capacity copied when you copy construct
a vector Yes No maybe
okay what who it depends can you
elaborate so in this case it makes a
copy is the capacity the same as the
capacity on the other side on the right
hand side or not does the standard make
any specification as to whether it's the
same or not okay at least as much I
heard okay the standard is silent on
that one so depending on what your
implementation is there may or may not
be an observable reserve I mean an
observable allocation when you do the
copy construction but don't worry about
that that's a special case what about in
general every object has a unique
address so if I pass in a bool X and if
you look at this code when I get to the
the the question mark : right here I
hope this is working is it working or
what it's hard to see all right well let
me wander over here when I get to this
question mark : based on the address I
will either or based on a bit I will
either get that reference to be a or b
and based on that the output will be
different so the very fact that I have
different objects no matter how much
otherwise the same they might be their
addresses alone are enough to make them
not substitutable with respect to
behavior so that's just a general proof
that such things happen and if we take
substitutability literally then this
isn't going to fly so it's not true
right behavior is not the right answer
so now we have to work harder and what
I'm trying to say is if this were easy I
wouldn't be giving a talk about it and I
wouldn't be revising it over the past I
don't know 15 years as as I think more
and more and more about it and talked to
more and more and more people so
same what what should be the same after
copy construction that's the question
that we need to answer and it better be
easy to understand because it is not
easy to understand it's useless at least
reasonably easy you know two objects
should represent the same value
now we haven't made a lot of progress
yet but the ideas were trying to find a
substitute ability criteria that works
in all cases so with that what do we
mean by value we don't mean this okay
now we're going to talk about
mathematical types and I can't find just
the right word because I don't really
mean mathematical I really mean platonic
or ethereal types that are in the ether
up here that we all will think about and
one day we decide gee I'd like to
approximate that in C++ so that's what I
mean by mathematical type I do not mean
a literal a like a semigroup or any of
that stuff I just mean some type that we
want to represent in C++ but we haven't
done it yet so it's the it's the
specification in our minds do you see
what I'm saying okay a mathematical type
consists of a set of globally unique
values so we've got a set and it doesn't
matter what the representation is so
heads-up this is one place where we're a
liqu stepping off and I have a slight
maybe different view what just happened
that's not good oh dear
hold on that was bad
okay slightly different view in that I
don't care yet what the mapping is from
the ethereal type to the bit patterns in
the C++ program but that's about it
there are many ways to render the same
ethereal type is in in in in software
engineering we call that encapsulation
we're encapsulating the implementation
we really don't care what the bits are
as long as they work what we care about
is the isomorphism between
the approximation in C++ and the
ethereal type we're trying to model does
that make any sense does anybody want me
to say that a different way or you're
okay say it a different way okay thank
you so when you go to design something
before you actually start typing they
have to think it was a crazy thought but
you have to think about what you're
trying to do and then once having
thought about it you have this mental
model in your head I've got this thing
that I want to implement and now I'm
gonna figure out how I'm gonna render
that in C++ but before you start typing
you still have a mental model Oh does
that make sense right so the mental
model is the specification and now we're
going to approximate it in C++ that's
what we're talking about and the
difference I'm saying is I believe that
the the specific bit pattern is the
reality in in AOP the bit pattern
matters I will look into that more but
that's that's the best I've done so far
but I'm gonna have this conversation
anyway so a set of globally unique
values independent of its particular
representation so for example integer we
all know what an integer is right and
five is an element of the set of
integers and how we represent it whether
it's any of these different things
doesn't matter because we're referring
to the unique integer five that element
of the set somewhere way over there you
know beyond the stars but there's one of
them there is only one integer 5 there
aren't two we cannot have two integer 5s
because a set is unique and integer is a
particular mathematical or ethereal type
so there's a set of operations on this
mathematical ethereal type that we would
like to approximate as well okay
the operations will become important
shortly so for C++ type it may it may be
an approximation to a mathematical type
and it may not
for example int int is an approximation
to the mathematical type integer there
are other approximations in C++ to the
mathematical type integer
for example long int short int sign
chart in 64 long long int right now
interestingly enough unsigned is not an
approximation to the mathematical type
int so mentioning that now and I'll
probably come back to it again and try
to convince you that that's the case
because the operations on an unsigned
are not the same as those on init
unsigned approximates a different kind
of algebra as an example I suspect many
of you in here are younger than I am and
if we were to go to a class that
returned age some of you I suspect would
haven't returned and unsigned why well
because your age can never be negative
so I'm going to get your age I'm gonna
get my age I'm going to subtract my age
from your age and that number will be
four billion that is not the algebra I
choose to use okay
so I've said that now we'll come back to
it the C++ object is just another
representation of this global abstract
unique value five okay so now I have
this date class and unfortunately
there's a problem with it and I like
somebody should be fairly clear to tell
me what's wrong with this date class
before we proceed what's wrong with it
let's say I say again the return types
of the getters what is wrong with the
return types of the getters
they're wider and why is that wrong I
want a real reason for why that's wrong
they don't represent the state I'm good
with that
that's actually important they don't
represent the state you're right they
could be negative but they won't be they
could be but they won't be yes good men
they're not Const now can anybody tell
me why aren't they caused this is tough
if you've seen this before you can't
talk
why aren't they constant no that's why
they should be constant why aren't they
constant no they don't these these
particular functions don't change the
state anybody else last chance
what they return by value that's still
on you and you maybe you have an idea
what is it in this particular case no
because because when you return by int
and where you turn by constant insert
modifiable had it been a user-defined
type then yes but I don't like that
either for different reasons it's
another talk the answer is because that
didn't fit on the slide I just want to
make sure you understand all right
now if you notice these are to date
classes they're trying to represent
proleptic Gregorian calendar dates in
the range of 1 1 1 to 12 31 1999 I'll
tell you now that all the operations on
these two dates are the same and they're
valid range of date holding what do I
want to say dates is the same
do they if the year month and day
correspond represent the same value I
here yes that's not the main part of the
talk but that's the idea of the talk the
answer is if they're trying to
approximate the same mathematical
abstraction and if the members then if
the values if we cook a composite value
is the same the same member of that set
that it's reasonable to say yes as soon
as the composite value doesn't match or
if the operations are different then
that's not a reasonable thing to say so
but the answer is yes so these two
things are the same and we don't care
about the representation not the least
little bit okay
so these are what we call salient
attributes salient attributes and I'm
going to take my watch off so I can keep
an eye on myself because I've been going
very slowly here salient attributes are
the set the documented set of observable
named attributes of a type T that must
respectively have a refer to the same
value in order for two instances of T to
have refer to the same value okay this
is not a trick question what are the
salient attributes of a time class this
is a simply constrained attribute class
hours minutes seconds milliseconds do we
care how its represented no we care
about the operations we care about the
the the the range of values the range of
values need not be the same but if the
range is overlap and we have a common
element that's good enough question this
is a reverse this is a reverse from this
as a mental exercise we never do this
but we're gonna do it here because this
is a conference what would be the
simplest overarching mathematical type
for which std string and cons char star
are both approximations list of
characters I heard list of characters
okay help me out you I'm trying to I'm
trying to map that on to what I think
the answer is so one of them let me
let's start with this an STD string is
an arbitrary string that can hold nulls
right and cons char star is not an
arbitrary string but it can be no right
both can hold the empty string but only
cons char star can hold null so the
answer is a nullable STD string a
nullable STD string would implement the
simplest approximation of simplest
mathematical type for which these are
both approximations neither one of which
fully approximates it right it's a an
attempt you see what the question was
now with retrospect either one of these
approximates this ethereal string this
sequence of arbitrary characters that
happens to be a nullable sequence okay a
nullable sequence of arbitrary
characters okay that's just that's just
a thought experiment so now if I
represent Fred as a conjuror star and
also as an STD string do those two
things represent the same value if and
only if they approximate the same
ethereal type yes
okay so okay now so the the the the what
was said here is the the interfaces and
and could be different one could return
milliseconds send some epic and one
other another one returns year month and
day and I am claiming that for the two
types to be substitutable with respect
to value they better have the same
interface okay but I'm not gonna say
you're wrong because they could
represent the same time point but that's
not the same type you see what I'm
saying in fact the date will pick one or
the other we won't pick both we don't
need two days we don't want two days
alright anyway this is an important
concept the idea that we're
approximating the same ethereal type
now what about integers and integers mod
five are those suppose I have four and
one type is integers Mayans and the
other one is my into mod 5 if I have
four is it the same for is it a
different form if I have an object whose
algebra is right I have one there's just
integers and the approximation to the
other one approximates integers mod five
if I take four and add it to itself this
is eight and what's the other one
three there you go so they're not what
they're different they're modeling
different ethereal types therefore the
values that they're modeling are
different and the and the resulting
operation we do the same thing to both
it doesn't have it doesn't work out to
be the same member the operation is
different and I'm saying this is why we
don't return unsigned just because the
value can't be negative it's because
when it's used later in an integer
context you will get the wrong answer
this happens all the time
you don't mix integers and unsigned if
you don't have to okay all right so it's
an interpretation of a subset of
instance day
the value is the salient attributes and
not the instant state itself it's a view
on the instant State and I use the term
recursive lightly here because I want to
show that there is a notion of
composition what are the salient
attributes of a point ok now I have a
box and what are the salient attributes
of a box there we go ok and how is it
recursive well the origin returns a
point which is a salient attribute and
the salient attribute has salient
attributes and so it's its composable
moving on we have a vector let's see if
you were paying attention what are the
salient attributes of a vector push ok
heard capacity but how about the values
of respective elements so if I know the
size and I know the respective elements
I'm modeling a sequence of integers
that's something we can understand
without having an STD vector I believe
that the ancient Greeks knew about
sequences of integers well before STD
vector came along probably Socrates and
Plato talked about it anyway now we
suggested capacity how do we feel about
capacity did Socrates know what capacity
was Plato anybody ok so we seem to agree
that is not part of value how is the
clients supposed to know they have to
read the documentation basically salient
attributes are part of logical design
they should be natural and intuitive
they must be documented explicitly water
break ok why is value important well it
turns out that when I was growing up we
didn't have IPC so much we just worked
on our own workstations and so we just
didn't care about going out of
once you go out of process you have to
care because you no longer necessarily
have the same representation let's take
an abstract data type you know here a
bunch of dates these are not
representations these are the dates
these are the ethereal type and now I
create a bunch of C++ objects from a C++
date class that I wrote and those data
objects are not dates in the sense
they're there they're not date values
they refer to date values but they
themselves are just referring to them
they are not themselves values and this
is a very important point because what
could happen is who would think of this
you might want to save those values in a
database that does that happen in the
real world we actually save data in a
program to a database we do and so
they'll be represented quite differently
and those representations will refer to
the same date values not equal date
values mind you the same date values
then somebody might think well Java is a
cool language I'm going to extract those
same values from the database but there
are no values in the database what
they're doing is they're making their
Java objects refer to the same values
and it's kind of like the difference
between saying and photocopying if you
have an image and you photocopy it
enough times in succession the image
will blur the beautiful thing here is no
matter how many times we take an object
in and out of the database it doesn't
lose any of its brilliance it's the same
object digitally the same object it's
the same bits they just happen to change
around because the mapping is different
from databases to C++ to Java which is
why I said it's the ethereal type that
matters and the the mapping is not
unique okay it's not just an exercise if
we don't all agree on what the integer 5
is we can't work together as a team
which types are naturally value types
here's a flashlight
it's on its off what's its state right
now okay now okay what's its value all
right so we don't really know what its
value is and when I first wrote this it
was really twice the pound was twice the
dollar things have changed all right
anyway it's not obvious and therefore
when we assign values to things that
don't have values we've missed something
very important if everything has a value
nothing has a value so we have to think
what kind of objects before I put this
up what kind of objects do not try to
represent a value can anybody think of
one pointers all right I have to say it
pointers actually represent something in
the middle they don't represent an
ethereal tight because pointers are
addresses in a local machine so you
can't that's not a global property on
the other hand they bear some
resemblance so we call them in core
value types but they're not the same so
the pointers are in between let's take a
look at these objects a thread pool
what would copy construction mean for a
thread pool bad news okay now a scope
guard is my favorite because that is the
least likely candidate least for being a
value type its purpose in life is to
manage the lifetime of some other object
or resource so scope guard no way now
look at these other things try to try to
get a feeling for what is and isn't a
value type okay I heard somebody say
anything that we can't apply operations
on is an alligator a value tied because
we can apply allocate and deallocate to
it to an alligator and we'll get back
memory okay so it was said that unless
we can apply algebraic operate
I think what you mean to say is unless
we can model an ethereal type that is
independent of its representation in the
computer it's not a value type is that
what I heard but what does it mean yes
okay so if you can do that but
unfortunately allocators deal with
memory and as we just said memory is
local to the Machine and yada-yada-yada
memory memory puts a little bit of a
spin on it we shouldn't dwell on that at
all that's another talk so anyway
there's some truth to what you said
algebraic structures certainly and
that's something that Alexander stepping
off makes a huge point on and so in that
sense we're 100% in agreement suppose we
have a thread-safe queue for inter task
communication is it a value type its
purpose for being there is to allow
threads to communicate put some work on
the queue and then take it off and work
on it is that a value type I heard I'd
say no it all depends on your
perspective that's the right answer
exactly that's the right answer it all
depends on your perspective in the
discourse and all of that good stuff and
should it support about semantics syntax
like copy construction and assignment
and and equality comparison and swap and
those kinds of good things should it it
depends what's interesting here is this
is in that rare middle ground and if the
reason for the things being there has
nothing to do with communicating value
but rather performing some task
the answer is no okay if we're not
trying to model an ethereal type but
rather do something useful it's a
mechanism so here's our taxonomy again
and mechanisms are on the left over here
and so let's zoom in a little bit
you've got my object type and we're
going to create this taxonomy it's
either stateless or it's stateful by
stateless I mean it's either a bunch of
functions the way we do it is we nest
them
destruct can we make them static because
we're old school and now old school is
new school because this is what we call
a utility struct and and that's an
important class category for us the next
one is functors and the next one is meta
functions and here's an example of date
util and a a static method of this
struct that does something and this is
where we put non primitive functionality
that might otherwise have been placed
inside the value type itself so this is
an important factoring tool it's also
really important class category so where
is it it's over here all right if we
have a stateful object it might be a
mechanism or a value type it's a value
type it's there but it's not it's a
mechanism we start at the top and if the
answer is yes it's a value type it's
over there and no it's over there and if
we look at the big picture again we can
come down and see that value types have
a rich taxonomy might be a full value
semantics type it might be just an
attribute class the constraints might be
complex which means they interact they
might be simple which means they're on a
per attribute basis or they might be
unconstrained but here's the whole
picture okay and these are the important
class categories that we're going to
talk about by the way an abstract
interface a pure abstract interface is
also an important category and it
doesn't come up nearly as much as the
others but when it comes up it's
something to be aware of and we know
exactly what it means now having said
that what does it mean for to abstract
types to compare equal any thoughts on
that you ever thought okay they're the
same type so that's not quite enough
they refer to the same value well it
turns out is a little bit of a trick
question because value if you think
about it there are no abstract
interfaces in the STL and the STL is all
about value all about value and so the
reason the thing is is that
was this fellow a long time ago who said
something very important in his book C++
programming style his name is Tom
Cargill and virtual functions are for
variation in behavior and data members
are for variation in value and it just
happens that it really doesn't make
sense to compare apples and oranges even
though they're both fruit because that
because the idea is you're going to
represent whatever you're gonna
represent the apple and the apple and
they're gonna have the same salient
attributes and that makes sense but it
doesn't really make sense to talk about
things that may or may not be the same
type and and as I said it's a it's
probably an ill-conceived problem to
even deal with that yes it can be done
and there are all kinds of tricks and
dynamic cast things that you can do but
basically that's not how we do things so
as a rule value types are not abstract
and mechanisms unless for performance
they're not they should be so mechanisms
are abstract and value types are not
alright what syntax should value types
have so value type defines the following
and I think everybody will recognize
these I don't want to be labor it it's
not about syntax right ain't about the
syntax so I'm just gonna put this up
quickly so that we get on to the next
thing I think everybody here can read
fairly quickly these are all familiar
things these are the operations stepping
off calls this syntax regular for type
to be regular there are a few more
properties that needs to have and one of
them is that it happens to be copy
constructible assignable and comparable
in linear time in the amount of bits
used to represent it and some other
things too but you've got to read this
wonderful little book and in fact the
the part about the hole in the and the
parts that was talked about the other
day in the keynote is the last chapter
of that by seán parent is the last
chapter in that
little book little for some definition
of little alright these are some
properties everybody knows and they're
not interesting this one is obvious and
everybody knows it should be that way
and it's necessary here's one that isn't
maybe quite as obvious and most people
know it but it's always interesting the
few people in the crowd haven't thought
about it before so let me throw it out
for the few of you that haven't thought
about it before if I have a deed that's
not part of my type but it's ours some
other type and there's a conversion
operation and if it works with a equal
equal D it darn well better work with D
equal equal a or somebody's going to
complain that's a bug think we'd all
agree that's a bug if it doesn't work
both ways so does everybody know what
I'm talking about okay so we'll go
quickly so I have a type T it has an
operator double equals it's a member
function and I have this other class D
and this class D has a conversion
operator and now I try to use it one way
and it works and then I try to use it
the other way and it breaks and we all
know that user-defined conversion on the
left-hand side of a member operator
doesn't happen so it's not symmetric so
what's the solution don't do that do
this then it works and everybody's happy
there's always a wise person that comes
along when we have a little bit more
interesting class so we have a string
and we're going to make operator double
equals on string and strings a free
function we're going to make the one
with the care star on the left hand side
free as well so that conversion can work
but why bother with the one on the right
hand side that's just a waste of time
I'm not going to do that so of course we
have the even smarter person come along
with class foo and class bar and then we
do bar equal equal foo and that works
and then when we swap them the
conversion to string on the left hand
side fails and oh well so don't be cute
don't do it just make all your operators
a double equal operators free and life
will be great
free operators and by the way all of
these
should be free but not these okay and
then we can talk about pre premium
increment and post increment in another
talk all right we'll talk about it now
pre increment is a member post increment
is free go figure
okay what semantics should value type
operations have so the important thing
is is that the whatever you're going to
do is derived from the state of the
object itself and nothing else it has to
be only this the bits that are in the
objects and we're saying that these
salient attributes must respectively
refer to the same value corresponding
fields or attributes refer to the same
value as okay now when we say the same
value again in that wonderful meaning
back in 2007 they started talking about
what the copy constructor does but if
you look at this the copy constructor
may or may not copy capacity and
therefore the copy constructor
implementation is not sufficient if
we're archaeologists to figure out what
the true value of the object is can't
tell us
so copy construction is not the right
place to start however comparing
something equal we do that with operator
equal equal and the nice thing about
operator equal equal is the
implementation of operator equal equal
is the operational definition of value
that's the implementation and the
documentation the function level
specification of operator double equals
is the definition of value in the
interface that is the contract that's
what it means okay they share many
properties that are objectively
verifiable they should be intuitive
here's something this is this is a slide
taken from my tooth
in a presentation it was so good I had
to put it back into this it's been it's
been hiding
so tell me people know about CMOS and
and mas technology ancient technology
and loss and they're there these are two
registers and they each hold eight bits
and I assumed that a sequence of bits is
a value right a sequence of bits
it's a we all agree a sequence of eight
bits is a value and I'm going to say
that the technology is orthogonal to
that value what do I mean by that I
don't care what the technology is it
could be an alligator I don't care
could be a lock it's not relevant to
value now we see these are not equal but
I'm gonna do an assignment now if I do
an assignment what's gonna happen
anybody what's gonna happen it's gonna
copy the value what exactly is the value
okay you know the bits don't actually
flow through the wire right it's it's
the voltage on the nodes that changes
right the information travels so you're
saying this happens no the information
happens but not the the transistors
don't flow through the wires into the
other register and turn it into a CMOS
transistor okay so this is not what we
want to mean by assignment and the big
concern is suppose we just assign the V
table pointer while we're at it
or maybe the allocator these are equally
silly concepts because the V table
pointer in the allocator are part of the
runtime type of the object even if
they're using the polymorphic memory
mechanism we do not want to propagate
allocators in this way
just throwing that out there don't do
this okay
knowing what salient attributes are will
help us with testing but that's again
another topic so suppose we have a B and
C objects of type T D as an object of
some other type suing it exists now why
wouldn't it exist is it possible that we
could have a value semantics type and
have it not have an operator double
equals or is that just impossible is a
singleton of value semantics type I'd be
interested think about it so the
question is would we ever have a value
semantics type that didn't have an
operator double equals is it is it even
thinkable function why wouldn't it have
an operator double equals that might be
a good answer if we don't know how to do
it that would be a good answer do we
know what it means for two functions to
have the same value yes okay well you're
saying the definition of value for a
function is that they do the same thing
on all on all inputs okay but if they
have different function pointers coming
in that's a hard problem do you know how
hard it is I think that's a good answer
yeah I believe it's undecidable I think
it's the same as the halting problem
anyway we'll talk more about hard
problems later sometimes almost regular
is good enough and it happens that
there's a very special kind of regular
type that is almost regular and Alex
Stepanov calls it semi regular it's
regular in its syntax and all of its
semantic properties but the operator
double equals and operator not equals is
missing so
about why it might be missing we'll talk
more about that a little later
okay and again the value of a is
independent of any external object state
any change to a must be accomplished via
a interface I'm just checking our time
suppose a value semantic object refers
to another autonomous object in memory
this is the example where we have the
in-court semantics this is not part of
the talk but we can have a pointer and
in index and here you see the pointer
and here you see the index and we have
rule operator double equals and two
element objects have the same value if
they one refer to the same record object
in the current process and two have the
same element index so here's our
wonderful example where we have a bunch
of element pointers and we have to
prospective record objects and if you
look at this two of these objects have
the same in core value does this matter
does it matter whether record object a
and record object B have the same value
there are autonomous objects the answer
is no they might not even be value
semantics we don't care what we care
about is that object to an object that
we refer to the same object the same
autonomous object and they have the same
of salient attribute which is the index
into the object and so these guys
compare equal why is this important
because it's an autonomous object it
could change even if it did have value
semantics and there were two of them one
could change but if that one changes it
doesn't matter because it changes for
both of them in lockstep but this is not
part of the talk this is just to keep a
placeholder so that you know there's a
lot more to talk about later it's not
full value semantics so again not the
focus of today's talk ok what do we mean
by properly so this is sort of a big
point we got off to a little bit of a
late start
I'm going slowly I just want to say that
if people want to go out and get food at
exactly 350 or is it 4:15 III I can just
stop right there so we'll do that
because I last time I didn't get any
food but that's okay so I'm just gonna
stop exactly when you say it's time
that's it how many five minutes okay so
we agreed that the same observable
behavior wasn't enough we might allocate
memory but this is the big takeaway for
this hour if a and B initially have the
same value and the same operation is
applied to each object then absent any
exceptions undefined behavior craziness
order of operations machine size
whatever they will again have the same
value or they never did this is huge
this is subtle essential property of
value if you write a value type and this
does not hold your value type is broken
in a profound way that's not intuitive
it's not substitutable all right
deciding what's not salient is hugely
important and there's a lot more to this
story I want to point out that this is
not a test driver Kevin Lin honey made
me point this out this is a sequence of
operations we're saying if we do this to
the same C++ type then it will again
have the same value now here's a thought
experiment
suppose we had a homegrown ordered set
and we were able to set a bit at
construction that changed the order from
being less to more so I create two
objects they're empty one is set to
increasing the other is set to
decreasing the question is they're both
empty do they represent the same value
no I heard no does anybody think yes
okay mister yes we're gonna add five to
both of them in pen five now each of
them has five in it do they have the
same value now I'm going to put six in
one of them represents the ordered set
five six and the other one six five
remember the name is ordered set do they
represent the same value okay I hear a
yes
again that's interesting because it's an
ordered set not sure why but no it's an
ordered set the word specifically
ordered set ordered set means sequence
its unique ordered set means it's a
sequence of unique elements that's what
it means
excellent no to all of those I know look
we use terms that look what can I do I'm
trying to use the standard library we
have we have unordered set and we have
set implicitly set is ordered what do
you want okay I understand the problem
believe me all right so I've gotten
through all of this so they're not
they're not equal that was the main
point and this is also now remember
these operations have to be salient
originally unordered set was called hash
set and hash set has all kinds of ways
to violate the intent of the ethereal
type that most people think it's trying
to approximate so you can discount all
of those operations as irrelevant and
think about what the ethereal type would
do and do that okay okay what makes two
unordered containers represent the same
value and I think I'm going to end with
this maybe if I have a bag of Halloween
candy to kids they each have a bag of
Halloween candy
how would you ask the question do those
bags have the same value yes is it a
homogeneous collection no Halloween
candy is not homogeneous what you do is
you take the two things of candy you lay
them out on the ground and you perm you
one to see if it can match the other
corresponding elements if they have the
same number of elements and
corresponding elements have the same
value as determined by the elements then
those two multi-sets
have the same value otherwise they don't
and where's Pablo is he here oh he's not
here oh yeah that's right he was tired
anyway in 2010 we
actually got that definition into the
standard in time for 2011 was a good
thing yep
that's that's a steppin off requirement
okay that's what we mean by what Stefan
off calls a regular a regular type now
keep in mind that everything having to
do with hashmaps violates that
everything right there was a suggestion
that we could solve that problem by
having order be salient in an unordered
set we decided not to do that because
that's just silly okay look just I think
this is probably a good place to stop
right here remember that it has to be
the same type as soon as you change
types and they're different
approximations then all bets are off
this is undefined behavior okay
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>