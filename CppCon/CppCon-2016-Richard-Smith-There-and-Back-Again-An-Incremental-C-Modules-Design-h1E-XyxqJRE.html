<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Richard Smith “There and Back Again: An Incremental C++ Modules Design&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Richard Smith “There and Back Again: An Incremental C++ Modules Design&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Richard Smith “There and Back Again: An Incremental C++ Modules Design&quot;</b></h2><h5 class="post__date">2016-10-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/h1E-XyxqJRE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone my name is Richard Smith I
work at Google I do quite a lot of
different things there I wear a number
of different hats so I'm on the C++
committee where I'm the project editor
which means I'm the person who puts
together the working draft since the
documents present to be sent twice so
edits the whole thing together I've also
been responsible for a number of the
features that have gone into C++ 14 and
17 and my laptop is second alright so I
also I am the lead developer of the
clang compiler which hopefully at least
a few of you have heard of and at Google
I'm also a professional language layer
in fact I'm kind of a little bit known
for telling people they have they have
undefined behavior and my my job title
inside Google is mob language layer mice
program you've got there it'll be a
shame if something were to happen to it
okay so today I'm going to be talking to
you a little bit about modules about
modules and clang a little bit about the
modules PS and about some ideas that
we've been discussing to help us at
Google and the rest of the community
embrace the modules TS and transition to
it so if you're expecting a talk about
the Lord of the Rings I'm sorry this is
not what what this is gonna be about
that there's other talks there's doors
at the back ok so firstly this is about
an incremental c++ modules design so
what do I mean by incremental so first
of all if you're not aware Google has
C++ code base it's pretty big
it may in fact be one of or the largest
monolithic C++ code base in the world
this means we have lots of code we can't
actually update the whole code base all
at once in a single commit in a lot of
cases we have a lot of changes going
into our code base this means via by a
lot I mean we have
a change to our C++ code base every few
seconds so if you imagine if you're
trying to say rename something as
something that's very widely used you
want to so first make the name available
we're in two different places the old
place in the new place transition
everything across and then remove the
old name well in that time between doing
the transition and we're moving the old
name if there's a good chance that some
new uses of it have arrived it's a bit
of a pain and the other thing is we have
a lot of developers which means if we
break the bill temporarily there's going
to be a large number of frowny faces and
all of our libraries are leased a large
proportion of our libraries have a lot
of dependencies on other libraries they
have a lot of libraries depending on
them and some of those dependencies are
things we actually can't or don't want
to change for a variety of technical
reasons and in fact these these problems
are not unique to Google they're they're
common across large parts of the
industry if you think about someone who
is renting a library to some someone
else they have similar problems that
they don't want to break other people
and so in order to enable changes to be
made in this configuration we need an
incremental development process
something which is not one of something
which is not we change the entire world
one on one step so we can't require
simultaneous changes across many
components if we want to make a change I
mean in fact this is the property that
we want that every change we make can be
made as a sequence of local incremental
changes and the code base needs to
compile and work and the tests pass at
every step along the way that's the goal
there are some cases where you can't
meet that goal we usually just
approximate this but this is what we're
trying to achieve and that's what I mean
by incremental and Titus I gave a great
talk on sustainability at CPP Co on the
last year so if you want to know more
about all this stuff go watch that and
then of course this is a talk about
modules so what are modules we just
don't know so this is my attempt at
defining what we mean when we say
modules lots of people mean lots of
different things some people mean the ML
style modules which is not
really what we're talking about here
we're talking about is this modules are
a way for one logical unit of code to
take its interface and expose it to
another logical unit of code and in some
sense this is a large code based problem
but for that you mean large to be more
than one file so most people have code
base is large enough to need something
like this and I'm sure some of you
thinking we have a solution to this
problem so the traditional solution is
we use hash includes hash includes
mainly textually duplicate the interface
of a module and to each one of its users
and as I'm sure we know this has a
number of problems so one of them is
that it's really brittle so if someone
defines a macro and then includes your
header that can change the meaning of
your header in or where you didn't
intend but it's not just macros if
someone declares a function and then
includes your header that can change the
meaning of your header as well something
we see if I'm out is someone defines an
operator left shift for some standards
for some type to stream it and then they
include a header and how that type is
written to oh streams depends on whether
or not some other header was included
first another problem with hash includes
is they're kind of uncontrolled so if
I'm exposing the interface of my library
to someone and I need in order to
implement that interface or and in order
to implement some of the parts of that
interface that I'm putting in my header
and put in my class definition I need
something else I can't stop that other
header that I include being leaked to
the people who include me
you just can't import something for your
own private use in a header and that
means that people will develop
dependencies on you to provide something
that you didn't want to provide and if
you remove that you break them and of
course the big problem the one that
initially led Google to invest heavily
in modules but not definitely not the
only problem is that hash includes is
slow it's slow just to get the pieces
that you want because all the pieces
that you want are passed every time for
everyone who includes it and most of the
stuff you get is actually things you
didn't even want that's not the
interface you're asking for
so this is a somewhat similar to a
growth from Manuel's talk if you saw
that we have order n source files or RM
headers included in each and what we
find in practice is that unless we are
careful M rows pretty much linearly with
n so the entire problem ends up being
quadratic which is kind of appalling and
even for really small files we end up
including just a huge number of header
files
so these 195 files
that's megabytes of source code for
hello world so I'm a compiler guy it's
my job to to us the crazy questions and
as a language learner it's kind of my
job to answer them so the question is is
there something we can do about this
with C++ as it is to fix the problem is
it just that the compiler is doing a bad
job so I'm gonna make a really audacious
claim my claim is that C++ has a module
system already now you probably don't
believe me and I'm not talking about
hash includes I'm talking about
something which is actually a little bit
more principled and solves some of the
problems that we were just mentioning so
in order for a C++ module system to be
useful and to be correct from a language
law perspective
we must conform to the standard and it
must still do what people meant when
they were at the source code so I'm
gonna start by talking about C++ is one
definition rule I assume most people
here have heard of the one definition
rules does anyone think they can tell me
what it is okay so I mean I'm just gonna
give you a brief rundown of what they
want one definition rule is because it
does matter so there must be at least
one definition of each entity that is
used by a program and this is C++ so
when we say used we don't actually mean
it's name appeared we mean something
more complex which is to do with whether
you use it just for its value or whether
you also use its address this is why you
sometimes don't need to define static
data members but mostly it means if you
use its name
in an evaluative context then it's used
and there must be a definition but that
can't be it right
this is C++ there's not one one
definition or here's the second one
definition rule one definition rule
number two there must be at most one
definition of various different types of
entity so you get at most one distinct
definition for anything by distinct what
I mean is the token sequence every time
you define the same thing it's got to be
exactly the same and those tokens have
got to be interpreted in the same way so
you can't get around this by saying well
yeah but I use the same token but it and
lookup found something different here
than over there that's not okay if you
break this rule just like if you break
the first rule your programs all formed
no no diagnostics required your compiler
might eat your program you get wonder
most one definition per translation unit
if you already have a different
definition visible you're not allowed to
give another one I think we we pretty
much all are familiar with that part and
for things which have strong linkage
things like non inline variables non
inline functions you get at most one
definition per program and like I said
this is C++ so there's not too one
definition rules there's three so one
definition rule number three says this
is the good bit this is the exciting bit
if you follow these first two rules the
program behaves as if there is exactly
one definition so if you have the same
class textually duplicated into two
source files because you use the hash
include' or maybe because just because
you copied and pasted it or you had a
monkey at the keyboard who got lucky
then the program behaves as if there is
exactly one definition in total those
two translation units are required to
act as if they are both talking about
the same class the same inline function
if that inline function say has a static
local variable that is the same static
local variable because there's only one
function in total the implementation is
required to make this happen somehow but
the good news is this actually means we
only need to pass each definition of
each entity in the entire program once
once per definition not
once per timers text included so this
gives us an inkling of how we might do
modules in standard C++ and the next
thing is we're gonna make an observation
which is that most headers are what I'm
going to call modular and what I mean by
this is this is a normal header file
it's not doing weird tricks like being
an X macro doing different things
depending on what you defined before you
included it it's not assert that H it's
self-contained which means it includes
everything that it uses its interface is
not intended to depend on other things
being provided first before it's
included and it's not intended to have
any other effect on the program other
than making certain things visible now
suppose we know in advance what the
modular headers are we can compile each
module header as a separate translation
unit and the second the next trick we're
gonna use is this hash include' doesn't
have to mean find a file using include
search paths pull it in off the disk
tokenize it and plunk less tokens into
the file it's actually a little bit more
general a match its implementation to
find how those tokens are produced so we
can protect we can pretend that we take
a token stream formed by compiling that
modular header and slip that into the
file at the point where we see the hash
include' instead of going back to to
disk and reto cognizing the original
file and we can do that in a context
which prevents macros from being
injected we just use our imagination to
say there is some token stream which
behaves that way that's enough
and then we make an observation if your
header was modular if you actually wrote
a normal sane header then this does the
same thing that your programmer really
did it's pretty cool it's kind of of
academic interest perhaps you might
argue but it does the same thing your
program already did or if it does
something different it's because you've
avoided a bug that you used to have
where some macro or some declaration
came beforehand was changing the meaning
in a way you didn't intend okay now
because we have this control over what
is in this the set of the we inject we
can actually implement that a different
way
and the way you implement it is when we
do this first step of compiling the
header we can cache what those
declarations definitions macros whatever
else were and instead of doing any
completions we'll just make them visible
okay and because we have the ODR we
don't need to care that they might
actually have meant something slightly
different in different contexts and
we've been told that was not the intent
of the program so just a quick rundown
of how that works there'll be a bit
brief because Manuel has covered a
little bit a bit of this in in his talk
so we pars
pooted H we compile it as if it were a
source file we generate a PCM file which
contains a pre composed form of that
source file we're going to call these
ast files but it's not actually an ASE
crank has a a data structure called to
the ast but it's not abstract it's
actually very concrete and says specific
meanings it's not representing the
syntax of the program it represents the
semantics and the syntax and it's not a
tree it's actually a graph but it's an
AST okay so we worked out this file and
then later we are we see a hash include'
of this and the compilation step for the
CPP file is provided the PCM as input
and it just makes those things visible
and they can be used and likewise if we
have another file this one sees this
hash include' of food or H makes that
visible season included some header
which we didn't say was modular maybe
it's doing some weird stuff and does not
make that one visible it just text
really includes it and defines a bar we
worked out of bought a PCM and then
obviously you can use multiple of these
when compiling a C++ source file which
at this stage is one of the benefits we
get over something like precompiled
headers okay so something weird just
happened here we have this textual
inclusion of non-modular dot H in foo
and another textual inclusion of normal
denoted H on in bar so suppose that
looks like this when we compile bar at H
we've already got a blob function
visible from the hash include' afoot
so when we get to the hash include' of
non-modular @h we might have a problem
and the problem is this if we don't
export to the macros in particular the
include guards from food or H which
maybe we don't want to do maybe we have
some feelings about macros if we don't
export the the macros from food election
in put them into bada H we're going to
see a second definition of this blur
function and as I mentioned you can only
have if you're to go to definition of
something visible you're not allowed
another one the idea is not so we must
export the include guards from normal to
load h1 we build foo and we actually
have a very general principle from this
which is that for legacy headers for
normal Java headers the macros and the
C++ level declarations are inseparable
you must make one visible whenever you
make the other one visible and if you
don't things will go wrong and
deployment to Google we have seen this
time and again anytime we try to deviate
from this principle we have been very
badly burned
ok so we have something pretty cool now
we have a system which generates results
which if your headers are modular when
you say they are it will give you
results which are essentially the same
as you've got for any other regular C++
compilation so you can share source
parts between a compiler that does this
and one that doesn't and there are a few
restrictions on on when you can do that
but actually these restrictions are
pretty much just us saying like we
promised the header file is actually
modular and these were restrictions we
really did want we've been saved from
certain sources of badness by these ok
so one thing that I've been working on
at Google is getting this to work in
clang so before I started working on
clang Doctor Who and various other
people had basic modules support for C
using similar principles working but the
C++ support was was a bit weak and in
fact there are quite a lot of bugs so
I've spent very much time getting this
working and we now have essentially
production ready I mean we're using it
in Google
traduction very implementation of this
in clang it has been for several
releases and we have a file called
module map which Manuel talked a little
bit about which specifies amongst other
things which of the headers are the
modular headers okay so does it work
actually we've deployed this form of
modules on a number of code basis not
just googles so the clang and LLVM code
base they compile without modification
other than bug fixes I mean assuming you
consider non module headers to be about
which I think most people probably would
we're using underneath that stock live
C++ stock G Lib C do you live see
completely unmodified live C++ needed a
few fixes and those have accompanying
module Maps just to say which the module
the headers are and which are the head
is where do you live C does something
truly truly scary and likewise we have
modules enabled for about 10% of the
header files in Google's codebase we
pick those 10% based on the places where
we thought we'd get the biggest impact
but it turns out that while we are
deploying it the places where you get
the biggest impact have shifted a little
bit as we've had other efforts to reduce
the the compile time of those bits and
we get a speed-up of 10 to 50 percent
from compiling the average source file
in Google from this and again we needed
to make a number of bug fixes to make
this work so if you want any more about
that I suggest you go to Manuel's talk
which is this morning and if you have
problems with that then I'm sure it'll
be up on YouTube so actually how many
people did go to Minot stock that is
most people I would say cool okay so
it's time to get some of the skeletons
out of the closet does it really work
well I mean we had to do some fairly
heroic things in the implementation
because we were extending a compiler
which while it was designed with this
sort of thing in mind from the start
there are a lot of interesting things
that happen when you use to compile
especially the way that we chose to do
it so cleanse approach is extreme
lazy we say we're not going to load
anything from the PCM folder we don't
need there's quite a lot of places in
clang where and we hit something we're
like okay now we really do need to know
what all the declarations of this thing
are or what this name lookup result is
and until we hit those points we don't
read anything from the file but there's
things that can go wrong
one thing that can go wrong is sometimes
we import the same entity from two
different ast files so maybe we have the
an inline function which was textually
included into two places we import them
both we now need to smash them together
somehow we now need to pretend that we
only saw one of those and this is it's a
little bit tricky for us to do this
architectural because we need to
maintain all of the plane ASTM variants
for doing this
the goal of the implementation is that
no part of clang other than the
serialization there knows anything about
modules and we pretty much succeed at
that task we can basically just say you
see to think we see something look up
something with that name that already
exists and merge it together if it's
already there but there are problems
with that like some things don't have
names
so merging together the type that is
returned by this function is a bit of a
pain and this sort of thing does happen
and you know we work through those
issues and then there's other kinds of
issues we head and do this might seem
like the same thing this is actually
quite different so this is the case
where someone gives you an ASC file as
an input and you've not seen the hash
include' for it yet but you know it
exists and maybe you've decided like we
do that that you're going to look for
things in that ASC file because it's
actually useful to do so one of the
reasons why it's useful is that you can
diagnose certain ODR violations even if
they happen in code that you didn't
include that's pretty cool
but it does mean we end up in situations
where we have a definition that's not
visible and then maybe we hit another
definition because the first definition
isn't visible that's not a violation of
the idea we don't have two definitions
visible at once so we need to deal with
that and what we say is okay
the definitions in that module file
we're going to make that one visible I'm
going to skip the tokens so that you
were down here by the idea we know the
the same and we actually have some work
here to say we're going to check as we
as we skip those tokens that we really
do think it is the same but that's not
quite valid upstream yet so it's
problems with that as well like things
like this that happen all the time in SI
system headers now notice that you don't
know what's the linkage name of this
type is until after you've got to the
end of the type pouch and cases like
this again you don't know what enum type
you're defining until you see the first
enumerator and then maybe you look it up
and say well this is the first in your
interest some other type maybe it's the
same maybe it's not I'll work it out bit
painful okay so these are problems but
these these are business as usual for a
c+ implementer our lives are a little
bit tricky C++ is not the easiest
language in the world
it sucks but does it really work yes it
actually does we've deployed this on
large code bases and you can genuinely
maintain a code base that compiles both
with and without this form of modules
okay cool
for themselves we can go home yes agreed
everyone happy with that Gabi you're
happy with this you don't know okay so
it's probably time that we take a step
back and think about the goals that
we're trying to achieve with modules
because well the thing I just talked
about it's probably around the best you
can do without syntax changes to C++
that's not actually the constraints that
we're living in
it's the constraints that we imposed
upon ourselves when when we set out to
deploy your modules in Google because we
want to be compatible with other
compilers we have various external
reasons to want to live under those
constraints but they're not the real
constraints so when we see modules what
do we actually mean so there's a bunch
of different features we want from
modules we want to make our compiles
faster we want to avoid certain problems
with with the idea with macros
interfering with with our
our interface definitions we want to
control the things we export from our
interfaces we want to possibly have some
way of saying I'm going to use something
in my interface that the rest of my code
gets to know exists but your code
doesn't and more than that we want to be
able to say I have internal things in my
interface like maybe a namespace
internal namespace detail or something
which is gonna be shared amongst the
things that didn't my friends and you
can also have a namespace internal and
then sayst details that don't conflict
that'll be pretty cool and we want to
have some actually nice syntax for this
and we probably also want to get rid of
include girls while we're at it because
he wants include guards right okay so
the kraang has solves some of these
problems well some of these problems
with an asterisk which means not really
maybe ish and some of these it really
isn't solve at all so we don't have
input syntax that's that's intentional
but it's also a problem because it means
we're using preprocessor syntax for
actually something it was designed for
but not something that it's actually
really a good fit for we have some
amount of export control and clangs
implementation but again no syntax for
it no way to easily access it and
because we try to be as true as we can
be to standard C++ semantics we have no
way of avoiding name collisions for
internal names fortunately there is
another approach so there is this thing
called the C++ modules TS now the
sequence first module CS is a work in
progress technical specification for C++
which does aim to solve the problems
that I just talked about I'm going to be
using the syntax in one over to talk
about of the modules TS plus some
syntactic tweaks from a paper p0 273 the
authors of which are I think all in this
room so if you want to blame people you
know where to find them
I'm only going to be using the syntactic
weeks that have been through the
evolution working group and largely
being being approved in principle if you
want to know more about them or just yes
because I don't have time to cover the
whole thing you should see Gabby's talk
from last year cpp con as well as
Gabby's talk tomorrow yes thank you yes
so I'm gonna give you a rundown of
roughly how the planck style modules
would translate into the modules TS so
instead of having header files we now
have what are called module interface
units these define the interface of your
module and they start with this the
syntax to say module through this says
this is a module interface for the
module so unlike header files
nothing is exported by default so by
default you need to opt in to exporting
declarations definitions from your
module and this is actually I think
maybe rare in in C++ this is probably
the right default and we have a
first-class import syntax so if someone
else can say hey that flew thing over
there like that can they have everything
that it imports please that's for
everything at exports please and there's
there's a bunch more stuff but this is
kind of the heart of there the modules -
yes and one other thing it gives us is
it gives us a module ownership semantics
so entities can be owned by a particular
module and what that means is there's a
few things it means for things that are
exported you're only allowed to have one
module be like the person who's who that
belongs to
but no one else is allowed to do we
declaring their old one they're just not
allowed for internal things they get a
new form of we're calling it linkage but
you can just think of it as it's this
modules this modules declaration it's
not going to conflict with anything else
there's no way you can have them both
visible at the same time so it's fine
that my module foo has
an X in your module flu has an X as long
as they're suitably internal okay so
this seems like somewhere we want to be
if we have a code base and we've managed
to port it or partially port it to
cleanse modules we probably want to be
thinking how do you go the next step how
do we get from there back to the the C++
standard at least the direction it's
going so this is where we come back to
needing an incremental transition plan
and more than that with with a
significantly sized codebase or with any
case where you want to incremental e
roll out a transition maybe over several
releases of some project you need your
rollout plan to be maintainable at every
step along the way so and the other
thing you need to be able to deal with
is libraries that actually can't do this
transition and there's a number of
reasons why I like these would be unable
to transition one of them would be maybe
they still support C++ 98 users maybe
they still support C++ 17 useless
maybe you can't modify them and that
they just can't be able to modify the
code themselves maybe they just have
customers that are forcing them to stay
in that mode maybe it's just not your
priority right now there are a number of
reasons why you might be in that boat so
let me give you an example of of what
you might want to do suppose you have
this foo library you depend on a couple
of other libraries and let's say for the
sake of argument if they haven't
transitioned yet it's doesn't pick with
their team schedule or they can't or
won't whatever and maybe you have
customers yourself who are also not much
of ice yet but you still wanted to play
modules for your code and this perhaps
is like the most important thing to do
for for whatever goals your your team is
trying to to achieve so you have these
couple of hash includes and as we
observed before advocate might be
depending on Yuri exploiting those it's
it's a sad truth but it does happen but
maybe even it's intentional maybe one of
these provides a base class that you're
using and you actually deliberately want
includes of your header to exploit your
base will cut so your base class can be
used helper function for your base class
can we use that sort of thing
so here's how you might do this with
module CS so that there's a few salient
parts a little worth worth calling out
the module four at the top we've seen
before there is a food at H at the
bottom which I'll come back to which is
how your existing customers are going to
import that module and then in the
middle we have the thing that used to be
in your header file and you'll see we've
got rid of the include guards for a a so
we have a couple of hash include' say we
share before we've got this class foo
which which we had before and this whole
thing is wrapped in an export module
declaration that's like you two
different things there one of them is
the export one strike well the export
construct says is the declaration after
me which in this case is a module
declaration it says that thing
everything within it that is exported so
we're exporting everything in that will
and everything in depth - and this class
foo and the module embraced up close
brace and this is something from p0 to 7
3 which said it's a syntax for saying
we're going to turn off the module
linkage rules just for this little bit
of code because this is this is legacy
this is something where we actually
don't want that right now and the reason
why I want to do this here is there's a
few reasons why I want to do it but one
of them is somewhere else might want to
forward declare class foo and we want to
allow them to do that that should still
work ok so now we have this this food at
H food at H is we're going to provide to
your existing users who have not
switched to modules yet so they can
still compile food which is going to
include import your module but it needs
to do something else because as you
remember we have this this fundamental
rule for no modular headers that if
anyone can see the declarations from a
normal drill head up they must also see
the macros and particular they must see
the include guards so we have to provide
the include guard macros somehow and we
can try to deplane them ourselves but
this is almost certainly a bad idea and
the reason why this isn't going to work
out well for us if we want to actually
check this file in is that that it's
going to constrain the people that we
import the people that we include to not
change if they change this sort of
include guards then they're going to
break us if they add a new include into
deputy dot H and we are not also
providing the include guard macro from
that include then our customers get
broken this is pretty bad
there's a key another thing which goes
wrong here which is that if anyone ever
does choose to transition to being a bit
more modular and they say we're going to
use import foo instead of instead of
hash include' food or H then they have a
problem because now people who use them
and any of these headers are again going
to run into these same multiple
definition problems because they again
don't have the include guts so this may
not be the best way to go another thing
you could do is you could do this and
what we've done here is we've said we're
not going to react sport that one in
depth two from our module we're actually
we're going to have those not be part of
our export interface if you want those
then we're going to put those in the
header file and food of H should really
be including that too that H as well
here there wasn't room on the slide so
you could do this and this will this
will probably work there's a couple of
things that are wrong with this one of
them is we actually did want to export
that one so we we do want to export
things that for instance our base
classes that can be Simpson is important
there are some other times we want to be
export someone's interface on purpose
and it's not the common case but it's
something something you sometimes want
to do and and the other thing is it
still suffers from this problem where
someone who says import foo I get the
wrong stuff but the big problem is we're
paying the inclusion cost for the
dependencies of food at H every time
someone includes it still we've not
actually saved any compile time map so
it didn't really work it's not a
completely satisfying solution for
incrementally transitioning so this
leaves us in an interesting situation we
have somewhere we want to be we've got
this module CSU want to transition to
and we can transition some of our code
maybe not all of it maybe not all at
once but it gives us the syntax
six that we want the question is how do
we get there and on the other hand we
have the system in clang which actually
does solve the incremental transition
problem we know that can be done we've
done it it does require some code base
cleanup and working through a lot of
pain with bugs in the compiler but you
know we've done that so you don't have
to but the end state isn't actually what
we want to be where we want to be it's
not clean it's it's still a lot of the
problems that we had before so what do
we do about this well I mean actually
why don't we have both well do we really
want both something like that
what what perhaps we want the idea that
we had is suppose there's some way to
get the semantics of the Klang approach
with modulus TS syntax just some small
tweaks that we can make that would allow
you to opt in to getting the the
transition semantics if we have that if
they we have some way of rewriting the
clang modules approach using the modulus
es syntax then we're done we can do all
the remaining steps incrementally we can
get all the way there we can be very
happy okay so what are we actually
missing from modules yes to support this
maybe you might think we're missing the
implicit translation of hash includes
into module imports maybe but actually
we can write that ourselves that's not
such a big deal we can write header
files which just say import something
maybe there's some semantic tweaks that
we made that necessary to make it work
there might be a couple of those but
actually one we've sat down and thought
really hard about those most of them are
working around for instance bugs in the
standard library implementation that we
can fix and when it comes right down to
it there's really only one thing that
that we're missing one thing that we
can't do with the module CS but that is
necessary for a smooth transition and
it's macros
so after a bunch of soul-searching this
is what we came up with some explicit
opt-in mechanism to say I'm sorry guys
but I want to enable legacy mode for
this this module I want some some some
way of saying turn on the ability to
store the macros from a modular header
including the ones from from all its non
module includes present them as part of
the module interface so this the idea is
that this preprocessor directive says
all the macros defined by this module
that you're currently processing they're
all export it but once we have that
something really nice happens the the
Clank style modules which as we've seen
enable smooth transition can now be
textually rewritten as modules TS syntax
so when you when you see a hash include'
of food of age you don't include the
real food rotation on desk you include
this fake food or h which imports the
module and the module takes the contents
of the real food adage it wraps it in
this export macro syntax we saw adds the
export sorry exit wraps in the export
module syntax we saw before add to the
export macros and then gives you the
same semantics that you are that you
want it and you have a choice here you
could do something like clang doors
where you have module maps and this has
stance to me automatically or and this
is the better part you can actually do
this translation yourself to the files
that are on disk you can check in the
result and you can transition that way
ok so when we have this we we write our
code like this the difference between
this and what we had before us we're
using this new in export macros feature
and now once we transition to this our
code still works and we can start to
clean it up we can move the dependencies
that we have that are I'm not supposed
to be exported out of our export block
when we've cleaned up our users we can
move
move our our class foo out of the turn
off the module linkage semantics block
when again when our dependencies no
longer rely on that we can completely
delete the header file when it's no
longer used I'll replace all the users
with import statements which you know we
ought to be able to do within minutes or
hours because I mean this is just a very
simple code transformation and finally
we can get rid of this export macros
directive when we're no longer relying
on it when we're no longer textually
what's a woman longer we're exporting
the interfaces of any non-modular
headers okay cool so we've solved the
problem we can now transition great
there's just one more thing so we do
still have all those those libraries may
be third-party libraries may be our own
libraries that we don't want to
transition yet for whatever reason maybe
we have open source releases and that
have to put the compilers C++ 98 or
without compilers whatever we do need to
deal with those somehow and with this
approach we are still cluttering up our
otherwise beautiful module interfaces
with hash includes textual inclusions of
the interfaces of other likelies you
probably don't like that probably don't
want that
and whenever we we rebuild our module
interface we're still going to be paying
compile time to repass these these other
libraries are the headers and we don't
want that either we would like that when
we change our module interface if
suppose we're just doing some local
testing we've got our library our tests
we change out our library a header we
just want to be compiled our own code
nothing else should be recompiled at all
and we still need this horrible export
macros directive which which we would
like to get rid of we would like to
transition away from that eventually
okay
so what do we do about this so we could
try to fix the problem for this this
third-party library one way we can do
that is we can refer a module around
their head of all that we could say we
know your header is module
so we're going to build a module for you
you're welcome
and and this is the psyche that should
work at first and then multiple people
are going to do the same thing now
you'll notice I was quite disciplined
here and I put like my beautiful library
object up there and maybe other people
won't be disciplined maybe some
whirlpool there's I don't Q object
someone else will cool there's Q object
you'll get a collision
won't you prick very pretty I won't do
what you want
another thing that's gonna be less than
desirable here is you get a certain
amount of duplication of completion
effort so once two or more people start
doing this you're going to be paying to
compile this the sink over and over
again once for each person who does this
sort of thing so we we have one last
week that we're considering this final
tweak is built on the export macros
directive and what you do is you say
import legacy some file and the compiler
synthesizes a module interface file for
you wraps it in the appropriate stuff
and gives it a name which is unique to
that file so every time anyone does this
they get the same module and this means
we now have quite a simple almost
beautiful interface for up for our
library we have just C++ source code in
here
the only exciting thing that happens is
we do have a macro here and this is part
of the cute library this this object
macro it's intentional we have that we
Ament to import it we get it we use it
and everything works okay
and using technique like this we think
you can take large code bases you can
increment B transition them piece by
piece so the module CS you can remove
the pieces you're not using when you
don't need them anymore you don't have
to wait for your dependencies to
transition to modules before you can you
get to go at your own pace do the pieces
that you want in the order that you want
to do them in and not have any friction
because
things change semantics in ways you
didn't like okay so there are a couple
of principles behind all this
the first one is that we really do want
to support an incremental transition we
really want to allow you to go piece by
piece step by step
stopping whenever you like and the
second one is this really fundamental
principle of C++ that you don't pay for
what you don't use so if you don't need
the expert macros directive don't use it
that's fine and if you do it's there for
you okay so there is a proposal for the
the two new features that we discussed
at the end here on the way to the C++
committee in a couple months time and we
will see how well that's that's received
whether they want to go in a different
direction or whether they think this is
actually a useful feature regardless of
that we're going to try implementing
these things in clang just to make sure
that our ideas do actually work and
speaking of implementations there are
two compilers that do implement as I
understand it production quality modules
at the moment M SVC implements the
current draft of the modules TS clang
has a partial implementation of the
current draft of the modules TS and
that's slightly modified by the changes
that I talked about from p0 to 73 and
it's going to have the features that I
talked about here in it pretty soon as
well that implementation is working for
aggress but but substantially complete
it's complete enough that you can you
can Bill cope with it and as I mentioned
earlier clang has for a couple of
releases had an implementation of what
I'm calling C++ 98 modules which is
which is using the existing hash
include' syntax to give you module
semantics all right any questions
it's see it seems to me that import
legacy would have similar problems as
pragma once as to determine whether if I
was unique or not so the the comment was
import legacy might have similar
problems to fragment once and this is
about determining whether it's the same
file yes that that's true
so in principle pregnant once has
various different problems particularly
on file systems which do duplicate files
in case where you have similes in
practice implementations have reasonable
solutions to those problems these days
they may not be perfect but in most
cases you can get the right thing to
happen with the fragment once and
likewise the right thing would happen
with import legacy have you thought
about you know not adding another
keyword legacy to the language and using
perhaps static for this purpose yeah
static we don't have enough meanings
aesthetic yet that's a good point
so actually one of the things which p02
7 3 introduces for the implementation of
a module we have instead of just saying
module 2 at the start we now say module
implementation foo and there's a few
other things like that and the way those
are handled is as context-sensitive
keywords so if you have an identifier
immediately after module we can
recognize that as being a special type
of keyword which is not otherwise
reserved and that's what proposes to do
for import legacy legacy is not actually
a keyword it's a context-sensitive
keyword thanks Marshall yeah we do
technically have register sitting around
that sounds like exactly the right
keyword
okay we make pretty heavy uses PCH files
and link time optimizations
how do modules interact with those or it
would that be something would be able to
check incremental e or is it an
all-or-nothing approach in inclines
implementation of modules we allow
arbitrary combinations of PCH parts and
modules so you can have even even
support even that's this kind of hard to
get into this situation when we support
building a module interface itself by
starting by importing a PCH file it's
very flexible and what we allow and
sorry what's the second part of your
question oh and the second part is a
link time optimization link time
optimizations okay so the design of the
modules ts very much encourages that the
module interface file is has the code
generation than the rest of the module
then people who use it so if it has
functions and variables and like to find
it you can generate the code for those
separately that's starting to work in
kinds implementation the the clang
modules approach with with module maps
and so forth doesn't do that but it's
something we're investigating is a
possibility for that site as well so
that's kind of part of the answer about
what happens at link time for link time
optimization well ultimately what you're
looking for there is the ability to emit
some kind of intermediate representation
that the link can then use to optimize
code with one thing we've talked about
is emitting into the PCM files that
intermediate representation in addition
to the clang ast because these for us at
least the two separate levels of the
compilation so we think we can get some
some gains there perhaps and do
something which is like LTO but a little
bit more localized thank you so I'm
interested in finding out which of my
existing headers or C files are modular
and which are not and fixing it is there
a critical diagnose set of Diagnostics
or a flag I should pass
trying to make this happen there is a
tool called modular ice in the Klang
distribution which can help answer some
of those questions and can help with
some of the transition alternatively you
can make some fairly good headway just
by building your header file as a sort
of saw as a source file by itself just
create a supercilious source file that
includes the header file nothing else if
that compiles then there's a good chance
that at least you're not depending on
anyone providing anything from the
outside but there's still a few site
conditions that that might trip you up
just a small comment when I saw a legacy
the immediate thing I thought of is what
happens when we do the next transition
to the next type of modular things and
we have legacy legacy maybe you should
use register I hope I hope the module
CSS forever so I see two opportunities
for modules to be very good for the
community one of them is an optimization
the other one is an architectural
building block which do you think is the
more important if you could have only
one okay so so the question is which do
I think is more important modules as an
architectural building block or modules
for optimization and do you mean
optimization for compile time or do you
mean optimizing the the generated code
because we can do both to a certain
extent okay so what I meant was a lot of
the time I'm concerned that we're so
eager to have modulus so that we can
compile faster we can get things done
that we might leave out some very
important things architectural e I see
modules as the next architectural step
after translation units and while I
probably can simulate the architectural
stuff because that's what I do
not everybody can so it would be very
helpful if we could have something that
is a real solid piece where we say we're
going to build components translation
units then we're going to roll them up
into modules and modules and translation
units place side by side right so
I suppose like your best summarize my
thoughts on this as modules for for
optimization for improving build
performance that's very much a short
term that's a tactical play in order to
keep C++ viable for people who are
having compile time pay modules to
fundamentally improve the semantics of
the C++ language that that's the
strategic play that's really where the
the value comes from five years ten
years down the line and that's that's I
think in some sense much more important
but its value that you don't get unless
you have the other thing as well okay
I was just wondering there was that I
didn't see any examples for like um
normally with like header files at CPP
files you have the declaration separated
from the definition you had like a
different file like a CPP and file for
the modules how would you go about doing
that or as are we with modules where are
you gonna be getting rid of the whole
separation or is it but that's a really
good question okay so the question is
with modules do we get rid of the
separation between implementation files
and interface files we have this cppm
suffix file is that just a source file
you don't need a separate source file
anymore so it can be that is certainly
your option you can put C++ source file
as source text in that module interface
file do everything you like in there
whether that's actually a good thing is
a separate question and in particular
the thing that you might want to keep in
mind is how frequently that code is
going to change what it's going to
depend on and have weekly that changes
because anything you put in your module
interface file if any of that changes
for any reason then anyone who is using
your module also recompile
so there are definitely trade-offs to be
made there and maybe we can imagine that
also becomes smarter in future and we
won't need to trigger those as we
compiles but a lot of current build
systems don't have the technology to say
did this change in a semantics
vii way so one of the earlier questions
about using this for architectural
reasons got me thinking about modules
versus namespaces and how how much
similarity and difference is there there
do modules participate in name lookup
when I say important food like what does
that actually do do I still have to keep
saying all the namespaces from it can I
import just food like from food we
import bar Python style or do I get all
or nothing so right now there is no
syntax to say that you only get part of
the interface provided by a module but
module names are a completely separate
namespace from namespaces we need more
words but anyway modules live in their
own module things live in their own
space that there is no link between that
and and then spaces the two are
completely orthogonal the only way in
which modules change kind of the name
lookup rules at all is in the sense of
module ownership and module visibility
so in particular if a module is not
visible you can't see the things that
are within it and in certain cases two
modules are allowed to have non
conflicting definitions of the same name
if they're internal to that module so I
could have like two different modules a
and B both of which put certain things
into namespace foo but if I only import
a ATO will be different things and if I
import a and not that I would do that
yes that could happen okay fantastic
just sort of an interesting question can
modules be nested to form hierarchies or
is that it's somewhat of an open
question this was something that p 0 to
7 3 touched on so module names can have
periods in when there is some notion of
hierarchy but at the moment all the
period is is essentially another
character that you can appear
modulename it doesn't mean anything
right now one of the things that that p
0 2 7 3 was I was looking into was do we
need some way of taking the interface of
a single module and splitting it across
multiple files and if you do that by
imports then you have this module
ownership constraint coming in and maybe
stopping you from doing some of the
cyclic references you want to make so
we're worried that people would turn to
ash increases to solve that problem and
so what we presented an alternative and
so far it looks like that's being
received favorably but you never know
how things are gonna go until they're
boots into the working paper yeah I
guess this is kind of answered already
but relative address relative naming of
modules seems like it might be a useful
thing to have but maybe that's still up
in the air my other question was about
export module as a preprocessor
directive is it scoped by a block in the
syntax it's for the rest of the file so
there's a question of is it for the rest
of the file or is it for the entire file
I think either of those is actually
acceptable
I'm optically tied to one or the other
the way that we have it specified
currently it says for the entire file
but it might actually be more useful to
say from this point onwards or something
like that but it's not block scoped
we're not expecting the preprocessor to
do brace matching on it yeah that's what
I was worried about Thanks okay that's
that's fine thank you everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>