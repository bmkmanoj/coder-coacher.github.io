<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: John Lakos “Advanced Levelization Techniques (part 3 of 3)&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: John Lakos “Advanced Levelization Techniques (part 3 of 3)&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: John Lakos “Advanced Levelization Techniques (part 3 of 3)&quot;</b></h2><h5 class="post__date">2016-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NrARQ7rHV-c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so we we are to say the least
a little behind and I think it's because
of the questions which I also think are
good I am willing to go either way but
I'm not possibly going to get through
all the slides if we have the same level
of questions I probably won't anyway but
I'm gonna get started if you feel you
have a question that just really you
need it in order to understand please go
ahead and ask if it's a question that
you can talk to me about afterwards
let's try to do that and with that said
the thing I talked about here is is
really a pretty edgy technique it does
achieve a purpose I think it's a
reasonable thing to do if you're trying
to present a view to a client where you
really don't want the client to have
access to everything that you're doing
right now and you want to distribute it
in your own time
what was that on his water okay that
scared me
ah all right anyway so as I said this is
an edgy thing it's it's really it's
really not you know you don't feel this
is the right thing to do that's
perfectly fine some people don't feel
they need to provide rapper components
they just trust their client to do the
right thing and then some don't
okay so now we're just going to touch on
a couple more things we're going to move
to the next section one thing I want to
say is the package naming which we
hadn't talked about until now is more
than just a convention you don't get to
name your components any old thing
because there are consequences so if you
look at this example we have a sub C and
and sub m packages the sub C packages or
excuse me the sub C components are
client-facing and the sub M components
are not intended for client use which is
a way of organizing something but when
you look at the physical ramifications
here are the implementation components
here the interface components it turns
out that you can see clearly that the C
sub C package depends on the sub in
package and similarly back and that's
not okay
so we can't do this even though we might
want to so at a minimum we're going to
need three packages to wrap this up the
wrapper sub at W package and the value
semantics type
that flow through the rapper package
down at the bottom and so another
possibilities we could break it up into
yet more where we have things that flow
through the interface and don't and
whatever but the bottom line is this is
a group of packages that together serve
some function so we call this a package
group but we're not willing to increase
the naming beyond just the few letters
sub W sub m and sub P and sub T notice
the implementation package name is a
little longer than the the interface
package name by design so this is a
package group and the way we're going to
name package groups without taking up
any more space is we're going to say
that the first three letters of each
package in the package group are the
same and that is the name of the group
and therefore groups need to be unique
throughout the enterprise because those
three letters are your the way you meant
additional packages in your area so sub
sub is the name of this package group
and has exactly three characters and
that's it that's my Fiat OK discussion
on that that was all I had left for the
last section why not
folders I want to have a name or are you
saying you want to have a hierarchy the
reason for not having a hierarchy is
that effects deployment right now I can
put any component dot o file in any
archive and I can put any header
anywhere in the enterprise in any
deployment directory any header file
directory once you do that you're tying
the directory structure into the
machinery of the component which
inhibits me and I don't like to be
inhibited ok good yes that isn't going
to help you physically well they can be
nested but we took care of that no weak
we care that the name not be a sub : :
sub m : : functioning we don't want to
do that we want to have just sub m and
have that work we want the name
to be short that's really important to
us we much rather have the name be short
so you don't use using if you use using
the whole point of this is lost the name
spaces sub in the package group name is
sub it all just works but package names
are unique throughout the enterprise by
construction ok so here are some
questions if you'd like to review this
is just section 3.5 of my new book I
hate to say yeah it's chapter 5 of the
old one it has all the techniques yes
including those it doesn't have as many
examples of callbacks it doesn't have
the final escalating encapsulation
technique yes the order is in the order
that I thought of them pretty much or
the order I felt like writing about them
in 1995 or 494 it's a fine order I think
so if you give escalation works do it
right if that doesn't work demotion do
it the simple ones are first and then it
gets you know other redundancy is
probably should come before another
couple of others yes you remove cyclic
excessive or otherwise inappropriate
dependencies physical dependencies link
time dependencies yes
yes level eyes yes but you can use them
to reduce dependencies as well you can
factor things you can do this is for
removing cyclic dependencies primarily
yes okay but we're done with that now
we're going to talk about some other
kind of dependencies this is the bonus
part this is the follow-on okay all
right
hi so the next thing we're going to talk
about is insulation which is the
analogous to encapsulation this has to
do with compile-time coupling so
insulation logical encapsulation versus
a physical insulation an implementation
detail of a component type data or
function that can be altered added or
removed without forcing clients to
rework their code is said to be
encapsulated okay now I'm going to read
another one an implementation detail of
a component type data or function that
can be altered added or removed without
forcing clients to recompile is said to
be insulated so here we have a
collection now this time the
dependencies are pointing up was easier
to do that way not sure it's the best
idea but anyway here's your client this
is this is the caller and here's a
library component and here is an imp
detail okay now if I make a change to
this imp detail you notice that it's
included by the library components
header and therefore the library
component has to recompile and the
client has to recompile okay D is
encapsulated by C because when that
change happens the client did not need
to rework code so it's an encapsulated
change does that make sense okay
but really we mean the use of D is
encapsulated so D the use of D at all is
not visible to the client
programmatically that's the point now
here we have implementation detail II
suppose it changes it's included by C's
dot CPP file when it changes the library
component has to recompile but not the
client so E is insulated by C or the use
of e is insulated by C you see what I
mean by u sub it's there's nothing he is
still available it's still usable but
that C uses it is not available to the
client in any way ok does it make sense
what the difference is ok so one of the
rules that we talked about is a header
file this is this is property one a
header file must be self-sufficient with
respect to compilation ok so there are
five reasons to include a header in a
header reason number one is is ax must
do it reason number two is has ax
can you think of what reason number
three might be what's another reason you
might yeah uses users type definitions
what am what users in the implementation
no turns out users in the interface and
implementation is not a reason to
include something in a header file
the read well the these are the reasons
if you're if you are if something is or
has a that is that is a reason to
include something and include okay if
you have this is an example right these
are points that are these are these are
examples of things that are used in the
interface but I don't just because I use
it in the interface doesn't mean I have
to include it I can forward to Claire it
okay so that's the point users in the
interface has it is users in the
implementation like but you can use
something in the implementation without
having it be has a-- like holds a-- is a
pointer to the thing and that's
different so if it's embedded data yes i
can do this this is fine just class
point works works perfectly so i don't
need to do this that's not necessary i
can do this just pointing out right even
though it returns it i don't need to
include as long as it's not an inline
function so in line if i have an inline
function body then yes i do
the fourth one is enum and the fifth one
is type def EG to a template
specialization so that's another example
and yet there's another one which is
covariant return types is another edge
case but basically the five is is a has
an inline enum and type def those are
the ones where you might need to include
a header and a header otherwise you want
to try to avoid that alright so next
example subsection is we have three
total insulation techniques these are
techniques for fully insulating
everything that's going on not partially
but totally so first one is the abstract
interface or protocol class and so
here's the here's the service and here's
the client and it doesn't matter what
goes on in the real service because
there's absolutely no no coupling
whatsoever so this not only is free of
compile time coupling it's free of link
time coupling
it's completely independent so that's
just great and this is clearly an
architectural II significant design it's
not something you can do locally you
have to you have to design your system
to do this ok so here's an example where
we have a bunch of widgets and we have a
framework that uses the widgets and a
nice thing about this is it's also it's
very good for decoupling systems ok now
if I want to I can factor out of the
widget a partial implementation so that
the widget is pure this is a very
important design principle and if we
were talking all about inheritance and
whatever I would talk about this for
hours but but we're not so the idea is
you don't want to have any
implementation in your protocol that's
we call that a protocol then whatever
factory we intend to do will move that
up by one level but the partial
implementation is typically not in
stanchion
and then the final widgets will fill in
the blanks not override existing
functionality but fill in those that
weren't filled in before ok ok so that
clear ok now there's this ugly name this
pimple thing pointer to imple or pimple
all right I used to call it a conker of
insulating concrete class basically what
it is is you have this concrete class
and it has an implementation and the
only thing you have in the class is a
pointer to that implementation and so
there's really nothing different between
every class that's a pimple and every
other class that's a pimple it just has
a pointer to it simple and it looks like
this and so here's my my class and it
has some member data and it has some
creators and there they are and here I
have manipulators and accessories nted
by this one thing because I didn't have
room and accessories should be
consequent out of room for that too
so free operators and they're down here
at the bottom and so this is the
implementation
so struct my class imple and it's just a
forward declaration and here it is over
here and we duplicate all the member
data and creators so we do that right
off the bat and then we replace the the
the data with a single pointer to imple
so instead of having D data we point to
the my class imple which is the the
instance there and then when you need to
eliminate all the inline functions
because that's compile time coupling so
they go away and then what do we have
now we have my int data with the Const
because there's room now and what's next
okay so now we have to implement this
constructor and what does it do it
allocates the imple and there's new and
in practice we would also deal with
alligators but if we did that then
things would become much more ugly so we
will ignore them for now just for
simplicity and so this is what it's
going to look like this is my class this
is the copy constructor and so to delete
it we have to delete the emple and then
the data we're just going to indirect to
the data directly so it's just accessed
directly we don't bother to try to wrap
the accessor zin the input because
really it's just private data anyway so
this is typically how we do the
conversion it's very mechanical and it
just works the problem is there's an
extra indirection when we do it so
clearly if you're going to insulate
something do it early in the project and
then once things have become stable you
might want to uninsulated but if you're
going to do it you're gonna get the most
bang for your buck early when you're
making changes so this is not
architectural II significant unlike
level ization techniques this is
something you can do incremental II back
and forth one thing you want to make
absolutely sure is you do not expose the
imple in the interface it is purely an
implementation detail of each individual
component class
questions yes using an internal buffer I
do not understand no I haven't
considered that why would I want to
consider that there I I think that
defeats a large part of the purpose
every every single pointed
implementation class looks the same
physically as every other one what
you've said is they come in different
sizes 64 128 256 whatever so the answer
is no I haven't thought of it now that I
thought of it I still probably wouldn't
do it
but I understand what you're saying I
probably wouldn't do even the pointer to
implement anyway because it's not
typically that important sometimes it is
but when it is when it is that's the
most flexible to do interesting okay all
right any other thoughts okay so the
next one is the procedural interface
this is here mostly for reference the I
just want you to pick up the high-level
ideas but I put some code in here
actually had to put on my reading
glasses because I wouldn't be able to
read it if I didn't talk about it anyway
we have some subsystem and it works fine
in C++ and now we're going to write C
like functions that deal with it and the
C light functions are a thin wrapper
they don't do anything else but
translate the the from from a see like
procedural interface to the C++ and so
all of this stuff is the object-oriented
subsystem and this is the procedural
interface and every procedural interface
function is independent entirely
independent of every other function so
it's physically
separate from any c++ components we
don't mix them in it's totally devoid of
additional implementation beyond that
needed for insulation purposes its its
named in a natural regular and
predictable way this is hard because we
obviously have overloading and lots of
strange functions and operators in C++
we have to come up with some sort of
equivalent names and C and they are
inherently ugly
they need to be callable from both C and
C++ immediately so we have to do some
stuff to make that work and exposing the
actual underlying opaque C++ types is a
good thing because then we can mix and
match we can even grant some additional
information outside the procedural
interface to create and insert from a
C++ client stuff that could be done
quicker if it were done in C++ rather
than through the procedural interface so
that's an example here's a point class
and point class it has this internal
include guard and enterprise-wide
namespace that we alighted so here is
the we have the the header and the CPP
and this is we always have a CPP of
course and this is always first as we
discussed and all of our code lives in
this global namespace and only member
functions are in the package namespace
meaning if we have member functions that
that that that's fine but if we have
free functions they're gonna live
outside the package namespace so here's
an example we have this this thing
that's an operator angle angle and you
can see that it's qualified and the
reason for this is if we didn't do this
if we tried to put it inside the
namespace we could get an overload error
it's one of the reasons why we we do our
utility classes as static methods of a
struct rather than doing namespaces just
one reason though all right so here is
my wrapper my z/b uses the same name it
just puts a Z underscore in front and
it's completely arbitrary but this
is the corresponding wrapper for this
component so there it is notice the Z
notice the include guards have the Z the
Z prefix provides the one-to-one mapping
all right and then you'll notice over
here with the creators we have all of
our nice little Z's in front too to
match what we need and so I added those
and if we're in if we're this is our if
we're in C we're using this part and if
we're in C++ we're using this part so
that's fine and then okay what's next
move that over okay and so this is the
correspondence between the the the
procedural interface and the underlying
interface and if you look at it line by
line this is the default constructor
this is the value constructor this is
the copy constructor this is the
destructor and you can see it's that's
just a mechanical transformation and
it's not pretty but I'm just
illustrating what it might look like
does it sort of make sense at a high
level you get the idea it's not
particularly exciting it's here for
reference and this is the CPP file for
the for the for the interface for the
procedural interface header and just in
clumps we'll just take examples of what
it might look like and I'm putting it
here again for reference it's going to
be on the slides which are going to be
distributed so I thought for
completeness I do this yes I'm not sure
you said a class that has virtual
functions suppose I have a class that
has virtual functions yes I I don't
that's the part I don't understand the
class itself has virtual functions right
so so
yes I think the answer to the question
is it doesn't matter because you're
passing the address of the underlying
object so it doesn't matter whether it
has true virtual functions or not it's
addresses its address so you pass it out
you have an opaque border you pass it in
it's fine now I think to be fair you
need you need to implement the static
conversions in other words when you want
to go from the derived class to the base
class you need to generate the
transitive closure of all of the derived
and base classes and call the right
function to do it mechanically and you
want to write a script to do that but
that's not that's beyond the scope of
this I remember when I actually did this
more than 20 years ago I had to do that
this was this actually was something I
had to do in in like 1985 believe it or
not her like not not 1985 like 1990 this
is old stuff this is like a chess tough
I just want to mention it but you can do
it you can do from one base class to
dorival class and back in C you just
have to go in or take the derived class
go inside the function and come back
with the base class it's just like a
static cast that's all it is
makes sense okay all right so now this
is just a quick plug for defensive
programming we use C assert because we
want to make sure that whenever we have
what's called a a narrow function narrow
contract we want to assert that the
contract is is being followed in in a
debug or safe mode and we happen to have
this thing called BS LS assert which is
in our public distribution you can go to
github Bloomberg and you'll find in the
BSL package group you'll see this thing
called BS LS assert and it's part of
what we're trying to standardize right
now it's not exactly the same in the
standard it's actually gotten twisted a
little bit that's what happens when
you're on a committee but it's more
general than what we have of course what
we have works really well but it's
library based and the standard is going
to go to a to a language
based approach if if it gets accepted
the thing is all of these asserts would
be here in in in anything that we did
for in the procedural interface and so
trouble is if you put this this stuff in
you could possibly return through C code
with an exception and we got to be
careful we don't do that now the the
it's not necessary for this particular
mechanism for you to throw an exception
you can abort you can do whatever you
want but if you happen to choose to
throw an exception on a precondition
error and it goes through C code who
knows what's going to happen so that
could be ugly this is clearly an
architectural e significant technique
it's not something that you can just
change willy-nilly you're really moving
four out of the C++ language into
another language so this is clearly a
boundary discussion on that I wrote that
myself in PowerPoint I have nothing
better to do okay all right so now we
talked about general general techniques
global techniques now we're going to
talk about partial implementation
techniques I think these are very
important because we want to be aware of
when we're just giving up coupling for
no reason we're just saying sure let's
couple the whole thing together
templates tend to do this as well
sometimes in certain contexts but but
when we're just coding we're not worried
about templates we could still be very
lacks and and couple things that don't
need to be coupled what's worse is
sometimes when you couple things you're
stuck and and there's a particular case
where a long time ago I was I was I was
working at Bear Sterns at the time and I
had written a abate a hash map and the
hash map think it was a hash map yeah I
think it was a hash map anyway hope I'm
telling the truth
anyway it was a node-based container and
whenever I needed a node it would
allocate I think it was a hundred
elements and sewed them onto a free list
and then and then it would use them one
at a time and whenever he did more and
allocate 100 and this was fine it seemed
to me until one fine day somebody
decided they would create an array of a
million of these node based containers
and populate them sparsely with like one
or two notes and of course at that point
the whole thing blew up and they said
you got to fix this right away
now it turns out that I was at the time
aware of insulation techniques and so my
memory strategy for my pool was not was
not exposed in the header it was all
done in the implementation so all I
needed to do was change that number from
a 100 to 30 to compile it
put the dotto in front of the library
which is essentially a patch and it all
worked within a couple of hours had I
not done that had it been in the header
file and compile time coupled it would
have had to go through the middleware
and those people who were on vacation or
whatever and by the time they released
that I would have been fired so the
thing is I got it right away with a
patch because it was an insulated change
and then later we could work through the
proper release channels okay so that's
really really important to be able to
just drop something in where you can and
so that's why this technique is super
important it saved my bacon and it could
save yours and besides that it's just
way more efficient in terms of
rebuilding your software when you don't
put everything out in the in the for the
compiler to have to redo so the first
example is just contacts s to an array
so here's an example where I've got some
data and I want to be able to return the
data now I could put the data in a
static buffer in an array I could just
put it right there and it would be
plopped down in every single translation
unit and if you had to change it well
then everybody'd have to recompile but I
don't have to do that what I've done
here is I've got this sum I've got
is in as a data member I have something
that that I just asked for the whatever
whatever data entry I want by index and
it just returns that information and I
can get the length the same way just by
asking how long is this thing so I could
easily iterate over by getting the
length and saying for I equals this blah
blah blah and and get whatever I wanted
now the data is in the CPP file but I
don't want to pay for anything I
actually want it to be just as fast as
if it were in the header file and it
turns out that here's my data and
everything is done at compile time it's
all setup at compile time so there's
really no runtime operation at all when
I go to access the data it just works
it just it's just that it's just as good
because all that information is right
there and available without having to do
any indirection
now if I change the data here I'm going
to eventually change it hold on here I'm
going to change the data and here I go
and what I do this all I have to do is
recompile the util no other client has
to recompile because nothing in the
header file changed it's all the same
stuff do you see how that works so it's
a little bit of extra work but why not
because if you want to change the data
if that's important to have flexibility
there you go this is how you do it okay
makes sense possibly all right that was
not too hard discussion yeah smart guy
does what static constant of what we're
talking about on the order of days not
while it's running right I'm changing
the source code recompiling my stuff
Reed linking the program statically
linking the program so it's not the
running program does that make sense
it's not I
there's nothing to count unless you're
saying he cashes it in a database okay
there's no there's no compiler that this
that's smart or dumb depending on how
you want to work it okay all right next
is what I'm gonna call a toy stack so
I've got this stack it's really dumb
it's just a stack of integers and I hope
I'm telling the truth is it a stack of
integers yes no it's a stack of toys
that's what it is it's a toy stack of
course would have to be a stack of toys
all right anyway so this is the
interface and it's just to illustrate
what's going on we know how stack works
we construct one and this is what the
constructor for a stack looks like let's
say and then we want to push a toy onto
the stack
and so this is what that looks like
so this is all in the implementation
right we haven't we it's all completely
insulated there's nothing nothing going
on that you can see except for the three
data members right now suppose we want
to push this into the two in line to
make it faster so we do that so now push
has this in line please keep in mind
that I would never really put this code
right under the function it would be
down below and would stay in line and it
would be separate from it but because
this is a presentation I took some
liberties so now this is what's going on
if d underscore length equals capacity
then we're going to resize otherwise and
hold again we're going to resize yes
then we're going to unconditionally do
this new thing and whatever by the way I
always put braces around him so unless I
don't have room on the slide so this was
hard for me to read anyway so this is if
this is not true then I'm going to just
jump over that and do what I need to do
and notice that I'm doing a lot of
memory management stuff in line and
that's not usually a good idea did I say
that no that's not true I forget that I
said there's a lot of stuff going on
here what I meant to say was I'm not I'm
not doing the memory management stuff in
line because
the resize is going to do the memory
management out of life what I'm doing
here is just what I need to do to grow
the stack so the next thing here is
suppose they are equal yes well then I'm
going to call this this resize function
which means I'm going to jump to the
private function which is my entry into
the CPP file that's what I'm doing I'm
going from the inline function to a
private function that's not inline and
that not private inline function resize
is going to do the work that I needed to
do and it says if the capacity is 0 make
it 1 otherwise double it so that's my
strategy that I'm going to use for
growing my stack size and this can be an
insulated change what if I want to
change it to 2 or 1.5 times I can do
that and my client doesn't have to
recompile even though the stack push
method was in line because the hard work
was factored out and put in the CPP file
ok this is called a partial insulation
technique how do I put all of the code
into the interface number one it would
bloat the code number two I couldn't
change it if I wanted to without
recompiling all my clients and number
three the the the includes that my
clients would presumably have to deal
with like whatever met other things any
other any other includes for example if
I had to include any anything having to
do with allocation or memory or whatever
whatever other kinds of things this is
also typical of like i/o streams where
you don't need to put all of the the
code in the header file because you can
you can sequester it in the CPP file
that's the third reason so you cut down
onto the dependencies you cut down on
the code bloat and you increase the
ability to change it without forcing
clients to recompile all positive
benefits and maybe I want to do this
Sims insulated optimization where I
change a copy to a move again it's all
in the CPP file I don't have to worry
that my client is going to have to
recompile it's all it's all sequestered
there ok so discussion on my toy stack
makes sense the idea is the same we're
moving we're moving stuff that we can
that is it's not doesn't happen very
often is very expensive is very has lots
of dependencies we're moving that to the
CPP file so when we change it our client
doesn't have to recompile all right the
next one an adaptive memory pool
simplified so here I have this this
basis for actually a multi pool
allocator and the idea is it has
allocate and deallocate and it allocates
pools of different sizes and this is
just what I just said okay so so for
example this has three three allocations
worth and you'll notice that each time I
I allocate a new thing it doubles in
size for first time I allocate one then
when it runs out I allocate two more and
use one when I when the second one is
called I run out I allocate four and so
on and here this this is much bigger
size objects right so I have all these
different objects running up from here
to here now if there's nothing needed to
that size there's nothing there it's
empty so this is like I call it a
beanstalk there's all all these
different size pools these adaptive
pools which when requested give you
initially one then two then four then
eight and so on okay so if something
comes in that's too big we just put it
on the sort of the too big list these
are oversized things so that's how that
generally works the one that we've been
using a lot is pools of size 56 so these
once I get to 32 it didn't bother to go
larger but with the design we have right
now it wouldn't hurt if I just kept
going forever it doesn't matter so how
does this work let's take a look at just
one pool so the pool it has a list of
blocks and then it has okay then that's
that's oh and then well this is the
memory blocks of arbitrary size okay and
then it has the block size which is 56
bytes here that's the one that we're
interested in we have the
sighs which is how many how big how many
of these blocks of size 56 do we have
and then then that's showing that we
have the begin pointer and that's saying
where where the next memory is going to
come from and we have the one passed the
end pointer which says where I'm going
to be when I get to the end we have the
free list and the free list is the list
of things that have been put back
because somebody did it the allocation
so this is a state of this adaptive
memory pool and okay so now I'm not
going to talk about what's inside the
pool I'm just going to sort of talk
about the interface for now and so these
are all empty lists this is this is this
is what the what's what's being
maintained and so this was created with
with the size of 56 and this is an
arbitrary sentinel and it turns out if
you look closely it there might be a
better Sentinel value who will see and
that's one and why is not all that
important but anyway so let's say I want
to allocate so if I allocate what
happens it allocates one thing and it's
returned and then so so that's now now
if I allocate again it allocates two and
returns the first one of those and then
if I call the allocate then it returns
the one I just had and puts it on the
free list and then if I call allocate it
returns the second one deliberately
returns the next one here because it's
faster okay and then if I call allocate
again then it decides to look at the
free list before it allocates again and
it returns that one and this continues
you allocate something and now it needs
to allocate for and return one and in
time this is what happens so anyway this
is the this is the implementation and
yeah this is just straightforward I'm
just just sort of highlighting what it
looks like okay and here's the
deallocate now this is what we need to
do to link something on to the free list
and
if there's something available so here
here's the is really the point this is
what we have to do to allocate something
if there's if there's a if there's a
block available and in the current chunk
then we're going to do this this is the
this is the the fully insulated
implementation and then if there's not
we're going to check the free list and
if not that then we're just going to
create a new block so these are three
different parts of what needs to happen
when we do an allocate so now hold on a
second so now we're going to put all of
this stuff here in the header file and
we're gonna say if yeah so we're going
to move some of the we're going to move
some of the implementation to the CPP
file but we're going to keep the most
important stuff so in this case if I
change the the max chunk size to from
say 32 to 64 I can do this I can add a
special case and we get a speed
improvement and I can change that and
that and we get a space improvement but
these are all changes that I can make in
the implementation without affecting the
client and so what's happening here is
as a as a again a partial insulation and
it allows me to facilitate performance
tuning think about it this way if you
had to recompile the world every time
you tweaked your your implementation
you wouldn't tweak it that much but if
you can tweak it link it in and run it
tweak it link it in and run it tweak it
link it and run it then it's going to
make things go a lot easier for you so
it really is a kind of important thing
there's another way we could break this
out too we could we could make things
smaller partial installation reduces
code bloat if there's a so for example
if there there's a block in the current
chunk return it as quickly spot
so now what we've done is we said you
know there's a part of this that I
really want to run fast so I don't have
to do all or nothing I can say you know
what I'm gonna I'm gonna take a little
bit of this out and put it in the header
file and that's okay otherwise I'm gonna
do the rest of it so it says that and
then anyway the idea is you can you can
do as much or as little in the in the
header file as you think it's
appropriate the more you do in the
header file the more there's code bloat
but at the same time maybe it's the part
that gets exercised the most so it might
make a lot of sense to do the first
attempt at acquiring something right
away and then if that doesn't work then
you say well it's very infrequent to
have to go to the free list or
reallocate a new block so I'll do that
in the CPP file but as far as just
trying to see if I have room to quickly
return one link let me put that in the
header file let me put that in the
inline function so that's what that's
talking about
okay so discussion on that that's a lot
of code late in the day I didn't want to
go through it it's on record you'll be
able to see it on this in the in the at
your own leisure and read it but at this
point that going over it line by line is
probably not worthwhile do you get the
idea though that there's some parts that
aren't used a lot not very big don't
have a lot of dependencies don't need to
be tweaked because that strategy is
stable put that in the header file put
the rest of the stuff that needs to be
tweaked in the CPP file using a
carryover by calling a private method
that goes over into the CPP file yes
link time code generation I don't know
what that is I don't know what you mean
by can't you certainly can do it this is
designed to be used in a conventional
well the as I said the idea the idea
here is if you put stuff in the CPP file
then you when other people wreak one
other
when you change something and recompile
your stuff the other people don't need
to recompile their code because your
header file didn't change now if you're
doing a whole program optimization it's
not a very large program so it doesn't
really matter
oh dear well that's not my understanding
I don't know what very large is to you
but if we tried to use whole program
optimization whatever it was that was
doing that would catch fire and burn so
I I don't know but but I don't even know
how to answer that
but I'm telling you that the purpose of
this is for conventional builds you know
static libraries this is how this is how
we would make it easier for people to
fine tune their their performance
without having to rebuild the world
that's that's my answer
I think any questions on this no yes
good all right so here are some
questions that you could ask yourself
about what I just talked about
so how about this one why when would you
put a pounding clue directly yeah type
type def - template yes good that was
excellent okay so there are five reasons
and of course covariant return types
okay which total insulation technique is
not architectural yep
oh good pimple dang that's great all
right I really don't have time to do
this last one but I can start and I
might we'll just see how close I get
okay so the whole thing that we've been
talking about the way we do architecture
is based on organizing principles and
the most important one of those is sound
physical design so you this is an
example of how we create a bit ball of
mud we start out as developers and we
say I've got an application and I have a
library and that's good because you want
to separate your library code from your
application code so if somebody else
comes along they can use your library
code without mucking with your
application and somebody else comes
along and said well I know you guys
don't need this stuff but somebody else
might so I'm gonna build it this way and
it's good and then somebody comes along
and doesn't play fair and decides to
have an application depend on another
application the applications are
malleable and therefore they change and
therefore app four becomes very unhappy
because the code stops working right
whereas the libraries are stable let the
apps are are not so this is bad and of
course we have you know continued to
work and then somebody gets this crazy
idea of pointing a physical dependency
up we don't ever point physical
dependencies up with the one exception
of the the insulation slides because
that was easier but we don't do that but
anyway it's still not a cycle now it's a
cycle now we have Lib C and the second
version of Lib a cyclically dependent
mutually dependent that's not good and
then library D comes along it's still
kind of okay and now it's all gone to
hell in a handbasket because we have a
large cycle in our in our design and
then you know app four is doing its
thing and then everyone
stop scaring and then it starts to look
like this and then pretty soon it starts
to look like this and this is not good
and then it starts to look like this and
this is really not good and oh well so
good physical design is is it's an
engineering discipline not an
afterthought we have to do it from its
inception and you know at the very point
where you you try to decompose the
problem into separate problems that
you're going to try to solve separately
and then recombine into a final solution
if you separate them this way you are
doomed if you separate them this way or
this way and then solve them bottom-up
you might do okay so that's the sort of
the very high level advice if you will
okay so here's an example of a design
that you'd be reason we could imagine
creating something like a logger and the
logger depends on a lot of software
reusable software and that's good and
then you know you have this transport
and the transport depends on the logger
which that's because transports have
lots of problems and when they have
problems you want to log whatever's
going on there now we're sort of at an
application level and then of course you
might want to build a mail system on top
of some sort of transport so that's a
good thing and it has its own little bit
of of implementation components we like
that and then what happens somebody
comes along and says you know that
transport is so flaky the next time
something bad happens I want the logger
to send me a mail message and that's
this and that's a bad idea
so we do not want that to happen now one
of the examples we used I think we saw
this is that we can use indirection
we can use a protocol to fix this and
the typical example is we have an
observer in the logger where we can
register an adapter and then we can test
the logger to transport the mail system
and then finally we can test the adapt
by registering it in the logger knowing
that the longer transport and mail
system work so this is a good thing so
when we're designing think like this and
not like this of course the next one is
don't build a date class that looks like
this right we don't want to do that this
is the date that depends on everything
and Oh anyway it was once said when when
when I was at Bear Sterns it was
suggested they're out of business now so
I can say this we hired a consulting
company and they were obviously a little
confused they suggested the the standard
layered approach where we have the data
access layer and the business object
layer and the control object layer and
the presentation layer and oh by the way
we're going to write it in Java it's
going to be awesome and the problem is
that they wrote classes like this where
clearly the data the the leaf level data
types depended directly on the database
and that's like this right and of course
that means everything depends on the
database and you can't take the database
on the train with you when you're trying
to work on your code on your laptop so
this was just disastrous and when my
boss at the time he couldn't believe
that they were actually suggesting this
he became irate went to the head guy and
the head guy called a meeting and and
and they pointed at me and said John
tell him tell him what you think
so I started and then he just kind of
said okay and and then he said so what
stuff you send your B team oh that was
awesome
anyway I thought I was going to get
fired because they refused to work on
the project unless I had nothing to do
with it and and it was kind of it was
actually very good because the deal
didn't go through and it was one of the
best things that could have happened
they were charging like more than 50
million dollars for nothing so I did I
turned out I did a good thing that
anyway water under the bridge but it is
a true story anyway so here we have an
example of what I would call a lateral
architecture where the business objects
are that or the value types are at the
bottom they are very lightweight they
represent values but they don't
not glued into anything else the
business logic uses the value types the
business loaders read the database and
populate the business types and then
there's something at the top the
coordinates the whole thing so this is a
lateral architecture not a layered
architecture and this could be done in C
it doesn't have to use virtual functions
or anything now if you want to get a
little more clever you could do
something like this and here what we
have is we have some abstract interfaces
that allow us to swap out a database
with maybe a different database or maybe
just a test database but in any event
the database is in no way coupled to the
rest of the system so this is a very
nice decoupling mechanism and accessing
a database is a perfect example where a
virtual function call is not going to
hurt you even if it goes ahead and use
calls an indirect pointer not to worry
about it okay I hope I hope everybody
trust me on that one so anyway this is
this is this is a very flexible version
of what I just showed you before now if
I had time so what I might do is I might
go through this at like a hundred
thousand to speed and and I won't
explain to you what's going on but
you'll just see suppose somebody said
write me a date apply a date class that
tells me whether today is a business day
now the first thing you do is you have
to parse that and say well that means
that I'm gonna have something like this
which is kind of like the date class we
had before with poor logical factoring
it's not flexible
it's just bad so what do we really want
to do if we were gonna solve this
problem we don't have time for we'd say
what are the real requirements
well-represented eight value as a C++
type determine what date value today is
determine if a date value is a business
day and provide well factored useful
components that we'll need to over and
over again that would be the goal we
have one minute so I have no idea what
to do but I can just run through these
slides and it would look something like
this now we use color actually to
represent different kinds of types so
mechanisms are green those are those are
in stanchion types that don't attempt to
represent a value and a day a week is an
enumeration
it's blue because it does try so it's
true blue you know Green is a little
closer on the color scheme to things
that that are not in Stan shil
and here's a date which was a value
semantics type so it's a value type okay
and this is how we would represent this
organization and then determine what
date value today is well it turns out we
would need to create a bunch of stuff
here and just to quickly go over it
these that we need this and the pink
thing by the way is it is a util all and
then that's its color so as we go in
that direction they're not in stanchion
types and it would look something like
this but you notice we had to do a lot
of stuff to get there and then the next
thing is determine if a date value as a
business day all right well we got a lot
of stuff to do here so without wasting
any time protocols are yellow they're
between green and pink and here we go
and so we have this and there's a
problem we don't have a data source
because in order to answer this question
we need data and so you need a calendar
cache right to go get the calendar
whatever calendar we're using and of
course we're going to need calendar
loader to go out of this library and and
so here's here's our calendar kick now
that's actually in the application area
but it's a mechanism to influence the
calendar loader that gets us the data
that allows us to access the calendar to
do whatever we need to do and now we're
good and it turns out they're a couple
of extra utilities we might want to have
like we want something we don't want to
put it in date but we want to get the we
want to get the fourth Wednesday let's
or fourth layout fourth Thursday in
November 2016 it's a useful thing to
know we're not going to put it there
we're gonna put it in a date util that
depends on date and some other things we
might want to do something like modified
following for a financial services
industry which means find the next
business day at or after the given date
otherwise the largest business the the
most recent business day in the date
before the current date and we put that
there and now we have the complete
picture and I'm just going to go through
this this is now components not classes
and I'm just gonna
really run through this now what we're
doing is we're back filling the problem
we're saying what other things do we
need to do to fill in the implementation
even though it's not client facing and
this is just a little discussion about
transitive dependencies which I'll skip
and so here's an example client facing
will add some other pieces that we need
and we have it looks something like this
we're adding all that stuff in on the
back end not no one sees it it's just
for us so it would look something like
this but the truth is it doesn't really
look like this it looks a little more
like this well that's not even really
true it looks like this this is what you
need to do what I just said properly but
we already had most of it before we
started so this is our stack if you have
any questions that's the outline and
here's the conclusion because I really
want to be done with this and that's the
end</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>