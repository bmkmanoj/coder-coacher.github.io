<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Jeremy Demeule &amp; Quentin Duval “Using Functional Programming Patterns...” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Jeremy Demeule &amp; Quentin Duval “Using Functional Programming Patterns...” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Jeremy Demeule &amp; Quentin Duval “Using Functional Programming Patterns...”</b></h2><h5 class="post__date">2017-10-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nR2raX2-a0Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Hello, and thank you everyone
for coming to this session.
Before we start
we will proceed with a small experiment
on Jeremy.
So, Jeremy
as a C++ developer,
and just glancing at this code,
how would you feel
about maintaining it?
- Well, not so much, in fact.
- So that's a no.
We'll repeat the experiment
with a different code now.
So, Jeremy,
how would you feel about
maintaining this code?
- Yes, much more readable.
This looks like
HTTP routing API.
So yes. More clear.
- So that's a yes.
So we can close the experiment now.
100% of the test subjects
preferred the second code.
So this is a success.
In fact both the code,
the two examples we showed,
they do exactly the same thing.
And our goal today
will be to describe to you
the approach we used,
inspired by functional programming,
to get to this.
- And we also will provide you
some particular way that we,
C++ developer,
can use to apply this approach
in other contexts.
- So a quick word about us.
This is Jeremy,
working at Murex almost 10 years now.
And he was there last
CppCon for the CDBC poster.
- And this is Quentin,
C++ developer at Murex too
and functional programmer enthusiast.
So what is the context?
At Murex we have some C++ colleague
and we have to expose some part
of the code
over HTTP and API.
So, the purpose of today is to build
over an HTTP passport
a layer of code which transform
HTTP request to response
by calling the right code.
- So we'll start by doing
everything manually.
We will build this player that transform
request into responses.
Manually just to show you the concepts
between HTTP routing
and also to show you
how quick it breaks.
How quickly it breaks when
we try to do it by hands.
So we'll start with a simple HTTP server
and what we'll do is.
We will send request to this server
and the first request
will be a get request
to the UTI/vi/foos
and we expect the server to answer
with the list of all the
foos inside the system.
- So for this simple purpose
we can start with a simple functions.
Or this we should take request
and a written response.
Inside the function we
look at the URI
inside the request and we match exactly
what we expect
and then we can just return the response
by calling the right code
with the correct status.
- So this is the resulting code
for just the simple request like this.
Well it's readable.
So lets try something a
little bit more complex and
first we will add a second code.
- For second URI
we can just add the new if
or can use the more advance C++ feature
like mud from string. The URI
to a function, the
function you want to code.
- So copy paste is always
the answer apparently.
It works.
We'll try a bit thing a bit more complex.
So what we will do now is
instead of sending static URI.
Meaning URI doesn't contain variable,
we are going to send a URI
which contains something
that we must extract.
So for instance we're
gonna send the get request
to the URI/vi/foos/2.
Where 2 stands for the
identifier of the foos
that we would like to retrieve.
So how can you do that?
- So this time we can't
use exact match anymore.
So we have express all
the URI you have to match
and in C++ we have regex which done it
to express this kind of things.
So lets use regex and
match what we from what we match.
We know what to do the global code
or the more specific one.
- So this is the full code.
We can see that it starts to smell a bit.
We have regex, we have a bit of
extraction.
But yeah it's still readable.
We can still maintain it sort of so
lets make things a bit more complex still.
This time we will send a post request.
Until now we've only querying
but it's not very useful
if we are not able to insert something
inside the system first.
So we'll send the post request
to the URI/vi/foos with the payload.
And the payload is the foos
that we would like to insert
and then obviously if we
query for this new foos.
We want to get it back.
- So this time in addition of the regex
we are also to match the
HTTP, the request method.
The HTTP verb and start.
- I think we can stop there.
I think we reach the point
where it's broken already.
Lets look at numbers.
We just have four routes to self
and we already have 30 line of code
and eight conditional branching
and three nested levels of indentation.
So this is a mess.
We started from an architecture which was
pretty simple. Where we
were supposed to transform
requests into responses
and we ended up with this.
Which is a mess
in which we have parsing,
matching, error handling.
Some business code, yeah
I think we are missing something.
- Yes what we are missing is
an abstraction of the routing part.
So as we saw the manual routing
only works for very few words
and it's not scalable.
- When we'd expose,
expose our approach the first
one that we are gonna look at
is an approach that is
inspired from Java and C#
and which is called aspect
oriented programming.
Which we will abbreviate
AOP starting from now.
So it works in Java, it works in C#,
so why not for us?
So to understand how it works,
we will go back to the
first code that we worked.
We had a process function
which took requests
and we've done the response
and then we started to
do the routing inside it.
So we want to get rid of this
so we will try a new strategy.
Which is to split this function
and have one function
for each of the route
that we want self.
So basically we want to
get rid of the if statement
from the function.
A function which are well names
and find a way to associate a URI
with a function that
will answer the request.
- So as we say,
we don't want general purpose function
to under other requests.
So one function for each different request
and we declare with
attributes or annotation,
the URI we want to match.
Something very more declarative.
- So this works,
it's more declarative
and we can associate that way a URI
with the function that
will respond appropriately.
Not only will it enhance it
for in stems to extract some
parameters out of the URI.
So in our case we're gonna
associate v1/foos/ a placeholder
name ID and
the framework that we're
gonna build is able to match
this ID by name to the
parameter of the function
and to help the framework a bit.
We're gonna use a new annotation,
a new attribute name PathVariable
and what the framework will do is
when it receives a request
it extracts it, it try to
match it with the right type
and if it's not the same type.
Lets roll and exception.
- Okay,
now we have several mappings
which can cause the moods
and we have to bring them together.
Usually in our world
it's managed by a class named controller
so lets reuse this patterns and
introduce control.
And now framework is needed
to register the routes
inside all engine to
dispatch the correct URI
to the right functions.
Also we use annotations
to declare this class
as a controller.
- So I think it works.
We can make it still
better by using something
like meta class. Why not?
So we use a meta class controller
to declare a full controller.
But there's something that annoys me a bit
with this approach.
As Jeremy said,
we gave the control of the instantiation
of the full controller to the framework.
So we cannot instantiate it,
we cannot give something
to the constructor of this
controller so if,
my foos and my foos vi
ID needs something like a
DB connection. I cannot inject it
inside the full controller.
So how do I do?
In fact to get some control back
you have to use some interfaces.
So we have to declare your outside wall,
your debilities when you
are in the interfaces.
Which is full services here.
This way we can mitigate to someone the
way, the way to right
of the re instance to manage this kind of
external dependencies.
As we already totally
divagate the management
of the full control framework.
We also can divagate the way
to retry this information
by using the new annotation inject.
Which tells framework to use
some kind of dependency injection
to retry the re instance.
- So that works,
we know of four different
kind of annotation.
But hey it gives so.
We can try to instantiate more services.
For instance if we want
to deal with the foos in
our system, we keep the foos controller
and then we can add a bar controller
if we want to deal with
the bar of the system.
And then the framework
is gonna do some magic
and is gonna bring the
full controller together.
So that it dispatch the right request
to the right controller.
So it seems to work and
I have a question for you.
- Yes.
- How would you like,
to implement this?
- To implement this?
I think this can be fun, very good change.
- So a good change.
Second question,
how would you feel about using it if
you're not the implementer?
- Well not so fact.
- Not so much.
- Yes.
Yes in fact we are dealing with since we
are not very C++.
This code not feel very C++ like we like.
With annotations so,
a lot of run time
run time friction.
And this is doable but
only with some tuning some,
un cogeneration so.
Is fragile and not very natural.
We use interfaces so
one time polymorphism.
We use it in C++ but we also
like to pay for what we use.
So not this kind of things,
not that way for every
external dependency.
Is not natural either
and finally we use dependency
injection to use...
To know the code is
correct only at runtime.
This is very tiring full process
and this not feel very C++.
We like our own compiler.
- So these are only some of the reason
why it's not a good idea already
to take just watching this in general
and put it into C++.
But in fact there are other things
that we would like to
improve about this approach.
The first thing would be.
The limited composition.
We declared the URI inside
request mapping annotation.
Which means that the URI are strings
that are not accessible
as first class amend.
We cannot just manipulate them,
we cannot create a function
that will return them
and condemn in the annotation.
And that deprives us of
being able to factorize
the URI for example.
So that's the first problem.
We have a second problem.
Which is that the cohesion
is pretty limited.
We sprinkled some URI
in different controllers.
In different methods
and so nowhere we have a way to see
the router and all the routes
that we have inside our cell.
So we would like to
improve on this as well
and the biggest problem
actually is the coupling.
We put annotations everywhere
and these are annotation.
They going back to the framework.
Each and every line of code that we write
needs the framework to work.
So we end up with a situation
which is pretty much depicted by
Joe Armstrong.
The creator of Erlang
which describes the situation
in which we want a banana.
But in fact what we get is a
gorilla that holds the banana
and the gorilla is so much
attached to the jungle.
That in fact we get all the jungle.
In out case that would be this.
We just want a route
for instance to test it
and the route is inside the controller
and needs the controller
to be able to do it stuff.
And this controller has also
annotation to the framework.
So in fact we cannot test the
route without the framework.
- So to summarize a little
we want to achieve the
same level of abstraction.
To be scalable but in addition we want
to have code very normal,
natural in C++.
So very more C++ like
we also want to increase the transparency
and to prefer composition
to build higher level concern.
And finally we also want
to have building blocks
which is reusable with
those whole framework.
- So we tried an approach
it did not work very well.
So we try a second one.
This time we turn to
functional programming
and the way we're gonna do it
is we are gonna look at
some of the big ideas
that we're gonna use.
Three big ideas and then
we are gonna show you
how we used them
to improve the API
and get the code that we
showed you in the first slide.
So first idea.
The first idea is
defining clear semantics.
We really would like to avoid things like,
publishing a concept
name a high controller.
Which quite frankly,
does not mean much.
We will try really hard
that every of our concept
that we expose in our API
have one abstract definition
and by abstract we don't mean vague.
We mean precise, we
want to define something
that points right to the
essence of the concept
that we expose and gets rid
of all the implementation
details that we don't care about.
The way we're gonna do this.
We're gonna use a simple trick
from functional programming.
We're gonna use pure function.
So for each concept,
we're gonna associate the pure function
that we present the meaning
of this concept.
So that's the first idea,
the second idea is composition.
We really would like to avoid
the phenomenon that we had before.
Which is the gorilla-banana syndrome.
We'll try really hard again
to translate each of out concept
into one separate entity in the code.
We don't mix them together inside a class.
They are separate,
obviously at some point.
We will have to build the router.
We'll have to find ways to combine them
and the way we're gonna do this
is by composition.
We want to keep really
simple building blocks
and then via the combinatorial
power of composition.
We want to find ways to
assemble them together
in many different ways.
Some idea
is to keep and to use simple constructs.
So at some point
we have to take a concept
and put them into code.
When we're gonna do this
we're always try to go
down the pyramid.
So we're gonna use plain old data
and by plain old data we
mean data without behavior.
Something like a vector could be qualified
as plain old data in our definition.
And if it doesn't fit,
well we'll try functions.
If data and function don't fit,
we try classes
and then we're gonna
go to meta programming
and things like this for
the icing on the cake.
Just to make things look nice.
So that's it, that's the approach.
- So a quick scenario of the goals
we want to give meanings
to the expose concepts.
We want to focus on competition
so to use things which compose way
and we want to prefer simple construct
to facilitate the composition.
So in our domain this lead
us to four main concepts
and one like car.
Lets start with the simplest one,
business.
Business is here to make the glue between
the outside world. The HTTP world
and the business logic.
It has to for specific request
take parameters form the URI
and returns appropriate answer.
Apply to C++ this is
just a simple function
with the request and additional parameter
and return the response as output
but of course calling
the right business code.
We don't need any interfaces,
no dependency agitation of any sort.
Just a simple function.
- So that's the first concept.
Now we're gonna look at the second concept
which is the one of the path.
So what's a path?
It's something that if we match it,
we want to execute the
associated end layer.
So we could see it as
the set of accepted URI
for a given end number.
Which can be seen again as a function
from a URI to a Boolean which says.
If it's inside the set
and that would work.
But we would like to refine it a bit
because if we look at
something like a regex.
We can see that there are capture groups
and so in our case as well.
We would like to extract
something from the URI
and give it to the handler if it matches.
So if we do this,
we're gonna refine our concept
to extract the parameters and their types
and that gives the definition of a path.
Which is a function from a URI
to an optional parameter.
Why is it optional?
Because we may not match.
So that's the semantic model.
How would you translate it into code?
- Into code we choose to work,
have a direct nothing
from the semantic model
to the code.
But to keep only that up.
The transformation URI to parameters
just apply here.
Indeed we have only the
starting definitions
but the key point is to
store enough information
to be ever to foos the semantic way.
When we really need it
so at runtime.
It is also possible to notice,
we can construct the path piece by piece.
This way we can read the partial path
which is a very dark and the request
to be another work.
So very composite verb.
We just talk about combining things
and we already define two concepts.
Now we can take a look about
how we can have a ration between them
and this will lead us
to the word concepts.
But instead of presenting it directly,
we'll do an exercise to rediscover it
from the semantics model
of the previous one.
- So lets do this.
We have a path and we have a handler.
We know that they are
associated to each other
by the very definition of a path.
Which is if we match it
we want to execute the associated amount.
How can we find the
semantic model of a route.
Well we're gonna look at the
semantic model of the path
and the request and we are
gonna try to match them
and see what we get.
So the path was a function
from a URI to an optional
parameter and the request was a function.
Which takes a request then the parameter
and returns the response.
To match them we're gonna
transform these two equation
basically to fuse them into one.
So the URI is inside the request.
So we can transform the first function
and says that in fact we're
gonna take our request
and return an optional parameter.
Now we see that we have the request
in the two functions.
So we can try to factorize this.
We can always do this thanks to caring
which is the fact that.
When we have a function
with n arguments it can
be seen as a function
which takes only one argument
and returns another function
which takes n-1 arguments.
So we can factorize things like this.
Now if we look inside the params
we see that we have an optional parameter
and we would like to fit
it inside the function.
Which takes a parameter
which is not optional.
But we can fix this, we
can just put optional
in the input and the output
of the second function.
Which we can do again, thanks
to functional programming.
The name of the concept is factor
and now we can choose these
two function by composing them
and what we get is the concept of a route.
Which is something which takes a request
and returns an optional response.
So that's the semantic model.
- This is the semantic model of world
just add till we find
it a little about the
meat behind these definitions.
We also need to match the HTTP verb
so a route need to match the HTTP verb,
the URI against the path
and to code the numbers.
In C++ we choose to use the
HTTP verb as constructor
and to bind the path with the number.
The semantic model of the path
written some parameters.
So we are able to match to manage them
at contact time with the
signature of the numbers.
- Okay so one thing to notice is that.
We are able to keep the types.
So if we want to capture an integer
and the function that will
provide accepts the string.
For instance it won't compile,
so this is how we get a route.
Now one of the program that we had before
in the API approach was that
the router did not exist.
We couldn't see it. We
were assembling controller
and some way, some how, something was
dispatching the request.
We would like to have
things that are explicit
so we're gonna build a
router. So what's a router?
Is something which takes several routes
and it will take a request and
it has to return a response.
Even if node match we have
at least to return something
like four four no results found.
So the definition is this simple function.
How can we do this into code?
- Into code we show a simple function
which take a very big number of foos
and being it will return it to dispatch
the request to the right route.
The right business code to code.
We have a different route
it has to like a switch a different case
in the switch to return rest
of the code the same match.
So this is very concise
with this eight lines we describe all
the previous manual attempt
we saw just before.
- So we are done with the
core concept of the API.
So we've got the handler, the
path, the router and the route
and now we will describe the last concept.
Which is not strictly needed
but which is really useful.
It's the concept of the middleware.
To explain what a middleware is
we first have to explain what
are cross cutting concepts
inside the cellar.
So here are our two routes,
we have a first route which returns
which lists the foos of the system
and we have a second foos
which lists all the bars
of the system and returns
them as a response.
Actually inside the HTTP server
we might need something more.
We might be interested for instance
to log every time the
first route is matched.
Because it's so important.
The second route might be very critical
and we might be interested in adding some
additional write checks on top of it.
And the way we could do this
is I could go inside the
list of foos function
and just add some logs
and I could go into the list bars function
and just add some additional write checks.
But it will not be great
in terms of design.
- Indeed, it is possible to do better
or we think we do better.
So the purpose of the video is to provide
the correct handlers.
So a middleware is just a function
which take a number
and return a new number
correctly with the new behavior.
In your log case, this
will be a simple function
which return a number.
Like and this one like previous handler,
the regional one and do
the special stuff here
to log the URI.
Very simple.
- So a middleware is just a function
which takes a handler and
returns a new handler.
Decorated with some new behavior
and this is nice because
because we return the same thing
that goes inside the function.
So we can take a handler, decorate it
and it returns a new handler.
Which we can feed into a new middleware
which gonna returns a new handler.
So we can compose them.
Which means that we can
build something like
stand up middleware by
composing something that
first check the rights
and then if the rights are granted.
Logs that we have matched the request
and then we'll call the
appropriate function.
So using this simple trick
what we can do is just rely on composition
to define only simple building blocks.
Which rights will be a very short function
with logs as well
and offer some ways to combine them
so the user can have plenty
of behaviors available
out of releasing the building blocks.
- Now we define the concept on the APIs
we can take a look at the result
and some benefits we get from this usage.
We transform the four request
and here's the resulting code.
The full resulting code,
we'll come back several times on it.
So lets start with some numbers.
We have four routes, 29 lines of codes.
Which is quite similar but
it seems more scalable in this case.
The syntactic complexity is very low, one
and we thing we are at a
good level of abstractions.
- Now if we go back to the code,
we can look at the shape of the code
and see that it's split in two basically.
So we have the left part
which is the router
and we have the right part which we put
all the handlers.
If we zoom on the router,
this is what we get.
So it's concise, it's pretty readable,
and it defines all the routes that we have
inside our cellar.
This is how we get the equation.
Another cool trick with
this server is that
it's totally decouple
from the transport layer.
So what you can do is
just take this router,
it behaves like a function.
You can fit it a request
and see what goes out.
So we can test it easily without mocking,
without dependency injection.
We can even do better,
we can zoom in on just one route
and assign it to another
variable for instance
and then we can test
this route in isolation.
So we can just try at least on foos
and see that it extracts
the variable correctly
from the path for instance.
- This other path has handlers
and finally they are
just simple functions.
They are not coupled
together behind an interface.
It shows then our so simple.
We can use them independently without
dependency injection of any sort.
As a result we think the
client code is very simplify.
Very easy to reasonable it.
Each piece can be or
concept are understandable
in these situations.
So the amount of knowledge
to use this kind of API
is very low
and this transpose to
the client code to...
We enforce the client code to
build it in the same way.
So very easy to combine.
- So one of the reason why we think that
it's simpler to use this API is because
instead of going the AOP road
and going up the layers.
Inside the AOP approach
we use mainly annotations.
Meta programming things and so on.
We went down and we don't
use powerful constructs
which are often complex. Instead we use
really simple things
like data and functions
which are really compos-able.
Functions to compose them you
just have to match the types.
Data to compose them it's really easy
you just nest the data
inside another data.
But in fact there is another
advantage doing this.
Because when we go up the layers
what we get is really often opaque
and hidden.
Meta programming things they
happen during the compilation
so at runtime you cannot even see them.
Classes you build them
mainly for instance for
encapsulation. So you
cannot see inside them
which is good for implementation details
but for somethings you want to show them.
By going down the pyramid
what we get is plain
old data for instance.
And plain old data you can inspect it,
you can look at it, you can transform it.
And this allows us to get it right.
So what is right?
It's an abbreviation for
do not repeat yourself
and it's often misunderstood as something
which is about code duplication.
About copy paste basically,
so this is a quote from
Dave Thomas, one of the guy
who coined the DRY term.
Which says otherwise, it
says that it's not about
copy paste, it's not
about code duplication.
What it is about,
it's about knowledge.
There is a ton of knowledge
inside the application
and what we want to do is
try to put this knowledge
in one place for each piece of knowledge.
You have one place
which is the authoritative place
form which we can derive
the other piece of data.
From which we can
transform the data to get
the same knowledge under a different form.
So that's the principle of DRY
and in out case it would
translate into what?
- In your case DRY is about
keeping one referential
of informations. So in
your specific domain,
this is a router.
We have so much information
inside the router.
It would be a shame to not use it
as a reference.
We also choose
the code because we are C++ developer
and we like to rely on the coupling.
But it's not the point to choose code
so the key point is to
choose one referential.
It can be the code or some resource slide,
XML, Gammify anything you want.
But to derive this information
to other forms.
- So one first example in
which we use this information,
we already showed you.
It was type safety.
We use the router to
contain data and types
are a kind of data
and what we did is we
avoided to erase this data.
So we keep the data we
don't erase the types
and because we do this.
We can match it against
the handler and check that
these are the same types
and again if they don't
align we don't combine.
- we use information inside the router
to for example generate documentation.
We have all the information
so for a given router
we are able to visit it and to generate
for each of these route
some kind of documentation
and I think you like one of them to...
- Yup so by visiting the information
we can generate documentation
but we can also do other things.
One of the thing that
we found really useful
was random generation.
So what do we mean by that
and why would it be useful?
So here we have a sample code
in which we have a router with two routes
and what we can do is
implement pretty simply
a generate function.
As to generate two random routes
and feed them back into the API.
If we do that we are
able to do something like
first testing for instance.
We can check that our router
will accept all the routes
which should be accepted.
So that's one use case,
there is a second use case
that we find. We could
for instance have a client
which is interested in
testing our HTTP server
and will ask us for sample route
so that he can test against us.
Again we can just ask
the generate function
to produce some route.
We can even ask this on single route
so that we can generate a route,
send them inside the mail.
I don't know to the client
so he can test the API.
So these are only three
use cases that we found
and in fac they could be plenty more.
- In routes we can predict
the usage of our API.
So by keeping the information open
we allow the user to extract information.
Give us to do things we can't anticipate.
We don't think this will
derail the encapsulation
principle. It's just
exploiting information
it already provide.
- So basically,
what we want to say by fulfilling DRY
and following DRY is that
there are really two ways
to look at this code.
One way to look at this code
would be as a piece of code
that dispatch request to
the associated handlers.
The appropriate one, the
second way we can look
at this code is as something
which is responsible
for the information that we give it.
When we start seeing this code
as responsible for the data
we know that we can reuse this data
and we know that we
should do the best we can.
Not to lose this information,
so no type erasure for instance.
Not to hide it,
it's used less to encapsulate information
that was provided to us by the client
and to make it available
so that the client can
reuse this information
that he already gave us to
produce additional feature.
Build some tools for instance.
So with that we presented
basically the API
and what it looks like
and we would like to
give you some takeaways.
That we think can be transposed and used
in other contexts.
- So the first one is
to define the concepts.
Very abstract but very precise
and of course apply to your domain.
Think then as pure functions,
they do one things but one things well.
And don't let the code disturb you.
It's very high level
then in the second time try to apply it
to the code and finally the C++ concept
on contracts will help
us a lot in the future.
- The second big idea that we think,
that we can apply almost
everywhere is composition
basically. One of the key
principle of functional
programming is trying
to have separate blocks.
So we try to keep our concepts separate
and then we find ways to compose them.
Composition allows us to
build complex behavior
out of really simple building blocks
and to do so. It's
easier, it's much easier
if you're using simple constructs.
Like data of functions.
- And finally the following information
so keep them in order to transform them.
Make the information open
by using some plain old data
and what the user give
you is the replacing.
So keep them safe
and APIs are responsible
for the given data.
Finally use this information
everywhere you can.
- So these are only three
big ideas of functional
programming. There are plenty more
that you can take a reuse.
But we would like to step back
and look at what we did today.
The first thing that we tried
was taking something that exist
inside another language and
just transpose it blindly.
So we took AOP, we look at annotation.
Transform them into attributes
and yeah it did not work out very well.
- In the second times,
we not attend to co piece turn on.
We just adapt ideas
and it worked much better.
- So basically we think that
there is a lot of things
that are attractive
in functional programming
and maybe we would like
just to copy the features.
But maybe the best way is just to
instead of looking at the features,
looking behind these features.
Looking at the motivation, the big ideas
that are behind this
features and in the end
just steal the ideas. Not the features.
So thank you.
(clapping)
So if you have some questions.
Sorry?
- Is that email, that's not email?
- No that's Twitter handler.
- So is this framework
that you're gonna use or?
- You mean is it, is it
available on the GitHub,
no not yet.
- We are working on it
internally in our company
but it's not ready yet.
- Do you try to apply to same approach
for a single candle.
For instance we post each there.
- Not really, this approach
we used it in different context.
I had a last assignment about login API
I could use the same.
We think that you should
be able to transpose it
in really different context but,
we are just experimenting with it.
- Hi I saw the parameter,
how does it.
- Oh sorry I didn't get it.
- I saw the example, the request.
To get the request.
- Yup.
- If we have more than one parameters,
for example we have
integer or street or babble
how to write the code.
- Okay so the question is,
what if we have several parameters.
We can in fact the way we
maybe we can go back to the
slides where we have some path.
What we provide inside the API
is basic building blocks.
So basically you saw that
we have a parameter path
to say for example that we
want to match an integer.
We have another one for two string
but you can define your own
and you can combine them
with the slash. So you
can do for instance,
all slash parameter to the string slash
a param slash user slash and so on.
So you can compose this
and what's gonna happen is that
if you define your route with this path.
The handler has to
accept as many arguments
as there are elements
that capture these element
inside the URI.
So basically if you have
a lender for instance,
the lender will take and if
you have param in param's
two string the lender will
have to accept a request
followed by an integer
followed by its two string.
- Okay another question.
I think maybe it can be improved.
I think that the parameter
and the body can be
illuminate because the
path is fixed right?
And the input parameter
can be deduced by the
handler's parameters.
- Yeah, maybe by changing.
So the question was, maybe
we could remove some of the
type information inside the path.
So that in fact we can try to deduce them
from the handler.
I think we could do that if we just
are interested inside by the dispatch
of the request inside the route.
But what we build with the path is that,
we put them inside the router and
we can reuse the
information at every level.
So we can reuse the information of a path
and ask the path. Can you
please describe yourself.
Or can you please generate a route
that would match the path?
So maybe that's a trade off.
Trying to have components that are
independent and which can work in autonomy
makes better for the
read information. Maybe.
- Thank you.
- Some other question?
- What requirements do we get for
that to be usable as param?
- So,
do you want to take the question?
- In fact not so much primitive
they are all very easy but
if you have we can provide
suggestion adapters
by using some kind of idea.
It can be a special suggestion.
It can be every kind of types.
- What we do basically is that,
we ask for functions to
be available on the type.
So we already provide
some function to describe
for instance an integer to indicate
what is the pattern that must
be matched inside the URI.
And the same for generation so,
some kind of arbitrary generator.
So available on integer, if
you define this for your types
then you can just put this inside the API
and it could work fine.
- How do you know if inside the functions
that you're looking at.
- Sorry couldn't hear it.
- So how do you hold a
different type of function
in the router type?
- Okay so, the way we
do it is we don't erase
the information and we use boost now.
But you could use different things to,
I mean you could recommend
something to visit
heterogeneous sequence is
that would work as well.
- I got a question
okay so I'd like to know.
What is the actual type
of that router?
I saw auto, what is that type?
- It's ugly.
(laughing)
- It's everything.
- It's big.
That was a question that we
had in a previous session
in which it was us. How big it would be
and if it would not break.
So in fact what we can do if
we go to the router is that
since the router accepts.
Oops.
Here accepts a lender,
we can inside the lender
put another router if
we want to erase types.
If we do that,
we lose some of the features.
Because it becomes opaque basically
but it allows us to for instance.
Declare a router specialized for the bars
another one for the foos
and bring them together as a router
for the HTTP server.
But basically it's more meant for
small services.
But yeah the type is
a router underscore T,
templated on the path.
Templated on the yeah...
You get it.
- So one more question.
so when we check our request,
it goes in order.
- Yup.
- So that means that the,
the first route is always tested.
So routes towards the end
might take a little longer.
- Yup.
- To match okay.
- That's one strategy.
- That's one strategy
but in fact we have all the information
so we can build more advance
way to reorganize the,
the matching using a tree or
an ash or everything we want.
- In fact there are some
APIs that we looked at
in closure and ask languages and
they sometimes refer
different ways to match
so some of them. If they find out that
all the routes are static.
They just build them up
because it's the most efficient way.
Some other API they try
so the common paths and it goes down.
It really depends.
- Excuse me I was just
wondering whether you need to
bring the routers within the path.
So you can subrouters within the path
so you have like partial matching
and then you've got a new router.
Then you're describing and
anything else would work for that
so they're matching, the router matches.
We know that's the path.
- So just to rephrase,
because I'm not sure to understand.
You mean that we could put the
router inside the router or?
- A different routes inside the router
but using the path syntax
and then you have a new router in there.
- Yeah maybe.
Yeah I guess we didn't try this actually
so we didn't think about this.
Oh yeah the remark was that,
we could maybe improve
the syntax of the path
to for instance put a
router after a slash.
Yeah, great solution. We
didn't thought about that.
Some other questions or?
Okay so thank you.
(clapping)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>