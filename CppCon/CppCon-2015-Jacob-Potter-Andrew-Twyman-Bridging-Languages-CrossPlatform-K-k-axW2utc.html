<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Jacob Potter &amp; Andrew Twyman “Bridging Languages Cross-Platform...&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Jacob Potter &amp; Andrew Twyman “Bridging Languages Cross-Platform...&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Jacob Potter &amp; Andrew Twyman “Bridging Languages Cross-Platform...&quot;</b></h2><h5 class="post__date">2015-10-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/K-k-axW2utc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome everyone thanks for coming
I'm going to get started we have a lot
to cover today so I hope that we don't
get too rushed I would ask you to hold
most questions till the end if there's
anything that's really unclear or you
think blatantly wrong feel free to call
that out but i'll save side
conversations until until the end so
high I Andrew Twyman this is my
colleague Jacob padder okay we work at
Dropbox on the cross-platform
infrastructure team what that means is
we help build libraries and tools for
building cross-platform code primarily
aimed at mobile and these are our three
Dropbox mobile apps you can see across
the bottom there so we're supporting a
multi-product code base as well as a
multi-platform code base focus primarily
on iOS and Android though desktop and
server platforms are on our road map as
well so here's a really brief overview
of our architecture we let our app
developers build their you eyes on in
the native language of whatever platform
they use or the natural language i
should say we also want to take
advantage of the platform's frameworks
and services that are unique to that
platforms we do that in the language
that it has to be done in but we want to
be able to write the core a pelagic the
business logic the communication with
the server the data storage in c++ codes
that we can share it across platforms
now between those two obviously has to
be some kind of bridge to get you from
one language to the other and that is
what we're here to talk about today the
specific language is we've been
supporting for a couple years now our
objective c in Java which are the
preferred languages on iOS and Android
and the bridging technologies are the
things that you have to use to get
through there and we have generation for
those as of today it's not advancing we
also are adding Python to the mix and
I'm going to spend some time a little
bit later on talking a lot about how we
did that and what we learned from the
process about kind of the general
procedures of bridging languages before
that a little bit of context and I want
to pull the audience really quickly how
many of you have seen the talk that we
gave at TV con last year where we
introduced Jeanne
about a third how many of you have
actually tried out Genie the tool that
we've open sourced mostly the same
people I'm unsurprising how many of you
have done any kind of bridging of C++ to
another language includes see okay
almost everybody s you got some
experience here so I'm not going to
repeat a lot of the higher-level
contexts that I gave last year I
encourage you if you haven't to go back
and take a look at the talk there's a
link here I'll give it again at the end
of the talk along with other links but
I'm going to give a introduction that's
just kind of enough context to
understand what we're going to talk
about today which is going to be focused
on implementation techniques and
technical details of how we did this and
all these details are not necessarily
about Jeanne only there about bridging
languages in general so I'm going to
talk about what we did with Jeanne but
you can generalize this to your own use
as as necessary so we are going to talk
about I'll do a quick review of the over
overview I'm going to talk about how we
added Python the kind of sub problems we
had to solve while bridging to it and
we're going to deep dive into a couple
different implementation techniques that
are relevant across the multiple
languages that we've done so starting
off with that brief introduction what is
jeannie well Jeannie is a code
generation tool that we've open sourced
that we use internally it generates that
language bridging layer that i showed in
the architecture diagram earlier if
you're going to follow our architecture
let's say you're going to do android and
iOS which is a pretty typical mix of
platforms you want your UI code to be
able to call a common implementation
your implementation might look something
like this in c++ which is you've got a
class it's got a method you want to call
and you've got a structure that contains
some data you want to pass through that
method pretty basic stuff so what do you
have to do if you want to do this well
you need to implement the class that
you're going to call you need to make
calls to it in Java and an objective-c
and then you need to do one more thing
which is to describe the your interface
in a way that our tool can consume using
the genie I do that's four things three
of them you would have had to do no
matter what you were doing you know
you've got to have a have a function to
call you got to have some calls to it
the one which is the IDL is what allows
you to not have to do all the rest so
this is all the stuff that Jeannie then
does for you once you provide that i dl
it provides abstract classes that
represent your model class in all of the
various languages where it's needed it
could provides concrete classes for your
data structure that you're going to pass
and then it provides all the bridging
that allows you to marshal these things
back and forth between languages when
it's doing that these are the basic
principles that we're following one very
important one is that we want developers
to be able to interact with natural
looking code in whatever language
they're using if you're making a call
from Java that happens to be implemented
in C++ that doesn't mean you should
follow some arcane syntax or know about
jni or anything like that we want you to
just make a method call as if it was a
Java object and have things work the way
we pass control between languages as we
make method calls we're not doing
serialize off RPC we're not going out of
process we're not doing protobuf system
like that we want things to just be
calls with arguments and return values
the interfaces that are callable can be
referenced from any language meaning you
can implement them in one place call
them in another place doesn't matter
which one as long as you put a couple
decorators in your IDL saying which ones
you would like to work because they
generate different code and then when
you pass data between languages it
actually gets copied because once but
because it has to be different types in
different languages we couldn't really
get around at least one copy being made
Genie supports these basic custom types
that you define in your IDL interfaces
are like an abstract base class in C++
you can implement it in any language
column for many call it from any other
language we have records things to think
of those as structs their immutable or
at least immutable through the bridge
they are marshaled by copy as I
mentioned and they contain other data
which might be records might be
containers might be primitive values but
not interfaces and also they contain
things by value therefore there's no
recursion
this isn't day you know tree that you're
building out of your records just record
and lastly we have enums there like a
scope scope dhinam in c++ those are very
basic they're just there so that you can
keep your values in sync between
languages you'd have to worry about
somebody changing in it value or adding
one of course we've got all the other
stuff you need to go back and forth I'm
not going to go into detail on most of
this one interesting one to mention
though is optionals how many of you have
used optional whether it's experimental
optional boost optionals and like that a
couple people this is basically just a
nullable value type so you can return
something or pass something x value but
you can either give it an object or not
give it an object without having to
resort to the heap and pointers we use
that a lot in Jeanne interfaces here's
an example of what Jeany IDL would look
like so you have an enum with a few
values you've got a record can contain
that enum contain a string this record
is asking Jeanne to create equality
comparison and ordering comparison
operators for it automatically then you
can have an interface this interface is
declared so that it can be implemented
in either java or objective-c not in C++
but you could add a plus C there if you
want to do the other direction as well
and then this interface has some methods
has a static method which is useful as a
factory so you can create one in the
first place and a constant all should be
relatively straightforward stuff cool so
that's hopefully just enough context for
you and understand what Jeany does and
what the basic types are and now i'm
going to focus on how we implement that
you don't need to know all the details
of exactly how a genie interface is used
or declared or what the options are so
much is what it's for is calling between
languages and let's talk about how we
get it specifically how we did it for
Python now Python was a was a challenge
for us it turned out to be more
complicated than we expected I want to
give a shout out to Julia our intern
from Yale who dove into this over the
summer and we like to throw in our
interns at the deep end so the reason
this was a bit of a challenge was that
we hadn't done very much bridging a
Python before we are when we did object
to c and java we had a lot of prior art
of handwritten marshaling that we could
look at for best practices for Python we
were kind of making it up as we went
also python is a lot more distinct from
C++ than Java or objective-c it's not a
SI derived language it doesn't have
strong typing so we had to make a few
things up along along the way but these
are the basic steps of the approach that
we took and I think they could be
applied to any language you have to pick
what the genie types are going to turn
into when they get into the new language
you need to figure out what your
bridging technology is that lets you
actually get between languages figure
out how that rigid technology meets a
few basic requirements that are kind of
the basis that lets you build a bridge
in the first place and then build our
Genie specific infrastructure on top of
that so let's start with step one types
when picking types for Python we want to
be idiomatic as I said we want the
classes to look natural like Python
programmers would expect how many people
have used python by the way okay almost
everybody so hopefully I'm not confusing
anyone and I'll go through these
examples pretty quickly so we want to
use the native Python types that the
programming expects we want to support
the level of flexibility that you expect
in Python such as duck typing and we
want to support both Python 2 and Python
3 which leads to a few interesting
details for us to deal with along the
way the basics I saw python has numbers
we need numbers it doesn't care as much
about limited length numbers as we do so
there are fewer numeric types that we
use pythons containers map very closely
to jeannie's containers their hash based
if you've ever taken pipe code from
Python two to three you know that
Unicode strings are one of the tricky
pieces and Geney does its best to follow
the best practices there but it is
liberal in what it'll accept it'll take
a string in any form but when it
produces its string it'll always be a
Unicode string and bites will always be
the right representation of raw bytes
rather than your code string and lastly
optionals don't have as much meeting in
Python because everything is by
reference and everything is nullable but
optional really just tells us whether
none is considered a legal value on an
argument or a return value so let's walk
through the individual types in five
we've got records which are just a
python class with some fields which are
named python is pretty loose about this
all fields are held by reference and you
can add more fields later if you want to
so really the only thing that declares
your fields is your init function Genie
generates all right just lost my mic
communing it back all right so that's
what a record would look like when
Jeannie generates it enums there
actually is a built-in emailed and type
in Python 3 it's available backported to
Python 2 so we will generate one of
those for you to give you consistent
values of your enums we use in denim
which means these enums are
interchangeable with stainles in python
code it also means that when you give us
an enum to make a call you can give us
an int and it'll be just as good we
don't care if you really use our own
type but we give it to you so you can
have it now for interfaces interfaces
are abstract base classes Python does
have a striped bass classes again in
Python 3 backported to Python 2 so we we
will make use of that if you choose to
make use of that then it will enforce
that you remembered to add all of the
necessary methods that your abstract
base class requires the way is to
declare it with that with metaclass is a
little bit weird that's from the future
module it lets us get provide code that
works in both Python 2 and 3 each of
which has a slightly different syntax
for for meta classes but this basically
works the way that you would expect but
but you might cry I said I want to
support duck typing and now i'm talking
about specific types that i'm generating
and abstract base classes that want to
enforce which methods you created so
some people like strict typing
particularly if they're coming from C++
some people don't we want to support
both of them so we give you all the
classes you need so if you want to
follow the strip the strong typing and
get the guarantees that comes with it
you can do that but as long as what you
give us acts like a genie type we'll use
it so like if you give us a
implementation of an interface that only
has one of the methods as long as that's
the only one you ever call thengels will
work
if you ever call one of the other
methods then you'll be pretty unhappy
right so that was step one we know what
we want everything to look like in
Python let's talk step 2 which is how do
we bridge from Python to C++ so we use a
technology called cff I it's out there
on the on the internet you can google it
stands for see foreign function
interface no seee not c++ which means we
have to go through see on our way to
python so it's pretty well accepted it
works in both or multiple different
Python implementations which is nice it
works on both major language versions
which is nice it generates code actually
see ffi is itself a language bridging
code generator which is kind of
interesting which make but that
generation makes it more efficient
because that code can get compiled and
has less one time cost than the dynamic
code you might have to use otherwise and
if you happen to be you have UCF of I or
plan to use it in the future no that it
has multiple modes of operation and
we're using API mode out of line but
that means nothing to you don't worry
about it because I'm going to describe
how we use it which is what that means
so here's the layers of a Python app
that uses Jeanne you've got the app
itself you've got those generated Python
classes that look like the examples I
showed you you've got this compiled
extension module which is what cfi
generates which is specific to the
Python implementation you've got a see
interface that Jeanne generates which is
C functions that are implemented in C++
this is a common thing you've probably
seen if you ever had to interact with C
code before you've got a dot H file
that's pure c-band then you implement it
in a dot CPP file everything's happy
that wrapper interface can then call
directly into the generated C++ classes
which Jeanne also generates for you
which in turn can go into your code or
come from your code where you
implemented an abstract base class in
C++ or did whatever you do so these are
the layers cff I being a code generator
itself has some build time inclusion in
your build process as well as at runtime
so you take your C++ code and the sea
jeanie generated for you build them all
together into a library Genie generates
you some code that will feed cff I the
declarations of all the functions it
needs to call it actually parses the
header files feeds Amanda cff I to make
sure that you have a single point of
definition cff I in turn generates some
C code that Britt that talks between
Python and those see functions which
gets compiled into a Python extension
which is a dot s 0 file at least on Mac
that's what it is and the final result
is that you've got a compiled binary
that's opera optimized for interacting
with Python and hopefully as efficient
as possible and all of this is done in a
way that is specific to the platform on
which you're running the build so if you
want to do both Python 2 and 3 use the
same code we should run these build
steps separately generate two different
extensions that you would load in a
Python 2 or a Python 3 interpreter so
once you've done that at Build time
things are pretty easy at runtime you
want to load the compiled Python
extension you can load it just like any
other python module with an import then
this lib object lets you make calls to
see functions and it does some of the
basic marshaling internally of course in
our Jeanne generated classes we don't
want you to call c functions or you want
you to call ordinary methods so we have
a proxy that'll hide this and give you
something that looks more like a normal
Python interface so let's go on to step
three which is if we're using cff I does
it actually meet our needs and what are
the basic needs that we have in order to
build the language bridge sorry those
needs are you need to make calls in one
direction you've got to make calls in
the other direction you got to be able
to pass data of some sort and you got to
be able to refer to an object from the
other language so that you can pass it
around and you no point to it in a call
things like that calling Python to C++
is pretty simple given what i already
showed you like we've already got that
from cff i calling in the other
direction is not quite a simple because
cff I is only really available in Python
there's no way for C++ to talk directly
to it but there is a way to set up a
callback which can allow sea of lost
to talk to it as long as Python set
something up in advance the way you do
that is you can decorate your function
with this callback decorator that allows
it to create a function pointer that C
can use or C++ can used and you would
have to make a call in to C++ give it
that function pointer and it would store
it somewhere in our case in Jeanne it'll
store that into just a global variable
and we would do all this initialization
when the Python module gets loaded so
that by the time you can call in to C++
and you can try and call back into
Python everything's ready and all your
callback should work so how do you pass
data in theory you can build a bridge if
all you've got going back and forth or
bits and bytes you know that's what
everything is anyway but it sure helps
if you've got some richer types you can
use on the on the interface so CF if I
can actually understand arbitrary see
types so we can take you to take
advantage of that we don't use all of
them we use all the primitive types
which Mac map directly to what we would
use in C++ and then everything else is a
pointer to an opaque strut meaning
what's eff i sees is a struct
declaration with no definition and all
it ever tries to do is pass around a
pointer to that struct and then the
struct is defined in C++ so we can hold
on to standard strings and vectors and
things like that again this is pretty
standard if you've ever bridge C++ to
see you hide everything behind a pig
structure so I'm sorry now the last
thing I mentioned is how do you
reference objects between the directions
going from C++ to python we use one of
those opaque structs that i mentioned
stick your C++ object in there pass a
pointer to it see if fi holds that in
what it calls a see data object which is
just an object of something with a
c-type in this case is C type would be a
pointer that all is relatively
straightforward if you go the other
direction again you've got a little bit
more work to do but it's still
relatively straightforward cff I gives
you the ability to create a handle which
is a CF if I a see data object that is
derived from a Python object you can
pass it to the C++ as a void star we
actually do a cast and turn it into
something with a slightly more specific
type just so we can keep it straight
when we're writing our see
interfaces then C++ can grab that
pointer hold on to it pass it back to
Python later in a call back at which
point you can call from handle get back
the original Python object now I've
skipped over object lifetime and
ownership here there are some tricks
which I'll get back to a little bit
later but this at least does allow you
to refer to an object and reference it
find it later so those are the are the
basic features that you need to build a
language bridge and I think I've proven
or at least concluded that CF if I can
do that but that is far from everything
that Genie actually wants to make use of
so let's talk about how we build some
higher-level concepts on top of these
basic concepts so the primary features
that Genie needs to do its work is it
needs to be able to proxy an interface
across languages these two marshals some
data used to be able to own objects
across languages not just reference them
and it needs to be able to handle errors
and exceptions that might come up we'll
talk about each of these four things in
it in turn proxy objects is just
something that allows you to hold onto
an object in language a that forwards
all of its methods calls to an object in
language be and it needs to hold
ownership so that when you're done with
the object in language a it goes away so
as you get separate proxy types with
Jeanne will generate generate for you in
each direction so for instance a my
model CPP proxy is a Python object that
inherits from the object abstract base
class my model in Python it owns a
reference to a C++ object which itself
inherits from the abstract base class my
model in C++ which is a C++ class of the
same name and the proxy when you make a
method call on it will just forward it
all down through the bridge through cff
I through all those layers get it down
to the original object and that's all
I'm going to say about proxies for now
but stay tuned Jacob's going to do a
deep dive across all languages into some
of the difficult parts of proxies that
come up a little bit later but let's
move on for now to marshaling the
structured data in CF fi marshalling a
primitive type is trivial it just does
it for
but what if you have you know a record
containing a list of Records each of
which contains a string all of these
need individual marshalling and you got
to do all these individual steps to get
things across the boundary one at a time
and it would be really nice if each of
those individual steps it didn't involve
a copy I've already said and we've
accepted that there's going to be one
copy when your marshal an object across
languages but it would be nice if there
wasn't you know a recursively increasing
number of copies depending on how big
and complex the object is so how do we
minimize that it turns out it makes it
easiest to do so if we let C++ always be
the the driver of the marshaling it
chooses which steps go next and and
drives the process the reason that makes
the most sense for us is that C++ can
understand by value and move semantics
which aren't meaningful in Python but
are very important to get right in C++
and on the flipside Python allows you to
incrementally construct objects of
classes and add fields as you go whereas
our C++ objects want you to give all the
fields in the constructor so this
direction lets us do that as I'll show
in the next few slides so we always
generate C++ to do marshalling of a
complete object and it can call into
Python to get or set individual parts as
necessary and genie will auto generate
the helper callbacks that it needs in
order to do that so let's talk about the
first direction Python to C++ Python
will pass a reference to the whole
object down to C++ as one of those
handles that I mentioned earlier c++
will then request the sub parts of the
object as necessary as it needs them
that might be all of the elements of a
list or it might be each of the fields
of a record and then once it's got all
those it construct can construct
everything at once and all of the
intermediate temporaries and copies can
go away because we have move semantics
or we have the return value optimization
so at worse there might be a significant
number of moves if you've got a very
complicated object but no extra copies
should be done in the in the process so
in the other direction we're going to
take advantage of the other property
property of python that i mentioned c++
when it wants to marshal an object will
ask python to first create an empty
object of the create correct type and
then it'll pass in the subparts one at a
time now if this is a list or a
dictionary that's pretty straightforward
you're just calling add or append if
this is a record than what we're doing
is we're adding new fields to the class
one at a time but that's perfectly legal
in Python as long as you've they're all
there before a user ever sees it they
don't care that they were added one of
the time and everything's by reference
there's no extra copying implied here so
when we're done we can pass the entire
object to Python and it's complete at
this point and can go in and act like
the right kind of object so marshaling
objects comes with object ownership you
gotta be allocating memory you got to be
freeing memory each language has its own
different semantics for doing that
there's no direct way of owning objects
between languages in Python or CFO by
with C++ the way that there is for
instance an objective c plus plus where
you can just mix the two languages
together or even in J&amp;amp;I where there are
calls to explicitly allocate and delete
from both sides so we need to do a lot
of this ourselves provide the helpers to
make it happen the basic rule that we
decided to follow is that every time we
pass an object across the boundary in
either direction we're passing ownership
with it so the person who gets the
object whether it was an argument passed
to them or a return value pass back to
them are expected to free it later so
he's explicit ownership and it's always
transferred across the boundary that
rule is simple it works for arguments
and returns we can check it and try and
enforce it everywhere in our unit tests
and elsewhere it's possible that by
doing a more complicated set of rules
you could get a little bit more
performance we might look into that
later but for now this works pretty well
for us but like any rule there are
exceptions which is really inside of
those multi-step marshaling callbacks
that I mentioned we don't pass transfer
control of the object back and forth
every time we don't try and ask for one
of its fields we let those be
a case where ownership isn't transferred
so how do we actually implement this
ownership once it's passed across the
boundary there has to be an explicit
called a delete which goes back across
the boundary in whichever direction
wherever possible we want to automate
this with REI I in C++ C it's really Rai
and we use unique pointers with a custom
deleter that will you know call back
into Python when the object is deleted
in the other direction there's not
really rai in python but we can do
something similar we have helper types
that will hold on to a C object that
will delete it in there there del
operation and we can use with blocks
that give a slightly more predictable
destruction time which just helps clean
things up it's optional because Python
would eventually garbage collect it but
we think it's a good citizen sort of
thing and helps us to validate in our
unit test that everything that should
get freed actually good so how do you do
explicit ownership in Python do I have
two copies of this slide I do I'm sorry
I revise this slide at the last minute
and this is the revised version so
python is garbage collected and it
doesn't have any explicit deletes so how
do we make that actually work as a
contract let's say you're trying to pass
a Python object down to C++ you create a
handle to it as I described earlier that
creates a see data object you pass it as
evil as close as a void star but the
garbage collector doesn't know anything
about that void star or the fact that
seagulls floss is still using it so it's
going to happily delete both the handle
and the object that it points to so you
need some way of delaying that garbage
collection by keeping that handle alive
so that it keeps the object alive so
that nothing goes away and you don't
have any dangling pointers the way we do
that is pretty simple we put that handle
into a set that's in a global variable
so in Python says oh that's referenced
in this set I'm not going to delete it
and then when we get that explicit
delete call later we just remove it from
the set and we can sprinkle around
asserts to make sure that nobody tries
to delete something that's not already
in the set which would indicate a bug
somewhere since works pretty well
we auto-generate this set as a global
variable of each class so that we aren't
mixing it into one gigantic set at least
but it doesn't really take it that much
extra space or data along the way so all
the ownership I've talked about so far
has been exclusive ownership that is
objects are uniquely owned they'll be
deleted once later that's true of almost
all the objects we have to use because
most of these objects are just created
and passed through the boundary once and
then you're done with it because you've
either marshaled it by copy you have a
new object on the other side that is
moving on and with going on with his
life this is true of all the wrapper
objects that we generate around C++
objects like this are wrappers around
strings and binary box types that we use
for optional primitive types so we can
nail them out if necessary it also works
for Python a handle objects held by
handle because it happens that the way
we use these they're always uniquely
exclusively owned so everything works
there is one case where it turns out we
needed shared ownership and that's for
interfaces interface is because they can
be passed around and passed to multiple
calls go back and forth over the
boundary you can't keep exclusive
ownership even over the the rapper
that's in the middle there because you
make might pass it to another call later
you don't know which of them is going to
free it so we use reference counting the
genie wrapper that we generate for each
interface has its own reference count
which counts the number of Python
references there are explicit calls to
deck Raph that'll come from Python
instead of calls to delete that we would
normally have if it was exclusive
ownership then the wrapper holds a
shared pointer which is how it shares
with references in c++ and that's much
more nice and automatic and smart
pointers are good that way you know if
they write it yourself that shared
pointer might be directly to a C++
object in which case we're done as far
as the ownership story or it might be to
a Python proxy which is itself holding a
Python object which it holds by a handle
but that's all okay that handle itself
is exclusive ownership and the reference
counting is handled on this this wrapper
ject that might be held in Python
multiple times and so when the last
reference from Python goes away the
rapper will go away if you pass it the
same C++ object to Python again it might
get a new rapper that doesn't really
bother us at all the proxy cache will
make that less all plus less common so
the last topic I want to talk about in
in terms of kind of advanced language
bridging for python is exceptions you
might know that c doesn't have
exceptions therefore c FF I doesn't
really know anything about them because
it doesn't expect to see functions to
throw them if you don't do anything of
your own and an exception gets to CF if
I depending on where it gets there and
from which language you might crash it
might just ignore it and move on in
return 0 it's probably not the behavior
you want if you're actually getting it
running into exceptions on either side
of your program so the bridging code is
responsible for catching any exception
marshalling it to the other language
that made the call and then wreath
rowing as an appropriate exception in
that language so that it can keep
propagating get handled caught etc and
hopefully lead to useful diagnostics at
some point so the way we do this we need
some way of passing the exception since
he doesn't know about them we use a per
thread state that holds on to an
exception it's basically an extra return
value a lot like what you might see with
errno or guest get last error in your
favorites EAP is now I know what many of
you are going to say you hate that kind
of capi I hate them too the reason I
hate it is because it's too easy to
forget to check that because it's not in
your face even return values are easy to
forget let alone something that's not
even in the in the function declaration
but since we're dealing with generated
code here the generator is never going
to forget to check well unless it has a
bug but we'll we'll get rid of those
hopefully as soon as possible so I'm
relatively happy with using using this
approach because it's not subject to the
errors that it normally is so what's
this / thread exception state it holds
an exception or no exception it can
always contains a Python exception we
just decided to settle on that rather
the complexity of holding one or the
other and translating it later they're
always going to have to translate it
across the boundary anyway we'll just do
the translation before after and restore
it when it's a Python exception but it's
actually C++ it holds on to it by handle
that's partially because thread locals
in Python when interacting with C++
threads are weird there are ways of
making them less weird but they're
outside of the scope of genie but inside
of the scope of some sample code you can
find in the genie repo so we only
populate this exception state while
we're in the process of crossing the
boundary meaning a function call
happened from language a to language be
language be through an exception and we
got to propagate it back to language I
only during that time do we set the
exception into this state and then when
we get back to the original language we
are immediately you want to check the
state and clear it we as we throw the
exception the code you need to do so in
both directions is symmetric it's not
identical because it's different
languages but it does roughly the same
thing so if you've got a call ye their
responsibility is to have a try catch
around everything they do catch
exceptions if an exception occurs stick
that exception into the exception state
and then return the caller in turn after
returns is responsible for checking the
exception state should do that before
making any assumptions about the return
value notably such as that it's valid
object and then if it sees an exception
in the exception state it should clear
the state and then throw that exception
and there's an implicitly a translation
here at some point when the exception
either goes into or comes out of the
state that's to get translated into a
different language but that's just
marshalling an object you're relatively
straightforward way the way we do that
Jeanne provides some tools for that for
you it'll provide a simple default
translation as well as a way for you to
plug in your own translation if you've
got your own custom exception types that
you want to use to get advanced features
like maybe back back traces the model
here is almost identical to what we do
in Java and I'm going to talk about that
and one of the deep dives later so I
will not go into much more detail than
that right now so wrapping up
on Python before we move into the next
topic what I've described is kind of all
of the basic building blocks so that
we're relevant to us building in Python
I think they're relevant to building in
any language though it hasn't been
tested yet one nice property of the way
we did this is that that see wrapper
layer should be reusable for bridging to
other languages that know how to talk to
see we already had some experimental use
of that at Dropbox with people who are
trying to bridge to see sharp so our
Python support is mostly complete it
still has a couple gaps but it is
available on github for you to try out
and we just pushed it to the Python
branch today and I hope you'll check it
out so enough about Python let's move
into some deep dives on individual
features that are relevant the Python
but also to other languages and with
that I'll hand things over to Jacob
great alright so as Andrew said earlier
we generate proxy objects when you're
calling from Java two spots or Python to
C++ or C++ to objective-c etc we get an
interface in each language and we also
get an implementation of that interface
that does cross-language calls so for
the example of java calling into c plus
plus we have a Java object with a native
function member function which means hey
JVM if you go and do an animal dynamic
symbol lookup you should find this
native C++ or C rather function Java
under your package under blah blah blah
for C++ calling java it's something very
similar in the other direction there's a
call object method or call void method
etc thing and so let's look at an
example of how we have that's used let's
say we have a weather report service
well we've got a little record for what
the weather is a weather listener is
something we might be implementing in
Java or objective z that has a function
that gets called whenever there's a new
weather report and then this service
will have an ad listener and remove
listener pair this is a fairly common
idiom that we see
you in our mobile code when you call
addlistener you give the weather service
your listener it hangs on to it when you
call a remove listener sometime later it
removes its reference and then you've
broken the reference cycle so let's look
at the example or the implementation in
C++ so here's how do we do this in C++
we just have a set of shared pointers in
addlistener we add that step and remove
the listener we remove from the set so
my weather service is something I've
hand written in C++ and then the weather
service class that it drives from is a
class full of pure virtual functions
which Jeanne wrote for us and then
there's some other code of course that
iterates through all those listeners and
calls them whenever necessary okay so
here's the thing when we make that erase
call we need to have the same listener
object even though we made two different
calls through the bridge which means our
bridging are our method implementation
for eid listener and for remove listener
can't be as simple as okay here's our
job object conjure up a new C++ wrapper
around it and keep going we have to wind
up with the same thing on both sides or
else our erase call will have gotten a
freshly created C++ listener and won't
find anything in the map and nothing
happens if we'd been more clever we
would have written in a cert but oops so
there are performance benefits to not
creating a whole bunch of objects that
are going to last for very long but
really this is for correctness all right
we might need identity comparisons to
behave the same in C++ or on one side of
the barrier as they do anywhere and this
is necessary to enable idioms that
developers want to use so what we do is
we keep cash with references to all of
the proxy objects that we've created and
whenever we pass something from java at
is equals plus or across any other
language pair we hang on to it and we
were use it if we can so we store a map
it's an
map from a na nun in reference to the
original object to a week pointer to the
proxy object now I use the word cash so
I want to be careful about what
guarantees I'm providing here this is
not an LR you type you know a victim
when we can the rapper's don't last
forever right if we generate a bunch of
temporary objects create wrappers then
don't need them anymore we don't want
this to hang around forever which is why
we're using week pointers and we only
care about whether we can get into a
situation where someone let's say in C++
has two different wrappers that can pair
differently but refer to the same object
we don't want that to happen so it
doesn't matter if these rappers last
longer than they should we only care if
they're visible if someone can actually
have two of them which week pointer
gives us exactly those things we need so
here's the generic version of this cash
we used to have four separate
implementations between each of Java C++
objective c each direction when i
started to implement this for python we
realized wait a minute let's not go from
four to six let's go from four to one so
now this actually shares code this is
one fairly ugly template it's
parameterised over a whole bunch of
different types any cash maps from proxy
objects sorry maps from implementation
objects to the proxy objects that we
already have for that imitation and then
there's this handle that the proxy
object is expected to hang on to that
points to the implementation and I can
use that to actually make its calls as
well and when the proxy object goes away
then the handle goes away and that
cleans up the map entries so I'm going
to go through what happens when the
proxy doesn't have anything referring to
it anymore it has first it has only a
strong pointer
has one or more starfighters owning it
then the strong pointer goes away so the
proxy object is still there we're about
to start calling its destructor the very
first thing that happens is atomically
any weak pointer that's referring to
that proxy object is now dangling and
this happens atomically in stead shared
pointer instead week pointer it also is
guaranteed to be atomic by Java weak
references and Objective C double
underscore week so we have that
guarantee so now the week pointer is
dangling okay now we know that although
this proxy object still exists no one
has a reference to it so we start
cleaning it up first the proxy object
itself we enter its destructor it might
contain the handle by a sub object or a
member or it has a pointer to it or
something the handles destruct ER
reaches back into the proxy cache and
says hey this nah none in reference to
the implementation that you have is
about to go away and the week pointer is
already cleared so please remove those
entries from the map then finally the
proxy object us away there might be
other things back in the Java side that
are referring to that thing that we were
proxying that doesn't matter whether the
implementation now goes away or not
isn't our concern and the proxy cache is
a global singleton so it sticks around
forever there's one proxy cache
instantiated i alighted the types that
it's actually instantiated on but it is
instantiated once per language mapping
not once per type of interface so here's
the holding again that was all very
abstract so let's talk about what we do
for in order to wrap a java object with
a C++ proxy so things have shifted a
little bit the proxy is a C++ object
that has implementations of virtual
functions it calls into Java so I moved
it right up next to the handle because
that's actually a base class
and then I put in concrete types for all
of these dotted lines it has a wrapper
for ajni reference the unknown thing is
also a ji reference and then there's a
stood week pointer from the cache
pointing into the proxy so global rift
that you see in the line from the cash
to the Java implementation is an rei
wrapper and then the raw j object is
pretty much a non-running reference to
the java the jni thing so that's Java
here's the general thing again so you
can see how it compares to the other
direction where things are a little more
complicated there are a few more boxes
but it's not much more complicated so
the relevant points here the handle is
something that we allocate with make
unique and then we release it so it's
just floating there are memory we then
take its pointer reinterpret cast it to
an integer play the Indiana Jones theme
song and pass it to Java which stores
that as a long the Java proxy objects
finalize method which could be called
very late but will probably be called
eventually someday calls back into C++
to a little helper that does delete
reinterpret cast and then that handle
goes away the job a week ref up top is a
c++ wrapper that we built around a java
java dot lang got weak reference and
javas garbage collector runs whenever it
runs it doesn't have the precise
reference counting precise destruction
of c++ but that's okay the only thing
that matters is that the clearing out of
the week pointer or the job a weak
reference happens all at once sometime
after there are no more handles to the
proxy so that's okay and so it's the
same layout this used to be two
different pieces of code there were two
more for objective-c the objective c to
c plus plus and c++ to objective-c
rappers were pretty similar but now it's
all one template
okay so there are some gotchas first of
all the proxy cache is a global
singleton lasts for the duration of the
program but we had it held by shared
pointer from the handle why do we do
that any ideas so we used to not hold it
by shared pointer and when we were only
running on Android and iOS things worked
fine then we started building this for
OSX and Linux and desktop environments
and I got a complaint from one of the
engineers my program works fine until I
try to quit it and then it crashes and
it turns out static destruction order
was causing us problems where if we have
a shared pointer that points across the
language boundary in a global and the
static destructors for that runs after
the static destruct ER for the proxy
cache itself then the world ends so
that's no good we changed it to week
pointer or two shared pointer to a
singleton there's only one of these but
there's still a shared pointer holding
it because we don't want it to go away
until the very last file that's using
this has had its static distortion run
and then the other thing is back here we
have a strong jmi reference to a
java.lang weak reference well it turns
out Java has not one not two not three
four different kinds of weak reference
and one of them is part of jni there's
ajni weak global reference don't ever
use it we used to use it it turns out
jmi weak global references are
upgradeable to strong references even
after the thing that they point to has
started being finalized and has sort of
started going through the garbage
collector process the J&amp;amp;I weak reference
although not a regular weak reference
can still be upgraded even at that point
which was leading to use after free if
there's a race between those two yeah we
don't but it's held as a so that would
be another option we could
allocate it with new in a singleton and
delete that but it's not deleted by us
it's deleted by the static destruction
process that happens when a C++ program
terminates or so destructors still run
and we want to be clean with respect to
sanitizer tools and not have to write in
exceptions so those are some of the
gotchas we ran into and then finally
here are all of the different ways we
instantiate this proxy cache can put it
takes a whole bunch of parameters so
sometimes the C++ types are showed point
or a weak pointer sometimes their
wrappers around Java we had to pass in
custom parameters to unordered map
because a Java a Jan I reference is not
doesn't necessarily correspond to the
identity of the Java object J&amp;amp;I is
designed to enable copying garbage
collectors object to move around you
have to actually ask the JVM if you want
to know whether two things are the same
and then an objective C Objective C
provides double under strong double
under week double under unsafe under
tained ID types which do automatic
objective-c reference counting for you
slice we had to run our own pleasure
called under tained ID hash because
stood hash doesn't play nicely with
these funky non-standard types but all
of these are put into one traits class
and then we use explicit template
instantiation so the unordered map
underlying all of this and the mutex
stuff is only compiled once and that
speeds up our compilation quite a bit it
also helps with code size since
previously before we merge these we had
a zillion different instances of what
was essentially an unordered map from
floyd start a shared pointer at a weak
pointer which i'll compile to exactly
the same code but the compiler doesn't
know that and so it has to spit it out a
billion times
so that's the proxy cache next I'm going
to talk a little bit about null ability
so a year ago we didn't handle no at all
and I didn't handle null at all I mean
if you pass null across the boundary you
would get a proxy object that points to
know and you would be very sad this was
embarrassing we fixed it shortly but we
changed it so that you can have a null
interface and no will get passed through
to know it was just an extra check in
some of the functions but if you wrapped
interface with optional Isabella so you
would dutifully add an optional wrapper
around that which didn't really have any
semantic meaning we also realized
objective c and java both have fairly
common null ability annotations java has
a whole bunch and so we would spit these
out for data objects we expect them to
not be no unless they're optional
interfaces could be null for a while we
had an intermediate state where most
things were noble but we would insert
explicit checks if you had a
non-optional interface what we do now is
in for interface type it's not nullable
unless you say it's optional you can
hook into the non null pointer library
which I'm going to be talking about
tomorrow so we have a C++ template that
represents very specifically a pointer
that has already explicitly been checked
for null which is a little bit different
than the gsl template from the keynote
on Monday so for more info on that I
have a talk tomorrow at two thirty
that's also open source so that's the
second interesting detail and finally
Andrew will talk a bit about Java
exception translation
alright I'm back as I expected or
writing a little bit short on time so
I'm going to keep this brief and
probably skip the code examples but
these slides will be up to be able to
take a closer look later I want to talk
a little bit about a cult stack that
looks like this you made a call from
Java to c++ using Java from our example
this is applicable to python and sort of
to objective-c though the
customizability is not quite there yet
so say your UI controller is making an
update to the data model it calls from
Java C++ the data model might call back
to a listener thus calling back from C++
to Java you now have a call stack that
has java than C++ than Java again and
you might encounter an error at which
point a job I exceptions going to be
going to be thrown so the jni exception
model that we're working with in Java is
very similar to what i described for
Python I used to think it was terrible I
still think it's terrible I just now
know that I couldn't think of a better
alternative so each thread has a pending
exception the contract is very much like
I described before Python except that
the Java side is done for us java does
it as part of jni the c plus plus side
is not done for us or our generated code
still has to use the jni methods to
check the exception state and set the
exception state Jeannie we'll do a
default translation for you and the way
it does that is when you're returning
from Java to c plus plus it'll check the
pending Java exception if it finds one
it actually throws ajni exception type
which is a custom type of exception that
holds the Java exception inside it keeps
it by a handle a global ref in the J and
I person parlance it'll throw that so
then the other side of this contract is
before you return the Java from C++ you
have to catch any exception you have if
that exception is one of those J&amp;amp;I
exceptions then you know it's already a
Java exception or our Genie generated
code knows it's already a Java exception
so I can just stick it back into the
exception state return to Java and the
same exception just keeps propagating of
course if it's not a Java exception then
we need to create something out
if it started from C++ s Zebo sauce
exception so we just create a runtime
exception in Java and pass along the
same message as within the standard
exception so that's free but it's a bit
simplistic what if that's not good
enough for you if you use exceptions
heavily which we do with various
different exception types you might have
custom exception types that you'd really
like to see thrown in your C++ code you
might have things built into your
exception types like back traces that
you'd like to be able to print for
debugging information because that Java
exception that i mentioned even if you
propagate it through it's got a very
nice back trace for the java parts but
not for the C++ parts that's a big you
know empty space in your back trace so
Jeanne gives you the ability to
customize to do things like this which
is we have some translation functions
that Jeanne uses when it needs to
translate an exception we define those
with an attribute that tells the linker
that if there's another definition of
this function use that one don't use
ours which means you can create one of
your own just to find it and your
definition will be used as long as it's
linked into your executable so let me
take an example of what you would do
with this if you have a custom you know
my security exception that you'd like to
throw you'd like that to map back and
forth to a job X security exception let
me talk a little bit about how you might
do that so the first function you'd have
to replace is called Jan I throw CDP
from Java exception it's a bit of a
mouthful but hopefully the name is
descriptive it is called when there's a
job exception that has made it to C++
and we need to turn it into a C++
exception this functions job is to take
that Java exception decide what to do
with it and then throw some C++
exception we don't care what I told you
what the default is but its job is to
throw something here's what it looks
like I'm not going to go into this in
depth since I don't have that much time
left but basically we're just using the
jni interface and some of the support
library that comes with Jeanne some of
the helpers to check whether the Java
exception is an instance of security
exception if it is I get the string out
of it translate it to a C++ string throw
simple sauce exception
and if not I do the default thing which
was throw this J and I exception for any
other type of Java exception let's get
that the other direction there's this
function called J and I set pending from
current which will its job is to be
called when we know we have just caught
a C++ exception of some sort and we
would like you to set the pending state
in J&amp;amp;I with some Java exception of your
choice interestingly you might notice
there's no argument here that tells you
what the javac the cville sauce
exception was the way that works is
you're always called inside of a catch
clause which means you could just throw
semicolon and throw the same exception
again and then use catch blocks to
process it as you would I'm not going to
talk through the details it's pretty
simple if it's the type you want you set
it into Java using a custom type
otherwise in this case the default
behavior is a little bit more complex
than one line so we we give you a
function you can call to just tell the
default exemption translation to run
there and it'll do the two cases that I
mentioned earlier so lastly i mentioned
stack traces i'm not going to have time
to show you code or even to talk about
very much detail here but with those two
helpers you actually can implement this
and i want to just mention the key
points that make this possible it's does
assume that you've got some way of
generating stack traces in c++ code it's
not as easy as it is in Java but there
are libraries that will do it for you
it'll just walk the stack and try and
get symbols and do something they're not
always perfect but they're often good
enough to be very useful in debugging
particularly in a debug build and there
are two things in Java that let us do
this which is Java exceptions have a
cause so you can chain them together
this exception was caused by that
exception which is caused by an earlier
exception and also they let you override
the stack trace so as long as you can
build an array of stack trace elements
which are just you know some plain old
data you can stick your C++ accept race
into a Java stack trace you can build
some helpers to do it but then the
important thing is that in one direction
you put your J&amp;amp;I exception inside of a
C++ exception
that also has a back trace let that
propagate and then in the other
direction you can then use some helpers
to build a chain of Java exceptions
where you've got a new job exception
you're about to throw which was caused
by a Java exception which is a copy of
your C++ exception where you've copied
over the back-trace into those stock
trace elements and then that in turn
might have been caused by another job
exception this could in theory chain
through an infinite number of levels so
what you see if this gets to the top of
the stack and gets printed out in Java
for instance in a crash so you'll see oh
here's a here's a Java exception with a
Java stack trace caused by this other
exception with a C++ stack trace in it
might be printed a little bit weirdly
because it was shoved inside of a Java
stack trace but you can use a format
that is easily possible and easily
readable and then that in turn could be
caused by something else and you get the
normal chaining behavior that Java
programmers are used to great so that's
all we have time for today there's
plenty of other new stuff in Jeanne that
we've developed over the past year if
you've been using Genie or want to try
it out I hope that you'll go check these
out they're all on github I want to give
a shout out to all of the people in the
community that have contributed to this
particularly Miro who did exception
external types and a big refactor who's
like basically a part of the team at
this point and stuff in at Dropbox who
has made a jetbrains plugin for the
genie IDL so you can as much more easily
and lastly I hope that you will join
this community whether you want to use
Genie whether you want to contribute to
it or you just want to share ideas
please talk to us check out this this
talk and our previous talk online check
out there's a magnet link here to a slot
community where you can chat with other
developers doing mobile c++
cross-platform work thanks dawn for
setting it up and there's other
resources like some developer tutorials
that Steven's in been making and feel
free to get in touch with us those are
our email addresses Jacob here is the
primary maintainer on geni so you'll see
em doing most of the pull requests and
processing that but I'm happy to answer
your questions as well thanks your watch
we're technically out of time but i will
stay around to
answer questions and yeah please talk to
us and go</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>