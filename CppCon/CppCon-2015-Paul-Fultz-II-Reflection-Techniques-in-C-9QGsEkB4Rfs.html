<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Paul Fultz II “Reflection Techniques in C++” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Paul Fultz II “Reflection Techniques in C++” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Paul Fultz II “Reflection Techniques in C++”</b></h2><h5 class="post__date">2015-10-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9QGsEkB4Rfs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Paul I'm going to be talking
about reflection and techniques and C++
so guess starting off kind of the
question is what is for reflection
perhaps for people who are not fully
aware of what reflection does reflection
essentially is basically introspection
on types or even you could go even as
far as introspection on not just the
types of the the they even est you know
you could go over classes and functions
and namespaces but in general most
people talk about reflection and they're
usually talking about some kind of
reflection on the class types finding
out what kind of members are available
usually generally it involves you know
you know numerating over class members
so like you know iterating over each of
the class members it is not really most
people when they refer to reflection
they're not really referring to a
predicate based introspection since of
deciding all whether this class has this
function foo or not that's already kind
of pretty much kind of a soft problem in
C++ for most cases to figure out how to
do so generally most people when they
refer to reflection that were flowing to
more being able to enumerate over each
of the members
so essentially what and by being able to
actually introspect over on the types it
gives us a way to actually treat our
data as pure right in as pure C++
classes which gives an extra level of
type safety when we're dealing with
certain data-driven type of applications
in in C++ were actually in this talk
here we're gonna actually focus mainly
on on the reflection Veda at compile
time meaning we're gonna basically use
data that's taking the only available at
compile time we're not gonna worry about
injecting reflection data into the
runtime
and sequels clauses languages designers
like you pay for what you don't use so a
general compile time reflection can kind
of give you that that kind of guarantee
once you have compiled and right
reflection you could if you needed the
one time capability you couldn't go turn
around and then generate run type of
data structures at runtime using the
compile time data but for this talk
we're just mainly going to focus on the
compile time data also right now we're
actually going to use we are going to
use currents people's clothes features
but right now currently there's no
native language feature for reflection
for C++ so in general and we were gonna
rely on it we're gonna we're gonna
actually mostly try to annotate our
classes with the metadata that we need
in a way there is a study group that's
working on a proposal for adding
reflection of your C++ which will
actually help in the future to simplify
a lot of these examples of what we're
doing so the next thing is to look at is
uses what are some uses for reflection
so the first one is serialization like
say to JSON or XML or some little cat
kind of format when we do this with a
reflection in general are going to treat
like a lot of times you can just treat
the name of the fields either as like
object keys for your JSON object or as
tag names for the XML but that kind of
can generally helps a lot with us
Trippier
your class directly as like almost a
jinx
object so and why should look here in
this talk as a simple example of how we
can like sterilize it out to an XML
actually so then as we go even further
with doing reflection we can also look
at object relationship mapping to say we
want to actually represent not just the
class sterilising out to some kind of
data format but we can actually look at
relating it to a table but this actually
introduces some new things that most
people don't think about as far as like
yeah you could treat each you know field
name is the column in the database but
there's all these other little
attributes that you need to know about
the columns and database like cause this
a primary key perhaps this only can for
250 you know string character length
there's all this or maybe this is a
foreign key related to the civil class
so there's all these a little type of
annotations that you want to be able to
add about the fields and why don't you
take a look at an example of possibly
doing that on a smaller we won't we
don't implement a full object
relationship mapping because we don't
have a full time to do that but we will
look at on a smart smaller scale smaller
examples how we can annotate the class
and even create database tables and
things like that so even further this
could actually apply it to any kind of
general data driven development
so those are two like well known
examples of serialization but actually
can apply to you know you can actually
create a command line parsing library
and all of your command line arms are
fields and a struct or whatever so you
can kind of even kind of expand out if
you think of if you think if you
actually can describe your problem in a
data-driven way
and date away that you can now treat
your your code as data you get extra
type safety from that so some of the
techniques we're going to look at we're
gonna get three different techniques the
first one is using boost fusion second
one visitor pattern and then kind of at
the very end do like a do-it-yourself I
call it credits you just we're just
gonna use some some made macros and a
little bit of meta programming to kind
of generate the metadata that we want so
starting off here with boost fusion
boost fusion is essentially a
heterogeneous sequence library it's kind
of way of describing it better is
generic algorithms for tuples but the
tuples aren't just stood tuples these
tuples could it apply to many different
types of tuples so starting off as a
simple example of understanding how the
library works this is kind of an example
right off of boost boost fusions
documentation right off their QuickStart
guide so we you know we can create a
make tupple and a boost fusion instead
of calling you still get you actually
use this at c 0 at C 1 at C to to kind
of get the index for each of the
elements in the tupple so that's kind of
how it works in there but even further
it's it goes much further than what the
standard library can do because you have
algorithms for example like for each so
say once you wonder your print XML you
could actually take your original double
print XML now in this example we're just
using type ID name like they do in the
QuickStart guide this is not really a
portable a fully portable way of doing
that but it's just for kind of a simple
illustration purposes
take a tumble and and iterate over it we
use the lambda Otto because the auto it
could be a different type it could be it
could be a strain so we use the auto
there for that but we can like boost
fusion algorithms don't just apply to
still tuples like I said you can
actually extend it to many ethyl classes
and one of the things that are very much
tough alike of course are strokes so as
an example boost fusion action provides
right there it adapts trunk so you can
actually define your struct and then
adapt it so then something you can
actually get this treated and basically
in inside of boost fusion algorithms but
even it going further if you don't like
repeating code boost fusion actually
provides like a defined stroke so you
can actually go in and it will actually
define the struct and adaptive both at
the same time so so once we actually
have an adaptive just as a quick example
we can actually turn around create a
struct and now we can actually access
the elements using the @c function so we
can actually access the first element
using that seed zero kind of thing and
then we can even turn around and call
the print XML function but ideally like
you saw the problem with reading XML we
actually want to be able to instead of
printing out type ID names which is
which ideally usually the type is done
what we want to use and also type of
even that names not portable but ideally
what we want to use the name so once we
start adapting it adapting a struct we
boost Fusion extra grow vines a function
called struck member name that we can
actually get the name of each of the
element so we can call struck number
name passing the name of the struct and
then index to it and we can actually
call the call and it will actually give
us the member name so yes
it's not an implementation detail but he
was asking if it was part of the public
API are those an implementation detail
but it's not an implementation detail no
so now when we're actually giving the
names we actually besides just getting
the name information we want to
basically when we're doing the for each
we want to basically iterate over it to
have both the name and the value
corresponding so what we want to do is
actually zip those names together with
their values so essentially kind of what
we want to do conceptually down at the
bottom there to show like a student make
tupple kind of idea of how it would kind
of look it's not actually gonna be a
tough old but it's kind of to
conceptualize kind of how when you zip
them together how it would look so
basically you're gonna have a double and
inside inside of the temple will be
another tupple that will first port the
name and then also the strength of the
I'm sorry the first one of the value and
then it will harden the name of it so
you do this we can create a wind names
function that will actually return us
back that was if these both things
together so first to start off we
actually use first we need to get a
range of indexes so to do that we can
actually just use boosted PL range see
it actually will build us a sequence of
indexes so we just create index
sequences from int from zero and then we
we can actually get the size of the
struct by calling result of colon colon
size truck it has to be a result of
calling colon is kind of a relic of the
legacy boost fusion but that's what you
have to do so we call result of colons
all inside struck and we can get the
based on the indexes up and call in next
once we have those will actually
transform each of those indexes into the
name so we call transform we pass the
range into there and then we take our
index with the
uses the auto I there and we just call
that into the struck member name there
and then that just gives us our names
and then we zip those two together so
when we when we have those when we want
to actually get the value or get the
name we could use directly that c0 and
c1 but using magic numbers everywhere in
general don't usually look quite as
clear so we can I should make these set
of functions tax that we can actually
call instead so once we have one of the
elements we can call at c0 and that Y
should return us back the value and that
c1 which will give us the name so now
once we have all that in place we can
actually go back to our print X amount
function and we can actually start
implementing it such where we actually
use the name of the member of fields for
printing out the XML so in this example
here we just call for each with the
names and we can now use get name get
value or actually get name mainly for
the tag and so if we run the print x
amount and we use it with the person
class we can actually get an output like
what is shown there at the bottom so now
going even further with more of what
boost Fusion is capable of doing boost
Fusion has this idea of associative
sequences they're essentially like
tupple associated tuples in a way
they're they're pretty much like like in
some ways like stood mac you know but
rather than having the keys being some
kind of value in general the keys are
actually just the type so by giving it
that title you can actually look up the
corresponding value in in the map so we
can build the fields you know name and a
in just two different strokes two
different types for each of those and we
can actually build them back together
with using the pair yet
a future pair to do this and then
instead of us accessing the fields using
like at C zero for each one or at C one
we can actually use actual names for
them so we can do like at key fields
name and actually get the name so it is
a little bit more readable but in
general you can even just take a stroke
and you can actually turn around and
actually still adapt that to an
associative sequence as well so it has a
actually has a defined associative
sequence solar actually defined the
struct and then we can actually pass in
what we want the keys to each of those
structures and this is kind of important
when we're wanting to actually add
attributes and at the same time we can
when we extend the when with what we did
with the with mains we can actually
extend it even further and give it the
key the corresponding key so when we
adapt it with keeds boost fusion
actually provides a struct associative
key that we can go out and query and
find out what the corresponding key is
for the struct and so we can basically
does the same process it takes that
range transforms it to the keys and then
it zips those two together or three
together actually and then we can add
get key as an extra function for what we
do and kind of what this is gearing
towards is being able to have a way that
we can store attributes so like when
we're doing like say object relationship
mapping like I said we want to be able
to annotate the fields to be able to
recognize this is a primary key this is
this has a set of attributes so as a
simple example here we can actually
build types that represent certain
attributes like primary key also max
length which we actually store as a
template parameter here and we use the
max length base base we inherit from
there so that we can actually have one
concrete type that we can use the
recognize the
so once we have that to actually
incorporate it into the keys we can just
inherent so once we have the keys like
name we want to make name a primary key
we just inherit from primary key and
then we also inherit from max linked to
15th or saying we want a maximum length
of 250 and then we turn around and we
can define our associative struck and it
will actually have the annotations that
we want all with it so so now we can we
can annotate our our keys but the next
thing we need to be able to do is
actually start checking for attributes
that we've added in there so because we
want like a check or has attribute that
actually check to see if one of the keys
has attribute we can actually a standard
library provides his base of that can
actually tell us ok this this attribute
or I'm sorry this key inherits from this
attribute so that's what the has
attribute function does there and then
you can see the example at the bottom
where you can do with primary key
without and we're trying to true or
false there now when we start wanting to
retrieve certain values from the keys
like say for example we want to be able
to get what part of the possible max
length is so if there is a max length
ideally what we want to do is actually
return back what max when value is
specified otherwise maybe where you turn
back to minus 1 and we just use that as
kind of a sensible value to know that a
max length value wasn't set so to be
able to do that we can't obviously C++
than have seen it static if to be able
to easily do that so instead we have to
be do function overloading so we create
function overloading for okay when it
has attribute max length and then we
make another overload for when it
doesn't have max length as well and then
here in the example code I use I use a
little macro usually to kind of abstract
out that all been able of craziness
usually so it makes a little bit neater
and easier to read I think so now that
we have all that we can actually start
looking at maybe creating a database
table so if we want to create so we can
create this function that basically will
spit out what the create table table
function would be that we could send off
to a database to actually create the
corresponding table for a person so in
this case here it takes the the TX or
whatever will be the person class in
this example and then we actually pass
in a corresponding table name and so
that we just would iterate over each of
the each of the elements with the names
and keys with the fields and then it
calls the create column field and this
is kind of where most of the main
functionality is act so in this example
here I just take and checked first I
check to see on is the value convertible
to a string they say ideally it's just
like a string type and essentially if it
is and we want to be able to get a max
length attribute with it so that we can
actually print out as an example you
know char
whatever amount that you usually do on
databases or if it doesn't have a max
like we check max less than 0 then we
just specify it as text which means it's
unlimited in them so basically you can
use that attribute to do that and then
at the end to right now I use type ID
for for all the other ones to print out
the type name ideally if you're doing
actual object relationship mapping you
only - should create like a relationship
between like integers and strings to
what they're called in the database
right now I just do type ID name but
yeah
Oh Oh this boost you should have a thing
to do the type IV no boost fusion does
not have a capability for converting
like a like a type to a straight so you
would have to essentially write your own
kind of mechanism or you could if you're
using these macros you could build a
macro on top of it that adds like a you
know static cops name okay if you use a
third tuple element well in general
because it's only the name is actually
only essentially associated with the
type and not each of the fields you
wouldn't associate it with each of the
fields so rather than we need to find or
instruct what you can do is just if you
want to put a name for for that type you
could do that now I guess you could say
when you eat for each of the fields for
the type you have the name of the field
and then the type of a name but
essentially because you know the type
instead it would just be better to
create a function that would take that
type and then map it over to yeah some
kind of type trait that would map that
over so you could be like okay if it's
an interval type go ahead and return
string int you know if it's convertible
to string return like a string as well
so that's that's what you should do and
then we also check for a primary key
here we get the key check to see if it's
a primary key and we spit out a primary
key and this all prints out the like
sequel statement so here in this example
here I say I create the person here and
then I create I call create table here
and then it from outputs here what's at
the bottom so who actually call create
table person
main charge to 50 now I actually pass in
the person named in this example here
like ideally if you wanted to you could
also add like a static constable that
stores the name of the table as well if
you wanted to but in this example I just
I just passing it so now some
third-party libraries to actually go
along with boost fusion the first thing
there is a library called CPP in that
actually builds on top of boost fusion
it uses it actually builds a whole
entire annotation stuff so like we're
kind of manually doing the annotations
ourselves in a lot of ways but CPP n is
a library that actually does that built
on boots few can do does the annotation
another library is boosts Hana that is
like a modern replacement for a boost
fusion so if you're using like the
latest version of claim or GCC you can
use boost Hana possibly instead you
might get a little bit of a cleaner
interfaces in some places and also much
faster compilation and there's also a
library I've actually started working on
hero that was trying to work on for
portability reasons that would be
somewhat of a modern replacement for
poor for boost fusion so so now moving
on to the visitor pattern this is a
metal technique that you can use to try
to annotate your classes with reflection
data essentially the visitor pattern a
lot of times it's traditionally
associated with like using some kind of
variant type but in this case we're
actually going to use it to actually be
able to reflectively go over our data
structures so essentially we just
provide like it's essentially a visit
function that's going to take the
visitor and it's going to call it for
each of the member functions usually
it's a little bit easier to see and
implement it
so in general I yeah what good way to
implement is this I create a strong
visit
I actually take in myself and that's a
first parameter in a function and for
each of those function I call you know
named self name age self page now for
this case I actually use use this as a
separate function rather than a member
function because ideally when you do
visits you want to do visits for cost
and non-confidence and so essentially if
you made it a member function you have
to create two overloads for this instead
what we're doing is we're just
templating ourself there and that way we
can actually use it for both Const and
non-pilots versions of course by doing
that that requires a little bit extra
work by the user to start calling the
visit so in general it's much easier to
actually use a visit each function that
we can actually just call that why
should go ahead and find the visit
object that we have and call that now
unfortunately in C++ we can't just call
a Cohen because in this example here I
take the T referent which that T could
not be a like a regular L value
reference so because of that if it's a
referent if T's a reference and they're
trying to call colon colon on it see
those posters I'm allowing it there's a
fit so what you have to do first is you
have to basically remove all over the
references or if you it has a constant
on it remove the comments off of it so
that's what the first line basically
essentially does yes oh could I just use
the K not necessarily because the K can
actually decay to pointers well I guess
in this case it wouldn't matter but but
decay does a bunch of other stuff too
besides just removing references so
that's why I just used that this instead
so that's what I am using care remove
the references it removes any console a
little keywords so that that way I can
actually do a colon colon visit and get
the visit object I call the visit object
then I pass myself back basically into
it and I can pass the function into it
as well so once we do this we can
actually go back and revisit our print
XML
so basically in this case here what
instead of just taking one element in
here we'll actually take a name in a
variable and the variable is auto
because it can represent various types
of training integer whatever and so
there now we just we can serialize it
out using name bar pretty simple right
so next what we would like to be able to
do is have attributes like we did before
in this case when we define our
attribute is in the visitor pattern
we're not actually going to attach it to
type so we actually have something a
little bit simpler to do yeah so
basically what we do here is we
basically call the so basically we
stored the link from can just store it
as a regular member variable here we
have the primary key so now when we want
to be able to use those attributes we
can just add them as extra parameters
onto the function so max aleene's
primary key there but by doing that we
actually need to update our xml - we
might have possibly extra parameters
there so we can add an attribute that
takes in a possible number of extra
attributes so yeah so yeah so so like I
skipped a bunch of slides for some
reason oh no I did okay okay so yeah so
that da-da-da is very number of
parameters we which for the case when
you don't have any attributes it just
gets ignored this case we're not using
attributes but it still needs to be
because the user might action estimate
now if they do pass in a bunch of
attributes you could rely on okay each
of these attributes have to go in
certain order when you're using primary
key you're not using primary key you
might need to put in order but rather it
would be much better to search through
all of those attributes and find out
which ones the primary key so to do that
you can use these three different
overloads it's actually search for a
primary key so in this case we say all
this primary key we find the first one
it's a primary key so we're just going
to return true all right we don't care
what the rest of the T's are right for
the second case which is completely
empty and in find a primary key at all
so we return false and then for another
for the the last case is for when it's
not it the first type is not obviously
the primary key but the rest of the T's
could be a primary key we go ahead and
call it recursively so it kind of does
this laying head tell type of recursion
that's kind of familiar with like
functional programming so and you can
use that to search for the primary key
the same process can happen with the get
max length in this case we're not just
returning turn false but in this case
we're actually returning back the xpac
link that you stored in the object and
if it's not found we return basically
minus one so then we can actually go
back and look at our create table
function basically in the create table
we basically take that number of
attributes and basically the mean of the
operation actually is going to be
created column right so in the create
column we actually do do the same kind
of process check to see if it's
convertible to string we call get max
length but we do attributes dot dot
because they're there many number of
attributes so we pass in all those
attributes in there and it will
basically search over it find a max
length and give us what that nice like
this if it is found otherwise minus one
and something we vets it's the same
process print out text or chart and at
the same time for we do the same thing
for the is primary key attributes dot
dot dot dot so now moving onto something
else you can do with visitors is there's
many times when you you have visitors
and you have all these attributes you
may sometimes want to only visit certain
certain overloads that have certain
attributes as an example like I have in
the slides as visiting just the ones
that have the primary key attribute so
this could be very possible when you're
running and or and that you want to do
something like you get you you call out
you create you insert the new data into
the the database and then you actually
get a response back what that primary
key is supposed to be what it is
especially if the primary keys are
harder and generated by the database so
what this does is it a basic just a
basis selects only the elements that
have the primary key attribute and then
it gives you the name the value and then
also the attribute that you asked for
so like you can also use it for other
cases besides just the primary key the
primary key doesn't actually store any
data but if you had other cases where
you wanted to select certain visits and
they had like and they had like data
stored in those attributes you could
actually visit those especially if you
in a more large or very driven
environment you may actually use that to
be like okay only these attributes I
have this I'm going to serialize out to
here the other ones I'm mister
to someplace else so that's kind of what
the visit selects so we'll actually look
at how you go about doing this visit
select so in this example here yeah we
basically only print out at the bottom
their name Tom because the name is the
primary key so basically we can actually
take what we were doing before a little
researching for an attribute and try to
do it in a more generic way so we start
off we declare a not found struck that
basis it's gonna signify that we didn't
find an attribute and then inside the
attribute finder class it takes an
attribute as a template parameter and
that's the attribute we're going to be
searching for and so basically we do the
three call overloads like we're doing
before and we actually search through
all of them and try to find that same
attribute if the attributes found they I
should return the entropy if the
attribute is not found make sure we turn
back our special not found struck that
we created now now C++ because it
doesn't have static if we can't just be
like okay now if it's if it's not found
that should be do this otherwise do what
we wanted to do so we can't we can't
really do that directly in C++ so we
have to use functionality so one way we
can do this is just overload based upon
the time so if the attributes found and
we take an attribute and we take a
function so basically if the attributes
found we go ahead and return the
function right if on the overload and
it's actually not found we actually
don't return the function instead we
just return a special function that does
nothing so basically ends up basically
turning that into dead code right so so
putting it together for like if we want
to implement visit select we can
actually take in the attributes we call
our actually be finder that then
searches and finds the attribute and
then we say if found on that attribute
passing the user-provided function that
they want to be called for that
attribute and then we pass on the name
bar and that single attribute now if
it's a not found that function won't be
called at all if it is found it oh I
should call a function with the name the
variable in that attribute so then that
way you can actually select only certain
visits that you want to do and that's
kind of how the visitor pattern works so
now finally the last thing here is the
do it I call it the do-it-yourself what
was really the best name for it but
essentially what we're going to do is
we're actually going to create our own
macro called reflectable
yes oh yeah
it's just red light so why was it figure
out why but why
that's just a 14 rep he's asking the
question why they only have to use the
auto ref ref it's just kind of a habit
because I just want to take something
when use the auto ref ref that's usually
usually uses that use that to signify
that you want to take anything that's a
reference right is when generally when
you want to use an auto ref ref so you
use auto when you always want to take by
value use auto ref ref when you want to
take my reference and so I don't really
care what the reference is because I'm
not gonna do anything with it I mean yes
later on and the code actually I'm just
passing a car's reference so that is
possible to do is a cantata ref as well
but in general I just use a home
reference meaning take a reference to
anything so good question so now the do
it yourself with the reflectable macro
here what we're gonna do is create a
little macro to do this now I don't know
basically this is going to take the
basically you just list out your types
here and where I should put the types in
parentheses so I should look at kind of
a way of doing it and the way when you
put your type in round parenthesis I
actually call that a tight expression so
essentially what we want some utilities
to kind of handle the type expression so
these are some basic macros called a
strip and pair basically what strip does
is it basically will strip off that that
like at the bottom there you see the
parentheses int it would strip off the
parentheses int and it leaves you with
just acts right and in the case of and
so you use that like when you need to
you you need another variable type but
there's other times like we want to be
able to actually declare the the field
itself so we don't we can't declare it
as in you know parentheses and X so we
need to declare it as an X so for that
case we use pair and what pair does is
basically remove off those parentheses
off the in and we just left with the
index so that's basically how that works
of course we still need a few more macro
here so we start off here with a in nrx
macro the basement just kind of counts
out the number of arguments there this
actually counts it up to eight and then
we use it kind of like a simple pattern
matching for each of those up to eight
so we basically say okay we take each
takes a macro and it takes a very deep a
demons and if it's you know if it has
one it calls it for the first argument
if it has two it calls it for each
argument for each both of those
arguments all the way up to eight so
it's just kind of like a repetitive
thing and you can use to call up two to
apply a macro to go to those arguments
so that's how that works also we need a
way to actually enumerate them so and
what I mean by enumerate is we want to
be able to when we call each of those we
can actually stick a comma in between
them so when we want to pass them on to
like in that little function are you
giving it we want to actually put a
comma in there so the first thing we
have is we have this common thing that
why should prepend a comma on to the
front of the macro then if you look at
the email macro it calls each right but
it actually changed it calls up with
that comma macro so it pretends that
macro into the front of what we're doing
but when we do that obviously because
we're prepend in a macro to each single
element it ends up adding an extra
argument on to the first of the this in
the front of the list right so we kind
of want to get rid of that first
argument so that's why where the tail
comes in and tail basically just ignores
off the first of the argument and then
gives us Socktober also we need a way to
actually string the size the arguments
regular you can use the power like pound
x right there like you see in the
strings on the feminist string size that
will actually turn in that token into a
string right but because we're actually
calling it from another macro blankie it
won't it will actually string a size of
the Mac
we're passing in so instead we just
spilled through a separate in direction
of this what the string size does goes
their separate direction and then
converts in its history so here's how we
can start writing with these utilities
here's how we can start writing the
reflectable macro essentially so we
first call each with a memory child show
on the next slide what the memory each
does but basically that line is
basically they declare each of the
members in the into the struck the the
next part is we actually declare a
struct called unpacked and inside there
we have an apply function that will take
itself and it will take a function and
for each of those function for that
function basically essentially will
actually call each of the elements there
but we actually want to not just call
each of the elements there we actually
want to actually have them name itself
and we'll show in that unpacked each how
we actually store it into a pair so the
next one you can see here when I do
remember each we call pair X semicolon
so it basically declares it as a member
variable and then for the other one for
the unpackage it basically calls a good
pair and stuff so that first the first
part was going to be the name so we
string the size of the name the strip X
which will give us the name of that
field and then the second part will just
be self dot strip X that will give us
the that will actually access the field
in the class so finally putting it
finally together we can actually call we
carry our own for each function that we
can actually use to basically iterate
over all the elements that we've
actually set up so basically that works
we use the similar case like we did
before where we had to use the remove
cons because we because we can't call
the scope operator on something
the reference so we do that we call
apply and then we pass in our lamda that
takes all the different elements that
are in that struct all together and
wants but we want to actually apply that
function to each of those arguments so
this actually uses a thing from actually
I think Shawn parent you tweeted
something very similar to this where we
actually okay okay here's a tough on
that on Thursday but it basically
basically we expand we expand when you
call the dot dot dot we're gonna expand
each of those that that function call
for each of those XS so it would
actually call that function for each of
those and then we actually put it in the
initializer list and the reason for this
is because when we by default
you can't insure the ordering for each
of these functions by default if you try
to pass it on to like a regular function
but inside of initializer list you're
actually guaranteed that it's going to
be from left to right so that's why it
goes into the initializer list and since
the initializer list only takes integers
that's why at the end that you come at
the zero there so it basically converts
it to basically energy the result of
that function to an integer and it only
puts a bunch of zeros in there but it
has the side effect of calling you to
the functions from left to right so
essentially by doing that we can
actually now have a for each function
that we can I should call for each of
our elements and we can actually then
actually implement print X amount like
we did or the other example so we we
call print X and now we call our for
each on it and we can basically do data
dot first will actually give us the name
and then data that second Y should give
us the value that's associated with it
so that's
we have time for about one question
so which of these solutions and where
have you being used before the last
solution I've never really used that
much but I use the variant of that at
one point to be actually develop it
using so that actually supported like
Gators and setters and things like that
using kind of a similar ease of similar
kind of thing that how cute properties
worked but in general I kind of tend
towards using like boost fusion in the
visitor pattern so if you're able to use
boost or how the library is kind of like
boost Hanan or boost hannah if you're
able to use those library it's better to
kind of tend towards using a library
based solution but if you're in a place
it's like okay we can't we don't have
those we don't want to we don't need a
dependency on boost and then sometimes
it's actually better to lean towards
using the desert pattern it's actually
fairly simple to write it just uses
basic C++ doesn't have any make a major
library dependencies just a simple
question I've used QT and the mock birth
reflection capabilities in the past you
haven't really mentioned on that I was
just curious if how that compares in
your mind to what you discussed this
today oh yeah yeah there's QT that does
that it's actually what we're I was kind
of focusing on more of is compile time
base reflection cuties Mach is actually
more of a runtime reflection and it's
not even entirely C++ because it
requires an extra step in the process
what I was trying to focus on this talk
is actually doing stuff that I should
only that basically essentially just
runs basically in C++ and you don't need
a separate build step because there's a
there's some other solutions to that
actually you can read the metadata using
like Lib playing and then oh I should go
out and generate some extra files for
you so that you can do reflection as
well there's there's there's several
tools that do that so well but the QT
the QT is actually
as just since you mentioned it it it
relies on getters and setters when you
do it besides running the mock so like
in this example I was able to just take
a plain struct and actually basically
essentially make it work with the
reflection framework if at all means
like if you need to like actually like
if you don't have the need for having
the getters and setters
but maybe you have certain requirements
you need these actually to be playing on
data types for whatever reason like
since you're interfacing with like hdf5
or some kind of little type of format
that kind of RC API that kind of
requires that then you can't really
instrument it with getters and setters
you can't you you also can't use the
Mach with it because if the choir is
inherited from cue object so these
techniques like like specially the first
two techniques you can still meet the
requirements of having a plano data type
to interface with c+ on on the other
side of the you can get reflection data
about it
Chinn at the beginning that the compile
time data could be used to serialize
serialize out for produce data the
runtime data right yeah so essentially
what you could do like instead of like I
have the example where I print the XML
instead you could just create like a
static map or whatever in your in your
data structure and then you get
essentially instead of doing the for
each and printing out the XML you just
fill up that map that's static map
that's associated with that type and by
doing that you can essentially have the
runtime data and then you just need a
mechanism to query based on that type to
query for that map so that's how you can
generate your one-time data good quick
question will your code be up on github
this code it will be up on get lab for
the presentation all the code in the
presentation will be on get lab which I
should be posting here in the next I
don't know when they're going to release
it for the conference but yeah it will
be out on get lab so you can make sure
you take a look at it and it all
compiles and runs you mentioned at the
beginning that there is a study group
that was looking into runtime reflection
for seeketh plus what's the name of that
group Burt you follow them or anything
yeah I don't remember the number for it
if it's it's like SG its SG it's not s
to eight I think that's the concepts one
lady's su for I don't I don't remember
which one it is
I'd have to go look it up sorry yeah
it's one of those two groups yeah
you're aware that tup you pronounced
tuple right okay well I mean it's yeah</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>