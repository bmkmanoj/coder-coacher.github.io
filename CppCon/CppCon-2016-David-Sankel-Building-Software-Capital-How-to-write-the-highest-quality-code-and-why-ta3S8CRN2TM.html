<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: David Sankel “Building Software Capital: How to write the highest quality code and why&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: David Sankel “Building Software Capital: How to write the highest quality code and why&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: David Sankel “Building Software Capital: How to write the highest quality code and why&quot;</b></h2><h5 class="post__date">2016-10-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ta3S8CRN2TM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right my name is David's ankle from
Bloomberg and this talk is about
building software capital how to build
really high quality code and answering
the question of why you'd want to build
really high quality code so I was at
this meeting and there were like a dozen
or so people there were a bunch of
people at this meeting and this was for
a very important project this was
something that was extremely critical
was very important everybody had an
interest in this thing and it turned out
that only three of these people were
actually software developers the rest of
the people in the room were all support
team marketing testing also the cost of
only three people were actually doing
the work for this project and as I was
sitting in this meeting I was starting
to think wouldn't it be better if
everybody in here was a coder you know
we wouldn't have all this wasted people
that were just paying to do not the real
work we'd actually get to time time to
market faster right you don't think
about it if it takes one man 12 months
to do a project then if you put 12
people on it then it'll take one month
to do it right this is this is a
fantastic idea you know I'm just
thinking about how everybody would be so
proud that I came up with this genius
idea and you know people are clapping
and then I started seeing these people
clapping that didn't have feet and then
I realized that I had fallen asleep I
must have been dreaming because this is
not how the world works this whole idea
where you can just you know add more men
to a project and have it get to market
earlier it doesn't exist in the real
world right we all know this and this
actually has been known for a really
long time how many of you guys have read
this book the mythical man-month almost
everybody right so this book was written
when I was negative six years old and
and he basically outlined why this
doesn't work okay this is a Brooks who
wrote the book
and the idea is if you have a whole
bunch of software developers and they're
all working on the same project there's
a lot of communication that needs to
happen in between these guys everybody
needs to talk with everybody in order to
make sure they're all in sync with the
project and what ends up happening is
this inner communication the cost of
maintaining that becomes so high that
you end up losing productivity so
realistically your graph looks something
like this if it takes one man 12 months
you throw another man on it you improve
your productivity you you know maybe
even a couple more productivity improves
but then it starts taking longer to
release the product when you have more
men added to it and then you get to this
red area and what this red area is up on
the top right that's blood right that's
when the project doesn't actually
deliver and somebody's going to be
shedding blood because of this thing so
ideally you want to have a team about
the right size so it's often commented
that you know the right team size is
about two pizzas worth of team if you
can feed your team with two pizzas then
that's about the right size
and when I've discussed this with
somebody before they they said well you
know I could eat two pizzas by myself so
that's obviously a very highly
productive software developer but
generally you have your team sizes
optimized about two pizzas worth so the
goal here is to improve your time to
market you can optimize your team size
and you can go so far doing that you can
hire top developers because we know that
really good developers tend to have a
higher productivity than your average
developer so you can go that route it's
going to be hard to find them there's
not that many and you're competing with
crazy startups that are willing to pay
millions of dollars so is there anything
else that we can do that's the question
how can we improve our time to market
without optimizing team size and hiring
top developers so one thing we could do
is we could reuse so if we have a piece
of software and it's already made and we
can use it in our next project
then maybe we can reduce the time to
market for our next project so the basic
idea goes like this
you start out with one piece of software
then you make another piece of software
which is based on the first one and then
you throw some new piece on it and
everything just fits perfectly together
then you do another piece which happens
to be unrelated you put these things
together and add a new piece and so on
and so forth so doing this next project
which requires many more lines of code
just requires putting a new piece on top
however this doesn't actually work like
this normally as well here's how it
frequently works
you start with one piece of software and
then you throw you another piece on and
and but this second piece that you throw
on there it doesn't fit exactly on the
first piece it's kind of teetering a
little bit it might fall off the third
piece of software that you're right has
a little bit of mud on the left because
it had to get done in a hurry it's not
really that clean but you know the
developer says hey it works we got to
mark it on time everything's fine right
management's happy ok it has a little
bit of mud who cares
the next piece of software requires more
mud and a bunch of sticks to throw this
thing together and you add your new
piece on it which requires more mud and
sticks and the developers start saying
you know we should really fix this stuff
someday
I'm sure you've heard this before so the
developer goes to the man and says can
we rewrite this and what does the man
the man say no I got to rewrite this
we've got things to do ok so here we go
we're going to take our previous piece
we're going to throw a new piece on and
this one doesn't even fit in the same
dimension as the other pieces but but
somehow we were able to make it work
and then the developer says to the man
look we really
need to rewrite this and let's say this
time he really gives a convincing
argument we need to rewrite this and the
man says ok fine we'll rewrite it what
happens next
blood everything blows up because
getting this whole rewrite done is
making the next product come out too
slow the whole company crumbles many of
us I'm sure have seen this happen before
it happens way too often so the idea and
what happens in most companies is you
have as time chugs along and you're
increasing the amount of software you
have your technical debt increases and
notice that it's not increasing linearly
this is increasing exponentially the
reason being is that when you have more
and more technical debt you need to take
out even more technical debt to pay the
taxes that you're paying or the interest
you're paying for the previous technical
debt and then you get to the point where
you just can't even add anything without
taking years and years to your product
and that's a really big problem so your
time increases to add new features but
eventually the basically the idea that
I'm trying to get across here is that
the greedy algorithm does not win in the
long run you know just getting whatever
doing throwing whatever kind of piece of
software you need to do to get the
features out to meet your business needs
is not going to solve your long term
goals you're going to end up in this
this problem and I can tell you from
what I've seen for for larger
corporations larger companies or even
companies have been around for five plus
years they're in this kind of situation
the technical debt is huge so we know
that the time to market with a debt
approach tends to increase over time but
if you take a no debt approach it stays
pretty much linearly now there's a
little area there to where if you're
read you know trying to release
something in two months and you don't
care about long term issues then and
maybe it makes sense to take out a bunch
of debt you know maybe if you
are trying to get some kind of demo done
or something along those lines or maybe
a game where you're releasing you forget
about it but even the gamers are are
thinking taking this into account these
days maybe it makes sense but for the
majority of us the software we work on
is the same kind of software someone
else is going to be working on ten years
down the line so the no debt approach is
the way to go for the long-term
sustainability so then there's this idea
of software capital software capital is
kind of like the opposite of technical
debt but let's before we go into what
exactly software capital is let's look
at some of the differences so technical
debt very easy to create you just and
any any person who just learns how to
program their first day can figure out
how to make technical debt software
capital on the other hand is expensive
and hard to create a technical debt you
have this reuse by the gun and what does
that mean
that means that management tells you you
have to reuse this software otherwise I
will shoot you right that's reuse by the
gun whereas if you look at software
capital as voluntarily reused so someone
will just go ahead and say hey I want to
use this this is going to make my job
easier
tactical debt has a very narrow focus is
usually concentrating only on the needs
of a particular problem whereas software
capital you have a wider focus more
generic in that sense technical debt of
course is ugly software capital can be
very beautiful and then of course
technical debt is usually incomplete
it'll have things like slash slash to do
in it we're a software capital doesn't
have any to do is it's complete and
ultimately technical debt is going to
increase your time to market over time
whereas software capital is going to
decrease your time to market so what is
software capital and the best example
that I can think of is stood vector how
many of you guys use to vector everybody
uses stood vector how many of you guys
have had to debug stood vector I see
three four these are probably like the
standard library implementers holding up
their hands generally you just trust
Stud vector right nothing doesn't have
any bugs you never really think about it
having buds it just it works right
documentation for stud vector it's
abundant right we have it documented in
maybe 30 books a million sites on the
internet it's all over the place so
vector is a great example of software
capital is something we can use to get
our job done easier and quicker so these
are some attributes of software capital
it's useful as clean it's complete
reliable general documented bug free
efficient and reusable this is the kind
of software we want to develop to
decrease our time to market so this
phrase software capital this was coined
by deans aris in 1996 in this article
that he wrote called software capital
achievement and leverage so use this
link to go get it or just search for on
the internet it's an interesting read
unfortunately it just it was written
back then but i got published like a
couple weeks ago so it's kind of neat
but he defines software capital as the
cumulative technology that can be
redeployed to new situations this is the
opposite of technical debt technical
debt if you think about it in financial
terms it requires you to pay interest
over time whereas software capital it
gives you dividends over time it pays
you instead of you paying it so it's
really the way to go so as john Lycos
would put it this is kind of a a graph
of the components in your organization
through dependency things at the top
depend on the things underneath where is
it most important to have your software
capital that would be the stuff at the
bottom the stuff that's most likely
going to be reused it's most beneficial
to have really high quality software
being written at that layer ok but how
do we build software capital but before
we get into that which is really going
to cover the rest of the talk if you're
sold on the need for developing software
capital that's really
all you need the rest of these things
are just tips on how to do it but you
will figure out how to write software
capital if you if it's important enough
to you you'll just see okay this thing
turned out to be pretty crappy what
processes what things can we do to make
this better and make this not happen
again but it's the approach it's the
attitude that you take when you go into
a software project so they're going to
be seven principles here that I'm going
to go over and just give you some tips
on how to write really high-quality code
the first principle is code reviews okay
so the idea is you want to get an
outside opinion about how your code
looks now we all know that you think
that your kid is adorable right you
think that your kid is the most
beautiful kid in the entire world
however before you put your kid into a
beauty pageant because you think he's so
cute you might want to get an outside
opinion so I often get asked a question
I'm just going pre-emptive where did I
get this picture I search google for
ugly kid somebody thinks this kid is
gorgeous so we want to get an outside
opinion and the things that we create is
from our perspective are great it's good
to get an outside opinion we want to see
others how they see our code is that
interface really intuitive well someone
else can tell you and I can tell you
that if you get a code review by one
other person you know carefully go
through every line and write all their
comments you're going to get 90% of the
feedback you'd get from getting a dozen
code reviews it's very very useful to
get a code review so getting that
outside opinion is very important
another reason why code reviews are nice
is because you find bugs so almost every
code review that I do
I'll find a bug in somebody else's code
I don't claim that I find all the bugs
but I find bugs so a hidden bug in a
piece of code that you don't know about
this is just unaccounted for technical
debt it's waiting to rear its ugly head
and the benefit of finding the bug early
is the closer you are to actually
introducing the bug the cheaper it is to
fit
generally if you're trying to debug
something which was written ten years
earlier and has 100 layers between you
and them that can be really expensive
you're going to spend a lot of your life
in a debugger if you have a bunch of
technical debt so finding bugs early on
is really key another benefit of code
reviews is standards and socialization
the idea is you want to do the best
thing everywhere if one guy happens to
figure out a really good way to do
something and he's the only one who does
it that doesn't really benefit you as
much as it could
whereas if he does a code review of you
of your code and then he teaches you oh
you could do this in a better way and
then you teach that to other people you
basically get this communication going
through the team really quickly so you
get this knowledge transfer which is
wonderful so the idea is and also you
have a couple people looking at the same
piece of code you basically don't
eliminate that thing we're like oh yeah
that piece of code that one guy handles
that you don't want to have that in your
organization so the another issue with
code reviews you get accountability
right does this thing have documentation
is this thing unit tested enough does it
follow our coding standards now two
people are responsible for this code I
don't know about you guys but when I
write code I love solving a problem and
when I finish solving the problem I feel
great it's like yeah I did it and then
adding documentation and stuff like that
that's kind of a chore maybe some people
love writing documentation I don't know
I don't but having somebody to keep me
accountable and say hey you know you
really ought to add documentation for
that or you really need to add unit
tests for that even though I feel like
it's complete that really helps a lot
and it's a lot easier to be objective
when you're reviewing somebody else's
code when I'm reviewing it I wouldn't
really need to document that well if I'm
reviewing somebody else's code doesn't
hurt me to say these more documentation
or going to write it so just a few tips
on code reviews if you haven't done
these before
I like the idea where you can choose
anybody on the team to do a code review
for your code having one code reviews
are that doesn't work out very well and
you're only getting input from one
person one round of feedback is usually
enough to do a vast improvement of the
code if it's something really critical
you might want more and this works
extremely extremely well with people who
love to learn people who don't love to
learn this this approach doesn't work
very well I wouldn't want them on my
team tooling can help you know there's
great stuff like github Enterprise and
all that out there are specific code
review tools but don't let that stop you
from doing this you can do it with
emails I've done it with emails for
years you just write in the email you
put the line number and you put the
comment and send it to the person and
one nice tip is using did you consider
language you know think about how you
feel if somebody looks at your code and
says this is garbage you really need to
improve that you know it hurts and
people are people
there's just a really simple trick you
could do instead of saying this is crap
you should have done this way you just
say did you consider it doing it this
way and it just seems to go over a lot
better that way so try that so the
second principle and running really high
quality code is having standards why do
you have standards if you have a bunch
of variants even in spacing in your code
that takes people to time to think and
like recalibrate and like okay I'm
looking this other file which was
indented this other way you can improve
your productivity by having everything
the same really what the standard is
oftentimes doesn't matter as much as
having a standard which is globally used
improves the professionalism of your
code and if your code looks professional
it's more likely to get to be reused be
used by other people and you know it
makes tooling possible if you have
everything done the same way everywhere
then you can write a little script to
update your code when you need to in the
future so what goes into a standard I
would say formatting any kind of idioms
that are things that are comments your
organization or the type of code you're
writing documentation requirements
organize things and whatever is the best
practice that you can think of so I
would say that tooling is a must for
your standards if you aren't using clang
format I start using clang format I pity
the fool who doesn't use clang format
these days stop wasting your time
manually formatting your code it gets
complete consistency it's fully
automated it's just everybody should
that these days or something like it
when you get new standards change or
something new has been recommended
retrofitting the old code is pretty
important and I recommend you do that
whenever it's feasible the code base is
a thing that can be operated on you know
don't think just about the little area
that you're working on somebody needs to
have the big picture in mind and to
operate on that and you need tooling to
do that you've seen several talks about
claying using clang as the library to
refactor your code that's a really good
idea
clang tidy you can add plugins to this
thing and then for your particular
coding standards you can have it go in
and even fix certain violations which is
nice so tooling is a really good idea
when you're working with standards so
what is the criteria how do you know if
something goes into the standard or not
or what what decision you should make
when you have two competing options so
the rule I like to go by is objective
criteria always Trump's subjective I
think this looks cooler versus there is
an objective reason as to why this one
works better so if you have a subjective
argument versus an objective argument
objective argument just wins there are
different dimensions and a concentration
on reuse is really important you know if
we implement it this way is this going
to hurt or improve our ability to be
reused and when people reuse code a lot
of times it's not just based on
objective factors is up based on
subjective factors so if it looks more
familiar that might be a good reason to
have it have a standard go that way and
don't waste time on trivialities just
cut off those discussions because they
can end forever no they can they don't
end forever they never end okay the
third principle here is unit testing why
would you unit test unit testing you can
kill bugs before they cause problems
sometimes you find bugs when you do your
unit testing your future-proofing
against new bugs just having unit tests
gives the impression of reliability and
people will just say oh well this is
really unit tested so I'm more likely
going to use it because I get the
impression that it's more reliable and
safe refactoring is another one if you
need to take some code and refactor it
and as well unit tested
you have a lot of confidence that you
refactor didn't break anything but you
get a lot of excuses with unit testing
you know oh this is GUI code that seems
to be just a complex oh it's GUI code
therefore I cannot unit test it with the
modular eyes GUI you actually can test
the pieces so you break it out and you
don't don't let that be an excuse to not
unit test your code or oh this depends
on disk or network or this other kind of
thing you can use dependency injection
to solve that and we'll look at that in
a minute here or I already know the code
is correct okay some people prove their
code and I think it's a wonderful thing
to do I do it myself but that doesn't
replace unit test because I prove my
code but the next person who goes in and
modifies it probably isn't going to so
we need to get flag when somebody breaks
the code and of course the most common
excuses I need to ship this thing well
if you have a code review barrier and
you say this code needs unit tests
before it's going to pass review people
will do it otherwise they aren't going
to get their stuff and in the master
branch so designing for testability is
really important and I'm just going to
show one thing which will handle 90% of
the cases here when people say they
don't know how to unit test their code
so here's a good example we have some
kind of server code so that people will
just say oh we're talking to a server we
possibly can't possibly unit test this
code we connect to a server we send a
request asynchronously and we have this
lambda here which handles a request so
how will we unit test this code well one
thing we can do is in that else branch
when we're handling our non error
payload we're going to parse that result
somehow you can refactor that function
into a separate component or a separate
function and now that function can be
very easily unit tested so that's one
thing you can do another thing you can
do is you can take your server and make
an abstract server so this thing which
has a connect and a send request
operation on it and inherit from it and
say okay this is going to be a test
server so now I have these functions
they're the three at the bottom where I
want to say throw
we exception on connects set request
response error I'm controlling how that
set request function is going to call
that lambda function underneath now I
can actually write the test code for
that I just use my test server I say the
behavior I want it to have
I throw it into my function and I can
verify the kinds of results that I have
so this works it's a really simple
technique and it's widely applicable to
all these situations where you don't
think that you can unit test your code
it's called the pendency injection I've
heard it called a few other things but I
think that's the most common way of
calling or the way of naming that thing
and then tooling is really important for
unit testing continuous integration
server you know have a server which
builds your code and runs your unit
tests on a commit that seems to be
pretty widespread these days but if
you're not doing that you know just get
to get it started make it make it happen
another thing that's nice is having a
try server and what that is is I have my
code I commit it I push it but I'm not
going on the master branch I'm going on
my own particular branch and I go to
some website and say okay go ahead and
try this branch on all the different
platforms and give me feedback on that
that can be really really handy the
fourth principle is contracts so
contracts are like documentation on
steroids I've heard it called that
before but really they're a different
thing and and we're going to go into
what what they mean and why this is
important for writing code that's highly
reusable so what are contracts how would
you describe a car you might say a car
is something with four wheels that has a
top on it you can drive it get from A to
B with it so on and so forth a
motorcycle wouldn't be a car but you
have this idea of what a car is now each
car is really unique I mean especially
different types of cars they're all
different but they all qualify as car we
have this common understanding but you
can change the pieces underneath and
still something represents a car that's
kind of what a contract is this is a
description of the behavior of a
function omitting the details that you
don't really need to know
so it's precise a precise and complete
specification of guaranteed user visible
behavior this will exclude
implementation detail you don't need to
know how the car works you just need to
know how to use it basically this is the
what and at the how and an example of
this if you have a sort function you
could have the contract say put the
specified in vector in order from lowest
to highest that is one way to have the
contract but you could also say put the
specified infector in order from lowest
to highest the algorithm runs in Big O
and log and time using Big O and space
now when you make a contract more
specific you're essentially going to get
more use cases out of it the more the
fewer guarantees that you have in your
contract that's going to give the
implementation more flexibility so you
have this kind of trade-off in terms of
implementation flexibility and the
number of use cases something has and
that'll change depending on the kind of
situation you have but in essence this
is an agreement between the user and
your implementation and just like a
contract in real life if you break the
contract the whole contract becomes
invalid that's the undefined behavior so
you have to abide by these preconditions
and I will abide by what I say I'm going
to do as the implementer of the function
so oftentimes you'll hear well the code
is the documentation the code is a very
precise description of what this thing
is going to do and and that makes sense
I mean it is a good thing and if you
have a small project and you just want
to use the code as a documentation I I
can understand that however in a large
project think about if you're modifying
one of these pieces all the way up at
the top you're going to have to in order
to figure out what this function does
you're going to have to look at the
implementation of the functions it calls
and then the implementations of the
functions that it calls all the way down
to the bottom that's just way too much
work to have to go through all these
different functions to the variable
on them nobody can do that on a
large-scale project so the code is the
documentation just cannot work and it's
pretty easy to see why so why would you
use contracts well it's it's an
objective way to define what a bug is a
bug is a broken contract if somebody
calls a function not meeting the
preconditions then there is a bug and
the bug is in the color of the function
if there's a bug because I didn't meet
the contract specification for the
function I'm implementing there is a bug
and it's in the implementation of that
function so it's really useful to be
able to to look at contracts this way
and to be able to figure out whose fault
is this and where the bug lies it allows
for tiers of abstraction which we just
discussed you know once you get to a
certain level you don't have to look at
the implementation you just have the
contract up here and you don't have to
carry about the piddly details that are
in the implementation of that function
if you have some code which is highly
reused you can make you can modify the
implementation of that function and have
complete confidence that you didn't
introduce any bugs right as long as you
stay within contract it also provides a
lot of guidelines in terms of what two
unit tests you know did when you write a
contract and you see okay well this
actually requires this this requires
this and that's just to provide this
well that's great guidelines to figure
out what's a unit test for your function
and finally which is interesting what is
interesting is it makes bad interfaces
really stand out if the contract to you
right for your function ends up being a
whole lot of information and a lot of
subtlety to it then you realize like oh
crap this is a bad interface and go and
modify it whereas if you don't write the
documentation for you might not even
realize just how terrible your interface
is so for contract specifications what
does something like this look like so
the contracts specification that we use
at Bloomberg
all the stuff you see underlined up
there is wording that's precise and
specified by our contract schema so use
a schema and keep
keep everything consistent through code
reviews otherwise you I don't think you
can really have contracts without doing
code reviews and have someone enforcing
that make it convenient having the
contract in the header is really nice
separating out your inline functions you
know you can put your functions inline
in your class or you can give the
declaration and the implementation later
on in the file
I recommend the latter because that way
someone has a concise and easy to read
contract specification of your class
that you're working with and finally
keep your contracts human Riedl readable
if someone sees legalese or markup if
you go crazy with dr. Jenn they're just
going to ignore it right and then they
don't do any good for anybody
so having a human readable contract
specification is very important and I
recommend the Bloomberg contract
specification and this is not because I
work there this is the best contract
specification that I've been able to
find out they're really good quality is
part of the bde coding standard go get
this thing and download it and what's
awesome and so this thing it has a
Creative Commons license so you just
copy and paste that thing into your
coding standard and then modify to your
liking and that's okay so the fifth
principle for writing really high
quality code is having really good
interfaces and I want talking about user
interfaces I'm talking about the
programmatic interface that you provide
in your header file so I worked with
this this one guy and he was very
troublesome to work with he was a
manager did not understand anything
about code and he said you know what I
really want is just a green button I
press the button and does the thing that
is the ideal user interface for
everything that doesn't actually work a
lot of times coming up with a good
interface it really is an art form and
you need to be general in the right ways
if you're going to add a template
parameter to your class that you're
writing or your class template that
you're writing you know is that the
right template parameter are people
actually going to use that does it make
sense a lot of you know becoming a
really good C++ awkward about developer
is knowing when not to use templates
like there's a lot of boost libraries in
my opinion that where people don't
really get this that it doesn't provide
a user well it's really clever and it
uses a whole bunch of template
parameters people just can't use it
because you're generalizing in the wrong
ways having really simple contracts
that's going to get a lot of reuse
keeping your your parts into manageable
pieces build on recognizable patterns if
someone recognizes the pattern that
you're using they're going to be more
likely to use it and naming is really
important so spending time on finding
the right name for a function or a class
I think is time well spent but again you
know make sure your art is critiqued by
other people besides you oh and yeah
math can be a really good guide to user
interfaces and I'm not going to go into
more depth in that I've talked about
that before but if you learn how to use
math to guide your designs that tends to
help a lot and along the same lines
organization is really really important
how you organize your code if it's a
consistent organization that can help a
lot so most of this is taken from John
Michaels book we'll talk about later
but the idea is you have three different
levels you have a component which is a
header and CPP combo file you have a
package which can either be a library or
an executable and then you have a
package group which is a collection of
packages we're just organizing things in
this way and three-level seems to work
well in practice so one way of doing
this is you have your header files the
name of your header file is organized by
group package and component group ford
slash package forward slash component
and then you have the dot h in the dot
CPP file similarly names and then your
namespaces correspond to your group
package your group and package name and
then your component is the name of the
class that's in there you have a
connection between your physical layout
which corresponds to your files and how
you organize things and directories that
corresponds with your logical
with your logical issues which is your
name spacing and your class names and
that kind of thing so if you're
wondering how to access a class you
always know the place to include it
right if you know the group in the
package then you know how to how to
access that class it makes it very easy
to keep your class your includes
consistent with what you're using in
your implementation files keep your
class member functions to be only those
that require private access to your
class that helps a lock that makes it so
you can if you're going to modify some
kind of function which uses your class
if you're going to modify your private
parts you only consider the things that
actually access your private parts so
you can separate like a circle class in
this instance which has the things that
require the private data from a circle
utila class which happens to use that
private which only uses the public
functions to implement its functionality
and then keep all these things
consistent so you know class circle
class circle util where you have your
static functions and this reduces
coupling it's it's some of this stuff
it's hard to appreciate until you've
actually worked with a code base that
works this way but it's a relief to use
something like this when it's organized
this way multiple classes in the same
component why would you do that
so one reason why you would put multiple
classes in the same component is if they
have circular dependencies because you
don't want to have circular dependencies
between your components friends should
stick together as John likes to say so
keep all that stuff in the same
component and as you're naming the
classes that are staying in if all your
classes are in the same component or
there are several classes in the same
component they all can't be named after
the component so one way to do that is
to call them the component name
underscore and then the class name which
belongs in that component that way you
still keep that correspondence like
whenever I see a class name I know
exactly which include to grab it from so
more rules for organization in one class
per per component generally speaking a
component consists of a single header
and a single CPP file that just
simplifies things
packages consist of logically related
components that have similar
dependencies that's the kind of rule to
figure out something belongs into a
package and no circular dependencies
between components nor with packages nor
with package groups that makes your
system a lot easier to reason about and
also improves testing so if you figure
this out and you have all your packages
and their dependencies figured out you
can actually look at what the big
picture is for your company you can make
a graph and see okay what are my package
groups how do they relate to each other
and you get this kind of bird's-eye view
of your software capital your assets in
your company and it's a really good view
to have so for more on organization read
John's large-scale civil hood software
design book if you don't have this book
haven't read it please go on Amazon and
buy it and especially read this part an
organization it's really important John
is coming out with a new book
unfortunately he's been almost ready for
several years now but hopefully it'll be
really soon now and I highly recommend
next I've already started reading some
of it so the sixth principle here is
innovation everybody loves innovation
great things happen the world is
changing we're getting smarter we're
learning more with C++ 11 we got to have
smart pointers and are really references
and lambda functions these were great
innovations C++ 17 we got optional we
got variant well actually we didn't
really get a heck of a lot with C+ 17
but we're hoping for C++ 20 we're going
to get some real innovations but with
innovation you have a tax so if we think
about this financially this is just a
tax that you get every year things are
improving and you have a tax and you can
decide to pay it or you can decide incur
technical debt because of it
so new stuff is great but it almost
always adds complexity right C++ is not
getting simpler over time to be a C++
expert you got to know all the note old
stuff and all the new stuff and that
isn't too fun
I innovation is the cause for code rot
so your code which looks great in 1990
does not look so great anymore
that's code rot and if you don't pay
your taxes you're going to incur
technical debt so how do you pay the
innovation tax training going to
conferences reading new books and of
course code reviews can be a great way
to disseminate that kind of information
and make you modernizing your code base
a priority
don't let it sit there in the old and
automation can help a lot with this some
of the clang tools for example can go in
and update your code the C++ 11 style
coms constructs so it's really important
to pay the innovation tax otherwise
you're in danger of hitting back that
old exponential growth of technical debt
type problem and it is hard to convince
people that to pay the innovation tax
but it is well worth while in the long
run so the seventh principle here is
infrastructure
what's infrastructure this is the stuff
that everything else that your company
does with regard to its software is
based upon this includes things like
version control continuous integration
your build systems the core libraries
that you use your coding standards and
anything that's going to have like a
sweeping effect on your code base this
is what I call infrastructure and I
would say that too often this is ignored
but the real thing here is that somebody
needs to own this big picture someone
needs to own infrastructure and who's
the right person to do this this is not
an easy task you can do one small
mistake in your infrastructure and the
whole edifice comes crumbling down so
you need to put your best people the
people with the most experience the
highest technical expertise on your
infrastructure people make the mistake
and they think oh man well we're going
to upgrade to let's say qt5 from QT 3
let's put an intern on that not a good
idea
right I mean and you can understand why
they would want to do that because it's
hard
to make the connection between the
infrastructure expenses that you have to
pay to the actual benefits you know that
you get from a company you know whatever
kind of financial things selling your
software or whatever but it does have a
really tremendous impact so you've got
to do it right and putting your best
people on that I would highly recommend
it and do make it a priority so if you
put all this together you can end up
creating something which is beautiful
which is big and can last decades
hundreds of years we don't know we
haven't seen software on that level but
if you want to make something which is
really going to last it's going to be
appreciated for a long time you have to
put these principles into place
otherwise eventually will fall so to sum
up the real value of your organization
is its software capital if you do not
have software capital you're in danger
of some startup coming along and just
killing you with new features because
you're too slow to be able to catch up
and this is the key to your sustainable
competitive advantage if you have a
bunch of software capital and you can
add new features to your product quickly
and even quicker as time goes on because
you have all these things already
written that's going to give you a huge
advantage going forward and here the
seven things that that I recommended but
anyway this this concludes my talk so we
can now open it up to questions
are you doing David yeah it was
interesting talk but I think that kind
of struck me throughout was that mostly
contracts I've ever worked the team
we're doing the software know all of the
stuff you just said but you can't
actually achieve it because management's
come along and said that we need this
thing delivered by this date and we sit
down and we look at what we need to do
and we kind of just tick off a lot of
the building of software capital because
you just can't get it done in the time
that's allocated and how would you
counter that as being really the problem
as at hand rather than people not
knowing what to do but rather they don't
have the time or the management will to
do it a good question so the question is
how do you convince your manager to to
care about software capital in a
nutshell and I think that what's really
important is to make an argument based
on the long-term sustainability of the
business you know if you if you just say
hey we need to you know do code reviews
hey we need to do this we need to do
that they don't connect that they just
see oh this is something the developer
wants he doesn't really see my needs as
a manager so I think making the argument
in terms of you know where do you want
this company to be in ten years are you
scared about it startup coming along and
you know killing us I think that's the
way to do it that or get yourself in a
management interesting actually
mentioned about startup the single
biggest thing I've noticed in the
current contract I mean is that there is
a huge worry that a start-up is going to
come along and kill us because they'll
move quicker and deliver a product
faster than we will because they've cut
more corners than we have so if you see
the problem build your software capital
okay so these are really good
suggestions for building software
capital but suppose you have a project
right now that needs to continue the
ship and has a large amount of technical
debt how do you start going into
converting that technical debt in the
software capital while continuing to
ship well you can't make like okay so
the question is you know how do you just
take a you have large software projects
you need to get things delivered how do
you can you get things delivered and
start paying that technical debt
or building software capital at the same
time you can't make resources come out
of thin air so it has to be made a
priority whether you spend one person on
it multiple people on it or you do it in
your spare time it just needs to be a a
concerted effort that's really believed
by by all the key people in the
organization I don't think you can
really do it as just a single software
developer I'm going to go after the
technical bet you might get fired
because you're not producing enough of
other stuff so it's really important to
sell this to the people who care and I
think it's possible no more questions I
guess I must have covered everything
it's fantastic I have one more question
is just do you have any good resources
or links that you can give to your
measure to help convince them that this
is the right way to go forward ah good
question do I have anything that you can
use to convince your manager I would say
email your manager and say watch the
first 15 minutes of this talk maybe
that'll help
so we've already had all the questions
that I wanted to ask so what remains I
just want to point out that the contract
on square-root you had it's really nice
contract because it says give me
something I will give you void there's
just a type on your slides oh you found
a typo yeah thank you for pointing that
out in front of everybody this is great
but how do we get there from here in
other words do you have any words of
wisdom of how to introduce these things
incrementally ah great question from
Rihanna how do we introduce these kinds
of things incrementally and actually the
last place that I worked we did this and
what we did is we started forming a
small core library that other things use
where we had these really high quality
standards and we slowly started to grow
it but we kept the quality of this core
library intact as we grew and this seems
to be a good way to do it because if you
just have a huge mess it can be
overwhelming but figure
out what's used by everybody whether
it's a shared pointer implementation or
whatever and start with that one thing
and make that really high quality that
build on it thanks a lot for wonderful
talk I love hearing more people talk
about all those things it occurs to me
that most of the things that we're
talking about here are pretty clearly
best practices and a lot of the argument
I think for convincing your management
can be at some point like best practices
like their best for a reason I know you
don't see it guys but if you go ask a
hundred developers they'll all say yeah
best practices so maybe we should best
practice management hey guys
but yeah send them to this talk some in
previous talks like is going to take the
you know culture five or ten years to
win this but we're getting there no
thanks dude
thanks Titus I love that best practices
are best practices for a reason David I
think you did a really good job at
explaining a lot of the the concepts
that I'm very very proud of you because
I I don't think I could have done nearly
as good a job as you did David's been
working at Bloomberg for less than a
month and he seems to have totally
embraced everything that we aspire to
but the reason I'm here is to tell you
that it isn't easy and it requires a lot
of fortitude at a lot of patience in
order to change a culture when I joined
Bloomberg in 2001 I can't even begin to
tell you what what I saw there we were
talking about people who didn't have a
computer science degree who were
anything but software engineers and had
made a lot of money for the firm and you
can't just tell them that they don't
know what they're doing you just can't
do that even if you believe it is not
true
they know what they're doing they're
making money for the firm of course five
years before I joined they realized the
technical debt that they had was so
great that they had to do something so
they they started it's almost like a
Christmas carol where we're a Scrooge's
partner you had this chain that was so
long but they could
fix it they just couldn't they didn't
have the ability to fix it so they gave
up five years later I joined and they
said basically can you help us and I
said well give it a shot now how many
people told me you can't win you cannot
win there's no way how many people have
come here and tried to win you can't win
but see I'm stubborn
so that was 15 years ago now it's an
entirely different thing and I want to
tell you that if you are slow and steady
if you show people you can't walk in and
tell people what to do I couldn't do
that but over time if you demonstrate
value and you do something and what
David said which is you start a project
on the side and you create something
that is pure and you say if you put
anything bad in that I will kill you and
you just stand by that and when no
matter what manager tells you you just
no you just say no just no knows the
answer no and there'll be many managers
to tell you to do some you say no now
you can't say no a lot of times you have
to choose your nose so nine out of ten
times you say yes do you want coffee yes
are you going to create a cyclic
dependency here no and then over time
this becomes software capital and then
when you say no you really mean no like
if you do that oh my goodness I'm going
postal so this is happening to me even
after 15 years but when I say no no
means no and it doesn't matter who asked
me to do it you know that's what you
have to do you have to establish
credibility and then no means no and so
that's the way it happens and building
something on the side that you have
authority over and you've demonstrated
value is how this happens and it takes
years and years and years but eventually
you can take this pile of goo you can
demote that's a keyword demote the
functionality to a lower level that's
stable and reasonable and and forward it
and then eventually this piece of Swiss
cheese will crumble and you'll have
what you want and you can build new
software off of this but it takes time
thanks John
one quick question so do test the code
you write for the unit testing do I test
the code that I write for unit testing
no because somebody else provided that
but hopefully is correct
okay so let's pretend I'm the manager
and basically I say all those seven
principles they sound nice
they sound smart but how do I know for
sure that they will work for my business
and how do I know I'm not going to spend
resources for writing unit tests and
infrastructure and whatever and it just
won't play out and I'm going to miss
deadlines and it not going to work for
my business so as as the the keynote
mentioned fear is the greatest motivator
I think that just give him some case
studies where they didn't do this and
where the business fell into flames and
successful organizations I look at look
at what happened with Gmail versus yahoo
mail you know Gmail came along had a new
interface and then yahoo mail tried to
come up and make something just as good
and what happened they weren't able to
get something just as good in time and
Gmail totally took the market yeah you
don't want that to happen to your
organization as do we know that gmail
succeeded and Yahoo failed due to Yahoo
not using distant principles in Gmail
well we know that this improves your
time to market so I don't really know
what else to tell you do you want to
talk about tests being untested and and
etherion philosophy there about the
tests being untested he was asking Oh
about half of your tests so I'm going to
say I don't know much about that topic
anyone that's interested let's all talk
later all right hi there how you doing I
would like to suggest some alternatives
if you're exasperated and you reach a
brick wall in trying to build software
capital these are some other things that
you can try I've done all these things I
know that they work so one is simply to
leave your current job so that makes all
the technical debt go away right away so
another possibility is to start your own
company and and then you get to dictate
the terms of the development that's a
really great option today especially
with all of the the social media tools
that are available like github and
things that you can do the community is
digital now a third possibility is to
join a startup that has a very small
number of programmers and you know
demonstrate your abilities and encourage
them to build software capital from the
beginning so you kind of head off the
debt before it has a chance to get
created those are three alternates
techniques thank you great thanks three
different ways to give up hi thank you
very much for that dog that was
fantastic I think a lot of these hinges
on good tooling I think you've mentioned
that and your infrastructure point is
basically that what's your suggestion
for if you're working in a company that
is averse to improving / changing their
tools I can think of many things with
for example continuous integration or
using a good good version control system
or you know other other tools that might
help to build software capital but the
company's just subversive change yeah so
generally companies that are reverse of
change don't change very much and that's
difficult to work with but I think you
have to keep coming back to the business
arguments as to why you know for the
long-term success and some companies
will not take this advice and they will
fall to the wayside and that's just all
there is to it all right thanks
Hey and the company I work in we have
something called a boy scout rule like
everybody every developer agrees upon
it's like when you come in and see a
piece of code you are asked to leave it
in a better state than you have found it
and I would like to hear your
you know this kind of stuff so that's an
interesting rule so I guess leave the
code in a state to where nobody can make
it into a better State that would be the
kind of rule that you know trying to
build software capital would be closer
to so we actually encountered this
scenario we we find a bug or the
customer reports it we fix it at the
request regression test for you so that
will it will not reoccur in the future
and then the client asks ok but how can
we guarantee that it will not reappear
the problem is there is a discrepancy
between what the client understands as a
bug and what we developers do so in our
case this particular bug was this
particular occurrence with on this
particular data with this particular
whatever circumstances and regression
test is for that maybe we try to
generalize a bit but what the client
sees is that ok the software crashed I
don't want to see crashes anymore how
can you guarantee that it's basically
impossible to answer with this unit
testing regression testing methodology
because we all know that there is no
such guarantee but what would you answer
in such a situation to the client to to
convince them that still the outcome
after this fix is a better quality
software and you should trust us that
this fix is worthwhile and worth to
include it in the next release so if
you're running a piece of software and
it crashes for your users they already
don't trust you very much yeah so the
best thing is to not let that happen
try to what write your really high
quality code so that they don't face
those crashes and if you do get those
kinds of issues then take them very
seriously and start rethinking you know
was this code reviewed was this code
unit tested like who's responsible for
this how did this happen and the answers
to those questions are how you can
improve your ability to create software
capital
alright this is the end of the session
thank you guys very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>