<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Herb Sutter “Meta: Thoughts on generative C++” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Herb Sutter “Meta: Thoughts on generative C++” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Herb Sutter “Meta: Thoughts on generative C++”</b></h2><h5 class="post__date">2017-09-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4AfRAVcThyA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Thank you, Don.
(audience applauding)
Just before we get started,
thank you very much to over 70 people
who responded to this challenge
before the Monday night cutoff.
That made it very hard to pick winners.
I could only pick two, so first of all,
many of you gave very
nice solutions, thank you.
And since I had to pick
two, let me describe
very briefly the exercise
and then show you the two
who have some wonderful
iPads that I'm told
run great Google search and
Microsoft Office as well.
(audience laughing)
The idea is I want to write a
case-insensitive string class.
It's a strawman example.
There are other ways you could do it.
But if I wanted this kind of type,
how many comparison operators
would I have to write
today in C++17, the latest
modern stuff we just shipped,
in order to provide comparisons
between CIString and CIString,
CIString char* C-cell strings.
And of course, that has to be symmetric.
And even the CIString,
CIString, I would like to be
symmetric because you want
conversions on both sides.
The answer is, yeah, 12 ought to do it.
No wait, 18 ought to do it.
And how many of you have
enjoyed writing code like this?
Sorry, how many of you have
written code like this?
Way more hands.
Only a couple of enjoyers.
So, thank you to, and can we invite up
Manuel Bergler and Ben Deane?
Can you give them a hand?
Please, wherever you
are, come on right up.
(audience clapping)
Manuel, I enjoyed that
you used string view
so you can actually take
more than const char*,
which was needed, and I liked
that you showed an if def
preferred way I'd do it in
production code for real,
but here's what you're
probably looking for.
I like that, both were
actually good answers.
And also, Ben, I picked
you before I realized
you were a fellow speaker, so oh well.
But that's okay, because
we prefer neither way.
And I liked that you also
had a very nice solution
that avoided extra conversion
operators allocations.
You didn't just convert to a
CIString and compare those.
And you referred to my paper
about this spaceship
operator to simplify this.
So that was really good,
that was a good awareness.
So thank you both of
you, enjoy your iPads.
(audience clapping)
And thank you again to
Stephens Capital Management
for providing those,
as well as other iPads,
for some of the other
questions in the contest
from the speakers this year.
Now this is actually
semi-related to the talk.
It has actually nothing to do technically
with the talk, but it has
a lot to do in principle.
So the reason I picked
this example was I have
a completely different
proposal that's currently
making its way through committee.
It builds on the work of many others,
including Bjarne Stroustrup
and others who have done
other proposals in the
area of comparisons,
Lawrence Crowl and many more.
And this proposal is
currently on its way through.
It's been approved by
the evolution groups,
and so it should go into wording review
and hopefully if nothing blows up,
it'll be in C++20 draft in
the next meeting or two.
The idea is, that we invent something
that other languages already have,
but the idea of the three-way
comparison operator.
Other languages have
the three-way comparison
spaceship operator 'cause
that what it looks like,
Darth Vader's TIE fighter,
but it's something that
even in C we've had,
strcmp does this, so
we've had cmp functions.
And if you're familiar with
PEARL, Python, some others,
they have similar things
under different names.
The idea, if this proposal is accepted,
is that instead of writing
those 18 functions, you write two.
Notice they are members,
they don't need to be
non-member friends to get
conversion and get symmetry.
You say, I want to compare
against another CIString,
by the way, that returns a weak ordering.
That means it's an ordering,
so I generate all six others,
not just equality/inequality.
And I actually have more information,
because it says what
kind of ordering it is,
which we do not have
expressed in code today.
Oh, and by the way, there's another one,
'cause I also want to compare
against C-style strings.
That could be even
better as a string view,
as several of you in your
solutions pointed out.
And it also returns a weak ordering.
And so the nice thing
about this, all I say is,
weak ordering, that means I generate six,
or in the second case, 12, the
the effect of 12 functions.
It doesn't actually
generate the functions,
it just makes those operators
available in your code,
and they get rewritten to calls
to the spaceship operator.
It's efficient, because in
the previous solution I showed
you might've noticed that a common thing
we do is we implement
four of the operators
in terms of equals and less than,
which is inefficient
because on the common,
if you do for instance, less than-equals,
in terms of less than or equals,
turns out you have to
traverse the common prefix,
the equals prefix twice,
depending on how you code,
and so that's undesirable.
This is guaranteed to be
single-pass, it's guaranteed
to be symmetric, documents
that there's a weak order.
And there's a lot less
boilerplate to write.
The idea is to allow people
to express intent directly.
So this has nothing to do with this talk.
And yes, it looks like it's a TIE fighter,
Vader's in particular, but I
choose the Falcon, so sue me.
It also kind of is that shape
if you squint just right.
But the reason this was a nice segue here
is because the rest of this talk,
especially the part about metaclasses
that'll give an overview of
related features first as well,
like the spaceship operator,
is about making C++ code simpler.
We're adding features to the language,
so the language is growing incrementally,
but C++ code should be simpler to write.
How? By letting programmers
state their intent
more directly, instead of circuitously.
Say things that in fact
we're already writing.
So we're not inventing new requirements.
These are things we are
already doing, it's just hard.
They do it by generating
things for you transparently.
So we're gonna have to have some way
of letting the programmer
see what's going on
when that's necessary,
for example, in debugging.
And that means tools are necessary
to make sure these features not only work
to write code once, but make
sure that code that you write
also continues to be easy to debug,
to maintain, as you release it over time.
So with that, let me switch
to the main topic for today,
which is thoughts on generative C++.
And again, the goal is to
make C++ more powerful,
which means we're adding capabilities,
but for C++ code to be simpler.
It is possible, if you do that right,
to actually simplify
the language additively,
which seems like an oxymoron,
but you do it by adding abstractions.
The way that I've gone
through this exercise,
so for the last two, two and
a half years in particular,
I've decided to focus on
spending the time I have
to write standards proposals
from the hundred things
we could write and add to the language,
specifically to things that
might simplify C++ code.
And that was a very general
and a very broad exercise.
And from that I'm now taking
some things and as appropriate,
one at a time bringing
them to the committee.
The spaceship operator was
a target of opportunity.
The committee was already
talking about that.
The design I had in my pocket
was already informed by
that discussion, Lawrence
Crowl and others.
And since, after rejecting it for C++17,
they continued to talk about it,
I said well fine, let's have
a proposal and do it right,
and see if that's something
that could get consensus.
And happily, it has,
building on other people's work as well.
But this whole exercise to
find out ways to simplify C++
has been driven by one thing
that helps to keep on course.
And I think it's important to have help,
at least I need help to stay on course
from all the wonderful gadgety features
that we could imagine, to ones
that really simplify code.
And the way that I've chosen to do it
is to look for people digging with spoons.
How many of you have written
template metaprograms?
On purpose?
Okay, that was just a joke.
(audience laughing)
How many of you like template metaprograms
because they let you
express important things,
but wish you could do it without
writing the template metaprogram?
Almost as many hands.
That's what the committee as a whole
is working toward, and
what this talk is about.
So if you find something
that people are already doing
with inadequate tools that
express things indirectly,
like, look, templates are Turing-complete.
I'll bet we can compute some stuff
at compile time with that.
And they're willing to
endure that much pain
to get that effect, that tells you
there's a market for shovels,
and it tells you that yes,
you are not inventing some new feature
that's taking C++ and turning
it into a different language,
taking it into a different direction.
This is something C++
programmers already do,
it's just hard.
And that's important
because it demonstrates
the market need, it also
demonstrates it really is C++.
It's what we are already doing.
So a good tool should make those things
easier and more things possible.
So we observe people digging
with the spoon of template
metaprogramming to compute
values and types at compile time.
So we've been adding constexpr functions
and we're doing much more
of that that I'll talk about
to have first-class
compile-time programming.
Express your intent more directly,
what you're already doing.
We observe that people are creating
interface definition
languages, side languages
and compilers that know
about things like properties
or about COM classes or CUTE classes.
And they do this because
they need to express
something that they can't
express in the language.
Is there a way to let them express that
in the language so you don't
need the side compilers,
you don't need the
non-portable extensions?
Again, something that
people are already doing,
usually multiple ways, multiple times,
can we bring that into C++ more directly?
Everything I'm gonna talk
about is under construction.
What we are gonna talk about
is always exciting stuff,
especially at the beginning
where you're liable to say,
oh great, can I use this in
my project in six months?
No, probably not, even the
earliest parts of this are early.
Reflection is one of the
earliest that is currently
actively undergoing wording review,
so that has a good
chance of being in C++20,
perhaps, we'll have to see.
But the rest is longer-term.
But look at this as an
arc of where we are going
that should reassure us that C++ is going
in a good direction that will help us.
And expect also that much of the syntax
I'm gonna show you is gonna change.
It's just strawman syntax.
Some of the concepts may get tweaked.
But let's see how far
we can go to replacing
some spoons with shovels in our language.
Most of the talk is going
to be on the bottom thing,
metaclasses, but I want to
take a few minutes first
to talk about the foundation
that's being built
and give you some references to papers
where you can find out more about that,
especially for Reflection,
compile-time programming, and Injection.
So let's focus on just that part for now.
As the foundational work
that is already in progress,
Reflection is at the most advanced
stage so far in committee.
The other two are still
being more incubated.
And then see what we can then do to build
on those things, assuming they exist.
So first, Reflection.
Thank you to many people,
but three of the main people
who've been working on this
for a long time, Matus Axel, David.
Several of you are here in the room.
Thank you to your companies, GlobalLogic,
CERN, Bloomberg, and the other companies
that send people to committee meetings,
help them write papers,
do implementations.
And you can find much of
what they've written here.
If you're looking for information,
here are, cherrypicking,
a few of the papers these
people recommend you read.
So thank you again for your
review on these slides as well.
But if you want to find out more,
thank you to all these people.
Let's give them a hand.
(audience applauding)
So really briefly, what's the idea?
The syntax may change, but think okay,
prefix $ to some expression, some type,
gives you a constpr value of meta::type.
So it might be a meta::function
or a meta::variable,
or a meta::type that represents a class.
So then you can iterate
over its member functions
and its data members, things like that.
Query things like their types,
their constants or parameters,
and in general ask for information
about the program that you can then query
and find out more about
and then do things with.
We don't currently have proposals,
we do have some early thinking,
but proposals to reflect on
statements and expressions.
So the bodies of functions.
But declarations are well along.
The idea is that we can
apply this reflection
in ordinary code, where it's
just another read-only value,
which the compiler may or may not need to
even bake into the object file
if it in-lines the results.
But you can't take its address,
because it may or may not
be in the object file,
that's why it's a PR
value, a pure temporary.
But in compile-time code it's
just an ordinary variable,
an ordinary temporary, and I'll discuss
compile-time code in a moment.
But there's the nutshell summary.
I'm gonna show the
bikeshedding thing only once,
but assume that this appears on every
single slide for the rest of the talk.
Syntax may change, it may
be prefix-$ expression.
There are lots of concerns about that,
including interaction with
existing code generation tools
that already stake a solid
claim on the dollar symbol.
So we may not want to
escape that all the time.
We may want reflexpr with angle brackets
or with round brackets.
We may want some underbars, who knows?
As long as I can spell
it some reasonable way,
I'm a happy camper.
For the purposes of
today, I'll use prefix-$.
Again, all of this is subject to change.
So what can I do with this?
Well, a very simple example is,
let's say I have an enumeration
and I just want to print,
iterate over all the enumerator values.
So you might want to say,
reflect on my enum type
and if that's a type that has,
in this case if we expose
those enumerators as variables
or the reflection might return
an actual enumerator's function,
then I just go through and
print each of their names.
And so this gives me the ability
to look at my type and then do something,
compute something based
on what that type is.
So I'm really getting a view
like a compiler into that type.
One of the nice things
about this, by the way,
is as soon as you show the
very first example like this,
and by the way, yes you can constrain
type name using concepts in C++20,
you can constrain that
to just enumerators,
things like that, so it only compiles
only available for enumerations.
But one of the nice things,
as soon as you do this,
is you get all the other
benefits that we have in C++.
For example, when are
templates instantiated?
When they're used.
We don't go stamp out a
million templates for all
the types you might decide
to write in the future.
Just the ones you ask for.
So when you ask for
print_strings of state,
if that is the only
instance of print_strings,
the use of print_strings in your program,
that is the only enumeration whose values
are stored in your object file,
or, in fact, an optimizer could
optimize that away and not store them.
But just store only the labels,
only the text, for example.
But all this work is done at compile time,
only in calling programs
that actually use it.
So I could shift theses four
lines as a header-only library
and in every translation unit for now
and in the future when it's used,
it would be instantiated
only for the enumerations
that program actually asks
about and only in that program,
which is nice and efficient.
This is dear to our hearts,
because what do we believe in
more than anything else in C++?
Don't pay for what you don't use.
This is that, and we just naturally get
to take advantage of those things.
So once we've looked at Reflection,
thanks again to those people,
and now let's move to compile-time
code that can use Reflection.
'Cause that's where you really start
to get the benefit of it.
And in particular, there
are many, many more
committee members I could thank,
but in particular, Daveed
Vandevoorde of EDG,
Louis Dionne at Amazon,
Antony Polukhin at Yandex,
I know at least Louis is in
the room, and many others.
Here are some of their papers.
Thank you to them and many more
for working on this and helping us
get what I'm about to
show on the next slides.
But let's give them a
round of applause as well.
This is hard work.
(audience applauding)
I'll tell you, these papers
do not write themselves.
And it takes a lot of
discipline, time, and expertise
to really follow through on a proposal.
So where are we today?
Well, thanks to, in
particular, Gaby Dos Reis,
who I believe is in the audience today,
we have constexpr in C++11, we
have more constexpr in C++14.
What, you want more than
one return statement?
Oh alright, you can do
that in 14, but not 11.
You wanted a loop?
Oh, you can do that now
where you couldn't before.
You want lambdas, you want &quot;if constexpr&quot;?
Well now other people get into the fray.
And so thank you to Gaby,
Faisal, and Ville in particular,
but also to many others, for getting us
more and more contexpr in the language.
So Ville in particular for &quot;if constexpr,&quot;
Faisal for generic lambdas
and for constexpr lambdas.
But would you like more?
- [Audience Together] Yes!
- Good, 'cause you're gonna get it
whether you really want it or not.
So thanks to some of those
same people, Antony, Daveed,
we're now looking at papers
post-C++17 to make virtually
all of the algorithms in the
standard library constexpr.
Think about what that means.
(audience applauding)
Why shouldn't I find if at compile time,
instead of writing my recursive
functional style template metaprogram?
Well then, if I have an
algorithm I want a container.
'Cause I can do all this
with arrays, excise arrays.
Wouldn't vector be nice, could
I have something vectorlike?
Well it turns out there
are proposals about that.
And the question is, how far can you go?
And earlier this year at C++Now
and 48 hours ago at this very conference,
the answer was, thanks to Ben
also, who just got and iPad.
It wasn't for that, but
thank you, Ben and Jason.
Well let's just make everything constexpr.
So we'll see how far down that road we go.
But we're seeing much, much more already.
What more can we do?
Right now when we have
constexpr functions,
they may run at compile time or may not.
And if we want to have
an actual piece of code
that is guaranteed to run at compile time,
that is one of the current
proposals I cited earlier.
The idea of a constexpr block
is the current thinking,
which I can put at statement scope,
so inside a function body.
I could put it class
scope, at namespace scope.
Now I start being able to write
imperative code in a lot more places.
But again, is this
something weird and not C++?
Am I turning C++ into Lisp?
Not that that would be a bad thing.
But actually it would be,
because the design goals are different.
No, again remember, this is letting us
write more directly the
things we are already writing.
And that helps us to
have that guiding star
to make sure, yeah,
we're not just doing some
weird other thing in a big
left turn or right turn.
This is still C++, just easier.
And &quot;C++, just easier&quot; is something
we can all get behind, I think.
So the idea of in my normal code,
I can have a constexpr block,
which means that IEs can highlight it
like this or I can see
it visually very clearly
in my code, where my
compile time code runs.
Helps me to distinguish it between
those two boxes on the left and right.
The normal code versus
the compile-time code.
Now the next question,
as soon as you say that,
and it's by these same people,
of course you're saying,
but wait, if I now have a
constexpr block of compile-time
code within normal code, what
if I want to go the other way?
I want to write normal code, generate it
from within a constexpr block.
How many of you were
already thinking that?
Yes, how many of you are
now thinking about it?
Yeah, so the idea here is, we
have an injection operator.
And the current proposal in PO633
and related papers is the arrow sign.
There might be some ambiguities there,
so a word like inject might be better.
Again, the syntax is all strawman.
But the idea is that I can now,
in my compile-time computation,
say okay, I now want to inject
a declaration into the surrounding code.
By default, into the enclosing
scope, or perhaps into
a certain nested outer class or namespace.
One place where this shows up
is in the very simple example we just saw,
where instead of printing
every enumerator value
of an enumeration, what
if we just want to print
the actual name in source code
of the enumerator at runtime
of a given enumerator value?
So then I can write a two string
function for an enumerator.
Again, I can constrain it with concepts.
And now notice that
there's a switch statement
inside which is a constexpr block,
which all it's doing
is for every variable,
inject a case statement.
So once the compile-time code
is run, what do you have?
Switch, case, case, case, case, case.
Could you have written that by hand?
Sure, I won't even ask
for the show of hands,
'cause I know many of you have.
Then what happens when
you add an enumerator?
Right, what happens when you
change an enumerator value?
It's hard to keep these things in sync,
because as soon as you
say something twice,
you will lie, an hour in the future.
We just can't help it.
Authors of fiction novels can't
even get the middle initial
of their main character straight
from page 52 to page 123.
We will lie, this will lie less.
Because it asks, what is the truth?
There's one source of truth,
which is the type system.
And man, if you gotta
pick a source of truth,
type system is the one you want to pick.
And then ask it, what is the truth
about, say, this enumerator?
And now I can use this with the
various enumerations I have.
And again, just like any other template,
we instantiate it only in the programs
that actually use it at compile-time,
and only for the enums
that are actually a query,
which is a nice feature to have.
Much better than just
injecting all enumerator names
and baking them into your XE just in case
they might be used, which
is what we resort to today.
Because it's hard to be more
precise about these things.
As soon as I talk about injection,
like this might have come up before,
but especially with injection, the concern
about injection is, but what
about being able to debug this?
What about being able to maintain it?
'Cause if we go back to
here, I just showed you
how to automate writing
all your case labels.
How many of you thought
that was pretty nice?
How many of you worried about
that you can't see that code?
Good, that's a healthy
reaction, almost as many hands.
You should worry about that,
just like in many other
places in the language,
even back to C, and any language
with abstractions already
hides information.
So let's see what we do about it,
because we'll do the same thing here.
So we already do things
that are less transparent.
There's two arguments to be made here
as to why we should just
go forward and pursue
this direction, even though
there is a transparency issue.
The first thing is, remember,
you're gonna get sick and
tired of me saying this,
but it's so important, we
are already doing this.
This is making code easier
to write that we are already
doing in nasty ways, like
template metaprogramming.
And even if this is hard to debug,
it will be less bad than
the things we are doing now.
How many of you have debugged
template metaprograms?
How many of you, by the way, just curious,
how many of you of you are
in shops that do not allow
non-library use of template
metaprograms in production code?
Besides something you
got, like from Boost,
they just don't allow you to write
template metaprograms in production code.
A few, well because of debug ability,
maintain ability, those kinds of things.
So it will be at least less bad,
even if we do nothing in tools.
But we already have cases like this.
For instance, the
compiler-generated functions.
Let's say you have a class
type with 10 members,
but I want to use compiler-generated
destructor assignment copy.
How many of you have already
wished you could step into
the debugger and see what was
going on in each of those?
How many of you of you actually
have a tool that does that?
Much smaller number, they exist.
But yours, I know is your
own research project.
So yes, exactly, Peter.
You have so few hands
that I can actually see
individual faces to see
what tools they're using.
So we already have this problem, and yet
nobody is burned or bent out
of shape, saying we shouldn't
have special member
functions, they're too scary.
We like them, they're convenient.
We could still have better
tooling than we even have today.
So let me just take a
moment, before we switch
to metaclasses for the rest of the talk,
to just talk about this general principle.
Because I think it's worth it.
I added these slides last night,
because this has already
come up multiple times
in the last two days at this conference,
including at the panel that
we had on Monday night,
in hallway discussions, and so
let me just address one thing
that I think is important to
remember when we talk about
language abstractions
and especially tooling.
By definition, abstractions are hiders.
They hide stuff, it's what they're for.
If they didn't do that,
they would be useless.
They would not have the
value that they have.
So it's not a problem, it's the point.
Now having said that, you
could use this to gloss over
many things that should
never be put into languages.
I'll talk about that a little at the end.
But abstractions are good.
We cannot build our civilization
without abstraction.
We are so deep in the layers
of software that we write,
we could never have scaled
to what we have today
without lots and lots of abstractions.
And where C++ shines is it makes
those abstraction layers
thinner, more efficient,
which is why C++ will
always have a future.
'Cause we'll always be building
bigger and deeper things.
Where thinness of the layer
matters, that's where we shine.
But let's just go back to the '70s.
Abstractions have always
needed tool support.
So variables hide their values.
So in a tool, yes, you can
do print-F-style debugging.
Then you're just writing your own tool.
But any IDE will give you a watch window.
Any debugger will give you a watch window
so you can see the value.
Why did you need that,
because the variable X
nicely abstracts away its current value.
So you can just talk about
the value in the abstract,
which is wonderful, we've been
doing this since the '50s.
It's really important, but
even that is an abstraction.
A function hides code.
Notice the word &quot;hide&quot;
appears all over the place.
Now that's okay, we
just want to think about
the document and semantics
and not worry about the how.
It does the work.
But sometimes you want to step into,
especially when you're debugging
your own functions in a cascade.
So you need Go To Definition,
you need Step Into in your debugger.
Pointers hide indirections.
You need visualizers that let you see
what the data structure
actually looks like.
Include hides dependencies,
because include files
can include other files.
So build systems need to be aware of that.
That's the first thing.
The second thing is, they need to see
when the file timestamp
has been updated, usually,
unless you're in a database
repo or something like that,
so that they can say, ah,
this changed and therefore,
based on the dependency graph I will go
and build all these other things.
But we're not scared of these things.
We'd like to do better at some
of them, like include files.
But we're not scared of
them, they're very useful,
even though they do require build support.
C++ has been very successful,
even in its early years, for classes.
Guess what, they hide code and
data, it's the whole point.
We have built a whole
generation of software tools
on classes, in many languages.
Because it's good they abstract behavior.
They encapsulate behavior,
which means they hide code
and data, which means you need most of
what we just talked about in your tools.
Overloads hide static polymorphism.
I could've said templates,
but we always go for that one.
Let's say overloads 'cause that's another
form people often think about.
That means we need better
warning and error messages.
If you've had compilers early on
that didn't have them, you know.
Because you want to know,
oh, I couldn't call this,
but here were the candidates.
That's important to know.
Virtual functions, they
hide dynamic polymorphism.
Again, a different kind of tool support.
So that's C++ up to
about 17, 18 years ago.
In C++17, I could mention
a few more things,
but along the way we've
added more constexpr.
Constexpr functions hide computations
that can be done at compile time.
So with constexpr functions today,
because they could be
compile-time or runtime,
you could fake it out by
executing them as if at runtime.
But you basically are
starting to see a need
for compile-time debug support.
Why, 'cause that's where
you're running your code.
If constexpr, more of that.
We hide whether code even has to compile.
So just like you have your macro ND bug,
and your IDE often grays out the code
that isn't actually being built,
which is actually a useful thing to see,
I would expect tools to do the
same thing with if constexpr.
Because whatever appears in there
isn't gonna be compiled in
an if constexpr false block.
So again, we need tool support.
I'm spending so much
time, three, four minutes,
talking about this because
this is not a new problem.
And it's important to emphasize
it's not a new problem.
So that, oh darn, I've run
out of space, let's fix that.
If we now go into the future, modules.
I have heard, even at this conference,
some angsting about, well, modules,
are they fundamentally different?
Are they gonna need build system support?
Sure, half of that build system support
is what we already have to
know when a file is touched.
Yeah, we do that with headers.
We can see when a compiled
module has been touched.
Yes, we need to look inside modules
to see which modules this
module transitively uses,
which is not that different
from what we do for headers as well.
Does the build system
need to be aware of it?
Absolutely.
But notice again, like the header,
the module, in a better
way, is an abstraction.
It hides stuff, this is
the point of modules.
It bundles stuff up, it doesn't
mean you can't look at it.
You can go in and look at it.
But it gives you an abstraction.
And so we need tool support for that.
This is not surprising.
Compile-time variables,
compile-time functions.
Just like regular variables and functions,
we need tool support for those,
but they need to be able
to run at compile-time.
And when we talk about injection,
this brings us all the way
back to our previous slide,
when we talk about
injection and metaclasses,
which depend on compile-time computation
and injection, we are generating stuff.
So we need to visualize that.
And I'll show an example as we go.
Remember the thing at the very top?
Don't lose sight of the
title of this slide.
Abstractions are hiders.
This is a feature, not a bug.
It's the point.
And it does mean they need tool support.
Now I promise, at the end of
the slide, to make one caveat.
Good abstractions also
need to be toolable.
This is a two-way contract.
Please do not use everything I just said
to justify some awful
language's feature design
that is not a cohesive
abstraction, that is undisciplined,
and say, yeah, tools
should just make it better.
Like for instance, with if constexpr,
the standards committee was
very careful to make sure
that you couldn't just
generate arbitrary source text.
Like oh, let's generate
half a class and then stop,
or generate the backend of a class,
close the current class, open another one,
and do something else in a
single if constexpr block.
That's not scoped, it's not nested.
So it was very careful to make sure
that an if constexpr block was a scope.
And we had very clear
rules about the scope.
Guess what, that makes it more toolable.
So please do not use the oh,
yeah you're gonna have to write
tools anyway, it's those lazy
toolwriters, it's their job.
Don't use that as an excuse
for a bad language feature.
A good abstraction however,
does have a responsiblity
to also answer, is this
gonna be write-only code
or is it gonna be code I
can debug and maintain.
So it has to be toolable.
And then we can reasonably say, okay,
let's make sure we build
the tools for that.
And the closer we can show
how it's similar to things
we were already doing
in tools, the better.
So having said that, let's now move
to the back part of the talk,
where I'm going to assume
all of those things exist.
And the question that I was interested in,
and the piece of my
broader simplifying C++
exploration that I'm
bringing forward here,
is how can we get rid of
things like compile-time
code by tools that
weren't designed for it,
like template metaprogramming.
Just because they happen
to be Turing-complete
doesn't mean you have
to Turing-complete them.
And how can we use that
to make C++ code simpler.
Again, focusing on things we
already are doing, just harder.
So the idea of metaclasses is
covered in my paper, PO707.
Many reviewers, thank you to them.
And a special thanks to Andrew Sutton.
Where are you, Andrew,
can you yell or wave?
Yo, in the back, thank you, Andrew.
Because besides being
Mr. Concepts Implementer,
having written the concepts
implementation in GCC,
he is now actively doing the metaclasses
implementation in Clang.
So thank you very much to all
the reviewers and to Andrew
for all their help on
everything I'm about to present.
(audience applauding)
I'll give you links at the
end to a couple of talks
Andrew's giving about the
implementation details.
They're not so much about the use,
but about the implementation details,
this afternoon and tomorrow morning.
Look for those in your schedule too,
if you care about the implementation
detail side of things.
I know there are a lot of
Clang hackers in the room,
so you'll find that interesting.
But the most important
shoutout I want to give
is to somebody who I think
is not currently in the room
because he had to take a flight right now.
But I want to especially
acknowledge Bjarne Stroustrup.
Nothing I am about to
tell you would be possible
if he had not held the line
in a principled, strong way
on a unified type system in C++.
Let me talk about that for a second.
So here's a movie that's
playing everywhere in theaters.
Okay, it's not actually.
I'm not gonna talk about
James and the Giant Peach.
I'm gonna talk about Bjarne
and the unified universe.
Because when we take a
look at the whole universe
of all these C++ types
that we can express.
There are so many.
We talk about value
types, they're the ones
that are favored by
default, with the special
member functions that get
generated by the language.
But we have plain old data structs.
They're blessed with a
name in the standard,
although you can't actually quite see them
in source code as clearly.
But people write COM classes,
they write functors, callable types.
A very different thing, but
it's still just a class.
A single inheritance base
class obeys different rules.
We write down what the
rules are in English,
but it's just a class.
C++ does not have a separate
interface concept for that.
We write expressions
templates, properties,
CORBA interfaces, any variant.
So sum types, product types.
It is fundamentally a strength of C++
that every single one of these
can be expressed as a class.
That we have not
bifurcated the type system.
And nothing I'm about to say
would be possible without that.
The trouble is that right now
we're writing all of these
things and much more, but
we're doing it by convention.
So some of these are documented
in the core guidelines as to how
you should write them or
SCOTS or MyBooks or others.
And we describe them in
English instead of as code.
Can we do better?
So the goal of metaclasses in
a nutshell, is to give a name.
A name is a word of
power if it's compilable.
To give a name to a specific
subset of the universe
of classes that have
common characteristics.
What common characteristics?
I want to express those
using compile-time code,
all the stuff we just had
a very brief overview of a moment ago.
And the goal is to make
classes easier to write.
'Cause I don't have to
remember English rules.
I don't have to override
the universal defaults
for what gets generated for me
to make them appropriate
for my kind of class.
In fact, every single
metaclass that we should write,
and this is important,
especially to committee
members who worry about opt-in.
We often talk about new features
and oh, can we make them
retroactive to old code?
No, we want people to opt in
so they know what they're getting.
Every metaclass you write is a single word
that is a bundle of opt-ins.
That is a powerful thing to be able
to write and customize yourself.
Because you are saying I want this.
And now a lot of the stress and anxiety
about providing useful things by default,
but what if they weren't needed,
melts away because the user asks for it.
So a very important contribution,
I hope, of metaclasses,
is to have a generalized
way of writing an opt-in
to say, I want this.
And you know what, once
you say you want it,
then we can go wild and help you.
It's about helping the
developer express intent.
Let's see the nutshell example.
I want to write a metaclass
as a very, very simple thing.
This is the current
vision, we're trying it
and evolving it and I'm
sure it's going to mature.
And especially with feedback
from the committee who saw this
for the first time a couple
of months ago in July.
And we're gonna continue to improve this.
This is a multi-year effort.
No, it's not in C++20, my goodness.
No, this is incubating still.
It's not a first proposal
to get to evolution yet.
It's incubating, but
I hope it's promising.
So everything may change,
but the current idea is
it's a custom transformation
from the source code
you write to an ordinary class definition.
And let me explain what I mean by that.
Because we already have it,
except I can't write it myself.
I have to be a compiler writer today
or a standards proposal writer.
In the language today, I
write &quot;class Point int x, y&quot;
or I write &quot;struct MyClass : Base void f&quot;
I have all sorts of
language rules that apply.
Class Point automatically
gets X and Y be private.
So I didn't write an access specifier,
but I get one as if I had written it.
We know these are the rules.
Oh, by the way, I didn't say anything
that would prevent generating
the special member function,
so I get a default
constructor, a destructor,
a copy constructor, a
copy assignment operator,
a move constructor, a move
assignment operator, for free.
This is great, unless
you didn't want them.
But here I do, so it's great.
And it's done for me, I didn't
have to write all that stuff.
This is a feature, not a bug.
With my class I inherit
publicly by default
from the base because I said &quot;struct.&quot;
And notice that the function
f is virtual if it happens
to have a signature, the same
signature virtual in the base.
So I didn't write virtual
here, but I implicitly get
virtual because I inherited
it from the base class.
Like or hate that
feature, it can be useful,
and it is something the
language already does for us.
So when you think of this,
here's what I wrote in source
and here's the actual
definition of the type.
You can think of it as if the compiler
executed this italicized
pseudocode for each member.
If there's no access specifier
then oh, if they said
&quot;class,&quot; make it private.
Otherwise if they said
&quot;struct,&quot; make it public.
Oh by the way, for every function,
if it's virtual in the base class
and it's not defined as virtual
here, then make it virtual.
If it's not virtual in the base class,
but they said &quot;override&quot;
here, then emit an error.
You wrote a function that
says override, but it does not
actually override a function
in the base class, and so on.
All of these rules in the middle
are already things we use every day.
They're in the standard,
they're in compilers.
Today they are written standardese
and they are implemented
by compiler writers.
I like standardese, but only a few dozen
people in the world can write it.
I'm not always one of them.
I rely on people like Jens and Richard.
So do most of the committee,
for core wording standardese.
I like compiler writers.
But there are only a few
hundred of them in the world.
What I would like to do is to be able
to have more people, in a disciplined way,
not in a free-range, all rules are off,
Wild West way, but in a disciplined way,
be able to write just that
code and give it a name.
So is it true that C++'s
defaults are all wrong?
People say this sometimes,
and they're right
when they're writing a kind
of class that wasn't intended
as the common case when
we picked the default.
So really, the main
problem with C++'s defaults
in many cases is that,
especially the class-based ones
that I just described in the middle there,
is it's one size fits all.
The class, like every single class,
has this same set of rules and defaults,
even if it's functor or a COM base class,
or a plain old data struct.
I couldn't say those things,
and that means I have to
=default or =delete the things
that did or didn't get generated
that I actually wanted,
when the single heuristic
for the whole universe
of classes guessed wrong.
So if you can only pick one rule
for everyone in a diverse universe,
it's gonna be wrong a lot of the time.
That's why we have =default, =delete,
for the purposes of opting in and out.
So instead, the key question is,
what if you could write your own code here
and give a name to a group
of defaults and behaviors?
And people have sometimes said oh,
what kind of code is
this, it's so strange.
It's code, put it in the
library, put it in a namespace.
Do all the things we already do with code.
Share it on GitHub and compile
it with somebody else's
compiler that supports
this language feature.
That's the intention.
Again, I want to be clear about
what we are proposing and
what we aren't proposing.
Only participating in
interpreting the source code
definition that you wrote
and what gets generated
as the definition, the one
definition of the type.
We are not trying to make
this a mutable language.
That would be madness,
or at least if it's not,
I don't want to explore and
I'm not interested in going
there and seeing whether it's
really as crazy as it looks.
I could get what I want without that.
So I'm not interested in exploring that.
I am also supremely uninterested
in violating the ODR.
The One Definition Rule is great.
C++ benefits strongly from it.
Bjarne was very wise to insist
on that from the early days of C++.
Now it is paying off in
spades with new features
like modules that really rely
on the One Definition Rule.
So when we generate
something, it's just a class.
What we generated from is
just the normal C++ grammar,
except that instead of the word &quot;class,&quot;
I could put in something more specific.
That's the only grammar change.
Other than that, I want to
leave the language alone
and let it evolve orthogonally.
So give a name to a group of related
classes that have common behavior.
Give it a single hook,
that is a translation
customization from source to definition.
And I hope that this
can replace many uses,
along with the other features that we saw,
of template metaprogramming, macros,
and nonportable language extensions.
It's not an open grammar,
not a way to violate the ODR,
and it is not specific
to object orientation
or virtual functions, even though
that's the first example I'll show.
Most of the examples I already cited
have nothing to do with OO.
But C++ does do OO and this is C++.
So you can use it for that too.
So the current idea is that I can write,
instead of a class, a $class.
That's the current syntax for metaclass.
And it contains the rules, as a constexpr
block of compile-time code,
of the things to apply
to whatever the source
code was that I wrote.
And then I can apply it in
the place of the word &quot;class,&quot;
to say &quot;interface Shape,&quot; for example,
instead of &quot;class Shape.&quot;
And if my $class interface
had all the rules
to require that functions
be public and virtual,
make them that way by default,
make sure there's no data,
then when I say &quot;interface
Shape&quot; I am opting in.
See, there's that big red opt-in button
that says I want all of that.
And all I had to write was one word.
That's convenient.
It's important opt-in be explicit,
but we also want to make it convenient.
The best way you can do
that is to get people
a way to write a customized opt-in.
And then if I say &quot;interface Shape,&quot;
then I get those defaults.
My functions are public
and virtual by default,
I can't write anything other than that.
And the typical things that
metaclasses are used for
in our experiments so far
have been to enforce rules,
to provide defaults, and to
provide generated functions.
Many of the things already done
in the language with
just the word &quot;class.&quot;
So here's an example of
how we write code today
and how I would like to be
able to write it in the future.
Today we write interfaces just fine.
We call them abstract base classes, ABCs.
They even have a cutesy name.
'Cause notice, we're
trying to give them a name,
even though I can't say
the name in code yet today.
The name reminds us of the
pattern we learned as English,
and that maybe a linter will help us with.
But I just remember, I make
every single function public.
I write &quot;virtual,&quot; I write &quot;=0.&quot;
I have virtual destructor,
let's make it noexcept while we're at it.
And then I am very careful
not to write a data member,
a nonpublic function,
a non-virtual function.
And I have to make sure
that my future self
who's maintaining this, or
their successor, keeps the rule.
So today, what happens
if, under maintenance,
I accidentally added a data
member on the left-hand side?
Code compiles and runs, it's
not what I wanted though.
It may mess with the size
and alignment of things
in a way I hadn't expected, or
it may just violate the fact
if I have non-virtual function,
that may violate semantics.
But I don't have a way to write that,
unless I want to resort to
writing lots of static asserts,
and nobody does that with Reflection.
The proposed way is to
write &quot;interface Shape&quot;
and then write your functions.
Notice I did not write public,
because it's public by default.
I did not write virtual,
because it's virtual by default.
And I can enforce that I didn't write
any data members, copy,
move, that kind of thing.
Here is how it looks in code.
And again, standard disclaimer,
this is strawman syntax.
So my &quot;$class interface&quot;
first declares the destructor,
and then has this constexpr
block I just showed you before.
So it's building on these
other proposals that we hope
to get anyway, and says,
well how can I use them?
Now I want to write compile-time code,
which requires that reflect on interface,
or reflect on myself is the
current syntax for that,
that I have no data
members, variables is empty.
Otherwise I will emit
a compile-time error,
which can be integrated
with the compiler's
native error handling and
controlled by the same switches.
You are writing a compiler extension here.
Interfaces may not contain data members.
For every function, require
that it's not copy or move,
otherwise say, interfaces
may not copy or move.
Consider a virtual clone.
You could be creative,
this is a good thing.
If it doesn't have an access
specifier, make it public.
And then require that it's
public and make it pure virtual.
So then when I say &quot;interface Shape,&quot;
that metaprogram runs on
the things that I wrote,
the declarations in the scope
of Shape, that's the idea.
One of the nice things,
I think, about this,
is I didn't write any standardese.
No standardese was harmed,
no core wording was harmed,
in the making of this code,
once we have the feature.
I can write this and put it in GitHub
and have you try it out
and debug it for me.
I can use debugging tools, I
can write unit tests for this,
which I cannot write for standardese.
I can do this on my own on a weekend
much faster than writing a paper
and going to a committee meeting
and then trying to get
it through evolution
and core and then wait for my compiler
to implement it, years later.
And my claim, my hope, but I'll say claim
because I believe I have evidence
that this is going to pan out,
is that it is without loss
of usability, expressiveness,
error message quality, or performance,
even compared to other languages
that build the feature
in as first-class entity.
Now that's rainbows and pixie dust.
That's the Holy Grail,
if we could do that.
I have some reason to
think we can achieve that.
So if we compare to the C# language,
here is how the interface concept
is implemented in the
current C# specification.
That's actually a zoomed-out
version of the C# specification.
It's about 18 pages of
English, so standardese for us.
The proposed is on the right-hand side,
which is about 10 lines
of unit-testable code
that I can ship on GitHub in
a library in proposed C++.
That's already some benefit.
But what about the use case?
So in C# and Java I can write
&quot;interface Shape int area()
&quot;void scale_by(double factor)&quot;
The proposal, as I'm showing it here,
has exactly all of that,
except this is C++,
so you have to write a semicolon
at the end, at the class.
It's okay, we can get over the semicolon.
Oh and by the way, you can
write things like const,
which you can't write, at least not with
the same meaning in other languages.
So you get to use whatever C++'s
rich language features are already.
And let me just show the
difference in philosophy,
because in Java and C#, the idea is,
we bake something in
as a language feature.
That way it gets first-class support,
it's gonna be efficient.
And we do that with interface,
we do that with lock,
which are synchronized in
Java, which is a language
feature that lets you do local locking.
But that's not who we are as
C++ users and language authors.
We want to write general things,
such as lock_guard in the bottom right,
where I could have almost
the same convenient syntax.
Notice this is C++17,
I didn't even have to
write &quot;lock_guard &amp;lt;newtext&amp;gt;.&quot;
I can get just about the same convenience.
But the right-hand side is just as usable
and it's more flexible,
because you can't do
timed locks on the left-hand side.
You can, and if it wasn't in the standard,
you could easily write your own type
to do a timed lock with
backoff on the right-hand side,
and get the same usability
and the same experience.
Because we're library writers.
We have a language that is arguably
the best in the world
for writing libraries.
And we want to make
that even more powerful.
So let me just demonstrate
that real quick.
Here is C#, is that
alright if I show some C#?
Okay, nervous laughter.
(audience laughing)
Ah, better laughter, that
sounded more relaxed.
So here I have interface Shape
and I can write this in C# today.
And if I say, for instance,
oh, let's say I make that private.
Notice I get a red squiggle.
And so it says, &quot;int Shape.area()
the modifier 'private'
&quot;is not valid for this item.&quot;
Okay, I can't have a private method in C#.
What if I added a data member?
Oh, it doesn't like that either.
If I hover over it says,
&quot;interfaces cannot contain fields.&quot;
Which is C#ese for
non-static data members.
The word &quot;fields&quot; might
be better, but hey,
we've doubled down on
non-static data members.
Non-static data members it is.
They can have fields.
Now what I'd like to be able
to do in C++ is write something
very much like what I
just showed on the screen.
So here is basically the same
thing I showed on the screen.
In this version of the prototype compiler,
there's still a &quot;...&quot; on the for.
That's gonna go away as
this goes through committee
and we follow the
guidance of the committee.
Other than that, I think it's the same
as what I just showed you.
And also, there's a
way that you can debug.
You can actually output
what gets generated.
Now I'm asking for something
that doesn't exist yet,
so let me just, I love
this part, pardon me,
cut and paste C# into
C++, because of course,
that's a thing we always
are able to do today, right?
And then you'll notice,
oh, it doesn't compile.
Why, somebody already noticed.
- [Audience Member] Semicolon.
- This is C++ so we gotta
write that semicolon.
And then it compiles.
(audience applauding)
And compiler debug shows you,
in this case, what it generated.
So if you were doing
this in the command line,
you could have that print out.
Notice that debug statement is running
at compile time in this constexpr block.
And you can see what it generated.
This is important 'cause if you remember
nothing else from this talk, remember that
these things need to be toolable.
Right there in the bottom-right
of that demo, is the thing
the tools need to build,
so you can step into.
That's it right there,
his is not just demoware.
There's a reason I put
this demo in the talk,
just to show you, look,
we can see what we got.
But that's also the first
step of toolability,
is to be able to see what we've got,
and then IDEs can build from there.
But we already have that today.
So thank you again, Andrew,
for doing this implementation so far.
And we continue to make
more of the examples
in the paper work, only a few do so far.
But remember I said, with equal
efficiency compared to other
languages that do this as a
built-in language feature.
Well, this is all at compile time,
so the runtime efficiency is the same.
I just built a C++ class,
same as any other C++ class.
I just wrote it more conveniently.
But what about diagnostic quality, I said.
Well, let's try some of these same things.
Let's try &quot;int oi,&quot; because
I have keyboard bounce.
&quot;Error: interfaces may
not contain data members.&quot;
Okay, let's compare that to
C#, where if I had written,
what was the, oh let's do
the same, let's say &quot;oi.&quot;
Do the same, &quot;interfaces
cannot contain fields.&quot;
Yeah, that's a wash.
I'll say we have equal diagnostics here.
Fields might be just a little
shorter name, but just saying.
But now, what if I wrote in C#,
what if I made this private,
I have a private method.
And then I see, &quot;The modifier 'private'
&quot;is not valid for this item.&quot;
What's an item?
This is the kind of generic
error message that you get,
or partway generic, when
you're a compiler writer
who has to write just a general
error message framework.
It's not specific to a particular thing,
although it could be in this case,
'cause interface is
baked into the language.
But it's just using a general thing
saying, can't use this
modifier in this context.
So to save space, they're
reusing an error message.
So private is specific,
this item is generic.
So it's a halfway generic error message.
Whereas here, what's
the natural thing I get
when I write &quot;private?&quot;
I get, &quot;error: interface
functions must be public.&quot;
Now why this is important,
it's not only that I can
get better diagnostics,
but the example I just showed you,
'cause C# could easily
have done the same thing.
The Visual Studio folks looking
at this on YouTube will say,
oh yeah, we can make that better.
Check it in in the next
version of open.net
or whatever has the fix and
has an equal error message.
But this is what you get by default
for language baked-in features,
because compiler writers by default
write very general,
grammar-based diagnostics.
This is a grammar-based diagnostic.
When we write diagnostics
with metaclasses,
we are thinking about the
metaclass that we are writing.
We naturally write this,
because it's what we're thinking.
It's the rule we're implementing as we go.
So I think that not
only am I hopeful that,
as I claimed here, that we
have the same usability,
expressiveness, and even
diagnostics as other languages
that build many of these things in
as direct compiler-supported,
plumbed-in features,
I think that not only can you get parity,
but just naturally, you
get better diagnostics.
Because you are already thinking
specifically about the thing
that you are authoring now,
the abstraction that I am having here.
So that's one example.
Here's another example, a
value type, a regular type.
Then we can argue over a
beer whether regular types
include comparison operators or not.
Let's embrace them for this slide.
Today in C++17, I write a bunch of stuff
and I have to reinstate
my default constructor.
Notice that very first red line.
Why do I have to reinstate
it as &quot;= default?&quot;
I see that, in the front
row it's like, ugh, yeah.
Right, because it was suppressed by who?
By &quot;Point(int, int).&quot;
You wrote a constructor so we
didn't give you a default one.
You can always reinstate
it with &quot;= default.&quot;
That's what we teach people today.
It's true, it works.
And I have to write my comparisons.
I make them friends because it's easier
than just declaring and then
defining them out of line.
But I want to just write them here.
And this way I get conversions
on both sides as well,
if Point is convertible
too, from some other type.
And I write my comparisons.
The proposal is though, I
can just be able to write
a value metaclass that does those things.
And I'll show it on the next slides.
Value Point would say, oh, data members,
those are private by default.
'Cause that's what we
tell people to do anyway.
So let's use the opportunity.
Make data members private by default.
Functions public by default.
Oh, and a value always
has a default constructor,
'cause that's part of
being a regular type.
So I don't need to reinstate it.
So on the left-hand side I had to write,
&quot;Point() = default;&quot; to reinstate it.
That's an opt-in.
It would be tempting but wrong to say that
the opt-in evaporates
on the right-hand side.
No, the opt-in is folded
into the word &quot;value.&quot;
And that value is the name opt-in
for yes, I do want a default constructor,
as it is for yes, I want
the comparison functions.
And yes, I want copy
construction, copy assignment,
move construction, move assignment,
and a non-virtual destructor,
which I can enforce
for a value and I can't get it
wrong even under maintenance.
Now what if under maintenance
I write &quot;value Point&quot;
and today I require that it can't have
a virtual function or
a virtual destructor,
'cause that's not what values are.
You don't want to slice
them and you would only use
virtual if you're doing
something like that,
or protected, have a protected member.
What if under maintenance
I did want to add that?
Well if I did it by accident,
as soon as I write in,
I maintain the right-hand side
and I add a virtual function
or a protected member,
I would get an error.
That doesn't mean I can't do it,
it just means I can't do it silently.
I can write a protected
function or a virtual function
on Point, but to do it
I will have to change
its category from value to something else.
And this is nothing but goodness,
because it means I can't do it silently
by default, make the mistake,
but if i really meant to do
it, I can say it clearly,
concisely, and explicitly,
without a lot of boilerplate.
So having a single word of
power to opt in to a group
of defaults is, I think,
really, really, important.
And it all comes down to letting
the programmer express intent.
Yes, I just started this
talk by mentioning PO515,
the spaceship operator.
Even with the spaceship operator,
so C++17 plus that proposal,
would be even shorter.
But you still have the opt-in
for the default constructor and so forth.
So I still think, even
with that, there's value
in the spaceship operator
that is orthogonal.
And metaclasses give you further value
on top of it, that's again, independent.
Here's what the implementation
would look like.
I won't go through it in
detail, but you'll notice
that at the top, you get
all your basic functions.
And we can actually go through.
We require that they be defaulted.
You could actually write
code that just tests for them
and injects them if they're not there.
Then in the constexpr block we make sure
that all the variables, if don't have
an access specifier, are made private.
And for every function,
if there's no access
specifier, it's public.
And we make sure it's not
protected virtual or a destructor
with a nice, high-quality error message.
And then we compose metaclass value.
It is a basic value,
which has all those things, and ordered,
which I'm not showing, but
it's the one that generates
you the comparison functions today.
And again, with spaceship
operator you would just use
the spaceship operator inside ordered.
And then I can write value
Point as shown before.
And I can write code that does equality.
That works, it's fine.
I can write set of point,
which requires less-than, and it works.
And all I wrote was
&quot;value Point(int, int)&quot;
and a constructor.
And I've opted in to all of that power.
Now here's another thing we do in C++17.
For those of you who can't
read in the front row,
it's class pair.
It is, I believe from the
current working draft,
or maybe a couple of working drafts old.
The definition of class pair,
because pair is such a simple class.
It couldn't possibly be hard to write.
So what kind of class is pair?
What can I or can't I do with it?
Read the code, read CPP reference.
I would very much like
to be able to write,
&quot;literal_value pair T1 first; T2 second;&quot;
I'm not showing the code for that.
The code for literal_value
is the one example
I use that I don't show
the code in the paper.
But presumably by now you
can see, ah, already have
an inkling, here's how
I would write that code.
Because I would want to
generate all the things
on the left-hand side, if
they're not written already.
This was actually a challenge that I put
to several C++ committee
members about five years ago
when we just kept on adding stuff to pair.
Turns out pair is really hard.
Marshall, are you in
the audience somewhere?
Marshall, am I roughly quoting
you correctly when I said that?
Was it pair or was it variant
that's right at the edge
of what we know how to do?
Oh, it was tuple, okay,
which is more like pair.
Excellent.
Yes, so the answer was yes.
And if hearing that from
one of the main authors
of the Clang standard library
implementation worries you,
we understand that we want
to make these things easier.
Simple things should be
simple, as Bjarne rightly says.
This is simple, we should
be able to make it simple
and write literal value that we can reuse
for pair and for tuple,
and define pair and tuple in this way.
This is the only proposal
I've seen that would let me
actually write pair as
&quot;T1 first; T2 second;&quot;
I think this is a very good
litmus test, at least for me,
a litmus test on A, are
we on the right track?
'Cause here's an example of stuff
we're doing today, even though it's hard.
And we'd like to do it more directly.
This is a poster child example of stuff
we need to do today, and
we're digging with a spoon.
Can we find the right kind of shovel
that can make this clearer to do?
Here's another example, enums.
Enums are baked into the language.
Imagine that we had a
basic enum metaclass,
again, I'm following the standard
library convention for
extracting common stuff
into a basic underscore-prefixed type.
And notice, it is a value.
The strawman syntax is
inheritance-like syntax,
maybe something else is better.
But the idea is, run the
metaclass value and then run this,
because this is a more
specific form of a value.
So value already gives
it copy constructors
and no virtual functions
and those kinds of things.
And what we're gonna say is basic enum
is a type that first
of all, can't be empty.
So we require that the number of variables
is greater than zero, that's data members.
We require that, here's
a cute little trick.
If you're wondering, data members,
but enums don't have data members.
No, but they sure are a lot like a class
that has nothing but public
constexpr data members.
The enumerators.
So if you think of enumerators
as public constexpr data
members, well, let's see.
All of the variables are,
if it doesn't have access,
by default it's public,
and then we enforce that.
If it doesn't have a storage duration,
make it constexpr and then enforce that.
If it doesn't have a type, set the type.
The code I skipped looks at
the type of the first element,
and if it's auto, we just pick int,
otherwise we use its
type, the first element.
And then we provide the explicit
conversion operator and such.
So we are composing a metaclass,
we're composing the value.
So a basic enum is a more specific value.
We apply defaults, public
constexpr, and then enforce them.
And we could also enforce
that there are no functions,
although this particular
code doesn't do that.
I'm sure you can see
exactly how to cut and paste
two lines to also enforce
that there are no functions.
And then I can say an
enum_class, for example.
The C++11 enum_class is a basic enum,
where I also add a constexpr
block to default the values
to one above the previous one,
unless it was set explicitly.
And so then I could
write &quot;enum_class state,&quot;
notice it's enum-underscore-class state.
&quot;auto started = 1, waiting, stopped&quot;
and that is even syntactically,
thanks to Dennis Ritchie
making enums look similar to classes.
That is already very close to what
you actually write with enum-space-class.
It's that you put the underlying type in
as a base with enum class in the language.
You say &quot;state : int say.&quot;
Whereas here you just say
&quot;int started = 1&quot; et cetera.
And there's a semicolon at the end
because we love semicolons.
Semicolons, they rule.
And then I can have skat_games,
diamonds starts at 9,
hearts as 10, spades as 11,
clubs as 12, grand as 24.
And I can do all my normal enums.
If we had had this 30 years ago,
would we need a separate
enum concept in the standard
that's bifurcating our type system?
Maybe not.
And again, look, no standardese.
And I claim, no loss in usability,
expressiveness, error
quality, or performance,
especially runtime performance.
Compile-time performance,
we have to make sure that we get enough.
But definitely runtime performance,
because all of this
happens at compile time.
And then, once I have all
that I can easily write
a flag enum that simply
declares the bitwise operations.
And has a different constexpr block,
which instead of doing plus one,
does powers of two, and
doesn't let you write
any of the values yourself,
'cause it's always powers of two.
And this is just code.
The first half is all declarations.
It's regular C++ grammar declarations.
And then there's a constexpr block
of compile-time code, which
is just regular C++ code,
whatever that we decide is
allowed inside a constexpr block.
And then I set, using Reflection,
I reflect on and set the values.
And now I've got a flag enum.
How many of you have reinvented
your own flag enum types?
Yes, how many of you
have used environments
where there are nonportable
proprietary flag enum types?
Yes, we keep on reinventing this.
Should we standardize one in the language?
There's probably some demand.
Should we standardize
interface in the language?
It's a common thing,
there's probably a demand.
But it'll never happen, it
doesn't carry its weight.
As a language feature, do
we really want to airlift
those 18 pages of the C#
spec for interface into C++?
I mean, we'll get to 2000
pages that much faster.
Do we really want that?
And how many of them can we
afford to add in the language?
But if you let people
write them as libraries,
suddenly they get cheap to add,
assuming the language feature bears out,
the general underlying language feature
of metaclasses that supports it.
Now I actually wrote a bug
the first time I wrote this.
So first of all, let me point
out we have a relationship
between basic value, a
value is a basic value,
a basic enum is a value, and
we've got these relationships,
so you can compose metaclasses.
But the first time I wrote
this, I actually forgot the XOR.
And and or, of course, oh
yeah, that's right, XOR.
And so what I'm about
to claim, many people
in the evolution working group
in the committee agree with.
So this is not just me saying this.
I forgot it, so it took
me 15 seconds to add it.
Because I just cut and
pasted those two lines
and just changed the bar to a caret.
Adding in a standardese wording
would have taken at least and hour.
And if you don't believe me, you haven't
been to evolution working group and core.
And the answer I got
from committee members
who've seen these slides
is that universally,
you'd never get it through in an hour.
Because it's expensive
to work with standardese.
And with an English
specification that tries to say
precisely in an imprecise language,
what a precise language rule ought to do.
Code, on the other hand, is precise.
Code don't lie, code
compiles, code unit-tests.
We love code.
Here's another example, a property.
This has been proposed to be standardized,
but again, one of those things
that has just not gotten enough traction
to be put into the language,
that people keep reinventing.
So today I might have a hidden data member
int value and provide
get and set functions.
By the way, disclaimer,
are properties the
solution to world hunger?
Of course not.
Can they be overused and
abused, like a knife?
Yes, just like a mugger in an
alley can use a knife on you
in a way that you do not appreciate.
But that doesn't mean you
don't want them in the kitchen.
You just don't want them lying around
on the floor or in the
wrong people's hands.
So properties, yes, they're overused,
but they're still useful.
That's why we keep reinventing them.
And again, I'll keep
harping on the same thing
that I keep boring you
with, 'cause it's important.
We C++ programmers already do it.
We keep inventing these.
C++/CX has them, Qt has them.
Every IDE under the sun
adds you some support
for properties in C++,
they're just nonstandard.
They all work a little differently.
But there's a need, but it's something
we'd never standardize in the language,
because it's too expensive
and too controversial.
I would like to be able to write
a property metaclass that is templatized.
So think of property as
a templated metaclass
that takes the type, the
underlying type that you want,
gives it a value, and
if you leave it empty,
could even make the forward
declaration do this,
but if you leave it
empty, by default it says,
oh look, you didn't define a data member.
Here, let me define one for you.
You didn't define a get or a set function,
let me define one for you.
And so that you get the same thing
that's on the right-hand side.
Now property of int, because
it's class that's generated,
just property of int value generates
a nested class inside my class,
which is not the same
as the right-hand side.
But you might have noticed I am using
a metaclass also on my class.
I'm calling it, say,
class X extended class.
What does it do, among other
things iterates and notices
any properties and in-lines
them into the base class,
so they can refer to each other.
So this another way to compose the two.
And we can default and enforce that
you can only write get and set functions.
We can enforce that you can
write them with conversions,
just like the standard std function,
that if it's a property
of int, that you can write
a get that returns something
that's convertible from int,
or you can write a set that takes
something convertible
to int, thing like that.
Very flexible, type-safe but convenient.
And you can write all
that in your metaclass.
And if you want to write a
custom one, say sting val,
your own get and set
functions, you can do that
and we can make sure you do
it right in the type system.
Now I mentioned Qt uses these.
So today in Qt you write
a Q_PROPERTY macro,
and this is just a subset of the features
that are available with Qt macros.
But you write your value,
you use annotations to say,
oh, well these get and set
functions relate to that value.
And I would like to be able to write it
something like the
right-hand side instead.
And again, have QClass do
all the things that a QClass
needs to do, including
treat any nested properties
the way that Qt properties
out to be treated.
And be able to write this in C++ code,
instead of putting it
through a separate compiler,
and still having all of the options.
I could have a different
stored type and a custom getter
and setter and still be
able to write that myself.
But on the right-hand side I have
a pair of braces that
define an abstraction.
And that's powerful, and they
reuse this well-known word.
Today Qt does this with a
more complex build chain.
You write a header file that includes
extensions, hidden by macros.
You run it through a
moc compiler as well as
your C++ compiler and combine the results.
I would like to just
write this as C++ code
that goes through my
normal straight toolchain.
And you can do other
things besides properties.
For example, signals and
slots are another thing
that we're currently
actively investigating,
with trying this out with
Qt as one of our examples
that we're testing out
over the coming year or so.
Look, instead of it saying
&quot;signals: void mySignal&quot;
could I say &quot;signal mySignal&quot;
and then do all the
processing for a signal.
That's a well-known return type
that the QClass metaclass
can recognize, for example.
But it's not just about Qt.
Remember, I said everybody
and their kid brother
framework-reinvents properties.
Well, so did the Windows
team over the last decade
with their new version of Windows apps.
And so C++/CX had to support that.
Well, you can't talk about
properties in portable C++,
so we added extensions for that.
We decided to do it in
the language so it needed
an augmented compiler that
took a superset of C++.
The good news is, you still
have a single toolchain.
The bad news is, it's still not portable
so it still won't work in Clang.
And it still opens you to accusations
of proprietary extensions.
But you either support properties and put
the information somewhere, or
you don't support properties.
So this is one approach, is to put it
inside an extended C++ compiler.
The current C++/WinRT work that Kenny Kerr
and colleagues are doing goes
a bit back to the com approach
of putting it in a
separate middle compiler.
So you still have the extra information,
but it will keep it away
from the C++ compiler.
But we still have a separate compiler.
This is much more like the Qt mock model.
And I would like to be able to have
just my single compiler be
able to compile all this,
which includes emitting information
that's needed by the framework.
Qt emits some metadata they need.
The Windows team has to emit
a .winmd file of Windows metadata.
So I have to be able to do some file IO
at compile time as well,
or as a separate build step
I can write &quot;generate a function&quot;
that I run as a build
step that generates that
from the metadata that I reflected over.
So how would this look?
The general idea, I wouldn't
worry about the specifics,
the general idea is, look, nonstandard,
nonportable complex code.
Potentially standard
portable, simpler code.
That's the takeaway.
And if I say &quot;rt_interface,&quot;
that's my generalized opt-in
that can say things like &quot;I
inherit from IInspectable.&quot;
&quot;I must have only public
member variables,&quot;
things like that.
And all of my functions
that I declare must be,
under the covers, transformed,
so that whatever their actual return type
that I declared in the source code was
becomes an out parameter
and a pointer to that.
And gets replaced by HRESULT,
because that's what the
underlying system needs.
All of that is done by a
separate compiler today.
It would be nice if we
could do that transformation
by transforming the source to
the generated C++ type in C++.
One other example, just so you know,
it's not just about Qt and Windows.
I gave a smaller version of this talk
about a month ago to
a group of physicists,
and in particular, from CERN at PODIO.
The PODIO project, they do
something similar again.
They write YAML that gets
run through a compiler.
And here is their YAML script.
They write &quot;ExampleHit :&quot;
That's gonna be a type,
and there's a description,
an author, and there are some members
that look suspiciously member-like,
except that they're a bullet list of text.
And from this, they generate
through this YAML script,
five interrelated classes,
the separate code generator.
Wouldn't it be nice if
they could just say,
&quot;podio::datatype&quot;
and then yes, anything that's
string, we can treat that
as a constexpr string for
your description and author.
Your data members, we know what those are.
And then we generate those same five
overlapping and interrelated types
from just this one that
contains all the information
that we have today as a non-C++ script.
Can we bring it into the language?
There's a new book out,
if you haven't already,
run, don't walk, because
I think the bookstore
sold its last copy yesterday already.
But they might be getting more.
So thank you to Daveed, to Doug,
and to Nico, who is also here today,
for writing this very nice book,
second edition of C++ Templates.
And I just had to page
through it when I saw it
for the first time on Sunday night.
And so I took a picture, I love phones.
And so I think this is
fair use, sorry guys.
There's this page, 495,
about the Curiously
Recurring Template Pattern.
You will see in a moment why
I flipped straight to that page.
The very first thing you might notice
about the first three lines
is you might call them
the curiously recurring
Curiously Recurring Template
Pattern, CRTP pattern.
'Cause they repeat that whole string
in those first three lines.
But the idea is that you
templatize a base class,
and the derived type gets
stuck in as the base parameter.
And once you see this, first of all,
how many of you have seen or used CRTP?
It's one of those acronyms
of consonants that we invent
because C++ can never
have enough of those.
NSDMIs, anyone?
But there's one question
that you should ask yourself
about the Curiously
Recurring Template Pattern.
Why do we do it, what's it for?
In a nutshell, yell it
out, couple of words.
(audience murmuring)
Composition to query
the derived class, yes.
So we customize the base class
based on the derived class.
Sound familiar?
Here's an example from the
book, slightly cleaned up,
of a CRTP equality comparable,
again, templatized by its derived type.
It exists just to inject the naught-equals
operator into the derived type.
And then the derived type says,
&quot;class X : public EqualityComparable&quot;
of me, of X, and passes itself in.
Just about line-for-line.
Because CRTP, I'm still going
through the exploration,
but it seems to me that all the uses
I've seen so far of CRTP are doing
what metaclasses aim to
do in a more general way.
You are trying to query
something about the derived type
and provide something in
the base that customizes it.
And of course, Reflection only
helps CRTP do more things.
Wouldn't it be nice if we could give
a shovel to say it more directly,
instead of using a useful
but not designed for it
language feature, which is templates.
Here is one other example,
and again, very similarly,
I don't have the exact syntax yet
for injecting those wrapper functions.
But again, it's one-for-one
what we do with metaclasses.
And we're doing it already.
So some open questions.
We have to validate that compile times
are gonna be good enough.
Is this still C++ or are
we turning this into Lisp,
which could also generate
compile-time stuff?
To the extent that we make sure
that we are automating and
providing direct support
for things we are already doing in C++,
we can be sure that yes, we are still C++,
that we haven't turned a corner
and gone astray somewhere.
Will this create divergence?
What if N companies define &quot;interface?&quot;
Absolutely.
When Bjarne gave us classes,
what if a C programmer had
said to you, oh darn, classes.
People can write their own data types?
That way lies madness.
Everybody might write
their own string type.
(audience laughing)
True, they did, but
classes are still useful,
and we could not live without them.
And they still have driven
a generation of the industry
into far larger and productive
and scalable systems.
So a metaclass is another encapsulation.
And how will we debug this?
Well, I said in the example,
see the compiler debug shape.
Yes, we already have generated functions.
We already need support for
step-into generated function.
Anything we do for
metaclasses will directly help
those existing uses we already have.
And the way to think about
this, a key mindset here,
is just go back to always thinking,
hey, the idea of metaclasses
is that class and struct
are the first two metaclasses,
and enum and union the third and fourth.
But they're just baked into the language.
Could I write me some of those
using compile-time code, please?
That's the idea.
And notice the keyword &quot;already&quot;
is all over that slide?
It's still very C++
because we're already doing these things.
They curiously recur, we
should ask ourselves why
and then give something direct for it.
So recall, abstractions are hiders.
And the whole point of the example I gave
is that I'm already showing you that yes,
we need to expose what is
generated, the actual definition.
Doing that using constexpr
compiler debug is a first step,
but it's exactly the kind of thing
that debuggers and IDEs will need to do.
A last thought on making
C++ powerful and simpler.
The way you make something
bigger but more simple to use
is to add abstraction.
And there's two kinds of abstraction.
Ones built into the language
and user-defined ones.
Ones where the users can
make their own word of power.
We only have two of those in C++ today,
the function and the class.
Now some of you may say,
well, that's not right.
We have so many features, templates.
But templates parameterize
types and functions,
they don't encapsulate anything.
They don't encapsulate behavior.
Overloading, absolutely,
static polymorphism, wonderful.
But it doesn't hide anything.
It's not an encapsulating,
user-defined abstraction.
Even modules groups things together,
and it is an isolation
boundary, that's very important.
It doesn't encapsulate
behavior so much as grouping.
So it's not creating a new
behavioral thing like a class does.
All of those are absolutely
valid and useful.
We want more of them.
But I'm hopeful that metaclasses might be
the third of those things
that actually let users
define words of power in a way
that simplifies how we use the language.
So we want to expand our
abstraction vocabulary.
Use it for everything from enforcing,
using Reflection and
compile-time programming
to enforce coding standards,
to write language extensions
as library code and many kinds of them.
Then we don't have to
wait for new compilers.
We can share language
features, what would otherwise
be language features, like
property, as a library.
And that means we can also take, not all,
but at least some of the language feature
proposals that are going through committee
and perhaps treat them as libraries.
Which are easier to debug,
much less expensive to process,
and you don't have to wait as long
to get them in your implementations.
So remember, all of this
is under construction.
But I picked this example for a reason.
I believe that is the
construction in Hyderabad,
in India, of a monorail system.
And you'll notice that you
know you haven't gone off track
when you stay parallel to
your original traffic road.
The same is true in C++.
We can generate all sorts
of bridges to nowhere
that don't belong in our language.
The way we stay rooted and make sure
that we're doing things
that belong in our language
is to make the roads we are
already traveling easier,
cheaper, more direct, more
high-bandwidth to travel.
If we can find people who
are digging with spoons,
that gives us the examples and use cases.
It demonstrates the need and
value of what we're doing.
And so I'm trying very hard
to stick close to that.
If you want to find out more
about how some of these
things are implemented,
see Andrew's talks at two o'clock today
and at nine o'clock tomorrow morning.
Again, warning, it's not about using them.
You won't see examples that are of uses
like we did today going through.
But you will see, what does it take
to implement this in Clang?
As he was implementing these things,
what did it teach him about how C++ works
and how these things need to integrate in?
So especially if you have
an implementation mindset,
check out his talks.
We have a couple of minutes left
for questions and a couple of microphones.
Would anyone like to ask a few questions?
And then you can stop me when we're done.
(audience applauding)
- Hello, I think that an
important subject matter
in your presentation is
that there is standardese.
Because it is written in English,
it doesn't much help anybody.
So is it not a good proposition to build
a language to specify
things into the language
so that the specification is code?
- So that is a valid approach,
Lisp did that, for example.
You might view this as
somewhat of an attempt to that.
But there has been no work on a general
meta C++ metalanguage that describes C++.
Bjarne has stuck very close to make sure
the C++ standard library
can be implemented
in C++, which is almost entirely true.
But not that the whole
language can be specced.
So no, there's been no work in that.
But other languages have tried that.
It leads to different places.
- Hi there, I was listening to your talk
and I was a bit skeptical.
After all, you're about to give
us a very sharp knife here.
So you had me when you
talked about flex enums,
because that is very clearly a thing
that would be useful to have.
But it's very clearly a thing--
- [Herb] The which?
- The flex enums.
It's very clearly a thing
that is not worth making it
a language feature, but
it would be good to have.
So I thought, okay, this
could be really useful.
What made me a little bit concerned
is when you said it
would be very difficult
to agree in the standards committee
on what an interface should look like.
It's much easier if we
have this metafeature,
so people can define interface.
And I suspect that you still do the work
in the standards committee and agree on
what an interface and
an enum and all that is
so that you specify it and you can ship
a standards library that comes with them.
Because otherwise everyone is
going to build it themselves.
So you still do the work.
It might be easier if you have
a framework for that kind of work.
- So let me completely agree with you
and clarify something to
make sure it's really clear.
Just like with classes, very common,
and I guess I forgot to say this,
very common, widely-used metaclasses
would also be put in the namespace std.
Why write interface more than once?
Where I was going with that,
the reason it wouldn't be
standardized is not
because of controversy.
Property probably would fail
because of controversy,
interface wouldn't.
But just because, is it
really worth its freight?
Is it worth 18 pages or
whatever of standardese,
and potentially bifurcating
the type system again,
as we did with enum, to add it?
As a baked-in feature compiler writers
would have to implement,
doesn't seem worthwhile.
Yes, it's useful, but
it's not that useful.
Whereas if I had a
general feature like this
and I could write it as a 10-line library,
I'll bet you dollars to
donuts that would sail through
library evolution working group.
- Okay, I can see that, it's just like,
don't give us the knife
if you don't give us
some nicely carved handles
to use with it already
or we will hurt ourselves.
- Like all other abstractions,
we should standardize common ones.
But then, because it's code,
we can have a much better
time agreeing on exactly
what it should be.
- [Questioner] Okay, I see, thanks.
- [Audience Member] Hi, can
you go back to any slides
as you were iterating over
class member functions?
- Can you just ask the question verbally?
- [Audience Member] Can
you go back to any slides
which are iterating over class members?
- Yeah, I understood, but I
was just thinking of saving
the time to go back to
a slide, but let's see.
- [Audience Member] Oh, sorry.
- Let's see.
Somewhere around--
- Any slide that you have
with for loop and make slides.
- [Herb] How about that one?
- Yeah yeah, so I saw you
used the syntax &quot;auto f :&quot;
so this cut-pastes the same generator
from function sequence, right?
So it seems that when you're modifying f,
the change is directly
propagated into language.
But what if I want to
have a disjointed copy
of the metaobject pointed to by f,
and make changes over
there and swap it back?
- Yes, so the short
answer to your question,
besides also, see Andrew's talk,
but the current syntax
uses an in-place semantics,
that is, I'm modifying my
metaclass as if in-place.
There are good reasons why
we're probably going to
switch to a source-destination syntax,
where basically the code is the same.
But I believe, in the current prototype
you would actually say,
&quot;$prototype.functions&quot;
so it's another class,
and then you would inject
each one instead of it having to be there.
So the structure is the
same, but you're right,
this has in-place semantics.
And that's one of the
things we're looking at,
saying is that really the right thing,
or should it be copy
from here, generate here?
Could lead to clearer code, yes.
So we're definitely pursuing
that, good observation.
- Had a couple of questions,
possibly related to that last question.
In the literal type
example it talked about
generating the make_functions as well.
But they would be outside the class.
Or is the intention to be
something like freight?
Contrasting with the if constexpr,
which definitely maintains
the scope, for good reason.
- So all of the examples that I show
in the paper and all of the examples
that the prototype compiler
currently supports,
although that's about to change,
is transforming one class
written in source code
to generate one class.
The PODIO example already
goes from one to five.
And generating non-members or injecting
into enclosing namespaces
absolutely is necessary.
And so that will be added as well.
'Cause then otherwise you
wouldn't be able to do
literal value because it requires
generating non-member functions as well.
- Okay great, the other question
I had was also about literal value.
Assuming literal value is clear enough
that it would easily go into
the standard library of metaclasses,
would you then consider
it likely that we will see
things like pair restated in
standard as literal type AB,
rather than old standardese we have now?
- So this is all very speculative.
But granting for the sake of discussion
that this goes anywhere, that it works,
that it becomes standardized,
that you have a standard literal value,
then we can have the
discussion, as we always do,
is can the standard library adopt
the new language feature
without a breaking change?
'Cause then the standard library vendors
would have to think about, well,
would this be an ABI break?
Maybe for the existing
ones, we'll still write them
the way we did before, but new things
we'll write using the new tool.
Perhaps we'll deprecate those ones
and then transition people over.
Or maybe it's not a
breaking change at all.
We will be careful to
write the literal value
metaclass so it generates
exactly what we have now
and then we can just go do it.
That would be the exercise you
would get to at that point.
That's like three or four major
steps beyond where we are.
But that's the kind of
thing that we would do,
and that we do already
with other proposals
where the standard library
is adopting a new language feature.
- [Audience Member] Thank you.
- Peter.
- My main question about
composability has mostly
been answered already by
the last two questions.
And thank you for giving my
students of the next decade
a lot of interesting work to do.
- Thank you and you're welcome, I think.
- Thank you for a great talk.
To my question, I'm just
curious how far can we go.
And how far are we from
templates for metaclasses?
- We absolutely need
templated metaclasses.
So one example that was in
these slides is property.
So you would define that
as template class T $class property,
because that's how you would say
I want a property of type int.
Then you could say
property&amp;lt;int&amp;gt; myproperty.
- [Audience Member] Thank you.
- Not that you already don't have enough
to do with metaclasses, but
have you given any thought
to having inheritance of metaclasses?
For example, if you're in a company
and you want to specify that all classes
have an assignment operator
or they all have something
which would give you the
major/minor version of that class?
So everyone in the company
could start with that base
interface and then create
their own interfaces from that?
- Yes, and again, some
people will view this
as a wonderful thing, and I think it is.
Some people will exactly be worried
about the bifurcation of
company-specific styles.
So what I'll point out,
using this as an example,
is that the way you phrased your question
shows your company is in
fact already doing this,
probably just enforcing it with linters
and other kinds of tools,
or not enforcing it.
So again, it's something
we are already doing.
We will do it much more
rigorously and predictably
and correctly and simply if
we can just say it in code.
Another example that's come up
when we were doing usability studies,
one of the things we learned
is everybody comes up
with a use they could use
in their current project
for metaclasses, and
they're all different.
One is for coding guidelines
or custom conventions like you have.
Another one was that they said
in their shop they use a robotics library.
It was a machine library,
it was a numerically-controlled machine.
And to use this library,
the library required
all of your classes had to
follow a certain pattern,
which right now they do by hand.
They forget, then things
break and it's hard to debug,
where they could just write the pattern
once as a metaclass, they
figured they could do it
in 20, 30 lines, and then they'd never
have to worry about that problem again.
And it would be just, okay,
here is the convention
in code of what this library requires.
So that's probably
similar to your example.
- [Audience Member] Yeah, thank you.
- We probably have time
for just one or two more,
so let me take one each.
Apologies to everybody else who's waiting,
but I'll be up here for a bit after.
- [Audience Member] So how
does &quot;compiler.require&quot;
differ from static assert?
- How does &quot;compiler.require&quot;
differ from static assert?
A, look at my paper, PO707.
There's a discussion of that in there.
The short version is it can be integrated
into compiler error messages,
you have some usability
benefits that you don't
have with static assert.
For example, in a metaclass
you can write that,
what's the example I'm trying to think of?
Let's say you want to try to,
if I'm remembering the
example on the fly right,
you're trying to ensure that I'm writing
a container-like vector of T,
and I want it to be copyable,
not just movable, if T
is copyable, not movable.
Where do you write that
static assert today?
'Cause you can't write it
inside the instantiation.
Sometimes you can write that inside
the instantiation of vector,
but you have to write it
after vector's been instantiated,
and some of these you have
to write outside the class,
today with static assert.
Whereas a metaclass would give you
a nice clean place to put it.
I might've misremembered the
particular compelling example,
but that's the one I remembered
off the top of my head,
is when you can't write
the static assert in that location today.
- [Audience Member] Thanks.
- Hi, I guess I had mixed feelings
of your discussion on CRTP.
I'm glad that you mentioned it,
but I was sorry that you
mentioned it so late.
So in all the code comparisons
on the left you have 17 code,
on the right you have the metaclass code,
and it looks much nicer.
But Reflection is a precondition
and CRTP already exists in the language.
So if we, on the left instead took CRTP,
greatly enhanced by Reflection
and maybe also injection.
So you kind of framed it
as, we're not gonna need
CRTP anymore, it's not meant for that.
I think the &quot;not meant for that&quot; ship
has sailed in C++ a long time ago.
But we use CRTP and it
works, so won't CRTP
plus Reflection and maybe injection
cover almost all of the examples,
most of what we want
to use metaclasses for,
and leave metaclasses not able
to carry their own
weight as a new feature?
- Excellent question to end on.
CRTP is a spoon, we are digging with it.
It was never designed for it.
It is a glorious hack,
it works effectively,
but it can't do everything.
I was careful to say &quot;I think.&quot;
The recording will tell
me whether I'm a liar,
that metaclasses let you do a superset,
let you do everything CRTP does, I think,
of the examples I've
seen so far, and more.
For example, with CRTP,
because of C++'s rules,
remember, CRTP is the base class.
You tell it what the derive class is
so it can inspect it and such.
So Reflection will let you
do more CRTP, absolutely.
But it will always be doing
things in the base class
which can be hidden by the
things in the derive class.
It's not putting them together.
It's going to have trouble
generating non-member functions.
It's going to have trouble
generating multiple classes,
like the PODIO example I gave
that the CERN people are doing,
where from one script they
are creating five classes.
You can do it, but you'll need five CRTPs
and you'll need to invoke
them all every time.
You can't just say, PODIO data type this,
and then generate all the things.
So I'm not trying to diss CRTP.
It has been very useful and
that's why it's recurring.
It's curious because it's not
what templates are meant for.
It seems like we're trying
to say something indirectly,
and we would like a
way to say it directly.
So I'm trying to address
mostly the curious part.
It's absolutely recurring, and it will be
even more useful with
injection and with Reflection.
But it still won't be able to do
the full generality of things,
'cause it just wasn't designed for that.
It's a coding pattern or
idiom, not a language feature
in its own right that we can make
do what we want and make general.
So I'll hang around for a few more.
Thank you very much for coming.
Enjoy your lunch, and then
the lightning talk sessions.
(audience applauding)
- Bash films can shoot your
event with multiple cameras,
link to presentation slides, add titles,
and edit your event live for
a full broadcast experience.
- How is this even working?
So this is actually a
more interesting program
to look at, in a lot of ways.
Let's profile it, do a little bit
of time to do a profile for it.
And see exactly what it
is that's making this
faster or slower, based
on the different inputs.
You can really gain a lot of insight
by actually looking at
the profile like this.
- I worked at Sesame Street.
I got brought on to be
a writer's assistant
on a show called Sesame Street English,
which was to teach English
to kids in China and Japan.
It seems very simple, the
shows that they put together,
but it's actually really
hard to design a show
that is not only for young
kids, but also the parents.
- Confession like this is therapeutic.
I hope you all get something out of this.
But if you don't, the therapy
will have been good for me.
So thank you.
Seven years ago I wasn't
working at Google.
I was working for my previous employer,
which was a large,
multinational investment bank.
I had what was, up to that point,
the worst day of my career.
- And then came the anger.
Anger at ourselves because we knew
we were responsible for
America's first space disaster.
We wrote two more words
into our vocabularies
as mission controllers,
&quot;tough&quot; and &quot;competent.&quot;
Tough, meaning will never again
shirk from our responsibilities,
because we are forever
accountable for what we do.
Competent, we'll never again
take anything for granted.
We will never stop learning.
From now on, the teams in
mission control will be perfect,
because as a team, we must never fail.
- One other thing, we're all
in a very fortunate position.
We've been very lucky in
our lives and so forth.
And I think as part of the mission,
it's also good sometimes to
take that fortune and give back.
(audience applauding)
To make sure that you take this platform
and use it towards worthy causes.
That's good karma, that's
good stuff in the universe.
- We understand that your
event will have needs
that are specific to your organization.
Please email or call us directly
to discuss your particular event.
We look forward to discussing your goals
and helping make your event a success.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>