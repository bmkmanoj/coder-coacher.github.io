<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Mathieu Ropert “API &amp; ABI Versioning...” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Mathieu Ropert “API &amp; ABI Versioning...” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Mathieu Ropert “API &amp; ABI Versioning...”</b></h2><h5 class="post__date">2017-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ia3IDPjA-d0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Okay, Hello everyone.
How are you this morning?
You good? Yeah, great, great.
You enjoying the conference so far?
Me too.
Okay, thank you all for coming here.
I'm going to talk to you
about API, ABI Versioning,
and basically how to
handle impacts in your code
when you do a change, any kind of change.
The question, usually,
you should ask yourself
when you change something,
when you release a new comment is,
What are the impacts?
Am I gonna break something for somebody,
if I push this change?
I'd really like to thank Titus,
who gave me your hell for
an introduction yesterday.
Because he said that,
basically, &quot;You can't help.&quot;
He said that, basically,
&quot;The idea is that there are&quot;
&quot;so many things that could go wrong&quot;
&quot;that you can't predict.&quot;
&quot;So many use cases you
could not have foreseen.&quot;
And he insisted on two parts especially,
that semver was clearly not the option
and that wanting to end all
binary compatibility was just madness.
Guess what I'm talking about today?
Semver! Binary Compatibility!
Right, all right.
Joking aside, the meat of this talk
is more about explaining
to you what kind of impact
you should expect from changing your code.
Because I think there is
some place here to be able
to tell what people can
expect from something
you will change in the code.
So we'll study the impacts on the API,
if you choose to change something.
We'll study the impact on the ABI,
some binary compatibility
and then we'll see all
to try to put a category on them.
Like, is it gonna break
or is it gonna be fine?
And of course, how to, well, communicate
with your developers to tell them
that you changed something
and that they should expect
well, what to expect exactly.
For those who were not in
my previous talk today,
Hello, my name is Mathieu.
I'm from France and I work at Murex.
I work in internal frameworks.
I work on some Open Source initiatives,
which are not published
yet, unfortunately.
And so, well, I have to ask myself
a lot of question about lifecycles
and how to maintain thing in the long run.
You can follow me or e-contact me
at, well, the social media of your choice.
So, let's talk a bit about
the lifecycle of a library.
So let's say you want
to publish something.
You want to publish a library,
you want to create something,
you want to put it out to the world,
some nice code you have.
There are like a million
question you can ask yourself
about what it's gonna be.
What are gonna be the impacts?
What should I be afraid of?
And since there are a million of them,
I just tried to insert the one
I think are really
pertinent, in that case.
The first one being:
Will all your users
belong to the same repo?
Because of course, it's a different world
if all the people that use your code
are in the same gate repo,
or if you are just one
of the, I don't know,
billions repo and GitHub and that people
will pull your code in
Verical base and use it.
On the first try, on the first side,
if you break something
you will know immediately.
You will probably not get
past the pull request,
it will be obvious.
In the second case, not so much.
So of course, in the first case,
Versioning is not mandatory.
You will see immediately
that you broke something.
Then again, I think
it's not enough to think
that you don't have to
worry before pushing.
Because I think pull
request, it's a bit too late
to notice that you broke
something for other people,
and instead I think we
should be more proactive,
more preemptive, trying to
think about what will change,
what will impact people if
you push that modification.
Second question will be:
Will you ever backward
compatibility ever, in your library?
That's not a common use
case to not break at all,
but I know that some of you
might have some constraints
or might have some will to say,
I will never break backward
compatibility, ever.
I will just, I don't know,
provide a new namespace every time,
but everything I put there,
it will still work 10,
20, 30 years from now.
Again, remember that even if
you decommission something,
if you say okay, it's deprecated.
And then 20 years later, you remove it.
Technically, you're breaking
backward compatibility.
So when I say, &quot;Never
break,&quot; it's really never.
So of course, if you do it
even rarely, even once in 10 years,
you have to have a way to distinguish
between a breaking change
and a non-breaking change.
This one is quite important.
Will your users ever have to hotswap
your library in production?
Again, I think there are
multiple-use cases here.
On one sides, we have the nice things
Google showed us yesterday,
the Live at TED, the high D,
that basically you always
recompile everything.
But maybe you have, I don't
know, some cloud application
or you use Docker, I don't know.
But maybe not.
Maybe you have a library
that's installed on servers,
that's installed on machines.
It's releasing it at
the bottom of the chain
of the dependencies and
you cannot allow yourself
to break binary compatibility.
I mean, imagine that you're a maintainer
of, I don't know,
[Inaudible], or the C runtime.
Can you just say, People.
Well sorry, I broke the
ABI, I broke the API,
just recompile everything
that depends on it?
I used to have Gentoo at home.
If anybody has ever tried
to recursively recompile
all dependencies on lmc,
well, I know it's not feasible.
It's not reasonable.
So if that's your use case,
you will have to worry
about binary compatibility,
you will have to worry about the ABI.
Of course, if you are a head-only library,
and I know that it's
quite trendy right now,
you don't have that option.
It's never, you're never gonna be able
to offer people a binary to hotswap
because, well, by definition
you don't have any binary.
So basically, it's important to know
when you're gonna change something.
It's important to try to categorize.
Will it break, or will it not break?
Are my users workflow?
If you want binary compatibility,
you do not have only to
monitor the change on the API,
but also on the ABI, which
I will explain later.
And of course, people get very angry
if you break something without
telling them beforehand.
Because, when you think about it,
well, when I think about it at least,
I think Versioning is about communication.
It's communication between
maintainers and users.
You want to tell them, All
right, this has changed.
Here is what you should have to do.
We changed stuff, here
are some nice features,
and don't worry, we didn't break anything.
But, it's all about communication.
A word of caution: for
the rest of this talk,
I'm gonna be talking about
what I think is reasonable use.
Because as Titus said yesterday,
&quot;Some people might expect
unreasonable things;&quot;
&quot;unreasonable guarantees from your code.&quot;
They might expect that the
line numbers will never change,
or that the symbol addresses
will remain the same,
or that even you can take them.
Or that, I don't know, the real type
of auto types will always be the same
whatever you do behind the scenes.
Or like the layout of your
private members, well, anything.
Well, this is not the talk.
I'm gonna try to focus
on the reasonable aspect
of what you can define.
And if you have overuse cases,
well, I'll be glad to talk
to you about this later on
but this is not the talk,
because it's a whole different world.
All right, let's start with
the easiest one, the API.
Because I think most of you know
at least one bit or
two about what's an API
and the ideas behind contracts.
Just to summarize, a
contract, an API, sorry,
is a contract between the
user and the maintainer.
It is: if you provide me this,
if you follow that, if you call this,
I will give you this and that in return.
And if you don't follow what I asked,
well you, I can't guarantee anything.
I don't know what you will get,
and it probably won't work.
On the other hand, since you take the
took the, to get it granted
to provide as a maintainer.
If people follow the rules,
you have to give them something in return
and you have to give them
what you agreed upon.
It's a mutually binding contract,
exactly like you can have in
law or in any other domain.
We usually divide that in two parts:
that's the pre-condition,
which is what people
who call you must adhere, must follow.
It's what on their hands,
what they have to respect.
And the other end is what you agree to do
if they respect that, the post-conditions.
A next example, for
example, if a contract,
yeah, sorry that the slide's a bit big,
is what you can find on CPP reference,
in this case it's std swap.
So when you look at the contract,
first you have the name of the contract,
the function you must call
in order to get something,
in that case it's swap.
Then you have where to find it,
which header you have to include.
And you can already see
that, technically speaking,
C++ 11 broke binary API compatibility
because the header has
changed in the release.
So technically people will not find
what they thought they could
find in the same place.
Then you have the signature.
Like what are the type of the arguments?
What are the type of the returns?
What are the different alternatives?
The extra pre-condition requirements.
Like for example, the type requirements.
For example, in the case of swap,
the first type must be move assignable
and move constructable.
In the second one, it just
needs to be swappable.
If you don't follow that,
swap, well I can't
guarantee what swap will do,
and neither does DOS DCL.
You are out of luck.
And of course, the
post-condition after that,
which is if you followed all
the rules I've set behind,
I will swap both members, T1 and T2.
Okay, so in C++ terms what does that mean?
I'd like to categorize that in two terms.
On the left-hand side,
you have what's internal.
What I call internal is
what the compiler can see,
what's part of the language so far.
The names, the signatures,
the location of your declaration.
Any of that, if you break something,
the compiler will tell you this.
It will tell them all right,
the type are mismatched,
or I can't find that function,
or the name is not what I thought.
It's the most easy,
it's the most simple part,
because it's the one that's
part of the type system.
The second one is what I call external,
because it's not today
part of the language.
It's things you expect,
it's things you ensure,
but it's not things that
the compiler can check.
It's things that you can
only document in some way,
and that people have
to follow nevertheless,
because otherwise it won't work.
All right, like I said,
since not all parts of the
API are part of the system,
some change are more
injurious than others.
If you changed the API
by something that the
compiler can't check?
Well, people will get angry
because their code won't compile,
but at least they will have some input,
they will have something.
It won't compile if I have
to open your documentation,
or your header files and
say okay, why did it break?
Why can't it find a function?
Or why is the type not the same?
And chances are they will see
that they have to adapt the code
because indeed, you
released a breaking change.
On the other hand,
if you changed the parts
that was on the right side,
it's quite possible
that the compiler will tell them nothing.
So if you do not advertise that,
people will have some nasty surprises.
For the rest of this talk,
I will try to categorize the
change you made on your code
by the type of impact it has on the API.
To follow a bit on what
I will talk on later about semver,
I would say there are three
kind of changes you can make.
The most obvious one is
the breaking changes.
I broke a contract, people
have to change their code.
If they don't, things will go bad.
If you are lucky, it won't compile.
If you're unlucky, it will be
even more terrible than that.
Second one is the non-breaking impact.
It's you added some stuff,
you offer a new opportunities,
but for existing users,
it should be transparent.
They won't have to do anything to adapt.
And of course, there is
the last kind of change,
is that you changed
something to your code,
but the API has not been impacted at all.
Let's see that in detail.
Easiest one first: no change.
Changes with no impact, well that's easy.
If you did not change any contract,
well, you did not change the API.
So basically, if you fix a bug,
if you do some performance tuning,
or if you refactor your code internally
because you changed the implementation,
but the older, the observable
and guaranteed behavior is the same;
well, that's a no-impact change.
So basically, what does
that mean in C++ terms?
That means no names or
signature have changed.
All the defined behavior
is the same, like I said,
and that it's important.
It includes specific guarantees.
Like for example, if you took,
went the extra mile and said, All right.
My function is guaranteed
to work in linear time.
Or if you say, All right.
My function will not
invalidate any iterator,
you cannot change that.
It's a breaking change,
so if you did not change
anything in the API
but still have a worse
algorithm, for example,
it's not no-change.
There is an impact right here.
So what's the non-breaking change?
Well, anything you add.
Anything you add that does
not touch what existed before.
So like new functions, new
namespace, new variable,
new struct member, new type, whatever.
That does not change the API.
Everything that was previously
there is still there.
I put a star on new overload
because like we said prior,
if some people are trying
to get the address off your functions,
if you add an overload, then
they might have some surprise.
But other than this case,
a new overload is supposed to be safe.
You can also relax an existing contract.
Basically, what I mean by that is,
that you change a contract
but only for the better
or for new options.
Like for example, if your function
took two arguments in the
past and you add a third one,
but that the default
value of the third one
gets the same behavior as before,
you did not break the API.
People can still call your
code as they did before
and expect the same results.
If you add a new struct
members, like I said,
it has no impact on the API.
All the other ones will
still be found in the struct,
no names have changed.
If you relax the pre-condition,
if you accept more values
than before, it's okay.
For example, if your
function in the past said,
No, I want only positive integers,
and now you can give me any integers?
Well, you just defined a
previously undefined behavior,
that's totally acceptable.
You can also narrow a post-condition.
Like if you said,
on the past I will only return
a number between 1 and 20,
and now I will only return
a number between 1 and 10.
1 and 10 is between 1 and
20, so it's still okay.
You did not break your promises.
Of course, you can also, sorry.
You can also narrow the guarantees.
If for example, in the
past you guaranteed people
that your algorithm will run in N log N,
and now it just runs in
N, that's just better.
So people will be on board with that.
It's not breaking change to me,
and I don't think it's to you.
And of course, like we said before,
basically defining any
kind of undefined behavior
is not a breaking change.
People should not rely
on undefined behavior.
I think it has been told many times,
even in this same room.
I don't need to insist on that.
So what's the breaking change?
Well, basically everything else.
For example, if you change a signature.
Like, you changed the argument types,
or you changed the return
types, or you changed the order.
Well, it won't work.
Some exception, or maybe some exception:
if you have like a new,
if you use a compatible type
with an implicit conversion,
it might be okay.
But beware, because there
are lots of conversion rules,
and if you had a few overloads already,
and you change one of them,
make sure that all the previous ones
still match the same thing.
For example, if you mix up strings,
pointers, Booleans, and integers.
Sometimes, if you change one of them
the overload will not
select what you think
for every type that it did in the past,
and people will get nasty surprises.
I did have some issues
when you pass a bool,
and the first conversion
says Selected, this is that.
Oh okay, you said false, that
means you mean null, right?
So that means it's a string? NO.
Yeah, I see some people laughing,
I guess that I wasn't the only
one to which that happened.
Of course, renaming.
If you rename something, it won't compile,
so clearly breaking change.
And the last one is maybe
less obvious, but still.
If you move something from
one header to another.
If people have to include
something else to find your code?
Well obviously, you broke the
API because it won't compile.
If you narrow a contract.
If you add more restriction than before?
Of course, it's a breaking change.
Reverse from what I said before.
If you accepted all integers
and now you only accept positive integers?
A lot of people, like maybe
half of them, will be unhappy
because they used to be able
to do that and now they can't.
On the other hand, of course,
if you relaxed the post-condition,
it's the same issue.
If in the past, you guaranteed people
that you did not invalidate in
the iterator and now you do?
You will have some very
angry people calling you.
That's evil, basically that's evil.
Because what happens if
you narrow a contract?
Well, basically you changed your API,
but if that's the only change you do,
the compiler will still compile fine.
It will be completely
unobservable for people
until they run your code.
If you're lucky, in test.
If you're unlucky, in production,
and they will get very, very unhappy.
No seriously, don't do that.
Do not narrow a contract
if that's the only thing you change.
One more example, just to be
sure that I hammer the point.
Let's see sum change, so.
In the past, I had a function
that was supposed to sort
a vector, a vector of int.
I documented the contracts on top,
I'm a pretty nice guy.
I told them, all right.
I sort a vector of integers
and I guarantee you
that I will do it in N log N,
and implementation details
is std sort, great.
Now I change the API.
I say, okay, I still sort
your vectors of integers,
but I changed a post-condition.
Now the complexity is a,
Sorry, what's the?
- [Student] Factorial.
- Yeah, factorial and. Thanks.
Because inside it I used bubble sort.
Are you familiar with bubble sort?
Yeah, yeah, funny algorithm.
For your culture, it's basically
you try to see if it's
sorted and if it's not,
you shuffle everything and you try again,
seeing if that time, it's okay.
That's an optimized
version of it, by the way,
because if it's already
sorted, it will not block.
So that's the optimized bubble
sort, technically speaking.
Yeah, but you see the point.
You've been a nice guy, you know?
You changed the contract and
you documented it, that's fine.
You say, Okay, hey I did
not take you by surprise.
The contract is documented,
I changed the complexity.
All right but I told
you, why are you unhappy?
Well, you broke the API and
the codes still compile.
Even the best intentioned
people in the world
will not look always at your changelog
if you say you broke the API.
Most of the time, they will
notice that you broke the API,
because their code don't compile.
So if you do a nasty change like this,
and people don't get a compile error?
Some of them at least will
push that into production,
expecting that whew, the
change did not impact me.
And sometime later, you will
get some very angry calls,
if not a lawyer.
So again, if you have to
break the API, break it.
Like, don't break it in half,
don't do it half-assed.
Just go for it, break the types,
break the names, break everything you can
so that the compiler will stop people
and they have to take some time
to figure out what you changed exactly.
Don't just change something
that the compiler does not see.
It's just too dangerous.
(water bottle being opened and closed)
Okay, let's talk about changes in ABI now.
The compatibility with binaries thing.
Okay, so who here knows about ABI?
Oh see, about half the people.
Right, so I think it's a nice time
that I take some time
to refresh your memory.
So ABI is Application Binary Interface.
It's the way that your
binaries talk to each other.
It's really how programs talk
to each other in your computer.
It's what defines how it works.
And the funny thing is, it's
not part of the Standard.
I put a little star there
because there is a very, very,
very small specific part
that's defined in the Standard,
but most of it is not defined
by the C++ Standard at all.
It depends on your
platform, on your compiler,
on a lot of thing but not on the Standard,
which of course, makes it tricky.
Again, I'd like to split
that into two parts.
The part on the left is what I
call the Infrastructure part.
It's all the rules from the ABI
that comes from your choice of platforms.
CPU, OS, compiler, that kind of stuff.
And that's the part of which I won't talk,
or probably not talk much.
Because it's the part that you developers,
API maintainers, do
not have to care about.
It's basically the choices of
the people who use your code.
It's up to them to make sure
that if two binaries are
to talk to each other,
they have to use the same infrastructure.
That's not your problem.
It's a problem, but it's not your problem
and since I don't have unlimited time,
I will focus on the second part,
which is what derives from your code.
What can you change in your code
that might have impact on the ABI?
And mostly it's about
changing symbol names,
it's about representation of binary types,
and it's about vtable.
First one is maybe the most
known one, it's mingling.
Mingling is the idea that
the linker that you use
for C++ is still very
tied to the C platform.
So that means that it
can only understand names
that have underscores,
letters, and numbers.
That's about it, but
the problem is in C++,
a name isn't just a name.
It's the name plus the type
of all arguments produced in m space.
And as you can see, things
like colons or stars
or whatever you can find in a signature,
that doesn't fit in that standard.
So in C++, you have
what you call mingling,
which is basically you give me the name,
you give me the signature.
I mix and match that,
and in the end I output some id
that's compatible with the
C names so that your linker,
your platform is able to work with that.
Their algorithm again is not
defined, in the standard.
It's usually defined by the compiler.
Most compilers try to be
nice and have the same,
on the same platform but
that's not even a guarantee.
So for example, here I have two overloads
for the same function foo.
First one takes int,
second one take double,
and as you can see the exact name
that comes out is a bit different.
So what's the first thing
we can deduce from that?
Is that if I change a type,
I change the signature,
I change that nice i and d
at the end of the function.
So I changed a symbol
name and as we might,
All I think I've run into at
least once in your career.
If you change the name in the
library and you run a binary?
You'll get a nice popup on Windows
and a nice error message on Unix
that tells you, &quot;I
cannot find that symbol.&quot;
So basically even if you
do not rename a function,
if you just changed the argument type,
you changed that magical id
and it's not binary compatible anymore.
And what's funny in there
is that you don't have
to care about your public function.
You do not only have to care
about your API functions,
because the natural thing
would be to think about,
okay I just have to wonder
about, did I change the API?
But that's not only that.
That also could be implementation details.
For example, if I do some inlining
because it's sort of
what the code could do.
I have a function foo,
which is part of my API
and then inside, as an
implementation detail
it calls a function in
the detail's namespace,
which is usually reserved
by the maintainer,
and it's not a public API.
So technically speaking,
if I do that change from left to right,
I did not break the API.
Function foo is still there,
it still compiles fine.
Defined behavior is still the same.
But there is a symbol
here that's not the same.
Bar in the past took no
arguments, now it takes one.
The magic name in the
end, it's not the same.
So what happens?
Well, I get the link error
or I get a loader error
and to the external view
the API does not change.
But I change the symbol anyway.
So you do not have only to care
about API methods, API symbols.
You have to care about any symbol
that's exported in your system.
And I think that's where,
Where is James? There he is.
I think that's where Windows got it right,
because in DLL as he shown yesterday,
it's private by default.
You have to explicitly state
that symbol will be exported.
So it's quite easy to look at your DLL
or to look at your export file,
or just run a grip on your configuration.
To know which symbols
you have to care about,
especially if you have
to export them manually,
because then you know
that you have broken the,
that you have broken the ABI
because you renamed the symbol.
On Unix, on the other end, the default is
that anything that's not static
or inside an anonymous namespace
will be a public symbol.
It's much harder to determine
if you change something
that will be visible to the outside world
and then break that code.
Usually, what I would recommend you,
especially if you want portable code,
is to use like, you know the
export macros that C make
and generate for you
that you can do by hand,
that expands to DLL
export/import on Windows
and to nothing on Unix?
Because you can easily grab
that and say okay, in the dif,
did any of those line change?
Because if it did, you
probably broke the ABI,
even if the API is still the same.
Got it? Great.
Now let's talk about the vtable.
The vtable is how your compiler will store
the layouts of the function
pointers to your classes.
Because as we all know when
you have a virtual method,
it's at runtime that the
code will try to think
which method to call in practice,
and that's usually done through
a function pointer table.
That again, is not
defined in the standard,
that's up to your compiler.
And usually you can
expect it to be the same
from one compilation to another,
as long as you don't change anything.
But since it's just a table of pointers,
offsets that the compiler,
or that the code will blindly jump to.
If you add method in there,
you will probably change
some offset somewhere
and it will not go well.
Especially if two sides of an API,
on two libraries disagree on
what the vtable layout is.
Like if the first library
thinks there are four methods,
the second one thinks there are five,
and that the particular one
you want to call is the third one,
and they don't agree on which one it is?
You will have some nasty surprises.
So basically, if you
reorder the virtual methods,
or if you add one, you will
probably change the size
or an offset and things will go badly.
And since we are on binary representation,
the last one is maybe the most known one,
because we've seen it in C.
It's the layout of the structures.
Because, well, your compiler does not
well the compiler does,
but your machine does not
see your nice struct layout.
Your machine just sees
offsets and size, basically,
and some are very basic assembly types.
So if the size of a structure change,
if the size of a member change,
or if the offset of a member change?
You will have some issues.
And the funny thing is, it
depends on your platform.
It can change from one
way to completely another,
depending on the rules of your platform.
For example, between ALM and NX86,
or between NX86 and Spark,
you don't have the same rules.
So in one case it might
even seems to work,
and then you push the same change
with the same rule as
binary on another platform
and it doesn't go as well.
Basically the idea is that you take
your nice little structure in C++
and then your compiler translates
that into a binary layout.
For example, my int,
that's on my machine, so x86-64 bits.
On my machine, I have
first fall byte integers.
Then I have a bool, a pointer
to a char, and then a double.
Okay, this is what it
looks like on my machine.
The first one, the compiler puts it
just at the start of my
structure, because it can.
Then I have a Boolean just after that.
Then I have a pointer and
the ABI on the machine says
that every pointer should
be aligned on its size,
which mean it should start on an offset,
that's a multiple of its own size.
So for example here,
the next available bit
would be address five,
but it's not a multiple of
eight, as far as I know.
So the compiler will add some padding
to be able to follow the rules.
So of course, if I had
a member at the end,
well, the size change.
And if I add in a member
in between m3 and m4?
Again, because of the alignment rules,
it will push everything.
So usually, if you change
anything in the struct,
like if you change sizes,
if you change order or
if you change offset,
it will not be binary compatible.
And even more than that, if
you change a member visibility,
it will maybe not be compatible.
Because that's where I come back
to the only part of the standard
that talks about the ABI.
There are two ways the
compiler can translate
your nice structure layout into binary.
There is the C compatible
one, and there is the
well, let's say the new C++ one.
And they do not have the same
rules and the same guarantees.
The C one says everything
should be in the same order,
aligned with whatever
platform rules you have.
The C++ says, and it only
activates if you have
at least two members that do
not have the same visibility.
For example, public and private.
Then the compiler say okay,
you're not trying to do C compatibility?
I have more leverage to wield
over other members if I want.
So it's even more hard for you
to know if the ABI will break or not.
The easy rule is just to say, okay,
I change anything in the structure,
any type, any size, any ordering,
it's not binary compatible anymore.
Of course, here I'm
talking about the types
you exchange through your
API, the public types.
Any type that both sides
of an API have to see,
because if it's only
internal in your code,
well, you can change
it as much as you want.
Your binary is just one unit,
he will always remove himself, hopefully.
But at soon at you are two people talking
about one kind of structure,
a public structure,
they have to agree on the layout.
If they don't, bad things will happen.
If you're lucky, it will fail very early.
If you're unlucky, it will, I don't know,
confuse the pay and get the members
of your financial structure,
and your clients will get money
every time they buy something,
instead of paying you.
Okay, so how do we put all that together,
and try to do some Versioning?
I think there was a nice introduction
to semver yesterday, but still.
Is all of you familiar,
are all of you familiar with semver here?
Or do I need to,
Could you raise your
hand if you know semver?
Ah, still, okay,
maybe half the people
don't know about semver,
so I think a quick recap
could be interesting.
Basically, it's a Versioning
scheme that was created,
I think, like six or seven
years ago by somebody at GitHub
and it's a formal convention
to express the impact
of changes in an API.
It's three numbers, X, Y, zed.
X is major, y is minor, and zed is patch.
Basically what it says
is that a major change
is anything that has impact.
Any breaking change
should be a major release.
Any minor change, any minor release
is for changes that don't break anything
but still add new behavior.
So they are changes,
but not impacting one.
And the last one is the patch,
which is not anything
in the API is the same,
you are safe to upgrade or even downgrade.
If you think you have to
do that, it should be okay.
So how do we handle that?
Well, my suggestion until we might move
to a new world of living ahead.
Until that, if that ever happens,
is to follow some kind of convention,
and well, until then I
didn't find a better one.
Maybe there are, maybe there aren't,
but at least we have something,
we can agree on something.
Maintain the changelog.
It's not enough to tell people,
All right, the version has changed.
Because if you just tell
people the version has changed?
Well, usually it means okay,
brace yourself, you may have issues.
I don't think it's enough.
No, it should be okay,
I changed something.
Please, please, go look at the changelog.
See if that's impacting to you
or not and adapt your code.
Of course, since we said that
half the stuff in the API
was not part of the type system,
you have to document that.
Because it's agreement
and if you have to agree on something,
it must be written somewhere.
There must be one source of truth
that people can use to
talk about something,
so please document.
Anything you want,
it could be like a Magden
file in your project,
it could be a wiki, it could be Doxygen,
it could be just comments.
Whatever you want, but document them.
And again, do not do any kind
of invisible breaking change.
If you change something in the API,
go for something that
the compiler will see.
Go for something that will
trigger compilation error.
Do not do the bubble sort thing.
I know that's a caricature,
but something much more
sinister can happen
and have happen a million
times in the past.
Because people changed the API
and then only changed the non,
the part that was not
seen by the type system.
How do you include ABI?
Well, first up trainees: don't!
I mean, I'm totally on board
with what was shown recently.
If you can avoid it, it's much easier.
As you have seen, as many
people have told before,
API is, ABI is complex.
It's lots of rules, they
depend on the platform.
Even on some case it might
work on your machine,
but not on the server machine
because it's not the same CPU,
or the same OS, or whatever.
It's dangerous, it's not easy to handle,
and if you're add-only, it's,
well, it's not even a choice.
You do not need to do that.
So easiest change, if
you can ask your clients,
&quot;Always recompile,&quot; do that.
It's much easier, you will sleep better.
But sometimes you can't, like I said.
Sometimes you maintain
the low-level library
and your clients will call you and say,
all right, there is a
security issue in your binary.
I need a binary fix by tomorrow,
and I need a binary fix
that will not requires me
to rebuild everything I
based on your product.
And if you have that,
you have to find a way.
And that's ABI, binary compatibility.
So my suggestion in that case,
if you want to take binary
compatibility into account
when you publish a library,
is that you adapt semver
to talk about that.
Because semver only cares about API,
because ABI is, well, a C++ concern.
So basically, what I
would suggest is that,
if you break the API or the ABI,
you say it's a major change.
People cannot expect to absorb the binary.
People cannot expect
their code to compile,
they have to do something.
If you only made backward
compatible change,
it's a minor release.
You just changed something,
but people can safely binary upgrade.
They can simply recompile
without changing their code, it will work.
And of course, there's the patch,
which is I did not change anything
that's a part of the contract.
I just fixed security issues,
I just improved the performance,
I just done internal refactoring.
No symbol have changed,
nothing has changed in the ABI or the API.
It's just a patch, go for it, it's safe.
What about dependencies?
That's the part when the binary
compatibility gets tricky.
Is that, well, if you
change the major revision
of a dependency, well, most of the time,
that means that your API changed.
Because people who built you
will have to rebuild again,
and possibly adapt the code.
Maybe you, maybe the
library you exposed in your,
thank you.
Maybe the library you use as a public type
has changed its API too,
so people will have to adapt.
I would say it's a probably,
it would break your API.
And it can also break your ABI, of course.
If one of your dependency has a new ABI?
Well, your clients will
probably also know about it,
because they will get some errors.
And of course, if you
change the major revision
of a private dependency, it's also mostly,
probably a breaking change
for you, in your ABI.
Because your binary,
if it just upswept your binary
and nothing else in
production, it won't work
because the dependency
expected only the same.
It's a tough subject, I wish I had
more time to talk about it
but like most people say,
usually that comes to a package manager,
or to some avier or artillery.
Can I do more than that?
Can I do more than just advertise people
that I changed something?
Because changelog is good,
documentation is good,
bumping a version to signal people
to read the documentation is good.
Can you do more? Yeah, of course.
You can go the extra mile.
You can provide people
with migration script.
Like a Clang script, for example,
or anything else, even maybe a sed.
Now I don't think a sed
would be maybe enough, but.
You know, any kind of script
that maybe people can use to just upgrade,
that would be nice.
Because the problem is, if
you break the API too often?
Well, you know people,
us developers we're lazy.
We don't have to, we don't
like to do work we can avoid,
so we just don't upgrade
if we can avoid it.
So if you provide people with
scripts that can help them
switch painlessly to the new
version, they will thank you.
And the more they do,
the less you will get
support requests for all the release.
In the future, I don't
have much time left,
so I'll go right over it.
Basically, two things
might impact this talk.
That might be the contracts,
because we may finally have something
to put, at least more part of
the left-turn external parts
of the API into the compiler.
We may have some options to tell users,
Okay, that part changed.
And maybe you will not
have to break anything
if you changed the contract.
You may be able to rely on
the compiler to tell users
that No, they cannot
expect the same thing.
And of course, if modules come
and if people may start
distributing, not headers,
but only the binary modules
plus maybe the library,
and that might change the
way you distribute software,
or the way you document stuff.
For example, if you have only
modules and no more headers,
maybe they will never have an option
to see code inside the header,
so no documentation, nothing.
They will have to find another source
to detect that something has changed.
Okay, now it's time to wake up,
and see if you followed everything.
Because as Beyan told us,
&quot;If you tell student that
there will be a test,&quot;
&quot;they will only study for the test.&quot;
So I don't tell you beforehand.
Okay, let's go.
Basically, every time I have a change,
you tell me is that a breaking change?
Did I break the API, did I break the ABI?
Did I change any of them,
did I change nothing?
All right, first one: what did I break?
Did I break the API?
- [Student] Yes.
Yeah, yeah, basically I did, yeah.
Did I break the ABI?
- [Student] Yeah.
Also, yeah great, I broke everything.
Well that happens, yeah.
A new member, you broke everything.
Okay, int too long.
Did I break the API?
- [Student] Maybe, yeah.
Maybe. Well, I would say no,
because technically I'm
just accepting more values.
But it's backward compatible.
I changed the API, but I
don't think I broke it.
But I broke the ABI
because it's not the same
binary signature for my new code.
Okay, I have an A structure
and I struct two members.
Did the API change?
Yes, no? No, the answer is no.
No, it's just names and
the compiler does not care
about the order of names,
fortunately for us.
C++ is not a language where you,
the offsets have an
impact on the compiler.
But I changed the order so
the ABI is completely broken.
Okay, now I reorder two methods.
Did I break something?
James?
- [James] Can you go back
to the previous slide?
- Yeah.
- [James] So this actually
is a break in API change,
because for example, you can aggregate
initialize a struct A instance,
and so now you've broken all
those aggregate initializers.
- Oh. Yeah, nice one.
You said no heckle.
That may be the first
one I've heard this talk.
I did not read the fine print,
I did not read the contract, my fault.
Okay, and this one?
Yay, I didn't change, I
didn't break anything.
I just reorder two members, no problem.
- [Student] Excuse me,
could you go back one?
- Yeah. (laughter)
- [Student] What if you take,
for example, your starting address
is a member function for something else?
- That's not an issue.
- [Student] But it's breaking
- They are not stored
inside the structure,
they're just names.
That has no impact.
- [Student] Pointer members.
- [Student] It's more the ABI.
- [Student] Yeah, point is
still a member function.
- [Student] Why not just take
your library and swap it?
- No, because a member function,
they don't have an address
that depends on your object.
It's just a function with the
first document being this.
It's not the vtable.
- [Student] You can look
it up by name, right?
- Yeah, yeah.
- [Student] The symbol didn't change,
so we could still could
look it up by name.
- Okay, this one is my favorite.
Before that, my function returned the sum,
and now it returns the max.
- [Student] Evil.
- Yeah, exactly. Evil.
It's an invisible breaking API change.
What are you trying to achieve here?
Are you just trolling me?
That doesn't troll me, that makes me mad.
Somebody will pay for this.
Okay, this one is the one you referred to.
In this case, I changed the
vtable so I broke the ABI.
Okay, this one is quite tricky
and it only works on my machine,
so the answer will depend on your machine.
And the answer is, on my machine it works.
Because, you know if I had
two bytes after a Boolean,
the alignment rules on x86-64 bit,
will say that the layout of
the structure is still the same
for all the previous members.
So maybe I did not change the ABI,
but you notice the star?
I would not rely on it.
I think there is a talk,
maybe tomorrow or today,
about what you can do to avoid ABI change
in that kind of thing.
That's something that might save you,
but most of the time it
will just come and bite you,
so you did not hear that from me.
- [Student] That has the same problem
that he mentioned before.
- Yeah, also that.
- [Student] Okay.
- Okay, now.
This one, breaking?
What did I break?
Did I break anything?
(student answers)
Yeah, I broke the ABI.
The API is still, well,
backward compatible
because I have a default argument,
but the ABI is not the same.
One more argument, not the same name.
Well, easy.
I renamed the function.
Well, obviously then nothing would work.
I don't know what people would expect.
Okay.
Did I break something?
- [Student] The API.
- Yeah, exactly, I broke the API.
The name is not the same,
but the offset is the same.
And since the ABI don't see names,
they see offsets and sizes, it's fine.
Okay, this one may be
a bit harder to read,
but basically it's just pretty similar
to the one that I shown before.
The API is the same,
but I renamed an internal
implementation function,
which has to be exported and
so I broke the ABI again.
Okay, so I've been told
that it's nice to end a talk
with a nice quote, so.
You might have heard
some variation of that.
Is that &quot;No system became successful&quot;
&quot;by breaking backward compatibility.&quot;
to which I will add my personal quote,
&quot;Especially if you did not
warn people beforehand.&quot;
Remember, Versioning
is about communication
between maintainer and
users, so talk to them.
Tell them when you break their stuff.
If you have to break
something, break it hard.
Do not break it silently, thank you,
and really talk to them.
Tell them when you change something.
Thank you.
(audience applause)
We have about five or maybe
more minutes for questions,
so if you want, you have two mics.
(student speaking in audience)
- Matheiu] Sorry, is this thing on?
- [James] No.
- [Matheiu] Okay, I just repeat.
- [Student] To comment,
- [Matheiu] Don't have the green, wait.
- [Student] GCC also has a way
to specify which assembles
it wants to export
and which you don't.
It's program visibility something.
- I'm sorry, I did not get that.
- [Student] GCC has a way to specify
which assembles you want
to export from leverand.
- Yeah, yeah. There are
two ways you can do that.
On Windows, James show us today
that there is the export list.
On Windows, on Unix there
is the advisability setting
on the compiler that can tell
that you should change
the behavior to export.
It's quite, it's quite
painful to use by hand,
but I think you can use Cmake
or maybe a verbial
system to do that for you
and change the default.
But the default is at
everything is visible
and you have to use the dash
visibility toggle to change that.
(tapping mic)
- [Student] Can you go back to that slide
where you map a semver to C++ changes?
I have a question about that.
- You mean the one with the mingling?
- [Student] No, no, no.
Where you say, you know,
change this part of semver
if you break this end.
- Okay, oh tell me.
The one about semver, right?
- [James] Yeah.
- This one.
[Student] Yeah.
- Okay.
- [Student] So to me as
a user of your library,
it seems like the last
two are indistinguishable.
You didn't break anything, in fact,
it's not even clear why you would,
you said there's no change.
Why would you inclement the patch?
Well, technically, like I said,
it's because you have to do
some internal refactoring,
so that has no impact on users,
but you might want to
push that code anyway,
because we are all maintainers.
Sometimes there are old
code we want to refactor,
or change that has no impact on anybody.
- [Student] But it's the
same as the second one,
non-breaking change, right?
(students talking)
- No, because you can go back
if you want, technically speaking.
I don't recommend that,
but sometimes people,
they want to downgrade.
And with a patch revision,
it's safe to downgrade,
technically speaking.
Usually you don't do that,
but sometimes you push a refactoring
and it ends up with bugs.
People might want to know if it's safe
to go back one revision, if
they have to for some reason.
Especially, which is one of the problem
with Versioning at a scale,
is that you have two restriction
from the diamonds somewhere
that want two different revision.
You might have to settle
for the oldest one, for some reason.
And with that you can
tell, okay it's possible.
It's not ideal, I won't say that.
But sometimes you want to say,
okay I can downgrade because
there's a critical bug
in the latest that has not been fixed yet.
It's becoming more and more frequent today
because we have faster release cycles,
but it can still happen.
- [Student] Thanks.
- [Student] Second comment.
Sometimes when you int connect
degrees, time, or functions,
it's also breaking change.
For example, if a function
compares to strings and it's guaranteed
to run tilda, not tilda, theta m.
And if you optimize it to return early,
if it finds some smudge, it can break,
it can be breaking change.
If for security, because
hackers can compile time.
- Oh, well, I guess that depends.
Did you guarantee in the past
that your function will
take at least some time?
If you did, well yeah, you broke the API.
But if you did not take any guarantee,
well, people base their stuff
on implementation details,
and as we've all been told
countless times, yeah.
Well, you shouldn't do that.
Thank you very much.
(applause)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>