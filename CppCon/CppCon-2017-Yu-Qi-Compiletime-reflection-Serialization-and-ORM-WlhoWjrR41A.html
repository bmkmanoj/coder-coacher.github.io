<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Yu Qi “Compile-time reflection, Serialization and ORM” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Yu Qi “Compile-time reflection, Serialization and ORM” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Yu Qi “Compile-time reflection, Serialization and ORM”</b></h2><h5 class="post__date">2017-10-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WlhoWjrR41A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Hello, everyone.
Welcome to my session.
Today, I will talk about
compile time reflection,
serialization, and ORM.
This is an outline of my session.
So first, I will introduce
some basic concepts
about reflection.
Then I will talk about the,
the implementation and the application
of compile time reflection.
And last, I will show you some possible
application prospects.
So what is reflection.
Reflection is a mechanism
that gets internal information
of a class by metadata.
So what is metadata?
Metadata is data that
describes other data.
The main feature of metadata
is self-description.
Let's look at some classic metadata.
Look at the picture.
The left picture is xml schema.
The schema defines xml.
Admin's name, type, and the sequence.
The right picture is a data table.
The table also defines the fuse.
Name, type, and sequence.
If we gather metadata, we can
do some interesting things.
Yeah, for example, we can
transform the metadata
to just an xml or some other format.
Of course, we will use
reflection to map the data.
And metadata is a key point.
There are some benefits of reflection.
Reflecting can make our
application more flexible
and can decouple the visits
of an object and the metadata.
Also, it can help us simplify our code.
Next, I will give you an
example to show the benefits.
This is a serialization function.
If we don't use reflection,
we have to write
a lot of applicable codes,
it's very over-elaborate and error prone.
We hope the code can be
automatically generated,
and reflection can help us do that.
This is an example, we used reflection.
If we use reflection,
we don't write the
over-elaborate code anymore.
Everything is automatic.
And we can show you the behavior.
For example, we can
transform the object to JSON.
And we can transform it to xml.
And you didn't modify the object at all.
So it's very flexible.
Next, I will talk about the implementation
of our compile time reflection.
In this section, I will talk about
the technical thought and
the concrete implementation
and there's some limitations,
and the proposals about reflection.
Yeah, I use some modest cloud
features and the macros.
Maybe many people don't like macro
because they look ugly, right?
But it can help us a lot.
Later, I will,
I will introduce some macros.
The macros will be used later.
This is the first macro.
This macro helps us to count
the variadic arguments.
If we pass one arguments,
the result is one.
If we pass two arguments,
the result is two.
Let's look at the process.
If we pass one argument after replacement,
we'll get macro RN.
And soon, we can give you
the value of N is one.
When we pass two arguments
after replacement,
we will deduce the value, and it's two.
So is that clear?
Okay.
Let's look, oh, there is a
detail we should pay attention.
Because the variadic
arguments' expand manner
is different between with
the studio and the GCC,
so we need a wrapper macro.
Here, we need a wrapper macro
to wrap the variadic arguments.
And it is also okay, in GCC.
Let's look at the second macro.
This macro is very simple.
It's just to collect the arguments.
We can collect the
arguments by comma, here.
Is that clear, okay.
Let's look at the last macro.
This macro helps us to make our array.
In this macro, we'll use
the former two macros.
The first macro, we can
answer, the arguments number.
When we get arguments number,
we can define a standard array
here, this is the nth value.
And soon, we use the second macro.
This macro will collect the arguments
so we can use the screen to
initialize the standard array.
Yeah, when we pass to T, A, and B,
we will generate a repeat,
and it has two elements,
string A and B.
So these are all the
macros we will use later.
Before I talk about the technical thought,
I'd like to introduce some
existing reflection libraries,
such as magic_get,
boost.fusion, and boost.hana.
Let's look at magic_get.
It's really magic.
You don't need to write extra code
and you can fit the field by index.
It's very cool.
But there are some limitations.
The first limitations, magic_get
just supports POD type.
If you want to support all types,
maybe magic_get is not a good choice.
And the other limitation is
magic_get flattens the array.
That means if the object was reflected,
it is different from the original object.
So if you want to support all types,
maybe you should use boost.fusion.
This is boost.fusion.
You need to define a macro,
and then you can reflect the object.
You can for each of the object fields
and get the field by index,
get the field name by index.
I think boost.fusion is good enough.
Maybe a small problem is that
the code is not very simple.
Because you have to make
a boost mprn at first.
Maybe we want to pass in lambda directory.
Compare with boost.hana, I
think hana is more simple.
Yeah, if you want to use
boost.hana to reflect an object,
do you see, it's similar.
You also need to define a macro.
And you need to pass the
object type and the fields.
And then you can for each object.
But there is still a small problem.
Here, boost.hana lost
the sequence information.
Sometimes, we need the
sequence information.
Later, I will talk about this point.
Okay, and this new code is a macro.
This macro does many things,
and makes us carry flags for the object.
This is one of the 56 macros.
It is a bit complicated, right?
And there are 55 more macros.
My idea is similar with boost.hana,
but their concrete
implementation is different.
My code is much more shorter.
The whole code is less than 500 lines.
And boost.hana's code is
more than 3,000 lines.
Last, I will, yeah, I
will tell you how to,
how to implement compile time reflection.
There are two steps.
The first step is to define the metadata.
I mentioned before, the
metadata is a key point.
If you have the metadata, you can reflect
and when you define the metadata,
you need to provide some
operations of metadata.
Such as get the value by index,
get the field name by index,
or for each of the fields.
And we hope our reflection library
can support all types, not just POD type.
Also, we expect we can fit
this object non-intrusive,
it's very important.
You don't need to change the object.
Okay, let's look at
how to define metadata.
I will give you a very simple
example to show the thought.
There is a template class member binding.
This member binding has three parameters.
The first parameter is type of the field.
And the second parameter
is the field's reference is a pointer.
The last parameter is the sequence.
So member binding can represent a field.
And we need to pack all the fields,
so we use a variatic template class pack
to pack all the fields.
Now, let's look at how to define
the metadata of an object.
There is an object aggregate.
There are two elements.
The first field is integer and
the second field is string.
Now, we specialize the template class
and pass the reflected object type.
Then we put the field's type
into the member binding.
Next, the field's value
and the field's sequence.
You can also define the
field's name in our array.
Now, we have finished the
definition of metadata
of aggregate.
And then we can use the metadata
to fit it into the internal information.
Here, you can print the
object fields by metadata.
Because we have packed all the fields
in a variatic template class
so we can recursive the pack.
And we can get a name by index
and the definitive value.
So we have to do that.
We can reflect the object aggregate.
And this idea is from
last year's Simply Comp.
There is some,
oh, here, I make a summary.
The first step saves the
reflected object type.
The second step is pack all the fields.
And we also need to define a string array
to hold the field's name.
And then we can visit all the
fields by recursive for each.
However, there are some problems.
This is the definition
of object aggregate.
If we want to reflect other objects,
we have to write a similar code.
So it's also very elaborate.
And we hope the code can be automatic.
So who can help us?
The macros, the macros can help us
generate the code automatically.
This is other limitations.
How to do that, the macro.
The macro will automatically
pack all the fields.
And generate a string array
to hold all the fields' names.
And we also can provide
generic for each aggregate
and some other measure.
Let's look at how to utilize the macro
to generate the metadata.
I think this macro is familiar with you
because I mentioned before,
at first, we need to
generate a string array
to hold all the fields.
And this macro can help us do that.
The next macro is a key point.
How to make the metadata.
We need to pass three parts of arguments.
The first is the object name.
And the number of arguments,
and the arguments themselves.
Okay, this is the concrete macro.
And the make arg lists
macro is a key point.
Here, we will generate a sequence.
The sequence, we can collect
the fields reference by comma.
Then we put the sequence into a tuple.
And now, we can pack all
the fields' reference.
This is a user macro.
You just need to pass the
object type and the field.
Just like boost.hana or fusion.
And then we can count the number
and it packs the fields'
reference into a tuple.
So we have automatically
generated metadata.
And the library supports
120 fields at most.
Of course, you can expand
the fields as you need.
Let's compare with
the automatic definition of metadata.
Before, we have to handwrite lots of code
to define the metadata of an object.
Now, we can automatically
generate the metadata.
The code is much more shorter
and the usage is much more simple.
Here, maybe someone thinks
the C++ 17 new feature,
structure bind, can help
us to reflect object.
But I don't think so
because structure bind
needs the fields of the object.
If you don't know the number
of the object's fields,
you can't use structure bind.
You cannot construct the structure bind.
And someone used this code,
the first, you have to
get the field number.
It's a variatic problem,
so I don't think structure
binding can help us.
Okay, let's look at the
operations of metadata.
Here, this function can
return the field's number.
And we use a trait to
check if the object is
a reflected object or not.
Here, I used T.
And this function will get
the field's name by index.
And this, we can get a value by index.
So things become very simple.
This is for each metadata.
Because we have pack order
object fields, you know, tuple.
So we just need it for each tuple.
So the sort is very clear and simple.
Here, I use,
I use fold expression.
Source class 17's new feature.
If we don't use the fold expression,
we have to write this swath of code.
Swath of code.
Yeah, fold expression makes our code
much more shorter and simple.
Okay, let's look at an example.
This example shows how to
use the reflection memory.
You can get name by index, get a value.
And for each object here, we
add the index information.
It is used, it will be used later.
Because it's useful.
And the code is on the GitHub.
And the serial annotation engine,
it now supports JSON, xml, msgpack.
And it can be extended easily
to support whatever you want.
But there's some limitations.
The first limitation is you
can't reflect member functions.
You can reflect private members.
Because we need to utilize
the macro to pack the fields
of the object.
So we can't fit in the private
members and the functions.
Now, there are some proposals.
The proposals, provide,
reflect export, and provide some measure
to get the private members
and member functions.
We need the compiler's help.
Furthermore, there is meta class,
the meta class is even more powerful.
And we hope the proposals can become true
as early as possible.
Before the proposals come true,
we need practical and
cross-platform reflection library.
So this is their motivation
of the reflection library.
Next, I will talk about the applications
of compile time reflection.
We can use compile time reflection
to develop a serialized engine
in the ORM library.
The serialization engine
can serialize the metadata
to any format, not just an xml or msgpack.
Let's look at the example.
Here, we can use the library
to serialize an object to
JSON and to xml or msgpack.
Let's look at the code,
how to transform the metadata to JSON.
This is the JSON function.
We, for each object,
because we have to
provide for each measure
to visit all the fields.
So we adjust for each of the objects.
And we can get the length of the field,
the value of the field.
So it's very easy to make a
JSON key to make a JSON value.
And there is a detail we
should pay attention to.
The field may be a struct, right,
not just the basic types.
Maybe reflect objects so
we need recursive to call their JSON,
to JSON measure, is for the nested struct.
Here, I used new features,
if constant export.
Because the type may be reflection type,
reflected object.
So that makes the JSON
keys also very simple
because we can get the field name.
The serialize function is also simple,
and the sort is similar.
We just for each of the objects,
and we know the type of the field,
so we can serialize the binder
data to the field value.
I want to say more about
if constant export.
If we don't use constant export,
we have to write it in native
code, that thing is ugly.
I like this feature, it's really helpful.
Okay, let's look at how
to make an ORM library.
ORM means you can map the
object to a data table
and you can also map the
data table to an object.
Look at the example.
We query a table and map
the data table to an object,
an object list.
And the measure, the sort is also similar.
Oh, you can find it on the GitHub.
And ORM library now has
support circle light.
And I will support my circle
and the post research later.
This is to serialize function.
We can for each the object
and for each the row of the data table
and map the column data to the field
because you have to know the
field type and the field value,
so it's very easy.
And you can also use a reflection
to generate the circle
script automatically.
This function is also useful
because it can generate the
subscript automatically.
Because maybe you will
change the data table,
but if you use the automatically measure,
you don't need to change the script
because it can be generated automatically.
So it's also very useful
to develop the ORM library.
Okay, next I will show
you some possible prospect
of a compile time reflection,
besides the ORM engine and ORM,
we can develop DSL or
data binding implications,
and the protocols adaptor.
Yeah, you can transform the
C++ struct to C sharp class
or Java class because you have,
you can get the field's
type and the field's name.
So you can use it to map
the C++ type to C sharp type
or Java type.
So you can use it to develop a IDL tool.
You can make a DSL language
using the metadata.
The next possible application
is data binding application.
Because we have to know
the field's information,
so we can easily generate
the key value GUI.
You don't need to drag your toes,
it's very convenient.
The other application
is protocol adaptors.
Because we can serialize
the input data such as JSON
to an object.
And then we can serialize
the object to xml or msgpack
or some special binary data as you want.
And this adaptor is really useful
because you can adapt different protocols.
So I think there are more prospects
for compile time reflection.
If you find new ideas, please tell me.
Okay, any questions.
Yes?
- [Man] Do you know any way to
have compile time reflection
on lambda closures.
Lambda closure is an object,
and if you want to serialize it,
we need somehow to access it.
So do you know of such a method?
I'm sorry, can you repeat it slowly.
- [Man] I'm speaking
about lambda closures.
Lambda closures.
Lambda function.
Lambda function.
- [Man] But at the moment,
when we instantiate it
with some capture,
this capture goes to an object
automatically created for us
known as lambda closure object.
The question is do you know
how to serialize this object
or to reflect this object.
So your question is how
to serialize the lambda?
Lambda closure.
Lambda closure.
Serialize.
- [Man] Serialize or reflect, whatever.
I don't--
Oh yeah, maybe I get your question.
So you mean how to reflect the closure
or a lambda, right?
- [Man] Yes, yes, yes.
So I think maybe we can't
because the lambda is anonymous function.
- [Man] What I am speaking about,
as soon as we have lambda with a capture,
then we have some data is
in this lambda closure.
So as soon as we wrote
square bracket, A, B, C,
this A, B, C goes into
the context of lambda.
And the sync is a data member,
which is potentially serializable
or potentially reflectable.
The big question is how to do it.
Okay, your problem is
how to reflect the
captured variable, right?
Reflect the captured variable of lambda.
- [Man] Yes, yes, yes.
The lambda captures the variable,
how to reflect the variables.
Oh, I never thought about
it, I have no idea now.
Okay.
Any other questions?
Okay, thank you.
(applause)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>