<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Pramod Gupta “C++ Multi-dimensional Arrays...” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Pramod Gupta “C++ Multi-dimensional Arrays...” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Pramod Gupta “C++ Multi-dimensional Arrays...”</b></h2><h5 class="post__date">2015-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CPPX4kwqh80" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm a research scientist at the
University of Washington and in the
Department of astronomy and what I want
to do here is quickly just show you the
kind of things we do with C++ so this is
from a C++ program it's a simulation of
a protoplanetary disk so right in the
center there's a star and there's this
gas spinning around it and we kind of
try to see how planets form so something
like this happened few billion years ago
with the with the solar system and the
bright spots are where there is more
matter so you can kind of see finally
you know it starts off sort of
homogeneous and it becomes sort of you
know sort of planets are being formed as
time goes on so these are kind of some
of the things that we do with C++ and
what I would like to talk today is about
multi-dimensional arrays which are kind
of critical to that type of simulation
that we do and one of the things so so
we use C++ because it's easy to learn
and easy to use but actually it's
because it's resource constrained yeah
so that's one of the use cases for C++
if you are resource constrained and you
know you are concerned about time and
memory and so on so then the language to
use is essentially if you know Fortran C
or C++ as I tell my students the more
expensive the computer that you're
running your code on the older is the
language which they use on it so the
most expensive computers you know tend
to run C C++ or Fortran and this is sort
of a generic thing because time is
critical and memory is critical and so
on and so usually I'm climbing the
mountain on the on the left hand side
but sometimes I do climb the mountain on
the right hand side and you know I don't
know if the book authors choose these
front covers or the
or the or the you know the publish
excuse its but they are appropriate to
the topic that these books contain okay
so multi-dimensional arrays in C++ so
what's the big deal now in lot of
systems programming you don't really see
multi-dimensional array is like you know
like one dimension is big enough and so
C and C++ have tended to kind of focus
on on that and in physics and applied
math and many of the scientific
computing field it's very common to a
multi dimensional arrays three four
three two and three are very common and
you even have higher ones you know we
are in three space dimensions and one
time dimension so so things like this
like you know like the temperature field
at a point you have a grid of point and
then you have the temperature at each a
point spin model on on 3d lattice in
fluid dynamics three components of the
velocity at a point in a fluid so these
are very common and so passing
multi-dimensional arrays to functions is
very critical for computational physics
applied math and scientific computing in
general and you know in linear algebra a
matrix is a two-dimensional array and a
matrix inversion function which needs to
notice each of the size of of the
dimension would be like you know at
compile time would be of limited use
now other languages have supported this
feature for decades so it's not exactly
you know some kind of brand new
cutting-edge feature so see 99 Java C
sharp so even the general-purpose
languages support this for you know over
15 years and scientific programming
languages like Fortran MATLAB and are
they have supported this obviously for
decades like you know like Fortran I
supported this for like 50 years so
there's no real you know unknown aspects
of this feature but C++ is the only
major programming language which does
not support this feature and the absence
of this feature increases the barrier to
moving from C X they try to C++ and for
small teams and grad students it limits
their usage of C++ because
you know when they're just beginning to
program they would like this basic
feature if they're doing scientific
computing now this does not mean that
C++ is not used in scientific computing
in fact it's used in a lot of places
usually it's the very big organizations
like Sir
Jet Propulsion lab LSST large-scale
synoptic telescope they were big a group
here at the unity of Washington LMB the
lab for molecular biology in Cambridge
which is I don't know if you know about
it but it's sort of called like the
Nobel Prize Factory they were like
dozens of them and so these very large
organizations tend to use C++ and if C++
is used for scientific computing one of
the first tasks is to make a class for
multi-dimensional arrays and and so if
you have one of these really big
organizations like if you're really big
like some of JPL you can actually get
dr. Strauss trip himself to help you out
with your C++ and you know he's actively
involved with these really big
organizations and if you're doing
something which is really small scale
then maybe you don't need you know you
don't have the kind of resource
constraints of C++ but if you have
something in the middle kind of like you
know as the it's often said like the
middle class you know so if you are in
that regime then you kind of like you
know would like certain more it'd be
preferable to have certain features sort
of feature already inbuilt in the
language so that you can not have to
create your own multi-dimensional array
class so all these organization like
LSST code for astronomical I encode for
cryo-electron microscopy they make their
own multi-dimensional array classes and
it's sort of reinventing the wheel over
and over again so since I'm from the
Astronomy Department here the picture of
telescope under construction in Chile
and you know you can get the size of the
whole building and the telescope from
the size of the pickup truck
so you that gives you a scale of what
it's all about and if we talk about the
very big we should talk about the very
little and this is something from
cryo-electron microscopy where they use
two-dimensional images of
two-dimensional electron
images from different directions to
reconstruct the structure of the
molecule or the virus and so the output
of all these projects is a huge amount
of data which is then processed with C++
so so it's being used in a lot of field
fields so what exactly is our concern
here the point is that this code is
valid c99 but it's not valid C++ so
essentially if you have this array in
red being passed to a function in C++
you need to know N and M at compile time
and in C you don't need to do that and
certainly in the other languages you
don't need to do that so this is sort of
the you know limitation which
essentially ensures that the first time
you start using C++ for scientific
computing you need to make your own
multi-dimensional array class or you
need to like you know get some standard
some non-standard library from somewhere
now this is valid C 99 and C++ so if so
you can leave the first dimension of the
array B unknown at compile time but the
second and all the later dimensions have
to be known at compile time and that
sort of is you know a bit problematic if
you are constrained all the time so that
code is correct only if M is equal to 3
so you need like you know different code
each time you have a different M now C
is this feature called variable-length
arrays and C variable-length arrays this
is from C 99 so C variable-length arrays
are not allowed by a compiler for c++
even though the same compiler supports
them for C which is kind of you know so
they're actively the compiler says no if
you have a dot CPP file I'm not going to
allow you to do this even though I know
how to do this but if your file is dot
CPP you know no can do and you know GCC
clang ICC so these are all the compilers
you know I mean so it's it's basically
really enforced here they are being
really strict about it they can give you
different types of extensions but you
know they're not going to allow you to
use VLA even though they
have the ability to allow you to do that
now see variable-length arrays are more
general than needed for just merely
passing multi-dimensional arrays to
functions like this is valid c99 but not
valid C++ and you know what you're doing
is essentially you're doing a you know
you can call it a malloc or a new within
that function so you just got N and M
from the as function parameters but
inside it you're allocating space and
this actually is you know the argument
against VLA that if N and M are large
enough then you can you know that code
can crash without throwing exception or
returning error code etc and at this one
of the main arguments but you know that
argument does not hold just for passing
arrays to functions because that memory
has been allocated somewhere else
so the aside if a future C++ standard
allowed the above subset of VLA it would
really reduce the barrier in moving from
other languages like C to C++ so how
about the C++ standard library now this
is a direct quote from the boost multi
array manual and so they say there's you
know lots of generic containers in the
standard library but no
multi-dimensional array type and then
they say you can use standard vector
standard vector double etcetera but they
themselves say that the resulting
interface is unwieldy and the memory
overhead is quite high so you know lots
of non-standard libraries have been made
to tackle this issue certainly all these
various projects I talk to you about
they have their own you know
multi-dimensional array classes which
are tightly knit with their own code and
these are some of the public lis
available standard libraries which is
Armadillo eigen bits plus plus boost dot
multi array so they have lots of feature
very large very complex they are good
for linear algebra you know matrix
algebra two-dimensional things in many
cases they're really good they're
optimized for that so this library is
from Austria
and it has its focuses only on 2d arrays
and 3d arrays which is kind of limiting
many times and this one focuses only on
2d arrays this from France and it's also
basically focused on linear algebra so
this is you know very strongly focused
on linear algebra eigenvalue finding and
things like that this one is interesting
it splits plus plus and it has very
large and very complex in fact it was
100 page manual and up to 11 dimensions
are supported which is fine for most
physics and applied math and scientific
computing applications but it's really
large you know it I mean it allows you
to like we'll come to it later but
there's a grow major and you know a
column major way of addressing these
arrays and this one allows you to do all
the n factorial different ways you can
access it so it has a huge amount of
generality but you know if you just want
the basic multi-dimensional array class
it's a bit too large and then there's
Boost dot Multi array which is actually
inspired by Blitz plus plus so it also
has lots of features and and it has a
relatively so it has all the you know
aspects of Blitz plus plus but it has a
very it also has a complicated syntax so
well at least from you know scientific
computing point of view compared to
other languages so if you look at this
code here they're already three classes
three types of objects that you need you
you need the array itself the first type
def then you need index and then you
know you need extends and so even though
the code the triple loop there looks
kind of familiar it's i JK are not you
know the traditional integers but they
really index objects of the index class
and so the drawbacks of the existing
library is for a lot of code in
scientific computing is that they're
very large and complex so
you know you need to your core become
dependent on a large non-standard
library and you know with hundred page
manuals and so on and so the usage of
the library is limited to those who are
willing to install it and learn from it
and in some cases the libraries may not
be actively maintained but they are so
complicated that you'd have to spend a
lot of time if you really wanted to
maintain them yourself so I wrote a
library based on what is available in
you know commonly available in lots of
these other languages like C and Fortran
and so on and the idea was to have a
minimal minimalistic library so you know
it should have at least the features
what native arrays have in other
languages and it should fill the gap
between C++ arrays which are very very
limited and you know these huge large
libraries and it should be convenient to
include with applications the code
should be you know readable code so the
user can convince himself that it's
correct like the previous speaker
pointed out he looked at some header
files and you know it works very
complicated even if they're doing
ordinary things and so if you are going
to use that type of code it's bit
problematic if you have to actually
debug anything and the efficiency should
be similar to native arrays in C++ and
it should be easy to debug array index
out of bounds because that is a very
common problem one you know we know from
experience so the choices are that it
should be easy to declare and use the
array you should not have to look at a
manual I mean you don't need to look at
a manual in these other languages and it
should be convenient to include so
single header or file should be enough
it should be efficient because you know
if it's not efficient it's not going to
be able to compete on those you know
enormous machines 10,000 core machines
it's as I said like you know all these
machines use huge amount of power and so
we are going to do a computation which
is going to use a lot of power you want
it to be efficient so it's not just a
time issue it's a power issue you'd like
compile time option to turn on array
bounds checking
and a compiled up option for C order or
Fortran order so these are the design
choices that I made so I would like to
prohibit the copy constructor and
assignment operator so the semantics are
similar to C++ native arrays and this
you know removes the problem of people
passing arrays you know like a thousand
by thousand or a million by million
array and you know complaining it's slow
so you must pass multi-dimensional
arrays by reference there's a member
function at for subscripting instead of
overloading operator the subscripting
operator if array bounds checking is on
you have a segmentation fault on error
and then you can find that you know
problematic line in your debugger so it
makes it easy to debug and there's no
default constructor since
multi-dimensional array without size
specified for each dimension has no
meaning so if you really need an array
of arrays you should use a higher
dimensional array and not you know
complicate things and then there's no
virtual member functions cos is not
designed for inheritance you know it's
supposed to be like used as is you can
use in you can use composition if you
want to use the array and do some you
know other fancy tricks put that in your
class and then do what you want the
maximum number of dimension is 7
essentially because higher dimension
arrays are extremely rare the memory
usage increases very rapidly so a lot of
these other array classes with well some
of them where they allow you to have
arbitrary number of dimensions it's
really only of theoretical importance
because beyond a few dimensions your
memory usage increases rapidly but it's
easy to modify the code if you want to
like have like you know array 8d etc
this is the user manual really it could
be put on one page but I'm using a big
font and you know you declare array
array to d-double you know the sizes you
use it by B dot at 3 comma 4 is 3.14 and
you can send it into a function just by
reference and and you know it's
prohibited there's no copy constructor
so you're not going to make you know the
users even if they are new they are not
going to make a mistake of
you know using the copy constructor here
so and you have two options at
compile-time a bounced check which you
can you know so when you're debugging
and testing your program it'll help you
to find your bugs and you can use the
Fortran order or the or the C order so I
like to call them Fortran order which is
first index moves changes fastest and
the C order where the last index changes
most rapidly you know the official names
are column major and row major and so
here is the same code using this the orc
are a library and you can see it's very
simple so even if you don't have a
manual handy you know you can go home
and write it right away you don't need
to like think what does this mean and
did I get all my classes right etc it's
exactly the same way you would write in
a traditional array and answer
performance so the correct answer to
every performance question is it depends
and it depends on a lot of things CPU
cache size memory this compiler etcetera
you know and so a lot of the big old
stuff that you read you should you know
check it out on your code because the
big old stuff is asymptotic and you may
not be in the asymptotic regime so
actually running the code many times is
the only reliable way of estimating
performance and what I found is that
it's been in few percent of the native
array performance there's a caveat that
the you know number of elements must be
large enough and you know you must be
doing enough computation so if you if
you have very small array then you don't
do any computations at all then the
native arrays have advantage because you
know the compiler understands all about
native arrays and you're not doing
dynamic memory allocation and so on so
this is the things which I told you you
know you prohibit the copy constructor
assignment operator you check that the
sizes are not negative a few basic
functions to give you the sizes you do
array bounds check you have a Fortran
order or a C order and this is just to
point out so if you have like seven
dimensions or
you know essentially you access the
array by a function like this it's
basically a function from multi you know
from X 1 X 2 so on till X 7 and you need
to map it to one value and these F's or
the C's the big uppercase C and the
uppercase F are constructed at the time
when you are constructing the array
there are functions of the size of the
array so to conclude the orc are a
library for multi-dimensional arrays
it's convenient to use and to include
the user manual is a few lines only so
you don't need to spend a lot of time
you can you know look at the code
yourself and convince yourself it's ok
for your needs
it has compile time options for array
bounds checking and for C order or
Fortran order and it has good
performance so it's available on github
and to conclude I'd like to say
questions and this is my picture of my
favorite over carrots it's a
two-dimensional or curry so it's
probably not going to perform that well
but it's still kind of neat so questions
yeah so I've thought a bit about it and
like you know I they seem to be so many
options I would think it would be like I
have to still go and put it up there
like you know but I would go with my
friends tell me like BST is good
essentially because you know so yeah so
if you want to use it either in your you
know proprietary code or in your you
know open source code it's all fine with
me kind of you know I mean the main main
my main reason to do this so you know
I've been waiting for lots of these
standards to come and go and I've been
hoping one day we would have a standard
multi-dimensional array but doesn't look
like it's happening anytime soon
and so I thought I had to do something
about it myself so you know so I'm more
than happy anybody uses it for
proprietary code or for in open source
code etc
I look at the array view and you know
that doesn't seem to own its own memory
it seems to me like a rapping on top of
so if you have erased somewhere and the
point of somewhere you can wrap it
within that but they don't seem to be
you know doing like a real
multi-dimensional array which owns its
own storage and where you don't need to
muck around with pointers yeah so it's
kind of like here you don't need to use
any pointers at all that's right yeah no
because array me who does not own its
memory yeah like the array view is kind
of like you know you you you have a
pointer from somewhere which has its
memory and then you you know construct
the array view giving it that pointer
and some you know space how much
elements you have say here it's totally
standalone yeah so and I'm passing it by
reference so you know the compiler may
be using pointers and so on but if you
look at the code it's the code itself is
very simple yeah and there is yes I
think the point is that from the user
point of view and that's one of my
target audience like users who are new
to C++ and they can use this without
having too much knowledge and it's
difficult to misuse it so you can't like
you know end up passing a whole array
but and having copy semantics kind of
well I did talk to dr. Strauss cope
himself in fact you know I mean you know
I call him dr. Strauss too because
people here seem to call him beyond me
but that seems like calling my
schoolteacher you know my first name but
okay so maybe I should look into that
you know so I tried to look into the
process for that and he told me to look
at the you know array view thing and I
did look at what's on the web and Neil
Mackintosh talk but it didn't seem to me
like you know addressing this
particularly
oh yeah so and I think one of the things
is as I pointed out that for example
this you know limit on say 7 or 15 or
whatever you know so I find a lot of
template code wants to be the most
general everyone but in practice you
know you need to say that if you know
there are limitations on machines in
today and in the next 30 years yeah and
you know if you if your memories if
something n is somewhere you know
occurring an exponential function you
don't need to go to very large n you
know it's like the whole thing with
Fibonacci sequence people do like an e
you know you don't really need to
calculate it you calculate it once and
you're done because you know the amount
of number that you can calculate it so
small so that type of practical thing
yeah fun no that is not a use case in my
situation and but you know these type of
things could be used in MPI programs and
so on where you just you know you're
separate so yeah I share nothing you you
could use it I have not used it but what
I'm saying is it's shared nothing so
it's not a thread concurrent type of
thing you know there's no locking here
there's no tracking of you know and and
it's it's all a private memories private
yeah so you would have to really do some
trickery to you know exercise yeah
okay okay yes I think I suggested and
maybe I'll talk with you afterwards you
find out more about this process like
you know so I'm from the astronomic
department here so it's like I'm not
familiar with a lot of these processes I
also wished the same thing actually not
with boost you know the performance
comparisons I did with were with you
know the native array but so you're
talking about runtime performance or
compilation yeah so so I think that's
one of my concerns yeah like so you know
like so they're two things so one is the
compile time performance you know if
this thing is going to take more compile
time then the scientists own code you
know you're not gonna use it but I think
the other is the runtime performance so
I think I compared it with the native
arrays and it it's doing fine there so
if the boost is similar performance to
native arrays then it would be similar
performance in practice and I think that
yeah regarding the comparison it's true
that you know boost and multi array and
blitz plus plus do a million things more
but a lot of scientific code like so if
the core needs all those functionality
it's great but a lot of code does not
necessarily need all that functionality
you know there's a lot of code being
written in C and Fortran and so on and
they're doing
fine without a lot of that extra
functionality so that's really the you
know focus of this thing so so yeah that
was what decided my you know design
decisions and sort of overall philosophy
yeah I've done a bit of it so the
question is have I done any work on
sparse matrices so I have done a bit of
it for my own use but I went you know
reached a stage where I could sort of
you know make it public yet but I have
looked into that because that's other
thing we have and that occurs in things
like machine learning and so on
we applied machine learning to one of
our astronomic problems and there you
can have a lot of sparse matrices you
know so very high dimensions but really
most of them are you know empty most of
the elements are empty really and so
I've done a bit there but it's not ready
yet it's not a microts they all
functions but they're in line because
they're in a very small I know let's go
to the yeah if death is between you
either you go for an order or see yeah
that's right yeah I won't make it
because I mean this is very scientific
word usually up like like n times N or
something but for instance an audio you
always looking for something similar
there is something like interdictor is
not as ready so you have like a two
stereo channel which is sacred in same
thing and either you have two two
channels behind each other or they're in
turn if this is the same problem like
robots cut a major but okay you have
like interfaces some of these take if
others are not interleave and then I
have to copy from one to the other and
then I need both versions in the same
code oh I see
okay don't want to switch that that one
parameter once and then it's like
hard-coded okay I'll look into that
policy
the edge so he called it edge so this
little confusing maybe if you know the
vector because the vector it does always
bounce shorts even is so even it hmm oh
yeah yeah towards the common things I
just feel like this you know cord is
simpler like you know if whether you use
the you know the you know these type
brackets or the square brackets you know
I think this just seems simpler but I
see your point that people may assume
dudes check yeah he's talking about
other one like you know with the
function type thing yeah yeah I can look
a bit into that because from a tree yeah
you would need to have like a starting
yeah then you return a proxy and then
yeah I think I should probably make it
more you know in the in the two-page
manual it should be written probably
that you know the default is basically
to not check and basically since it's
you know the header is readable it's
right at the top the choice between you
know checking and not checking in
Fortran or not so I'm hoping if people
use it anywhere they would at least open
it up and look at the first few lines
and it could be right
yeah it's mostly because it's easier
than remembering row-major and you know
column-major you know il is it's always
tricky to remember what it really mean
but I think for time is Fortran it's
sort of easy to remember then you know
mnemonic for it is like you know Fortran
is first here so like you know first
index varies fastest and in C you know
it's like odometer so the last index
varies faster so that's kind of like
just to make it easy to remember but you
write that some other target audience it
might be new to them but I should
probably again make a note of that that
so it's sometimes people are porting
code from Fortran or C and they need to
probably know the the ordering you know
if they're putting some code for example
right but if it's 2d it's fine but if
you have like you know 70s then you know
because what it's saying is the last
index or the first and the first one
maybe agree is the row but do we agree
the last one is the column or the second
one is the column if you have a seven
dimensional array yeah so I think that
was part of it like you know so the real
interesting case here is three four five
dimensions yeah
yeah it's just a it's just a formula
being used here for the calculation is
is different you know so and basically
based on what approach you are using
it's just a matter of the way you are
doing the multiplication than addition
and you know it gets slightly more
complicated if you have say seven
dimensions so all these FBF and big seas
are defined that when you're
constructing this array so the array
uses memory equal to the memory are
using and a little bit of more to you
know save these things calculate and
save them once but but usually the aim
here is for larger arrays yeah like you
know which is not common which is common
inside the computing like you know
hundred by hundred or thousand by twelve
I know million by million okay yeah I
agree with that
it's the idea here is to make it easy to
use so that in lot of use cases so I
think if the use case is doing something
which it needs all the features then
boost multi array I think that's
probably you know appropriate but a lot
of new cases don't need all that you
know extra stuff and so for that this
works out fine I guess one last question
and
well the way it works is generally
inside computing at the beginning when
they're writing maybe they don't care
you know that much but gradually when
they go to the supercomputer and run it
over there then they start caring when
they need like you know thousands of
cores so so my opinion always has been
and I try to convince them that you know
if you go with these statically compiled
languages you know you don't need to
change your code six months later in any
dramatic way maybe you need to fiddle a
little bit but because some of them you
know lacks a features like a convenient
multi-dimensional array sometimes they
you know start using some other
languages and then six months later when
they find that it's not enough you know
they can't it's not running fast enough
then they need to kind of you know think
what to do yeah that depends because I
think anything many cases it the kind of
index manipulation in scientific code is
not necessarily just you know AI is
equal to BI type of thing yeah they'll
be like you know AI is equal to the
average of all the different you know bi
is around and so on yeah so it gets
complicated so I'm not so concerned
about you know like its it seems
unlikely the compiler can anticipate all
the possible you know things people do
okay I guess the session is over thanks
a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>