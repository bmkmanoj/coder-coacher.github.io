<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Victor Ciura “Bringing Clang-tidy Magic to Visual Studio C++ Developers” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Victor Ciura “Bringing Clang-tidy Magic to Visual Studio C++ Developers” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Victor Ciura “Bringing Clang-tidy Magic to Visual Studio C++ Developers”</b></h2><h5 class="post__date">2017-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Wl-9ozmxXbo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Good morning, everyone.
My name is Victor Ciura
and I'm Senior Software
Engineer at Caphyon,
working on the Advanced Installer Team.
I've been working on Advanced Installer
for over a decade now.
And currently I spend most of my time
working with my team on improving
the re-packing, the
virtualization capabilities
in Advanced Installer, helping our clients
migrate their Window
to desktop applications
to the modern application
model of the Windows store.
That is UWP AppX packages.
To give you a bit of context
about the project I work on,
Advanced Installer is an ID,
it's a Windows Installer offering tool
that helps developers and IT pros
create and MSI/EXE, App-V
packages and AppX packages.
It's a 14-year-old code-based,
under active development,
about two and-half-million
lines of C++ code,
134 Visual Studio projects
that include executables,
DLLs, static LIBs.
We build everything Visual Studio 2017.
We do about a monthly release
cycle on three week sprints.
We do Windows-only deployment.
And we have strong
Windows SDK dependencies
as our codebase has a
fairly wide API surface area
due to our application domain, of course.
Why am I here?
Well, I Googled this phrase,
(chuckles) a few days back
to check my spelling and found myself
looking at some really disturbing quotes.
(audience laughing)
I see some of you
reaching for your phones,
please don't that.
Cannot compete with this.
(chuckles) I mean, why am I
here at CppCon giving this talk?
Well, our experience
in adopting Clang tools
in traditionally Windows-only
development environment,
we've been in Visual Studio world for
all our professional lives,
has been a very positive
experience for my team.
And we are here to share
some of our experiences
in the journey of trying
to adopt Clang tools,
especially clang-tidy.
And the story I'm about to tell is about
the struggles to get here
as well as the benefits
we encountered and the
large-scale manufacturing
we were able to perform with clang-tidy,
once we set up everything.
Just a bit of a disclaimer,
this talk is not about
Clang versus Visual Studio.
I see some Microsoft people
in the room. (laughs)
So we're an Windows-only development team,
and we're gonna continue being this way.
And we're gonna continue
using both Visual Studio
and Clang tools on the
side to modernize/refactor
and overall improve our code quality.
A bit of a timeline.
I think in this kind of talk,
a case study kind of talk,
very important thing is
to realize the time scale
in order to share the travel
and experience with you
and make sure you know
what you're embarking on
if you would like to
try something similar.
It all started a year ago here at CppCon,
with a Birds of a Feather
session on Clang format.
About that time, we were
thinking about adopting
Clang format for our workflow.
And this session at CppCon last year
gave us the right
motivation and experience
sharing with other people here,
to try to tackle this on.
And we achieved this at
the end of last year.
And it culminated with a
big reformat and STM push
after endless debates on styles then,
(chuckles) configs, of course.
And our current workflow is
basically using Clang format
via Visual Studio extension
with auto-format on save.
That's a free extension
on Windows Marketplace.
Our goals was building on
the success of Clang format.
We gained courage to
experiment with Clang-Tidy.
But this is not a straight
through proposition,
because using Clang
format doesn't require you
to be able to compile
your codebase with Clang,
just needs to be able to
lix it, to organize it.
So embarking on a clang-tidy strip
required that Clang was
able to compile our Windows
codebase.
That compiled fine with
Visual Studio, of course.
Just a note, we were already
on high warning levels, W4
and WX for our projects.
So we were in pretty good shape already,
in terms of warnings and conformance.
But we did encounter
quite a few non-standard
C++ language extensions that if
you can people will use them. (chuckles)
And there was quite a bit of
those and we tried to fix them.
And achieve course compiler
compatibility with Clang.
Of course, we intended to
perform large-scale re-factorings
with modernized modules
and readability modules
from clang-tidy, and we did all that
and also ran code analysis
to find subtle bugs
and fix them.
Just to give you a few example
of stuff we encountered,
non-visual destructor
codes, overload function,
hiding base class methods,
incorrect re-ordering
of number initializes
lists, pessimizing moves
and missing field initializers,
just to name a few.
A lot more, (chuckles) lot more.
A frequent offender, double
user-defined conversions.
We had quite a a few of
those, especially for strings.
And string details.
And we had quite a few of
those and we had to fix
each and every one.
Coming back to the timeline,
we started playing with Clang on Windows
with LLVM 3.9 in January this year.
First commits, fixing, like
I said, warnings and errors.
And to help with that we
created crude automation attempt
with some batch files.
I'll just show you one a little later
to see how simple and naive that was.
And after a month on this workflow,
we needed to upgrade to
something more powerful.
And we implemented the PowerShell script
to help with this, build
and fixing workflow.
In March, our PowerShell
script gained the ability
to run clang-tidy checks as well.
And we did the first
experiments on our source code
on some core libraries.
In April, after only three months,
we were able to compile our whole codebase
with Clang 3.9, with some
default warnings disabled,
to be fair.
And immediately after that, to prevent
further breakage, we
integrated Clang built
into our workflow by creating Jenkins job
to build basically every
SCM change in our codebase.
Later on, we did several
improvements to our PowerShell
automation scrip,
like support for pre-compiled
headers, parallel compilation,
project filters, SDK versioning and so on.
And over the summer continued
experiments with clang-tidy
on our source code with better coverage.
And it's important to
mention that at that time
we also upgraded from
Visual Studio 2015 to 2017.
And this is available for Clang
because we also need to update
our Clang compilation scripts.
We started work on a custom
based refactoring tool
based on libTooling,
and that helped us tremendously as well,
during this cool rejuvenation.
And we fixed Clang 4.0
issues and upgraded in July
to Clang 4.0.
Next, we got a little
courageous and started
tackling -Wall warnings in
Clang, quite a few of those.
(chuckles) And we've made
extensive code transformations
with our custom libTooling helpers.
Finally, in August, our whole codebase
compiles with Clang -Wall.
And, again, we got a little courageous
and started embarking on -Wextra.
We're still not there,
but it's work in progress.
And we started developing
a Visual Studio extension
that we named Clang Power Tools
to help developers with this workflow.
And over the summer we did
large scale refactorings
with clang-tidy using modernized modules,
readability modules from clang-tidy.
And we did huge code
transformations with these modules.
Of course, every change needed to be
thoroughly inspected and tested.
There were some problems
with some of the modules.
But, overall, it was a very,
very positive experience
that I encourage you all to take.
So in September we finally
upgraded to LLV 5.0
and fixed a little bit more
warnings coming from that.
Basically most of them were
lambda capture warnings.
And we open-sourced our
Visual Studio extension
and our PowerShell scripts on GitHub.
In September we also
published the extension
to Visual Studio Marketplace.
And it's a free extension you
can try out for yourselves.
And here we are.
Some of the transformations we performed
on our codebase with tidy, use-nullptr,
loop conversions for
basically modernizing loops
to page for loops, use-overrides,
that was a very beneficial
modernization,
redundant-string-cstr, use-emplace,
auto, make-shared,
make-unique, equals-default,
that was a big one, and equals-delete.
Default-member initializing,
passing by value,
braced-initialization, using
instead of tide depths,
CPP core guidelines,
readability improvements
and some string optimizations.
Lot of effort was involved
in examining reports
from the static analysis
tool in clang-tidy
and fixing some of the
bugs we encountered.
There were some false
positives, of course,
as it's expected with these kind of tools.
And also examining CPP core
guidelines, reports as well.
How did we achieve all that?
Using tools, of course.
Like I said, our PowerShell scripts,
our custom lib-tooling implementations
and our Visual Studio extension.
I'm up here, but I have
to give a shout out
to some of my teammates
that helped tremendously
in this effort.
For developing my PowerShell scripts,
I have my PowerShell
wizard there, Gabriel.
And our Visual Studio extension as well as
our custom tools LibTooling,
and many, many other teammates that helped
fixing errors and warnings
in our source code.
It was really a big effort.
Simple beginnings,
(chuckles) as you can see,
this is how we started at
the beginning of this year
with some simple batch files, very naive.
We quickly came to (chuckles)
some of the limitations
on this approach.
But you've got to start somewhere.
And this is how we started. (chuckles)
As you can see, it's not very fancy.
After about a month of
struggling with batch files
and fixing issues that way,
my colleague, Gabriel, helped
me with PowerShell script
that we developed since then.
It's much more complicated.
I cannot feed that on the slide.
Over a thousand lines, very configurable.
Over time, we added
many knobs and switches
to this script.
And supports both Clang
compile, syntax only, of course,
and tidy workflows.
Works directly on Visual Studio projects.
There's round-tripping
an converting projects
to Clang compilation JSON
database, or anything like that.
It works directly on the
Visual Studio projects
or MSBuild projects for that matter.
It supports parallel compilation.
That's a big positive
effect, 'cause otherwise
it would take forever.
When we started it used to
be able to run overnight
and that's it, 'cause it's
a fairly large codebase.
It constructs Clang PCH
files from Visual Studio
standard fx files,
and automatically extracts
all the required settings
from Visual Studio projects,
like pre-processor definitions,
additionally, include
directories, SDK versions,
PCH information, debug
information and so on.
To give you a bit of a
flavor on using the script,
some of the switches are up there.
I'm not gonna go over every
each and every one of those.
Just to tell you that our main
script has too many knobs,
so to speak, it's very powerful.
So we developed what we
call a bootstrapper script
that you can copy and customize.
We give you an example,
you can copy and customize
to be able to more
easily use this approach
in your workflow by specifying
compilations constants
in this bootstrapper
script, and be able to run
with much fewer common line
parameters we're running.
For example, you have here
samples PowerShell script.
And you give it a project,
project, foo and bar,
and you tell it to compile
every source file that matches meow
and apply clang-tidy fixes in the category
of modernize, basically,
all modernize models.
This is standard clang-tidy syntax.
And for a simpler workflow,
you can just tell it to
parallel compile every project
in a current directory,
ignoring projects foo and
bar, just a few examples.
How would this kind of script look like?
Well, something like this
you can define constants
that are specific to your project needs
or for your team, like
your perfect combination of
Clang flags that you need,
your mileage may vary.
Not everybody can use the same
configuration flags, of course.
Additional specific include directories,
Visual Studio versioning
information and so on.
And as soon as we able to
compile everything with Clang,
we needed to make sure it
doesn't break going forward.
And, as I told you, we had
to immediately integrate this
in our workflow.
And we've been using Jenkins
Continuous Integration,
and the perfect combination for
using this PowerShell script we think
is integrating in CI.
And to give you an example using Jenkins,
basically, you have to
install and configure
Jenkins PowerShell plugin, if that's not
already on your box.
And add a build step, or
complete a new job for Clang
using Windows PowerShell script task.
And this is how it
would look, for example.
This is invoking our
boostrappers PowerShell script
to run in parallel.
And we have one ignore project
that's a third-party project
that we cannot make it
compile with Clang, for example.
This is a simple Jenkins CI integration
for running your PowerShell
scripts with Clang.
And our recommendation
is that you basically
pull SEM and build every
SEM change with Clang,
make sure it doesn't break
and fix issues as soon
as they appear, once you achieve
compatibility, of course.
The best part about this is
of course when a Clang build
is broken, we have a
slack bot for Jenkins.
And we're immediately notified.
And the person responsible will fix it
as soon as physically possible. (laughs)
Email notification is another option,
receiving a big failure with
the reports and change sets.
And of course with a Clang error
that needs to be addressed.
What about developer workflow?
Well, for a developer workflow, of course
you can use the PowerShell script,
and we've been using that
at the very beginning.
But that's much more tedious
and we think a much better approach
is using a Visual Studio extension,
'cause we're living in Visual Studio
and that's the most appropriate way
to deal with these things.
So we think the best approach is
integration right in the ID.
And we started developing
this Visual Studio extension
that we're offering for free.
And we also open source.
Our Visual Studio extension basically
is based on our PowerShell script.
But it will rely less
and less on this script
as we move forward.
This is just our first draft.
The extension is available in
the Visual Studio marketplace.
You can just search for
it, just search Clang
and you'll find Clang power tools.
Install it.
And configure it.
We exposes some of the
notes of our automation
for clang-tidy and clang-compile.
For example, clang-compile
flags that you can configure.
You can configure the
behavior of the compilation
as well as configure clang-tidy checks.
For example, you have a
full list of supported
clang-tidy checks that you can run.
And you can toggle them whenever you need.
There is also in-line
documentation for switches
that we pulled off from the web.
So we can basically have
the whole experience
right there in the ID and see
what modules are you running.
And you can run repeated
workflows on the same settings,
because these settings are
persisted, of course, in your ID.
So, for example, you can
tell it to autofix issues
that Clang finds.
And automatically fix them and
loads in your ID environment.
You can configure individual
clang-tidy checks or modules.
Or you can even give it a wild card check.
For example, you wanna run
all modernized modules,
or all readability modules.
You can also do that.
How it would look like, well,
if you install to the extension,
you will find it in the contextual place
you would expect.
For example, you can run it for a project
or for a solution.
You can run either
compile, just syntax only.
We're not emitting any object file
or intermediate representation,
don't don't need that.
Basically the compilation
step is just needed
to make sure you have
compatibility and you are able
to run tidy.
So you can compile or tidy a whole project
or your whole solution,
or just a single file.
For example, your current editor file.
Or you can compile several
project, for example,
you encounter, let's say you
receive broken build report
from Jenkins and you just
jump into Visual Studio,
go to that file that is
broken and just fix that.
You can select multiple files, of course.
How it looks like.
We integrate with standard output,
Windows Visual Studio,
that's where you're gonna see
compilation errors and warnings
as well as the error tab in Visual Studio.
It's navigable so it will
jump to the right location
in the source code,
exactly as you would expect
from a Visual Studio warning or error.
And has, of course, all the
standard output that you would,
in diagnostics that you would
expect from a Clang compiler
and clang-tidy.
For example, for the tidy
workflow, you can see here
on clang-tidy analyze report.
And this one is for null
the reference, for example.
Okay.
Where can you get it?
Well, the Visual Studio
extension is, like I said,
in the Visual Studio marketplace,
you can get it right now.
It relies on LLVM for Windows,
so it's not standalone.
You need to have installed
LLVM on your box.
There is a standard
distribution for Windows.
Don't worry, you don't have
to build it from source.
(chuckles) There's a
Windows Installer kit.
So it works with Clang 3.9, 4.0, 5.0.
It works with Visual Studio 2017.
Right now, we're soon
gonna add support for 2015.
And if somebody is still
on that version, of course.
You can find all the
source code on GitHub,
as well as for the extension itself
and for the PowerShell
scripts that we provide.
And going forward, we're thinking big.
Beyond clang-tidy, as I
said, we wrote custom tools
that are project specific to
meet our refactoring needs.
We have quite a few of those.
And we're still developing on them.
We fixed hundreds of
member initializer's list
with wrong order, that was
a big milestone to achieve
- Wreorder compatibility.
We removed a lot of class private fields
that were unused, like
references, pointers
and other scalar types.
We refactored some heavily
used class constructors.
We changed some of our mechanisms
for acquiring dependencies
between our models.
And that was quite a
large code transformation
that we wouldn't have
been able to preform,
we just replaced, or stuff like that.
So we actually built a custom tool
for doing those refactorings.
And we have even more on the way.
We think we unlocked a big potential here
for code transformations.
I think the biggest
challenge was getting here,
so achieving cross-compiler compatibility
was the biggest challenge.
Once we achieved that, we
unlocked a tremendous horizon
for what we can do in terms of tooling.
Once we were able to run tidy
and run our custom LibTooling
checks on our source code,
basically, you're just
limited by your imagination.
You can do any code transformation,
you can do function deprecation,
you can easily change arguments
and deprecate source code
and modernize your application
and have full control
over what happens at scale.
We're talking about millions
of lines of code here.
And some of the transformations
are not trivial.
We can't get away
rep-replace all the time.
So for our roadmap,
we're working on -Wextra.
There were lot of issues
with this set of flags.
We have a few remaining issues to fix.
We plan to continuously
improve the Clang Power Tools,
Visual Studio extension,
and run even more clang-tidy checks,
fix more issues with clang-analyzer.
This is a tremendous
source of information.
Some of the reports were
really eye-opening for us.
Just to make a clarification, we did ran,
also run Visual Studio static analyzer
and, for example, Visual Studio
CP core guidelines checks.
I think we can get the
best of both worlds.
It's not that one tool
is better than the other.
They just complement each other very well.
So there's never too
many tools you can run
or too many reports you can see
and too many bugs to fix. (chuckles)
So we're gonna continue using both.
We're gonna run previous
checks on new code,
so this is an important issue
of developing a workflow
around clang-tidy.
Once we ran our initial transformations
and our initial fixes,
we need to be able to develop
a workflow going forward,
how we're gonna use this
in our day-to-day activity.
How frequently are we
going to run tidy checks?
So we're still figuring
this out and experimenting
with different workflows.
Of course, in order to
be able to achieve this,
we need to be able to compile our codebase
on each commit, on each
revision, with Clang.
So this is a very important issue.
We don't need any regression on this part.
So the biggest effort going
forward is investing more
in libTooling and our custom checks.
Some of them are general purpose
and we intend to make them open-source
and available for others to try out.
Some of them are very specific.
I think most of them you can
categorize as project specific.
And we're gonna develop
even more of those.
Okay, I didn't want to go to long
with what I prepared, because this kind of
case study and presentation
implies questions on your part.
And I just want to be able
to give you ample time
in asking me questions
or getting an opinion.
If you can line up to the mics
and start asking questions.
Go ahead.
- [Man] Okay, how do
you avoid warnings from
clang-tidy, or so, and third-party headers
that you include and that
are pulled into the analysis
by clang-tidy?
- Yeah, that's a difficult
issue. (chuckles).
- [Man] Because iSystem
doesn't work on Windows.
- Yeah, yeah, that's a difficult issue.
You basically you have
to try to isolate those.
Our scripts and extension
can ignore specific
translation units, for example.
But in terms of headers,
you basically need to do
the required refactorings
to minimize the impact
of third-party headers that generate
tidy reports or analysis reports
to be able to carve out and ignore
as a very small portion
of your code as you can.
We don't have a perfect
solution in this regard
in terms of headers, yeah.
You just have to basically
try to isolate the impact
of that header on a very
small piece of your code,
to be able to ignore.
We don't have a solution for headers.
Basically, with tidy, you
have a transitive include
of all of your source code dependencies.
And it's difficult to turn
off errors and warnings
that come from headers.
Another observation I need
to make on this aspect
is with regards to auto-fixes.
For example, when you apply a tidy fix
on some source code, for
example, on some CPP files,
it will also fix included
headers that translations
you need pulls.
So this is something that we encountered
when we tried to paralyze
clang-tidy modernizations.
We couldn't do that because
when running in parallel
in multiple CPP files, they
reference the same headers
and they basically try
to write over each other
and corrupted those headers.
So clang-tidy auto-fix in parallel, again,
that's something we
cannot do, again, because
of the transitive nature
of headers included
from multiple CPP files.
So headers are a difficult issue.
Yeah, sorry.
- [Man] Thank you.
- [Audience Member] Hi,
actually have two things
I wanna say.
First, like a little background.
I actually work on Clang for Windows.
And when I first read
the abstract of the talk,
I saw that you mentioned all
these PowerShell scripts.
And I was like, &quot;Oh,
I'm gonna come in here
&quot;and tell him that we already
have a Visual Studio extension
&quot;for clang-tidy, but it's
just not on the marketplace.&quot;
And so I was gonna say,
like, &quot;Maybe you can improve
&quot;our extension and get
it on the marketplace.&quot;
But it turns out yours
is actually much better
than the one that I had developed.
And so I think on behalf of
the other Clang for Windows
developers who are in this room,
I just wanna say thank you,
because it's really awesome.
- You're welcome.
- So the other thing I wanted to say,
which is actually a question
is that I saw in your
configuration options dialog,
you had the compiler options.
And so it looks to me like you're using
probably the GCC driver,
you're just calling Clang.exe,
is that right?
- Clang plus, plus.
- [Audience Member] Yeah,
so is there any reason
or have you considered using ClangCL.exe?
Because then you can actually
you don't have to pass any
extra compiler options.
You can just pull the
MSVC compiler options
from the project file and just use it.
- Yeah, that's a good question.
We did try that.
But in the end we just
wanted to have full control
over the compilation flags
and be able to experiment
with different compilation settings.
So the reason we took this
route is because we wanted
to keep control, basically.
Yeah, that's an option
we are still looking at,
but we prefer this route,
because wanted to be able to
very fine tune compilation settings
and be able to experiment
with, like I said,
with -Wextra and we
even tried some warnings
that are not in -Wextra,
but we considered it useful.
So we wanted to be as generic as possible
and not use any magic. (laughs)
In terms of the extension,
I'm not sure exactly
what's the best approach here.
Maybe unifying approach of
contributing to single extension
and making that available in
the Visual Studio marketplace.
Maybe that would be a better approach.
- [Audience Member] Yeah, I'll
probably just delete mine.
(laughs)
- (laughs) Don't do that.
Maybe we can combine and
get the best of both worlds.
So we think it's important
to get it out there.
That's why we open sourced
it, we welcome extensions
from anybody who can contribute.
But we think it's important to be visible.
People, when they're gonna search
for this kind of extension,
from within Visual
Studio extension manager,
they need to be able to find this
and be able to run as quickly as possible.
So we're gonna continue to invest in this.
And I think we can benefit from
many of you people's ideas.
So your ideas are welcome.
Thank you.
- [Audience Member] And
I'm on the other end.
I'm like you, I looked at the clang-tidy
about three years ago before
it was available on Windows.
And I've got a codebase
that's much bigger than yours.
Anyway, I did not succeed.
So thank you for pushing
(chuckles) this through.
This looks fascinating.
- We didn't think we're
gonna succeed either.
- [Audience Member] (laughs)
So does the extension
go to the VCX proj file and
go pull in all of the current
flags and so forth and
translate it right at...
In real-time there?
There's a JSON file that
has to get generated, right?
- No, I alluded to this earlier.
Maybe I went too fast.
We're actually not doing any roundtripping
in converting your Visual
Studio VCH project file
into a JSON Clang compilation database.
We're not doing that.
We're actually working directly on
MSBUild configuration file,
on your Visual Studio
project file directly.
The script actually pulls information
from that project file directly.
Some of the required information
needs extracted from there.
For example, SDK
versioning, target platform,
additionally include
directories, PCH information,
Unicode information,
pre-processor information,
and stuff like that.
Still a lot more to do in this area.
More information can be
automatically extracting from there.
And we can do more in mapping
specific Visual Studio
compilations settings to Clang settings.
Some of those right now are
just note that you have to
figure out how to configure.
We did quite a few effort in this part,
we're lots more to go.
Right now, our Visual Studio extension
actually relies on this PowerShell script.
It has it in the box, so to speak.
Going forward, we plan
to rely less and less
on this PowerShell script and leverage
some of the integrated SDK that
Visual Studio extension has
to be able to extract more information
from the project and from
the current editor context.
For example, we're thinking about
even integrating in the editor,
with Intellisense-like features,
or more code navigation stuff,
or more on the lines
of auto-fixes for tidy.
So right now we are heavily dependent
on the PowerShell script,
because we started that way
when we thought the best
way to achieve publications
with this extension is
to just leverage a script
we already had, 'cause
we started with a script.
And we continue to consider
that continuous integration
is a very important aspect of this.
So we're not gonna deprecate the script,
once we improve the extension.
So the script is gonna improve as well.
But the extension itself
will rely less and less
on the script file actually
pulling information
from the VCH project file.
And it's gonna figure
out lots of the settings
from the environment itself,
using the Visual Studio SDK.
- [Audience Member] And
on more quick thing,
couple years ago, when
I looked at clang-tidy,
there were like three
levels of transformation.
It was totally safe, something
that might break the code,
something that probably
would break the code.
Is that in the options?
- That depends on the check you select,
not all the checks are configurable.
Some of the checks are
configurable, for example,
loop convert, with range for loops.
That design have the exact
same labels you mentioned,
like safe, unsafe, and
experiment or something.
This is something we're not
currently exposing right now.
We basically run with a
checks default option.
But we do plan to expose that.
- [Audience Member] Just wondering
what your experience was on your codebase
in terms of errors generated
when you did some of the
more aggressive transformations.
- Yeah, (chuckles) good ones and bad ones.
I can give you a few examples.
I didn't wanna pick on clang-tidy.
So this was mostly a
talk about the experience
and case study and didn't wanna show bugs
or issues (laughs).
But we encountered quite a few of those.
For example, the loop convert tidy check
was quite a good one and a decent citizen.
We did the default checks.
We also did some of the
unsafe transformations.
It was pretty good.
The result was pretty good.
Very few issues.
For example, other extensions
are not very safe to run.
For example, Use-using
was a particular check
in clang-tidy that caused
lots of struggle for us.
First of all, it didn't
catch all the type divs
that it's supposed to catch
and it messed around with some of our
function pointer
definitions using type divs.
It has some issues there in terms of
we were using custom calling conventions,
like standard call.
And basically the function pointer syntax
just screwed up (laughs) that tidy check.
So we had some issues.
Some of the checks were very nice
and we didn't even have
basically any problem.
Generated huge divs, huge
divs in our codebase,
but basically, were just
mechanical replacements
or very clever replacements
that were basically zero errors,
zero problems that we detect.
Some of them are tricky.
For example, removing
redundant C_str from -Wstring.
Some of them them were tricky.
In some place people relied
a null terminated string
being passed in.
So we needed to be very
careful in removing those.
So, overall, the experience was very nice.
But you need to be very careful
and your mileage might vary.
So it's very tricky.
And you need to examine
each and every change
very carefully before you push it in.
- [Audience Member] Great,
thank you very much.
- [Audience Member] Yeah,
his question touched on
what I was gonna ask which is:
How did you go about
validating the changes
that tidy made to ensure
that they weren't
breaking something subtle?
How was your regression
touch coverage and such?
- Basically, you have to be very careful
and, of course, you rely on unit tests,
that's very important.
Some of the transformations
were just plain
breaking the build, so that
will immediately spot it.
But some of the stuff was silent.
Like I said, in the example
with -Wstring C_str,
we find some of those
just by examining the div.
So you basically, you're doing large scale
code transformation.
And that spares you the time
of actually doing it yourself.
But that doesn't preclude the fact
that you need to analyze
the results carefully
before you push any.
So you cannot blindly just trust the tool
that it will make the things right
and just commit everything as it is.
So we actually did careful resignation
line by line for each
div that will generate.
And, of course, rely on your unit test.
But it depends on how good
your coverage is. (chuckles)
You just need to be very careful.
It's a very powerful tool.
But you don't have to trust it. (chuckles)
- [Audience Member] Would you say you have
good test coverage?
You're pretty happy
with your coverage?
- Yeah, but you're never
covered. (laughs)
- Well, you're never
fully satisfied.
And how long does your
system take to build?
- Sorry?
- [Audience Member] How
long does your system
take to build?
- On Clang or on Visual Studio?
- [Audience Member] Visual Studio.
- On Visual Studio, the bug
build is about 40 minutes.
Release built, about an hour.
And on Clang, about 45 minutes.
But on Clang we just use F syntax only,
so we're just parsing it, that's it.
About 45 minutes in parallel.
Our Clang script basically
saturates all the course.
So that is another issue
that we need to address
in continuous integration scenarios.
We did priority queues for Jenkins jobs,
because when a Clang build triggered,
it basically saturates with all the cores
or on our big machines.
And other jobs were not
able to perform as well.
Clang build runs pretty as fast as it can
so it basically saturates your machine.
- [Audience Member] Okay, thank you.
- [Audience Member] Well, first of all,
thank you very much for the tool.
I just can't wait to try
it out in our projects.
It's really awesome.
All this aweseomeness is available
when you actually make your
code compilable on the Clang.
So, as you've said, it
took quite a lot of effort
to make sure to make it compilable.
And before you make it
you cannot Clang tools
to help you transform the codes,
right?
- It's a catch 22, yeah.
- [Audience Member]
(chuckles) Right, right.
So maybe there are some
tricks that you use
to actually make,
to help yourself to make
this code compilable.
Which are those?
- Yes, it's a multiple phase process.
So, first of all, you
must be able to compile
your source code, to be able to run tidy.
But you don't have to
be able to compile it
with all the switches on.
You can disable lot of warnings initially.
And, basically, the
clang-tidy is able to work
as soon as you don't have any errors.
We actually have a switch that treats
Clang warnings as errors.
But you don't have to do it right away.
You can disable a large
amount of warnings, initially,
to be able to just make it compile
with Microsoft compatibility switches.
You just have to make it
compile without errors.
That's the first step.
Without that, you cannot run tidy.
But after you do that, you
can run tidy modernizations
and even LibTooling
stuff that you developed
to make it work.
And we actually did that.
For example, member
initializer list reordering.
That was a very sensitive issue
that we actually couldn't perform by hand,
because it's very difficult
to check the correct order,
where classes had tens of members.
So doing that over
millions of lines of code
is basically impossible.
So we actually did that with
a custom developed LibTooling
tool that we developed.
So before achieving tidy
compilation without errors,
basically we just have to
rely on transformations
that we do by hand or
with grip-like replaces.
It's a catch-22, problem
is, it's difficult.
But it's a multiple-phase process.
So you do modernizations.
And you were able to flip
even more Clang switches.
We enabled warnings that
we initially disabled.
The more fixes with tidy and LibTooling
enable more warnings, so
it's a multi-stage approach.
- [Audience Member] Yes, just understood.
Another question, you
mentioned there is an extension
Clang format, right?
- Yep, that's not ours, but we use it.
- [Audience Member] So the question is
does your extension actually supersede
these Clang formed extension?
- No, but we, version 1.0 of our
Clang powered tools extension
doesn't call format, but
this is the first thing
we're gonna implement
(chuckles) in our next version
is automatically Clang format
after tidy with auto-fix.
'Cause we actually did that
in our scripting scenarios.
We actually did tidy transformations
and right after that, we did Clang format
on those transformations,
because those transformations
don't format the code
like you would expect.
They do surgical replaces, so to speak,
so you need to rerun Clang format.
So not in version 1.0, but in version 1.1,
(laughs) let's say, our
extension will supersede
Clang format, basically,
for tidy scenarios.
For your day-to-day editing scenarios,
I think you would be better off
using the Clang format extension.
The can live side-by-side.
I actually have both of
them installed on my box.
So for day-to-day editing, I think,
the experience in Clang format extension,
that's already free in the
Visual Studio marketplace.
That's very good and very simple workflow.
We actually use auto-format
on save and everything.
It's great.
But for tidy scenarios,
our extension will provide
the format for you, if you like,
and will pick up your configured style
or whatever you have in your project.
- [Audience Member] Thanks.
- [Audience Member] Yes,
my question is about
you give us your timeline,
and there was multiple people involved,
but in terms of workload,
like was it full time
for some of them, was it.
- That's a very good question.
I wanted to mention that and I forgot.
It started as a hobby
project for me. (laughs)
And very soon after that, a colleague
decided to help with
the PowerShell script.
And as soon as we got the ball rolling,
more people pitched in to help.
It was totally 20% effort, so to speak.
So it wasn't a goal for us.
It was something we would like to see.
And basically we just
convinced people to come help.
So they saw what we were doing.
They saw the commits and the changes.
They said, &quot;Mm-hm, interesting.
&quot;You fixed that?
&quot;Why did you fix that?&quot;
I explained the warning or
the issue that we encountered.
But we piqued their interest
and they pitched in to help.
It was not something we
decided to work full-time.
We did this as we worked on features
for a commercial product.
So we did this work,
another point aspect is,
we did this work on our trunk.
So we didn't split a branch
that we fixed issues on
and synced with our
production environment.
That would have been total
failure, in my opinion,
because they would have
quickly gone out of sync.
And people would stop,
would ignore that branch
and the build would
continuously be broken.
I cannot fix all the
issues myself. (chuckles)
So we did this live as we
worked on developing features
for production.
So a few people helped. (laughs)
It's a one-man job. (chuckles)
- [Audience Member] Okay, thank you.
- [Audience Member] Yes, my question is
I was wondering if you have any metrics
that would prove that all
the effort that you put in
was worthwhile at the end.
- One metric I can give you,
my colleagues are very happy
(audience laughing)
with the code transformation.
I think it's a good metric.
It's not something in terms
of return of investment,
or something like that.
But if people are happy
and they like the result,
they like looking at modern code,
if you don't have any
contention and debates
about the review process on those changes,
people rarely had any
objections on the transformation
we were able to perform with tidy.
So if people don't have
any issues with the divs
in themselves, and they're
happy with the result,
and they pitched in voluntarily to help
with this process, I think
that's a very good metric.
(laughs)
- [Audience Member] Was
that your original plan
that you just wanted to
run it so the code looked better?
Or were you running to fix
bugs that you didn't know you had.
- It was a multi-pronged approach.
So we basically wanted both.
We wanted to modernize our code base
as well as run analysis.
I was very impressed
with other talks I saw
about using analysis on
code bases and finding bugs.
And we did experiment
with Visual Studio static analyzer
and we were happy with that.
And we were interested
in running more CPP code
guideline checks in tidy.
We had many goals,
but it wasn't something that we scheduled.
It's something that happened.
We started, like you saw, we
started with the batch files.
We started fixing errors.
People got interested.
We were reading up on the reports
and studying the subtle issues.
- [Audience Member] Do
you have any gut feeling
for whether you think
the code is more stable?
- I wouldn't say that. (laughs)
I wouldn't say it's more stable.
We had issues, like I said.
We uncovered issues.
Some of them we caught
before we committed,
some of them we caught in
testing and I'm not gonna pretend
this will improve your code.
Maybe this process will also
add some bugs. (chuckles)
You have to be very careful.
But, overall, we're very
happy with what we did.
And we don't have any regrets.
And we're gonna continue
doing it. (chuckles)
- [Audience Member] Thank you.
- [Audience Member] At the scale that
you're working millions of lines of code.
That seems pretty big for Visual Studio.
I was just wondering
if you could talk about
your experience with that.
- We don't have any issues on that scale.
We don't have all the
projects in a single solution,
if that's what you're referring to.
We have several server solutions.
I think our biggest solution
has about 40 projects in it.
But we have many solutions.
We have about 134 projects overall.
We don't have any issues with
the ID itself on this scale.
We're happy with...
Especially in the latest
version of Visual Studio, 15.3,
with lightweight solution loader.
It actually loads very fast,
even if you have many
projects in one solutions.
So on that front, we're happy with it.
- [Audience Member] Thanks.
- [Audience Member] Hi, you said that
you were doing all the work on your trunk.
Did you have any other
branches active at the time?
Did you have any issues merging.
- Yeah.
(audience laughing)
Yeah, I was hoping to avoid that.
Like any refactoring you're gonna do,
you're gonna have issues with
active branches when merging.
Yes, we had issues when we
actually fixed some stuff
and some teammates reintegrated
a branch and we had to...
Basically they had mergers
and they solved them
by using their version.
So we had to reapply.
And we think it's the right approach
because they cannot redo their work,
but we cannot rerun our tools.
So the right approach in
resolving much conflicts
would be accept the changes
that are actual code changes
that people do when integrating it,
and rerunning your tools,
because rerunning tools is easy.
Making that developer rewrite its code,
it's not something you can expect.
We did have several issues like that.
But we basically reran our
scripts so everything worked out.
- [Audience Member] Very good.
Another question I had,
what was the most surprising bug or error
that you saw after running something
that you thought would be fairly safe?
- Use-using. (chuckles)
Use-using seems like a very
trivial thing to modernize.
And, sorry?
(man speaks from a distance)
It seems like trivial, but it messed up
our whole codebase.
It didn't pick up all the type divs,
messed up our function
pointer definitions,
had issues in type divs
in site template functions
where it actually
replaced, when we replaced
the type div with using,
it actually replaced
with the concrete type
of that template instantiation
instead of maintaining
the template parameter.
I think it's the most buggy check in tidy.
- [Audience Member] Can you
create bug reports with that?
- No yet.
Yeah, we're gonna do that.
Yeah, yeah.
Actually, at least on
Windows, in 3 point, no,
in Clang 4.0, it actually
crashed this tidy.
So in 5.0 it works, but
we had several issues.
And it was surprising.
'Cause you asked about
the surprising scenario.
I thought that would be
a trivial transformation,
use-using, but it wasn't.
- [Audience Member] Thank you.
- [Audience Member] Thank you for the talk
and for the courage of expressing it
and bringing it.
The question is your code, when
you build it for production,
what compiler do you use?
- Visual Studio 2017.
15.3 right now.
- [Audience Member] Okay.
Even though you are using
the latest Visual Studio?
I mean...
Yeah, yeah, it's possible.
- 15.3 is the latest
Visual Studio version, Visual Studio 2017.
- [Audience Member] Oh, oh, I'm sorry.
- Its version number is 15.3.
It's Visual Studio 2017.
- [Audience Member] When your Jenkins--
- Sorry, we don't actually ship anything
if the Clang build is broken.
- [Audience Member] Ah, okay.
- The Clang build is always clean.
- [Audience Member] I see, so
you're building it with both
but you're shipping it with Visual Studio.
- We don't have any plans to ship.
I read a blog post about
Chromium on Windows
and their plans to use Clang on Windows
to build...
Up until now they used
Visual Studio compiler
to build their Windows flavor.
And they plan to build
it using LLVM on Windows.
We don't have any plans on that front.
We're happy with our current toolset.
We just need to use the
best of both worlds.
(chuckles)
- [Audience Member] When
you use your Jenkins
on the continuous integration server,
how do you actually, what do you actually
do to build it?
Are you running your PowerShell script?
- Yeah, I can show it to you again.
Here you go.
The workflow is add a build step of type
Windows PowerShell, that's
a plugin for Jenkins.
It's maybe you already have
it in your Jenkins books.
Otherwise it's in the Jenkins gallery.
So add that PowerShell plugin.
This is the one, PowerShell plugin.
So add a build step of
type Windows PowerShell
or just create another job.
We have a different job.
We have a Jenkins job for Clang builds.
It's a separate job.
But you can add it as a build step post
for your regular build
in the same Jenkins job.
And the script, here it is.
This is our bootstrapper script.
AI comes from advanced installer.
It's not something with
artificial intelligence
or anything.
(laughs)
- [Audience Member] Do you build
in Jenkins for production,
too, with Visual Studio?
- Yes, for release candidates, not for
the actual RTM or goldmaster that we ship.
But for release candidates and QA testing,
we build that in Jenkins as well.
- [Audience Member] And was what?
Was make file or--
- No, we actually use MSBuild files.
Visual Studio projects are
basically MSBuild files.
So as you saw this Windows
PowerShell build action,
there's a a MSBuild.
I think you can see it here.
Yeah, the second one, the second one.
That's an MSBuild action.
And you give it the project
file and it builds it for you.
- [Audience Member] Gotcha.
So the last question, I'm
not using, unfortunately,
a clang-tidy here.
And my question is if I wanna replace
not the using or other regular statement,
but one function with another one,
for example, I'm deprecating something?
So is it possible and how feasible it is.
- Yes, you have to build the
custom LibTooling for that.
Tidy doesn't do refactoring like that.
- [Audience Member] LibTooling.
- LibTooling is a C++ library from LLVM.
You build your custom
tools on top of that.
And it exposes fully ST and
basically can do anything.
- Thank you.
- Okay, thank you very much,
the session is over.
Catch--
- [Audience Member] Can
I say one more thing?
- Yeah.
- [Audience Member] There's
a bunch of other Clang tools
that are built on LibTooling already.
There's Clang Rename that
will rename variables
across your project.
- Yes, there are.
- [Audience Member] So there might be one
that deletes a function, I'm not sure.
But there's
lots of refactoring tools.
- I wasn't sure
about the answer, but
there are several tools.
Catch me in the hallways.
If you have any more
questions, I'll be here.
I'll be happy to answer
any of our questions.
(audience applauding)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>