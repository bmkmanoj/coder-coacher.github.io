<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Anastasia Kazakova “New standards to the rescue: the view through an IDE’s glasses” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Anastasia Kazakova “New standards to the rescue: the view through an IDE’s glasses” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Anastasia Kazakova “New standards to the rescue: the view through an IDE’s glasses”</b></h2><h5 class="post__date">2017-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cBpPxantld8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- My name is Anastasia
Kazakova I am from JetBrains,
but today I'm not gonna
talk about our tools
so if you're interested
just come to our booth on
Wednesday and Thursday.
I'm gonna talk about the new standards
and before I start I would like to say
a little bit sorry for my voice
I'm a little bit running out of it
but I'll try to make this
work for this one hour.
So talking about myself for quite a bit,
I was working as a C++
developer for eight years,
doing some networking and embedded stuff
and then I moved to JetBrains
working mostly as
product marketing manager
or do some evangelism around the tools,
and I'm also running my own C++ user group
in St. Petersburg in Russia.
So this talk is mostly about the triangle
between like developers,
languages, and tools,
and how they are connected and related.
So if we start thinking
so we have a developer
who's actually start working on some task
in a particular area
and he starts with selecting
an apprope language.
I am a type of the person who believes
there are no universal languages
and so if he selects C++ then
he has some reasons for that
in some special area for that.
So language features, they
are to help developers
to write some accurate and concise code
to solve their particular problems
for the area they are working in
and to provide some necessary performance
and actually fit into
their business environment,
the whole infrastructure they have.
So if we come with the tools,
actually developers they need tools
to leverage some language issues
to make developers more
productive with some routine tasks
and also to push some guidelines
like the super recorded lines
that Bjorn is talking about
and any type of guidelines you have
so they are just impossible
without the tools
because you will completely
forgot about all the guidelines
when you have a project with
a deadline back yesterday
and like 50 people working on a project
and whatever is else anyway
is happening on your project.
So language, they need tools
for pushing this kind of
guidelines and good practices
and actually for why that option
of the new language features
because like if the tools is
throwing it into your face like
how to modernize your code,
you're more likely using
more of the language features
than just without that.
But how about the other side,
how the language can
helps tools do better?
Can tools benefit from
the new language features
or there are any issues with that
so how this relationship evolves.
This is what we're gonna talk here
about this kind of relationship.
So before that let's see
how our C++ reality actually looks like
and how we cope and how
we're leaving all this stuff.
So talking about the IDE expectation,
when I ask people what
they expect from the IDE
usually they start with
the word correctness
like we expect 100%
correctness from the tool
so that you can cope with any C++ we write
and you are perfect with that.
That's a good, but then
they come with performance.
So they wanted to work quickly on the fly
and then they think about
some kind of a smartness,
so they would like to have
some fancy highlighting
or a call completion that
is working like immediately.
They also want the tool to
know about the whole project
like to refract for the whole project
not one translation you need
or do whichever stuff they need
to find user just across
the whole project.
And they want it to be
helpful that means that
IDE actually has to cope
with the incorrect code.
So the, like the level of the errors
that the IDE can cope differs
from compiler completely
so the compiler just stops,
the IDE couldn't stop,
it has to deal further.
And the people actually they are expecting
all the tools that just exist in the world
to be built into their IDE.
Some of the tools they work
with the EST, some not,
but any kind of tools
that you have on board,
believe me or not, the
people will blaming the IDE
if the tools is not working.
That's just our reality.
But okay let's just leave the whole list,
let's just take the first two,
correctness and performance.
And actually for C++ especially,
this is some kind of balance question.
So you have to provide the correct tool,
but still you have to be quick.
And each time with each problem
you have to think about this balance.
And I'll come back to this balance
in a couple of slides
back and you will see why.
So as I said IDE works with any code.
So it could be legacy code
that is back many years
and it's quite old, like no
one writes the code that way,
and it could be modern standards
and the people that actually
asking for new features
before they even arrive to
the kind of C++ standards
or even technical specification.
They just come in and say hey
I need this feature right now.
And sometimes these things coexist
so they have some legacy project
and they want to use some new features,
and the thing about the incorrect code
that I already mentioned
like they already cover
level that is completely different
from what we have in the compilers.
In the beginning of this year
we made a big research on C++ developers,
not only our users, it
was quite extensive,
so in total we got 9,000 responses.
And they're here we have two graphs,
the big one is which standard
of the people are using
so that not exclusive,
so the total is bigger than
100 don't be surprised.
And this round one is
if you are gonna move to a new standard.
And you see like half of the respondents
are not gonna move to
a new standard at all
and you see that the biggest
part is actually using C++ 11.
But there are quite a big part of people
who actually gonna move to C++ 17,
that's huge, that's really great.
But that's shows the difference,
that shows the variety
so there is no like something on trend,
so the people select different things.
And I would like to play some
kind of a game here with you
so I call it are they different?
So I will be actually showing
you some pieces of code
with very similar lines
and you have to decide if these
lines are different or not.
So here is the first sample
and there are actually two lines
in the end of the test function,
one with K and one without.
They look very similar,
but the question is are they different?
I will give you some seconds to think.
Hey I see people smiling.
Yeah so actually they are different.
So one is template and
one is binary expression.
Okay, let's play another round.
Are these lines different?
And actually the answer is yes again.
So the first one is the
constructor with parameter X
and the second is the
variable zed, with type X.
Okay, another example,
another two lines in the
end of the test function,
and again the same question,
are they different?
Yeah I hope you got it.
So yes they are different as well
and so the first one is a cast
and the second one is an expression.
And the last sample for this
game is actually this one.
Two lines, very similar in the beginning,
they have the just difference in the end.
And are these lines different?
And actually the answer is also yes
because first one is
a list of declarations
and the second one is
a list of expressions.
And you know what's interesting,
to get it we have to read
the line until the very end.
And this could be some
kind of an internet input.
And now think about the language
tool you're working with.
So you have an IDE that has
to deal somehow with your code
and it has to make the difference
in these kind of situations
to make the highlighting different,
to make the code formatting different,
to provide some different
IntelliSense for you
and in each place on this
like some code like this,
it has to distinguish
types from non-types.
And that's the magic question for C++
and for language tools working with C++.
That's actually the bigger challenge.
So we have to distinguish
types from non-types
and we need it everywhere.
And to do that we actually need to
parse and resolve the code
because without that that's impossible.
Let's think about what
affects the resolve.
So there are some simple things like
what are the definitions, that is simple.
Default arguments, so you have
to check all the signatures
to see what are the default arguments
and if it fits or not your case.
And of course the overload resolution.
All the things are in general quite easy
but still the language
still has to do with that,
has to do that, has to
understand all this code
and actually this code
could be spread around
the whole of your project so
it should not be just one file.
Okay so the language tool has
to parse and resolve the code.
What is it needed for?
Actually for everything.
So not just for some smart
refactoring and code highlighting
but for the simple things like
just formatting code properly
or highlight your code properly.
And there is a very like
easy thing like highlighting,
could we highlight with the lexer in C++?
Like this code could
not be compiled properly
without C++ version
because it required a space
between the last two angles in this line.
And this is all about
the C++, like in C++ 11
there is a description in the standard
how you should deal with that
and it can like leave without a space now
and because the parser will
just get if it's template or not
and there is a rule actually
doing an actual resolve
inside the standard description.
And to be honest that's
the only language I know
that has this big problems
coming out of their
really actually simple examples.
Another example about
highlighting with the lexer.
Like very simple,
could I highlight just
keywords with the lexer?
And the answer again is not
because here if I highlight public,
that won't be correct
because I have a macker
and actually this is a variable
called public public here.
So it's not correct just to
use the lexer for highlighting.
So how we do.
Actually there is some
kind of a game of parsers
happening in all language
tools and all IDEs
so there are different ways.
Like tools they have heuristics,
they have some fuzzy parsers,
they have like using
several parsers at a time,
and they are trying to be based
on Clang and whichever ways.
So there are many things happening.
So either we learn to
be smart with C++ like
and to find some kind of a balance
between again correctness
and performance for example
if we take the Clang formatting tool,
it's very nice and quick
tool for formatting
but do know that it's not
using a complete parser.
It's using some kind of a fuzzy parser
so it's not looking into the header files,
it's not like parsing the code properly
just because it's for another task.
It's for quickly formatting your code
but it could be confused in case of C++
because like things happen.
Like IDEs they are doing
a lot of stuff here
so I'm not going to talk very
detailed about these ways
but there are a lot of things happening
in the way of optimizing the parser
so it's different from the typical parser
that the compiler is actually using,
the compiler usually
resolve the name immediately
when it meets it.
IDE could sometimes postpone
and it really helps to see the time
to encourage the performance.
IDEs they like the global includes
because these are some
kind of the same headers.
Same header files included
into each translation unit
so they can cache and that's good
until you write some kind of a define
before you global include.
Local reparse is also a good thing
when you could save on performance
because you could for example
skip the whole function body
and just parse the function signature
until you use the auto return type
because in that case you have
to parse the function body
to understand actually what's
going back from this function,
what's returned back.
So there are many tricky ways
and with that understanding
let's now look at the actual features
that are coming from the new standards.
This is some kind of place
that I'm gonna work through for now.
Let's start with if constexpr
that we already have.
So this is the example that
is solving a pretty easy task
like get value dependent
on either its point or not.
And here is the implementation
using enable if.
That's quite like nice
and maybe something first
coming into your mind
but now let's look from
the point of a tool.
If we manage to find
get value call somewhere
and we try to find out
what is that actually
we have to look and compare
what is actually there,
is it the first or is it the second one?
So we have to calculate this enable if
and we have to understand
what exactly is the function.
Is there a better way?
Actually these.
So I could rewrite this nice
function with if constexpr
and just hide everything inside
and that's actually a good thing
because I'm hiding the
implementation details actually
inside the function.
And now the IDE has just one function,
it has auto return type
which I said is not very nice
but still it's like one function
so if you just find usages
you just click go and look for all of them
and you just don't mind what's inside
until you really have to.
Okay, this is about if constexpr.
Now let's talk about the concepts.
Actually concepts is a very good thing
from the point of language
tool to some extent.
Because it's like a template
with the proper interface.
Because what is template
from the language tool?
It just a text.
It has nothing before it was used,
so to understand what's
there in the template,
the language tool, the IDE
has to find the usages,
has to understand how the
template is instantiated,
how it's used.
But if we have a concept,
then we can make some decisions
based on this concept.
We could cache some information
and later we could check
if it's fitting the concept or not
with this kind of cache information
and we could even do more,
we could suggest some
completion for example,
if the concept is saying
that there is some kind
of function existing there
so we could for example
complete it, tweak it,
make some checks,
we could provide some additional
information about this text
and so you while you are
writing this template
you could benefit from some IntelliSense
that is better than just simple text.
And actually like talking about the cache
when I said that we could try
and cache some information,
that means that we could do
some performance improvements
on the stage of checking if
something complies this concept.
Okay now includes.
Like what is includes in C++?
Just a text includes, text substitution.
That's really bad if
you look at this example
on the right of the slide
and you just get that this line with X
from the sample from the game,
it actually has different meaning
depending on what magic is
because it different like it's either type
or X is just an integer and
it depends on this magic
and so if you have like this
header file, you parse it,
you get all information to understand
what's really in your code,
you have to find out what this magic is
and if someone is changing it
you have to reparse the whole thing
and change all the
information in your code.
And this just insane for the tools.
So when you have lots of
higher files built like that,
don't be surprised that you see
that your tool is just going mad
because it's trying to reparse
the thing all the time.
Like you see that the problem here is that
actually the information is
affected by this kind of context
and it takes most of the time
for the language tool to understand
what's inside to parse to take information
from these header files and these headers,
they could be included in
different transition units
with different context and then
you have to store all the information
again and again with using this context.
And the one story is that
one that's global include
and another story is completely
when this is some kind of
local include somewhere
inside your C++ function
somewhere in the beginning
or somewhere in the middle.
So this and there are also
like ill formed includes
that makes the whole story even worse.
What is better, modules of course like
because this is the thing very similar
to what we for example have in Java,
we have imports with a very
clear interface defined.
And if we know what's inside,
that's actually great because
we could guess that there should
be these kind of functions
and we could complete
them and we could say
no if you're making a
mistake in the function
we could like highlight in red
and say no it's not from
this, from this module.
So and modules hopefully
are less context dependent
and if we think about ASTD Two
Like when Alisdair was talking
about ASTD Two at C++ Now,
I was very glad to hear
that he was talking about
this kind of direction with
concept and modules in ASTD Two
because what for example
we do in our tools
for ASTD library for
now, we do some hacks.
We try to guess what's
inside this standard library
for this architecture, cache
this information, and use it.
But that's not legal because
that's just context include.
But if it's a model these
hacks become more official
so it could do it like
in a true and natural way
and this actually optimizes the work
and make your actually
work with the code easier
because like you have
you already helping you
and not struggling with
your text includes.
Now let's talk a little
bit about contracts.
I won't be talking about them a lot
but I would like just
to show the possibility
that it could be bringing
to the language tools
because what the contracts are,
they're just the runtime checks
but what if your tool could check them
before you run the application?
That's actually possible.
You just need to do the data flaw analysis
and to include these
conditions into this analysis
and hopefully they could
be checked to some extent.
That's doable so we did data
flaw analysis in C lines
so and we know that actually
some of these conditions
could be checked as well.
So the contracts,
if you think about them like
just a runtime conditions,
that's good, but maybe we could do more.
Now let's talk about reflection.
There are actually two
possibilities for reflection.
Introspection and code generation.
If we take the introspection,
it's just the ability to inspect a type
and retrieve various
qualities from the type
so you might want to introspect
like object data or members,
some member functions, some
inheritance hierarchy, whatever.
And the good thing is that
tools, language tools,
since they parse the code,
they have all the information
for your introspection.
So they can provide it to you
so that it's not an issue.
And it could be quick
and that's actually good.
But if we talk about reflection,
we should talk also about
the code generation.
And generation code is,
it's actually big and huge opportunity
that you could get into your code
and like I will switch to this slide
with metaclasses talking about
code generation and reflection
because metaclasses actually,
a great thing from the
developer point of view,
it helps us to avoid boilerplate code
and this Herb's proposal
actually is intended to help us
to follow some constraints to get some DSL
without an actual compiler,
different from C++ compiler.
But for the language tool it means that
it has to generate all this code
so this is the example
from Herb's proposal
that's very simple so we just
tried this small shape code
in the top right corner
and you have this kinda
for metaclasses interface
definition somewhere
hopefully in some standard
library for metaclasses
and you just get this kind of shape
with some information generated out of it.
And it could be much more
so you could generate
a long list of functions
the other stuff there.
But the thing is that
from the point of view
of the language tool
you have to generate this code
and you can't postpone it
because you'll start using
this kind of a shape struct
like this kind of a shape
interface over there
and you'll need all these
functions to be completed.
You'll have, you'll already
check these constraints
that you have only these functions
and don't have any other functions
so this is something
that we can't postpone and we have to do
and this is some kind
of for C++ interpreter
that's happening inside
your language tool.
There could be like some ways to cheat
so we could just allow everything
and like say like do whatever
you want until you compile it.
Or we could just treat everything as text
but that's not a good way
because it doesn't help you in any way.
The better way is indeed to
check these kind of conditions
and to parse all the definitions
and probably if we parse
the metaclass definitions
we could even provide some IntelliSense
inside these metaclasses definitions.
So not to treat them as text.
Like not to treat this piece
on the left just as text
but to provide some highlighting
and completion there,
that would be awesome.
But that needs all this code to be parsed
and that's really tough.
Like that's the story about
the reflection code
generation and metaclasses.
And also I would like to talk here about
the modernize tools.
So we have, they are common more or less,
so we have the C++ core
guidelines, we have support,
native support for core
deadlines and Visual Studio
and some guidelines that are
supported in Cevelop tool
and Clang-tidy that's a very powerful
Clang family based tool
that provides a lot of
modernized features.
And it's actually helping
to transform your code
into a more modern way
so and I just want to run
and to show for those
who never saw how the Clang-tidy works,
just a small example of integration
that we have with Clang-tidy
and they're just running the
whole Clang-tidy bunch of stuff
with some modernized checks on the code.
So it's actually finds
the issues and fix it
so you can just run it
with minus fix option
and it will update your code.
And that means that it
could bring your code
from the old legacy stage
to the more modern code
that is maybe easier and
hopefully your language tool,
and the language tool
can help better with it.
So if you would like to
see more about the tools
I will actually be doing another talk
about the tools tomorrow
so showing you like lots
of bunch of that stuff.
But for now I get
actually that's it I guess
it was quite quick but still
there are some useful references here
if you're interested in some more details
of what I was talking here
actually the last one is exactly about
some optimization happening
in language tools in
comparison to compiler,
the talk on LLVM meeting was quite short
but there is a slide from the long talk
that was happening at my user group.
So and now we have lots
of time for questions
so I'm ready to answer whatever you have.
(audience applauds)
Yeah.
- [Man] Where can we get
a copy of the slides?
- Sorry?
- [Man] Where can we get
a copy of the slides?
- I guess they will be published somewhere
at least the organizers
asked to store the slides.
- [Woman] Video, video's on YouTube.
- Yeah so I guess somewhere
under the YouTube video
will be some links so I guess
you will find the slides.
More questions?
- [Man] Is there any changes
that you would like to
see coming forward--
(coughing drowns out speaker)
- Sorry. Like yeah
everything I was talking here
is the change that we would
like to see to some extent
like maybe the metaclass
is not our biggest fan
or like from the developer
point they are very interested
and from the point of
language tool they are tough
but anyway like all the stuff
about modules and concepts
seems very interesting
and provide very interesting abilities
like very interesting features
that could be built upon
these language features
and the language tools
and that's really great like
there are new horizons coming.
Yeah?
- [Man] So the IDE has to deal
with code that is incomplete.
- Yeah.
- [Man] But still provides
meaningful results.
- Yeah.
- [Man] So how does all
this kinda tie into that
like all these fancy new
features, how do you...
- Yeah we always have to deal
with incomplete code you know
it doesn't matter like if you
have old language features
or like C++ 17 but like
that's the usual thing
so we have to deal somehow we have to like
store some things for some time
to wait until you finish some constructs
just not to spoil
everything on your screen
but that's the like typical thing,
we try to deal with that so at
least maybe not like you know
blow off your code until you
type the end of the statement.
But that's the typical rule
so you got to it quite quickly
so no rocket science actually there,
just the thing that you
have to keep in mind always
when you are like implementing
this kind of stuff.
Okay, more questions?
Okay you can come later
to me or to the booth
and I can answer more
if you have some more questions in mind.
Thank you.
(audience applauds)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>