<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Diego Franco “LauncherOne rocket with C++ engine” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Diego Franco “LauncherOne rocket with C++ engine” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Diego Franco “LauncherOne rocket with C++ engine”</b></h2><h5 class="post__date">2017-10-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kfGPJlcBb7Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Thank you guys for being here.
Really appreciate it.
This is my first talk (nervous laughter)
so don't hit me too hard.
I'll try to do my best.
Hope you enjoy it.
So let's start.
Let's have an introduction
about the company.
What Virgin does, just so you guys know
what the product is all about.
And what we are doing, that's developing.
Basically we are trying to competing
the putting satellites in the space.
And right now is quite expensive.
Using bigger rockets
such as Falcon and so on.
And there's now a new
trend of the industry
to have new rockets that are
cheaper to deploy satellites
and this is one of them.
They use a size 747 airplane and attached
you can see a rocket.
Basically the rocket takes off,
the airplane takes off with the rocket,
and releases it,
saving some costs during this procedure.
And then it takes off,
the rocket takes off,
and then goes to space
and release the payload.
Yeah that's basically what it is.
Basically the payloads are not enormous,
it's trying to break a new industry for
new companies to start deploying
their own satellites to deploy.
Whether satellites is easier or there
are some companies that
want to deploy internet
in other places around the world.
So it's gonna actually new
opportunities for lower price.
So first I have to say thanks to my team.
Mostly, obviously, my software team
which I'm very thankful all the things
that I learned with them.
Yeah wanted to say publicly.
About me, I'm the
software developer for the
safety system for the
rocket, the main engineer.
This is the rocket that you see behind.
It's kinda large.
(laughter)
So before this is the agenda.
So I wanna have an idea what people
are the best intentions here,
how I can take it better.
Would you mind raising
your questions, your hand,
the people who's more
interested in the code per se
or a number of you what it
takes to build a rocket?
Like you prefer have an
overview of the rocket
from the system stand point of view
and getting to know what it takes.
How you make decisions based on those
requirements for the software design.
Okay.
So I'm gonna try to do my best,
obviously I cannot disclose
our very specific information.
So I'll try to do my best
in answering questions,
to my best knowledge I can.
First is rocket engineering overview,
then we're gonna talk about how to
have a system design based
on your requirements.
How requirements for critical systems.
Then we're gonna talk
about error handling,
what are one of the
approaches you guys can do.
One thing that I should
say right now is that
error handling is very
subjective sometimes.
If you follow your error
handling policies very consistent
and you test it and it works,
well I cannot say it's bad, right?
At least it works.
But I'm gonna show you some methodologies
that you should consider
for your code bases.
And finally, testing for the testing.
How when you right critical systems,
it's so important to test
absolutely everything
that is being done.
And when you actually
design the architecture,
it's so interesting
that most of the effort
goes into having an
architecture that you can
test absolutely everything.
Obviously you wanna make maintaining wall
and we're gonna talk
about those things later,
but it's so important how
testing changes everything.
One thing, simplicity is
the soul of efficiency.
I like this phrase a lot.
When you build critical systems
there's another saying if I'm correct,
it goes like this,
anybody can write computer code
that computers can understand,
but good programmers write code
that humans can understand.
So when you have a critical
system it's so important
simplicity that it's
so clear the word flow.
You don't wanna have
something to intermingle
that can lead to errors.
So there's one thing there.
Why do we want critical
systems in the first place?
Well for instance we have in
1996 European Ariane 5 rocket,
it terminated due to
developers, if I'm correct,
they disabled the
assertions and what happened
is that there was a
floating point at number...
A casting conversion to a signed integer
so that goes hardware overflow.
that wasn't seen because they did say
well assertions so they were running...
Well no I'm not sure about what's
the cause why they didn't get it,
but basically lack of testing.
Not checking the ranges
for your algorithms.
You need to make sure when
you're running an alogrithm
you need to make sure what's the range
for the mathematical
equations that you're running
where they are undefined.
Or running when it is divided by zero.
That's pretty obvious, but you should know
what parameters the whole
algorithm works for.
This is like a closeup for the rocket.
Here in the front you can see
a payload has to two stages.
The first stage takes you
horizontal wise up to space
and then the second one
is used to go vertical,
if you were to deploy then.
The payload.
Okay so what are the basic challenges?
I mean there are tons of
challenges in a rocket.
I'm just gonna name few that
I consider important for us.
Radiation, I'm gonna talk
about that one later.
Temperatures, as you're closer to the
sun obviously gets hotter.
When you are close to orbit it changes
between shade and direct sun
to direct point to the sun
between these temperatures,
248 and minus 148.
So materials are gonna
support a lot of stress.
Vibration, well basically
you have a rocket
which is going around 20
to 30,000 miles per hour.
And any little dip with the
air can cause a huge vibration.
The fuel is not too efficient.
Well that's quite interesting,
even though we're going to low orbit
we don't need to have like the most
efficient rocket in the world.
But by definition rockets,
they're not too efficient
by the law of conservation of momentum.
I believe, if I'm correct,
if you wanna use a rocket
to go to another star
and you wanna go within
a person's lifetime,
you will need to have
in fuel all the energy
of the shown visible
universe as fuel. (laughs)
it has to be able to go within 80 years to
Alpha Centauri or something like that.
So problem with that is
because when you have fuel
you have to bring the
weight with it, right?
So that becomes a problem.
And now there are new technologies.
I dunno if you guys are familiar,
there's something called
the electromagnetic drive,
that supposedly breaks the law of
the conservation of momentum.
And what it does is it's
like a closed capsule that
you radiate microwaves inside
and then it starts moving
by itself without having
any contact with the outside.
You guys can Google it,
it's very interesting.
So those type of things we might be using,
maybe to go to very far places.
But to go to low of
orbits rockets are perfect
because we convert with the
deals of the weight of the fuel.
Any questions so far?
Okay so radiation.
There are different
things that we consider
when we have hardware
that you're gonna run
software on top of it.
Two important things that can happen
on the gates of the
memories were is an l1 cache
or even the registers
of the same processor
is running instructions
like the program counter.
Those are gates right,
it can be implemented with MOSFETs
or BJTs or whatever it is.
If you have radiation it has
to be ionizing radiation.
So what that is is that
the atoms sometimes they,
when you knock out the
electrons on their last orbit,
they become ionized and they can change.
They try to, with the
electromagnetic force,
try to create new bonds.
And that's the danger
of ionizing a radiation
because you can basically
change the structure of things.
So that's why we don't wanna
have x-rays a lot through us
because it can change the
structure of our DNA for instance.
Well that happens the same thing
with memories and processors.
When you have ionizing
radiation hitting those gates,
you're gonna change the
structure of the material inside.
And you can change the voltages.
Now if you change the voltages,
how is that gonna happen?
For instance you have a MOSFET,
you can create a shortcut between
the train and the gate, I think?
You can consume a lot of current
and if you don't shut it down,
that's gonna burn the gate.
It's gonna burn your
processor, and memory.
That is what's called
a Single Event Latch.
Is when you have radiation
and you don't stop it
because it's gonna keep
running the shortcut.
A Single Event Upset is just it hits it,
but it comes back again.
The problem is you lost information.
You had a one, you had a zero,
and that becomes an issue.
So what type of radiation
is going to effect?
Basically any one which
is ionization radiation.
For that we have alpha, beta, gamma.
Basically alpha is you
know what we call quartz,
just protons and neutrons.
Beta is you know belongs
to the family of leptons,
where we have electrons
and also neutrinos.
And then gamma you have photons.
Photons as they reach the frequency
higher than ultraviolet,
they have enough energy
to knock out the electrons
of your atoms they become ionizing
so in that regard you can see
gamma ray, x-rays, and so on.
Infrared is below there, is
on the other side so is safe.
Okay so what do we do to prevent
our cells from a Single Event Upset?
Well vendors, they have
something which is called ECC,
An Error Correcting Code.
So an Error Correcting Code allows you to
write back the original value
that you had if you had radiation.
Which is awesome.
Procedures that run
these algorithms for ECC
is called memory scrubbing.
It's writing back the original
information that you had.
Let me see, so ECCs
it's very important when
you have processors that
you're going to send to space.
Because when you have radiation,
radiation it happens but
it's not like a bunch of it
is gonna change your software right away.
Obviously as they die it's bigger
as you have bigger memories.
There's a higher probability of having
a big change in its state.
So you should consider
having ECCs when you
have you know, your main memory obviously.
As it comes to caches,
l3, l2, and l1, some
vendors offer up to l2.
Having a sale on l1, it's kinda hard.
You have to be very unlucky.
But still some vendors they
add ECC to those levels.
Now very critical applications
should use ECCs on all other levels.
So that would be l1, l2, l3, main memory.
And also NAND flash, NOR flash,
so you correct everything.
But it still you should
consider at some point
whether that's necessary if
you're not already doing it
for what you're trying to approach.
Also when there's radiation
hardened components
those are processors, or memories,
that even if when you have radiation
the material doesn't change.
So you won't have change of...
Basically they're trying to
avoid single event upset.
And single event latch by
the material they're using.
The problem is that there's not lot of
demand for these processors
and they're very expensive.
So you're always gonna be way behind.
There's gonna be a
processor that is not nearly
as close to an ARM A8 or Intel, whatever.
It's behind.
[Male Audience Member] Question.
Yes.
(background noise drowns
out audience member)
All right so he was
asking what about having
what is called a triple
modularity redundancy.
I'm gonna mention that a little bit later.
[Male audience Member] Another question.
Yeah.
[Male Audience Member] So you're talking
about cosmic radiation, right?
Right radiation, yes.
[Male Audience Member] Cosmic radiation.
Well it can be,
not sure what you mean cosmic.
Like that it doesn't come
from the earth as well?
[Male Audience Member] Why
I'm asking is because I wanna
know if you have any benchmarking like how
the radiation is changing
on the lower orbits
compared to on the earth.
Because on the earth you also have this
because of the cosmic radiation, right?
So let me rephrase the question.
So what you're saying is
that you have less radiation
as you're closer to the
earth and more outside?
[Male Audience Member] right.
Yes so that's--
[Male Audience Member]
the lower orbits you
will have much more because the rotation.
Yeah, so basically we are protected by
the earth's magnetic
field that helps a lot.
So as you go further and
further the impact of radiation
goes higher since we're deploying
satellites in lower orbits the impact
of radiation is not that big.
But if you're going to Mars, yes.
You should consider it because...
And obviously the
probability of having a cell
increases not only by the size of your DEI
but also as the flight, you
know the mission is longer.
So let's say we want to design
our own critical system.
So what's the most important thing?
Oh I want to go to Mars.
Well that's cool,
but clearly what do we need to
actually get approved
to actually go there.
That's the most important thing.
So there are different
institutions that allows
you to certify so you're able to fly.
For instance for rockets you need
to be certified with FAA,
Federal Aviation Association.
For medical devices
you have the FDA 510(k)
you have other ones like
the IEC 61508 and so on.
It's almost impossible
to say I'm gonna fly
with everything that you want.
There's almost like a
negotiation that you say,
this is good, this is not.
Basically what they
wanna make sure is that
now that you have a mission assurance,
they don't care if you don't go to Mars,
they do care so you don't kill anybody
when trying to send a rocket.
when you launch rocket they don't want it
to land anywhere except the
ocean if there's an error.
So they really wanna
make sure you are covered
what we called safety.
A mission assurance is more like
a nice to have down the road.
Yes, we made it to Mars.
But just not killing anybody at first
that's a huge win already.
And sometimes it's not as
straight forward to do that.
Think about it, you have a rocket
with a bunch of fuel
that wants to explode.
And you're going at 20,000 miles per hour.
So it's interesting.
As you define those
requirements and you say,
we're gonna deal with them and we're
gonna make sure we can work
out something together.
I'm gonna comply with these requirements,
like this or like that.
You're start identifying the
risks from that negotiation
and those risks have
to be very, very clear.
In case something happens that's critical.
So from the hardware perspective,
you basically when you
design a critical system...
Okay we're alll software developers
and you know we wanna make
a really nice software.
But in order to make a
very reliable system,
you need to have the
best software procedures.
But on top of that you want
to be covered by hardware,
and if hardware fails,
you wanna be covered so the
system when it fails is safe.
There are systems when they
fail, they shut down safely.
They don't, I dunno let
me think of something.
Say that you have an electric
knife and you turn it on,
and then when you shut it down
for some reason it closes
back or something like that.
So you know that if the power goes out
you wouldn't have a sharp
knife pointing at anybody.
That's kinda fail safe.
So it's very important that
when you have these systems,
the fail safety is a must.
And the fault tolerance, you
can start playing with that.
You can say we can have a,
if I'm correct for instance,
the Boeing 74 has a
triple redundancy system
so if two processors go down,
still you have another
one it's gonna save you.
You can get away only
with one, fault tolerance.
You can say well I'm only
gonna allow one fault to happen
and I can keep working.
If something happens
again, we'll I'm fail safe.
So those are the type of
things you negotiate with FAA.
Any questions so far?
[Male Audience Member]
when a rocket explodes
on the launch pad,
what kind of repercussions
are there for the...
okay we've gone through all of this
and it's not supposed to happen.
And yet we do know that that
does happen from time to time,
does that turn into like
a huge company crisis?
Or is it just we'll get
it better next time?
When I talk about at later,
turns out that testing
rockets is very hard.
Because they're very expensive.
Say like when you develop...
I'm sorry, he was saying
that why things go wrong
when we launch a rocket in the launch pad?
What's going on?
Right, that's basically what it is?
[Male Audience Member] so my stat is
we know sometimes they fail.
Because we just watch TV.
And my question to you,
we have all these procedures
from the, whatever is the FDA,
to prevent exactly that--
Right, okay so basically what you're--
[Male Audience Member] what
kind of repercussions that
go through the company, do
they close down the company?
Or do they just...
I'm curious what happens
to your organization.
So what kind of repercussions
we have if something goes wrong.
We launch a rocket and how is
it gong to affect the company?
I think that's a very open question.
It depends on the company, their budget.
How much can you afford?
For instance, the 1996
European rocket that I showed,
if I'm correct, that cost the
company, the European agency,
370 million dollars.
I dunno know many companies
can deal with that loss.
It's relative to the company.
But one thing is that it's
hard to test a rocket.
Why?
Because it's so expensive.
You develop a foreign application,
oh you run it in your
computer and your phone.
Oh, it didn't work.
Okay you can have it there
all night long until it works.
A rocket, you're gonna
send one thousand rockets?
You cannot do that.
It's super expensive to test a rocket.
So basically what you wanna do is
you wanna try to cover
everything with so much testing
to make sure you have covered everything.
And you will only know if
it works until you launch.
And still, even if you put
so much time and effort
trying to develop something very reliable,
things can get out of watch.
You know like we're humans.
But the idea of following strong
requirements and procedures
should alleviate those things.
Or should try to improve
the probability of success.
So we already talk about
radiation as you see.
Temperature protection.
That's more on the outside of the rocket.
I think I'm gonna go a little bit faster.
Processor cores.
So we were saying for instance,
there's something which
is called lockstep.
Sometimes you can have two processors
which are checking each
other's instructions.
So if they say I should be here.
Are you there?
Yes.
Freescale for instance,
they have one of these.
And lots of vendors they have those.
You can have a triple modularity.
There's three processors running all
the instructions at the same time.
And if one of them fails,
then it's democracy.
What the other two says.
Are you ready?
Okay, great so let's run this instruction.
Designing software for this type of
architectures it takes longer.
It's something it takes more effort,
but it's rewarding.
And again, I'm just for disclosure,
I'm not disclosing any specifics
for Virgin Orbit obviously.
Design in general.
(background noise drowns
out audience member)
I'm sorry?
[Male Audience Member] So
you are running your code,
in triple modular redundancy,
is this... (speaks quietly)
That's a good question.
I think it depends on
libraries that you're using.
It depends on so many
different limitations.
I would consider that
like a very open question.
It depends how deep you wanna go.
You can tweak a specific
things at the bottom,
or you can use different abstractions
so you don't have to deal with that.
How much efficiency?
How much performance you wanna achieve?
Maybe you wanna start
tweaking down the road.
At the bottom.
So you know it's...
From the software perspective,
so okay we have decided the hardware.
Now we know we're fail
safe, we're fault tolerant.
Yes, we're moving the right direction.
Okay so comes the
question critical systems
and most of the people
jump right away into
oh, we need an RTOS, a real
time operating systems.
And you know there's a
lot of discussions on the
website where we should use
a real time operating systems
or a regular OSS.
And this is like a kind
of a long discussion.
Basically when you use an RTOS it's
because you wanna predict
accurately how the system behaves.
You don't want a lot of jitter,
but you don't want a
hard RTOS performance.
It means it's very predictable.
You know it's gonna do
something at this specific time.
And very accurately.
Not all of the critical
systems need to run
with this exact timeline.
You can have some buffering between
because you're running calculations
that are not that
critical and you're okay.
If it is between these
time window, it's fine.
So it all depends.
It's not jumping into those
conclusions right away.
You need to see your timing requirements.
How fast do you wanna
process your information.
Say that you have a
specific critical systems
and you be processing the
information from the sensors.
How fast do you need?
How often, what's the
frequency that you need to
read those sensors for you
to provide a reliable system?
That changes space in the configuration.
One way to implement the OSS is that
sometimes you wanna have isolation.
You wanna run your critical applications
that won't be affected
by other applications
that are not as reliable.
So if you we have for instance,
one operating system
running two processes,
and one processor you have a really good
application that you
wrote, super reliable.
But the other application fails.
Maybe it can bring your OS down.
Okay, so now your application
is gonna go down as well.
Like if you did something very wrong.
So they're coupled somehow.
One way to mitigate that
is to use a type 1 hypervisor.
So type 1 hypervisors,
they fly around this level.
And what they do is that
you can run different
operating systems in the same DEI,
and each operating systems
get assigned different cores.
And if one of these Oss completely dies,
you want the other one
will never know about it.
Super reliable on the other
side, you're super okay.
No problem.
Some operating systems,
for instance Linux,
well Linux has a very well reliable
virtual memory system
for for other processes
won't be able to interact with your memory
unless you allow it by shared memory.
So you can say I'm going
to segregate one core
to one application and that way
I can gain more performance
and other cores similar ones.
You can play with these configurations.
Again, nothing is hard stone.
It's not like this is better than that.
It's how did you negotiate with the FAA?
Are they okay if this fails?
Great, yeah.
Because your fault around here.
So I'm just showing you different options,
but again take from me that,
oh, this is the way it must be done.
It depends.
It depends from the requirements,
but here you have the options
to play based on what you have.
Any questions?
(background noise drowns
out audience member)
Oh yeah, they're super involved.
They have code reviews, yeah.
They're gonna have a good look into you.
(laughs)
so now we decide that the
hardware, the software also,
fault tolerances, everything.
What's next?
Let's ride, let's start writing the code.
I've seen so many organization that
they don't have good documentation.
Good documentation, I've
seen lots of developers,
they don't like it.
I learned to appreciate it so much.
So much.
Before I was like, oh it's okay.
But now I know it's critical.
So when you're developing
a critical system,
let's rewind a little bit back.
When we develop We say,
oh I need to do this interface.
And then you think a
little bit and you say,
oh I have a good idea.
And then you implement it.
As you think it's great it's great.
Are you sure you really took
into consideration everything?
Oh yeah, of course, why?
Because it looks good in
your brain, oh it's awesome.
Well those decisions cannot be done yet
because you need to have
a lot of time analyze.
A very clear and serious workflow.
You need to analyze
all the different paths
the workflow is gonna go for.
And then, you're gonna consider if each
of those notes can fail.
And then what you're gonna do.
And if they cannot fail, well great.
But you have to have a very clear
logic documentation for everything.
And that is from the top application
to all the way to the system call.
All everything must be covered.
Once you have a very clear workflows,
then you may say I can
start writing my code.
And if you're gonna make
a change to your software
because you have a great idea,
well make sure the FAA is okay with that.
Everything has to be very well calculated.
This is good,
because when you have really...
Now obviously, maybe I'm going to fast,
but this doesn't apply for everybody.
We're just talking for critical systems.
If we have an ideal environment
where our customers are changing
their requirements all the time,
well that's gonna be kind hard to have
a workflow for everything.
But if we know how the system should work,
we should have documentation
right away for everything.
And these step may take some time.
And it's critical
and I would consider this
the most important one.
Actually writing code,
is just making this logic work.
But this is very, very important.
So my advice is workflows.
And when you write really good workflows,
that's the key to write
really good interfaces.
To write very clear code.
Write out workflow that you read it,
you say no it sucks.
I'm gonna show it
somebody who doesn't know
about the system to see what they thinks.
Where you show your workflow to somebody
who has no idea what your system does,
but he understands right away?
You have written a really
good class interface.
Most of the time. (laughs)
Not necessarily, but most of the time.
So take time in expressing that logic
and that's how you achieve
more simple design.
Very reliable.
And as you write
documentation make sure all of
the requirements from the FAA are covered.
That way you make sure the
code is covered as well.
Well, the software architecture must match
this logic as well.
As I mentioned before,
as you do the workflows,
make sure that you account
for every single possible failure,
that way you know what you're gonna do.
What do we define?
So when you say okay, something fail?
What do I do?
Well it depends on what you're doing.
Testing rockets is hard, it's expensive.
So maybe you don't wanna
kill the application,
you just wanna kill it until,
Wait a bit longer because
telemetry is gold.
Just having a rocket out there and
sending your data whether it's
not working or it's working,
it's awesome.
Because you're gonna get that data
and you're gonna fix
it, whatever happened,
and then next launch is
gonna be so much better.
There are other systems
that you can test easier.
It all depends.
But I would say try to push the high error
to terminate that application
in critical systems
just to the point, the
last position before
it actually hurts somebody.
That you know you're safe,
you're safe, you're safe.
Maybe nothing is working, but you're safe.
That's fine.
I'm not gonna hurt anybody.
I'm gonna hurt somebody,
okay. (exploding noise)
I'm done.
At least you've all
these bunch of telemetry,
you can get away with and you can analyze.
And you can go from there.
So for software this is
pretty straight forward.
I'm pretty sure everybody's...
Maybe I should.
Okay SOLID principles.
Make sure you follow SOLID principles.
I don't think there's
much to talk about there.
It's pretty well known fact.
class designs.
When you write the software architecture
make sure that you have the workflow.
Have a class design where
you have a clear interface.
Also think about what data
structure you're gonna use
or what design patterns you're gonna use.
What type of inheritance?
You're gonna use an interface
or you're gonna use a base
class that's gonna provide
some sort of common
code for something else.
And also number of threads.
Now think about when you
have number of threads,
that becomes tricky.
When you have critical systems
and you have multiple threads,
you should be very careful
how you're doing things.
Because when you have multi-threaded code,
you have always conditions,
you start adding more complexity
to the system than needed.
So everything must be very...
It's not like throwing threads just
because oh it looks better,
or better performance.
It's about safety all the time.
Libraries.
Well you may think just
very expensive libraries
are the ones that are used in rockets.
Not necessarily.
Libraries that are well
maintained, for instance,
what I do is sometimes I talk to
the maintainers in an email.
I read what they're
doing, I test their code,
and I notice, oh I found an issue.
I'm gonna send them an email
to see how fast they reply.
You start seeing their
interaction, if it is active.
And then if they have a code base
which is very well unit tested.
And then when you go
through their source code,
at least there's good documentation.
You could argue, you can use that library
for your application because you know
exactly what's going on.
An you can test it.
There's no like a hard decision,
use this or use that.
Because it depends on these factors.
And also when you have
libraries that are used just
for initialization of the rocket,
so let's say that we ar in the launch pad
and we turn on the rocket,
something fails because of a library.
But nothing exploded, everything is fine.
Okay make sure the initialization is fine,
but for run-time has
to be very, very picky.
You don't wanna run-time
something to go wrong.
Libraries that are used in run-time
are way more picky to be chosen.
For reliability purposes.
Any questions?
(background noise drowns
out audience member)
Yes, everything. Like, everything.
(laughs)
Okay, so for software
development, this is for the FAA.
I guess most of the
organizations follow this.
At least for safety critical systems.
Test-driven development.
So obviously every single
commit must have their test.
And the unit test that they should have
should not only test all of
the interfaces from a to z,
but should also test performance.
Or it should also test some
dependencies that it has.
You have to be super picky with unit test.
Basically we're gonna talk about it later,
about unit tests, but it's critical.
Obviously ticketing system.
Ticketing system should
match requirements.
FAA wants you to do this,
you should be able to
connect them and say,
this ticket is gonna help with
this requirement and so on.
At least you know you're
compliant with everything.
Repository.
I don't think there's
much to say about it.
Build server.
The build server, you can have continuing
building your code.
We want to be testing as many
things as possible all the time.
So may you wanna have in the build server
not only a unit test,
but also an integration test.
So when you have the
final of your software,
you should have say
another piece of software
which is testing your software.
Based on mocks.
If you try to add more unit test,
every time you push something to master,
or before your marriage to master,
because you know it's being
complied to be reviewed.
Try to run as many things.
So before the build server
tells to your team to review,
it has passed so many unit
tests, integration tests,
that finally code review comes into play.
It gives you more reliability.
Now.
[Male Audience Member]
What kind of metrics do you
use to ensure that you quality code
in regards to the tests?
So what kinds of metrics
I use to make sure
that the unit tests
match the requirements?
[Male Audience Member]
Exactly. And also that
the units tests fulfill quality standards.
Right, so basically when
you write your documentation
and you write your workflows, guess what?
That's also checked by the FAA. (laughs)
So if you have a software architecture
that really reflects the workflows,
since the FAA also review your
software architecture (laughs),
make sure that your classes are tested.
Like I've already said before,
you know already what your
class should look like.
When you run unit tests,
basically you're just
trying to do bug hunting.
Like I actually phrase later.
You're just trying to check.
You're not saying, oh this works, awesome.
You're just trying to say
I wanna find that bug.
So try to hit it hard.
Try to make sure all day,
like the pre-conditions
and post-conditions
of all the interfaces have been tested.
So if you have a constructor
that accepts a specific type,
make sure that those ranges
have been tested very carefully.
As I mentioned before,
when you have say a class that
is calculating an algorithm,
and it's expecting three dowels
or whatever types they are,
make sure that those combinations of types
is not gonna lead to something weird.
Like an underflow. Overflow.
Yeah.
(background noise drowns
out audience member)
Well I guess it's because you didn't
write a unit test which is good enough.
That's the thing.
I'm sorry, so he was saying,
when you make a change in the unit test,
say for performance,
and then it passes.
How do you know that later on
that is going to affect you?
Because it passed the unit test.
Well there's a problem with the unit test.
That unit test is not actually
measuring the performance needed.
So unit tests are,
like I spend more time in code review
sometimes than unit testing anything else.
Because everything has to be
to the limit all the time.
If you can.
Yes.
[Male Audience Member] How
much time on average it takes
for the build server to actually verify
each commit before it comes--
Well it depends on what you are testing,
how you're testing it.
So for instance,
let's say that you have a class that is
waiting for an elapsed time to happen
because you're waiting
for a sensor to come over.
You're testing on a server,
server is maybe not using the
hardware that you're using
in the rocket, so you use mocks.
So you wanna use a mock, great.
But maybe you can create a
mock for the time as well.
You don't need to wait one minute to run,
but actually you can
set one minute virtually
and then it can jump and everything.
So you can start playing with
the dimensions of time as well.
So you can run a test that in
real time can take one year,
but you can simulate it faster,
and actually can be very
reliable if you do it correctly.
So let's go to error handling.
So we have software, oops,
let's try the next one.
I like this one.
Software testing is a sport
like hunting, it's bug hunting.
That's what we're trying to do.
It's not saying it works,
it's saying at least we didn't
find anything weird so far.
(laughs)
Okay, so what type of errors we want?
We want the ones that are hard errors,
like oh nothing is gonna happen.
We need to terminate.
So those are the most crucial ones
that you want to leave for last.
You don't wanna kill your
safety critical system.
Imagine if it is artificial ventilator
and you kill it.
Well you're gonna kill
a lot of things as well.
The last thing you wanna do.
Obviously I think this is very
obvious for most of the people.
You always wanna try
to have compile-errors.
More than anything else.
And there's always a
way to get away with it
and sometimes it's not
as straight forward.
Sometimes we just get carried away by
so many things because we're thinking
so many details that we forget,
oh, maybe I could have
done this checking wrong
in compile-time.
So always put a lot of thought
when you decide where something is giving
you an error in initialization
because I've seen, based on my experience,
so many opportunities to refactor a code
and actually make it much better.
Where you can get away with compile-time.
Now initialization.
Well if you're gonna start
the system and it fails,
phew, we didn't lose the rocket.
Okay, that's fine.
Or you start on like a TV show ventilator
before you give it to a patient.
Okay, didn't work. Let's get another one.
So it's okay.
It's not ideal,
but you wouldn't kill anybody
if at least the operator,
who's managing the device,
is not doing something crazy
with the patients and users.
And run-time, if it is critical,
I have to say it's unacceptable, right?
I mean it's bad.
You don't want that. (laughs)
Okay so some examples of compile-time.
I like this example because
basically when we have a code
base and there's an error,
what do we want to do?
We wanna log the error.
Because we don't wanna kill
the application completely.
We wanna keep working.
What if there's an error
on the log as well?
What do you do?
You're gonna lose that
precious information.
What if that error was telling
you crucial information
about the system and you're gonna miss it
because you did something wrong.
And the class is not gonna be
able to send data specific message.
So obviously there are things
that we cannot control completely,
But there are things that you should
be able to ensure for your own concerns.
You're writing an application,
the application should be
able to have post-conditions
assured up to the moment
because a system call.
So you should never have
calls, to system calls,
that can fail because your
application is sending
something that doesn't make sense.
If it fails because the kernel
did something wrong okay.
But applications should assure
at least what I did is correct.
So for instance, this is one way.
You can have like a message.
Okay let's say you're
sending logs through socket,
and then usually system
calls they have like
a pointer for the message you wanna send,
and then decides.
But what if you screw with the size of the
pointer that you're gonna be sending?
What if it's super huge?
Well it's gonna fail.
So try not to do that.
You know C++ gives you so
many tools to avoid that.
So for instance, let's look at this one.
So you can have for instance a struct,
which is not a point.
You're always gonna have structs,
and you can get away making sure
that you will never accept a pointer
by using like a type trade
code, STD, is pointer.
So you can use something like STD enable.
Enable if t is the same,
if it is a pointer and you deny it,
you can assure that you will never be able
to have a pointer here.
It's always memory that
is known in compile-time.
Well what's the advantage of that?
You know the size of it.
You can know in compile-time
what's the size of the message
and you can do something like this.
You can assert in compile-time
if we're trying to send nonsense.
That's one example.
Let's look at another one.
Well this is for enable if.
As I mentioned before,
sometimes we have...
I'm sorry, how much do we have left?
15 minutes, okay.
So sometimes we have classes
that can have overflows.
Look, seriously.
Have a class to check for safe at.
If you're adding integers.
On sign make sure that you are making
sure that you're not gonna overflow.
Even if it takes more
clogs in the processor,
it's fine.
You're not running a high
frequency training system.
So when you write these types of classes,
you have to define for what
types they're gonna work.
You can do something like this.
Like an enable if for a specific types
you know your safe at is gonna work.
It doesn't need a sign or
a sign integer or so on.
At least you're making
sure in compile-time
you're not gonna be doing
nonsense with the types.
Okay initialization.
There's not to much to
talk about this one here.
There are some things that
we just cannot control.
Like for instance there's another
pilot system for an airplane,
what if there is no sensor involved?
There's nothing you can do.
You just have to say hey,
I cannot start the system.
This is not working.
So what you do is that you throw.
You throw, you're saying there's an error,
you have to throw right away.
You have to stop the application.
Now in run-time, there
are different situations.
So we have class a step.
It's expected to fail frequently.
It's expected to fail infrequently.
It is not expected to fail.
Can fail depending on the circumstances
and never fails.
So let us start with the first one.
It's expected to fail frequently.
Let's say that we have
a mathematic algorithm
that is running some calculations
based on some input of a sensor
which is giving you random data
based on temperature, or whatever.
You cannot know in compile-time
oh, this is gonna work now.
Or I'm gonna throw if this is like that.
You will never know until you
actually run the calculations.
So for those things,
well it's likely it can fail
and actually quite frequently.
For those type of
situations where you expect
something like calculations to fail,
but fail doesn't mean
that there's an error.
When it fails is that,
I'm gonna show you in the next example.
Let's look at this code.
What do you think is the
problem with this code?
If you're running a critical system.
Right so, we have here,
we're creating an instance of a bool,
which is calling this
free function calculate.
And usually for instance in kernels,
you say okay, here's my data,
you calculate it and let
me know through the return
whether it's valid or not.
And then you say if it is
valid, okay I can use it.
Well the problem with this is
when you're writing critical code,
well anybody has any ideas?
(male audience member replies)
The what?
[Male Audience Member] It's not valid.
Yeah so basically, the
problem with this code
is that result still can be used
in the code and is invalid.
Basically the end user of this interface,
maybe he misused that interface
and he forgot to check for is valid.
And then he's gonna do
something with result
and it's gonna be very bad,
because he forgot to check his valid.
So basically what you have is instances,
say in this tach, this
function in this tach,
that are invalid and you're dealing
with that in your critical system.
That's seems pretty dangerous.
But again, we're just
sharing subjective things.
As I mentioned, for instance,
the kernel in Linux is
written very reliable.
It works very nice.
And it does things like this.
So I'm not trying to say it's bad or not.
Just saying there are some idioms you
can use to try to avoid those situations.
So consider for instance,
in C++ everything we
have is totally optional.
Okay you can get away with
this, this is awesome.
Because you can check
whether it failed or not.
Great.
But this only works for so much.
Let's say that you have a
class and the class can fail.
And it has five interfaces.
So what are you gonna do if it fails
and how do you know if
the other interfaces
can be used or not?
There are different ways to do it,
but one reliable way...
So to clarify, this one is
basically gonna tell you hey,
this object I'm gonna return to you,
is valid or invalid.
And you can check it like
doing something like this.
Why checking it like this is good?
Well if you notice you're
creating an instance
of STR inside of the if.
It's a code.
That means that you will not
be able to use it. (laughs)
An invalid STR over here.
So it's impossible for the interface
if you use this idiom of the if is code,
to use an invalid object of STR.
So it gives you those semantics of
that type of idiom is code reliable.
Objects.
Let's look at this.
So this I value a lot. Why?
Sometimes you have
classes. Classes can fail.
You have a bunch of interfaces that you
wanna make sure that the interfaces
that you provide are reliable.
You wanna make sure that hey,
if this constructor works,
I know all the interfaces are okay,
you can use them as much as you want
and it's never gonna fail.
Great. How do you do that?
Well I like the idiom
of the safe bool idiom.
And how you can improve it?
Obviously when you use
your defined conversions
by using an explicit bool.
So let's go through this pretty fast.
So basically on the
constructor you have a valid.
The valid is gonna run some calculations
to make sure that whatever,
maybe this example
doesn't show it too good.
But let's assume for some moment that in
calculate constructor you have some types,
some arguments,
then valid is gonna call a
function, private function,
to say hey,
these were the arguments
that were sent to me.
Is this okay with us, or not?
And they're gonna say,
oh this is okay or not.
They're just gonna return
that true or false.
Then valid gets a sign whether it's valid.
And then, the result
can get the calculation.
Maybe if valid was false,
the calculation that
we solved is nonsense.
And also other result is gonna
get other nonsense calculation
because valid was false.
But that's fine.
Because the moment you try to get result,
it's gonna assert.
It's gonna hard assert.
And that's gonna show you in
unit test or integration test,
you did something very silly.
If you didn't follow what
the interface was saying.
So in order for you to
always avoid any assert,
just follow this idiom.
If scopes if.
You will never be able to have
an assert running something weird here.
And you're also making sure that
all the interfaces are valid.
So you know like we see here,
we create an instance of calculate.
And then when we call the if,
we're gonna call the explicit defined
conversion for a bool.
And then it's gonna return
valid true or false.
So this if is gonna result
in the true or false.
And at that point we know
that all interfaces are valid.
They're not gonna assert.
[Male Audience Member] What happens to
those asserts when the rocket flies?
So what happens to those
asserts when the rocket flies?
One of the reasons why you have the
critical failure in the European Agency,
is because they did say well, asserts.
And what I propose here,
and again I'm not trying to
say this is the correct way,
the philosophy that I like,
is that the pre-conditions
and post-conditions
of the class should be assured completely.
They cannot give you nonsense.
That's a huge danger.
In order to enforce those conditions,
you can do assert.
And you can do a hard assert saying no.
This is just totally, I have to abort,
I'm just doing nonsense.
Now, if you do well unit test,
and well integration test,
and I just mentioned few.
Because when you have a rocket,
you have like other five
or six seven stages.
Like on the flight and so on.
All those should pop up.
And normally when you have for instance,
say a critical, an artificial ventilator,
you're not gonna test
artificial ventilator
with new features with new
patients to see if it works.
(laughs)
Usually what you wanna
provide is something that
is so tested for the procedures
that you're gonna know it works,
that you know everything
is not gonna assert.
If you really run unit test as it is.
So that's the philosophy
I wanna show you today.
[Male Audience Member]
So the answer is that
even when they're in flight
your kill system value won't--
Well--
[Male Audience Member] Start
to recover from assert.
Okay, so he's saying that even when
you fly the rocket, you're
okay like a certain.
Yeah well basically, no.
You shouldn't be okay.
Because that should never happen
if you use this idiom and if you
had really good code review.
Also if you have really good
unit test and integration test.
[Male Audience Member]
- what if it happens?
Well if it does happen--
(audience members respond)
So there's like a limit to things.
You cannot say like...
That's why I was saying when you
have unit tests you're bug hunting.
But you're not saying this work for real.
You're trying to find issues.
That's why it's so important to run
unit test so much and well done.
But I mean, from what I've seen so far,
the probability that you have
an assert like this failing,
is super low.
Extremely low.
Because when you have critical
systems the workflow is so simple.
Starting with.
And when you have a very clear workflow
and you run not one unit test,
we're talking about you're gonna be
running thousand of unit tests.
With a lot of integration tests.
If this doesn't pop up
because the end user didn't
use the interface correctly,
it's because something huge was
missing in the organization.
I mean this is not small bug this is huge.
This is gonna pop up right away.
So it's several things combined.
But everything comes with
advantages and disadvantages.
(background noise drowns
out audience member)
what happens with what?
[Male audience Member]
Ultimately what does happen?
Because you must have a code to
pop up you have a code exception--
If the rocket explodes?
[Male Audience Member] No, what happens
if you end up running an
assert. You have a code--
Well if you wind up running an assert,
basically what's gonna happen is that
the hardware that you
created is gonna save you.
To be safe.
So at least you're gonna make sure
that all the people were safe.
That's why you created the
system with fault tolerances.
For there to be fault
tolerance or even fail safe.
Let's say that even the power
in the processor goes out.
So yeah there are risks,
but honestly, based on my experience,
a small risk if you don't
unit test correctly as it is.
(background noise drowns
out audience member)
I cannot give too many specifics for that.
(laughter)
Yes.
Okay so expected to fail infrequently.
So you can say okay,
I'm gonna use this idiom
and I have a function which is called
run one million times.
And for example let's
say that we have a tire,
tire of a car,
and we're gonna run it one
thousand times per second.
How often does a tire get flat?
Well very infrequently.
Well do you wanna check ever
single cycle, are you flat?
Are you flat? Are you flat?
It's kinda nonsense.
So if it is very infrequently,
well try better things
such as try and catch.
Now that is if you're
concerned with performance.
Why?
Before having the zero
cost model in exceptions,
it was very expensive performance
wise to throw exceptions.
Now compilers are using what is called
the zero cost model.
I'm not gonna claim that
I know it perfectly,
but to some level it's like basically,
compilers before the zero cost model
they used to implement the
exception within the stack
right before were you
have to try and catch.
So every time you used to call out try,
you had a try,
the system was looking to
catch an exception handler
and then I'm gonna
register those exceptions.
Handlers.
Maybe you wanna check also the
constructors that had been created
in case you run an exception.
You're gonna run the second one and then
you're gonna run the catch handler.
Well the problem with that
is there is more than one.
So you're losing performance
and also all the code
is inline with the one that doesn't catch.
Doesn't throw.
So for instance,
the up high is the code
that you want to run
and then say underneath you have
the code that is gonna take the catch.
When you have processors that
they use branch prediction,
they're never gonna catch.
Possibly it can start predicting
that maybe it's gonna throw.
So it's gonna say oh, I'm gonna throw.
Oh no, I didn't throw.
You're gonna be swapping
the l1 cache a lot
and maybe losing some performance as well.
So in order to mitigate those things,
all that block must move
to other place in memory.
So when you run an exception,
basically it's just a code
and the branch prediction
won't see anything such as
any type of code for exception.
And if an exception happens,
yeah you're gonna pay a round
trip time to run memory.
But it's fine.
It just happens very once in awhile.
So these doesn't pay an
price for performance.
And you know it's gonna
happen just once in awhile.
Not this is if you are concerned
a little bit with performance mostly.
Something that is not expected to fail.
Well you have a velocity
what if the sensor
tells you is higher
than the speed of light?
That cannot happen in physics,
but maybe something is
happening with the block
that suddenly you're higher
than the speed of light.
Well that shouldn't happen.
Different ways to accomplish this.
So you can reuse the simple
bool idiom as I showed before,
and you can have a class
that checks the constructor
to say that everything works.
Guys I'm so sorry, I
tried to do that faster.
It's my first time presenting.
I think I took more time than I should.
I'm not done,
but they're telling me I
have to finish right now.
So I'm so sorry. (laughs)
I hope you guys enjoyed the session.
If you guys have any questions,
please let me know.
(applause)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>