<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Joel Falcou PART 1 “Expression Templates - Past, Present, Future” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Joel Falcou PART 1 “Expression Templates - Past, Present, Future” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Joel Falcou PART 1 “Expression Templates - Past, Present, Future”</b></h2><h5 class="post__date">2015-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IiVl5oSU5B8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so thanks to all of you let me
introduce myself so I'm I'm Topher ku
I'm a NASA set professor from University
of Paris and also CTO of Nam scale which
is a company that deal with
high-performance computing and I will
speak for quite a long time about a
subject that is probably the most most
most obscure and most you know
intriguing concepts in in C++ which is
expression templates so the original
talk title was extraction template who
when what where how but I decided that
speaking for five hours was too long so
I just shorted it to three so it's more
like past present future is more for
some definition of past and present so
what will we be doing in this ongoing
sessions is try to actually grasp what
our expression templates both
technically how it should be written and
all it works and why you should care or
not because sometimes you just don't
need them okay and as all tools is also
important to know when you you should
not using it okay so the presentation
workshop tutorial is basically split
into three sessions the first session
will be very introductive starting from
from the ground up writing everything by
hand see where the problem are what's
the main concepts and where the worst
difficulty starts to pop up and then on
the second session we speak about some
tools which already there for
simplifying that mostly Bruce Prado
I try to get as much as I can of out of
boost proto introduction in one hour if
you really really want to dig into more
details
I have another presentation on exactly
this for a bit longer times it which
available on on the CPP now web video
websites and the third part will be
about how can the new way of actually
programming using C++ 14 and beyond
actually simplifies a simplified version
of exception templates and how we can
use a new cardigan of sequences 14 to
actually solve the remaining issues that
we will go over so it was advertised as
a workshop but as a setup is not really
very cool for typing code for a long
time so what we do is we will have a
bunch of slides when I try to explain
stuff and more interactive session where
I would be probably writing code live
and asking you questions and see how all
we should be doing things everything is
available on on github ok and you know
if it's zoom enough okay so you got the
slides and all the example codes that
you will be seeing now it may be change
a bit afterwards but also matter yours
there so you can just prune the clones a
bleep or get downloads of files and
everything is inside I will also use my
taxes during the online compiler so we
can actually get the example running ok
so first things first let's make a small
poll all we need people out there
actually know what expression template
is about okay not bad and if you know
what is about how many of you survived
okay well well that's that's that's a
classical joke we get about exception
templates it's it's so complicated you
basically brain your brain your brain
out but we try to demystify that so what
is expression template what was ago so
for a long time designing libraries in
C++ was all about getting a correct
model probably a correct object oriented
model if you were into this and try to
make the library API fit this model and
fit into the actual let's say historical
C++ language syntax and after why what
we found out is that it's quite limiting
and we borrowed the page to other
languages and we go over that and now
one of the training stuff is writing
library as if it was providing your
service
as another language and by designing a
library as a language with all it means
when we see that we can actually extract
more optimization opportunities and the
your code will become more clear for the
end users because we just have to write
whatever they want to be doing instead
of writing what they should be doing to
get the effects I want so we end up with
code like this okay so that's something
I picked up from chaos here Gita which
is a representation of LLVM carried no
scope using boo spirit so boo spirit is
a library which is in boost that
provides a way to define passers and
context generators and the main asset of
this library is that you can actually
write something that just happened to
look like you just copy-paste it a piece
of grammar okay over there
directly into your CPS postcode okay so
you just write what you want to be doing
you want you write what you want to
achieve and the library itself we turn
in your description of the problem into
the actual optimize and strictly minimal
code to do this so it looks like
everything but C++ okay is only stuff
that look like C++ it's basic easy
operators and how the code is set up but
if you look at this part between
identifiers and program well it doesn't
look like we do C++ and so the deal is
by having a way to share the language
the way we want this wave for spirit how
many of you have heard of eigen yeah so
I can use the same techniques okay
we have a parent program in every called
busine D which is the same stuff you
have boost MSM that use same kind of
mechanics to help you write a state
machine directly he has you will be
writing in the UNR document and so on
and so on
so you we push into those libraries
don't specific information and the
library use this to get whatever they
need to choose what kind of course it
should be generating and so the question
is up does it works
so the main issues is to look at this on
a different angle so actually if you
look at what was going on expression
templates is actually pretty old main
idea is to say I want to write code that
looked at something else captures the
meaning of what is being writen doesn't
do any computation and ship some kind of
complex temporary object somewhere else
and the summarize we take care about
looking at your pictures and decide what
to do and the problem is up to recently
and still now the language itself was
not very keen to help us writing this in
a comprehensible manner so efficient
templates as a techniques as an
implementation techniques as being not
very something that people accept as no
more okay it's support is very flaky
some people actually are about the fact
that that we should not be doing this
and that's the job of the compilers or
so no thought and now with the advent of
MOOC semantics and our value references
copier regions so many issues but we
should be using expression templates to
do those meaningful expression
construction for performance wisdom is
actually put in question because if you
have all this core language support why
do we need this
so the idea of this is to actually see
what we can do with that and try to find
a way to make it work properly so why
using a vision template so you have
different reason to do that
answer a performances okay one of the
selling point of expression template we
will see that just after that I develop
solve old emails from the 90s was to
prevent creation of temporary array
object on the stack while composing
large algebraic flag expressions so by
removing the need of temporaries we were
making less memory allocation and the
code was more tight so answer B for code
clarity because writing what you want to
do instead of what you should be doing
is easier for the writer first and for
the reader afterwards
and see just for bragging rights because
man that's one fine piece of C++ : just
wrote and I'm pretty proud of it and of
course answer the orbs evil okay so we
will go over all of this probably not
see but many a and B okay a bit of see a
tree and we try to see how everything
fits okay so yeah as I say when we
explain all everything works we actually
show that it's not that complicated it's
not complicated it's a bit complex every
sub pieces we will be using to build our
small and written expression template
and shine is in itself a very simple
audience that you will probably use
elsewhere already the complexity comes
from the stacking of all of this in a
very tight space next part as the same
we see oh we can actually generate that
Windu's prado and see all the new sea
prospers can actually be useful and when
we discuss some new stuff and all we can
actually make all those techniques some
things that the language can provide us
that's more or less what we will be
doing so first part is okay basic
principle oh everything is supposed to
walk okay so first is okay where does it
come from it's actually a very very very
old technique 20 years older than say so
it's actually a joint discovery by on
one side taught version and on the other
side there is one would around 1994 1995
so taught was an intern at rogue wave
Oregon working on the image processing
libraries dealing with image algebra you
know like some of images and scaling of
the pixels or and so on and so on and he
discovered what we become the expression
template techniques by trying exactly to
do what I said earlier is trying to
optimize all those temporary objects Rob
where we show the technical report on
this I think it was 94 and there is a
whole bunch of C++ report articles that
you can find on the internet about
explaining all the intricacies of what
Todd found so
and at the same time everybody would was
walking on some very rare implementation
and just end up doing the same exact
kind of things and it was actually
proposed on somewhere and the funny
thing is that the actual first users of
this that pushed the the technique into
the public was a physicist that actually
published a paper in and roll called
computers in physics that say hey look
at that we can actually no write C++
code and it's as fast as our old good
old Fortran which act at the time was
big so I dig up Zeus okay so that's the
first email actually speaking about the
problem one of the first email I guess I
couldn't go I mean earlier than that so
it's made by someone that made the
matrices for complex number and the
question is I have a temporaries that
should not be there oh can I actually
get rid of that - which David the other
one say okay oh you can it's a bit
complicated and start with the most
biggest and the statement of the century
it make any use of class and function
templates okay to avoid the generation
of temporary so that problem is the
first race that is coming from CPP comp
come CPP something on Usenet okay so
that's the first stuff I found out about
this so we had a V use of function
templates that's a small to say so it's
all doesn't mean it's not useful yet so
how does it was so make issue when you
want to understand what extras and
templates is actually doing it so
actually to look at what the compiler is
doing so let's say you have this kind of
arithmetic expression going on okay with
parents and operators identifiers
constant so when you pass it with your
brain is clear what's going on but for a
machine it's a bit more complicated so
as you can bind on what you want to know
is you might want to do is understand
what this expression means and what all
is components so you can take decision
about what to do with each of them so
one classical way to do that but with
the only sane way to do that
is to being what we call a derivation
tree or syntax tree which is a tree
representing the structure of the
expression in a way that we can
construct it by traversing the tree so
it goes like this so that's a full-blown
syntax tree where everything is set up
okay so this EPA so problem by French is
expression commercially pure algebra an
algebraic expression is made of
something on the left and operator and
something on the right as and is
something on the left or on the right
can be either another expression of
arithmetic components okay
or if we look down down down the tree an
identifier X Y Z or a constant 3 &amp;amp; 4 and
by combining this you can buy you can
build arbitrarily large expression with
plus x constants in antivirus so if we
if we wanted to store the structure of
this tree somewhere we will probably end
up having some kind of tree structure
continuing to left start to right char
and whatever happens when you traverse
the tree okay so you can actually write
regular runtime based built or function
code based implementation of these three
classes you probably end up with a tree
base class with that alt interface you
need and you will probably have
subclasses like constant link fire and
so on and so on binary expression that
we just do whatever the name implies and
you can put into a vector or another
construct of base expression pointers or
reference so you can actually write this
and an ABI to run at one time probably
using some kind of factory but if you
look at them at the problem is you have
to stuff going on you have something
which is intrinsically dynamic or no
none runtime the value of XYZ it doesn't
know them yet you know it's the value
behind this identifier but doesn't know
what
and there is another part which is
completely know at static at compile
time
it's the static structure of which piece
of tree goes where the fact that you
have a tree with the minus operator is
containing two sub trees one wizard time
Submariner and one DiNozzo - with a
constant of the right and plus on the
left is completely known as compile time
it doesn't need to store this
information at runtime okay so the trick
is to find a way to say okay what I have
want to have is a representation of a
tree with some amount of children that
can embed these structures in a
competent way which means in the type
okay
so the idea is to say okay that's pretty
trivial I just could just have a first
type oh I'm going with myself so that's
a full syntax tree and so what would we
be doing to do is once we have those
types okay we can do something like this
we start from an arbitrary statement
using our library on the left yes
and on the right we see another kind of
tree okay these blue and red stuff okay
and if you look at these three it's far
more simpler than this one okay because
we stripping it of all these syntactic
informations that didn't bring anything
on the table we just have a simple tree
which is a succession of operation node
and sub trees and sub trees can be a
constant or something else but
everything about the actual syntax the
actual parents or whatever is stripped
that's what we call an abstract syntax
tree okay so that's just boiled down
version of what the compiler is supposed
to generate and what we do if you look
closely at the color code is we we embed
in red so structure of the tree into
this expression type in the big box on
the net and if you go down this very
complex type of expert of the sign
expert of matrix X pair of plus of
course of multiplies if you go down this
in one way or another you are able to
reconstruct the tree because you have
all the information I'm making in that
segment between something which is a
matrix on the left with something which
is an exposition doing some plus
operation with left hand side in the
right hand side which is each of them
being something else which can
recursively be another expression and
this information will be sold into a
type and the objects you build actually
store value copies actually are
reference to the runtime information
into the the leaf of the tree the blue
blocks okay which we call terminals and
what would we be doing is also we did
this capture somehow you can actually
taste the type of this massive tree and
you can torture it as much as you want
using template metaprogramming because
that's a type so I can transform it the
way I want until you end up with
something which is exactly what we need
to take decision about what kind of code
do I want to generate and throw in this
example what we do say okay we are
dealing with matrixes I have my trees
that give me whatever operation I should
be doing on every element of my matrixes
so I will just put out a loop nest and
because I feel it I will just put it up
on openmp prioritization from around it
and I will just we play my tree Maya
cinnamon between X and costs of a plus B
times a for every element of the matrix
is inside this box
okay so I've wrote that and the compiler
did this for me okay
and the trick happens there we transform
this iced tea as much as we want until
we know what we will be doing okay so
that's the first stuff we will be
needing to do we need to store the
matrix term we need to store the
expression as we beat them first
challenge second challenge we need to
find a way so that construction is easy
and Eden behind operators and function
overloading and third we need to have a
way to traverse this tree to transform
it or to evaluate some value out of it
and when we know how to do those three
pieces
we can actually generate whatever we
want okay so we take an expression and
we do something which is very kind to
what a compiler is doing we extract this
tree away and try to reason about this
tree
the cool thing with tree is that we can
actually do a lot of stuff with them
okay because natural process of tree is
based on recursions we will probably
have fattened matching on what kind of
node I am traversing at the moment and
we can just write regular I mean typical
that we just visit this tree and take
decisions about okay is it clear
that's the main idea of what we'll be
doing just build the tree and go down it
or whatever we need to do and when we
traverse it we just decide what we do
with it
okay so well what do we need we need to
start the expression as I say actually
we need to stuff storing the operation I
will be doing at crossing the node or
not the operation but actually a
representation of what's going on okay
we need to start the sub expressions and
the first question will be should we be
storing them by value or by reference
when we see that this is actually a real
problem and in a way to travel them to
do something at the same and then how do
we capture the expression will be just
be using operators and function
overloads and use a great tradition of
writing efficient C++ code with just Y
functions that do nothing except
returning a representation of the small
trees that are currently building so
basically your plus function won't do
anything you just return an empty shell
and say yeah I just crossed a plus
operation between this and that this is
the information I found about them
continue with the rest of the expression
okay so let's have a look I start with
something very simple okay we have an
NRI expression which is an expression
numerator or functions that take exactly
one argument so could be like only
reminders negation absolute value
whatever and the whatever operation that
being done when you traverse the tree is
tall in the
code tag over there this will give me
whatever happens when I'm encountering
this expression and I say I have only
one argument so I we have only one shot
which is another subtree and of course
this tree could be of any type so as I
don't know what it will be I will just
again store it as as a template
pragmatism and you can actually be the
next new nari expression by taking some
child and put it inside it and for for
the example what we do is we give this
expression a function call operator I
would just evaluate its value stored
into the expression okay and what do we
do well the tag actually is a type which
is itself a colorable object and so what
we do is I evaluate my cheat my child
okay see parents and whatever this gives
me I pass it to my operation okay and I
will turn whatever this operation does
so if you build a linear expression of
unary minus something we have an into
something and return - is something okay
and obviously just I just did the simple
version so it fits on the slide
obviously you can actually know except
and context per whatever you want in
this doesn't change anything
okay so that's a unary expression and in
a very very very complex way this is a
binary expression which is basically the
same except they have two children
okay pío pío p0 p1 get stored store
the operation and then when you evaluate
a tree you just call the operation
function on whatever the result of the
information of the both children is I
could have written the ternary
expression or whatever same things if
you cross your brain a bit you can
actually write just an expression that
takes a class dot dot chives we treat
you answering with an arbitrary number
of children it's a bit more complex but
you can actually do this so okay I store
unary expression in something like this
okay I still binary expression in
something like that right okay
and of course if you buy the binary
expression of binary expression and so
on and so on we just store them in one
to the others okay so type give you the
three structures and the value give you
every value around the tree when you go
down well we have a special cases that
we call terminal which is the leaf of
the tree that contains a value or
something that we contain the value it's
usually simpler because you just need to
know as a value you store inside it okay
that's a very simple terminal we see
later that it's actually a bit limited
but for for the example it's perfect so
I'm just constructing a terminal with a
value supposed to contains and whenever
you ask me to evaluate myself I would
just return the value to you so a
terminal or float continuing 3.5 when
you were very to just return use a
floating point three point five and if
you are the generic expression
containing a terminal when you will
evaluate the expression you will grab
the terminal value pass it to the
operation returns the value of this
operation and everything is just done
recursively by this chain of operator
function calls one into the others
driven by the number of parameters of
each expressions and whatever happens
when you call the operation function
call okay so basically we if I wanted to
make a bad choice we are done thanks for
coming okay
it's a bit more complacent absently but
you see you see the magic is there we
have this recursive call of evaluate
myself please
does that go down to three go down three
and of course depending on what you want
to do this is a simple direct evaluation
that you could actually have all the
option of three traversals
and fix prefix for speak whatever you
could actually also have an operation
that just say my result well it's not a
new tree but I built from whatever I was
I got inside okay so this is this is
what the Magic Flight these recursive
calls and the fact that you know in each
operator what you are doing because you
know that you have a tag and so much
right and determine all just returns the
value okay
well but okay now what I want to do is
actually I don't want to construct this
expression by myself because it's
completely not expressive what I need to
do is find a way to add operators nice
operator plus of something something and
you get you end up with a binary
expression of plus something something
so you can just call plus and you get
your expression built okay that's what
we want
except we basically have three different
types here okay and all of these three
types can actually be used on the left
or the right inside of our plus barrier
okay so the question is called all can I
write this operator so it does not end
up as template a template be operative
press of a B which is far far far too
much unconstrained so the idea is to
find a way to say I will take everything
there and put it into a common box and I
will try to apply my operators on this
common box okay so that's basically what
we will be doing if you are writing a
runtime based polymorphism versions but
we don't want to do this so what we'll
be doing is using your very very
well-known items which is a cursory
recursive template pattern okay that's
quite a mouthful so apparently it's a
pattern which is based on some kind of
recursive template which act in a Coon's
way okay so let's have a look so the
idea is oh can i simulate runtime
polymorphisms at compile time well you
write some things that look like this
just have a look at that how many people
know about the CRT P just another poll
yes cool so I want forward one spend too
much time in that for the others here's
what what goes you have a base class
which is probably trying on the template
types and you're providing interface
okay and you have a derived class okay
is that here it's from base using its
own type I'll subtract the template
parameters of the base class so derived
iterates from base derive and as strange
as it looks it just walks and what
happens in Bayesian in the interface
function
you can actually take this cast it to
whatever is template parameter is and
call whatever function on that and why
does it works why does it work
it works because whatever base of T you
have by definition it cannot be anything
else but a T okay that's a bit kruky
okay and actually I think the smoke
through feeds on to your other projects
different template system but whatever
it's really with it was if you're a base
of T you cannot be anything else but a T
by construction so casting yourself into
a T reference whoops okay and it could
be a static cast you don't even have to
do dynamic cast because you know you are
T so we just go down it's basically I
think I think we can say some kind of
programmatically done slicing of object
I think that's based image we can have
of that we just sliced base up to the T
market it's not slicing the other way
around we actually pull up your base
into a T a fool T and you do whatever
you need so what you what do we win with
that the interface function is inherited
by every types in everything from base
of something so we have a place where we
have a common interface and we know what
to do with it and the actual
implementation is store into the
subclasses like with regular
polymorphism so we can either type
specific implementation into the base
herbs or into the subclasses and we can
take a base of something and call
whatever we want on it and it would be
dispatched to the current version so if
we take that and put it on our own area
and binary expression in terminal we end
up with this which is not very readable
from afar okay so let's have a look at
how it looks a bit bigger okay probably
better if I show you it there okay is it
is it okay for the size for everybody or
kind of should i zoom a bit more it's
okay okay so we have this base expert
classes which is basically our base
route for our CRT P system we just I
just static
inside the self function that's
something which is very classic and what
is in the face of our expression
whatever is the type of expression and
unary binary terminal operation we want
to have these function collaborators so
we ship it into the into the base class
and what does it do it take itself and
apply is corporator I could actually
call this another function and put it
into privates into a private section but
in that details so what happened for
unary expert you know me explore any of
it from base base X of itself okay cell
constructor and the end the actual
implementation of the function
collaborator just as before we just
enter it from base expert okay
binary expert same stuff we inherit from
the basics for something same for
terminal okay and now we go to the
actual meat of the systems I want to
define my over enterprise okay I can do
this so basic spur it has is self memory
functions that just do I mean just
writes a static stuff okay and then you
call it inside the whatever interface
you want yes please yeah I just it just
occurs to me right now
it just i should have been calling it
something else into the base classes
yeah yeah yeah but we never actually an
end those there's an on-base expert I
would go to that afterwards okay
but yeah you should have been better
style I will I will correct it on the on
the Gita usually better start to up
different thing because in this case we
are not very sure you don't mask
anything well the fact is that in this
system so that means that if you end up
actually dealing directly with an energy
expert and you call the whatever we
directly go to the whatever you don't go
through the base one and do the cast and
when you go through the base you go
through all the loops and go back to sit
down to the to the correct one okay so
we have this self stuff that used to
cast yourself into one of your sub
classes and you ask your sub classes to
take care of the actual processing okay
here's a question
so it's from there we just borrow plates
we do this for every kind of expression
very repetitive work the only one to do
that at home
ready same for binary same time you know
and let's look at operator plus we will
go on the other stuff afterwards look at
that
this part lines 56 to 60 this block so
what we say that when we call operator
plus on two different ways expert of
whatever what I do is I build the new
binary expert the operation being plus
okay that's this plus and the score is
telling us what do we store whatever is
inside
Tobias expert okay
and we just be the object storage the
things okay and follow the repetitions
we do the same for operator times okay
same things different tag same system
extracts the self from the base
expression stow it into a new block
ship the block so we didn't do any
computation there we just build a very
lightweight representation of I just
came across a plus into this expression
so I would just want to inform you that
I just did this and you will take care
of that later and what do we doing plus
so plus can be an empty type just a tag
but what we want to do is actually use
it as kind of an object so what we do is
we just give him a polymorphic template
operators function call that a Katia you
and just return T plus U and what was
the type of this is and same for x we
just do T times u so that give us if
operation called syntax for the
operation inside the expression okay
doctor classical way to do it so what
happens now when I when I call my up my
parents will be later on on the binary
expression that goes there these
functions air which sit inside tag okay
this operation is actually this piece of
code and when you go down inside the tag
operation you don't care about the fact
that you've got a binary expression and
something in something you just get raw
values as an input and you do whatever
you want with them okay because we ever
made it through whatever before and what
we have is recursive a variation of all
of this okay so I have a way to build
those operators right okay and I can
write self exists look into the main I
just be determinant of end containing
for and I build an expression which is D
plus D I've taught that into E and I
just asked for the value of e by calling
is evaluation operation okay well still
not very fancy but let's see if it
actually works in two parts I'm a bit
I'm a bit lazy so just as this guy to do
all the work for me
so that's experiment expert I'm your
binary expression plus times so I don't
remember what I use
so four plus four probably give us our
eight G's problem is the most convoluted
version of printing eight on the screen
you can actually find well I can do more
than that but as that's currently for
still too much well judge joking so what
happens if I just want to do this
instead I could just write it okay pick
compiled link run think 20 is it right
yes four times four is four but oh crap
because I guess it's too okay so adopt
solution is it better it's actually
simpler than me trying to fix my ratio
on on the screen so so it was that so
okay so if you look at the combination
line I'm using she prefers 14 majority
cause I'm a lazy guy and I put auto
everywhere okay of course it's not
needed of course it's not needed but you
can work if you want even try to write
this not using auto and I will probably
get an appointment with you next month
okay because as you can see already this
autos there to be replaced it's not that
funky okay I have a tendon you and I
want the type of arbitrary t plus I'll
be telling you in tsipras first 98 so
that's not that quite easy
yes questions yes what I we do just now
is I would try to print the actual types
of e okay so beware oh yeah well maybe
say yeah what I need
let's pray yes theory so okay so let's
have a look at the tip of everybody
there D and E okay so what is the oldest
what's already yes
boost Domingo probably this so let's
take the type idea of the whole thing
and ask boost the mango to print it into
a readable formats okay so what happens
what is okay what is the type of D we
expect it to be something like struck
terminal event if not something is is
rotten into the Kingdom of Denmark okay
it's not a member of boost what the crap
is that
who's in charge okay let actually snot
me so just five seconds I don't remember
what was the damn thing is you know
readings of dog this was a week you know
core manga where is it actually sitting
in a boost go of course I'm stupid
should have known okay it's stemming
elephant right so now let's have a look
at what happens if we do this so what we
expect is something close to unity
expert plus terminal in terminal okay
let's have a look
binary x four plus terminal in terminal
okay so question why don't we just store
binary expert of plus base expert a
Marine base
expert a minute why don't we just do
that why am I supposed to extract the
self from the base expert before storing
them
what yep yes yeah exactly you you may
want to carry on more data than just the
base expert allow you to okay you may
have special members or special data set
into your actual derived class that you
really really want to add when you when
you store them okay so that's D plus D
so let's let's go to the next level D
plus D times D and we will touch the
first issues okay well that's exactly
what we think it should be okay one more
time starts to be big okay okay so first
problem
look at these frigging symbols sighs
okay first one is okay second one is
okay the sell one start to be you know
whirring and the last one is completely
out of control so um well just so and of
course you don't really want to go into
this kind of territories which actually
happened how many freaking parents do I
have there okay it's at school yeah so I
was about to make a joke about the
compile time and then I remember that
the latency there is probably more than
yet wolves on the actual computation so
yeah and sincere whirring let's bring
the Wi-Fi
come on okay one it combines so yeah
first issues is this very very very very
very long symbol name doesn't sound like
much I mean just simple name but at some
point the compilers asked to build it to
store it somewhere in more or less some
kind of stiffen binding come on okay you
asked to stores a similar name into
something which is probably as a string
like structure which probably means as a
compiler is allocating memory to store
it okay and it's still inviting okay
well meanwhile so several names that's
the first issue we met that's 99 okay
that's maybe 75% of why expression
templates are safe to be slow to compile
but that's what Rachel's they're okay
symbol names symbol names mean strings
longer strings means more complex signal
more complex but we call more memory and
more memory means maybe more swapping or
whatever and your memory consumption of
your compiler we just go up and at some
point that will be the main issues about
that that's really worrying actually ok
ok let's play ok I think it's from yeah
ok battery F expert of + between what
between x + + + + x + x + + + + + x
again and x again and end on that's
quite a mouthful so that first first
mutation and of course if you're if you
feel about it if you think about it I
mean it's just as much as you 3 is deep
it will go worse animals but it's
exactly what we think it should be ok no
surprise there and of course the
important thing is ok but I would just
cut on that because I don't really want
to spend one more we're waiting for the
completion of course the important thing
is when you do this
okay you end up with the end you ask it
for so this this place where you you go
from the tree form to the actual
evaluation of the tree and somehow
sometimes called what we call a
compression point it's a point into the
expression temperate system where you
stop being lazy and you do some work and
there we put it there just just on this
apparent father parents but we can
actually put it wherever we want okay so
let's have a look at something else a
different version of this okay this is
one yeah this one
same idea okay same basic code I just
change a small stuff it's not look at
line eighty-five I can write u equals D
times D plus D times D okay I don't even
call parents anymore I just use the
assignment operators of course what
happens let's look at terminal because
what you is it's a terminal float so
what this is assignment operators of
seminar does it is we take a basic spur
of whatever and we say cool we have a
bath expert
I know it's someone who behind it if I
ever read it so we just ever read it and
store it into my value so we move the a
variation from let's just evaluate it to
an or let's say semantics driven
evaluation point which is whenever I
assign another random expression to a
terminal
I want the expression to be you know
condensed evaluated into the value and I
store it into my terminal that's a
classic things assignment operators do
the compression point that what all
linear algebra expression template base
library does when you write my matrix it
calls this huge amount of math
expression so our same in the bird of
your matrix class we just do some loops
and for every point into my matrixes I
will store the information of your
expression on the right for every point
I'm currently computing so you can put
your compression point wherever you want
and by wherever you want it actually
means wherever it makes sense
semantically into your small languages
when should I go from the lazy form to
the compressed forms that give me a
value and you could actually have
multiple such compression points okay so
we have one there okay oh yeah and I did
this every stuff oh yeah so anyway you
could actually have this one so what do
i do there I'm turning my terminal float
into a natural float so somewhere I need
to add an operator that say okay I'm
taking an expression and I'm converting
it to some value okay so and that's what
I actually did there it's a bit
different I put it into the bass expert
and I gave the bass expert an operator
of conversion to some types which is
value type okay when we see how we
compute value type afterwards and what
does it do it computes the value of the
expression so I would just call function
call operator on my current expression
yes that's ID yet sorry for that but the
value type come on
it depends it depends on what odd
whatever is stored into the base
expression private terminal of end I
should return an end we have a floor
that should become a table to float and
if I have an operation that take
whatever and whatever and return the
complex of double I should be returning
this but as the base expert class
doesn't have any way to know which one
is it except by asking is derived plus
so we use this quite early line 9 I'm
not sure there is something more elegant
I'm taking opinion afterwards what I do
is okay let's build let's try to build a
fake derived and call it
to parents on it and give me the type of
that okay and that's probably the type
of what it should be returning anyway
okay because by going down all the
operators function cold calls if we
finally end up into a place where okay
that's a float okay I try to write
something like okay Rachel they called I
blah blah blah doesn't bode well so
that's the simplest thing I found about
I think that better elegant way should
to should be to add a value type meter
function externally stored out of Paul's
expression types and just call it
whenever I need okay just to doesn't
have all these kooky stuff but yeah we
can actually say okay commercial
operator is also also a compression
points that's another great classic okay
and of course I just call that terminal
you could actually call it viable value
matrixes whatever okay but that just
walk okay and now let's compile actually
should be oh come on no I wanna know
this one the self combine okay true true
true
doesn't work why it doesn't work focus
that doesn't work why why it's not
working
do I have all my information about
derived when I compile based expert of
derived if I add this using inside no
because I'm if I'm building a base
expert of derived that means I'm
building a derived and I cannot ask
what's the freaking type of operators
parents on derive a is because I still
doesn't know my type is not complete yet
okay this works because it doesn't need
arrived to be complete when you try to
take a reference to it so that doesn't
work okay if you want to make this work
actually I forgot about this can you get
my cursor back since you probably want
to have something like like this I'm not
even sure if we walk
so you probably want something like
template blah blah blah and you want
this you probably want something like
this okay and what you want to be okay
and what you probably want to do is
something like that but do do we really
think it will be walking we can actually
pass this I guess that won't work either
yeah yeah yeah you will start we were
still trying to instantiate something we
should not be doing and the one way to
make it work I think everything to the
other solution but it's a bit more
complex you you have to ditch Auto and
while we're only things the only way to
make it work is to delays the
information of these types by using the
old-school result of protocol that needs
to be called whenever it does all the
information okay so well beware of this
that's one of the limitation of the C
RTP you cannot do anything into base
class that requires information about
the compact type of the device class so
okay forgot about that just take this
somewhere else and let's just put it
into what should I be putting it yeah
tell me no but putting it in terminal is
not very useful okay because we know its
value okay just that dot but what should
be cool is to be able to call part and
call these commercial operators on let's
say float of a plus B okay and like they
say when you end up with something
complicated this is left as an exercise
for the reader okay so try to do this at
home in which it's not that kruky but
you have to think about it to be
differently those that should be working
yep and of course when you have that you
can actually well can I actually put it
somewhere there yeah actually
well I can
because I doesn't know the type of
written type same problem okay so we
wish we could actually do something like
this but it's not possible okay so
that's once one of the limitation of the
systems okay you are bound to just ask
for information about the non complete
type of your derived class but you can
actually live with this so this notion
of compression points is very important
because that's where the magic happens
okay you want your user to not know
about your evaluation strategies just
write something and somewhere I would
just go from the lazy representation of
the tree to something that make sense
sort of okay so that's where we go so as
we saw that the operational definition
we just put some tag with an operator
which has returned whatever it is a
binary expression with plus and whether
so what is missing from this what if I
want to write something like some
terminal plus some literal like u plus 3
tree is clearly not something which is a
base expert well don't have much choice
you will have to write the two others
overload of plus one taking random types
and base expert on the left or basic
spur and random type on the right okay
so that's three operator for binary
operation which means that if you had
ten every operation that's probably
seven yes seven and so on and so on to
power of number of arguments minus one
okay well should I do something special
for unary expression no why because the
only stuff that interests me in unary
expression is my usual function or
operators called on one base expert so
just have one to write for unary
explanation so we wrote operators you
can actually wrote a function not seen
as continuous arctangent copy whatever
you want and the system is still the
same you what
function take some arguments putting
into the correct box and suppose
okay and you should have somewhere into
the box description what should happen
when I'm coming down this special tree
Oh perfect timing so just finish on that
before some question on this part and
and and then a small break yep
also limitation is currently if we do
that what if I want to take the exact
same code and write something that just
say hey by the way what I want to do is
when I call to string I get the string
containing the exact string
representation of the tree you just
wrote well you would take your your
stuff you know and you're working choose
and go down every damn based expression
stuff and add the two string operations
that do whatever you need and so on and
so on and then Bob from the other
departments come and say you all but now
what I need to do is actually something
that's saying I'm taking this expression
of operation on Bibles and I want you to
compute the derivative of this function
and then again you write to stuff you
write everything back into the best
expert problem is if you just do it this
way it's fine as long as you have one
stuff to move around as soon as you have
multiple evaluation scheme for the same
tree these systems is actually a bit
brittle and at least not solid with big
s means that you don't really want to
touch the code of the expression
structure whenever you feel the need to
write another tree traversal that's
basic 101 I mean that's what the ester
does that what you should be doing all
the time we need to find a way to
separate the data structures are
tripping on the tree from the tree
traversal okay so well we know how to do
this we can actually have visit or next
set methods into somewhere and you can
just implement some kind of visitor
patterns and probably solve everything
okay take that same time it this very
simple example is cool because we only
do something okay one thing as soon as
you grow up and you need to do more
thing with the same tree it starts to be
a bit cumbersome and you need to have
something which is more let's say
flexible
oh you want to do this and that's what
would we be seeing and so that's all
actually Bruce produce some of the
issues by separating those two now okay
is there any question on this first part
is everything clear now on what the
expression template is supposed to do
and how it works when you actually build
it from the ground up any questions so
is there like kids every every one of
you or you all understood everything I
said I hope it's option two any question
yes oh okay so the question is all do
ideas or runtime value correctly so what
happens there so let's take the simplest
example more than this one this one
let's put put it it back so what happens
when I call a parent I'm jumping into
the a parents of whatever I got from
this which is probably the parents from
binary expressions there yep
and what does value expression operate
functional brain code does it say okay
guys I would just call the semi burritos
on my left and inside okay and whenever
I got this erection done I would just
forward it to the function call from up
so I need to ever act ca parents and CB
parents to know what's going on so what
is ca in CB now in cases that's D which
is a terminal so I jump into the
operator parent from terminals that just
gives the value back so CI give me for
CB give me four and I will just called
operators function call for four on up
which happened to be a plus which is I
don't remember where there and just do a
plus so it works just because we
generate this chain of function calls
and yes when you comply with our
optimization you get in line actually
and you count on that for the
performance of course but yeah it just
has this repressive code we do whatever
you want go down the tree up so you get
terminals and you get back to value okay
and speaking of inlining this is a very
important point in this very simple
example if you look at this I've been
lazy by just throwing every chilled
children by value because okay not not
complexity anything now
imagine that your Torino is not a single
int but it's vector containing jag bytes
of data okay you don't really really
want to copy it every time you build the
new nodes into your tree so one thing
that people usually do when you do that
they store the sub expression as close
reference also at reference to concert a
subtree that's cool but it implies
something which is very very I'd say I
mean when you say it is it's obvious but
people already miss it if you store your
sub expression by reference that means
that the lifetime of your big
expressions is basically limited by the
statement is built on you doesn't want
to store it into a not available because
all she's gone all you have is dealing
references to temporaries you can cheat
a bit by storing everything by reference
to Const and praise gods are the
lifetime extension kitchens okay but
it's not safe and it will bite you later
because you will end up with a burg that
something's blow up and you doesn't know
where and the debugging when you build
into debug just works because the
Belcher's do all the stuff one by one
but in release mode it just grew up so
it's a very complicated issues but we
see that in problem we start afterwards
you really really want to store
everything by value so it's safe but
sometimes it's not efficient so we need
to find a way to know how to take this
decision okay that's for the afterwards
any other questions yes
sorry
Oh actually we did this example is
actually very simple we just store a
single you know in a single integer okay
now let's let's let's imagine what we
store is vectors okay what will happen
if you write your operator plus and over
at times directly using vectors you will
end up with a code that say let's build
the temporary vector in which how we
store the result write the loop fills a
resort ship back to the resulting
vectors and when you write D plus D plus
D perceive as differently here we go
there and we got one terminal for one
temporary sorry for every call to the
prosper aider compilers may see that
something's cookie remove some but not
all and you we probably not get out of
having all those memory allocation them
what's happens there if I put a vector
of whatever inside there I won't do
anything to the plus I just build this
empty box taking things containing
reference to something else okay and
then when I evaluated your expression I
will build a single temporary vector if
needed or we probably just resize my
destination vector and fill the blank
with the evaluation okay so what we did
the fact that it doesn't do any
temporary is that when you look at plus
times and other function operators they
don't do the computation it just builds
this dandling tree of stuff that you get
average later and when you average it
later you can say okay there is probably
multiple array into these things but I
don't care I know that I would just
beside myself and asked all of them all
they are all of this all their value one
by one and you doesn't have any
temporary vectors or whatever that's
that's what happens I should have put
that into the example actually I would
do see that a bit later but yeah so you
say this temporary because who doesn't
do any computation on the fly you do a
lazy evaluation of the tree and you give
first evaluation later when you know
that you have all you information
you can kick you can take conscious
decisions about how many memory you need
to allocate okay that's that's what's
going on okay and we make the assumption
that the temporary expression object are
usually small and you know non costly to
copy yes like sorry yep okay so the
question is can we can we end up with a
way to actually manipulate the three so
we can decide what part to average first
that does it is this okay or also
decision based on the three when we see
that in with loose Prado it's actually
very complicated to write with this kind
of system because it doesn't have any
built-in introspection on the structure
of the tree Yury probably you have to
write function and make a function that
we enumerate all the cases you may want
and decide by calling the correct
function when we see with Prado is that
basically you can say okay this is a
kind of pattern that interests me and
whenever you meet that do this okay and
we spraying with this and something some
of the things that we speak about later
you can actually all order or offspring
the way you want to makes of a relation
that but you need something more
powerful than just a bunch of CRT P with
simple simple classes but yes that's at
one of the motivation of booze problem
okay so let's have a break and if you
still want to hear about me so came back
in about 15 or 15 minutes</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>