<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Casey Carter “Iterator Haiku&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Casey Carter “Iterator Haiku&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Casey Carter “Iterator Haiku&quot;</b></h2><h5 class="post__date">2016-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rZs9ndzGB_8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right everyone thank you for coming
my name's Casey Carter I'm with
Microsoft I also happen to be the
project editor for the ranges TS right
now on this d-plus Standards Committee
I'm here today to talk about iterator
haiku which is a pretty name for a
design change that occurred in the
ranges TS where we took the C++
standards v iterator categories and
expanded them into seven indicator
iterator categories to be able to
describe more problems and then found a
flaw in our design and in the process of
correcting it turned the seven iterator
categories back into five again without
being able to without reducing the
descriptive 'ti of the system so
overview of the talk first about
questions if anybody has questions just
raise your hand make yourself known I'll
interrupt the talk for questions because
I'm trying to stay very high-level which
means I'm occasionally going to skim
over some details and probably miss out
things that people need to understand
I've got a lot of ground to cover so I'm
not going to go too deep here I've got
to make sure you guys have enough
background to understand the design
issues that I'm talking about is the the
point of the talk so we're going to talk
a little bit about ranges and iterators
and standard C++ and we're going to talk
about how the Palo Alto tech report
changed that I'm also going to tell you
guys what that is since most of you
aren't members of the C++ Standards
Committee you probably haven't heard of
it before and then I'm going to talk
about how ranges and iterators evolved
and their ranges TS itself there are
some design flaws with the design
concept that show up as strange issues
with how the concepts are applied to the
iterators and I'm going to talk about
how I decided to investigate those by
reacting with tagging and how it found a
horrible flaw in the design that it was
internally inconsistent that was a
contradiction and our design and we had
to fix it first of all ranges in
standard C++ well I don't need ranges to
yes if there are already ranges in the
standard the answer is I have family to
feed so it's important that I be paid to
do something and I'd rather be paid to
work on ranges than to
dig ditches but realistically speaking
the standard has two different kinds of
ranges right so why do we mean more
range than that the fact is that the
range isn't the standard although they
exist they're not very well defined and
they don't quite cover as much ground as
we'd like them to we can't get our hands
wrapped around them and write lots of
new kinds of ranges they're not well
specified they don't have strong
semantics so first kind of idea for what
what exists is a range in standard C++
ranges are sequences of elements that
are between two iterators right I call
this a the range sequence notion so we
can keep it separate from the other
notion of our range we like to overload
terms in C++ right the more different
meanings you have for a term the better
job you're doing these kinds of ranges
are often denoted with an interval
notation as iterator pair an iterator I
in it or okay the range of elements is
everything from I up to but not
including the element or not element if
it's past the end denoted by K the
interval notation implicitly requires
reach ability right it's defining the
standard that this notation means that
some number of increments applied to I
will result in the value of K right that
this is a finite interval it's
guaranteed it has to happen essentially
the equality operator is an end of
sequence test that we can apply to these
two things in the interval we can test I
to see if it's equal to K and that means
that we've reached the end of the
sequence our other notion of ranges in
the standard is range object this means
you know things that you can plug into
range based for they must be ranges
because the word range is right there in
the name range base bore and the
interesting fact about these kinds of
range object things is that we can apply
begin and into them and get iterators
back and get to the range of the first
kind right arrange sequence range base
for converts range objects and arrange
sequences so that our two kinds of
ranges actually end up being one kind of
range and can do the same sorts of
things
all right I said Rangers are denoted by
iterators so we have to at least briefly
talk about what are iterators there are
five different categories of iterators
in standard C++ the first one I'm going
to talk about is that input input
iterators have several different
operations all right there's a you can
take star of an impure writer to read
its value you can do you reference it as
if it was a pointer plus plus advances
the input iterator to the next element
in the sequence equals I can use to test
two iterator values to see if they
denote the same element in the sequence
or I can test an iterator with the end
iterator of a sequence to see if I've
gotten to the end right we use the same
syntax for both of those operations not
equals is obviously the complement of
equality right if they're not equals
then equals would return false body will
return to these kinds of iterators are
single paths I can only go through a
sequence once with inputted raters I
can't go back to a value that I saw
before and they are obviously readable I
already said that but that's a very
important point here that we can get the
value of the elements out of the
sequence using an input iterator the
fact that they're required to be
readable doesn't mean that they're not
necessarily writable like might have a
writable input iterator that's single
pass and that I can read and write the
iterator the values of they might be
mutable the classic example I have up
here for this is a an ice-cream iterator
that you may be familiar with if you've
written C++ written programs before I
can use an ice-cream iterator to iterate
over a range of values and an input
stream next up for word iterators for
word iterators are a refinement of it or
input iterators which means everything I
can do with an input greater I can do
with a foreword iterator but it has an
additional characteristic which is that
forward iterators are multipass if I
keep an old iterator value around I can
start over from that point again in the
sequence and it over the sequence
multiple times
a classic example we have here for this
is the iterator is over a forward list
a foreword list a Sifu singly-linked
we're all relatively familiar with it if
we've written programs I can iterate
over four word lists several times I can
compare the uterus for equality just
like etiquette with improved iterators
they are always readable sometimes
writable just like with in polluted
Raiders to keep difference here is that
their multipaths bi-directional
iterators have all the properties for
word iterators plus they can be
decremented right we can move them
backwards through the sequence as well
as forwards example for this is a doubly
linked list with a doubly linked list I
can move forward to the list I can move
backward through the list
it's a bi-directional iterator random
access iterator so the most powerful
kind of iterator we have in standard C++
I can do all sorts of interesting things
with them that I couldn't do with the
other kinds they are all most pointers
right I can add constant offsets to them
to move to a random point in the
sequence in constant time which would
take me linear time with a forward
iterator I'd have to increment over and
over again instead of being able to jump
ten steps at once the example here is
iterator vector iterators we're all
familiar with vector iterators because
vector is our favorite thing I can sort
random-access iterators right things
that require me to jump around in the
sequence to multiple places quickly are
the kinds of algorithms that can be
written with random access iterators
last but not least we have output output
a sort of the redheaded stepchild of the
C++ inter-rater categories output is an
iterator is required to be mutable but
not required to be readable and that
since people like to think it's the
opposite of input but it isn't really
because an input iterator could be
readable and writeable all of the other
kinds of iterators that are required to
be readable could still be writable this
is the class that's left for iterators
that don't fit any of the readable
categories right if they don't put any
of the readable categories there right
only they are output iterators these are
also single pass just like input
iterators they have a dereference
operation that we used to write into
them they have an increment operation
that we use to administer this stream
they notably don't have a
quality because output iterators right
alone right there's there's no way for
me to detect the ends of output streams
which is scary in some sense it makes it
hard to program reliably when you can't
verify that the size of your output
range is big enough to hold the number
of things you're going to stick into it
the example here I have for this is an
out stream iterator which is the
complement of I stream iterator in C++
it lets me take a range of things and
write them out into an output stream so
the interesting feature we have to cover
is the domains of these operations we've
talked about the kinds of operations I
can do on these types but we don't know
when I can do these operations on these
types or what values it's legal to apply
the operations to so we're going to talk
about the domain of a function the
domain of a function is it says right
there
the set of values over which the
function is defined and the example I
have here is a really simple function
that takes an integer and divides 42 by
that integer something we've all seen
before in math and people probably know
what happens if I pass the zero to this
function we don't know right that's the
problem we don't know what happens it's
undefined behavior horrible things may
happen nothing may happen it may return
seven it may cause nasal demons to fly
out of your nose so zero is not a value
that's in the domain of this function
although other integers are and I'm
talking about this because we want to
talk about the domain of equality for
iterators when can I apply equals to a
pair of iterators for forward iterators
it's fairly simple it's iterators that
range over the same underlying sequence
right two iterators that point into the
same range i am allowed to compare with
operator equals to see if they are the
same forward iterators that point in two
different ranges two different vectors
two different lists list and a vector i
can't compare those kinds of iterators
to each other even if their types allow
me to do so because their values are not
legally in the domain of that operation
output iterators what's the domain of
equality is
an easy question to answer there is no
spoon output it ears don't have a
quality comparison so I can never
compare to upper ears for quality I
don't need to worry about it
which leaves employers left it's the
last thing right how do i define the
domain of a quality for input iterators
this is how the c++ standard defines it
with one of my favorite paragraphs of
text in the Inquirer standard the term
the domain of equality is used in the
ordinary mathematical sense to denote
the set of values over which equality is
required to be eight defined this second
change over time each algorithm places
additional requirements on the domain of
equality for the iterator values it uses
these requirements can be inferred I
presume easily inferred from the uses
that algorithm makes of equals and not
equals for example in case it's not
clear we have an example to clarify
things the call find a BX is defined
only if the value a has the property P
defined as follows B has property P and
a value I has property P if a tie equals
x or if a tie is not equal to X and plus
plus I has property P okay everybody
understand right the point I'm making
here is in order to determine when it's
legal for me to apply equality to an
input iterator I have to go look at all
the algorithms in the standard library
figure out how they use input iterators
and and determine you know I have to
extrapolate from that behavior what my
input Reiter has to do if I want to
implement an iterator or how my
algorithm can use input iterators if I
want to implement an algorithm this is
obviously kind of problematic because
nobody has time to examine every
algorithm and the standard but alone
every algorithm written by everybody who
didn't contribute it to the standard so
the general rule we've come up with for
input raters and how they work is that
there are essentially two values in an
input range of iterators that we care
about at any time that we can look at
right there's the current value that's
the value I'm looking at in my algorithm
and there's the end iterator and these
are the two positions I know of right
current and end and once I advance the
current value of my input Reiter
next thing I know that the old values
are no longer in the domain of equality
since inputted writers are single paths
right so at any given time I know about
the current position and the imposition
and no other positions in an input range
so we've got these five integrator
categories that we've described we're
gonna move on we're going to talk about
how they get affected by the Palo Alto
TR the Palo Alto TR was when a bunch of
people in the C++ standards committee
got together at Palo Alto to talk about
how we could apply concepts to C++
without going through the fiasco once
again of concepts when they tried to
apply them during C++ 0x
right you may not all know this but
there was a thing called concepts and
they did have them in the standard and
they were applying them throughout the
standard library and we gave up in 2009
and said you know what we're doing this
wrong we have a hundred and twenty
different concepts defined in the C++
standard working paper something's not
right here
the invitations don't work we've screwed
up we we have to give up on this because
we don't know how to finish this for C++
11 so they yanked all that out and we
people were upset so they got together
and said okay let's look at just a small
part and figure out how we can define
concepts to constrain the iterators and
algorithms in the STL just the iterators
and algorithms and do it with as few
concepts as possible and still have
strong semantics this is a great thing
because concepts let us replace tables
in the standard that most people don't
go look at with actual syntax and the
program that the compiler can verify
this is awesome but I've been talking
about concepts now for several minutes
some of you are asking what's the
concept so we're going to talk about
that fairly briefly concepts come from
the concepts technical specification for
C++ a concept is a predicate over some
set of parameters it's usually a set of
requirements that are applied to those
parameters that they're expected to
satisfy and if the parameters satisfy
those requirements there
that are to satisfy the concept if they
don't they're considered not to satisfy
the concept syntactic requirements as
applied by the concepts TS I like to
think of as being requirements on types
for example I can say Auto foo equals
bar and that's the kind of syntactic
thing that the concepts TS can validate
I can validate that it's possible for me
to take a bar of some type T and make a
copy of it with copy syntax
it lets me constrain associated types
that have to exist for a type or
expressions that need to be valid
now these concepts as they're used in
the ranges TS or a slightly different
kind of idea we take the syntactic
concepts and we say you know syntax is
great but syntax needs to have semantics
to mean anything so we apply syntax
semantics requirements I'm sorry as well
which I consider to be requirements on
values as opposed to requirements on
types you know the concepts ts lets me
say this thing has to have copy
construction syntax but I need to be
able to say that the result of the copy
is actually equal to the original thing
because that's what copying means right
we have to have meaning for our syntax
to be useful now the Palo Alto TR
authors they look through the algorithms
and got there so they develop their
concepts by seeing how the algorithms
used iterators they didn't do it by
saying you know here's every kind of
iterator we know about let's try to
figure out how to classify them and
group them together they said here's
every kind of algorithm we have what do
these algorithms need what operations do
they use and they developed the concepts
from above and I guess instead of below
some of the algorithms they noticed take
unpaired input iterators and they said
you know what these kinds of iterators
don't need an equality quality operation
because they're never compared for
equality you know you have an unpaired
iterator there's nothing for you to
compare it with it's ridiculous to
require these kinds of iterators to have
an equality operation that can't ever be
used and the examples I have here for
these are the three
legged double range algorithms like
equal first one last one first two where
the length of the second range is
implicitly the same as the range of the
length of the first range
the other one is iterator plus count
algorithms like copying where I copy
everything from first until I have
copied count things and then I stopped
that range has a specified length
instead of a specified int and they said
okay if I don't need equality and
inequality operations for these kinds of
iterators I can define a new category
right we'll define a new category we'll
call it week input iterator it's a
little weaker than the regular input
iterator concept because it doesn't have
an equality operation moving forward
another radius TS we've decided we don't
arrange to yes because we want to have
algorithms that take the range object
kind of ranges as well as the range
sequence kind of ranges for many many
reasons right it's nice to be able to
have one handle on a thing instead of
having to specify two distinct end
points it makes it hard to specify an
incorrect range when you have a range
object instead of when you have to pull
a beginning in an end from somewhere
until an algorithm to use these
beginning in pairs right I can get
begins and ends from different ranges
and pass them to algorithms and
algorithms don't know about that because
they assume like I said earlier that
reach ability property exists that they
are actually noting the same range so
the range TS takes these range
elgyn johner if that are implemented by
just the same kind of technique that
range based for uses right it turns the
range objects into range sequences by
applying beginning into them and passes
those range sequences to the existing
range sequence algorithms but of course
we also were concerned that you know
there's this thing called output ranges
that are denoted by just one iterator in
most cases in the standard algorithms
and we're concerned that
you can't match the links of input
sequences with the output sequences to
make sure that your outputs are big
enough and for other reasons we you know
we wanted to have actual physical output
ranges as a thing and we also wanted to
have symptoms and their ranges TS which
you guys have heard about before if
you've seen any of Eric nibblers talks
if you haven't since animals are not
x-men hunting killer robots which you
may have learned in the movies sentinels
are a new way to denote the range as
sequences kinds of ranges that I'll
detail later on so if we want to have
output ranges we've got this problem
that output iterators don't have an
equality operation so we can't pair them
together and use them to denote output
sequence range objects so we renamed the
output iterator concept that already
existed in the C++ standard two-week
output iterator and we added a new
strong output iterator concept that has
equality and inequality and now we're
using the same weak versus strong
relationship for output iterators as
already exists for input iterators from
the Palo Alto TS this is really nice
because it lets us have the same kinds
of behavior for output iterators that we
already had for the other iterators but
it also means that five categories have
become seven right we're officially
halfway through the Haiku here we've got
two more iterator categories that
weren't in standard C++ which means
ranges we now have 40% more categories
this looks great on a more on a
marketing bullet because as c---plus
programmers one of our primary jobs is
to make small numbers bigger or to make
big numbers smaller right we all do this
every day we know this is a good thing
we also decided that we needed to factor
out the common commonality of the weak
input and weak output array our concept
into a plain weak iterator concept and
factor the commonality of input and
output with strong ones into a plain
iterator concept so that we have ways to
handle those things and to specify
things that expect a stronger iterator
that has
or a weakened Raider that doesn't need
to have equality but doesn't care if
it's input or output unfortunately this
means that in the text of the ranges TS
the word iterators colloquy means things
that satisfy week iterator this is
extremely weird because other uses of
terms colloquy in the standard like
forwarded Raiders or random-access
iterators means things that satisfy
satisfy this concept that has the same
name so it's bizarre that iterator means
things that satisfy week iterator and a
source of confusion sentinels I was
talking about sentinels earlier where
did these things come from what our
sentinels often ranges have a distinct
value that denotes the end like with
istream iterators we use the default
constructed istream iterator to mean end
of the range this works great and is
useful but the question arises the
compiler has to examine these things at
runtime to determine whether the value
I'm looking at hastens to be the special
end value why could I not use a distinct
type instead of a distinct value to
represent the end and then the compiler
will be able to tell at compile time
that something is the end of the range
because it has a different type in order
to realize that we have the Sentinel
concept in the ranges TS Sentinel is a
relationship that exists between some
type I that satisfies the iterator
concept and another type s that
satisfies regular regular meaning it
behaves like the regular types in
standard C++ they can be copied and
moved and default constructed compared
for equality compared for inequality
these are the the operations that I can
do on regular types so the sentinel has
to be a regular type and of course once
I have this type I and s I need a way to
compare them to tell when I'm at the end
of a range so they have to also be a
quality comparable
I can compare them with equal to or not
equal to of course that's actually kind
of complicated because what does it mean
for me to compare two things that have
different types the Palo Alto report has
an answer for this it says you know we
have this great definition of a cross
type of quality comparable concept and
the way cross type relations were
designed in Palo Alto so that they could
have mathematical soundness is that
cross type relations require the same
relation to be valid for each of the
types individually and for their common
type what's common type C is a common
type of the type T and type u if I can
convert a type an object T of type T to
C and if the that conversion preserves
the identity of values of T which means
that they're converted the converted
value of T 1 equals the convert value of
T 2 only if t1 equals t2 to start with
right it doesn't map different things to
the same value of the common type and it
doesn't map things that are equal in the
original type to different values in the
common type and of course the same
requirement has to exist for you because
I haven't said anything special about TR
u they have to be symmetric requirements
for these two types so an example of
this is the int is a common type of int
and shorts right we know we can convert
instants we know we convert shorts to
int and that that conversion will
preserve the values identities similarly
long is also a common type of N in short
and so it's long long I can convert
these things without losing value or
identity int trivially is a common type
of int an int that's a nice thing right
I can convert a type to itself and more
interestingly standard string is a
common type of care pointer and care
pointer Const all right those things are
both convertible to this other weird
type the idea here is that it makes
sense to relate two kinds of different
types of things to each other if I can
embed
both into a common universe where they
have the same meaning and in the case of
numbers the same meaning we all know in
some way implicitly means you know these
things can all be converted to real
numbers so if I can convert them to real
numbers and they convert to the same
real number they must in some sense be
the same thing there's a natural number
and an integer and a rational number and
a real number and a complex number are
called three right we know that these
things are all equal we consider them to
be the same thing right that this is all
three because they all have a common
type question all right the comment is
that no pointers or I might have a no
care pointer can I convert my no care
pointer to a string no I can't because
that's not a value that's in the domain
of the conversion and the response I
have to that is that doesn't necessarily
mean that they don't satisfy the common
type concept because the vast majority
of the values do satisfy this
requirement vast majority is the wrong
term not every value in the domain is
required to have this property I mean
not every value of the type I should say
is required to have this property the
important thing for our concepts is that
the values were looking at in any
particular usage case are all within the
domains of the operations that are
required so I can say that integers are
divisible even though there is an
integer value that I can't divide things
by another question
yes that's true
you have broken my example and that's
why I shouldn't have added another
example of something more interesting
this morning before the talk yeah the
comment was that care pointer equality
compares the pointers not the things
that they're pointing at so this is
wrong and Ben is correct this is a
terrible example I apologize back to
cross type of quality incomparable cross
type light relations like I said require
the relation to hold for the individual
types and the relation has to hold for
the value is converted to the common
type and most importantly the relation
needs to be the same over the individual
types as it is over the common type in
this sense that if the common types of
if the common type converted value of a
T is equal to the converted common type
value of a u and two different T values
are equal then the pardon me we start
over if I have two different values of T
that are equal to each other and the
common type of this T value equals the
common type of some u value then the
common type of that other T value has to
be equal to the common type of that you
value as well the idea here is that the
relationship needs to establish a
correspondence between the values of T
and the values of u so that if two T's
are equal and one of them compares to
equal to AU then both of those T's have
to compare equal to u right I'm
establishing that the relationship needs
to be transitive across types this is a
nice really strong relationship that
very closely establishes the belief we
have in mathematical numbers right that
three integer is the same as three
double is the same as three rational and
that those have to be transitive
across types as well so going back to
the sentinel concept the sentinel
concept requires this cross type of
quality compilation ship to exist
between in the iterator type and a
sentinel type so they have to be
transitive they also have to be
individually a quality comparable which
means I can't have weak ranges that are
denoted by weak iterators and a sentinel
because they need to individually be a
quality comparable and weak iterators
aren't individually a quality comparable
this happens despite the fact that the
algorithms don't use a quality on single
pass iterators right if I have a single
pass iterator and a sentinel value I'm
not going to compare that iterator to
itself for equality here's a example
algorithm any of right this takes an
iterator and a sentinel and some kind of
predicate and as it loops through the
range it invokes the predicate on each
of these input iterators it doesn't ever
need to compare the current position to
itself because it knows it's equal and
since this is a single pass range the
only position I can look at in the range
is the current position or the end with
sentinels end is a different type than
the IMP than the input iterator type so
that comparison uses the cross type of
quality I never need to use the
symmetric equality for the iterator
types I don't compare iterators with
other iterators here of course the
concepts require those operations anyway
because it's a checkbox right I need to
fill checked off that checkbox to
satisfy the cross type of quality
comparable concept so we end up
requiring this operation that does one
of two things it's either useless
because you're comparing something that
you can prove is equal to itself anyway
or it has undefined behavior because
you're screwed up and you're comparing
two things that aren't in the domain of
equality for input iterators so we've
got a foot gun here that isn't just the
foot gun but it's required foot gun
right you have to implement this thing
that's either useless or dangerous
skip so the idea here is that by
establishing the common type between
iterators and sentinels they both
abstractly are denoting positions
positions in a sequence of some kindness
the the common universe that I've
embedded in raters and sentinels into
here so that I can compare them with
each other and we if embody this in the
ranges to yes with the recommendation
that you know the Equality operation on
sentinels must be always be true right
because sentinels abstractly represent
the end position of a sequence all right
if you have two signals that you're
comparing they both must refer to the
end and therefore they must both be
equal so we've been telling people you
know don't bother to implement any kind
of weird equality comparison operation
just say yes true if people compare two
sentinels they must be equal
they both abstractly represent end so
looking at this I was confused by this
fact that we're telling people that
sentinels are always equal when
sentinels can have state you know
they're either predicates or positions
and it didn't I don't understand how
they could be both so I had found enough
material here that I decided to figure
out how sentinels were really supposed
to fit into the iterator model I needed
to throw out everything I already knew
about ranges as iterator perish that we
had in the standard and that we needed
to start over ax meat izing iterators
and ranges just from the iterator
Sentinel model of denoting a range you
know instead of saying range is an
iterator pair or an iterator and since I
know I wanted to just start over with
only the iterator Sentinel abstraction
and see if I could drive all the range
properties that the standard says hey
this is how forward iterators work this
is how random access iterators work this
is a nice side effect it means I have to
define the domains of the internal
operations which is useful because we
hadn't already specified about those
were in the ranges TS we had told people
these things have to exist we hadn't
really made it clear when you could use
them you know you can look at the
algorithms and figure out oh I can use
them same way the algorithms do
it would be nice if we had those
explicitly specified sadly enough I'm
not going to cover the entire act
Immunization here I know you would all
enjoy that several hours of mathematical
derivations who wouldn't think that was
fun but unfortunately we don't have time
for that there's lots of cool things and
they're like if I ask the notes arranged
then either insr equal or plus plus is
denotes arranged as well unfortunately I
ran into a problem with staple sentinels
when I was doing this so here's a Type S
this type has one one member it's an
integer I and it has an equality
operation when compared with an int
pointer it says I'm it returns true if
and only if that int pointer points is
something that's greater than or equal
to my int member right this is simple
enough this looks like some kind of a
threshold in and I'm trying to make a
Centon here so I've got to give it the
other kinds of quality it has to be
symmetrical equality wise i compare
compare an endpoint with an S I can
compare an S with an int pointer I can
compare SS with themselves right
remember I said we have to have this
symmetrical equality of operation that
returns true and of course I need to
define the not equal overloads
appropriately they need to be opposite
so what happens if I try to use this s
as a sentinel I have this particular
range of integers right it has three
integers in it two one and three nice
and straightforward
well a plus one is not equal to s2
because a plus one denotes the value one
right which is obviously not greater
than or equal to two but a plus two is
equal to s 2 because 3 is greater than
equal to 2 so the range denoted by a
plus 1 and s2 is just a single integer 1
a plus 1 is also not equal to s3 because
1 is not greater than or equal to 3 but
a plus 2 is equal to s 3 because 3 again
is greater than equal to 3 so the range
a plus 1 s 3 is also exactly the same
thing right
just the integer one so since I've
established that a plus two equals both
s2 and s3 and the cross type equality
comparability concept tells me this
equals two relations of your ship is
transitive then it must be the case that
s2 equals us three right they both equal
the same iterator so they must both be
equal to each other and of course this
is true because we said that the
Equality relationship between symbols is
always true so we're fine so far right
everything is consistent
however a plus 0 is also equal to s2
because a plus 0 has the value 2 2 is
greater than or equal to 2 and therefore
the range a plus 0 s 2 is an empty range
it has nothing in it but since a plus 0
equals s2 and a plus 0 equals s2 and
I've already proven that a plus 2 equals
s2 earlier on it must be the case that
they're equal to each other so I've
proven that a plus 0 equals a plus 2 use
two different pointers into this same
array must in fact be equal even though
they point at different things and have
different addresses this is obviously a
contradiction and this fundamentally
arises with stateful ranges I'm sorry
staple sentinels because of the cross
type of quality comparable concept
requires transitivity across types I it
doesn't make sense in some way for me to
say that sentinels always have to
compare equal if sentinels are
predicates and these predicates are
allowed to have state so even though s
looks like a sinal to me it's not it it
didn't satisfy the concepts there was a
contradiction so the problem here is
like I said the sentinels are positions
idea versus the idea that since animals
are predicates so they don't both make
sense at the same time we had two
implementations and strangely enough
neither of the two implementations had
stumbled across this issue or exploded
or open a black hole
despite the contradiction so something
must be going on that the algorithms
aren't using this require
and that exists I went back and examined
the algorithms because like I said
earlier I was a hint of foreshadowing
the algorithms don't use equal to or not
equal to on single pass iterators I said
okay what are the algorithms do with
sentinels how do they use sentinels and
how do they use central the central
iterator operations together the
algorithms care that equality for
iterator and Sentinel and inequality for
iterators and sentinels all have the
same domain right all four of these
things should behave the same they care
about symmetry that I equals s means the
same thing as s equal to I and the same
for in the case of not equals I don't
want algorithm writers to have to care
about which side of the operation they
put which thing on they also care about
this complement requirement that not
equals has to have the opposite meaning
of equal to right this is
straightforward it's one of the things
that should be obvious but nothing is
ever obvious when you're defining
requirements we need to have a
requirement to be complete and ideally
the requirements should meet our
intuition so that we don't screw things
up the first three of these look a lot
like they should be requirements in
general for a quality comparison right
there's nothing iterator or Sentinel
specific here so conveniently enough I
said you know what we need to define a
weaker kind of a quality comparison
requirement than the cross type of
quality comparable concept from the Palo
Alto tr4 iterators and sentinels enter
weakly a quality comparable weekly a
quality comparable strangely enough has
exactly those three requirements that I
stated on the last slide were needed but
weren't specific to iterators and
sentinels so I took this concept and
factored it out essentially of the
existing equality comparison concepts
and you and refined this concept to make
those this is a kind of nasty in it
because in a sense were invoking your
predicate using the sentiment syntax for
equality comparison which is nasty
semantically because it doesn't have all
the semantics we expect when we see
equal equal right I've intentionally
removed that transitivity across types
so I'm breaking your expectations
this is unfortunate but it's necessary
to preserve backwards compatibility with
exhibit existing algorithms right the
existing algorithms use this syntax to
compare iterations of sentinels so it
has to work
nice consequence of this is that weak
ranges are possible right we already
knew we could write weak ranges with a
single iterator at where it's the length
of that range is implicitly is inferred
from the length of another range in the
operation or from an iterator and
account we know these weak ranges exist
it seems like she'd be able to describe
them with iterators and sentinels as
well well we can if we further relax our
sentinel concept to not require the
types to be individually a quality
comparable anymore since that
requirement was only there to satisfy
the cross type equality comparability
requirement right it said the types had
to be individually comparable as well so
now we don't need to satisfy that we
don't need to require the types to me
individually comparable so now I can
change my definition of s here I can
specifically change its self equality
comparison to do the same thing that we
all would have expected if I hadn't told
you that it was ok to return true for
all sentinels it says you know what look
at the ice return true if the eyes are
the same and now if we plug that into
our other program so everything
magically works as we intuitively
expected it to the properties that were
true before are true before except that
I can't use transitivity to say that s2
and s3 are equal and therefore I can't
derive the contradiction at the end so
now that we've done this we can say hey
if I don't need a quality comparison in
general to satisfy the cross type of
quality comparison for iterators and
sentinels then maybe I don't need these
strong concepts at all right I already
said that the algorithms don't use a
quality comparison on single pass ranges
so
why don't we simply get rid of the
strong variants we can get rid of the
strong variants and I can replace
references to strong concept name with
reference to weak concept name and
satisfies the central requirements right
if if it satisfies the Sentinel
requirements that it's a quality
comparable which was the only difference
that existed between these weak concepts
and the strong concepts having done that
we can say alright if I don't have
strong concepts there's no need for me
to distinguish between weak and strong
ones I can take my weak concepts and
strip that weak prefix from the
beginning of them and just use the
shorter simpler name and tada we've gone
back through the rest of the haiku we've
converted seven iterator categories back
into five by throwing two away and
renaming two of them of the old names
and now I can say hey look the ranges TS
doesn't change the standard model of
iterators all that much we still have
the same iterator categories this is a
nice from a teachability standpoint
because it's always better to have fewer
things to explain to people but most
importantly writers of single-pass
iterators and sentinels don't any longer
need to write this stupid Equality
comparison that always returns true or
does something wrong that violates the
requirements we've turned undefined
behavior into a compiler error right now
when people try to say hey this this
input iterator equal this other input
iterator that's a value I cashed earlier
mistakenly they won't get undefined
behavior the compiler will say hey this
input iterator type doesn't have an
equality comparison operation you've
screwed up this is very sexy but of
course it's not always true because
there are lots of input raters out there
that have operator equal to defined for
them right now all the ones in the C++
standard for example so hopefully
someday we'll get checked concept
implementations that can check
implementations and say hey you're using
this operation that isn't required by
your constraints you've screwed up here
so that the implementations will be able
to know they can't use that equality
even if it does happen to exist
and the types that a user ends up
passing to the algorithm the other nice
thing like I said we've reduced the
number of concepts it's seven down to
five again or C++ programmers we like to
make numbers bigger and make number
smaller and the best thing about it is
that word iterators now means things
that satisfy the iterator concept again
right we don't have to say iterator
means week iterators and explain to
people that that is intended even though
there's a concept called iterator that
iterators doesn't mean things that's
satisfying now we can say yes iterators
means thanks best buy the iterator
concept so the interesting takeaway here
is I guess from a standpoint of concept
library design you know what did I learn
here about this relationship and the
thing is that a the obviously first off
concepts that don't exactly fit the
usage requirements smell right they
should tell you that something is wrong
obviously we have to trade off the
minimality of requirements with our
perfect equational reasoning purity that
we like to have things look nice and
mathematical but when you've got
requirements for operations that nobody
is using it all something is definitely
wrong I also learned that you know again
deriving things from first principles is
a great way to get clarity when
something's wrong due to design you know
throw away your preconceptions and the
things that you think you know and just
start over this was great because for
some reason I didn't see the inherent
contradiction in this statements
sentinels are always equal iterators are
sometimes sentinels but iterators are
never always equal right this didn't
even occur to me until I was literally
typing up the slides for the talk was
when I had this thought and I should
have realized immediately you know from
these statements there's a contradiction
here somewhere this doesn't make sense
anyway if people would like to learn
more about their English TS I obviously
haven't covered everything or even a
significant percentage thereof this was
just something that I thought was an
interesting design evolution from an
error that we found in the design you
can go look at the ranges ts working
paper it's at that link these slides
will
sleepy made available at some point so
you can go in there and click on that
link there are early design blogs that
describe a lot of these low-level design
features in excruciating detail that
were interesting
I think obviously they were interesting
enough to pull me into being an author
of the ranges yes with Eric that are
available
Eric Kneedler com there's my
implementation of the ranges TS that
uses concepts and therefore needs a
recent version of GCC that supports
concepts to work you can get that and
play with it if you like which is all
sorts of fun there's the implementation
with C++ eleven concepts that are
hideous
nasty balls of metaprogramming which
means that they're kind of hard to use
and the error message is are interesting
in Eric nibblers range b3 library which
lots of people have probably heard about
before you can grab that and use it it
supports a wider range of compilers
obviously than mine since mine requires
concepts there's also a new
implementation of range b3 with
workarounds to compile with MS BC visual
C++ which is awesome there were many
changes made to the compiler and some
changes made to the library to get this
to work even though Visual C++ doesn't
fully support C++ 11 or C++ 14 one good
way to get that library if you want to
play with it individual C++ is using PC
package my buddy Robert promised me that
he would cover for me the next time I
want to go out and drink during the day
if I put this slide on my talk so those
of you that happen to use visual C++
this is an incredibly handy way to get a
hold of libraries and install things
with one command and never again have to
tell Visual Studio where your libraries
are or where their headers are or even
which of your libraries you happen to
want to use with a given project and
that's everything I had to say so if
there are comments questions people want
to point and laugh this would be a good
time to do that
question yes if we had a sentinel that
returned I'm sorry the comment is if we
had defined a sentinel that always
returns true for every iterator this
sentinel says it's true for every
iterator then we would find and
consistently immediately and the
response to that is yes that would be a
terrible implementation of a sentinel
actually no it's a the comet is that we
don't need stateful sentinels to
discover the bug that I said I
discovered and that's true to an extent
except that that sentinel design
violates other requirements as well I
think
the common is that we could go ahead and
use name functions and have them default
to the behavior of invoking what the
iterators would do I don't have a
detailed response for that obviously
customization points are an incredibly
complicated problem that we have to deal
with it lengthen their ranges TS because
we want to have constrained
customization points that have actual
semantics to them unlike the ones in the
C++ standard and in order to implement
those we have to somehow avoid invoking
the customization points with the same
names in namespace stud is very
problematic and been the topic of lots
of work but we think we have at least a
solution for all right the comment is
that it's confusing to use some
algorithms that expect arrange to be
denoted by two iterators with a range
that's a noted by an iterator and a
sentinel the example given orders
reverse you know how do i reverse a
range that starts with an iterator and
ends with a Sentinel when I don't know
what the and I don't have an iterator
for the end of that range especially
when if that range might be infinite it
might take me forever to find the end of
that range to be able to start reversing
it and the response is I don't have a
good answer to that right now that I
don't see we haven't quite got a handle
on infinite ranges yet and how to
incorporate them into the standard I'm
getting closer a lot of the newer
wording says things like iterator and
cyntha Nolton Doda range instead of
saying reach ability which once you
remove the reach ability requirement
allows for the possibility of infinite
ranges yes
comment please
so actually if you have something
denoted by a bi-directional iterator at
the center though the comment is that
something denoted by a bi-directional
iterator and a sentinel is not a
bi-directional range it's a forward
range and I would argue that in some
sense that's a matter of definition
right how do we define a range and I
define a range a foo range as being
something with foo iterators regardless
of what the characteristics of the in
delimiter are and that's obviously kind
of fudging a little bit in some sense an
iterator sentinel range has two
different sub ranges that we know about
right there's the beginner narrator and
there's the end sentinel and then
there's another point somewhere in
between here which is the highest
iterator i've ever seen right so that
when I write algorithms they start
traversing from the iterator and when I
get to here I have this sub range that I
know a begin and it or iterator for that
I can traverse using whatever the
traversal properties of my iterator
category are right I can move around in
here bidirectionally or randomly
depending on if I have bi-directional or
random access iterators and then I have
this other sub range here the iterator
Sentinel sub range that I can really
only traverse forward until I find the
sentinel so that's uh makes it
interesting to implement good range
algorithms because iterator Sentinel
algorithms you want to be single paths
and forward only in some kind of sense
so yes it's complicated to write a
reverse that's efficient for an iterator
sentinel range because you need an end
to be able to reverse things and you
have to find an end if you don't have an
end a diretor
so the question sorry I don't I didn't
mean to interrupt I thought you were
pretty much the question is why don't we
you make ranges be the the fundamental
thing right why don't we build up range
algorithms that use ranges as an
indivisible kind of entity instead of
having iterators and saying you know
that ranges are just a proxy for
iterators and the best response I have
for that is to say that positions exist
right when we have when we have ranges
they often refer to data structures or
regions of memory and those things exist
and they have positions within them to
denote the different places and if we
try to throw out positions there are
certain things become harder to express
you know what does find return it's the
big question if you look at the D
standard library D ranges are
fundamental to DS range library you'll
see that it has several different
flavors of
find and there's one that returns the
range from the beginning of the range
you give it to the thing it found and
one that returns from the thing it found
until the end of the range and one that
returns both different sub ranges I
think and several different variations
thereof and it's all because the D
doesn't really have a concept of
position it can't just say you know
here's this position and the range of
gave me where I found the thing so I
think that combined with the fact that
we have lots and lots of old code using
the position notion means that our range
notion and our position based and ocean
need to continue to interoperate oh my
session is over so I won't be taking any
more questions thank you all for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>