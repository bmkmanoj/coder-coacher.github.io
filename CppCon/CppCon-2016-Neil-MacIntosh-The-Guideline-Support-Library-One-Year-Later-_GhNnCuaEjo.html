<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Neil MacIntosh “The Guideline Support Library: One Year Later&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Neil MacIntosh “The Guideline Support Library: One Year Later&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Neil MacIntosh “The Guideline Support Library: One Year Later&quot;</b></h2><h5 class="post__date">2016-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_GhNnCuaEjo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's get on to what this talks about
which is the guideline support library
one year later
so are we going to talk about today
let's find out if I can hit the button
that makes PowerPoint go forwards oh
well not you know hello
play or not okay but we'll just try
getting the old-fashioned way shall we
start how it really doesn't want to show
you the slides well it's going to be a
very short talk it just kind of just
consists of starting there let's try
starting from here instead shift shift
f5 there we are so hopefully we can move
forward from here yes good just not
backwards okay so our agenda was briefly
I'm going to talk about a refresher of
what the GSL is what our implementations
about I'm going to talk about things
that have happened to the GSL in the
past year what we did basically a sort
of a summer vacation report if you like
and then I'm going to talk about what we
plan to do in the future how you can
help how you can use it and why it would
be great if more people joined in and
used it so let's review what happened at
this conference last year okay so we
announced the GSL it was part of the
announcement of the core guidelines so
the whole aim of the project of the core
guidelines plus the GSL is to have more
safety by construction in our
programming simpler better more
efficient more fun programming basically
and the guideline support library it's a
collection of small foundational types
to help you achieve that goal they're
referenced throughout the core
guidelines in examples of how you could
do something better than the bad old
ways that exist in the language so at
the same time at CPP con last year we
publicly released the Microsoft
implementation of that library so it's
open source standards-based it's
portable it's up there and github for
everybody to download and have a play
with it's under the MIT license out the
box we support em SVC clang GCC we've
seen a ported to a bunch of platforms it
runs on various versions of Windows it
runs on Linux and OS X which that
somebody just told me is called Mac OS
now sorry I live in the past so that's
what we did last year we announced it
and then PowerPoint decided to that that
would that you get one slide at a time
today with me so I'll just do it that
way I don't know how these computer
things work they're super complicated
thing but somebody tells me like there's
a bit of way to avoid bugs like this I
just don't know what it is yeah nice
yeah that's a good idea I have to tell
my management that they love it
so this is where we are one year later
here's a snapshot of what it looks like
on github so we've got you know two
hundred and thirty-odd watchers I don't
know what that is but it's creepy
because they look like the Eye of Sauron
to me I'm one of them apparently because
I can unwatched I'm we've got stars and
we've got Forbes I don't know what any
of those things really mean or how they
write compared to other projects I just
thought I'd put them on there because
they look like statistics and so enjoy
them but personally if I was get
harboured making called like rainbows
and ponies and unicorns or something in
that way I'd feel better about having
two hundred and thirty two of them as it
is I feel a little creeped out we've had
three hundred fifty-three commits that's
almost one per day but obviously we've
got drunk sometimes and forgot but in
actual fact if you look at the graphs on
github it's a little bit more bursty
than that I'm afraid
and forty-one contributors is a number
I'm really excited by the best news is
only about six and six or seven of them
work for my company and out of that
number only about two or three directly
report to me so I actually think that's
quite an achievement we've got a broad
range of people who have committed
something at some point to the GSL which
is cool I've given you some statistics
there cuz everybody well actually
because I work in a management chain and
I've just learned you always have to
have a slide with some statistics and
really matter what they say people just
need to look at the numbers
so there's some statistics about issues
and PRS you can see that we've got a few
outstanding at the moment these numbers
are a couple of days out of date and I
had to write this presentation so
probably the number of got larger than
it should but we do resolve most of them
we occasionally reject things and we get
a few duplicates I think on the whole we
do a pretty good job of processing most
of those issues that tells me that
people when they join in on the effort
when you point out there's problems and
when we have these discussions on the
repo it actually results in things we
accept and and convert in one way or
another into the GSL so that tells me
the whole sort of open source community
process is working which is good and
down the bottom here you can see it's
pretty small right it's three thousand
lines of code I think I've seen plenty
of functions inside my company that are
three thousand lines long right so it's
a small amount of code with an
equivalently small amount of tests which
is something I'd like to see change and
grow and outstrip the size of the code
over time ideally but the nice thing
about it is its small its compact so bit
of a refresher about the GSL right the
abstract concept as opposed to the
implementation we were just talking
about there so ii mentioned before it's
all about making your programming better
and there's two key focuses we've got in
the library at an abstract level the
first is to encourage more memory safety
right don't overrun buffers anymore
don't write to things you shouldn't
don't dereference already deleted
pointers or old pointers these things
are bad for programs and bad for our
users the second is type safety if some
things in integer use it as an integer
and not as a pointer right because those
sorts of practices lead to surprises and
again nasty outcomes for everybody so
they're the two key concerns we have
when we put together the functions and
types in the library the second part of
it is it needs to be efficient there's
that whole closer to the middle zero
overhead you know promised land that c++
wants to lead us to and the GSL is part
of that whole story so we have this
really key focus in the library design
which is it should be no more overhead
than if you wrote equivalent safe code
by hand right using whatever techniques
you like that's not the same as as low
overhead as unsafe
right it'll always have a little bit of
overhead compared to adding safe code
but the goal here is safety at a very
affordable cost so let's have a look at
what's in it because when I talked about
the GSL last year I didn't really get a
great opportunity to dive into all the
different parts and some of them have
been added in the past year so I thought
now is a good time to show off a list of
words on a screen and and boy you by
walking them through walking you through
them a little bit so let's start on the
left-hand side of the slide where the
exciting stuff is so the top of the list
is obviously the owners and containers
so these are the way we manage
allocations safely in programs right so
hopefully unique pointer and shared
pointer on that list are pretty familiar
to everybody and we're just talking
about the standard library types there
it's not some nefarious alternate
implementation and the GSL that has some
strange behavior you didn't expect the
standard the standard two of them owner
of tea is really like the best way to
think of it is an encapsulated unique
pointer it's a way of being able to mark
legacy code that has raw pointers that
that point to heap allocations and say
you know what here is the pointer that
owns a heap allocation in the same way
that unique pointer does it gives tools
a better chance of working out what's
going on and following around for leaks
or for double deletes and so on and it
gives code reviewers and you and your
friends a bit a chance of being able to
follow what's going on as well the last
two on that list dine array is pretty
simple it's a runtime equivalent you
might think of as you might think of it
as a runtime equivalent to stood array
so it's a fixed size array but the
length of the array is determined at run
time rather than a compile time so it's
like vector but it can't shrink or grow
is another way of putting it and stack
array I like to think of as the extra
credit challenged that biana
put in when he was contributing here and
that's the idea that it's the same thing
as dying array but somehow its
allocation is made from the stack rather
than the heap for environments that want
to see that efficiency it turns out
that's pretty hard to actually go and
implement in a portable way so I still
like to see that as the extra credit
challenge if we can do that we're
winning
underneath our owners in containers list
we have the views so span which I think
most people have heard of by now string
span the string equivalent so these are
ways of accessing sequences of objects
without having to know how they're being
stored elsewhere so this is a nice way
to separate concerns in your application
it allows us to be really careful about
not overrunning bounds of things there's
a wealth of sort of improvements to the
design of your code that you get from
embracing things like string span and
span and the odd one out bout down the
bottom there is Z string with its
constant it's wide variance I think last
year I had a pretty lame joke about how
yeah Z string was zu string because of
Gabi dos Reis and a strong French accent
this year when I've written it is the CW
out front it looks more polished to me
but I don't have a polish team member to
make the butt of my joke so I'll just
have to leave it up there and say if
like I don't know so the string I'm not
sure z string it is in the utilities
section we have not now which is a
simple way to say the pointer here
should never be null seems like a useful
sort of a thing especially for pointer
parameters which might be part of a
legacy API you don't to replace them
with a reference but you do want to be
able to say hey this thing I don't ever
want to get a null here because we've
all been in the case where we do in it's
bad news finally a simple way to produce
a one-shot function that will execute
when you leave scope no matter how you
leave this go so you can think of it as
a quick and dirty ra íí- mechanism to
use in your code hey I'm writing
something here I know at the end of the
scope I really need to clean up a
resource wrap it in a lambda pass it to
a finally off you go we have ensures and
it expects under contract support there
like the nexus of evil in the GSL
because their macros are therefore
they're clearly evil
there are standings for the lack of a
contracts facility in the language today
now I'd love to see a contracts facility
in the language one day until it comes
we have these macros allow us to specify
preconditions and postconditions for
functions and have them enforced and
we'll dig a little bit more into that
later in the talk about how the
enforcement works
under the conversions section I'd start
with narrowcast ahead of narrow narrow
carts a really simple concept it's just
static cast renamed right and the idea
of narrow cast is you use it where your
static cast is narrowing something right
you're going from an int to a short
right it might be might be perfectly
safe maybe your value is too in that
variable so it's fine go from into a
short your two will remain a two but
maybe your value is you know like 80,000
and it's going to change on its way from
into a short on some platforms so narrow
cast lets you see hey I am explicitly
moving this theme to a narrowest
representation space and it just does
exactly what static cast does if you'd
like some extra protection sometimes we
all would narrow is your friend because
narrow will actually go and assert hey I
moved it to the the short and it's still
the same value as it was in the int and
if it's not I'm gonna do whatever the
contract facility is configured to do in
your library tell you things went wrong
so they're a great way to make more
explicit in your code
those narrowing conversions and where
you choose to catch potential errors
from them finally there's the most
speculative part of the library at the
moment is the concepts on the right hand
side of the screen and we're really
basically stealing them from the
Magnificent Rangers by inclusion the
problem in my particular implementation
is we don't have a great way to do
concepts today and we're waiting for the
compiler support there once it comes we
can do something much better but at
least conceptually they belong to GSL
because we think they're a great thing
when you're doing template
metaprogramming in particular or just
template programming in general so as I
say this is just a quick rough guide
it's bigger than I did last year there's
probably things I've missed does URL
down the bottom to the core guidelines
themselves which is the definitive
reference on things that should be in
the GSL so that's the place to go and
look so whenever I talk about the GSL
people often say yeah but what about
standard library isn't that's supposed
to be the foundational set of types for
program in C++ that's the answer to all
my needs why would I look at your stupid
library it's a fair question
the salad library is awesome I love it
it's getting better all the time
it's really cool talking about it at
standards meetings it's just you know
it's fascinating perhaps only one or two
people I think got the very very slight
sarcasm in that statement and the answer
is the two are complimentary and one
sort of feeding the other to a degree
right so we already include some parts
of the standard library in the GSL and
we're trying to standardize parts of the
GSL that we think makes sense to
standardize so the overlap between the
two the intersection should grow over
time so one way you can think about the
GSL is like an extended version of the
or a TS if you like for some
foundational types that we think belong
in the standard library longer term not
saying everything in the GSL will end up
in the standard library but we would
hope that at least some significant
types and functions within it will spend
indeed we've already started that
process for span and bite and they're
both on track to go into the c++ 20
version of the standard library so yeah
there is some truth to the rumor that
we're trying to do this got a question
there mr. winters it's a good question
why does the GSL re-export unique
pointer and shared pointer in its own
namespace the answer is we can imagine
there are some environments where people
will want to GSL implementation where
their standard library may not have
caught up to the point where it has a
unique pointer understand in a shared
point yet and we want to give people
some degree of consistency as well right
that you're operating in the GSL and
these are the types that belong in the
GSL even if they happen to come from
your standard library so is it a pre
adopt for somebody who's not reached C++
11 yes
that's that's a good way of thinking of
it so where can I get geocells to
actually play with well I already
mentioned we've got ours up on github
and there's the URL at the top of the
screen I like to put all these things in
slide deck so you can go have a look
afterwards if you're interested or if
you haven't already our implementations
header only so it's really easy just
drop it into your favorite location off
you go and yesterday indeed I packaged
it up as a VC package our exciting
yep there's another ed coming now our
exciting new package management system
for deploying C++ libraries on Windows
platforms it is actually quite a cool
thing it's also open source it's also a
community effort and designed to
actually make things much easier and
better it only took me 20 minutes to put
it together under Robert Schumacher's I
was going to say violent guidance but he
didn't hit me at all right I'm just his
gaze is enough to make me do it we also
have it packaged up as a nougat package
or you can just go pull the source from
github
unlike Highlander is not just one it
cannot be only one there's multiple GSL
so there's ours but Martin Turner
Mattia bus alia have both contributed
implementations the GSL that fit in a
single header file support C++ 98
compilers much better than our
implementation does which is basically
not at all and and just have some slight
variations in the way they do things and
just recently Vicenta has forked our GSL
and he's got a name as well of providing
better downlevel compiler support
without it with variations on our
implementation so all of these are
fantastic things I love having multiple
implementations of the library out there
I think it's only a good thing for
everybody especially people on older
platforms it's great we are
implementation chooses to focus on C++
11 as a minimum as defined by c plus
plus 11 plus some hacks per m sv c 2013
today we want to move forward and we
want you to move forward on to newer
compilers because the language only gets
better with newer compilers your code
only gets better all those things so our
implementation is going to try and push
you forward over time but we recognize
that people have a need to move at their
own pace and there's it's great that
there's other implementations to help
you in that goal if you know of any
other implementations that I haven't
listed here please contact me and I'll
get them added to this slide deck before
it goes up on the web because I'm all
about advertising my friends in GSL love
so we as the documentation for all these
wonderful things other than in my head
it's a great question so the CPP core
guidelines is the primary source of
these things and ultimately what we had
hoped to have there is standard style
fairly dry specifications of everything
fairly dry and detailed so that anyone
can go and implement a GSL and get the
right behavior out of their
implementation if they want to so I
think that's an important goal so far
we've just got a couple of
standardization proposals for Bight and
span up there it's definitely something
we want to work on and improve and get
more of the specifications up there in
the very near future but not everybody
likes reading standards proposals and oh
I don't like reading stance proposals
and there's certainly not my definition
of good documentation I think a lot of
people like me find it easier to copy
and paste look at examples get some sort
of quick idea of how you use this and
how you know which things are easier to
adopt than others where's a good place
to start so we want some tutorial style
guidance as well that would be a
fantastic place for anybody who feels
they have a bit of a knack for
documentation to contribute to the
project we're going to try and make a
start in the next short period of time
after CPP con but anybody who wants to
you know pitch in and help please do so
who uses our implementation of this
amazing beast called the GSL and the
answer is we do right we implemented
this thing so we can use it inside
Microsoft so we dog food which I find a
repulsive term actually I prefer living
the dream because I'm just a glass
half-full kind of guy like I like to
think I'm heading towards the brave new
future and at the moment as of today we
use it the following places CPP korchek
which is a static analysis tooling
integrates into Visual Studio over V C++
and tries to enforce some of the core
guidelines so that's built heavily using
the GSL visual C++ itself the compiler
has started to use the geocell just
recently as part of a dog fooding effort
oops
living the dream effort office in some
core shared components have started to
adopt the GSL and one of the people
responsible for that is sitting in this
room right now
feeling nervous there's the edge HTML
browser which you know you get as a
fantastic new thing on Windows 10 also
users geo cell uses it in some key parts
like from memory it's like cascading
style sheet pausing and all those sorts
of sort of core parts of it and they're
looking to expand their adoption as well
there's currently some pilot work
underway to get Windows using the GSL in
earnest as well so the idea is that by
this time next year I think all of the
sort of the big-name flagship Microsoft
products that everybody knows will have
the GSL sitting inside them somewhere
and I think that would be it's a fine
tribute to our commitment to live the
dream there's also some other names up
on the slide though and there's some
exciting open-source projects that I
know about that are also using the GSL
and they both happen to be projects
whose contributors all leaders are
giving talks or have given talks at this
week's conference so there's the bear
flank hypervisor that Ryan Quinn works
on and I think a hypervisor is a good
example of a pretty low-level piece of
code and it's using the geocell and
there's been some great contributions
and feedback that have come out of that
usage and the same to the boost a FIO v2
right with Neil Douglas working there
they use the GSL in fact I think his
slide deck contains actual geocell span
being used in the wild for you to see
there you go if you are aware of other
projects and you'd like us to publicize
your use the geocell again insert your
name here let me know I like to I like
to tell the world about who's using it
and whether or not they like it and how
they use it okay so we get we finished
with the what is it and overview and
statistics what did we do with it in the
past year so the geocell itself in terms
of specification as a library was all
about standardization so we took a
review string view and byte to the
standardization process to see if we
could get them included in the standard
library let's walk through those
so a review the first thing that
happened is you got renamed to spam and
I think that was just starting to happen
at CPP con last year we'd already got
the feedback that hey ray V was the name
is super overloaded and there was a lot
of discussion about alternatives and you
know in the usual semi random way span
was chosen as a as a better name we also
got a ton of really useful feedback
about the interface of spam what it
should look like and one of those one of
the most confusing areas was the
original review in spann we're multi
Deventer or spam was multidimensional
and there was another proposal going
forth for Standardization of a
multi-dimensional view over data type at
the same time so we looked at the two
and they did things kind of the same and
then kind of different in places as well
and we wondered whether we should spend
a lot of time trying to reconciling them
into into one mega proposal and I think
the decision we made was the right one
which was Spain serves a really specific
super common use case which is a single
dimension array of data right you've got
a contiguous sequence and it's got one
dimension that's sort of 90 percent of
uses in C++ in the wild so what we want
for that is a type that's carefully
designed to support those use cases
makes them as easy as possible to write
it can be optimized as much as you like
to make them affect as effective and
efficient as possible because
multi-dimensional usage is a different
beast in lots and lots of ways you
sometimes on a slice and stride data and
it suddenly becomes non contiguous you
know you want to do things like change
the representation of the data the order
in which rows and columns and and you
know you need to be able to support
non-uniform memory access and there's
all these extra things that start
bubbling up very quickly once you look
at the multi-dimensional cases so we
thought by separating them away from
span we could concentrate on one solid
vocabulary time for the most common
programming cases so for those of you
who missed the multi dimensional support
or started using it in some way that
became multi span it's not the best name
something most original name that's made
it up in hurry but I left it there so
people can continue to use that and we
can
look at what we want to do with multi
span going forward we also got some good
feedback about you know fixing up small
things like iterators the set of
constructors on span and this summer
that work will still go on for a bit
there's a link there to the
standardization proposal for span at the
bottom of the slide string do we took
along as well but string views suffered
a less noble fate than span and we ended
up withdrawing it at the loulou meeting
we ended up withdrawing it not because
it's a bad idea but because it turns out
there's already another good idea and
there's going into the standard library
that's a very similar idea and that's
string view or basic string view to be
technical and it's a very similar
concept it's a view over a string and
they're just done different ways
effectively so string span has a
interface that's extremely similar to
span by design and string view has an
interface that is much closer to that of
string again by design and each you know
you can argue for the merits of each but
I think nobody could argue that you
didn't want to have string view in the
library it's a great idea it works well
with string so having two types with
very similar names and very similar
purposes just seemed like a good way to
confuse the world and annoy them at the
same time
so we bowed out and so string span lives
on in the GSL I'm not sure what we'll do
with it going forward in a world with
string view we need to sort of see does
its can its take out its own place in
the same way that we did with span
versus multi-dimensional span right is
there a way we separate these two to
make sense of them or are we going to
fold them together and just pick up a
new string view I'm not a hundred
percent sure that's something that's
something for the next 12 months of the
GSL even though we withdrew string span
I wouldn't want you to think that the Z
string span or z string is not a thing
right so that type is still really
useful it's just an alias for a
character pointer but it's a useful
alias because it tells you this char
pointer is actually supposed to be null
terminated as opposed to it's just a
pointer to a single character or it's
just a pointer to some object
representation I'm looking at that may
or may not have nulls in it and so on
and so on so that's a great way to make
your programs more expressive there
we think you should still continue to
use bite bite just seems like a really
obvious idea as soon as you look at it
and it was funny how many people and the
committee meetings would say it's such
an obvious thing that we need to buy it
but it's a really hard thing to get
agreement on so happily I think we have
got some agreement on taking bite in and
the nice thing about it is we've managed
to implement by using existing library
and language facilities so it's just in
implemented as a enum over an unsigned
char as its representation underneath so
that's a really nice elegant
representation we do have to change the
core language wording a little bit to
make it okay to alias memory and object
representations using a bite star but
that's a smaller change given it's
already over the existing type that's
allowed to do that so it's simple its
elegant it's going to be added to the
language we just missed the cutoff for
C++ 17 it turns out that even without
night times you can run out of time in
Finland at a meeting so unfortunately to
go to C++ 24 that's life good feedback
that we got on the type was to add some
basic bitwise operations and comparisons
they work the same way as they would for
unsigned char today so it's a really
unsurprising and uneventful and boring
little type but it says a lot about your
programs because now you can distinguish
numbers from characters from memory and
that to me is like a fundamental that
you need to be able to to do to be able
to write and read programs fairly safely
so because I love examples that are
really toy and cutesy I put together
this toy cutesy example of how these
cool things we did with the spec work
together nicely so if we imagine we're
going to do a very quick toy like
processing of a packet that's coming in
from unknown network or something it's
got a fixed sized header let's imagine
header size is declared somewhere to be
some constant number the first thing we
can do with these types is you can use a
fixed size span if you're going to
process the header
and you're gonna return the ball saying
Oh either I like the hitter or I don't
right ahead is gonna tell you some other
information in some way maybe in a story
somewhere maybe you'd return it and
something more useful their ball but
it's a toy had to fit on the screen the
point here is the spans pass by value
because it's a cheap to copy around
reference type it's just referring to
some data it's not storing the data the
data is stored wherever it was wherever
it came in some buffer somewhere that
you're processing out of her const byte
lets you say very clearly I'm not gonna
modify this stuff and I'm just looking
at memory I'm trading it as bytes maybe
it's a SN got one encoded or something
like that right it's not it's just not
an object I know about yet in any
meaningful way and you've specified the
size and it's fixed size so then we go
another function that just processes the
body the rest of the packet now that can
take a span too because it's kind of
presumably operate over the same buffer
it's just taking a pointer again into
the buffer again you're just looking at
the bytes so they're just can't spy it
this time it's a dynamic span right
because you don't know how long the body
of this packet will be so dynamic and
and fixed size bands each have their own
sort of success in this example and then
we have a little top-level thing that's
gonna function that's going to tie them
together and what we're gonna point out
here is you can still use pointer
lengths in a function just like the bad
old days if you want to or more
importantly if you have to write and so
maybe this is an API that we just can't
change right we need it to be pointing
link for some reason maybe it's an ABI
boundary right well maybe we just don't
have to go update too many callers yet
because we're in the process of adopting
the Geo cell that's another way you need
to sometimes think about these processes
is I slowly worm my way of goodness into
york's your source code base you know
start start at the center of the onion
and work your way out so we're going to
take a pointer on the length but we're
gonna make it a con spike pointer to
make things a little bit safer and
clearer so then you know the reason I
wanted to take a pointer length here is
to point out that you can initialize the
span with a pointer length and what
you've got is a really nice clear trust
point in your application I'm I'm making
a statement about this pointer and this
integer I got from somewhere I'm making
a statement that I trust that the two go
together and I try
that length is right that's a statement
the tools then have a real chance
because you've been they if they
understand span they understand what
you're saying at that line tools can go
and look then for evidence that'll I was
told to you so you can find a bug that's
a good thing and so can code reviewers
right lines like this where you
initialize a span from a point length
should be a red flag to everybody doing
a code review gee I hope we get this
right because otherwise it's going to be
wrong rotten all the way down to the
core the line that afterwards is really
nice because the illustrate illustrates
one of the the things I think is really
useful about span which is it lets you
get rid of worrying about null pointers
plus lengths being passed to you if a
null point is really important to you as
a signaling mechanism you can still call
dot data on span and ask to look at the
pointer to see if it was not or not but
you know nine times out of ten you don't
really care if it was a null pointer
passed to you or a valid pointer in a
zero length right all you care about is
do I have data and do I have enough data
to operate on particularly in this case
we were looking for a fixed size header
so span wraps all that up for you
it won't null pointer dereference there
it'll just tell you whether or not it's
got enough data i think that in itself
reduces the amount of error-prone error
handling code you need to write after
that you want to pass you're done you
want to pass this dynamic span you've
constructed is down to verify header
automatically it will check to make sure
that there is enough data to meet that
fixed size requirement when it
constructs the parameter to pass down to
verify header so span makes sure you
can't make a mistake so there's two
checks in this function to make sure
that there's header size number of bytes
there's one in the f-test and one in the
call to verify header now you'd hope
that good optimizing compilers will see
the two checks turn them into one and
make this make that second conversion
nice and cheap and we'll talk about that
a little bit later on but the point is
the guarantee is there even if somebody
under maintenance goes and removes your
if test that would make it safe or
modifies it or gets it wrong users eat
users less then stat less than equal to
or something like that finally once we
know that there's
enough room for the header in the packet
we can skip past it to process the body
and we just do that using sub span sub
spans cheap it's fast and it's safe
because it checks to make sure that
there's enough room to move past
obviously in this case we feel like
we're pretty confident about that
because we've already made the previous
two checks there was header size bytes
available so that's why I love spam it
makes programming so much simpler and
safer
so that was my spiel about what happened
to the GSL as a library over the past
year with synthetic example what
happened to our implementation of it in
the past year well most of the time was
spent tracking and tracing along with
the standardization changes and keeping
the implementation up today fixing bugs
and we did a lot of that not just for
span byte and string span but also for
the other types of listed there on the
screen there's more work to go on all of
them I'm sure but we did improve all of
them at least a little bit and had some
good discussions with the community
what's next for the GSL itself okay so
we've got to finish what we started so
we want to finish the standardization
process we want to add more
documentation as I talked about earlier
and we want to start thinking about
standardizing new types and finishing
their interface and make sure it's as
tight as possible and not null is the
first one that leaps to mind Multi span
I think we need to go back and revisit
do we want a multi-dimensional type what
does it look like how does it play with
the multi-dimensional view type that's
proposed in the link at the bottom of
the screen and in the implementation I
want to take a crack at those exciting
container types that I mentioned earlier
if anybody is interested in taking a
crack at that before we get to it please
send us a PR I would love some community
contributions there away from specific
types and implementation details I'd
like to do a much better job of release
management for the GSL from now on and a
number of people have asked about this
right on the repository so we're going
to start making releases there'll be a
fairly arbitrary thing they're not going
to necessarily correspond to oh and now
it's feature complete or you know it's
just not the way GSL works right the
evolution process works what they will
correspond to is hey we most likely
we've shipped an up
date visual see we've shipped the new
version of Visual Studio with a new
compiler in it there here's the version
of the GSL that corresponds to that that
we tested with that compiler it makes it
easy for our customers and our users to
know here's a snapshot of GSL the
correspondence to a release of our
compiler at least I'm not against doing
other releases for other reasons but for
me that's the most useful release cycle
we could follow that I can see at the
moment and I'll label the releases and
I'll make sure that the new get packages
and the VC packages reflect those labels
so you can go peep from your favorite
package management system if that's how
you acquire the GSL will also be
deprecated MSB C 30 2013 at some point
the next year because at some point the
next year I'm hoping that we'll see the
next version of Visual Studio and when
we do I don't even want to come only
ever one to have to support two versions
of our compiler at a time okay because
otherwise I just it's just too painful
for words and that's going to be the
current shipping version of Visual
Studio which today is vs 2015 but at
some point the future BBS next and the
previous one previous ones currently vs
2013 once the previous version becomes B
as 2015 2013 drops off my care list and
that's where we talked about how useful
it is to have Forks and other GSL
implementations that might want to give
you longer period of support for the
older compilers and last but not least
we're going to do some performance
tuning specifically if span in the next
year so just a quick reminder that the
target was zero overhead for equivalent
checks to handwritten code so you've got
one big knob you can turn today in the
GSL to manage performance and that's how
are those contracts ensures and expects
evaluate so you can have them evaluated
and turn into an immediate quarters to
terminate if the check fails you can
have them evaluated throw an exception
we can have them evaluated and do
nothing and enjoy the world of undefined
behavior which is obviously filled with
rainbows unicorns beer you know you name
it it's got it I would recommend you
choose the first and that's what we ship
in the products where we use the GSL
and just as a data point even though
we're talking about performance I have
not had a single complaint yet from
internal users using the GSL that
performance of span and its runtime
checks cost them anything
usually there's such big pieces of
software doing other things like you
know loading web pages and images from
into like networking it doesn't actually
make much difference in the mix to them
that doesn't mean we don't want to make
it as small and fast and efficient as
possible and that doesn't mean it might
not have an impact somewhere it's just
not a particularly measurable one that
makes it unusable today so for people
who say I can't use it till it's not
optimized you'd be in the minority I
think if you really felt that way you
could use the bottom option but you'd
have to be super confident the middle
option I see is mainly about testing but
you know there are environments where
you need to be able to handle an
exception rather than fail fast and
there's been some interesting topics so
talks that this week on that very topic
I think so the tuning we're looking at
doing is around span and we wanted it to
be with our compiler because a compiler
currently the optimizer support that was
built does ship in the compiler and has
since update - it's only for x64
architectures because you've got to
start somewhere other ones will follow
but it requires source changes to span
that aren't on github yet
so after cpp con my long list of things
to do to the GSL repository is push up
those source changes into span when I do
that I'm gonna make a VC blog post
because my PM loves it when we make BC
blog posts and he's very good at making
them so he'll make the blog post I
should say at the link down there on the
screen and we'll dive into some
interesting really nutty details of how
it works and you know what to look for
but what I can give you a sneak peak of
is these are the sorts of cases with
with going to target with this first
round of tuning now they're all very
solid they're very simple cases because
they fit on a screen but they're very
simple cases to op like in terms of
optimization you know you look at them
and they make sense if it's a fixed
length span and you're indexing inside a
function so parameter you're indexing
inside that fixed length well
construction of the span will have
already done the link the range check
right so you don't need to range check
again
for that red code the a sub 4 so there's
a simple obvious case where people are
going to expect to see that range check
elided all the places in red on the
screen a place is where today a range
check would occur like just blindly
every single time and they're places
where we think it probably shouldn't so
in the second example if you test the
condition in the F and this is like my
toy example earlier you'd probably elide
the check that would happen at the line
inside the F right because it's
redundant and inside loops you get even
more opportunities because there's
opportunities to hoist even if you need
the check still you can hoist the check
and in the last example sometimes you
hoist it you might rewrite it to make
more sense these are all opportunities
we're actively targeting now you do get
those optimizations today sometimes with
spam right depending on your compiler
your optimization level what your code
looks like some compilers including ours
will pick it up and do these things for
you but they're heavily dependent on
what the code around looks like right
like all optimizations they can be
negated so what we're hoping to do with
this is make them negated less often so
make those optimizations a little more
reliable in the wild I've got a question
there so the question is are we tagging
on GSL span or is it a built in or
something we're looking into
so a reasonable right so agree it would
would other GSL implementations have the
same advantage or the same opportunities
so the answer is we're going to most
likely change the way we do the contract
checks rather than recognize span
especially and we'll change them to use
at least one intrinsic that's known to
our compiler and has a specific meaning
and can be keyed off to do some some
cleverness if we like so there's nothing
stopping other GSL implementations
adopting that same strategy when they're
compiling on the right version of our
compiler so yeah it should be open to
others it's great question thank you oh
there's another one down there
that's a very I don't know the answer to
so do the other GSL implementations use
the same namespace yeah I mean they
should because it's prescribed in the
core guidelines that everything should
be in GSL but I haven't checked to be
honest I'm pretty sure that Martin
manners does for chin tase a fork of
ours so it would I don't know about
Matias okay one more question
yes right so the question is is there a
test suite for the GSL yes so our
Microsoft implementation today has a
test suite that is sort of effectively
also the via the validation test suite
because we happen to be the same people
implementing it a contributing to the
design to a large degree especially as
we've been tracking the standardization
so I would like to move parts of that
test suite that are really about
validating that the interface works as
it should to the crawl guidelines
repository ultimately so there's one
spot where you can go get all of that so
yeah the answer is yes there is a test
suite today but you know we probably
need to clean it up and put it somewhere
where people can consume it more easily
for alternate implementations and to
validate them so the questions were well
timed because we've hit my last slide
which is enthusing all of you to join
the GSL party right I want more than 41
contributors next year on my little
github homepage you know the more people
that contribute to this the better
people find bugs all the time they find
limitations with their specific usage
and I exhort you to come and join that
collection of people and port the GSL
our implementation start your own
implementation that's alternative if you
want to use our GSL tell us where it
doesn't work for you shortcomings bugs
feedback it all as that set of open
issues suggested gets listened to gets
incorporated makes it better for
everybody there's a bunch of links down
the bottom there and I think I've got
time I'm not sure what is that time here
yeah I've got time for some questions if
people have them I'm down the end there
so the question is is Spain going to
mandate maybe I for it or you know
there's part of its specification or are
we still stuck with hey it's a Spain you
don't know how its implemented the
current proposal for the standard
library simply says it might be
implemented as a pointer in length
internally but it doesn't specify
implementation details therefore it
doesn't specify the API of span so I
think that's probably the way it's going
to be right right so that yeah yeah it's
a good point you'd like to be able to
pass span across API boundaries even if
you can't pass a victor I think that's a
it's a reasonable thing I sort of
separate that issue from getting Spain
standardized and right is a separate
issue from should we have a standard API
and and you know what does it look like
and and so on and so forth but it's a
it's a reasonable point I have a lot of
sympathy for that payment right so
what's the experience being with people
using it on production code so it's a
good it's a fair question and I think
probably the overwhelming feedback we
get initially is your documentation is a
little light on so just to hack on that
point again please help us out if you
can with documentation because you'll
only make a lot of friends that way but
you're right are they finding problems
in their code they didn't know about we
so it's interesting internally because
we do run a whole suite of analysis
tools and so on that we don't ship
externally at this point that validate
or check for a lot of the problems that
these types are trying to overcome so to
a degree we've already caught a lot of
the low-hanging fruit so it's unlikely
spans going to stumble across a lot of
that we do get good feedback when we run
certainly the core guidelines checking
that there's lots of places where we
find
hey people are casting away Const here
why and then you ask this question your
drill through what is just a horrible
piece of code and you realize this is
really horrible right and a bug farm and
somebody needs to clean it up so the
core guidelines checking we've done
certainly finds things that smell bad
even if they're not an active bug today
what we've found and the feedback we've
gotten is that even if we didn't find a
smoking gun bug as you adopt spam and
you sort of hope that you don't when
it's shipping software what you do find
is all things got much much cleaner so
when that was certainly the case with
edge right well you'd have these
complicated loops with all these
pointers being Swizzle de round and
incremented and decremented and so on to
try and pass through stuff and replacing
it with span made it infinitely more
readable about what was going on I'm
slicing up a chunk here
now I'm chunking it now I'm doing it
again and you knew it was being checked
so it would just go bang if something
went wrong because it goes just to
terminate so people liked the fact that
the code was getting certainly simpler a
bit clearer and they felt there were
more checks there in case there was a
bug in there yes right so the static
analysis in shipping visual studio how
much it uses the GSL so there's sort of
two parts to the static analysis we ship
Visual Studio today so one is just the
basic set of checks that come with slash
analyze that doesn't use the GSL because
it's a separate code base from where
we've done cpp core check for instance
which is the new set of checks around
the core guidelines so we've only used
the GSL in the cpp core check tool at
this point which hilariously is actually
a much bigger code base than slash
analyze it's built on the larger
framework from an internal project we
are in the process of getting the slash
analyze onto GSL so that again in the
next year parts of the compiler of parts
of slash analyze will use GSL - sorry
i'm just checking to see if i'm not
favoring one side of the room
yes gentleman on the back
sure so the question is in one of the
previous slides I mentioned concerns
about not null with unique pointer and
shared pointer and could I elaborate so
there's an issue actually at the github
repository currently that just points
out that there's some trickiness once
you put a unique pointer or a shared
pointer inside and not null at the
moment and the trickiness comes from how
do i call get is it the same like it
does get what what are the semantics of
get does it even exist in on a not null
unique pointer for instance so there's
just some basic questions of are we
forwarding things properly in those
cases because when we design not now
originally we thought of it as a wrapper
over a raw pointer right but the other
problem is how do we do moves properly
and what do they really mean what
happens if you call you know reset it's
not like these are insoluble problems we
just want to make sure we've thought
through them sufficiently for them to
make sense we feel like not now over a
raw pointer is much simpler as a use
case you can design the interface and
you can understand it pretty clearly
once you're wrapping other people's
smart pointers or even wrapping span
right you start to run into oh what does
that really mean do i forward dot data
on span or do I call got get get and
does that mean if I had code using a
span and I made it a nochmal span I'd
have to change my dot data to get inside
my function we want to avoid those sorts
of tricky cases cropping up in the
future would rather think about them now
I think yeah I mean I would fit for now
I would say use not now on real pointers
because that was certainly the thought
process that led to its design right
like was it's a good way to signal hey
I'm passing by reference but I'm not
using a reference I'm using a pointer
but I do expect there to always be an
object at the end of the pointer we
didn't really envision oh and I'd
definitely use it for every smart
pointer in the universe as well not
saying it can't do that or some subset
of that I just don't think it was its
original design inspiration
right so the question is the static
analysis tool we demoed last year how
does it keep up with the changes to the
GSL and and you know how is it available
and basically what's the relationship if
you like between the two so the static
analysis tool we demoed last year is
best represented today in shipping bits
by CPP korchek so CPP korchek uses the
GSL it's rarely more than like I don't
know two weeks behind the github version
of the GSL in terms of the code it's
actually using to be like that we build
it with currently it doesn't recognize
any of the GSL types especially because
the only core guidelines it enforces at
the moment are just about pre-existing
language features like don't use
reinterpret cast don't Const cast away
Const please don't use a pointer use the
span instead so to enforce a lot of
those you don't actually need to
recognize geo cell types and functions
themselves you're just looking at
existing code patterns one reason we've
done there is we knew that span was
changing it was changing its name and
its interface and we wanted to give a
little bit of time to sort of come to
rest over time it will recognize those
parts over time we want to open-source
the code and the framework used for a
lot of those checks and then it's much
easier to keep it or you can you know
that at that point it's very easy to see
this thing because one github repo will
simply reference the other which is what
we do internally right now right so the
things we live demo at last you're still
not available so some of them are
actually available in our experimental
cpp core check nougat package so if you
download that turn it on for your
project it will give you some degree of
lifetime checking which is the stuff I
demoed on straight on stage with herb
last year it's not necessarily exactly
the same set of checks we had on stage
there is a difference between the two we
played around with the implementation in
between to be honest and it will change
again right this is experimental work
and we're trying to work out what's the
best subset of
attacking the problem to put into a
release tool so that it doesn't just
give random warnings and a lot of false
positives and annoy people too much I
think the existing one falls into that
category so the basic the basic story
there is we've got something out there
it's certainly not finished cooking it's
got some more time to go you should
expect to see more releases in the next
12 months and it should get better is
the answer question right so it's a it's
a great question about compiler support
and we talked about you know how we'll
move just to have two concurrent
releases being supported for em SVC but
what about other compilers that we
currently you know know that we compile
against in support so the answer there
will be driven I think somewhat by our
internal usage of other compilers as
much as anything as well as external
usage I haven't heard anybody who uses
those compilers internally or externally
coming to me and saying I've got two
concurrent versions I need to support
for whatever reason we happen to just
sort of fix on a version and use it for
much longer time than the MS PC cycle
and you know one could say somewhat
Snack Lee maybe that's because in SVC is
doing a lot of conformance catch-up work
in the last 12 months right fine you can
you know I'll take that pot shot of
myself from my own company so I don't
have a plan for it yet
I think we've you know we'll probably
just continue to support the versions we
have now as minimum versions for as long
as long as that seems to work once we
discover those minimum versions and
missing something and we think it's an
important something to be in the library
then we would probably bump onwards but
you know again it's feedback I'd love to
hear from the community if people have
particular preferences or nades who are
using it
right so the question is basically do we
plan to put the static and eleazar
analyzer work and the optimization work
into the clang c2 as we call it effort
the clang with Microsoft codes in
feature in Visual Studio you know it's
interesting question so the static
analysis part will stake analysis part
not so much at the moment so the static
analysis part is tied to the front-end
part of the compiler the part that
you're replacing with clang when you use
the clang front in so at the moment
there's no easy story to keep that going
there I guess the answer would be used
clang and lies or playing tidy if you've
got clean compliant code might be one
option or compile it again with the
Microsoft front end with slash analyze
on it or slash analyzed and CPP korchek
enabled and you'd get that static
analysis support it doesn't really
matter what code gen process is going on
in the background so you've got a couple
of different paths there in terms of the
optimizations they should find their way
into the clang with Microsoft code gene
product but over what time period and
whether they're there already I don't
know if the top of my head and I'd have
to go check to be honest right yes so
the question was is there a plan to have
CPP core check that static analysis
tools available via something other than
you get yes we plan to ship them in box
with Visual Studio in the next version
so they're just there by default and
then they just go through the whole
usual update mechanism every time we do
an update right so that makes them
easier for us to service and improve
them in Chrome
in a rapid way and it's much easier for
everybody to acquire them then all you
have to do is just turn them on in your
project settings and you're done
so yeah the nougat package solution was
a sort of a temporary path to get us up
and running in v/s 2015 2015 right so do
we plan to make an extension for CPP
korchek 4 vs 2015 probably not and
probably because the new version is
coming and then things will be in box
and we tend to be focused on you know
what can we ship and what do we want the
experience to be next time we do a
release because you can download it edit
your project as a nougat package and
turn it on we feel people have a path to
use it who want to adopt it now
and we just want to make that path
smoother and and just part of the
whiteboard visual studio I intend you
know a quiet visual studio from my
management I turned it on turn on the
chairs so we will support the nougat
package for some period of time but we
once we do the new release like this
next then we'll just freeze that you get
packaged as it was for the years 2015
and part of the reason there is when we
make changes to CPP korchek do testing
improvement to it we often find things
we want to change in the compiler at the
same time and it's much easier to do
that on the on the leading edge product
that's the latest release it's just the
way it works sorry will be supported in
vs code I've wondered that myself
sometimes as I've used years ago there's
no reason it can't be supported in vs
code it's just a matter of hooking the
hooking the machinery up so yeah I mean
there's nothing stopping it but I don't
have a plan to go do it out of my team
in the near future it is so the question
is you know we talked about optimizing
the bounds checks can you just turn them
off you can at the moment the hammer to
do that is that configuration macro for
the GSL as a whole you can just you know
GSL
enforcement of contracts or whatever the
enormous ugly all-caps name is that's a
big hammer though it turns off all the
contract checks for all the types and
functions in one go we considered having
a more fine-grained solution that let
you just turn them off for span or just
turn them off the narrow or whatever I
think the problem is it encourages
people to turn them off from my
perspective and I'd rather take a really
wholehearted run first at making them
efficient and affordable and so as you
don't notice them and if we do love that
and people still say I really need these
ones to turn off then we could have a
more fine-grained solution but for now
you can in release builds just say yeah
don't check any of the contracts I rent
my test suite I rent it in a debug mode
and I feel it's good enough so you know
I'm prepared to take the risk that's it
well thank you very much everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>