<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Arthur O'Dwyer “Template Normal Programming (part 2 of 2)&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Arthur O'Dwyer “Template Normal Programming (part 2 of 2)&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Arthur O'Dwyer “Template Normal Programming (part 2 of 2)&quot;</b></h2><h5 class="post__date">2016-09-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VIz6xBvwYd8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello folks we're gonna start again we
got we've got quite a bit more to get
through hopefully so let's pick up where
we left off with how to partially
specialize a function the right way I
think is fun last time function
templates cannot be partially
specialized right you can't you can't do
it so if we have something that we want
to behave like a function which is to
say it's a procedure for doing a thing
from some inputs and getting some
outputs and we need it to be partially
specialized on the type of those inputs
the right way to do it is to delegate
the partial specialization work off to
some thing that can be partially
specialized such as a class template and
you use the right tool for the job if
you need partial specialization use
something that can be partially
specialized and don't use something that
can't so in this case I have a single
function called this pointer single
function template called his pointer and
all it does is instantiate one of these
two classes one of these plenties class
templates I have a primary template atop
and I have a partial specialization of
this class and is a partial
specialization because it's got angle
brackets after the name is pointer in
pole it's got angle brackets that means
it's a partial specialization and I just
dispatched a one or the other of them
and you know for and there it works and
this is also how I could implement the
is void trade earlier using a full
specialization now you know everything
there is to know about all these kinds
of things which is nice but there's
still one more thing I want to explain
let's talk about translation units so
here's a puzzle which we're not actually
gonna puzzle over but suppose we had to
write a function to reverse the
characters of a possibly multi byte
string in place only possibly multi by
it we also want versions that work for
ASCII ASCII UTF a you know different
character sets latin-1 but we don't want
to do it using the old terrible you know
mb len and m mb in all these different
functions with locales how c did it we
would like it to be compile time and be
able to parameterize it on the character
set itself and we're gonna do that as a
template parameter so how I would use it
might look something like this
I've got this function called reverse
and it takes as a template parameter so
it's a function template keep calling
these things functions
takes a template parameter called
charset and that could be one of these
little tags drops up here struct ASCII
or struck utf-8 and depending on the
value or its pending on the the type
that's passed in I get one behavior or
the other right now reverse can be
implemented basically like this this is
the you know reverse each individual
character and then reverse the entire
string good good interview question by
the way remember those for your leg
voids and it relies on ambolyn of char
set which is a function that's going to
return and you know give given where I
am in the string tell me how many bytes
are in this next character for a ski
that's always gonna be one for utf-8 it
could be anywhere from one to four four
or maybe five so we're gonna need to
define some full specializations of mb
len here mb line of ascii always returns
1 mb learn a few tf8 returns something
complicated that oh well I don't want to
define all this in my header file this
makes me sad I would like to move this
definition of this template function
this full specialization out into a CPP
file and another translation unit term
of right there so I can do that
this this is a a definition just like
any other function definition and I can
make it a function declaration just like
any other function declaration by just
putting a semicolon there and then often
my CPP file I can write out the actual
implementation of it as we see here so
here I have my CPP file at the bottom
which has the definitions of my full
specializations and then and my header
file I have the declarations of those
two specializations and I have the
definition of the primary template for a
reverse that make sense and this works
fine however that's still a lot of code
I don't want all of that code that
wasn't that much it was like that much
but so I don't want it in my header file
I want to put my implementation code in
my CPP file if I can't so how do I get
rid of that well that brings us
- this next a little bit of syntax here
so I can I'm sorry not quite yet because
first I can say okay well I'll just
specialize that I'll specialize it fully
for reverse of ascii and verse of utf-8
I'll tell it's I have full
specializations of these and I'll put
the full specializations down the CPP
file but now I've repeated the
implementation twice and I don't want to
do that either so what do I do now
okay well now we get to a new piece of
syntax here explicit instantiation
definition this is a special syntax that
means please instantiate this template
with the given template parameters as if
it were being used right here it doesn't
tell you how to define and it just says
I would like this defined please so it
looks just like a full specialization
except that after the word template
where a full specialization has empty
angle brackets I told you those were
important because now they go away
template without the empty angle
brackets is a completely different thing
has no relation to an explicit
specialization and so it has a
completely different name that could not
possibly be confused with it called
explicit instantiation and it looks like
this the word template with no angle
brackets and then you declare the thing
again basically as if you were going to
use it's like class vector of int for
example is void vo void and that just
means instantiate the thing right here
please now if I don't want to
instantiate it right here and I would
just like to instantiate its declaration
and say well it's defined somewhere else
I can just take the word extern in front
of it
that's what extern does right it's what
i says like here's the declaration they
the definition is somewhere else and
then you'd better define it somewhere
else
all right so that's an explicit
instantiation definition and declaration
so there's there's one interesting thing
about explicit instantiation for class
templates which is different from
anything else because the weird thing
about classes and sequel suppose they'd
be the neat thing about them in
particular is they can have members a
function cannot have members a variable
cannot have members but a class can have
members and so when I explicitly
instantiate the definition of a class I
also that counts as an explicit
instantiation of all of that classes
members as well so when I say it and I
say I'm instantiating in class foo of
int I also
get food within : : F and foo of n : : G
in this translation unit as well so this
is a way if you have a whole bunch of
very similar templates and you would
like to explicitly instantiate them all
in one go maybe stick them all the
static members of some class and then
just instantiate that class boom if
that's a case you ever run into yourself
you know so we can explicitly
instantiate without specializing it
looks like this so here we have a
primary template still in the dot H file
and we're saying extern template no
angle brackets so that's an explicit
instantiation declaration that says I
have explicitly instantiated this
somewhere in my code not here don't
worry about it
you know just use it don't don't try to
find it yourself and in the CPP file
that's where I say template no angle
brackets and that and that is an
explicit instantiation definition that
causes Reverse of ASCII and reverse of
utf-8 to get instantiate it there don't
mix and match though these angle
brackets are important if I stick the
angle brackets on up here that says I
have some we're not here because I don't
have a body here but somewhere I have an
explicit specialization of full
specialization of Reverse a scape but I
don't actually make one in my CPP file
in my CPP file
I don't specialize it I just instantiate
the primary template because I forgot
the angle brackets there and so this is
not guaranteed to work although it
doesn't practice for reasons of men name
mangling here's the deal with name
mangling that this is exactly the case
we just looked at right right so on the
Left these are two translation units the
the two though papery things two
different modules two different CPP
files that I'm compiling and the one CPP
file I've said template bracket bracket
into agent and that is saying somewhere
in my code I have a full specialization
of a not here but somewhere and I try to
call it across in the right-hand one
I instantiate the primary template now
what happens that instantiate in the
primary template generates some code and
you know that the code has a mangled
function then people name mangling like
vaguely familiar yeah okay so it happens
that the name of the thing that gets
instantiated there happens to mangle to
the exact same thing as the thing that
I'm calling and so it will work but try
not to do that
and if you reverse it and I put over
here I put this is an explicit
instantiation declaration on the left
without the angle brackets and on the
right I've got a full specialization
that says well here's the full
specialization we now have two competing
definitions I'm sorry the thing on the
left is not a declaration it's a
definition because I didn't say the word
extern so we actually have two competing
definitions and they're probably not the
same because the one on the left is an
instantiation of the the dot I thought
in the primary template on the left and
the one on the right has its own though
about that thought that might have
something completely different in it and
so the the answer that I get from my
main here is gonna depend on whether it
was in line from my translation unit or
generated an out of line function call
to the other one and and it could depend
on optimization level or what order the
they happen to get linked in which order
the linker decided to throw away the
duplicate definition so this is fragile
even in practice and may change
depending on thing so so don't mix and
match now you know everything there's no
explicit instantiation that actually
concludes part one awesome do we have
any questions from the audience well I
go to part two if you look you'll get an
answer from the speaker while I go to
part two which is the bigger yeah can I
do explicit instantiation of classes and
extern them as well I believe that you
can not a hundred percent sure about
that but I think so and I think that
would do the obvious thing which is say
I have definitely explicitly
instantiated this somewhere but it's not
here and it would say that about all of
the members
the class how do you explicitly
instantiate a static member function of
a class template where the static member
function is actually static member
function template and it depends whether
that you that class template are you
making a template can stamp out
extensions of the static but you've got
two level of cookie-cutter there right
and you can do each one individually and
this is what you will see sometimes
where you have like template class T
template class you some stuff that
that's the syntax for if I have a class
template which has a member which is a
template and Here I am making a a cookie
cutter to stamp out cookie cutters to
stamp out the actual definition of the
thing because I have a template for a
template of a thing and I'm not actually
going to cover that which is too bad all
right does anyone need a refresher on
part one all right so let's talk about
some some idioms that we can use with
with templates let's say I wanted to
specialize on some condition that was
more complicated than that just make a
full specialization for void example
that I gave earlier so here I have an
example inspired from real life where I
have a tree container and a vector
container and they both have iterators
right have a tree iterator that when I'm
going through a tree right I can only
like plus plus that I can't like hop to
and nodes ahead in the tree without just
following the next pointers but with a
vector I can just do a random access
iterator and I have UI of a vector and
set down to bottom using them actually
okay hang on
what is this right I said tree iterator
ampersand I thought that whenever I
referred to a class template I always
needed to put the angle brackets because
otherwise it wouldn't be able to do so
what I meant well there's a special case
a special case is if I'm actually inside
the definition of that class template
itself then
I can kind of deduce which TI me and
then T I mean is T alright I'm inside
the definition I where I've got my
template parameters like element so tree
iterator implicitly means tree iterator
of element because I happen to be inside
the definition itself oak tree iterator
development this is known as the I'm
gonna say it's an injected class name
and I'm probably pretty close to right
so yes the bear template name can be
used as a type name in which case it's
basically as if you put all the template
parameters after an angle brackets this
is fine it helps cut down on repetition
especially in declaring things like the
copy assignment operator and things like
that I recommend that you use it and
especially that you know what it means
when you see it all right so we're
worried right so we have a we have a
standard algorithm called advanced that
takes an iterator of some type and
advances it by n positions and here's
the implementation of it it just calls
plus plus and times for random access
iterators we can actually do better we
could write something like this right
this is advanced specialized for vector
iterators where it takes a vector
iterator of some element type and in
that case it's gonna return and begin
plus in however no wrong that would be
that looks like it's supposed to try
trying to be a partial specialization
right it's got the same name as this
primary template but it's like sort of
more specialized but it's not fully
specialized well function template can
be fully specialized but they can't be
partially specialized no no no don't
therefore we shouldn't do it this way
and we could do it the the other way by
employing this class template but let's
just do something like this let's say
for tree iterator I'm gonna generalize a
little bit I'm gonna say we're not gonna
specialize just for a vector iterator
because I might add some new kind of
random access iterator later so I've got
my tree iterator and I'm gonna add a
member to it because I control all these
different iterator types and I can just
add a member that says supports plus
false and supports plus true and then I
can over I can make a function a a pair
of function templates which are not they
don't look anything like partial
specializations
because again they can't be because they
take a different parameter type as the
third parameter one of them takes
particularly false type and the other
one takes particularly true type and I'm
going to pass it or supports plus two
those let me go let me go back one slide
let me point out for those of you who
are already familiar with tag dispatch
that for the sake of pedagogy in this
case supports plus is not a member type
def it is actually a member variable
static member variable of false type if
people say in true type and false type
this is one bit of type traits it is
useful now they are you might say well
isn't that just a void or a bool no it's
not bool these are actually two
different types as different as int and
double they're they're very different
types and they happen to be for some
reason associated with the the semantic
values of true and false it's like if as
if we pretended that int were true and
double were false they're just two
completely different types that happen
to be associated with the concepts of
true and false and they're useful for
things like this where we're trying to
overload on on these concepts these
compiled on concepts of true and false
and that's not using concepts in the
Burano term i could but that would make
this slide a little bit more complicated
does everyone see how this slide works
before we go to the next one
all right in practice yes it will look
more like this
so up here instead of declaring a static
data member called supports plus I once
said make a member Elias member type def
name support plus supports plus tree
iterator of T : : sports plus is now an
alias for false type and vector iterator
of e : : supports plus is now an alias
for true type and I do the same thing
with advanced simple here and my
advanced calls this function advanced
simple with begin and and and then this
little expression here type name major
sports plus
curly Bret and so the curly braces are
there because we're trying now to create
an object of that type right those
there's the curly braces that you would
it could also be friends that would also
work but why the word type name how many
people have been writing template code
and you've had to stick the word type
name somewhere all right how many people
got like confused by that all right good
well so so what's going on with this
type name so C++ is grammar is not
context-free normally conduct
context-free grammar is one of these see
us something terms that you don't really
need to know but in order to parse
function definition you actually need to
know something about the context in
which that function is being defined
namely you need to know things like in
this example is a a function or a type
if a is a function then a of X is a
function call if it's a type then this
is like into X all right if a is a type
I'm just declaring X to be of type a so
I need to know something about the
context what is a and so if the context
ends up being dependent on a template
parameter where I don't know what that
parameter is yet T : : a I don't know
what that is that might be a function it
might be a type in land it might be
something else right so how can this
possibly work how can I have this
function here a function template and I
instantiate it with s1 where a is a
function then this should be a function
call to s1 of a that's what called a and
in this case foo of s2 well this should
be a declaration of an int how can we
possibly make this work the answer is we
can't that that's too much work so we're
just going to assume that any name that
depends on a template parameter refers
to a non type non template plain old
entity it's gonna be you know variable
or a function or you know but it's it's
a noun well type is now in too but it's
it's not a type it's not gonna be a type
or a template or any weird thing it's
gonna be a regular old the normal esteem
you can imagine so in this example foo
of s2
if we try to compile that it's gonna go
instantiate ends gonna say s to : : a is
a is some plain old thing that I'm gonna
call with X oh but it's not a plain old
thing it's int what doesn't make sense
it's gonna give you an error it's gonna
say it was parsed as a non type I
assumed it was a non type originally but
instantiation of foo of s 2 yields a
type so hard error and this is how we
fix that we stick the word type name in
front so to let the compiler know when
it parses that template hey this thing
coming up it might look like a regular
old plain thing you're gonna assume it's
a plain old thing because it's dependent
on the type print on a template
parameter but it's not I'm telling you
it's a type name so please treat it as a
type name that means this is a
definition variable definition and now
if I try to compile this one with s1 it
will say hey you told me to Y of it
t : : a was a type name and it's not so
it'll be an error similarly we have
things to refer to a template let's say
I had these three s1 s2 s3 and I try to
do this does this work if your moment to
digest this a little bit
s1 : : a is an int with value 0 0 less
than 0 greater than X discard the result
ok sure that works great foo of s2 t :
close so s2 : : now at this point a is
not a plain old thing a is a template so
we have to tell it template a right
template a ok this is an angle bracket
and the 0 is substituting in for n so N
equals 0 in that in that instantiation
and then we're gonna call it with the
with X ok so that works and then in s3
we actually have a variable declaration
we're declaring variable X to be of type
s3 : : a with N equals 0 ok so that's so
that's where these type name and
template key
it's come into play so hopefully from
that you can figure out where to use
them in future questions about template
type name dependent contexts right so
let's go back to attack this patch
example we see now why we have the type
name down there because if we didn't it
would have assumed because it er is a
template parameter it Urkel uncle and
supports + is probably a variable and
that's why my original example where it
was a variable worked out great as soon
as I make it a type name instead well
now I need to tell it explicitly when it
parses this template hey this is a type
name coming up otherwise I get a syntax
error okay so now you know if it there
is to know about tag dispatch except
what if we don't control it err
right because this entire thing up here
depended on my being able to insert this
supports + member into tree iterator and
vector iterator what if I wanted to work
with plain old pointers okay we have
nose class off of which to hang our
supports plus member type Dave what do
we do we make one up so I'm gonna make
up a new class I'm going to call it it
er traits and I'm gonna have it's gonna
be a class template and the primary
template is gonna say by default
supports plus is an alias for full type
and four-vector iterator sports plus is
gonna be an alias for to type this is a
partial specialization which is totally
fine because class templates are allowed
to do partial specialization and I'm
gonna make another partial
specialization for T stars where
supports plus is also true type and then
I can just use type name it ur traits of
it ur colon colon supports plus if it ur
happens to be one of those types are
which we've partially specialized the it
or traits class template supports plus
will be true type I will make a new
variable of type true type I will pass
that as the third argument to advanced
imple function overloading will say
you must want the one that takes the
third argument of type two type and it
will do the fast random access
implementation if it's not one of those
it will instantiate the primary template
create a variable of type false type
pass that to the one whose third
argument is false type yeah
I steal best practices you can also if
you want if they literate rates of
hitter supports plus and the fact we had
to write type name in front of it you
can again get rid of that by creating a
temp a alias template and stick the
typed name up in the alias template and
then your code gets cleaner because an
alias template always refers to a type
so we don't have to stick type name in
front of it anymore so tag this patch we
have one more nested function call in
here is the assumption that we can just
inline it away yep sure is
yeah compiler secreted in lining and I
know everything there's no bitrates
classes well so let's talk about
declarations and definitions we have
three cases here one is normal entities
like functions and variables this is the
case that we should all be real familiar
with is the case that exists in C so you
know I have here a function declaration
a variable declaration in the other
translation unit right two different
translation units here two different CPP
files I have the definitions and when I
try to use them from the left-hand
translation unit well they're declared
so it compiles fine and then the linker
finds the definitions over in the right
hand side and links and we're happy
inline functions and variables work a
little bit differently you can define
them in two places and it will work just
fine and the way that works is that the
linker will find out that oh you have
two definitions of this and where
normally that would be a multiple
definition error the linker will instead
just throw away all but one of them just
quietly throw them away and take
whichever one happen to come in first or
whatever here a stick it wants to use so
in this case I've actually defined a in
two places and this works just fine and
I'm actually using it in two places as
well yes what if there are different
definitions then you have undefined
behavior so don't do that yeah
now suppose I do something like this
where I have a declaration of the inline
function over here but I haven't told
the compiler how to define it but I'm
still trying to use it and then over on
the right hand side I have something
that does create a definition of it so
if I manage to get this all the way
through the compiler to the linker which
I believe you can in all major
implementations with that most like a
warning it will actually work because
the linker is totally happy it says
though you're using a I've got a
definition for a and it links but this
is officially ill-formed so avoid this
however the linker will kind of do the
right thing however this is ill-formed
because an inline function a variable
shall be defined in every translation
unit which is odr used outside of a
discarded statement and in the left-hand
translation unit we have an inline
function of variable which is OD are
used in main but it is not defined it's
defined in a different translation unit
in the same program which is why the
linker is totally happy and it probably
works in practice
but yeah officially don't do this and
especially I mean a good reason not to
do this in practice either is let's say
that someone does some refactoring on
the right-hand side and they remove foo
bar or let's say they turn on
optimizations on the right-hand side and
a gets in line so there's no longer a
definition so at this point there is no
definition of a on the right-hand side
because we did we didn't need it so you
know we got rid of it at compile time
and we go to link and suddenly there is
no more and now we have an error so it's
always good to make sure when you use an
inline function make sure that you also
provide the definition of it because I
mean that's a point of inline right we
want to we want to inline the definition
then for the Cole site so it'd be nice
to tell it what the definition is
so templates work under very very
similar rules here I'm using a
particular specialization of a and let's
see I've by the way I've been color
coding these in a little a little way
out and underlining where the the thing
is needed and bluing where the thing is
actually defined so here it's needed and
defined in the same place and over in
the
it's needed and defined in the same
place and it all works great again we
have two definitions and again the
linker does its magic thing that does
four in line which is throw away all but
one of them by the way that the
buzzwords to remember there are linked
one section if you were on GCC or clang
or a UNIX e-type operating system or for
Windows combat sections is hell that's
actually I'm letting you throw away all
the one of them or we could do something
like this on the left hand side I'm
trying to use a sub int but I haven't
told you how to define it so it's not
going to get defined over there but it
will get defined on the right hand side
because I have explicitly instantiated
it and so I'm using the explicit
initiation I'm defining the explicit
instantiation this should work in this
case I am using an explicit and implicit
instantiation a sub and on the right
hand side so we'll get to find over
there it's needed on the left hand side
the linker will probably link them
together and it will just work however
we have the same issues here as we had
with the inline case what if someone
refactor is away fubar then my code
breaks what if a sub in actually got in
lined and then the compiler decided to
Danida generate an out of mine
definition of it that my code breaks so
while this will work at zero you start
turning up the optimization level and
suddenly it breaks it maybe because you
were using a template instantiation in a
place where you have a declaration for
it but you haven't defined it and so the
compiler just generates the call and
then eventually it breaks in the linker
here's the example here a on a and is
unused then of course we have a linker
error there are at least the four ways
template stuff can go wrong we're gonna
talk about some of them now when it's
instantiation needed so this and rule of
thumb is never instantiate anything you
don't a hundred percent have to and this
is the decent rule of thumb for
understanding the compilers point of
view when the compiler sees something
like this I have a template here and it
has static a certain inside it that says
size of t is two and I'm
in Stan she ate this class with int now
size of int is not to size of int is for
for most people I'm gonna assume that it
is for these slides so I try to
expansion and it works I can actually
create a pointer to to a see of int just
fine
the static assert does not fire and the
reason the static assert doesn't fire is
that it doesn't need to be instantiated
that's in the body of the of the class
that's in the definition of the class
and in order to get a pointer to it I
don't need to have a definition of the
class I don't need to know its members I
don't need to know how big it is all I
need to know is how big is a pointer to
it and the answer is how big is a
pointer on your system and I just need
to know they is a class which it is so
this is totally fine now if I actually
whoops if I actually were to create
something without the pointer there now
sudden I need to know how big is the
class and that means I need to know what
are its members well it's a first quick
sidebar and static assert instead of
assert false how many people with no
static cert like pretty well inside out
yeah cool all right
so static assert is a compile time way
of making your program ill-formed and
requiring a diagnostic this is nice if
you are a library writer and your user
is doing something stupid that you want
to stop them from doing you can just
stick a static assert in there to say
hey you're probably doing it wrong or I
it's a sort of unit test at compile time
so if you are particularly relying on
some invariant and you really want to
check it like size of int equals four
like I know my codes on a break if we go
to a platform with two two by ten so I'm
just gonna static assert it right here
and that way my code will fail to
compile because they on the program will
be ill formed if that if it breaks
statics are false
always makes the program it will formed
if it's some constant expression
evaluating to false and it doesn't
depend on any template parameter you'll
have a real hard time getting that
passed the compiler because the compiler
will just be going along even parsing
through a template even if you don't
stand she ate it and it'll say you know
what you know in this example F F won't
even compile
matter if I instantiate it or not I'm
static asserting inside it that size of
into zero well that can't possibly be
true and so the compiler will actually
reject that out of hand and just say no
F will never compile this is this is
dumb you should just delete all of this
code and that means sometimes not be
what you want if you run into this
situation where you're trying to static
assert false somewhere and and it's not
letting you because it knows false is
always false the pro tip there is make
it depend on a template parameter
something like this where I say static
cert size of T for this template
parameter is zero well that's still
never really true
barring compiler extensions because no
type has size zero but because it's
dependent on T the compiler were
actually wait until it knows what T is
just let's do it in and find out so what
I have here is a function G that if you
use it it will static assert and if you
don't use that it won't and again by use
I mean something that actually requires
the definition to get instantiated so
that makes sense on static assert
because this is useful all right so
here's an example where I'm
instantiating the the definition of the
class and if you look closely you'll see
that each of the lines here s DM s M F
and F has a definition that also
shouldn't compile right in two of the
cases I'm static asserting that sizeof
int is two and quite a template
dependent so it's okay any other case
I'm trying to take no clutter and cast
it to a tee which is int and that
shouldn't compile either
you can't cast nobler to int but I can
still create an object of type C because
here I don't need to know the
definitions of SD MSM F and F all I need
to know is their declarations I need to
know the definition of the class and
therefore anything the declarations of
all its members to find out like which
ones take up space and so on but I don't
need to know what their initialized to
so again the compiler is applying it
applying its rule of thumb which is
never instantiate anything you don't
absolutely 100
have to instantiate I'm gonna skip few
of these slides
remember the template definitions behave
basically like they have the inline
keyword attached to them so in this case
we covered this act a little bit earlier
with the two slides and which things you
could get away with in practice in which
things you can't in this case you can
get away with ff1 in practice even
though you shouldn't do it because ff1
might be defined somewhere else the
compiler will often let you off with a
warning and as long as the linker is
happy you're happy
in case ff2 we will actually try to
instantiate the body of ff2 of this
inline function and we will find out
that the aesthetic certified fails in
fact we'll find it out very quickly so
you know when I try to do FF 2 when I've
read even define FF - it won't work
when I templatized these with a FF 1
that's totally fine but it better be
defined elsewhere with FF 2 now I'm
trying to call the thing so I better try
to define this body and I find out that
the definition of its body contains
static assert of something which is
false and therefore a static assert
failed if I add an explicit
instantiation definition remember
explicit an she ation definitions we
have extra 10 plate that says I promised
that someone somewhere else has
explicitly instantiated this so you
don't have to the compiler will say oh I
don't 100% have to instantiate this cool
I won't and it will completely ignore
the static assert and it won't fire it
probably fires in the other translation
unit if you did it right but it doesn't
fire in yours or if I fully specialized
F of 3 and I say somewhere else not here
but somewhere else I have made an
explicit full specialization of FF 3
event so you don't have to instantiate
the primary template please in fact
please don't in Spanish 8 the primary
template I want the full specialization
from elsewhere and it says ok I won't I
don't care what's in the primaries but
primary template anymore so this is also
fine variable templates work very
similarly to function templates in class
templates but watch out I have found
that clang and GCC currently disagree as
to what constitutes a definition of a
variable template
so in GCC and MSB see when I just say
template type in T into V T they say oh
yeah
that's just as if I wrote into BT
semicolon it's a definition it's a
global variables definition it reserved
space and so on for clang for some
reason this is just a declaration I
don't really understand it it's as if
you put the extern keyword in if you
wanted it to be a definition you would
need to actually initialize that you can
say equals zero or empty curly braces or
something and then it would say okay
this is now a definition for sure I feel
like this is a bug in clang but I don't
really know all right I know everything
there's no but implicit instantiation I
know that went like super fast and was
probably confusing but we're gonna have
less confusing stuff coming so let's all
forget that that section happens so
hopefully by now everyone's seen
periodic templates so I'm gonna skip
over the motivation and let's talk about
very etic template parameter deduction
yeah all right
so template parameter deduction in a
nutshell we already covered all of it
except for very attic templates which I
said we get to in part two so here it is
what happens in this case here I have a
template it's called F and it has a
certain number of parameters one of them
is named T and the others are named use
and it has some parameters collectively
named views which are of type capital
use and so they all contribute to
deduction right the parameters use
contribute to the deduction of template
parameters use so what am i telling it
well I'm telling it explicitly through
the angle brackets that the first
template parameter which would be T is
char okay I know that T is truck T is
fixed as char then I'm gonna deduce what
u is are so it looks like the first one
of yous is in tune the second one is int
and the third one is int and then we're
done okay cool that's the simple case
let's try this now I'm telling it well
the first template parameter T that's
char T is fixed this char and now the
second template parameter as is
interesting a second template parameter
is the first of the use that's also char
but I'm not saying anything about
the other use okay so then we go when we
look at the arguments well the first
argument that's the first one of the
lowercase used that doesn't contribute
to the deduction because we know that
that the type of that is char right and
then the next one that's an end so we
deduce the second one of uses ant and
the third one is int and then we're done
okay let me get that does that make
sense
- okay - hands yeah if the 0 with some
single quotes on the on which line my
use would be char int int
yeah T is char but the three arguments
all contribute to use T is actually not
deducible here if I don't specify T it
won't compile at all but also question
yeah okay they use do not all have to be
the same type
they all have to just like when I pass
multiple int to a function as function
parameters the instant I'll have the
same have the same value here when I
have multiple types as template
parameters they don't all have to be the
same type yes
yes you can just keep going as long as
you want there in the angle brackets or
outside them for that matter so as far
as explicitly specified template
parameters concerned the first pack
expansion encountered in the template
parameter list basically just soaks up
all of the remaining explicitly
specified template parameters those are
the things in the angle brackets the
type deduction step might wind up
lengthening that first pack but it will
never shorten it right where we said
like why know that the the first element
of use is char and the second element is
int and the third element is double but
I don't care what happens after that
well we might go on we say oh well I can
deduce that the fourth one is int and
the fifth one is sin is whatever yeah
so let's look at some of these cases in
this case we are specifying explicitly
that T is int and used begins with char
int something something something well V
we we don't know anything about V now
you might say well I can look at this
and I can predict that V would be int
and then use must just be the single of
element char but that's working right to
left and that's not what the compiler
does and that's not what the standard
says the compiler should do then Pilar
is doing its job in this case it's
saying okay T is in use this char and
maybe some other stuff and ve can't be
deduced at all and because if he can't
be deduced at all this will refuse to
compile all right this doesn't know what
V is in the second case T's starts out
with int and char and then well that's
all we know about that from the from the
parameter from the template parameter
list in the angle brackets so then we go
and we look and we say oh we have one
parameter one function parameter and
it's a double so you must be double and
then we're done and we have completely
deduced everything there is to say about
this function and so it works in this
case let's say we start off with int
char so T's starts off as int then char
so the first two parameters don't
contribute to type of duction at all so
it's okay that second one isn't the char
it's an int but it will get converted
and then there's a double so we add that
on to the the pack so T's is just in
char double and that also works the this
is actually a little bit interesting
right because you you might say well
yeah I said H of in char and I'm giving
it three arguments why doesn't it tell
me I just have too many arguments the
answer is well that's not how very attic
like deduction works questions about
this slide
oh yeah you would think so but no why
can't be be deduced well because they
use the is the first pack expansion that
we encountered and it soaks up all the
rest so it uses char and into maybe some
other stuff and then there's nothing
left for V and it can't be deduced from
the fabulist so why does the second one
work given it the first one failed
because in that case we can deduce EU
from the parameter list the parameter
list tells us that you must be double
I'm not sure what you mean by expanded
out the types then T's would be into
Chara double and you would be derived
and it would probably complain about the
number of parameters that you've had
well in that case I'd be fine but yeah
there's no way to specify in in the
second case in G there's no way to tell
it explicitly what u is you can only
ever be deduced from the parameter list
because anything I throw inside those
angle brackets is just gonna keep
getting added to T's
there's no way to specify you in the
angle brackets anything I throw in there
it's gonna get soaked up I believe yes
but I'm gonna move on to the next bet so
as far as deduction is concerned alright
so we talked about explicitly specified
template parameters now let's talk about
the parameter deduction a parameter pack
contributes to deduction only if it
comes at the very end of the parameter
list otherwise it does not contribute to
deduction so in this case I have in in
this case I have an F and I'm not going
to specify anything about the angle
bracket so I'm just going to eat
on the deduction and I'm gonna deduce
that the first parameter is you so
that's a char you as a char and then the
rest of the parameter is int int those
must be the t's so a way to do such is
fine in the second case to use these
parameters all of these parameters don't
contribute to deduction so and I have a
T at the end but that doesn't work
either like that there's just nothing I
can say at this point I'm like well x12
some of these some of these x12 things
are probably some of the use but the
users aren't aren't contributing to the
duction so I can't say anything about
capital use from this and so yeah I just
don't know where to start with this one
and with case H here I am explicitly
stating that T is int and that u starts
with int int now here they use don't
contribute to the deduction but we know
they start with in 10 so let's say okay
you know this one well it's a char but
we said it was and so it's int this is
ant and then we've run out of the use
that were explicitly specified so this
next thing must be a T so T must be int
and we have fact explicit well sorry
actually the T doesn't give you the
deduction either we already may already
specified that one too so this just
happens to work it's not a very
satisfying answer when I say it like
that so the trick here is that the
parameter pack contributes the deduction
only if it comes to the very end of the
parameter list so only an F do we deduce
anything about T's in the other cases
we're not deducing anything about use
yeah can I have two parameter packs as
template arguments like this so the
trick is what does it mean to contribute
to deduction again GCC and clang differ
on this in MSV c tends to agree with GCC
in this case I'm saying explicitly that
T's must start the first one of T's must
be int the second one must be int and
I'm not saying anything about the others
however T's
do not contribute to deduction so clang
says well you said T's couldn't read the
duction that's the very first thing in
here like I can't I don't know where to
start
all right you get a compiler error heart
error M SVC and GCC both say oh when you
told me it was int int and I'm not sure
what comes later but okay so this is an
int that's an int and then this next
thing must be used and so you the first
you must be an int and then I run out of
parameters so okay so so uses in or
that's a typo there for int I think
these Burbidge and that was a 3.0 if
that was a 3.0 this would be double so
yeah so again there's some confusion in
the compiler world about what contribute
to the duction really means now you know
everything there is to know about
template type deduction even for very
attics and I think that's the last
everything you need to know about yeah
what would happen if we just said F
parens one two three
in that case I believe that clang gives
you a compiler error and MSV c and GCC
say well you didn't tell me anything
about T so I'm gonna assume it's empty
and you as his indent it and it doesn't
make a whole lot of sense but this code
doesn't make a whole lot of sense don't
do this all right
let's take a quick break with some
patterns how many minutes do I have left
by the way all right well let's try two
real quick do this so the the CRT P is a
useful pattern to know and in fact it's
so useful that you can come to see me
afterward because I'm gonna talk more
about C++ 11 and I want to talk about
these things so I hope you all do too I
hope you're all excited for C++ 11
because here's some things that are
gonna be be new in it one of them I
already mentioned inline variables in
fact beyond I mentioned it he said don't
use them because they're global
variables and the terrible I think if
you're going to use global variables
make sure they're in line yeah can you
make static inline variables I believe
that you can
oh it's not a beta members that are in
line yes definitely yes definitely yes
to that one and that's pretty much all I
have to say about inline variables let's
talk about template audio this is a this
is a neat thing but it's not really that
neat
I haven't talked much about template
non-type parameters but by now when you
see in all of the ways that you can kind
of match up and deduce things you can
figure how a nan type parameter would
work if such a thing existed which it
does for example here there's a very
common one with Yui never use a stood
array right I say sit array of int comma
10 that 10 still in the angle brackets
is a non-title so in that case T is
explicitly specified as int and the end
parameter is explicitly specified as 10
you can also deduce template nan type
parameters and you you can see that when
you take B there's a function called
size that takes a reference to an array
of n elements and that you can actually
deduce what the n is in those cases
however mostly when you have these
template nan type parameters you will
see them mostly in metaprogramming
contexts like you can create these index
sequences of integers like that and you
also very frequently end up with things
like integral constants actually true
type and false type or special cases of
integral constant happen to be
associated with true and false so I can
do things like this and template auto
when when that starts coming and you
start getting scared by that know that
that is basically just collapsing
something like the above into that so
instead of now having two parameters one
to say what is the type of the thing
that's coming next and the other one to
say what is the thing we can now just
have one parameter and we no longer
really care about what its type is we
can get it with deco type if we want it
but as with generic lambdas we just say
Auto and we just get the thing
also remember when I said in part one
the class templates can't do deduction
there's a thing coming and C++ 17 that
be are now alluded to this is the slide
from before and remember and I said that
we we can't do the duction on class
templates coming in 17 a way to do
deduction on class templates at least
pretty constructors thereof and the way
this is gonna work is we're basically
whenever we see something like this
where there's a bear template name for a
class template and it's not followed by
any angle brackets then we know when
we're constructing an object of this
type we're gonna pretend that we have a
make helper function like make pair make
topple we're gonna pretend that that
exists and it has the exact same
signature as the constructor of the
primary template so in this case we have
a make my vac that takes a T and we're
going to pretend that instead of calling
the constructor of MIVEC something which
we don't know yet we're trying to deduce
we're gonna pretend that we called make
my vac of those exact same arguments and
then we're gonna do overload resolution
on that and we're gonna do a template
type of duction and so on we're gonna do
that ah if I called make my FAC of 1
then T there would be int so I'm gonna
say T here is int and I'm just going to
assume that you want to my BEC of int
and this happens to work really great
for parent uppal or here's a more
complicated example if i have two
different constructors for my beck it
still works
I'm making a MIVEC I resolve make my
Beck of one in this case overload
resolution looks at these now these are
not partial this is not a partial
specialization functions can't be
partially specialized we have two
different functions in the overload set
but this one is more specialized than
the other so this is a better match I'm
sorry this nope in this case one is not
a pointer sorry when it's not a pointer
so we do this one make magma with T
equals n then we go to my
coven's so it goes right in this case
now in this case we have an address of
an end so in this case this one is more
specialized so we take this this one
with T equals in and we get my FAC of
int using the pointer parameter so this
is a case where we have deduced
something for T that is not the thing we
passed though we passed it in star but
because there's this extra constructor
that takes a T star we can deduce T
equals n this makes sense this is the
first non totally obvious example of how
this might work
um the naming of this make my back this
is completely fictitious function it
does not exist in your code the compiler
is kind of pretending that this make
function exists based on the fact these
constructors exist and then it's also
pretending that you call it
you don't actually call it make pair and
make couple well they will still exist
are back with that ability but they you
will not continue to make make helpers
yes it does it does interact with with
Auto almost always Auto syntax as well
my FAC of one or my backup address I
will also work here's another example
we now have a template my back where it
has one overloaded takes a T and 1 over
it takes a double so let's pretend that
we had these two template function
templates and we're calling it with a
double well it turns out that we're
trying to call make my back of one dot
IO but the second overload this one
which takes a double we'd love to call
this but we don't know what T is T can't
be deduced so it doesn't participate so
we to go to this one and we say oh now T
is double okay I know about that and we
make a my back of double
or in this case where I have a partial
specialization of a class template in
this case it's super unclear I don't I
think not only will a compilers disagree
once this is implemented but I think the
standard needs a little bit of love in
this instance but in this case it sure
looks like we would get a compiler error
because we're gonna deduce that T is in
star and we're going to see that there's
a parse specialization for in star and
we're gonna try to call that constructor
and it doesn't exist and we're gonna
have issues so there's a little bit of
work to be done on the specification yet
this will also mean that there will be a
difference between these two classes
where right now there is not the
difference here is in the first case I
have a my fact that takes 80 and in the
second case I'm my vac that takes some
type def 40 some some some member type
def 50 and if I were to actually
construct the overload resolution here
and I would try to to call the red one
it would work great T would be int in
this case I know that my BEC of T : : :
: type is 1 it is int what does that say
about T well I don't know because I'm
back in the same problem I was in in C++
14 of well I know that some crazy member
I know something about T I know maybe
it's size you know where I know that
some member of this particular template
has ends that doesn't tell me what T is
specifically so in the blue case I
wouldn't be able to come to use the new
feature in the red case I am able to use
the new feature and if you want to guide
deduction to get it to do the right
thing there's a syntax for that it looks
a little odd it doesn't really look like
a declaration but that's also because
it's not really a declaration because
these constructors exist already you
don't need to read eclair them but you
need to in some way guide to say when
someone does something that looks like a
MIVEC of double and they don't say
anything about which MIVEC they want
they probably want my back of int and
you do that with this exact index little
air
that's a deduction guide and they
participate and the third one is clearly
the best one and so on and so on you
know all the crazy stuff coming in C++
17 and now we're actually done ahead of
time with two minutes remaining or
something um today one has any questions
like then I can also go back and talk
about mix-ins question because taking
the Oh why when I have two of 1 comma 2
comma 3 does it the deuce intends rather
than inter for F comma int ref ref comma
Intergraph because int int int works and
we don't like adding multiple ampersands
unless we need to
in fact we never like adding multiple
ampersands and we only add one if we
really really need to that was from part
1 we don't know were you here for the
first part yeah okay
well the same rule applies in part 1
alright well that that's it thank you
all for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>