<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Lars Knoll “Qt as a C++ Framework: History, Present State and Future” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Lars Knoll “Qt as a C++ Framework: History, Present State and Future” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Lars Knoll “Qt as a C++ Framework: History, Present State and Future”</b></h2><h5 class="post__date">2017-09-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YWiAUUblD34" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">(audience clapping)
- Thanks and good morning everybody.
Yeah, thanks for having
me here and giving me
the opportunity to speak
a little bit about Qt
as a C++ framework.
I'm gonna talk a little
big about where we're
coming from, where we are today,
some of the philosophies,
design principles
behind Qt because they to some extent
also differ a bit from
you know what you know
maybe from the standard libraries
and also have a little bit of an outlook
you know where we're going.
Let's see how this goes.
Just to get a quick idea,
I mean how many of you
do know Qt and have used it before?
(audience member cheering)
Wow, thanks.
That's great and fantastic.
So I'll probably be
telling you a little bit
of stuff you also already know.
But, let's see we'll keep the thing short,
but I'll still have a
little bit of an intro
about what Qt really is, what we have.
And, let's keep that one short.
Everything else you can see.
It's probably the most
comprehensive C++ framework
available today.
But, it's not only that.
It's not only a C++ framework.
We also have other things in there.
We have a lot of you
know tooling around it.
We have things to help you
create embedded devices.
We have a UI technology called Qt Quick
which is not C++ but
integrates very well with C++.
And, I'll come to that a bit later.
So there's a lot of stuff in there.
And, in the end, it has
pretty much everything
you need to do and to
create your applications
for whatever use case it is.
It's dual licensed.
We have a commercial version available.
And, there's also a
commercial company called
the Qt company behind a lot
of the development efforts
around Qt.
But, it's also available
under a combination
of LGPL version three
and GPL version three.
We're developing it fully out in the open.
It's an Open Source
project, the development
except a lot of the development
is done by the Qt company,
but we do have a lot of
external contributors as well
that help us, you know develop Qt further
and contribute whatever's
important to them to Qt.
We currently have two products
basically that you know
come out of that one.
One of them is called Qt
for Application Development
which covers pretty much all
desktop and mobile platforms
that are in use today.
We have Linux, Windows, Mac
OS, and on the mobile side,
IOS, Android, and also Windows Phone
if you're still using it.
In addition to that, we
had over the last years
an increasing focus also
on the embedded side
where we're seeing a
lot of usage coming up.
We're seeing many more
people that want to create
applications, you know complete devices
that have a user interface,
that have a touch screen,
where Qt is a very natural fit.
And, we're supporting most
of the embedded operating
systems that are in use out there.
Let's say for anything above
the microcontroller level.
So embedded Linux, QNX,
VxWorks, Windows, IoT Core,
Integrity.
Let's have a little look at
you know what's in there.
That's what I meant by
comprehensive framework.
The application development side is based
on top of a platform abstraction layer
that abstracts the way the
different operating systems
and their differences.
That's what you see on the bottom here.
On top of that, we have a
set of essential libraries
and frameworks as we're calling it.
It starts with Qt Core
which has the foundations,
you know tooling, classes,
threading, file IO,
you name it, everything non graphical.
GUI library which are the
foundations of graphical things,
painting, text, font
handling, anything related
to these kind of things, PDF generation,
lots of other stuff in there.
And, then on top of that, we
build up different things.
Widgets for classical desktop widgets.
We have a SQL module.
We have other things.
We have our Qt quick UI technology.
Multimedia, you know sensors integration
on mobile devices for
example and lots and lots
of other things.
As you see, the list is comprehensive.
And, then complementing
that on the right hand side,
development tools are mainly
centered around our Qt
Creator IDE, but we
also have an integration
for example in Visual Studio.
And, where we provide things
like graphical designers,
development help for C++
developer you know like stat,
Clang Static Analyzer
integration profiling,
debugging, remote debugging
on embedded devices,
all those kind of things.
So that's the application
development product
at a quick glance.
The other product, Device
Creation, is something that is
there for the embedded
device where we basically add
on top of Qt for application development.
It extends application development.
So what you see on the bottom is
basically what you just saw
before in the application
development slide for
the embedded platforms,
and then we extend that
with embedded specific
solutions like virtual keyboard, support
for different serial
buses like canbus, modbus,
software stack boot to Qt
where we make it easier
to integrate on an embedded Linux device,
and embedded tooling like you know running
a device emulator locally,
building for that one
and debugging on that
one, remote debugging
on the device, and these kind of things.
So that's, at a glance the product.
As I said, one of the main corner parts
of what we're doing there
is the Qt Creator IDE.
This is really the center
part of our offering
which many of our people use.
It's a full cross platform IDE,
works the same way on
all desktop platforms
and has support for Qt projects.
And, we also know a lot
of people who are using it
purely for C++ projects.
They're not even using
Qt, but they're using
Qt Creator as their IDE
because it gives them
the cross platform aspect of things.
As said, lots of things in there,
code editing, compiling.
You know now with the latest releases,
we have added support so
that you know we're running,
we're basically giving
you immediately inside
the source code and compiler
warnings and errors.
So you see that, and you
can see that for example
here, this is Qt Creator,
the current version running.
If I go here for example,
you don't see that.
I need to get out of the
presentation for a second.
Here we go.
Is that working?
No, it's not.
Problem with the second screen.
Sorry, it's doesn't seems to work.
Let's stay with this one.
But, you have in line code editing there,
and in line warnings and error messages.
So that's a little bit it.
I can at least show you a
screenshot of Qt creator,
a little bit older version where you see
the code editor, you
know project management.
You see the debugging panes.
All of that and everything you need.
Okay so much for a very
quick and rough overview
over what Qt is.
But, let's go a little
bit back into history
actually to be exactly,
let's go 26 years back.
Let's go back to a park
bench in Trondheim, Norway.
That's where it all started actually.
There were two you know
students at the University
at Trondheim called Eirik
Chambe-Eng and Haavard Nord,
and they were actually
working there on their thesis
in 1991, 1990 and had to
develop a graphical application
at that point for Unix
and for the Macintosh,
the early version.
And, they got extremely
frustrated with what they could
find there in terms of tooling and help.
On Unix it was X11.
There were Athena widgets, Motif,
and they tried using that and felt like
you know this can't
really be the solution.
This is hard to use.
It's very hard to debug work with,
and it just doesn't feel right.
So you know they sat
down on that park bench
at some point, and said okay you know this
is not working.
What we really need is
we need not some C appx.
We need an object oriented
presentation system,
a display system, something that makes
our lives easier that helps us bring
these applications onto the screen.
And, that also a little bit defines what
their real goal there was in the end.
It was about making software
development fun and easy.
That's something you
know that was missing,
at that time, for them.
And, they felt like you
know software development
is really hard.
It's no fun.
You know you get home.
It doesn't fulfill you.
So how can we change that?
How can we make it actually fun and easy
for developers to work with software,
to work with graphical applications
and get those out and get those developed?
And, you know after that
talk, it took a little while.
They were talk a bit
around and sit and that.
And, you see a diagram here that was
from 1993 when they
started you know developing
their ideas a little bit more.
What you see a lot of what made up
you know the first version of Qt
and what they were thinking.
Also, you know a little bit interesting.
You see now where the Q comes from.
The earliest version there
was actually called Quasar.
That was the idea they had for the name.
In addition, there was this
thing that the Q was nice,
and it wasn't taken as a prefix letter
because you know there was
X for the XT widgets, Motif
had its own prefix.
So you know namespaces
didn't exist at that time,
so what do you do?
You pick a letter, and you use that one
and you know occupy
that as your namespace.
That's what happened.
And, it's interesting to see that,
if you look at the design, a lot of things
are still there in Q today.
You have the Q object as the central piece
really smack in the middle there on top,
a meta object that's helping you manage
you know the signal slot mechanism
which is something that
Eirik and Haavard invented
in the times and has been
picked up by many others
afterwards.
Seeing event handling at the bottom,
and on the right hand
side, you see a font,
a painter, colors.
So the basic things you need to build up
a graphical user interfaces.
And, they took that
forward, and in the 1994,
they managed to convince their wives
to sponsor them for awhile
and founded a company
called Troll Tech.
Here you see one of the earliest
versions of the website.
So they were starting off
from the very beginning
which was actually unusual
there by basically marketing
everything through the internet.
You know the World Wide Web
was very new at that time,
so it was actually something
that wasn't quite usual.
They never really sold physical copies
which was the standard
distribution model at that time.
You know if a customer asked for that,
then they went and you
know burned the CD Rom
and shipped it off, but by default,
you know you download the
thing from the internet.
And, that's how this works.
So it was very interesting.
And, in April '96, they actually made
the first sale of a Qt license.
It was the European Space
Agency that purchased
10 licenses to make some
satellite simulation software.
It was pretty interesting.
Actually an interesting
decision and a gutsy decision
by them because Qt wasn't
even at version 1.0
when they did it.
And, Troll Tech had four employees.
Then you know Eirik sat down and had
to make an invoice.
And, he didn't even know how to do that,
so he took an invoice from somewhere else
that he had gotten, copied
it, basically made it
look approximately the same.
Then you know looked at that and said
you know I can't write invoice number one.
That just looks wrong.
So he went over to Haavard and asked him
what should we do?
He said let's put invoice 211 in there.
Sounds like it's a decent
size, and it's a prime number.
That's cool.
(audience laughing)
So that's what they did.
So the first invoice started
actually at number 211.
Then they had a couple more,
but by the end of the year,
they felt like the
numbers looked to small,
so they added a fourth,
you know 1,400 to them
to make it a bit bigger.
Troll Tech sold
internationally from the very,
very beginning.
You know the first eight
customers that the company had
came from eight different countries
and not one of them was from Norway.
It was actually pretty amazing.
It was a good start.
Qt 1.0 was then released also in 1996.
At that point in time you know,
C++ was still pretty early,
so Qt 1.0 worked completely
without templates,
nothing in there.
They had you know specialized
lists for pointers
for integers for three or
four types that they needed,
and that was it.
Also interestingly enough, they started
from the very beginning and released work
cross platform.
The version was working
on Windows, Windows 95
and on Unix, and they released
the Unix version with the
source code out there.
You know nowadays you would
say an Open Source license,
it wouldn't be Open Source
approved license nowadays,
but it was there, and it
was free for everybody
to download and use for
non commercial purposes
which was also in a way
a marketing instrument.
You know because they
were a small company,
no marketing budget, how do
you spread the word, right?
Well give out the source
code, and let's see
what they're currently building up
in the emerging Open Source
community around Linux
will do with it.
And, actually you know something
then magically happened.
In '97, a guy called Matthias Ettrich
actually you know got
fed up with the state
of user interfaces on Linux.
You know at that point in time,
I don't know who of you
remembers that FW VM.
And, you know very old
just window managers.
You could move some windows around on X11,
but you know you didn't
really have a windowing
or desktop like Windows 95 had.
And, he wanted to change that.
And, he said you know
I want to change that.
I want to do a project there.
And, he announced it
as I'm on the new scoop
comp OS Linus Misc at that point in time.
You know the younger ones have never seen
or worked with or seen use groups.
But, they were one way
of communicating things
out there at that time.
And, he basically announced that he wanted
to start that project.
And, you know some codes
from there where he said
I want to use that Qt framework.
I want to use Qt for it.
Since a few weeks, a really
great new widget library
is available free source and price
for free software development.
Check it out at www.troll.no.
The stuff is called Qt
and is really a revolution
in programming X.
It's almost complete,
fully C++ widget library.
And, it implements a
slightly improved Motif look
and feel or switchable
during startup Windows 95.
Good stuff.
And, you know he started that.
He managed to attract
quite a lot of people
especially in Germany
at that point in time.
And, they started working on it.
And, you know half a year later, they had
the first version of KDE up and running,
a desktop for Linux, fantastic.
And, it was actually a revolution.
In some respects, actually
it was a lot more rough
around the edges, and it's not as complete
as maybe Windows 95 was, but it started
providing something.
You know it had a panel down
there, something to launch
graphical tasks, control
center, help browser.
It had a browser, file manager.
So the basics were there.
And, it started picking up greatly.
Lots of people started you know using it
and extending it.
An Open Source community formed around it.
And, if you look at it in hindsight,
you know this is probably
why Qt really took off,
became successful and why
we're still here today
using the framework.
1999 then, you know that was a little bit
after I became a user of Qt
which was in '98 approximately.
Troll Tech released Qt version 2.0.
And, they found out you know
we did some larger changes
there, biggest one was
we move over to Unicode.
We have 16 bit strings,
and that was all that was
required for Unicode
at that point in time.
And, they changed the
license to GPL, had a first
version on embedded Linux
running on the framebuffer.
And, on the business side
then, you know Troll Tech
you know received the first
round of venture capital
funding.
So within a year from end
of '99 to end of 2000,
the number of employees grew from
around you know a handful to around 50.
So large growth.
That's also when I started
working from Troll Tech
at that point in time
as a software engineer
working mainly on
internationalization, Unicode support,
bi-directional texts, complex text layout.
That was my initial stuff
where I worked a lot on.
And, got started you know actually moved
to Norway for that job
and got stuck there.
We soon also saw the need that you could
easily create user interfaces with C++,
but you had to all stuck it together.
You know and define in C++
how the look should be,
how you arrange your widgets.
You know whether that line
edit is on top of the button
or below, to the left, to the right using
a mechanism they had in
there that was flexible
called layouts.
But, you know many people
said this is tedious work.
I want to see it
graphically, and I don't want
to have to recompile
before I can see it again.
So we worked on a first version
of what we called Qt
Designer, the UI designer
to help you there.
And, that's probably a slightly
later screenshot of it.
But, it's something where
you can graphically put
your user interface together.
And, then you know later on
use that in your C++ projects.
Moving forward in history,
Qt 3 came out in 2001.
Little bit of changes there.
In Qt 1 and Qt 2, our string class
was explicitly shared,
figured out that was
a problem for many users.
Many sand boxes came in because people
started modifying that
string, and then it got
modified in a completely different part
of the application as well.
So we moved over and said okay let's move
to implicit sharing
where we basically detach
whenever the string gets modified.
We started using templates more.
You know the compilers
were catching up to C++ 98.
We still had to deal
with Visual Studio 6.0.
Some of you might remember that one
which wasn't very good.
But, we started introducing templates,
value based containers.
We moved and started having a system
where we could upcast
our Qt object hierarchy
to the concrete instance
using Qt object cast
because RTTY was still
in its infancy there,
and it wasn't working
reliably across, for example,
shared library boundaries.
And, we started working on
the Mac and Open Source Qt
for the Mac.
Then you know let's fast
forward a little bit.
In 2005, we moved over
to Qt 4 where we did
a major overhaul of those
template and tool classes.
Many of them in Qt 3
were still you know based
on pointers, so you
had to new every object
that you wanted to stick into a container
leading to larger issues
with memory management,
and other things.
So we moved them to be value based.
And, we made the
implicitly shared classes,
we added atomic ref counting to that.
I'll come back to that
one a little bit later
and talk a bit about that one.
And, as the final thing, we open sourced
then also the Windows version.
That was the last version
we actually open sourced.
Since then, you know everything
has been out in the open.
But, you know we were for a
long time, as a small business,
you know growing.
We needed to get revenue and
not open sourcing Windows
was seen for us as an
insurance that we would get
the customers that we needed to survive.
Things grew further.
We had a lot of things
going on in the Open Source
community with KDE and others.
Also some competing
projects to KDE popping up
with Gnome and lots of
things going back and forth.
But, you know for us things moved forward.
And, then at some point,
you know we actually got
one of these tech giants interested in us.
Nokia was looking at us.
They needed a technology to unify,
(coughing)
I'm sorry, to unify
their different platforms
and have a unified API
for their developers.
They were thinking about okay we need
to have a developer offering.
And, this was still a
little bit before the iPhone
when those decisions were made.
But, they saw they needed
a developer offering
and a unified API so that
they could you know move
from where they were with S40 and Symbian
over to what was, at that point in time,
their long term strategy,
a Linux based stack
called Maemo or MeeGo.
They did a huge investment,
and that was something
that really helped and pushed Qt forward.
You know we were doing
you know the Qt quick UI
technology, for example,
as the first versions.
We had, for the longest time,
you know all of the R and D
and Qt, we wanted to do an IDE.
We said this is cool.
We want to do it.
You know management in
Troll Tech always said
maybe not.
You know there are other IDEs out there.
Why don't we use Eclipse.
There's Visual Studio.
But, we were itching
for it, and we thought
that this is bad because we don't have
a good cross platform IDE and Eclipse was
really not very usable for C++.
So we wanted to do it but
never really had the funding.
With Nokia, we finally had that.
And, we went in and
you know pushed forward
with Qt Creator.
We worked on a WebKit integration
where we you know basically integrated
a browser engine as one of
the frameworks that we offer
to people.
So people could basically
instantiate the browser engine
and use that within their application.
And, Nokia did another thing.
They changed the Open
Source license from GPL
to LGPL making it much freer
and also you know with that,
you know increasing its
use probably 10 fold.
So we got a lot more people to
use Qt through those changes.
But, unfortunately not everything went
as it was supposed to go.
(audience laughing)
In 2011, we had a burning platform.
At least, that's what our CEO
told us at that point in time.
You know we were just about getting ready.
It was a hard fight inside Nokia.
You know you have a big
ship, a huge company.
And, we were trying to
you know bring Qt in there
as the framework for
development both in house
but also for third party users.
We had things ready.
Symbian was there using it.
We had apps going into the Nokia app store
using Qt.
Their nine, MeeGo device was almost out.
But, you know management didn't believe
this could workout and said we had
a burning platform.
We needed to hop off it.
We did.
We hopped over to Window Phone which meant
that Qt actually had no
role inside Nokia anymore
at least not a big one, a minor one.
So for us, this was
clearly a large setback
and something that took
awhile to recover from.
But, it lead ultimately to the fact
that then you know a year later in 2012
we actually separated ways from Nokia
and you know got bought up
by a small Finnish company
called Digia.
At the same time, we
were then also working
towards the current version of Qt, Qt 5
where we did larger changes again.
You know we looked at you know how have we
so far been doing platform integrations.
And, the one thing we learned at Nokia
is that porting Qt to
a new operating system
was extremely difficult.
We didn't have the right
abstractions in place.
And, you know that Symbian port used up
a lot and a lot of manpower.
So we wanted to change that, and we did
a new abstraction underneath that makes
it very easy to port Qt
actually to new architectures
called the Qt platform abstraction.
And, that's the one that
actually also then later on
allowed it for us and made
it relatively easier for us
to then move over to and
implement Android and IOS
support.
Or, you know support for
many different embedded
operating systems.
(coughing)
We also had a lot of work on touch based
user interfaces that started
already during the Nokia times,
and we saw that you
know had a first version
of our technology there.
The need for that one also came
in through different things
where we saw that you
know widgets that we had
as UI technologies so far were very good,
but they were mostly limited
to static user interfaces.
We tried to put animations in there.
For example, we had a
main window framework
where you had dock widgets
and these kinds of things.
And, we tried to make in animated.
So when you move a dock
window and hover it over
a certain place where you
might want to drop it down
to dock into, it would make space there.
And, it would animate
so that you could see
where it would drop.
It took a developer a year
to get that implemented
and was really, really hard
code to maintain afterwards.
So we thought about how
could we do that differently
because our users have the same needs.
That lead us to Qt Quick.
So we moved there.
We brought that forward.
We saw that we needed also here with Qt 5
that we needed to bring that
on top of a GL scene graph
to really get the best
performance out of the hardware.
Because you're doing
animations, you're doing
lots of graphics, it needs to perform.
People expect it to be fluid.
You know fluid animations
like they were seeing
on the iPhone.
And, that's something
we needed to do there.
And, we started having a larger focus
also on the embedded systems
because that's where we
were seeing that you know
there was a lot of demand
for solutions.
People wanted to use you
know C++ on embedded systems.
But, there wasn't any good solution to do
you know user interfaces.
And, during that time, we also
started you know opening up
our development under open governance.
Now from that time onwards,
Qt was being developed
as an Open Source project.
Before, you know we were
working at Troll Tech.
We developed everything
in house, and then we
basically released the final
versions as Open Source.
But I said, I mean we
moved out of from Nokia,
got acquired by a small
Finnish company called Digia
and were there for a couple
of years until we, last year,
split ways with Digia.
And, since then, the Qt company is
a fully independent company
listed on the Helsinki
Stock Exchange.
And, we're focusing fully
now on Qt as a product.
Just now final slide on
business just to give
you an idea, the Qt Company
is we're around 250 employees,
around 150 of those technical.
We have a revenue of 32,000,000 euros
and you know Qt has currently
around 1,000,000 active users.
So it's big.
It's quite a lot.
Okay so much for history,
so much for companies.
Let's move over to something else.
And, a little bit on
the philosophy and how
we are developing Qt,
what we're doing there,
what's important to us.
First thing is we want to empower users
with the technology we have.
And, that goes back to the original thing
that I said with Eirik's
and Haavard's vision
was software development should be fun.
It should be easy.
Make a product that's as
versatile and flexible
as possible, give developers
the tools they need.
Let them be in control.
Make it easy to use Qt.
You know have, for example,
word cluster documentation,
so they can find everything.
But, also try to make it so easy
that they don't really
need the documentation
in the first place.
Give people freedom, you know with Qt.
Freedom to innovate, you know extend Qt,
do things on top of it, you know integrate
with other frameworks from the side.
We don't want to limit anybody how they do
their application, how
they do what they need
to do.
You know if you want to pull
in a third party library,
you know do that.
So make it easy to integrate
with other technology
and also you know as
a freedom don't attach
any strings to our product.
Use it as you like.
And, from our point of
view also the freedom
nowadays is also that we are independent.
You know most of the development is done
through the Qt Company, a small company.
We are independent.
We have no afflation with
any of the major tech giants
meaning you know our
agenda is really helping
our users and nothing else there.
Continue with Open Source.
As said, we've always been Open Source,
and we'll continue doing that.
All our development is in the open,
and you know the development is done
on Qt project it's a meritocracy,
so anybody who has an
interest and wants to
can gain influence.
They can become involved,
you know gain influence,
maybe also become an approver for changes,
start reviewing other people's changes,
can become a maintainer
for a certain area.
So that's very good.
It also allows our users and our customers
to see exactly what we're developing.
You know we're not hiding anything.
You can follow every change.
You can get blame on it.
You know what's happened.
You know who's responsible.
You can contact the developer and see
you know why did he do that.
I'm having a problem
with this piece of code.
All of that is possible.
Here you can see a little
bit of the statistics
on Qt project and the contributions.
So you see that you know the percentage
of commits and where they come from,
from which companies.
So you see that the
majority is still coming
from the Qt Company, but
then there's other companies.
And, you have a large set
going up of smaller people,
individuals contributing.
This also has changed over time.
Some years ago, we had you
know a lot of contributions
from Black Berry.
Those have a little bit died
down 'cause they don't have
a mobile phone anymore, or
a mobile OS of their own.
So things are changing.
New people are coming in,
but it's going forward,
and it allows people to really
contribute their own things.
Cross platform, as I said,
is also extremely important,
and it'll stay that.
We want to be available on all major OSes,
and we want to make sure that
when the operating systems
change that you know our
users don't have to worry
too much about that.
We're taking that work of porting Qt
to new operating system for you.
Also Qt is a horizontal
framework and offering,
and that works across different things.
I said we had an embedded version.
So we're working from very
small embedded devices
like you know this car instrument cluster
implemented on IMX six.
You know to large desktop systems,
what you see here is Autodesk Maya.
They're using Qt for their tooling.
They actually even have
a developer community
or their own around it that also uses Qt.
So their exposing plugin
interfaces where people can
in Qt write their own plugins to Maya
and plug them into their framework.
And, we have also large
distributed systems
like some of the European
air traffic control systems
that are also using Qt.
So whenever you fly to
Europe, think about that.
(audience laughing)
I hope you're not getting scared about.
API design concepts, you
know what's important for us
when we design our APIs.
The thing that's most important for us,
and we have a slightly
different focus probably
than what you see in
the standards committee
and with the C++ standard library.
You know for us, we see
that code is written once,
but it's read and modified many times.
This goes back a little bit
to the you know programming
versus engineering that you
heard from Titus on Tuesday.
You know most of our users are not doing
throwaway code.
If they have a code, they
need to maintain that
over many years and
read it again and again
and modify it again and again.
How can we make that easy?
Because the maintenance is
the larger part of the work.
It's more work than the
initial development.
And, we all know that we're lazy.
We rarely comment our code.
So how can we make code self documenting?
So what we want really is APIs that lead
to readable and maintainable code.
They should be intuitive
and self documenting.
That means we need to
have descriptive naming.
We are going and if we can
for property based APIs.
We want to hide as much
complexity as possible
in the Qt implementation
and don't expose it
to our users.
And, we want to remove the
need for boiler plate code
as much as possible.
The APIs should also be
easy to learn and to use.
You know we're trying to
implement or are always
one concept per class or per method.
That API should do one thing
and should do that well.
I can tell you we're
not perfect with that.
We have our own dark corners
where we're violating
everyone of these
principles I'm naming here.
But at least, we're trying,
and I think for the most used
parts of Qt, we're actually
pretty good at that.
We're going with consistent naming.
You know same name for the same concept
throughout all of Qt like
a static polymorphism.
We have, for example, the Qstring class
and the QByteArray class.
They're doing similar things.
One is an eight bit byte array.
QString is a Unicode string.
But, still you still have
things where you want
to find sub strings in
there, do other things.
You want to maybe
uppercase, lowercase things.
So we name those methods the same way.
And, we do that through all of Qt
and try to be as consistent
as we can with that.
Aiming and striving for
clear and simple semantics
that don't surprise anybody.
And, you know trying to
make it so that you can do
a lot with a class without
having to learn a lot.
Ideally, you rarely have to
look up in the documentation
or learn things there.
You can just look at the code completion.
Okay these are the methods I can use.
Go with that.
Make them hard to misuse.
Our defaults should match
the intuitively expected
behavior from our users.
Don't surprise them.
So that makes it then
easy and natural to write
correct code, and it does encourage
good programming practices.
We also don't want to fail
if methods that should be
independent of each other are
called in different order.
They shouldn't have subtle
or hidden side effects.
We want to avoid implicit conversions.
We've seen that as a big problem.
And, we try to not do any magic.
Stuff we've all been doing
in the past ourselves.
And, of course don't
fail three codes later
when you do something that's wrong.
Qt APIs are supposed to
be flexible and cover
the common use case.
We have a 90/10 rule that we say
where you know the 90%
use case is what 90%
of the users want to do with that class.
And, that should be as easy
to implement as possible
using the class or the set of classes
that we provide, and
then should be extensible
so the remaining 10% of the use cases
which go beyond that, they
have to be possible still
but maybe they require
a little bit more work.
Performance.
This is one thing where we
deviate also from what you know
from the standard libraries.
I mean you know one thing
you know the committee
and then the C++ standards
are very agreeing
is you don't pay for what
you don't use, right?
We're deviating a little bit from that.
We say of course we want to ensure
as good performance as
possible on all parts
of the framework, but we also say
we don't want to
complicate the default APIs
for performance reasons.
Less readable code implicitly
leads to more bugs.
It leads to longer development cycles,
you know it takes longer to
get your product to market
and most of our customers
actually have time pressure.
They need to get the product out.
They have limited resources, so they want
to get the product to market fast.
And, as you all know,
95% of your code base
is not necessarily performance sensitive.
So if it's a couple of percents lower,
it doesn't really matter at all.
And, we're seeing that users will use
complex API often the wrong ways.
So a simple API does
actually on the user side
often lead to more performant code
even though they could do it even better
if they had more complex API.
But, then they would probably use it wrong
and it wouldn't work anyway.
But, we do as much as possible of course
go the extra mile to create APIs
both as fast and as simple as possible.
And, where we require
you know offer low level
access to optimize critical paths.
But, we want to really
keep it simple as I said.
You know and make it easy
also for new and intermediate
developers.
C++ has a very steep learning curve
that makes it often a little bit hard
to get started for new
people especially you know
if you have a student
coming from university,
he's worked with Java.
You can bet on that they will for example
pass objects by value to
functions 'cause that's what
you do.
And, we're seeing that
a lot of the projects
don't only have C++ goals.
If they're lucky, they have
one who really knows C++
inside and out and can really
help with these things.
Often they don't have anybody.
So C++ is complex, but you
know most of the complexity
is only rarely required for people.
You know you would
rarely see an application
developer fiddling with
template meta programing.
Usually it doesn't happen.
They will shy away from that.
And, with that, you can
make 99% of the code
self explaining and easy to write.
The other thing is that code, as I said,
often lives a lot longer
than originally planned.
There's code that was written
for these kind of machines
that's still running you know
in business critical parts
of systems today usually using an emulator
of the old machines,
but it's still running.
And, I've seen that myself.
When I was doing my PhD
thesis, you know I was working
actually in physics at
a facility in Heidelberg
with an accelerator.
And, the controlling software
was written for PDP 11,
you know 1970s type of computer.
And, yeah in '99 when I did that one,
that was 25 years later,
it was still running that.
And, they had problems because
that machine broke down,
so they needed to put it onto an emulator.
And, it was running way too
fast because it was depending
on timing loops, and
they had to do all sorts
of crazy things to get that working.
So the software's often
running really long,
and we need to make sure
that people you know can't
live without, they can bring the software
into the next decade.
And, we know that computers are changing.
In '95, you had desktop computers,
that was the main thing.
You had some workstations,
and you had high end things.
Nowadays, you know all
of us, we have you know
much more powerful computers
just in our pocket.
And, people want to develop
for those computers,
for mobile devices, and for
lots of embedded devices.
So for us, it's important
that we isolate our users
from those platform changes.
And, we do that by bringing
Qt to new platforms
but also by providing stable APIs.
We are striving to have source
and binary compatibility
you know within major versions,
and from one major version
to the next, we do need
that from time to time.
Every five to seven
years, we've been moving
from one major version to the next one.
We need to do that to keep Qt alive,
to take new concepts and
to clean up old things
that actually don't make sense anymore.
But, we still always need to make sure
that we have a good path for our users
to move with us forward and minimize
the API breakages there.
A lot of that can also be avoided if we
from the get-go do a lot of work to make
the APIs as good as we possibly can.
Okay, let's have a look at implementation.
What are we doing there?
Well clear naming is one thing.
We don't use any abbreviations
for function names.
We prefer typing them out.
Your code editor can
help you and offer you
the completion, so you
don't have to type it all.
And, it leads to much more readable code
afterwards which makes
it easier to maintain.
No boolean arguments for example we use
enums instead whenever we can.
And, we make sure that
each method does one thing
but does that one well.
And, it's orthogonal.
I'll show you an example of one thing
that we had wrong in Qt 3.
We had a find method in our QString class.
Who of you has an idea
what the false there means?
(audience member responding)
Case sensitivity, yes,
but it's not obvious.
And, is it obvious what
the method returns?
Not quite neither.
Does it return an iterator?
Does it return an index into the string?
Does it return actually the found string?
You don't know.
Have to look up.
If you look it up and you
look up the declaration,
you find that.
You find it returns an
integer, so probably an index.
And, the bool is the case sensitivity.
In Qt 4, we changed that.
And, we said no, this is not a good API.
We want API that's intuitively readable.
When everybody who reads
that for the first time
even if he doesn't know
Qt, knows what it does.
So we changed the API to indexOf,
so you know it returns an
index inside the string.
And, we changed the
boolean flag to be an enum,
case insensitive or case sensitive.
Much easier, and suddenly,
the code become readable.
And, you don't need to
look this one up anymore
to know what exactly is going on.
We also moved over to
more property based API.
And, we're doing that
especially for our high level
graphical objects wherever possible
because it's a very intuitive model,
and you don't enforce any
specific initialization order.
You have defined default values.
You can query those properties,
and they're orthogonal
to each other usually.
Also here now an example,
a bad one from Qt 3.
You instantiate a Qslider
basically a GUI control
to slide you know between two values.
Now I'd be surprised
if anybody really knew
out of their head what all
of those parameters mean.
I don't.
So after that we changed.
And, in Qt 4 and Qt 5,
this is how it looks like.
We say we create a new slider.
Okay Qt vertical, we can put
that into the constructor
because it's easy to understand.
We're setting the range.
We're setting the current
value, and we're setting
an object name.
And, suddenly the code becomes readable.
And, anybody who comes in
and you know has to go in
to fix something in
that code base, sees it
for the first time, can
actually work with that one,
and knows what it does
without having to look up
documentation.
Or, even if you look up the documentation
of that slider constructor
with five, six arguments,
you still have to count to
see which one does what.
QObject, the base for most of
our more complex Qt classes.
I mean this one's
actually also interesting.
It's pointer based.
So you create them on the heap.
They're designed for sub-classing.
You can't copy them.
And, that was something
that was introduced
in the very beginning already with Qt.
We have a memory management where we use
a parent/child relationship, and that maps
very well to graphical stuff.
You have a widget on the screen,
and inside that you place other widgets
like you know a button and
line edit and other things.
And, usually you know
when you want to get rid
of that whole you know widget again,
you just want to delete the outermost one,
everything else is supposed
to go away with it.
And, that's something that we did there.
You can't have circular references,
so it makes for a very simply
memory management model.
And, that was even before
you know we had things
like smart pointers or
anything like that in C++.
We have signals and slots in there,
really important for encapsulating.
Those objects make them more independent,
loosely coupled, so it can connect
you know a signal from one object
to any slot from another object.
You know the slot will get called
whenever the signal gets triggered.
Properties and support
for runtime introspection
are other things we added
there because we needed
them for many different things.
And, they fell out from themselves
out of the Qt support
for signals and slots.
I said signals and slots
facilitate coupling.
It's one of those places which
removes a lot of glue code
that you used to have otherwise.
The type-safe, you know if
one object gets deleted,
connections get disconnected.
So it's really safe and something that was
really first deployed in Qt.
I know that there are quite
a few other frameworks
now to do the same thing.
There's boost signals for example.
But, one of the things that we still have
is that they're also
thread safe, and they work
across threads.
So what you can do is
you can connect objects
from different threads with each other.
And, you know inside
threads you'll have a direct
connection usually meaning
a direct function call
between threads.
We'll just post the thing
over to the other thread,
and it's more like a message passing.
But, it makes for a very easy inter thread
communication mechanism and a safe one.
Here's an example.
You might have seen that one.
We have the QObject macro.
That's the one thing we
need in there to implement
our magic.
It's also what identifies that QObject
for the meta object compiler.
I'll come to that one in a minute.
We have properties.
We have signals and slots.
Very simple and also very readable.
And, you're seeing that
we're extending C++
to some extent, and
that's one of the things
that people have been
in the past criticized.
I mean we have signals and we have slots
as keywords here.
Nowadays, usually we have
to write our header files
using an ugly Q underscore signals and Q
underscore slots macros.
But, you can still write them this way
if you so choose, and it
makes for more readable code.
It's also, as I said, one of our goals,
keep the code readable.
It can connect.
We've had, you know in the old times,
connect system where
basically things were done
string based, so signal
and slot were just macros
that basically converted
the argument to a string.
And, you know then they were passed
into the connect function
which looked those up.
As I said, you know we were
generating introspection
information.
We could resolve from a name.
We could resolve from a function pointer
that we needed to call or connect with.
In Qt 5 now, we also
have type-safe connects
using modern syntax you know like that.
Or, you can also connect of
course to lambdas these days.
And, I said there's different
types of connections.
You can make them direct,
you can make them queued
so that control returns to the event loop
and the event loop then
at some point notifies
the slot, and you can make them automatic
which means direct, you know
if you're in the same thread,
queued if it's between threads.
One of the questions I'm
always getting is why are
we using the moc.
You know the moc is the
Qt meta object compiler
which actually passes our
header files and generates
the data we need to be able to implement
the signal slot and the property system.
It emits that meta data.
It emits introspection information.
And, the big advantage
we're having using it
as opposed to, for example, a mechanism
that doesn't use that is that we do have
dynamic introspection
information at runtime available.
We can look up a method by name.
We can look up properties
and enums by name.
We can convert between
a string representation
of an enum and its value back and forth.
We can invoke methods.
And, you know at least
if you're using, at least
if you're using a decent build system,
if you're using Cmake,
if you're using Qmake,
moc is completely
invisible to the developer.
You don't ever see it actually.
The build system will take
care of mocing the files
it needs to moc.
It will take care of compiling
the generated C++ files
and link them into the finally binary.
So that's fine.
It doesn't really cost us
a whole lot to have that
available, and it really simplifies usage
and makes a lot of things
like what I'll come later to,
the Qt quick technology for
user interfaces possible.
Value classes is the second set of classes
that we have.
You know most of Qt low level
classes are value classes.
Like we have rects,
font, Qstring, Qvector.
Mainly data structures with methods.
There's no virtual
methods, and ideally they
should have been marked final.
Only when we implemented
them, we didn't have
a final keyword available unfortunately.
And, adding it afterwards is difficult
because some people were
actually inheriting from them
for good or for bad reasons,
but they're doing it.
They're primitive or implicitly shared.
And, our implicit sharing
uses atomic ref counting.
I'll get to that.
So primitive, you know that one.
A point, you have an X
and a Y, and you have
setters and getters.
Nothing spectacular here to see.
I mean those are some of our classes.
And, then we have
implicitly shared classes
like for example our font.
The way we implement those is that we have
you know put all our data
into what we call a D pointer.
They're hidden in a private header file
giving us much more freedom to
add and remove data members.
And, whenever you set
something, the implicit sharing
looks at the ref count,
does a detach, i.e.
copies the data if the
ref count is not one
and then sets it.
Simple mechanism.
Noteworthy, you know
people have been asking us,
but isn't that expensive?
You know we're using atomic ref counting
and these kind of things.
Yes, there is a little
bit of an overhead we pay,
but we see that in most
cases this doesn't matter.
I mean there's usually not a
contention on that cache line.
Checking whether the ref
count does not equals one
is something we can do non-atomically.
Because if it is, we want to
know if the ref count is one.
If it's one, we are the only user.
So we can do that load non-atomically.
So the only atomic
operations we need to do
is the increment and the decrement on copy
or on destruction.
The advantage we're
having is that they behave
really almost exactly
like primitive types.
They have copy semantics.
They're easy and fast to copy.
So you know the mistake
that many of our users do
is pass these kinds of objects by value
especially when they
come from a non C++ world
and not by const reference.
And, with that, I mean the things get
actually a lot cheaper.
And, they're thread safe even
if the data behind is shared.
I can create a copy of
a vector, hand that copy
over to another thread, and
as long as the data is shared,
you know we can still use them together.
So that's great.
There's a little bit of
problems also of course.
You know there's a bit of
a performance overhead.
We have slightly different
iteration semantics
because they could detach when
you use non const iterators
and range-for can also be problematic
because it can detach.
That's something that got added in C++ 11
after we had all of those available.
Another large part of what
we have been doing in Qt
is filling gaps in the standard libraries.
And, you know for largest
time that was also needed
because there was nothing
happening on the standard
evolvement.
QString, C++ still doesn't
have any real Unicode support.
I think that's a huge gap,
and it's actually something
where we're lacking out to
many, many other frameworks
or many other programming
languages that have that built in.
Locale handling, date, time zone handling,
for the largest time before
C++ 11, we were using
atomic instructions.
C++ didn't really have anything.
Threading was also just posix threading.
So we were doing our own stuff there
even though nowadays we
could move over and use
the C++ classes.
But, the classes are there.
They're widely used.
So removing them is also not that easy.
We're file handling, IO and networking.
I know that's also coming now.
And, of course graphics where
you know the C++ otherwise
doesn't really offer anything.
And, let's move over to that one,
creating user interfaces.
Two offerings we have, I talked
about a little bit about before.
We have the widgets
which are C++ controlls
so that you can use and create.
And, we have the Qt Quick UI technology
to create more animated
touch based user interfaces.
Q widgets.
Here's the simple Hello
World example there.
Nothing special.
Many of you have been using Qt, so you've
been probably writing those
lines in one way or another.
Now we create an application.
We create a label with hello world.
We show it, and you know
let the event loop run.
We have the graphical designer.
I showed that one before of Qt widgets.
So making it easy to put those together.
And, then of course we have
Qt Quick as a technology
which we have been developing
over the last years.
And, that is something
where we you know do
user interface design
in a declarative way.
It's written in a
language that we call QML.
It's not C++.
We'll get to that, but you know you still
write more of your application
logic in C++ in Qt natively,
and you just hook the UI up to that.
So the UI is actually supposed to be
a very thin layer on top of that.
And, we've seen people doing it wrong
and doing everything up
there on the QML level
because you do have some
Javascript support in there.
It's often you know it doesn't lead
to the best designs or
the best performance.
So it's a declarative language to define
user interfaces.
Actually objects in QML
are all QObjects underneath
in the C++ world.
It's very easy there to
create bindings to properties.
And, we have some automatic
dependency tracking in there
so that bindings always stay up to date.
I'll show you that in a second.
States and transitions and
animations are supported
and built in, so it's very easy to create
animated user interfaces and animations.
And, you can easily bind
it to C++, Javascript,
and integrate custom C++ types of course.
And, on the right hand side here, you see
a simple example of a
Hello World in Qt Quick.
Of course you need the
C++ type to instantiate
that Qt Quick object still.
But, other than that you
know you have a text element
showing hello world.
And, I put in MouseArea in there that
allows you to click that
text, and we would then quit
the application, very
simple straight forward.
Why are we doing and using QML?
As said, I mean it has you know built in
and represents the visible structure
of the user interface in a good way
because it's a visual tree as well.
And, you can do that and show
that with minimal syntax.
We have property bindings
in there so you know you
can write foo, you know some property
like the width, column, some expression,
and we'll make sure that
you know the relationship
between the property and
the expression always stays
up to date.
So if anything on the
right hand side changes,
the property value will
always get updated.
So automatic dependency tracking
and reevaluation of those properties.
That's very important
because it makes it easy
to write something without glue code.
It's very easy to write.
You don't need glue code,
and it's actually also
that's another thing it's
friendly for UX designers.
Here you also see a
little bit of a screenshot
that's some controls
that are also available.
So you have ready made buttons and sliders
and whatever you need also
available at your fingertips
there for creating user interfaces.
Can easily integrate C++ and QML,
so you know you create
a QObject basically.
You can create properties on that object.
Important is here, oh I
forgot that actually you
also have a notification
when the property changes
and the size change signal.
So whenever the size
changes, you should emit
that signal as well.
And, then you can have a
slot like rectangle clicked.
And, you can basically instantiate that,
instantiate the Qt quick
view, instantiate that object
and set that object as a context property
what we call it with giving
it a name on the view.
And, with that, you can then
use that on the QML side.
So we have the Rect.qml, and we bind there
the width of the rectangle to what we had
on the C++ side, my object
and the size property
of that one.
So whenever that one
changes on the C++ side,
the width on the QML side will
get updated automatically.
And, we have you know again a MouseArea,
and if that one gets clicked, we call back
into C++, the slot in C++.
So you get the call back in
C++ and can work your way
from there.
That's how we can very easily
integrate the two sides.
Also on Qt Quick we
have a designer similar
to the one that we had for widgets.
And, it's where you can put
together your user interface
in a graphical fashion
where it's integrated
and easy to use.
And, you have also there a separation
between the presentation
and the logic of the user
interface.
Okay, let's move over a
little bit into the outlook
and the future.
Currently 5.9 is the current release.
I haven't gone into
what's in there really.
If you're interested, look it up.
Currently, we're up and have 5.9.2.
The interesting piece is
that 5.9 is what we call
a long term supported release.
We will support it for
three years to come.
That's probably interesting for you guys.
If you start anything new, that's the one
you want to use.
We're having a six months release cycle
where every six months we
have a new feature release.
We have of course path
level releases in between.
5.10 is currently in feature freeze.
We'll have a beta soon and the
final hopefully in November.
And, 5.11 May, 5.12
probably November next year.
And, that's probably going
to be the next candidate
for long term supported release.
And, that's as far as sort
of you know the release
train goes.
I'm not going to go
too much into what kind
of features we have in there.
Just a little bit of
where our focus areas are,
one of them is graphics.
What we've seen in the
past, I mean a couple
of years ago when we
went to Qt 5, we thought
okay OpenGL is the thing.
You know we're having that
pretty much everywhere.
Yeah well it turns out things changed,
and you know suddenly you
know the Khronos Group
came up with, or actually AMD
first came up with something
with Mantle, then you
know Apple started pushing
for their own graphics API called Metal,
then the Khronos Group
came up with Vulkan.
Windows, Microsoft's you know Direct3D 12,
and we also still have to
support software rasterization
some places.
So we have a big amount
of different graphics APIs
that people might be using.
And, you know how do we abstract those
is a big research project
that we currently have.
And, you know the solution
there is really you know
to provide a scene graph
that you can use together
and abstract it on a higher level,
so you talk about materials.
You talk about meshes,
these kind of things,
and have support for that.
We already have some support for different
graphics backends in Qt
Quick and for our 3D APIs
called Qt 3D.
We have a lot of research
ongoing how we can
integrate that.
We have one problem though
that you know because
we thought OpenGL is the
thing and we can use it
everywhere, we've exposed
a couple of those directly
in Qt 5.
And, we'll need to figure
out how to deal with that.
Our problem, fortunately
we'll find a solution.
We have a lot of general
work that were ongoing.
You know we improve performance,
reduce memory consumption
all over Qt is always an ongoing process.
Looking into you know speech support,
we're seeing that this is
requested a lot by customers.
They want to control also
their graphical applications
with speech.
How do we integrate
with digital assistants
that are currently coming everywhere?
What do we do you know
on the graphics side,
on the 3D side with the augmented reality,
virtual reality?
How do we integrate things there?
There's a lot happening,
so that's going to be
important for us.
And, of course also you
know a lot of things
happening on the IDE side.
We're doing more and more
work on code refactoring,
making that easier.
But, then we have a big project
also where you know we see
that there are more and more
companies that you know do
the software in C++,
but they need a solution
for the graphics designers
to work with the software
engineers in a good way, an easy way.
This default workflow is
that the graphics designer
works in Photoshop,
creates lots of things,
creates some sketches, sends
that over to the developer.
The developer tries to implement it,
doesn't get it quite right.
It doesn't perform because
on the embedded device
for example because
hardware's not powerful enough
to actually implement or
support what the designer's
thought of.
Then it goes back to the designer.
You have very long development
cycles because of that.
So integrating designers in that workflow
and making them, enabling
them to work directly on,
for example, the target
hardware with the real product
is something that's
important, and that we'll be
putting quite a bit of effort into it.
And, you know things like
graphical asset conditioning
and other things that are
important in that space as well.
Okay on the C++ side,
we're using since 5.7,
we're using C++ 11 fully inside Qt.
Not quite fully, I have
to say because we still
have to support Visual Studio 2013,
and that one has problems
with, for example,
constant expressions,
but as much as we can.
And, we want to start
using 14 and 17 features
as much as we can as well
because it would simplify
coding inside Qt, make
our maintenance easier.
We're currently still
limited by many of our users
using older compilers.
So that'll come, but we're
usually living a little bit
behind the bleeding edge there.
But, we're already doing certain things.
We're using has include for example.
We're using the deprecated
faults with attribute
annotations, hiding them behind macros
which expand to nothing
in case the compiler
doesn't support it.
We've added a String View class similar
to standard String View
but working on a QString
and make other things that
help that we integrate
as good as we can with
the upcoming standards.
I think the one that's
going to be really important
for us is then C++ 20.
That could become really interesting.
Concepts for better
diagnostics and error messages,
I know that a lot of our users
are struggling with those.
Having modules, you know
we would really need those
for our code models in
the IDE for compile times.
But, we do need, so that's
something to remember,
we do need some sort of
macro support in there.
And, I know that some people
don't want that in modules.
We'll need it, otherwise
we can't use them.
Now to which level is
a different discussion,
and that's something we can have.
And, I'm really looking forward to having
a reflection and also the
hooks, meta-programming
things come somewhere
closer to a standard.
And, it would be fantastic if we could get
at least some sort of
subsets, some first start
of that one into the next
version of the standard
because I mean honestly
I would love to get rid
of our meta object compiler
of moc in the long term
if we can do it.
And, I would really love
us to reduce the need
for template meta-programming a lot.
So with that, here's
the Qt logos that we had
over the history.
We've evolved a little bit, flat.
And, that's the one we have currently.
And, with that, I'd like
to conclude my talk.
Thank you very much for your attention,
and I think we have a couple
of minutes for questions
at least I hope so.
Thank you very much.
(audience clapping)
- [Audience Member] Thank
you for the talk, Lars.
I have a question about the subject
that you probably didn't cover.
What about the security of Qt?
- Security, yes.
I have a focus on that of course.
We're trying to make sure you know we have
code reviews.
We do a lot of work trying to make sure
that we find any issues.
I've had actually a good
chat here with a person
from Google about you know fuzzing.
That was you, right?
And, these are things we have.
We have a security mailing list,
and we do get relatively few issues.
I have to say that, but
we do get them from time
to time, and we handle them
of course with you know
quickly, so we have a policy there.
You know closed mailing
list for security issues,
trying to handle them,
and we then also you know
disclose them with security advisories
and you know patches and updates.
Please.
- [Audience Member] Is it
pronounce Q, T or cute?
- That's a good question.
So everybody inside Europe says cute
at least from our side.
I know that in the US
that Q, T is externally
the more prevalent pronunciation,
but we're saying cute usually
from everybody who works
in the company and everybody
who works with it closest,
so all the contributors.
I think that's the going
name that we're going for.
- [Audience Member] Thank you.
- First of all, I'd like to give
credit to Qt for QML
which works really slick.
Also, I'd like to give credit
for you being brave enough
to tell C++ community that
two, 3% may not differ
in performance, maybe brave.
But, I have a question.
I program in Qt daily and
sometimes I feel like the Qt
and C++ are different,
they're diverging somehow.
And, being a C++ programmer
feels different than being
a Qt programmer.
What are your thoughts
on this for the future?
Like you have Q vector,
a lot of duplicates,
like these to merge or somehow?
- Ideally yes.
There's a couple of
issues that I'm seeing.
First of all, I mean the obvious one
there's lots of people out there using
the existing classes.
You know you can't just
you know throw those away
and tell everybody to port over.
There's a lot of work
involved and most people
don't want to invest
that work unless we offer
a very good migration path.
Secondly, there's a couple of
classes where we do believe
that you know we offer a
better and easier to use API.
And, yes it does feel
different sometimes a bit.
But, I mean C++ still doesn't
have any you know I mean
we've been asked to give up
QString because why not use
standard string.
First of all, that one's eight bit.
Okay we could UTF-8 in
there, but it doesn't have
any of the Unicode functionality,
uppercasing, lowercasing,
anything you need.
So we can't really give that one up.
Now the main question comes
around some of our containers
classes, vector, lists,
and hashes, and others.
- [Audience Member] And so on.
- And, there it is a valid question.
I mean from my point of
view, I'm always saying
you know use the ones that suit you best.
There's some advantages
with using, for example
a QVector because of the
implicit sharing it's very cheap
to basically you know take a copy, move it
to a secondary thread, that copy.
If you take a copy with
a vector, even though
that other copy only
need read only access,
you're still copying all the data.
So depending on your use
case, one or the other
might make more sense.
But, I think it's fair to just use both
and use whatever suits you best.
- [Audience Member] Thank you.
- Sure.
- My question goes in the same direction.
When will we get rid of
the only raw pointers
that we have right now in Qt in the API
and that should frankly be
replaced by smart pointers
or something else?
- Again, the problem is a
problem of compatibility.
How much you know do you
break of your users codes?
I mean there's you know
probably billions of lines
of code out there with Qt.
How much of those lines
do we want to break?
So ideally, you know we
need to find strategies
to offer transitions.
You know methods for people to transition
to non raw pointers.
That said, I mean even
if we you know sometimes
we return raw pointers,
you can always put them
into a smart pointer
or something like that
on your side, right?
A unique pointer.
- Yes and no, but usually
you create an object,
you do that directly in the smart pointer,
then you hand it to some
Qt API that re-parents it.
And, then like between
the line where I called
the Qt API and where I can
like reset my smart pointer,
there is an area where
it basically two objects
own the same thing, and
that should not happen.
And, there's no way around
that problem right now.
- [Lars] Unless you take
it out of the smart pointer
beforehand yes.
- Yeah but then you have
the area where nothing owns
it before it.
- Yeah I see the problem.
As I said, it comes from the history.
And, it's not an easy one to solve.
We'll have discussions
over that, but don't expect
any very quick fix for that
because it probably also
would involve breaking
certain APIs that we're
currently having.
It's something that we have
to be cautious about at least.
- If your code is Open Source,
where does the company's
income come from?
- As I said, we have a
dual licensing model.
We offer Qt both under Open
Source licensing terms,
you know LGPL and GPL, and
under a commercial license.
People can come to us, they
can buy that one from us,
they get commercial support.
There's a lot less strings attached to it
than with the Open Source version.
Because LGPL and GPL also still give you
some obligations that you have to follow,
and not everybody might
like those obligations.
So the model behind that one is saying
that with the Open Source
version you know you're helping
us expand the ecosystem.
If you don't want to do that, you can buy
a commercial version,
and with that one fund
the further development of the product.
- [Man In Baseball Cap] Okay, thank you.
- You're welcome.
Okay, over there.
- [Audience Member] You were here first.
- Okay, go ahead.
- So it's basically a follow
up on the question before.
The main reason I think
there's a lot of pointers
involved in Qt is that the
QObject inherited stuff
doesn't have move operations.
I mean yeah in C++ 17 the problem
a little bit goes away,
but right now you can't
really return QObjects
or the real type of them
by value from functions.
So you have to allocate them on the heap,
pass around pointers everywhere.
- [Lars] That's correct.
- Still plans to change
that like move semantics
because it makes sense
to move objects around.
I can understand it doesn't make sense
to copy objects that have connections
to some other stuff because no one knows
what should happen to the connections,
but if you move it around,
I don't see the problem.
- Well it might actually.
Thing is if we look at the implementation
we're anyway hiding all the
data behind the D pointer.
In principle, if I was to
design this anew nowadays,
all of those would actually probably get
some more value semantics.
But, you know we've designed
this more than 20 years ago.
So we'll have to somehow
deal with the heritage.
It could be a possibility
to see whether we can
provide move semantics.
That might be possible.
I need to look into it.
- It's definitely possible
because I've implemented
several wrappers around
QObjects that do the moving,
but for now I can only
do it non-generically
because I'm not part of
the meta object compiler.
So I have to know the signals and slots
that the object has to do the remapping
of the signals.
- That's a little bit the problem.
If we move it, we'd need to change
some of the internals to basically hold
the private data pointer.
That one is never moved anyway.
Then those things could be easier.
- [Man In Stripped Shirt]
Yeah, but are there plans
to do that?
- Nothing concrete.
But, it's an Open Source project.
If you have good ideas how to do that,
you know more than welcome
to get yourself involved.
- [Man In Stripped Shirt] Yeah, thanks.
- Sure.
- I have sort of a two
part question, comment
about where you answered with the QString.
Do you actually have benchmarks that show
that the copy on write model is better
especially in the contest
of GUIs where the strings
are supper short and cheap to copy?
Because it seems like to me that the lock
would be way more expensive.
- There is no lock.
- [Man In Purple Shirt]
Well if it's copy on write.
- It's an atomic operation
that we're doing.
And, in most cases, I mean
it's an atomic increment
for the copy.
We have done some benchmarks.
And, for very short
strings, I agree with you.
You know copying them would be faster.
The problem is we didn't know those.
But, we have some work
in progress patches.
I know that one of our developers, Tiago,
he has a patch for us
which is for short string
optimizations where we would
basically you know don't even
allocated a D pointer and
basically just copy them
all the time for short strings.
So we have that somewhere.
It would break binary compatibility.
That's why the stuff hasn't landed yet.
- And, you know the argument
for the Qt containers
that keeps coming up
is the Unicode support
in QString, I believe
there is a standard string
compatible working Unicode
support in CS string
which is probably going to be standardized
at some point.
Is that something you
guys would get behind?
- CS string is Qstring.
I mean CopperSpice forked
from Qt and basically used
QString and made it a CS string.
- [Man In Purple Shirt] But,
it's got the standard string
interface, so you don't
have the divergence
of communities over.
- It can't have just the
standard string interface
because standard string
doesn't offer you many
of the other things.
At least, the most important methods
from standard string, I think we do have.
And, if they're still
not there, we can discuss
filling them in.
But, you do need more than that, right?
You do need case conversions.
You do need many other
things that you know you want
to have from Unicode.
- Yeah, but I mean okay
you could patch in,
like the case conversions,
at least in my opinion
even things like finding within a string
shouldn't be part of the
public interface of the string,
they should be free functions anyway.
So I don't really see them missing
in the public interface of that object
to be an argument against it.
- [Lars] Once again.
- Well you're arguing
that the public interface
of standard string isn't rich enough
to express everything in QString.
Or, what is the argument
against interface compatible?
- I'm saying you know we can probably make
it compatible, but we will need extensions
on top of what the standard
interface of standard string is.
- [Man In Purple Shirt]
But, the way to do that is
free functions anyway.
- It might not be a problem.
I'm just saying it can't
just be the standard
string interface.
- Yeah, but the point is it
seems like it's a conscious
divergence between the Qt community
and the standard, you know
the rest of us C++ guys.
It's a divergence that had
evolved over the years, right,
over many years.
Some of them has been
in the past conscious
because we were looking at
when we did, for example,
Qt 4 APIs and trying to really find
you know good and intuitive
APIs as I discussed earlier.
We have been then also
adding a lot of you know
things that are compatible
with the standard classes
to make them more
compatible with each other.
But, it's also difficult to now go in
and say now we just you know move over
to whatever the standard has and we move
everything we've had so far because we
so much code out there.
So it's not an easy thing to solve.
I mean you can't just say
why don't you just move over
and then I would start using Qt.
But, you shouldn't forget
that there's, as I said,
there's a huge amount of users out there
whose code we would break
if we move those methods.
- Yeah, but you've broken a lot of stuff
in a lot of versions.
From Qt 4 to five very, very little.
One place where we broke a lot of things
was from Qt 3 to Qt 4.
That was in 2005.
- Yeah, but most of those was getting rid
of singletons, so it's okay.
- So you know usage
has, you know multiplied
since then.
Okay.
- Hi, great talk.
I just had a quick question.
You alluded or kind of
gave us a brief overview
that the Qt team is looking into using
other graphical I guess
languages or frameworks.
I was hoping you can
tell us a little bit more
about the research you
guys have been doing.
And, just maybe if one of the frameworks
lends itself easier to
be used underneath Qt
or just any insight into that.
- Well I mean we're talking about
the 3D APIs that are being
pushed by different vendors.
I mean Apple pushing Metal.
Khronos pushing Vulkan,
Microsoft Direct3D 12.
The problem with all of those
is that they're targeted
mainly at game developers
to a large degree.
They're very low level APIs which means
you have to build up a lot
of stuff on top of them.
And, that is quite a bit of work.
I mean there's nothing
fundamental that's you know
keeping us from supporting them.
We have, for example,
done for the Qt Quick
scene graph we have a
backend for Direct3D.
Nowadays, it's not 100%
functionally equivalent
to the OpenGL one, but it's very close.
And, we're doing more research there.
It's a question to some extent
of finding the right
abstractions and defining those.
And, then the other part is just work
to implement that.
And, they have been spreading
so far so many different
APIs, so you know it's a lot of work
to support them all.
So we're doing things in stages as we see
you know the needs from our users.
- [Man In Jacket] Thanks.
- Sure.
Okay, thank you everybody.
(audience clapping)
- Bash films can shoot your
event with multiple cameras,
link to presentation slides, add titles,
and edit your event live for
a full broadcast experience.
- How is this even working?
So this is actually a
more interesting program
to you know look at in a lot of ways.
So let's profile it.
Do a little bit of time
to do a profile for us.
I'll see exactly what
it is that's making this
faster or slower based
on the different inputs.
I mean you could really
gain a lot of insight
by actually looking at
the profile like this.
- I worked at Sesame Street.
I got brought on to be
a writer's assistant
on a show called Sesame Street English
which was to teach English
to kids in China and Japan.
It seems very simple, the
shows they put together,
but it's actually really
hard to design a show
that is not only for young
kids but also the parents.
- Confession like this is therapeutic.
I hope you all get something out of this,
but if you don't, the
therapy will have been good
for me, so thank you.
(laughing)
Seven years ago, I
wasn't working at Google.
I was working for my previous employer
which was a large
multinational investment bank.
I had what was up to
that point the worst day
of my career.
- And, then came the anger.
Anger at ourselves because we knew
we were responsible for
America's first space disaster.
We wrote two more words
into our vocabulary
as mission controllers,
tough and competent.
Tough, meaning we will never again shirk
from our responsibilities
because we're forever accountable
for what we do.
Competent, we'll never again
take anything for granted.
We'll never stop learning.
From now on, the teams in Mission Control
will be perfect because as
a team, we must never fail.
- One other thing, we're all
in a very fortunate position.
We've been very lucky in
our lives and so forth.
And, I think as part of the mission,
it's also good sometimes
to take that fortune
and give back,
(clapping)
to make sure that we take
this platform and use it
towards worthy causes.
That's good karma.
That's good stuff in the universe.
- We understand that your
event will have needs
that are specific to your organization.
Please email or call
us directly to discuss
your particular event.
We look forward to discussing your goals
and helping make your event a success.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>