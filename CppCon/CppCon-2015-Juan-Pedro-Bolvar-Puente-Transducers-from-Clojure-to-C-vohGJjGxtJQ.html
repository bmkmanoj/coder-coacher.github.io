<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Juan Pedro Bolívar Puente “Transducers: from Clojure to C++&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Juan Pedro Bolívar Puente “Transducers: from Clojure to C++&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Juan Pedro Bolívar Puente “Transducers: from Clojure to C++&quot;</b></h2><h5 class="post__date">2015-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vohGJjGxtJQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hello welcome everyone my name is
Pompeii I worked for Ableton which is
berlin-based music software company and
at Ableton we made an implementation in
C++ of transducers that I would like to
show here but before I start I would
like to thank everyone for being here in
this room in spite of all the spam that
we got about the static analysis session
but I have two good news for you the
first one is that we're going to talk
about functional programming which to
paraphrase some parent in a way tries to
eliminate incidental code structures so
hopefully by leveraging the tools
presented today we can read some better
about correctness of our code and don't
need to resort to proprietary static
analysis tools second good news is that
everything that's presented here today
is based on an implementation and that
we made that is open source so you are
really welcome and encouraged to study
the code to modify to improve it and to
share it with others so let's get
started and first talk about what is a
transducer which is a funny word that I
don't know because it's a little bit of
what the
situation when you say I'm going to what
are you going to talk about in this
conference about transducers and then
people go and look on the look it up on
the internet and they get definitions
like this in Wikipedia that says like a
transducer is a device that converts one
form of energy to another like I don't
know it's going to convert my chakras or
clean up my Karma and if you look for
pictures then you get pictures of
devices that I have no clue what they
are for probably sure that maybe there
are some electrical engineers here that
know not me
so what is this right what is a
transducer in the context of programming
and in the context of programming the
first person that I know of that use
this term is rich Hickey who is the main
author or original author of closure the
programming
which is a lisp based or at least the
derivative that runs on the JVM on the
Java Virtual Machine he introduced
transducers in the latest version of the
language which came I think March or May
this year and he did so when researching
how to unify the way he operated or he
described transformations on collections
and the way he described transformations
on channels we will come back to this
later
then last summer when we first saw the
blog post from rich geeky about Ableton
we were very impressed about the
possibilities of this and we were
working at Ableton in a research project
where one of the topics that we were
working on was trying to be able to
describe the data model of an
application in this case music
applications in a way that is
declarative that leverages the reactive
functional programming paradigms and so
forth this project is not going on
anymore but a lot of the code that we
developed is now under this library
called atria the URL is here it will
come back later and it will be shared
with with the slides at the end so what
is a transducer one of the most simple
transducers that we can implement is
this and if we want to define a
transducer we could say that a transfer
a transducer is a transformation over a
sequential process we will come back
later to the sequential process part but
we can what we can see here is that we
have a call to something called map and
we pass to this a lambda that describes
a mapping between integers and strings
right and this represents something very
similar to the map function that you
have languages like Python closure
haskell and whatnot in c++ we will call
it transform but there are some
differences in the parameters you see
and so forth but the important thing to
get here is that it's a transformation
but it's a transformation that is also a
value and this is not obvious or
immediate in C++ because in C++ not
everything is a value but transducers
are a value so the transformation that
is described by the
sort of this map thing can be stored in
a variable and can be copied around it's
actually it can be a regular value can
be passed around and so forth it's a
value that it's also composable so you
can use this transformation that you
have here as a value and take other
transformations that are described in
other parts of the program and compose
them together to make a more complex
transformation in this case we compose
the mapping that we showed before with a
filtering of the indicators that let
pass only the integers that are greater
than zero and we compose them with a
comp function here this come function
actually the name comes from closure and
is nothing more than function
composition so this also tells us that a
trans user is just a function so another
important thing and probably the most
important thing about transducers is
that they are transformations that are
independent of the source and
independent of the process that is
putting the values in type inside the
transformation assume some of you may
have noticed and like in the cost to
transform filter and so on of the STL
here there is no sequence parameter and
this is so because transducers they
don't have information of what they are
transforming that comes later in another
part of the program and actually these
transformations can be multiple so one
way to apply to our concrete
transformation will be this our library
provides for example this sequence
function the sequence function takes a
transducer is in this case the XS that
we have here and it takes a second
parameter which will be a range in this
case it could be a vector of intz that
we can deduce for this from the
signatures here that is the input of the
transformation now what this returns is
another range that acts as an adapter
that applies the transformation on the
iterators lazily basically every time
you run through the iterator you are
applying the rate the transformation and
you can use it with a standard STL
algorithms now so you could for example
compo copy the resulting strings of
applying this transformation
into another container for example yes
yes they can we will come back to that
later another way to apply the
transducer for example if you wanted to
I don't know use the standard input and
output you can compose it with these two
other transducers read that whenever it
gets a pulse and we will come back to
this notion of pulse later reads from
the standard input in this case integers
and these are the one that just quests
to the standard ample output and this
run will basically execute the
transducer until there is nothing else
to be done and as we can see here in a
very different context we also using the
transducer to in this case transform
output coming from and to files but the
most interesting use case of transducers
is that you cannot have applied only to
data that you have already available and
that you can pull which is what you
normally do with iterators right that's
a pull model you can also apply to push
models so probably many of you already
have used boost signals how many of you
have used it already okay great so as
you know both signals it's like a
general implementation of the observer
pattern of the delegate pattern so you
have this boosts signal here that has a
signature in this case it's a signal
that takes things and the ideas that you
can connect to it and later admit it and
many you can have many observers many
functions that are observing on it and
kind of respond to this integer it's
very useful to model for example UI
events like for example mouse clicks
right so you could have a function like
this actually having one of the examples
this is not provided in the library
because I didn't want to depend on whose
signal but one of the examples actually
provide how to write such a make signal
function where you take a boost signal
and a transducer and what you get here
is another boost signal that in this
case will have the signature both a
silly-string
because this transformation
puts STD strings so now we can connect
to this second signal and when we omit
the first thing signal the second signal
first it might get emitted yes or no or
even more times depending on what the
transformation we have in this case
because we're filtering integers
critters by greater than zero when we
pass 41 it actually passes the 41 ohm
which gets converted to a string and the
string get passed to the listeners when
we pass a minus 10 to the first signal
it will actually not call the second
signal right so you can see maybe with
this code already how it's useful it can
be useful to have this transformation
expressed in a way that you can use in
all this various context and it's very
important to what I already said about
sequential processes which is this word
that we use that transducers transform
sequential processes are not gas ranges
even though in many of the examples that
we will show through the code because
it's very easy it's to express ranges in
C++ we will use ranges you can do it to
to many kind of processes this processes
can be ranges as we already saw all
right but one very useful example and
that's why we wanted to do like the
clarity of reactive programming with
this library is for example GUI events
right so when you click the mouse the
mouse is a source of input that is one
single source of input and when you
click it you get an event then you click
it again you get another event so there
is a sequence here it's a sequence that
happens in time that the abstraction of
the transducer because it's kind of a
push model actually allows us to
transform this sequence CSP channels so
this is concurrent sequential processes
the language closure and many languages
now also like goal or rest include this
notion of inter process communication
that doesn't use mutable state so you
have these channels when one process
pushes data and the other date the other
channel sorry the other process pulls
data from it if you wanted to be able to
connect processes with different
interfaces you can use the transducer in
the middle to kind of adapt the kind of
channel that one is expecting to the one
that the
one is expecting network sockets could
be another example of something that is
a sequence right so once you have a
socket you have a stream of data that is
that is also following a push model
because the data comes from the Internet
as the other computer is sending it and
you could also transform it with the
transducer these are just examples
actually you can probably think of your
own
so one metaphor that I like to use to
think about trans users is machines in a
in an industrial processing line like
this one right so here we have a machine
that takes as inputs these kind of pasta
slices and these creepy red sauce and it
says Folsom together to produce
something that it's maybe like a
cannelloni or whatever this machine here
which is if you're familiar with it with
functional programming is something like
a sip anything that is doing it doesn't
care about where the past time the sauce
come from right they could come from
different places
it just takes it as they come and then
produces the cannelloni and moves it
forward right it doesn't return a value
which is different to how we think
normally about doing a transformation in
C++ we return something here in the
transducer you call the next one you
pass it over right you have some outputs
that way a movie that I really like is
modern times which is this critique on
current or on the Industrial Revolution
and the dehumanizing effects of the
Industrial Revolution which gives us
lots of gifts that are useful to
describe transistors in this case we
have this transducer here that takes
plates of food so it could be like a
vector or an array of pieces of food and
this is very similar to a cut reducer
that takes a collection and then passes
the individual pieces of the collection
along to the next transformation in the
transducer which in this case is Charlie
Chaplin it could be a human transducer
that transforms food into poop so this
human transducer then can be combined
with different transformations right it
doesn't have to be combined always with
this cutting thing it can be combined
with
with a soup dispenser but we have to be
careful we are talking about C++
compiler error errors can be harmful
okay so now we know think enough about
what's the concept behind the transducer
it's time to talk about how does this
work how does the transducer do all this
magic so to try to deduce kind of the
concept of transducer rich Hickey the
inventor of it uses this sentence which
I really like which is that a transducer
tries to extract the essence of map and
filter and by looking at map and filter
at the traditional implementations in a
functional language of map and filter
you can look at the commonalities and
try to from 8 extract the essence of a
transducer let's do this derivation
process because we're in a C++
conference in C++
it actually works the same way that that
rich Hickey does it for closure here we
have a very simple implementation of the
transform function which is the
equivalent for map in functional
languages in the STL and transform
function takes two input iterators that
describe a range which is something that
we want to transform that's our inputs
and produces into this output iterator a
sequence which is the same as this one
but transformed with the values
transformed through this mapping and the
mapping here is a fang right the way
this work is well it's very trivial
right we just loop over it and then we
apply the function to every element and
store it in the iterator and increment a
traitor
at the end we return the final state of
the iterator if we look at filter it's
very similar the signature instead of of
a mapping what it takes it's a predicate
so the element be in the collection or
should it not and what it does is
actually very similar but instead of
projecting the values of the collection
with the mapping
where it simply does is to say it should
I put the element or not with a
predicate we can see commonalities here
right the blue parts of this shell or
this loop is the same in the two
functions so we could think about how
can we extract this there is another
part that is common which is the way
they are doing the output right so there
is something essential to the mapping
and the filtering that is happened that
it's not definitely out putting things
into another collection and it's not is
it is neither iterating over a
collection let's get rid of the blue
part first with accumulate accumulate
it's a function of the standard library
that is in the header numeric and a bit
sad that it's in the header numeric
because it's in a way the most generic
algorithm you have in the standard
library and it's in this header where it
looks like you can use it only for I
don't know summing things which is what
the typical example in which you use it
but actually this function is basically
more general than map and filter it's a
more general way to iterate sequentially
over a collection right because the
signature of this function what it takes
is again to iterators the sequence over
which we want to iterate but then what
we do over the sequence is totally
abstracted there is a state that is
often called accumulator as well I might
use the two words interchangeably which
is well the state of the computation
that we're doing over the sequence and
then there is the second parameter this
fourth parameter here which is the
readiest
reducing function reducing function
comes from the fact that this function
in closure is called reduced in Haskell
is called fold and we call this the
reducing function oftentimes I will call
it just a step because it's simpler and
this is what we do inside of the loop
and inside of the loop the only thing we
do is to say well a stop function I give
you the input I give you your current
state you give me the next state right
it's a very functional way of thinking
about transforming the collection in C++
normally you don't deal with state in
this way you have local variables for
that mutable local variables but here
the step function can actually perform a
computation with mutable state in an
abstract sense without
mutable state in the concrete sense
because it just takes the state as an
argument and returns it a new value
which is country the next state the
other part the red part we can also
abstract and we can abstract as a
reducing function for accumulate this
reducing function here will allows us to
output something into an iterator what's
the state well the state is the current
position in the output iterator it's
gonna take one increment it and return
another one and then what it does with
the input is to copy it in the current
position in the output iterator
if we combine these two functions if I
simply pass here the step function what
do I get I get copy right I get the
equivalent of STD copy so we can as well
grab instead this output RF into two
simple lambdas to get transform and
filter as we see here
so transform we'll just call the output
or sorry the step function for the
transform implementation
we'll just call the output a step
function it passes the current state it
actually doesn't even need to know this
thing with the current state it it's
actually an output iterator but this
thing doesn't know the output at the
output step doesn't know but what this
does know is that it needs to map the
inputs through the mapping the filter is
simple it's similar sorry it's simple as
well why not it just in every step what
it does is to look with the predicate at
the input if the input passes the
predicate then it passes it along to the
output a step function if it doesn't
pass the predicate well it still needs
to return something it returns the
current state which will have the fact
of not increment in the
the output iterator and so on and so on
right well it's what to find sorry it
was defined in the previous slide so
it's it's this one here right this
lambda here that takes an output
iterator the input and just outputs and
increments so the last thing that we
have hard-coded here is yeah this output
our RF here this is not essential to map
and filter so how do we abstract this we
can abstract it like this so this will
be finally our implementation of the map
transducer the map transducer we could
use it actually to do exactly the same
that we will do with transform but just
using the building blocks that we built
in the previous slides like this
how does this work because I mean it's
like three levels of lambdas this is not
typical C++ code let's look at what
happens to step by step so the outermost
point of this expression here is this
call to map right this call to map what
is doing simply is capturing the mapping
function so it's a Fang was the mapping
function that we were passing to trans
to transform it just captures it
somewhere in this variable so we can use
it later in the other lambdas now we
come to the red part this red part is
what we will normally call transducer
actually and this transducer what it
does simply is to capture the red are
reducing function that we pass as a
parameter in this case the output RF the
thing that actually outputs to iterator
to iterators and keeps it in the scope
what it does then is it returns another
step function this with this step
function that it returns is what it's
finally passed to accumulate to do its
job and inside this a step function it
just adds something very similar to what
we did in the step slide in the previous
list but using the parameters that we
have available through these captures
right so it calls the mapping over the
current inputs passing it to the next
step function that when bound like this
is going to be output
but it could be something else right
that's how we get the independence of
the process and the composition and
finally returns the state for filter
it's exactly the same structure we have
in the outermost layer capturing the
arguments capturing the parameters in
this case it's a function it could be
actually an integral for example if
you're implementing something like take
it could be nothing actually some
transducers don't even have this layer
we will see some later then in the next
layer we bind it to another reducing
function and finally return another
reducing function which is the one that
is going to do all the work with all the
parameters that we captured along the
way so just to be clear because I've
used many term mini terms here what is
what the reducing function what is the
reducing function reducing function is
what we pass to reduce what we pass to
accumulate it's something that takes a
state and some inputs as a parameter in
here we see some the reducing functions
that we see are here the parameter to
the transducer and the result of the
transducer right and we are calling the
one that is cropped as a parameter
inside the transducers once the
transducer the transducer is again a
function that takes a reducing function
as parameter and returns another one and
builds chains in this way the state also
known as accumulator is the first
argument of the reducing functions and
the transducers normally don't make
assumptions of what's in the state it's
simply something that pertains or is in
the domain of the particular computation
that we are doing in the most nested to
decent function like for output it was
an iterator it could be something else
right and finally we have some inputs
which is the argument of the reducing
function that the transducer builds
that's what I will call sometimes these
are the inputs of this transition of
this transducer this transducer takes
this kind of inputs that's because the
reducing function that the transducer
produce takes these inputs and then what
are the outputs of the transducer the
outputs of the transducers is not what
the
functions return the outputs of the
transducer is what the transducer passes
to the next reducing function right
that's what one could call the output of
the transducer so we decompose all this
now we can say mmm smells like essence
of map and filter right smells so good
lavender so one thing to note here
though is especially for the ones that
are already used to functional
programming what happens when you
compose transducers as we saw in the
introductory slides and we can show it
again here if I wanted to make a
function that filters and maps sequences
I could do so but by simply composing
the two transducers before passing the
output RF but here if I want to filter
before mapping filter goes before map
that might be a bit unusual if you used
to in Haskell you know you will compose
it the other way around you compose on
the right side the filter and then the
map but this is because the transducers
they don't directly transform the
collection the transducers they are kind
of factories for the actual reducing
functions so yeah they are building
these layers and and that's why the
outermost layer has to be the first one
yeah so to see an example of this again
we can expand the previous expression so
if we expand the composition what we get
is that we pass the output of F to the
result of the map and all these to the
result of the filter and to see how this
layering works is like we can
conceptually think of we're building a
function right it's like we're writing
code when we are composing transducers
in the innermost part of the function we
have the output RF now we pass it to the
map and we are like in the function
going one line before and saying well
now the inputs are actually the inputs
mapped this is actually so the code
because well the types wouldn't match
and so forth but but you can imagine
this right like we are simply saying
okay the inputs are mapped and with the
filtering what we're doing is adding a
knife around it so this is how the
layering works the the transducers are
kind of taking a step function and
changing the code by basically grabbing
it and grabbing it and grabbing in its
second onion all right so first thing
before we continue also is to know that
in Adria in our library we use the
closures nomenclature I think this makes
it a bit more easier to relate to a lot
of what's written already about trans
users in the Internet so we will not use
the word accumulate anymore we're going
to use the word reduce and the
signatures change a little bit so our
reduce takes the step function first
then it takes the initial State and then
takes ranges not not iterate or
separator it takes ranges then there is
this transduce function and transduce is
basically a very thin wrapper around
reduce that takes a step function and
the transformations separate then there
are utility functions like for example
in - that takes the transducer some
ranges and copies into this collection
passes for our first argument the
content of the ranges transformed with
trans future there is into vector which
reduces the type of the resulting vector
because you should be using vectors most
of the time in your life and that is
stuff like sequence which does things
lazily instead okay so let's talk about
some more advanced topics on how to use
transducers how our how our
implementation works as well the first
thing to know is that transducers are
very attic and some of you might have
already noticed actually that when I
implemented map and filter there were
these ellipses next to the inputs right
because the inputs could be of any
number so actually
unlike in closure because in closure
they overload the RET of the reducing
function for different purposes we used
a different design that allows us
actually to have even transducers of ret
Syria where the reducing function only
takes a state takes no input I mean this
is very nice if you have like some other
source of input you can use it to
generate values so if you wanted to
generate an infinite sequence of random
values you could just do something like
this right
so the ret of this transducer we have to
talk when we talk about the arity of the
transducer we have to talk about the
inputs and the outputs because the
outputs can also be multiple right so
this will be it has like zero inputs and
multiple outputs a zero input is what I
call a pulls this pulls will be
generated here by iterating over the
sequence whenever you do the plus plus
iterator you're kind of calling the
transducer this generates a pulse which
is a calling to the iterator that passes
no arguments but then they sorry in the
transducer that passes no arguments but
then the transducer might generate stuff
then we have transducers which are what
we saw already in the other slides that
take one argument so map in this case we
have one collection and we transfuse it
with a plus operation and this
transducer which just multiplies
everything by 2 the result is going to
be here the sum of all these elements
multiplied by 2 then I thing here is
that unlike if you used STL transform or
something this is going to be applied on
the fly as we get the Sun right there is
no internal value that you need to
compute for the whole vector but there
are also transducers that take multiple
arguments and our operations over
collections are like this if you make
operations over boost signals you could
also have ways to transform multiple
bulls both signals or whatever here we
have two vectors of different lengths
and into vector can for example
transform the two collections
sipping every pair of elements with the
operation plus so it would generate
another vector that contains 4.3 s first
element 4.2 a second element 4.1 as
third element and then it wouldn't
contain any more elements because they
are not not more elements in the second
collection if we wanted to simply
generate tuples actually we can pass the
identity transducer I mean into vector
when it gets multiple inputs in the last
step of the transaction will actually
sit into into a table so the identity
here is actually the normal identity
function for functional programming
languages it's a it's a function that
takes an argument and returns the same
argument that cetera once you say right
you take a step function you return the
same step function you did nothing to it
but you you're within the contract there
are other transducers actually that even
generate more inputs than they take so
for example here we have this mapping
that this mapping takes no input is
again a generator and it produces tuples
with three random numbers now unzip here
what it's going to do is to take the
three elements of the tupple and pass
them as three inputs to the next
iterator sorry to the next transducer
the next transducer here is a filter and
as you can see it already sees the three
elements of the table as different
arguments and you can do something like
say well they have to be in increasing
order and then here we use a different
transducer which is called interleaf
which what it does is it takes the three
things that come in parallel and put
some cereal so this might be something
that you want to do other okay but we
can see here this is a more complicated
example to illustrate like how
transducers actually can like take less
arguments produce more arguments and
then this one is actually going to take
three arguments but produce three
different outputs
right in one single step so it's very
flexible in this regard but now that we
get to I think one of my favorite topics
which is state how to do state inside a
transducer we saw already actually the
mapping with one random actually has
stayed wet has to be local state that's
not very nice already but let's look at
a more concrete example of how we would
like to do this with enumerate enumerate
the name comes from the Python function
I also did a lot of Python in my
previous life and in this case you can
use it as a generator so you can use it
just to generate sequences of numbers
but if you use it over other inputs you
can use it simply to tag every element
with the time at which they occur or not
the time but the order in which they are
right so in this case we will get a 0 B
is 1 C is 2 what not it can be very
useful for example actually to create
like a reverse map or something like
that
like how will you implement a numeric
The Closer way actually of doing this if
you look at the closure implementations
will be something that to C++ I will
translate it like this enumerate in that
transducer the first thing that we see
is that it has no arguments right there
is no parameter so we can get rid of the
outermost layer we are directly in the
transducer with a step function and the
other step function and what it does
simply is in the captures of the lambda
it defines a variable which is going to
be the counter its use in C++ 14 things
another disclaimer will use C++ 14 in
the slides but the actual implementation
uses C++ 11 the second disclaimer is
that there is no move in any of the
slides even though you could add some
but I think that move semantics they
just make the
code look very ugly on the slide so it's
an exercise to to add the proper
forwarding and whatnot here so we have
the counter here and then simply on
every step as first input we pass the
current counter and increment the
counter so the next time you call the
reducing function you get the next value
right what's wrong with this I'm gonna
let some cute animals explain it to you
right there is hidden state here it
makes us very sad hidden state mutable
lambdas kill this and in the Ableton
office some people can get really angry
about this you know you don't hide state
right this may be a bit counterintuitive
for a C++ developer right I mean
variable states that's what we always do
but here we're talking about a
functional approach to doing
transformation and we already have a
variable that represents state as a
value that we don't need to mutate right
state goes here in this a state thing
here that that we have that's why we
call it state and we don't call it I
don't know refrigerator state doesn't go
here right the nice thing is that if you
really are able to abstract the state
into the accumulator then you can do
even more powerful things with
transducers you could have transducers
that go back in time because they keep
the state from earlier executions right
like the possibilities are more open
also when with regards to parallelize
and execution and whatnot so we would
like to get rid of this state what's the
solution the solution that we offer in
the libraries this state grabber type we
need a state wrapper because as I said
we cannot really make assumptions about
the state that we get for the next
reducing function right the state that
we get originally is something that only
the next reducing function understand we
don't do anything about it
so the only thing we can do with it is
to attach data to it to put data next to
it so we can use something that is a
little bit like at Apple in this case we
have our own type because we want to
support type aeration and other
operations and whatnot this is basically
a tuple that contains the original state
and some data that we add to it right so
our transducer what it's going to do is
to you know get the state drop it into
more and more of these Russian dolls and
whenever you grab it you add inside the
box your little note with the
information that you need for the next
execution the next time you receive it
you open it you get your information you
pass it along the tag thing we're going
to talk about it later it's basically to
identify that this is your state this is
your type and then you can customize
some behaviors let's look at this new
implementation of enumerate let's see
what happens with the state here so if
we have like a polls because we're
executing it with no inputs and will
compose enumerate with this other kind
of generic state sort of generic
reducing function that we call here step
when we call enumerate for the first
time we get some state that we don't
know anything about it's just a symbol
here we get some state and now what
enumerator is going to try to do is to
get its data and for that our library
provides a state data function now the
state might contain already our data or
not if it doesn't contain our data
already we need to provide a way to
retrieve an initial an initial value and
this is done with this we just return
the current sorry the initial count
which is fixed to 0 so in this case
because it's the first execution there
was nothing here with data this is just
going to return the 0 then we also need
to ungroup it because this is a state
grabber thingy step doesn't understand
the state's state grabbers it
understands something else
so we need to unwrap it finally we can
call the next step function with the
uncraft state we also Pat in this case
the zero because that's the input that
we're generating and then when it
returns step did something with the
inputs but now it's giving us back some
state of its own type which is this
rhombus here what we need to do now is
to grab it we use the state grab
function and in this case we need to put
the next element that we want to to emit
so M plus 1 right so we just put it in
this box this is a representation for
the state grabber containing the state
that the step needs on our state finally
we return this right the next time we
execute then enumerate again this is
called we unwrap everything but now when
we unwrap it what happens we already
have a box so this function doesn't get
called instead we get the data that we
already have in there we get the data
and that's going to be the input that we
pass along we also get some state that
step returned we pass it along
it returns we wrap it with the next
count which will be the two and so forth
and so forth right so in this way you
could also imagine actually that this is
step if it was another enumerate it
could also be returning a state wrappers
and whatnot actually we don't care right
at this level you know this composes
through the fact that we actually don't
know we make no assumptions so what
about quadratics yes yeah
no the reason is because if you wanted
to pass or to return like a fat value or
something that you need to do some
computation there it's better if it's
grabbed in a lambda like let's say you
want to return a vector I do it in other
places if it's a lambda it's not even
going to try to construct it or anything
or a random number yeah yeah so it's a
bit more flexible this way but this is
never going to take arguments because
it's an initialization or the arguments
that it can use come from the other
layers right yes no it's actually there
is not an optional it's actually the
state and we come to the next slide the
states changes on the first iteration so
this implementation of reduce which I
change the layout a little bit to make
it simpler for the changes I'm going to
do with it but it's very similar to the
accumulate we had right so we have a
first and last thing of some input range
we iterate over it calling the stop
function now what's the problem the
first execution of this loop because I'm
not using an optional or anything the
first execution the type of this is the
rhombus type the second but this is
going to return a state crupper so I can
definitely not assign it to this
variable so this is not going to work
the only thing we can make this work is
by extracting the first iteration of the
loop out in this way we can say in the
first iteration we call the step
function this is going to change the
type we assign this and this is going to
be the type that is already fixed for
the hole reduction then at the very end
we need to unwrap all the layers and
potentially even like I don't know two
more stuff that the state
there are some partial results in the
style in the state or whatever so we
need to complete the state this complete
state is going to return something of
the original type and uncorrupted so
this is the change we need to do here
nonetheless we are not done we created a
problem we created a problem for filter
which I represent here with this
transducer that let's pass on chocolate
but some chocolate it's for itself let's
see what's the pairing with filter
filter now takes again a state and some
input input here is a heart then runs a
predicate on the input if the state is
unwrapped
but it's compared it's it's composed
with enumerate this means that enumerate
if the predicate passes wants to return
something wrapped like this right but if
the predicate doesn't pass we're not
going to get something grabbed from
enumerate with a state so I mean we
could try to make up some data here use
a boost optional as you said but we know
how to make this value the only one that
knows how to make these values enumerate
and we don't want to call it because
otherwise we will be generating an input
that we don't want to generate this is a
problem so we have a utility inside our
library which is call and skip and in
the change you see now that we are
calling the reducing function with this
call wrapper here this whole thing the
only thing is going to do is actually
call a step with as a means escape a
sorry skip skip what it's going to do is
to not call it very simple now what
these two functions here allow us to do
is that they do a little bit of magic
they detect that if you call the step
function and if you don't call it you
will get a different type ordered you
will get the same if you will get the
same they do not
thing but if you will get a different
type then what they return is actually a
union lag type something like a boost
variant or an STD variant when we get it
in the standard or C++ Union a union
that can hold both the result of calling
the step function and the result of not
calling it this way we can have the
filter and filter doesn't need anymore
to make to invent a value of the next
thing it can just return what it has and
it's going to be dropped in this thing
right call another thing that it does is
that when it gets the Union lag value it
also unbox a set to pass the underlying
value to the next producing function so
that's actually they do a little bit so
we covered the problem of state the next
problem we want to deal with is early
termination so sometimes users need to
terminate early the example is take so
take says I want to generate only four
inputs four outputs sorry and after four
things I want to finish so we want this
example to work where I compose
enumerate with this and generate a
generator with take which says it's four
and then pass it to into vector without
any collection here right and it should
be able to finish at some point same
thing here we actually have a collection
here but still we want to finish before
we are done with the other collection
right we want to finish after we have
four elements the wettable implement
take is actually very similar to
enumerate because you also have a count
there is one difference of course which
is that you start and here you can see
another example of how you use the
parameters inside the initial state the
initial state is the count and then from
the count you go down you take one every
step now you will say well this can wrap
around
zero this is country not so nice
actually but there is something new here
which is when we grab the state we pass
attack this is the tag that we saw for
the state crapper
the tag is the tag tag this allows us to
define one operation for take and this
operation is called state grabber data
is reduced and basically what it says is
is my transducer given its current data
is current private data is it done and
in this case it's done with the count
which zero right this is the tag that we
gave now we need to do one last change
then to reduce as well we need to say is
it reduced already right inside the loop
now I'm doing all these examples of how
you execute the step functions with
reduce again reduce exonic is an example
of a sequential process if you were
transducing boost signals you will have
to kind of translate this structure here
to the structure of two signals they're
actually batteries included in the
library to do more things
another example is reduced nested so we
saw there is reduce but reduce cost
complete inside of it
maybe you want to reduce inside a
transducer one example will be cut the
example with Charlie Chaplin getting the
things from the array cut what it does
is it takes a race or vectors
collections and then passes on the
individual elements of the collection it
flattens right or concatenates hence the
name the way to do this it simply it
gets the input the inputs are collection
is a collection it says well what I'm
going to do is to reduce the collection
with the next step function so every
element in this clip in this collection
is going to be passed to the step
function individually now the state
grabbers are important here
so this one needs to return the state
crappers because they contain
information like am I done so to
preserve them there is reduce nested
another utilities Reducto and Reducto
will be something that actually you
could use if you wanted to implement
your boo signal adapter for for trans
users what it does is to provide a more
object-oriented interface to perform a
reduction technique into account all
this is reduced the changing type during
the first iteration and whatnot so it's
parameterize over a reducing function as
state and some inputs and what it
provides is operator parentheses so it's
a function basically but it doesn't take
a state the state is encapsulated into
the object that's why it's an
object-oriented way of doing this and it
just takes the inputs then it provides a
conversion to bool and explicit
conversion to boot to be safe
actually she removed without the inputs
here that's a typo that basically is is
reduced am i don't but negated so you
can do while myra doctor says to I
continue otherwise I stop and then
provides current which returns the
innermost state without the grabbers at
the current moment without completion
and complete which completes the state
and returns so you can imagine how this
could be useful for example if you
wanted to use the boost signal actually
you could directly create one of these
objects and pass it to the post signal
and so on there is another thing that is
provided in the library which is trans
user which is basically STD function for
trans users as you have seen the
transducers are lambda sweet and for
lenders from lambdas from lambdas they
have anonymous types very complicated
types even if you implement them with
templates templates tracks they're gonna
have complicated types because they
compose and their types grow and grow so
if you wanted to do type a ratio the
transducer thing allows you to express
only the inputs as first argument our
motors and the outputs a second
and this back here is just a tag list so
this thing actually that takes integers
and can produces pairs of integers can
be stored in this thing without
expressing the full type it has the
planet that is actually expensive it's
more expensive than you will expect for
an STD function because of the type of
ratio of the state variable but in some
cases it might be what you need it might
be the right solution for your problem
normally I will recommend to try to do
the temperature at a different level in
your system if you can there are lots of
trans users implemented in the library
there is all of the transducers from the
closure standard library are also
provided in our implementation there are
some of what's provided in pythons
itertools
we implemented or reconceptualized as
transducers which can be useful
especially when dealing with collections
and some transducers of our own that
we're not in any of these libraries
Astros users the final thing to talk
about is performance and to talk about
performance I'm going to use the I'm
going to talk about move semantics for
only one time which is here and with
this change what we are doing is to move
the state on every iteration oh sorry
so to come back the problem with this
loop here is that basically on every
step we'll cop in the state right we
need to copy the state into this
function and then it's going to return
the next state if the current state is
for example a vector because we
accumulating everything into a new
vector or something this can be
expensive and we want to support
actually have an expensive state here
because we want to be functional we want
to have all our state in this variable
so the way to solve it is to move it but
we cannot move it directly we have to
move it in two steps and this is because
the standard says that the assignment
the Move assignment operator can assume
no
using this means that basically the
left-hand side cannot be the right-hand
side now the step function if it's an
identity function could be returning us
the same thing as a value reference that
we passed to it and this will break the
rules so the way we do this is this to
stat we create a new variable where we
move into and then we move this variable
into the state this solves the problem
and it's optimized a way in most cases
if you're doing simple operations
anyways now with this change transducers
are fast and that's a good thing about
performance with transducers because if
you use forwarding of your inputs of
your state's and everything it's a chain
where every function doesn't need to
copy anything right everything goes to
the next one
and then it's returned from the next one
and there is no copy in between so
that's good
there are also small functions so there
is a two in line and my experiments show
that clang and GCC they have no much
trouble in line in this kind of
functions of course if you make a
complicated transducer then it's going
to be hard to line but many of them
especially of the most common ones tack
map and filter the really easy to inline
in fact they're so easy to inline that
the simple cases like composing a map
with a filter and passing it to an
accumulate to compute a sum it's going
to be as performant when using
transducer then if you write the for
loop by hand so this is quite cool they
are actually even faster sometimes than
equivalent boost wrench adapters because
the boost wrench adapters are not so
easy to inline because they have a
reference to the next iterate order and
so forth the ugly part is that
typewriter is expensive for transducers
as we discussed for for this transfuse
thing filtering before stateful to
enthuse also adds overhead because of
this Union type that it needs to return
there are alternative designs that I
would like to explore actually that
don't require this Union type a stable
need to try them a measure you can also
use a stateful
I stateful transducer instead with
mutable state if you really need that
performance and adapting as an iterator
this sequence thing that we saw has a
small overhead as well if you compare it
to equivalent boost range adapters and
that's because they this thing needs to
keep a queue
I need a transducer can produce more
inputs than it takes so the only way you
can adapt this into a pool model is to
queuing up all the inputs that you're
getting so finally conclusion very fast
if I want you to remain remember
something about this talk is that a
transducer is a transformation there is
a value that is composable and that is
independent of the process of the
sequential process that it's from for
transforming we have an implementation
in C++ that is pure this is a surprising
result actually that in C++ we could
make a pure implementation where
enclosure actually they could but it
will be very expensive so you never
think about a case where C++ can be more
functional than closure well this one
it's fast as well so it's a very
lightweight abstraction you can use it
in performant code code it's a work in
progress so some of the interfaces are
bound to change I would really like to
hear actually your critique and what
your thoughts are about this and since
we are in a C++ conference with a lot of
people that are in the Standards
Committee I wanted to include this
question because I think this is a very
general construction construction I
think that complements very well all
this new work in boost sorry introducing
ranges and views so I would like to
think could this be somehow eventually
material for a proposal for the standard
in the meantime you can download our
implementation in our github page and
thank you very much for listening
yes yes yeah our functions actually we
take them by universal reference and so
we don't copy them they're also moved
here but I mean you could think of wait
sorry now they're not always moved no
yes okay so when the transducer takes
another one if you personal value
reference it's going to be moved inside
the rocker yes the other one over there
I think we need to finish yeah we're
done okay well thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>