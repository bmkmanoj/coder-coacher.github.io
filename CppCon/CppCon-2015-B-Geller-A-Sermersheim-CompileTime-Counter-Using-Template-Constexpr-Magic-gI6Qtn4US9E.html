<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: B. Geller &amp; A. Sermersheim &quot;Compile-Time Counter Using Template &amp; Constexpr Magic&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: B. Geller &amp; A. Sermersheim &quot;Compile-Time Counter Using Template &amp; Constexpr Magic&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: B. Geller &amp; A. Sermersheim &quot;Compile-Time Counter Using Template &amp; Constexpr Magic&quot;</b></h2><h5 class="post__date">2015-10-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gI6Qtn4US9E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Barbara this is Ansel we've done
copper spice and oxy press what we're
gonna be talking about is compile-time
counters in the process of doing copper
spice what we needed to do was we needed
to do some registration for some meta
type data the problem was how to do this
it isn't practical to actually do all
the code that you need to do and to
write it all by hand so we needed a way
to automate this process so what we came
up with was a way that you actually do
some information and then you chain
everything and in the process so in the
process what we actually want to do is
we want to register some data and some
metadata we want to do that in CS
register 0 and we actually want to
register the data and then call CS
register one we want CS register 1 to do
something and call CS register 2 the
problem is 0 &amp;amp; 1 let's just call 0 &amp;amp; 1
our values they're not data types and
we're trying to use method overloading
so the problem is how do you actually do
this and use method overloading when
these are numeric values and they're not
data types and we put this slide in here
for reference if anybody's unfamiliar
with Const expert one of the things that
we're going to be using in this talk is
contacts / very heavily and it allows
you to set up a value that has evaluated
at compile time so you can use it for
things like the size of an array we'll
be using it in a slightly different
context in a moment so as part of our
solution we had to use templates because
the solution to every complex problem in
C++ involves templates in some fashion
and what we need to do is we need to
somehow have a value wrapped up as a
data type now usually when you're using
a template the reason you're using it is
because you want to pass a data type as
a parameter to some class or
function or method or what have you and
the question is can you pass an integer
as a data type and of course you can
what not as many people realize is that
when you define a template of data type
based on an integral parameter that
results in a unique data type that's
distinct from every other integer that
you could pass to that template of data
type so what we have here is this
template CS int and what we're noticing
here is CS int the N minus 1 so what
this class does is it wraps up an
integer inside a templated class but
more importantly we've set up an
inheritance relationship where 3
inherits from - 2 inherits from one one
inherits from 0 then we've had to
specialize the templated class to stop
the recursion at zero otherwise it would
just continue infinitely into the
negative numbers so what you're looking
at is one too many slides yes so what
we're looking at what we're looking at
here is class ginger this is the
beginning of a class there actually is a
macro in the real code what we've done
is we're showing the expansion here
we've left out some of the details we're
showing the main information and we're
showing this templated method now this
template and Method is what's going to
catch the end of our chain this is a
templated method that's good for any
integer value and it will simply do
nothing the second part of this is we're
declaring a method called CS counter
that takes a wrapped 0 and returns a
wrapped 0 hold on to this line remember
it will use it in a moment notice we're
still at the opening curly so we're
still inside this declaration so now
what we have here is we're assuming that
there's another macro on line 42 and
then a macro on line 43 we're trying to
show just the snippets of code that
actually makes sense
so the first top part is what's expanded
for line 42 the bottom is what's on 43
and the question is
what is the value 42 and what is value
43 anybody care to hazard a guess and
why 42 very good I points for the
reference so there's the static context
fir and we are doing an assignment of
value of 42 there's a deckle type
there's the CS counter so the way that I
like to look at deckle type it in this
particular context we're using an
expression deckle type the way I look at
expression dekho type is it's a
hypothetical statement is if I were to
do this thing at this point in the code
what data type would it evaluate to so
in this case we're saying if I were to
call CS counter with a wrapped 255 what
would I get back and the answer is by
the normal rules for method overloading
it would match the zero and the reason
for that is because 255 inherits from
254 inherits from 253 all the way down
to 0 and therefore you can successfully
call the method that we declared on the
previous slide so value 42 will be 0
then on the following line what we do is
we declare a new overload of the CS
counter method that takes a wrapped one
and returns a wrapped one therefore in
the second half of the slide when we
evaluate value 43 and you'll notice that
value 42 and value 43 are initialized
with exactly the same expression is
exactly the same expression and it is
Const expert however value 43 will get
the value 1 because when the compiler
resolves the overloaded method 255 is
slightly closer to 1 than it is to 0
therefore the overloaded method that
will be found is the one we just
declared that returns a 1 the visibility
this is because it can only look up at
this point it can't look down so it does
compile it does actually work and so
value 43 will be a one now notice in
here that we're doing the same type of a
code when you go to the next slide what
you're gonna see is now we're expanding
what really happened with 42 so again
with 42 we're at a value of zero and
what you can see is in the static void
CS register we're actually calling our
Stata meta object register method that's
where we're actually doing what
registration we've put in some V values
in here we didn't expand all of the
values simply because some of them got
really long and it didn't fit on the
slide but then notice at the end of that
method this is where the chaining will
take place and it will call cs register
passing a1 so now the visibility is that
it's calling something that isn't
defined yet so it's visible below so
that becomes the question if you look at
the two highlighted points on the screen
I mentioned that in the first case the
compiler will only consider for overload
resolution the methods that are already
visible however in the second case down
at the bottom of the screen we are able
to call a method that has not yet been
declared does anybody know why this is
possible the standard defines when a
class is complete and most of us all
know that the end of the curly a class
is complete this is one of the obvious
cases we also talked about that
something is complete between Curly's on
an inline function but there's a couple
of other very obscure exceptions in a
standard and it turns out that those
exceptions work in our favor the first
exception which I'll mention for
completeness is that after the equal
sign that declares a default value for a
parameter of a method the entire class
is considered complete and therefore you
can refer to things that have not yet
been defined the other location where it
is defined to be complete is after the
equal sign of the default initialize
for a non-static Const member variable
and this becomes very important because
if you'll note at the top of the screen
what we have is a static Const member
variable which means in this context at
the top the compiler is not permitted to
look at any methods that are declared
below that line for purposes of
evaluating that deckle type however
inside the method at the bottom of the
screen the compiler can see the entire
class even methods that have not yet
been declared so this is allowing you to
actually create a counter based on
runtime information and allows us to do
a concatenation what this did is it gave
us the ability to set up everything to
have the macros that we established and
it actually went through and set up
everything and then every time we
instantiate a class the registration
happens automatically we don't have to
keep track of the count it was pointed
out to us the value of 255 that is the
clang limitation which can be overridden
by a parameter but the truth is this
code gets optimized in a very amazing
way we actually looked at the assembly
dump on a lot of this
and speaking of clay if you compile this
code with claim my hats off to their
optimization teenies because this code
is compiled and optimized in the most
amazing way possible the entire integer
wrapper disappears all of the overloaded
methods disappear and it tail call
optimized --is all of the CS register
methods together so this is a zero
overhead mechanism for chaining method
calls together in the body of a class
and we believe that this is a useful
technique if you should ever have a need
for it you can actually store a counter
in the overloaded method table of your
compiler and it will work at standards
compliant and C++ 11 and anything later
it still works obviously in GCC there
optimization isn't quite as excellent as
playing but it's still really good in
the GCC implementation all of the
extraneous parts the integer wrapper is
optimized away however it's not quite
smart enough to see through the tail
call nature of these methods so you do
end up with separate registration
methods for each integer not quite as
low overhead but still quite impressive
and just in case anyone's curious copper
spies and doxy press everything is
available off of our website we're
available for questions and - over any
of this code in case anybody wants to
chat with us about it and we hope you'll
take a look at both copper spice and oxy
press thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>