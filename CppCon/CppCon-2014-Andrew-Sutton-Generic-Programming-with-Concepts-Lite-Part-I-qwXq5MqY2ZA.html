<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2014: Andrew Sutton &quot;Generic Programming with Concepts Lite, Part I&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2014: Andrew Sutton &quot;Generic Programming with Concepts Lite, Part I&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2014: Andrew Sutton &quot;Generic Programming with Concepts Lite, Part I&quot;</b></h2><h5 class="post__date">2014-10-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qwXq5MqY2ZA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so talk of the topic of the talk is
generic program with concepts like I
know this is a same talk that I
submitted to ACC you the Association of
C++ users at least the the abstract was
the same and so the title of the talk is
saying but then I felt kind of bad and
they completely rewrote it so this is
definitely a different talk plus it's an
extra hour well actually I guess an
extra half-hour yeah so this talk is not
specifically about a survey of language
features four concepts I mean that's
certainly in there but it's not it's not
the only thing that I actually want to
talk about really what I would I kind of
wanted to do what I was thinking about
how to present this and the fact that I
had no idea of who the audience was
going to be was to present something
that kind of motivated why concepts are
important rather than hey look here's a
fancy new language feature you can do X
Y &amp;amp; Z that's I've done that and it
doesn't seem to click very well connect
very well so I'm going to actually talk
about sort of the motivating problems at
least this hour is gonna be mostly about
motivating problems the next hour that
sounds terrifying to say the next hour
of the talk will focus on more more
about concept stuff actually so you know
for most of this talk actually focuses
on improving improving compiler
Diagnostics or at least that seems that
way because that's really the most
obvious win that we get out of concepts
we don't get gigabytes of error messages
anymore
at least that's it hopefully we don't
but I'm one of the other features that
actually falls out of this is sort of
well better a better support for
directly expressing your intent we don't
have to rely on idioms anymore or some
weird cleverness that shows up in our
programs and then something that would
sort of taken me by surprise but I kind
of knew that we were gonna build this
feature in which is the the overloading
partial specialization support but I
didn't really know it we haven't really
sat down and figured out kind of how
that fits in with the rest of C++ and it
turns out that when you sit down and
think about and you work through these
ideas you actually get a very good
platform for actually defining sort of
an open extension model for for
templates and for functions and classes
and things like that all right so before
we really start I'm going to go through
some some contributions and some
other information concepts this version
of concepts is the result of a
collaboration from these these handsome
dudes
so that's gets me on the top left and
I'm sure you guys recognize the irony
here if you don't know Gabi this is
Gabriel dos Reis he works at Microsoft
now he's actually one of the guys that
kind of pushed me into actually working
out the overloading stuff which turned
out to be a pretty good idea the the the
current state of this is that is it's on
its way to be an ISO technical
specification we have a working draft
last published version is m40 40 you can
probably find a more recent version with
the word missing next to it I didn't
submit an updated version up to last
month conference there will be a new and
updated version of this paper for the
November meeting please do not grab this
paper and assume that it's a very good
introduction to concepts it's not this
is technical wording for the C++
standard it reads badly
it is almost incomprehensible and it
will not teach you anything about
programming or concepts or programming
with concepts that said hopefully we'll
have a PD TSM November depending on how
much time I can actually commit to
rewriting everything that did previously
if you guys do want good overviews of
this stuff there are a couple of papers
I can recommend the first is going to be
n33 5-1 a concept designed to the STL
this is based on a meeting back in Palo
Alto between ICS me and Vienna and Alex
stepping off and Paula Mick Jones and a
bunch of guys from Indiana Martian
Martians a loose ski livery spoof Oh
Sean parent was there basically sat down
we kind of worked out all the concepts
that were going to be in the STL and how
you how we wanted to specify them sort
of a rough sketch of what the language
features should actually be the there
have been a couple of papers on the
actual language feature itself roughly
titled concepts light sometimes with the
colon after it like constraining
templates with predicates the the most
recent overview of that is in 3701
called concepts light so if you guys
have time to dedicate to reading 180
pages of introduction material it's
actually worthwhile please do not as I
have seen go straight to the
specification and then go on to the
proposals list and start making
suggestions about concept design
they will not be appreciated there there
is an implementation based on GCC 4.10
previously the slide slide said 4.9 so
we're following trunk you guys can get
it from here if you have your laptop out
and you have enough bandwidth to
actually go grab GCC and build it from
source during the talk there will be
time to do so
I strongly recommend disabling the boot
strap otherwise you will not be able to
finish feature completeness basically we
do we implement everything that is
actually in this talk with two notable
exceptions both related to some new
features that kind of crept into two
concepts after the last meeting related
to placeholder types but it's it's
actually fairly stable - all the bugs
you'll find but if we had to have users
and we apparently were shipping a high
high frequency trading platform somebody
was insane and decided to write against
it and yeah we have a bunch of academic
products that are actually using this
implementation support so Jason
Merrill's the guy from GCC who's
actually been reviewing all the patches
and he'll be responsible essentially for
the the thumbs up yes or no for when
this gets moved into GCC's trunk which I
think will happen this fall I hope to
talk with him in November because I
think we're actually ready to do that
Braden Ober Zoo is a student at the
university of akron he's 21 and
apparently quite good at adapting
himself to working with GCC he actually
implemented a bunch of stuff four
concepts this summer and if you guys
there's anybody here use GCC how lovely
if you guys if you guys end up using the
new variable template features in GCC he
did the first patch of that and variable
concepts and some other stuff so he's
actually pretty good student and then of
course I have to give a little nod to
Vela butl Annan be the soft-spoken viele
leute alayan and for some if you guys
know him it's clearly a joke he actually
threw a couple of patches against
concepts which which have been helpful
for Diagnostics so finally I have to
tell you there is no library support for
concepts because we just decided to punt
on that because it turns out that
actually building a concept enabled
library is a ton of work and we wanted
to focus on the way that you say things
rather than what's actually being said
now that actually being said there is a
library out there called oh that's
the right URL called origin you can find
it from that URL it's not quite right
just slash words will get you there and
that actually has a bunch of concepts
from the n33 5-1 documents mostly
aligned with that and there's some
slight differences but you'd be able to
find your way around and there's some
initial experimental support for ranges
I think I think Eric Kneedler is talking
about this week do we need is that true
anybody no no I would have looked I was
gonna pick on him if he was I was
actually actually gonna ask him to
correct some of my terminology later in
the talk so that's unfortunate but yeah
so this is some some basic range support
stuff for concepts based on his work
actually all right so the the basic
overview of the talk works like this the
first hour is really just gonna be
motivation and then sort of concepts
lightest like I'm going to eventually
end up with the the initial version of
concepts that was never actually
published because we were told to fix it
and improve it and that's a good
stopping point for the first hour then
we'll actually talk about What's in
concepts like for the second hour all
right and now I'm going to do something
very strange I'm gonna talk about
concepts in generic programming in the
context of a completely different
language oh and my favorite reference
from Wikipedia so generic programming is
a style of programming to which
algorithms are specified in terms of to
be specified later types that are then
instantiate when needed for specific
types provided as arguments this is
actually a fairly good description of
generic programming well it's it's sort
of an actually a good description of
generic programming from the perspective
of what a compiler does and maybe not
how you actually go about doing this
stuff so guess what language I'm gonna
start with no come on
Pascal I'm functional programming
language illiterate I'm sorry no Python
curiously enough I'm gonna star with
Python so here's a simple algorithm in
Python basically it's the all algorithm
I know it's a built-in but if we defined
it anyways it turns out this is totally
legal which is odd to me so basically
you loop over all the elements in a
sequence you have value with some
predicate you return false if any of
those fail you return true if all of
them succeed it's a very basic algorithm
right so the question is is this generic
does this fall into our category of
generic programming and I'm going to
answer that a second apparently my
slides are out of order that's okay so
we can we can use it so we can we can
test with I know that there's an extra
function on this slide by the way it's
it's not a big deal it's there for a
reason
I know I could write this much more
simply so if we call it test with a list
of two and is even or even you prints
true oh my god I left these pretend that
says is even and is even Wow so we can
do this with a tough bowl we can do with
a list we can do with a string turns out
to work fine in GC they know that Python
and then we try to call with a list and
we pass in true because apparently
you've misread the documentation and
then bad things kind of happen so here's
what happens with with Python this is a
dynamically typed language so basically
we we take the I mean so in the
dynamically typed language the type goes
along with the object right there's no
static there's nothing static about it
there's this little field that goes
along with the type and says this is
what I am or with the object this is
what I am and this is how you can use me
so whenever you call this function that
object goes into these algorithms and
the compiler sort of or the programming
language sort of has rules to figure how
you look this stuff up and sometimes you
find the right function and sometimes
you don't and if you don't you get an
exception if you do then everything is
good and this is generally called duck
typing so the idea is basically that we
we can actually look at this as
instantiating a generic algorithm based
on the dynamic type of an object and it
turns out to work pretty well for a
definition of generic program more
importantly a parade that gives me a
nice basis for actually comparing two
different styles of program to have it
turns out to have a lot of similarities
right and this is what actually happens
when you run when you run this that
little exception there at the back what
you get is a stack trace because what's
happened is I've called this function
which calls test which calls all which
was on the previous slide and when you
look at the stack trace you can actually
see every call in that stack and I know
you're thinking okay so who cares this
is pretty boring I do this all the time
I get these exceptions a lot because I
write in JavaScript or Ruby or Python
this is this as par for the course right
so it turns out that these type errors
are actually kind of a kind of kind of
nasty so whenever you use an object or
an expression in a way that's not
actually supported by the type the error
has to be diagnosed diagnosed at the
point of use and this always entails
some kind of instantiate or boot sorry
I'm getting ahead of myself
there's always entails some kind of a
stack write in Python you get you get
the stack trace in C++ we get something
quite a bit different so let's let's
move to C++ now so we want to do two
things we want to be able to achieve the
same level of simplicity because look at
this algorithm how hard is it that's
that's really simple that's really
straightforward we like to be able to do
this in C++ we don't want to stand on
all the ceremony of usual C++ templates
and we want to be able to get better
diagnostics out of that because I think
that we can do better than than printing
the entire stack trace for a runtime
runtime track of that time I think we
can do it so the first thing we actually
have to do because we're moving to C++
and it's statically typed is actually
fill out the types we have to assign
types to all of these things so this
will be kind of like the the Madlib game
for programming in C++ so what we put in
for these dashes where do you guys want
to start we'll do this the same way that
I run my class wants to start with the
the for all statement actually wants to
start at the parameter types anybody one
person he wants to start with before
each or the four oh I only get two votes
I had three votes thank you strongly in
favor all right well I'm gonna I'm gonna
cheat I'm gonna do this one first
because this one's actually really easy
Auto
it's a for loop I don't really care what
the type of that argument is for every
element in this range who cares what the
type do something yes it made missing a
semicolon
we'll get to that this is why you need
concepts all right so I'm going to do
this and no apparently this won't work
the record cool now the other ones I'm
gonna do something a little bit
different I'm actually just gonna put
Otto in here too because remember the
genetic algorithm is written in terms of
placeholders that you want a substitute
later and there's really no reason we
can't do this
we have generic lambdas right c++ 14 so
we do this in generic - why can't we
actually do this for functions what is
what's different about this then
actually declare an assembler and it
turns out that the answer is actually
nothing so one of the things that came
out of the wrapper school meeting is
that we get this nice ability to expand
the use of Auto as parameter types and
so for function declarations we can
actually do this so we can declare some
function f1 so you can tell it to new is
a big new sticker office so you can
declare some function f1 call it Auto X
you can declare some function f2 and
this one's fun you can make it a vector
of auto x and this one's really fun
because we can declare a member function
pointer to some class that takes some
argument and return some marking I'm not
going to argue that these are good
programs I'm just saying we got this on
accident from a generalization from core
and so we can actually do that stuff I
said what does it mean no the first
one's pretty easy we just you basically
just replace the auto with the type name
and that's really the meaning of these
declarations in fact they're actually
equivalent declarations so if you
declare that one Y in one part of your
program and this another way another
part of the program same declaration no
big deal can you guess what vector f2 is
pretty tricky just replace replace the
auto with the template parameter and
then even f3 even though it looks weird
and you're like hey I don't know what
that describes it's it's formulaic
there's there's a nice set of set of
rules that actually describe how this
work so yeah that's that's the first
concepts like feature that I'm talking
about and it has nothing to do with
constants but we go alright so this is
my
you know what actually you're right the
car F will bind to a bit reference so we
could go back to using this and function
so if you try to call you're gonna get
an error yes
today today it is yes I don't actually
care it's Auto in this example it's auto
no it's seriously like there's there's a
good name for this but it involves the
type alias and I didn't feel like
showing it so I'm we're skipping it so
here's what happens in C++ and everybody
knows this by heart I'm sure this is
what happens when you inst when you when
you actually call a function template
you do this overload resolution step and
basically for every function template
for which there is a corresponding
definition or declaration not definition
you deduce the template arguments from
the function arguments so you figure out
what kinds of types you need for the
algorithm you substitute those back into
the template that template declaration
we're placing every occurrence of
template parameters with the deduced
template arguments and you create a new
declaration called the specialization
and then you actually end up calling
that substituted code no I'm
whitewashing this is there's clearly
more involved in an overload resolution
than just these three bullets but for
the for the sake of this go the same the
sake of this discussion this is
good enough and so what actually happens
well we get this and if you guys are
unfamiliar with reading template
instantiation stack errors this is the
context in which the instantiation error
happens because we are instantiating the
all algorithm this is where that call
came from this is where that call came
from and here's the error so you just
got a pair at the top at the bottom
makes a lot of sense right now this is a
very simple error because it fits in one
slide that's how you know these things
obviously get much much worse right so
this is exactly the same problem that
you have with Python and this is exactly
why I put these things that these two
languages up here because whenever you
get a type error regardless of the
language if you deal with generic
programs you are going to get the error
happening inside of some stack and those
languages will always give you the stack
if they're good they'll give you the
stack to show you how you got there
right type errors make writing and
maintaining programs difficult I'm
they're just a pain they sometimes lead
to very subtle type errors especially in
C++ of conversions get involved and you
sort of miss something and if you ever
end up with a serious C++ template
instantiation bug has anybody hit a big
one like a couple hundred pages of text
everybody should raise your hand if
you've written with templates you've
gotten it yeah so they're just nasty and
these things are the worst these these
little subtle bugs that sometimes creep
through or like oh you've included the
wrong header file and therefore overload
resolution does one thing and you
expected to do another be sure to
include math if you're going to take the
absolute value of something so really
what we want to do is be able to prevent
these type errors are bad we like we
like checked code so I'm Python the easy
thing that we might do is we might just
throw some assertions in here that
actually check these things right so
assert is instance C you know basically
just checking to see if they're
instances of these types this will
clearly not work in C++ because we don't
have a typesetter file that lets us do
this for one reason for one thing and so
if you call all of and you get with is
even you get true for that it works fine
because the assertions pass if you call
you call all of with true again it's an
error and so this is a good idea right
and this is actually a question for you
guys to answer this is good
yes or no why not it's better what's
it's but is it no I agree this is not
actually very good there are a whole lot
of problems with this the point of
assertion is actually inside the
function definition which means that if
you hit that assertion it's too late
you're going to get a stack you're gonna
get a stack trace it's just too late you
have missed the check it also puts the
interface in terms inside of the
implementation and this is not this is
not something we spend enough time
talking about the fact that the contract
is actually inside the definition of a
function is a bad thing the declaration
should have the interface it should
specify all the requirements that you
need one of the other side effects of
that is if you if you push these
insertions inside of the type or inside
of the definition you can't actually you
can't effectively extend that definition
to support more types without going back
and modifying the function definite
begin definition to begin with there's
no way of sort of extending that as
needed for types in your library or my
library or somebody else's library you
have to go back to the one the one true
arbiter of that definition and say hey
by the way accept this type and that's
just not good that's not good software
engineering and finally and this is the
the final point we're not actually
checking the right properties for those
things yeah
a lot will keep going trust me you'll
see you'll see the difference right so
what happens is you know even if we've
even if we've done the right thing when
you run that code we still get this
stack trace which is not what we want
because we're still looking at the same
stuff no it's true it's a little bit
better because look we can actually say
this is the exact error that happened
but it's still it's it's too little too
late for me it's not it's not good
debugging it's not good information now
the way you might do this with C++ might
this is the type based equivalent for
C++ and templates is to use static
assert now for the sake of argument I
think yeah so sequence and predicate
look like this if you've never seen a
type trait before these are types rates
they basically always return false when
you create an object of that type
they're just dummy arguments so the way
that you might actually do this in
templates today is you throw some static
asserts inside of your function or your
class and is this better yes you'll get
a string no it's actually worse it's
worse
static assert actually gives you worse
Diagnostics because what happens is you
yes you do point out the static
assertion and you can find it but then
the compilers because they try really
hard to compile your programs well go
ahead and compile everything else in
that definition and give you every
single type error that you didn't want
to diagnose in the first place how bad
can this really get any guesses
that's not that good right I know it's
small that's on purpose well let me let
me zoom in a little bit so this is what
we like about static assert it does tell
you in the context required from here
what exactly those errors are and what
we actually do get a nice a nice message
it says bad sequence or bad bad bad
predicate that's good but then the
compiler tries to be helpful and it
tells me that begin was not declared in
this scope and then it tells me hey did
you think about calling this function
and I mean lighting a lot of a lot of
paths here by the way and the funny
thing is that this is actual code these
are actual error messages from a from a
file on my laptop and I don't know why I
don't get the other definitions of begin
I don't think I'm including the right
header files because there should be
more than just this that's that's not
the only definition of begin then it
tells you the same thing for end and
then just for good measure we like to
know that you can't call a boolean value
as a function just in case you didn't
know because of all the other error
messages so static assert actually gives
you worse error message it gives you
worse Diagnostics because once you hit
that the inside of that definition you
are going to get everything in that
context and if it's inside of a class
template if you thought that putting
these inside of a class template was a
good idea no you break that contract and
you will get every single substitution
failure that can occurs from the
instantiation of member variables all of
them really hard to read so how do we
actually get around this we don't we
don't want to dump the entire stack and
so it turns out that the best way that
we can do this really is to lift those
constraints out of the implementation
and stick them into the declaration
themselves and then check those
constraints because now they're part of
the declaration when they're first used
so when you actually go to call the
function that's when you look at its
declaration say I
I refuse to do this I know that true is
not a function I will not call that so
here's what this looks like in practice
today so we're going to start with this
this is our function your static assert
sequence and predicate then do a quick
little rewrite because I like things to
be in expressions and multiple
declarations of static assert don't do
it for me so now we have
logically equivalent set of assertions
it has to be a sequence it has to be a
predicate and then who knows what comes
next beauty we lift it into an enable if
how many people how many people no
enable if and oh I got the good audience
today got the right audience and then
you end up with with with stuff like
this I was gonna use a different words
and stuff it looks terrible
what so this is what we end up with Edie
if you've if you guys have done any time
looking at C++ standard libraries these
days it's all over the place and it
really it's really hard it works more or
less oh yeah I forgot about my my meme I
put this in there so it works but if
there's there's so much to be desired we
can do so much better than this if yeah
that the dog
that's a side effect if you only have
one overload and one one candidate and
the overload said it gives you the error
you think which is not it doesn't remove
it it just gives you the error that you
did so if you're really going to be
effective with enable if and to be
effective with enable if you really need
deep knowledge of the template
instantiation system the template system
you do because it's hard to work with
you need to know about things like
sphenoid friendliness and instantiation
context and I can I can talk about those
for a long time because I get to deal
with them on a daily basis if has
anybody actually tried to use enable if
with a class template is it easy kind of
you have to use like a specialization
where there's a generic case and
specialize the true because yeah that's
that's fun I have to look it up every
time I try it although it's been quite a
while it doesn't work really well enable
that doesn't work very well member
functions who was I talking to in the
hall that just complained about this
Alistair yes couple issues I think or
was a smart pointers I forget
overloading is limited at true/false
conditions now this is you know this is
kind of an iffy thing you might say like
okay what true/false is good enough but
if you what happens a lot with concepts
I say a lot I don't have no idea that's
actually true what happens sometimes
with concepts is that we have sort of
hierarchies of things and you end up
with sort of this linear sequence of
more specialized algorithms like input
iterator bi-directional iterator sorry
inputted or right or forward iterator
bi-directional iterator random access
iterator and if you're limited to
true/false conditions then yes you you
can build that hierarchy into those
predicates but it's it's it's closed if
you want to add you have to go back and
modify those constraints your modify an
existing source code not great obviously
it's not intuitive it's hard to read
it's hard to write it has this really
lovely property of completely obscuring
what you're trying to declare and yes I
know that there have been libraries and
there have been attempts to improve this
and they've been by and large fairly
successful I think but it's still your
writing declarations in terms of
mechanism and you don't want to do that
you want to write a declaration and have
it mean what you actually say we don't
want to declare language mechanics we
want to declare functions and classes it
does not significantly improve
Diagnostics it can compilers are
actually getting better at
I know that I was surprised by some
error message messages that GCC gave me
recently saying which type failed a
substitution or which template argument
failed Li to do is that was kind of cool
but it's still not getting to the heart
of the error it's just it's a
substitution failure or it's or it's a
template argument reduction fail those
are your two choices and if you use this
pervasively in your code base it will
lead to slower compile throughs it will
because enable if is a template when you
instantiate a template you have to go
generate a class and the compiler has to
do analysis on that it's just there's a
lot of machinery involved with actually
using this idiom especially if your
libraries tend to do a lot of like meta
programming heavy conditions in in that
expression slot there that first one it
does lead to slower compile times
all right so concepts the these are the
problems that we sort of set out to
solve right we wanted to actually have
simple and direct expression of 1/10
when you write when you write a
declaration it should look like a
declaration and it should be obvious
what's required of your template
arguments we want to be able to overload
declarations based on those requirements
and to support open extension which
means we don't want to go back and
modify the definition of the function
just to be able to support a new
overload in a new domain or to bridge
one library into another we don't want
to go back and we write code to do this
we definitely want to improve
Diagnostics definitely want to improve
Diagnostics and then a couple of other
things that showed up in the wish list
obviously we can't add any runtime
overhead because we like templates and
they give us that so there we have some
some constraints here no no additional
runtime overhead that's actually not too
hard because their templates you know we
don't do anything at one time the tricky
one was not actually significantly
improved increasing compile time this is
a difficult thing to do because you're
adding a new language feature that adds
new semantics to the language that have
to be processed as part of the regular
processing of language so how do you add
new stuff without actually slowing your
compile times down a little bit and it
turns out that you can't but compared to
previously we can still do better in
fact it actually ran some performance
tests a number like a year ago of
concepts like vs. similar code written
using enable if and type traits and
essentially you get an order of
magnitude level of performance but again
that's against similar code to test
it's queued it's not it's not really a
fair evaluation and then we have this
weird whine like don't increase the size
of the binary this one actually crept in
a couple of weeks ago because of some
suggestions for core I I will mention
this briefly in the next hour and
explain why why this actually showed up
but I don't think you want larger
binaries just because you put
constraints inside of templates alright
so here's what we had before
now concepts lightest was a really
simple idea though the first initial
version of this was really easy you just
take that enable if and you drop with
this requires clause in and that
requires clause just carries the same
the same condition that you had before
seriously 30 minutes Wow I'm Jim I
should have made more slides you guys
can ask more questions please although
if we finish earlier that means more
time to relax or more time for questions
so the the requires Clause just takes
the the you know this that sequence
there it just sort of slips it in
between the template and the template in
the declaration works great all right
I'm done questions just kidding
so we'll actually make this a little bit
more concise later as we go this is not
the most elegant way that we can declare
these things but at least it should be
clear there is a template it has
constraints then there here's the
function right we can we can make this
more elegant later so this requires
clause is fantastic it allows the
specification of constraints on template
arguments obviously it's technically
allowed on any template or function
declaration yes new compared to not C++
this is new in the concepts TS the
proposed concepts yes so these are these
are features that are coming in that are
would be part of the TS
and hopefully c++ 17 modular time and
voting of course okay so a requires
clause I'm allowed on any template or
function declarations followed by a
constraint expression and by the way
these will expand as we go for like
concepts version two it's followed by
constraint expression a constraint
expression is basically a constant
expression with with a couple of
limitations on it and there's sort of
subtle and I doubt that you guys will
ever run into them because most people
don't overload provide user defined
operators for for logical and logical or
these days and if you do and you try to
do something with this you'll be told
sharply that you cannot and then of
course constraints actually end up
getting checked at the point of use
during a lookup this isn't being very
explicit that this happens at the point
of during during lookup and at no other
time so for just for terminology we can
say constraint is satisfied if and only
if it evaluates to true we have this
interesting case where sometimes
substitution failures creep out of
constraints if you end up getting the
substitution failure like you you
substitute void into the type of
expression t ref but you know you can't
make a reference to void so that becomes
a substitution fail so if you get a
substitution failure in these
constraints then you actually end up
just getting false works out nicely so
things either work or they don't and so
what happens if you try to call this
thing using our using our sort of
whipping boy for example all here the
error actually occurs the point of views
and look you can actually see that
because the context in function main not
not somewhere else not inside of the
instantiation context of the template we
see that you can't actually call that
function and then we do cool stuff
because we tell you why you can't call
that function and this is what concepts
light actually gives you this is real
output from the compiler it will tell
you that sequence this thing evaluated
to false
I cannot instantiate this declaration
because that term evaluates to false
furthermore I can't instantiate this
declaration because this term evaluated
to false now that seems kind of odd
right I'm giving you two errors for
single expression you guys should get
the idea that there's a little bit more
to that expression than just a single
expression in fact
there is these constraints are actually
based on the content or the spelling of
those constraint expressions and so
everything that concepts does under the
hood deals with these these expressions
in a very very different way than C++
normally does it's all lexical yes/no
but we probably could yeah in fact
almost certainly we can yeah no one I
have a slide on that in the next hour
but I will preface with saying that is
the reason why concepts light is
actually like we don't try to do that
which I will repeat directly in the next
hour
okay so surely we're not actually
constrained just just a function
declarations clearly not have re set
every any function template declaration
a regular declaration or sorry function
declaration so where else can we
actually use these things practically
and I'm pointing this out that I'm
specifically using type traits in the
standard library here just so I don't
have to introduce new new ideas yet okay
well we can we can clearly put them on
class templates this works out nicely so
if you want a vector then you you just
declare it as is and you say template
type name t standard you know is
requires that it's an object type and is
object is defined in the standard
library to be any type you can use to
declare an object or variable for
example you have a complex type oh sorry
uh partial template specializations sure
we can do this too it is a template
after all sort of depends how you
process these internally yes yeah well
I'm specifically specializing for the
Gaussian integer case as opposed to the
regular the normal complex float which
actually shows up again but yes we could
swap out his floating point to get the
right definition of the right definition
of those complex notice that you when
you do this you do actually have provide
the specialization arcs so even though
it looks like a regular primary template
it is in fact a specialization with the
constraints alias templates worked fine
- yeah more on that next Oh
this is all about motivation not about
not about specific details so alias
templates work fine you can actually
constrain these things oh this is a
variable template that's an alias
template alias templates worked fine so
Alistair issues with with make unsigned
and integral it used to be the case I
don't know if I don't know if the
standard libraries to fix this yet it
used to be the case that so bool is an
integral type you cannot make bool
unsigned so this this becomes an issue I
don't know if that's still the case or
people have made that friendly yet
variable templates have you guys seen
variable templates yet this is new in 14
it's a template you can constrain it
works the same way you throw the the
requires Clause on there so this is my
favorite declaration of min now it's
just a variable that refers to numeric
limits of min works out nicely you can
just even constrain member functions and
this is one of the bigger wins and the
constraints on a member function
actually shows up after the declaration
but before the definition there's a very
good reason for that
it's a mini one I guess why that reason
is lecture there's two very good reasons
one of them is technical one of them is
just good sort of yes I think I know
where you're going I think the answer is
going to be yes yeah
so there's an interesting question as to
whether or not you can use function
parameter names in your requires clause
and the answer is yes but not for an
obvious reason No
the simple reason we ended up putting it
after well the two reasons we end up
putting after one it actually looks
better because now all of your
declarations can be aligned in the same
column clearly the right choice and the
other is that if you do it right a
definition that requires Clause becomes
ambiguous if you try to write it before
it's not clear whether the requires
Clause would pertain to the temporal
parameter list or the declaration
following it and so by moving it after
you just make it you make it clearly
belong to that declaration so the the
the out of class definition from
concerned member function would look
like this complete with a correct
definition I hope no because I'm not
providing arguments to begin an end
classy it's magic should show the error
for this one and surprisingly you can
actually stick constraints on normal
functions this this fell out of some
generalizations from core that happened
in Switzerland that is this is a
peculiar thing and I I would if you
you're using GCC and downloading the the
compiler don't do this you will get
linker errors this is a known bug for
GCC right now this is not static if I'm
just gonna I'm just going to point this
out right now this is clearly not static
it if you define this the compiler will
definitely parse the body of that
function as if you didn't even bother
specified specified requires clause this
that means like I said this crept in is
a generalization that made the
specification easier and then somebody
said I have an idea we could actually
use this for XY and Z and so we actually
end up with the ability to constrain
regular regular functions now this is
actually where the no code bloat
argument comes from because if those
constraints are part of the signature
you actually end up having to put the
constraints into the symbol table
and that's nasty because those
constraints can get big if you look at a
real concept definition with like a
hundred requirements that is a big
concept that is a big constraint and
your simple table will explode
now there's another interesting thing
that falls out of this is that if I have
a bunch of these declarations that have
different constraints same same F same
function names same F different
constraints you can only ever call one
of them these are these are some
guarantees that we have an overload
resolution so why would you actually put
a whole bunch of definitions in your
symbol table for functions you can't
call so you can do this just be aware
that it's a bit odd and it'll take some
time to adjust to this but as soon as we
have constrained virtual functions and
yes
they're coming it's the same idea it's a
very very similar idea with simple tape
virtual tables alright so again yes yes
but it depends where next next hour next
hour all will become clear
okay so constraint checking always
happens at lookup
so for variables classes a Li I aliases
wrong sorry wrong ending aliases
correctly although a Li I sounds good
that happens as soon as he hit the
template ID you run a check on the
constraints that's going to lead to some
interesting interesting situations for
you for functions which is what I've
been looking at so far always happens to
an overload resolution so basically you
you call some function there are some
templates some of them are constrained
you have to evaluate the constraints as
part of overload resolution if they're
not satisfied they either return false
or do not return true then there there
non-viable they don't they don't play it
in the rest of the overload resolution
algorithm yes
there are no changes to scoping rules
for C++ so whatever you're calling today
is whatever you're calling tomorrow that
seems to be fairly important yes see
this is a question that was asked I
don't think we ever answered it I don't
know so the question is whether or not
so if you have constraints like standard
is object with the name standard is
object poll standard in the standard
namespace into the set of associated
namespaces four overload resolution the
answer is I don't know it does not
currently and there's no wording in
there to support that and I think the
answer will generally be no but I that
may change I hope it doesn't all right I
get a thumbs up in the back so we have
an answer good we've done the work of
the evolution group here so if you don't
find anything if all of your if all of
your your lookups fail you your
constraints fail for a class template
your constraints fail all of your
constraints fail for function templates
no no good conversion sequences then you
start getting these errors now there are
a couple of interesting sort of gotchas
that come out of this this lookup based
check you cannot avoid constraints if I
declare my this is my fake numerical in
its class and it requires is arithmetic
and then I get clever and I want to kind
of push some non-conforming type in by
the way Center is a standard is
arithmetic covers only standard only
fundamental types so whatever is already
in the language it's not extended so if
I want to come along later and sort of
adapt my class to this type can't do it
that's actually an error this this is
designed very specifically to keep you
very honest about what your templates
are and what the resulting
specializations are you only get a
specialization if the constraints are
actually satisfied you cannot bypass
constraint checks
what but you can add them yes
next next like at the end of the next
all right so if you actually try to
compile this actual output from the
actual compiler will tell you
constraints not satisfied this
specialization when you do this
evaluates to false now the reason for
this after you surprised me because this
check was not actually something that I
expected to see because it didn't used
to be there this is a recent change to
the language instead of specialization
the template specialization must be more
specialized than its primary it's my
primary template and so the compilers
sort of grew this extra check that
results in this error which is nice
because that's actually quite true yeah
actually the first time I was doing this
I was looking at I've seen this error
twice and my output code I'm like why am
i why am I seeing this twice 1 for this
check and one for the Declaration of the
variable that was causing instantiation
there's another interesting thing like
the lookup based constraint checking you
are not always required to instantiate a
template even if you're using a template
ID for example if your type is not
required to be complete so if you
declare a pointer to say vector or
something like that it will not actually
it won't actually instantiate the vector
template but again the check happens on
lookup and so you can't actually form
this type vector int ref doesn't work
because in bur F is not an object type
the idea is that you can't sort of
bypass the constraints and carrier on
pointers to types that you could never
complete later anyways so we just
checked this as early as possible and
prevent you from getting errors later on
and this is a little bit that's a little
bit different it's kind of subtle in it
we actually went back and forth on
whether or not this was gonna happen or
not and I think this is this is
definitely the right answer because we
don't we again we want to keep you
honest you should not be able to bypass
constraints they say what's necessary to
specialized template yes
it's part of the Declaration absolutely
if you if you do not actually put the
constraints on your declaration so he
likes like your template type MT class
factor and then lower later on you have
a template is requires is object t class
vector that's actually a redecoration
error because now you've declared two
classes named named it back to with
different with different requirements so
you actually have to put the the
requirements are part of the declaration
they have to follow the declaration no
they're not oh you know you you're in
you're in bad territory if that happens
that is that is undefined behavior no
diagnostic required I think it was
Alistar and then this is purely for the
concepts features the the enable if
version of this with with class
templates requires you to instantiate
the class because you have to find the
the specialization the most specialized
version of that and that you're actually
in the specialization set lookup
algorithm at that so this is this is
definitely concepts of yes it depends
know so to require to requires
expressions are the same when they're
spelled the same modulo names of
template parameters same rule for
template arguments in general the the
they are equivalent I guess it would be
the right way to say that the formal way
to say that yes
right and in fact there's some I
actually have a little bit extra time
checking constraints is interesting
because it almost virtually requires all
of the arguments to be checked to be
complete and almost virtually requires
that because you're doing lookup on them
and some time like if you if you do a
check for can you know is copy
constructible well guess how you figure
that out you got to go complete the type
and then do a lookup on the copy
constructor so there are some things
that you were probably doing with
templates before that if you add
constraints will will not work because
you're going to complete a type and it's
gonna it's just not gonna it's not going
to check yeah
they have different spelling and
therefore they are not equivalent it's
checked lexically not not logically
yes and if you say yes and if you say
true and true and parentheses that is
also considered to be lexically
different oddly that that came out of
course there was a discussion of this
and I think Jason Merrill said nope
that's different not ya know so the type
completion rules follow whatever you're
actually checking for the concept it's
just that it's it's very unpredictable
as to what what those constraints checks
actually end up doing like even if
you're using standard type traits like
you know he has copy constructible or
has has no throat instructor those will
require a completion but if you ask for
something like is object that's that's
just a very like a name check and that
doesn't require completion I think so
and by the way if you guys want to play
with this stuff and you start doing a
curiously recurring template pattern
where the base class is a template don't
put constraints in the base class
template because that will always break
found that one out by accident alright
so let's see here yeah so if you do this
with the pointer valuates to false you
can't declare the variable nice and
there should be an extra an extra thing
here that says invalid type and
declaration but
that's just the way that complete types
work because it can work but you have to
be really careful with your constraint
so the best advice that I can give is
just don't don't try you would put those
constraints on the members on the
members of that class to make sure they
don't get picked up in the hope of my
overload resolution all right
so almost done at the first hour so
let's see
deferred type checking for templates
results in bad Diagnostics buried
interfaces because you have to push
things into the definition at times
unless using enable if and then if it's
it's fairly closed for extension we
can't sort of naturally extend things
the way that we like concepts there at
least the goal we want to be able to
write constraints as part of the
declaration certainly and to check those
at the point of views that that gives us
a lot of power to do some very
interesting things so everything up
until this point that talk is really
with with except for some of the
discussion of overloading partial
specialization it's really sort of like
version 1.0 of concepts light or maybe
point nine alpha or something like that
which would be concepts lightest like
this is the the first implementation
draft where you just had a requires
clause and you just check yes or no
either works or doesn't it didn't there
wasn't really any advanced to really
advance support for you know defining
concepts which came out for a
teleconference call there wasn't really
any excuse me advanced support for
overloading because we still fell into
that true/false thing gabi kind of
pushed us to go this direction which I'm
kind of glad he did at this point so we
ended up getting overloading a little
bit later the the general idea of early
early concepts like was just simply to
be a simple a nice clean replacement for
enable live and then it's sort of we've
figured out that we can do a lot better
than just true or false and that's
that's really the point of the next talk
so any remaining questions in my last
one I have five minutes or so yeah
yes answer in the next slide
next talk stick around there's actually
a really good language there's a really
good reason for it actually because it's
an expression it's it's a constraint
expression like that that requires
clauses followed by something that is
either true or false
the idea of concept is quite a bit more
than that there's a lot of information
that you might want to include in a
concept that's that's a bit more than
like well it's just you know a type tree
yeah I think that's probably a bug in
the Diagnostics yeah no actually so what
happens is and when you actually
generate the Diagnostics is that you
find an expression we substitute in and
I just didn't rewrite the expression a
second time so you you could choose to
rewrite that but it actually turns it'd
be kind of hard in GCC because they like
to do it's it's a it's an implementation
detail but yes I could rewrite the
expression if I had better or
substitution support you get another
question so let's say is there a
thematic T instead of is a tipi
rewriting expressions in C++ or sorry in
GCC is difficult I will just gonna leave
it at that
this was extremely difficult to make
work the first time I hope to continue
improving it whoever who their hand up
yes yes you could do that although that
I think the better solution is to make
the primary unconstrained but yeah you
certainly could yes oh yeah yep next
next next slide next time yeah
why is this an error so it fights so
there can be yeah yeah okay other
yep one more yeah yeah that would work
if they're that big up with arithmetic
yes yes wait which one if you take the
requires clause out it's C++ today oh
yeah yes it would work no because it's a
different Declaration unless you forward
to clarinet and defining a later yes you
have you have weakened the post
condition other questions
alright so we're gonna take a 15-minute
break I think and then you guys are
still interested I will continue talking
for another hour with a completely
different set of slides in the first
hour
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>