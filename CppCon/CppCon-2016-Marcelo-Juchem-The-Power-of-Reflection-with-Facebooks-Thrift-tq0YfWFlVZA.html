<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Marcelo Juchem “The Power of Reflection with Facebook's Thrift&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Marcelo Juchem “The Power of Reflection with Facebook's Thrift&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Marcelo Juchem “The Power of Reflection with Facebook's Thrift&quot;</b></h2><h5 class="post__date">2016-10-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tq0YfWFlVZA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to everybody my name is Marcelo
I work for Facebook I'm a software
engineer and I'm here today to talk
about reflection using Facebook drift so
basically let me just talk about the
goals of this presentation today I want
to showcase a few examples of what can
be done with reflection those are some
real-world problems that we hear so
viens Facebook this is useful should be
useful for users like to see what's
possible to follow some examples and
also for library white writers to see
the to look at the problem from the
perspective of Facebook so the more use
cases they can't they have at hand a
better and also I'm here present also to
present a freight working framework that
can be used today so it's not something
that would have to wait for a compiler
support for a new proposal to be
accepted and and of course we're tripped
applies because you need tripped
foreigner for this work for those who
are not familiar with drift is basically
the RPC framework that we have a
Facebook so we write a so we write some
definition in using a interface
definition language based the saying
those are the types that I have and we
generate some code for you based on that
and we won't look at how the reflection
framework is implemented I know some of
you might be interested in that but
that's not the point of this talk you
can take a look at the source code later
or come find me and I'll be happy to
talk about it but the focus here is to
look at how to use it and what is
possible so channel here so just initial
words first and we're going to take a
look at a few examples basically code
and how to use it then how to enable
reflection support in tricked few
closing words and before I go we can
have some questions so before I start I
assume you're familiar with reflection
the concept of reflection and
introspection high level familiarity
with civilization just because one of
our examples is basically civilizer
search algorithms like binary search or
the dictionary lookup
and of course familiarity with
metaprogramming so if you're not
familiar with meta programming you never
you never done some meta programming
before this talk will definitely not be
useful for you things like meta
functions specializations traits classes
type lists this is basically what a tie
place will look like in this this lights
list transforms basically how to apply
it to a meta function to every single
element of a list and we also have
compiled time strings which is basically
a pipe that will represent a string this
is not a runtime string that is
allocated somewhere it's just a type
usually a very attic type that's what we
have in our implementation so I'm gonna
abbreviate a few things just to make the
code more readable so whenever you have
a list of integrals instead of writing
an integral cost all the time I'll just
do it like this just because it's easier
to read and also whenever you have a
list of strings I will write it like
this
also too to make readability better so
let's start with a first example with
jason ugly printer I could write a
pretty printer with proper indentation
but that's besides the point like you
can you like you don't need to know
reflection in order to write a proper
indenter so we'll take that out of the
equation and focus only on the
reflection usage this is the interface
that we're aiming for so if you've real
simple just a function print where you
passed will you pass an instance of your
object and we should figure things out
and create it for you like this is very
useful for debugging and given that it's
Jason you can actually use for our
things as well for simplicity I'll just
write to sender see out but you could
just send a an output string here or
whatever that you want and just write to
it instead so let's take a look at the
implementation and what what would this
function look like
we start by reflection that they're
reflecting the type class of this type
so basically what does that mean is is
it a integral is it a floating point
enumeration is it a struct is it a list
a map or what is it the reason we need
this is basically because we will
implement this the the pretty printer in
one way
for lists and in a different way for
structs list don't have members that you
have to wider eight over just elements
there are no genius whereas the
structure have like may have several
different members with different types
in an integral Tony doesn't even have
members is just number and the way we're
gonna do it is by delegating the
implementation to some other template
much very similar to what type traits do
in C++ so basically say give me the
specialization of greater for this
particular type class so I want a
printer for structs I want a printer for
integers something like that and then we
just call the method print passing the
object that we want to print so let's
take a look at the general case for the
printer so ideally we would just do this
sim simply pass it to sender see out it
will just print whatever we want and
we're done
this works really well for integers for
doubles but it doesn't work really well
for lists or for maps or structures
unless we have written an overload for
the shift operator but for integers it
works pretty well so let's leave it at
that for now for billions we want a
slightly different format we want to
write through enforce instead of one
zero we could use blue alpha but we're
just not going to do it because just for
the sake of an example so we just write
an overload football and there we have
it so the next thing is strings how do
we write strings ideal we have to devote
to quote them because that's the format
the Jason accepts so we write a
specialization for Strings that's just a
template specializations for a
specialization for printer so whenever
the type class is a string this is
what's going to be called and we just
write the print function and what it
does is price the quotes right the value
right the the ending quote proper
implementation of this would escape the
string because we might have double
quotes in the string itself but a for
the sake of simplicity we're just not
going to do it in assume it's
like there would be no invalidating
strings you could simply write it an
escape function here and say escape what
and we just work but let's leave it at
that
so let's look at lists now basically
this is the form of all live lifts when
it comes to Jason you start with a
square bracket and you write every
single element separated by a coma it
doesn't have to be strings it can be any
single optional there could be
structures could be other lists but this
is just an example so what we're gonna
do is we're gonna specialize the
template for lists for the list type
class and you please note that the list
itself receives the type class of the
object it contains so it may not makes a
lot of sense now but it's very handy
when it comes to printing the object
that is containing the list we're gonna
make use of this shortly next step is to
basically print the braces and then we
want to iterate over a list just like we
normally do we're gonna handle the
limiters just make sure we're gonna fill
in every single element with commas
that's nothing new like and right after
we call the proper specialization of
printer for the type class of the
containing element so basically we write
we are on the list list specialization
and whatever we have inside the list
we're gonna delegate to that to properly
print this object so the next next thing
is sets like how do we print sets the
format that I chose is basically the
same as lists so let's see how we do
that it's pretty much the same thing you
specialize per sets you have a type
class of the contained element and then
you can simply delegate to the list I
mean it's pretty much the same thing
same thing so why we implement that
right it will make a difference
later because the interface of the
awfulest and a set is not the same well
a vector for instance has in place back
a set has in place so we will specialize
properly later but for now it's this
should be fine the next example is maps
basically there's a format of a map you
have a curly braces and then you have
the keys separated from the u values
like : and then the elements are
separated by a coma
what we do now is we specialized for map
and just like we did for lists we
receive the type class of the key and
the value contained in a map the rest is
pretty much the same you write the curly
braces you write the for loop you write
the coma separators you write the colon
separators for our key and value and
then you delegate to print off whatever
the key and the value type is please
note that by using the specialization
here for printer you can write the the
specialization for each type class
independent of each other you don't need
to change the implementation of ant to
support a new type you just add a new
specialisation you're done so the
advantage of that is that you can even
specialize in different headers but it's
just one reason but you can use any
other implementation design you you want
to go with but this is what we choose
for what we chose for this example the
next thing is how to clean an enum like
there are several solutions out there
too like how do we figure out what's
this thing string representation of an
enum right so that's why most people
just use the integer representation we
created that what I chose instead to use
the string just to show you how we can
do that how you can convert an enum to
do strong representation in itself it's
much the same thing we have a
specialization for enumeration and then
we want to see out with the quotes and
we call this function called enum to
string what this function does is just
imagine a giant switch case from the
enum itself to string there is a
guarantee that this train will be
statically allocated so you don't have
to manage lifetime of it it's you can
simply rely that it is stored somewhere
and it's the lifetime is valid for the
duration of the program this is also
useful due to the aesthetic
initialization order Fiasco we had a lot
of problems at Facebook with that
but you can rest assure that at least
this part is safe and the next thing is
the structure like how do you how do you
infer what the members of the structure
are how to why trait over them and how
do we properly print because stroke is
basically it's represented just like a
map in Jason with a different difference
that it is heterogeneous so the members
don't have to necessarily have the same
type basically the same thing you will
see that there's a recurring pattern
here that's after a while the the part
of the examples will become really
boring because it's just a team the same
thing if you feel like it's boring I've
accomplished my goal because that
basically means you don't have a lot of
cognitive load you can simply just say
well I know how to solve this problem
let's just go ahead and do it let's
focus on what really matters which is
not figuring out how to iterate over
types and what not it is to serve water
problems so same thing you write the
braces you reflect the struct so that's
basically saying give me the information
that you have for this particular struct
I want to know what's this jackfruit
actually structure that he has let's
take a look at what that means
so basically gives you things like
what's the name of a struct as a
compile-time string what are the members
of the struct what are the annotations
because trif allows you to annotate
types members and whatnot and you could
sorry and the member descriptors looked
like this it's almost the same thing it
tells you the name of the member not the
type but the member itself it gives you
the type of the member it gives you a
getter function so that you don't have
to say X dot foo you can simply say give
me this getter and I'm just gonna use it
I don't care what the name is I don't
care what the identifier is I'm gonna
strike that and write your generic code
and also annotations just because thrift
allows you to do that we're gonna arrest
through some examples later that use
annotations to perform some data mapping
so that the goal is basically to say I
want to change only the IDL and not the
code that I write in C++ and the
reflection framework we just
your things all for you and then we now
that we we know what it gives us we can
simply say well I have to I to rate over
the members but they have to know how to
get the members first so give me the
information you have four members and
then I'm going to iterate over this type
lists so the way you I trade over type
list is very similar to the way you
iterate over types
oh sorry over values just not quite
because we're dealing with types here
not really values right but there is a
helper function call for each to which
you just pass a visitor and you say I
trade over that and call the visitor
passing the type every time you find a
new type so for the first and the index
at which this type appears so if you
have asteroid compose of integer member
a boolean member double member and float
member energy will be the first member
of the structure the boolean would be
the sorry the boolean will be the second
double will be the third and fourth will
be the fourth and as you can see you can
also pass additional arguments that
would be forwarded to the visitor later
so we don't have to manage you don't
have to create stateful visitors you can
simply say this is a visitor here like
give me whatever arguments I has to for
each and with that in mind we can simply
say well I trait over that using for
each and whenever you find a member call
this visitor here and pass the member
information to it and also of course the
structure itself so let's take a look at
how this visitor is implemented because
every time it's called we want to figure
out for this specific member what is the
type and how do i how do i print it it
received a member and the index like we
saw before this is just boilerplate and
we will also repeat for every single
visitor you see but simply you receive
the type information first as a tag
either indexed or not and whatever
arguments you you've passed to for each
and then you can simply say if it's not
the first element printed coma and also
i want to print the name but the thing
is that this name is a compile-time
string but I need a runtime serine are
right you needed to be somewhere your
memory so what we do is we have this
function called Z data and what it does
is whenever you have a compile-time
string it will give you a null
terminated statically allocated string
so it's pretty handy you just say for
this compile time string give me
something that I can use its runtime and
that's how you convert compile time to
Rend time strings and then you call
together on the member that you can get
from the metadata that you received from
the from the for each and you can also
get a type class for that member from
this information and you simply delegate
to the correct printer implementation
and that's pretty much it
you're just iterating over the members
of structure and print and based on the
correct type and type class word we're
just calling the correct printer for it
and the last thing is how do we create a
variant so I expect you guys are also
familiar with parents but basically it's
a way to store at most one of different
types in a specific container so there's
which which is the name of what's stored
there so say I want to store I have a
variant of foo and bar who is int and
bar is double and but at this specific
time I want to store food in it which is
an int so we're gonna print the the name
of what store in there the name of the
member and the value that's contained
remember the way we reflect variants it
is through a variant rates basically we
can say instantiate the variant race for
this participant and I can give it the
name of the parent and also the ite
which is basically the num dat tells you
which type is stored there and you could
say for instance print the name of this
thing using Z data that we just saw it
also gives you the scripters for each of
the members that can be store in the
variant this pretty similar to what the
member descriptors are four struts only
that variants only store one thing at at
a time and while struts like have all
the members at the same time and the
scripture is a way to for you to
abstract
to the members themselves so just like
strict members it gives you the type of
the member the idea of that specific
member so enum value acts is going to
represent the specific member and also a
getter so that you pass the parent to it
and it returns a reference to that
specific member and a setter so you can
actually set values in it so this pretty
much abstracts access to the variants so
you can simply write generic code in
order to use it and an example of it is
say you have some instance of a variant
and you have you've obtained the
descriptor somehow to a specific member
you want to get the value of that member
from the parent that's what you do and
if you want to be sure we can check if
the value that's stored in the variant
is the same represented by this
descriptor so let's see let's take a
look at how we implement a printer for a
variant then with that information in
mind we we write the braces and from the
type that's stored there this is an enum
value this is a runtime value we want to
figure out what what's the descriptor
for this particular member
that's store in the UNAM and this is a
type so we have to go from a runtime
value to a type but the problem is that
a runtime we don't have type information
right so how do you how do you figure
that out and it's pretty much what we
did before it's basically with visitors
but we need a way to to do that
efficiently so we imagine you have some
type we have members foo and bar and you
have a list of those types with proper
values and you basically you have a
needle which is a runtime value and you
want to get the mem the the element in
this type list hos value of foo is the
same as the needle so use the matter
function get type foo to basically
filter the the element by by that
specific member there's a thing called
sort of search which is binary search
that's basically it so we're gonna
binary search the type list hope hoping
to find a needle in there you pass the
needle you pass a visitor the visitor
will receive the type itself that's type
information and you can also pass
additional arguments
pretty much the same pattern we've seen
so far just for a different use case so
we just do that we want to sort search
based on the ID of what store in the
variant but the problem is what if the
list is not sorted but you cannot really
bind you're searching something that's
not certain so we need you need
something to sort the list let's take a
look at how we do that you imagine have
the same list and again we want to sort
by foo you just call the sort method
function and it's gonna you pass a
compare because we want a sending order
and it's gonna return the list or it for
you pretty much the same you know like
very similar interface to well you you
have in in the standard sort just now
four types with that in mind we sort the
list by ID and we pass this thing around
to to sort of search and there you go
and you pass the visitor that you want
to be called if there's a match along
with the variant itself and let's now
see what's implementation for the
visitor for a parent so basically have
the member descriptor for whatever
member is stored in the in a variant
like and we don't really care about the
index at this point so we basically
write the string representation of what
store there because it's basically the
format with which shows we get a
reference to what store in the parent
because we need to be able to print
whatever is store in there and we we
delegate that to printer with the
correct type class in a mine so whatever
is stored there we're gonna forward it
to the correct implementation and that's
pretty much it that's how we implement
us a Jason pretty printer using static
reflection and no matter what types you
come up with encrypt this we'll figure
it out and we'll print it for you so
compare that to some of the approaches
people usually do which is like every
time you write a new type and you say a
new container or a new structure you
have to somehow implement support for
that in your pre printer with this at
hand you don't really need to because
trip will give that for free to you
so we don't we don't we pretty much
don't have to change the code for a
printer ever again don't quote me on
that so let's look at serialization now
how could we write a serializer a
serialize ER it's sort of the same
structure as a pretty printer only now
we have to deal with encoding and we
have to also support a serialization so
the way we're gonna do that I also want
a pretty simple interface where you pass
the the object that you want to
serialize or deserialize and a data
reader or do a writer that's gonna
abstract transport or the buffer or
whatever is the media that you decide to
write this this data to so the data
writer is gonna be dead like I'm not
gonna go into the implementation for a
better writer we're just gonna assume it
works but basically you write raw will
write the by the byte representation of
the integer so if you have to deal with
engine s or are encoding this should be
the place and right string will we write
strings for you of the specific type so
as you can imagine you would write the
size of a string and you would write the
data of the underlined date of the
string that could be its rightful raw so
I was talking to to some guys about
Prada both before this talk we could
extend this data rider to say emit
protobuf the probe of layout format when
i need a little chaff you change this
but we can do it and we also have a data
reader too so we can read the things we
wrote with a theater writer this is not
very interesting for reflection itself
but is going to be what we're gonna use
for our serializer so let's see how we
implement a serialize ER pretty much the
same thing as the Chasen player we
figure out the type class of whatever we
have and we afford it to the sterilizer
the proper sterilizer specialization
calling either serialize or DC relies
passing along their writer or reader so
then general the general case is pretty
much like integers and doubles what do
we do we write it wrong and we really
wrong and that's it first rains we write
a string read the string no big deal
for enumeration we write the string
representation of Tina just because we
show we chose to and you read the string
representation of enum any want to parse
it so this feature here like enum traits
: parse it's basically a way to convert
from a string to an enum value it is
pretty efficient internally it builds a
try at compile time which is very
efficient for a strange lookup and
whenever there's a match returns the
value associated with each of the
compile time strings and there you go
you will sign that enum value to the
output of the serialize Oh in this case
parse we'll just throw we have order
we have other very versions that don't
throw we will return you an error code
for this specific example it's this this
efficient so for lists it's it's not
that difficult you write the size of the
list
I trait on the list and write every
single element delegating a proper
serialize ur and this realize you
basically you read the size I'd read
that many times create an element at the
end of the list this realized to that
element you just created and it's pretty
much it this is not a very good API for
lists other than instant vector so if
you use a stud string for instance it's
not gonna work because not the same API
we have we have something we call
container traits in the reflection API
that will abstract for you that for us
as well but just for readability
purposes I didn't use it here I will
upload more demos later to the code base
so you can take a look if you're
interested but it's container traces is
basically a way to say abstract the
containers as well so I don't have to
know what's the underlying plantation
and you are able to to register your own
user-defined container and say this is
my container this is the trades class
for it so the reflection subsystem can
can use that and for sets its
pretty much the same thing right the
size I trade serialized breed the size
I'd rate is realizing to a local element
and then you place that into the set for
maps also the same thing right the size
either eight right the key right a value
read the size hydrate this utilize the
key into a lock of that object create
the element in a map moving the key
either and just this year lies into it
so the next thing is searchers how do we
serialize the structures we know we have
the information for the members so we
can simply say for each on that thing
passes a visitor that will utilize that
for you the members of a specific struck
so we can rely on that for prediction
really cool you actually you might
actually change that so we we could
decide to write a specific identifier
for for the that member and say and
later we can say whenever you're the
serializing check if this identifier
matches something in the strand destruct
we have this information available in
the annotation you can take a look at
this utilization civilization code that
we have for drift if you were
interesting that but again for the sake
of simplicity and for time constraint so
you haven't done it here and now let's
take a look at the serial Iser visitor
take the member with the member
information you get a reference to the
value you see realize that value and you
need to figure out the type class as
well and there you go so most of it is
just figuring out the type class getting
a reference and passing it around that's
pretty much it
like I said it should be boring this
realized same thing you you get the
members you for you write a foreach loop
you pass around to a visitor and that's
it
get the reference the serializing to it
and figure out the correct
specialization for variant serialization
first we have the type itself pretty
pretty soon this is going to be pretty
similar to what we did for
for a pretty printer you have to type
you have to figure out of the street
descriptor do whatever we've done before
which is sort this thing find research
into it call a koala a visitor but a
thing is what if the variant is empty or
like yeah that's pretty much the case if
the variance ape is empty then sort of
search will return it or true if it
finds a match or false if you didn't
find any match inside the type list of
members in this case let's say we're
gonna write an empty string to say hey
there's nothing written there's nothing
there assume this is gonna be an empty
parent and this is the serialize er
visitor for the parent we have the name
here that we get from the member
metadata and we have to write that as a
string so z data the rescue the data
gives us gives us the contents but we
also need the size of the string right
so size is basically what like you pass
any compile-time container be a type
list or a compile-time string returns
you in interval constant with the size
of that container and there we go you
can write the contents of that string
and then you have to get a reference to
the to the variant remember serialize
pass around there we go
this realization you read the string
representing what's in there you okay so
here's the thing from the string you
have to figure out what's the what's the
in a member of what's stored in there we
could for instance parse this string
into an enum and then you sort of search
like we did before but that will not be
ideal it would be much better if we
could just perform the lookup from the
string itself right so we want to look
up in the names of the members of the
variant we don't want to have to convert
that to a now to an enum and then do it
there so how do we go from a
compile-time straining to the sorry from
our runtime string to a compile-time
string it is somewhat similar to what we
did with sort a search but instead of
when you search we're going to build
searcher so say you have a list with a
few of compile-time strings and a needle
which is a run-time string and you want
to look it up
so basically call it try find and what
it does like a mission before it compile
it creates a try data structure based on
those strings at compile time and it
basically looks at the needle up this
should be pretty efficient I have some
benchmarks showing that is much faster
than say looking up in a map or NASA IFS
or whatever or even building a runtime
try and looking it up pass to the
visitor the visitor will be called with
this string if there's a match and will
pass along any of the show arguments you
have same thing we said before and we're
also returning a boolean if they were
telling you whether there was a match or
not and then with that in mind we can
call try fine so we come we pass the
string to it so we will perform the
correct lookup and we pass the visitor
to it and if it's not found it means
whatever was whatever was in the blob
doesn't represent a valid member of this
variant so this will happen if we have
an empty if we serialize an empty event
or it could also happen with we have an
invalid value there like whatever but we
don't really care about that right now
in this example and in this case just
clear this the variant like just make it
empty so this here eliezer we don't note
that we don't receive the member
descriptor here we receive a name of the
member so we have to go from this name
to the member itself so it would be good
if we could perform some lookup by name
in the variant descriptor and say give
me whatever member information you have
for this specific name here that's what
we do here so we use reflect parent to
get the information for the parent and
it provides us by name helper that we
can use for for that purpose and then
you initialize that member inside a
parent like the foe constructed just so
we have the correct the correct type
setting there we do serialize into that
into that thing but we need a reference
to
so we use get to get a reference to it
that's it along there we go now we have
this deserialization for parent members
and there you have it like you have a
full serializer
and working condition so the next and
final example is about like untyped data
translation say you have a map string to
string like very like very common data
and this happens a lot in cold actually
and assume there's a structure to it
this is just like a fantasy example but
uh assume you have information like host
name host port and whatnot since you
have a map and a map is a mad genius in
a types it represents you you have to
represent everything as a string the
thing is for one if I set something in
the map I'm not sure I'm using the
correct key like M did I spell host port
correctly or did I make a typo like how
do I catch this error and also is my
number well-formed like am i passing
some weird strain there that does that
so it would be nice if we could convert
that to a typed representation of this
thing so say you're migrating some API
from the old map of string string to
some to some new API that takes a
structure instead like with actual type
information how do you perform this
mapping there should be a way for us to
say well the member on the left is
associated with the key on the right so
whenever you find this member here
that's the corresponding key in the map
we can use annotations for that and
tripped and say in the IDL this is the
mapping so whenever you have to update
the mapping itself either delete a
member update a member room at a member
you do everything in the IDL and the
code should figure that out for you you
don't have to change any code in order
to do that so it's pretty scalable
because you change in a single place you
don't have to repeat yourself over and
over and for the reason is not error
prone and if there's a if there's a
problem with this mapping here it
doesn't represent a valid member or
whatnot you will tell your compile time
and we want the the public interface to
also be simple it should be as easy as
translate this is what I have this is
what I want right so let's try to get
that
what's implementation for converting
from an untyped data say a map of
strangers training to the typed version
well basically you I to rate on what you
have which is just a map and use the try
fine technique to say well let me know
what's the corresponding member matching
this particular key here but the trick
here is that it doesn't map directly to
the member name it maps to an annotation
for that specific number so we we need a
way to look that up based on the
annotation not on a member name so this
is all additions work in instead of
reflection like you have the inefficient
name which is property and you have the
annotation value which is like hostname
post forward flight and so on so forth
so the thing on the right is the value
associated to that annotation we want
the property annotation this is the
member of the and the name of the
annotation we want we want to get the
value associated to that right we want
to get that from the membrane formation
itself because that's what the that's
what the steroid profession gives us in
order to do that we write a function
that says given a member return me the
property associated with that member
right it's going to look up this this
mapping that you just wrote here in the
ideal and return you the correct thing
so we have to transform this list
somehow to convert the members to the
property values themselves so that we
get the correct mapping this gives us a
type list of properties containing host
name host port and all those things that
we saw on the right here and then we can
try fine on it based on the key that we
got from them from the map collab is ER
past the the value that you have for
that specific entry in the map and
district where you want to set it and
from there on you receive the property
here again this is not this property
not the member the member meditator
right it's just as compile-time string
representing the value of the annotation
so we want to convert that property into
the member descriptor so we can do that
by just performing a lookup in the type
list
fado got here is basically the same as
stat fine giving a list I want to look
look an element in this list and we
basically have say properties the member
we want to look up and the predicate is
get property so basically run grab grab
get property on every element of the
list and match that against property
this will give you the member of
metadata you can use that to get there
together and pass the structure to it
and you'll have a reference to the
element in the struct where you want to
set the value into next thing is you
need to convert the string that you got
from the map from the legacy map you
need to convert that string into
whatever type you have in the structure
right so Foley is an open source library
created by Facebook as well it it
provides this handy converter here so
that you can convert pretty much any
like regular data type say strings
integers doubles you can convert one to
another so from is actually string
member type is whatever the memory type
is going to be it's going to perform a
conversion for you and then you simply
assign one to the other and that's it
sure sure yeah it's just values like
you're looking into a map of string to
string and you sorry the question is
would boost lexical casts work so they
pretty much serve the same purpose
you're just getting us a string and
convert it into an integer that will or
whatever so translate we want to convert
back from the from the flat config which
is a structure to the legacy config how
do we do that there's actually much
simpler because now you have the memory
formation itself you want to get the
members and you know which members you
want to get for
basically everything that's in this
truck right so we don't need to look
something up it's just either eight of
them over the members of this truck so
you passed this memory formation to four
each
all visitor again the same boring thing
in the visitor you receive the memory
information use that to get a reference
to it to the member of the struct and
you wanna you want to also get the
property name associated with that
member and use that as the key but first
you have to convert it to a string right
so we do that now we have the value and
the key itself next thing we do is
convert the value to a string because we
have a typed value from the struck right
it could be an integer convert that to a
string and set it in the map to the
appropriate key that's it and we're
pretty much done so with this code it's
actually two visitors and two entry
point functions we can convert back and
forth from a flat config to from untyped
config to a flat structure what if we
wanted to convert it to not to a flat
structure but instead to a nested
structure saying like I want the config
to contain another struct called address
which by itself contains host import so
on so forth like it could be deeply
nested because it's much easier to
organize information this way we could
simply recurse like we did for a pretty
printer for a serializer and perform
perform the correct conversions
I had another example that I that makes
it much simpler by flattening all the
getters of a specific structure necess
structure so get a simple single list
with every single leaf in the structure
what I had to cut it off of the
presentation for time constraints the
demo will be uploaded though to the
trifa code base so very very shortly you
have access to it I'm gonna provide the
slides with that example as well in the
repo so how do we how do we enable this
like because so far it seems like it's
in a magic like there's a lot we can do
manipulate those types
introspect into into the structure of
the program but how do I get this like
do I have to write a bunch of macros and
manually you fill in the blanks
actually no say you have the module that
rift which is basically the ideal
containing all the types nearer in your
and that you care about and say you want
to call trip just like you usually do to
generate C++ stubs or PC information and
whatnot the only thing you have to do is
add a flag called fatal there's not a
very good name but uh because it would
be much better if we had reflection in
there say generate reflect information
this for historical purposes I'm
changing that and and I'll land soon I
hope to change soon to change that to
reflection but for now that's how we do
it but watch out for this change it will
be reflection in the future and then
it's gonna inside a directory where our
truth usually puts all the files and
generates there will be on a few other
files there as well that it can then
include to have this this type
information and that's all you have to
do you just include the correct module
and you you you set you you use the flag
interest in the trick compiler how do
you import this metadata you just
include a file so first return from it
first struts it's in separate file you
know is yet another file you know is
this basically variants it's just the
way a trip names those things it's in
yet another file the reason we separate
that is because you might maybe you're
not interested in all this metadata just
in a few in a few of them and you don't
want to pay the price for the build time
price for including all of it but if you
do there's a handy header cold
underscore types that you can include if
you have all this there's more
information in the source code there's a
header the main header for reflection
it's called reflections of H by the way
the path is also going to change from
fatal to reflection but reflection that
H contains like a lot of documentation
in line that you can simply take a look
at it explains the to how to how to
generate this metadata how to include
this metadata how to troubleshoot in
case there are problems
information is all there and so if your
closing words some places where we want
to use this we've been experimenting
with I had an intern recently thanks
Dylan who reimplemented all the all the
serialization framework that we have to
instead of generate the civilization
code in the trifa compiler to use
Telegraph lection is tad - to generate
that for you right so impressively
enough we've seen gains in build times
because of that we're still not sure
exactly why but so far we we think it's
because parsing and token validation and
how that that stuff it's very costly so
instead of including the code everywhere
you just instantiate in the templates
where you need so for a specific file
that's compiled by trips you might not
make a difference but for big projects
you make makes a lot of difference like
I don't have numbers because I finished
those lies like 30 minutes ago but but
uh we're still experimenting with that
there are still some improvements we can
get let's see let's hope for the best
there's also runtime performance just
because we we think it's because the
compilers do a good job at optimizing
templates I'm sure there are a lot more
we can do but uh things like the
building to try a compile time or
building a sort of list at compile time
it's work that you don't have to do it
at runtime
right and also some other things like
there are a lot of transformations that
we're doing the types themselves that
are done at compile time and don't have
to we don't have to pay the price for
them at at runtime so that may also be a
contributor to that and civil size
reduction just because we have we have
come full control over the
implementation of serialization we will
also have that with regards to the tree
from file right but uh the thing is if
you write a sterilization for a specific
structure you have to either put that in
the structure itself and say read write
forever or you can write a separate
specialization but the name of the
structure has to be there the name of
the members have to has to be there so
you don't
much a lot of control over the naming of
things with this there's there are lots
and lots of templates that we can
actually just change the names and
shorten them so that the symbols
themselves can can reduce your size and
also because a lot of the transforms are
done at compile time every every time
you see a using statement
that's computation that's not being
generated as run time so it's a function
that's not being emitted so that's less
code to compile and less symbols to to
include in your binary nearly across
language extensions we just we just
talked to some some guys that work with
Python in Facebook we don't have a lot
of we don't have any products yet in
this but we're we're interested in for
instance using this to generate the
Python bindings instead of generating
Python code so it's a lot less code that
you have to generate in Python a lot
less code interpreter has bars and
basically you can have the reflection
subsystem take care of generating
everything for you all you need is a
call to one function that will generate
all the types you need and register it
in the Python interpreter and I think
the biggest gain from this is cheaper
experimentation should you have a need
for a different sterilizer or you need a
compare for destruct the specific struck
here or you need say a specific
transform like merge or whatnot or
pretty printer you don't have to change
the trip compiler in order to implement
that you can write that as a separate
library that's not intrusive because it
doesn't change any other code it was a
separate file that you don't have to
include if you don't want so it's much
cheaper for it to experiment with
you need to to be able to to to write
metaprogramming what is too much cheaper
do then understanding how the trip
compiler works and changing that and
believe me it's pretty messy and run
time reflection all of this that I
presented is based the compile time
reflection right but a metadata is all
there and you we've seen that there are
ways to convert this compile time
metadata into runtime information so I'm
playing to to investigate a little bit
and how to convert that to runtime right
now
there there's some benefits to it for
instance buuuut times you don't have to
instantiate a lot of templates you can
simply use like Ida read over data you
pay the price for rent time performance
but in some some occasions you just
don't care right and also although
runtime reflection is a bit a little bit
limited because you don't have access to
the types themselves there is a lot more
people that can use the runtime
reflection then there is people that can
use competin reflection so you wouldn't
need matter programming skills in for
instance to use rent and reflection so
it's something that are also planning on
adding soon C++ time support this is not
at all a take into suggesting something
to be included in the in the standard
basically people I'm sorry basically
because this is not generic enough to be
used by C++ it only fits tricked use
cases which for us does the job most of
the time but I think the the best thing
that this can provide to whoever is
writing a proposal for first hander for
reflection is basically this this is
those already used cases we've seen so
far where reflection can be applied
those are way that the ways that we
modeled compiled reflection for this
problems so they are good some of them
are not so much so it's it's a way for
you to see it's a different perspective
where you can see what can improve can
be improved here what is the good things
that we can reuse and what not and what
use cases should it be focused on and
and that might my proposal should
actually address and the last question
is why not write then a compiler branch
C++ like say for a clang or GCC well
several reasons one is this is not
generic enough and will take a lot more
it will be a lot more costly to
implement something that's simplest plus
worthy as opposed to something that
suffice is the subset of strict that we
care about there is also another reason
inte R if there's a single
implementation of this if we were to
change the compiler we would have to
support
clang and JCC and probably Visual Studio
I don't have access to the sources of
users to do and whatever other compilers
that people decide to use by having this
encrypt this is pretty much C++ 11 so
any compliant compiler can can use this
by doing that in truth it's just it's
just cheaper for us to do it the only
downside is there is that now you have
to include a few files to have access to
this but you might be fine with it
hopefully I will delete most of this
code whenever reflection gets in the
language I very much want to do it but I
think for a while now I won't be able to
so let's use what we have as an
experiment with it while we can so that
when we get something we have a much
better idea of what we want in how we
can accomplish that and before I go I
just would like to use the remaining
time for any questions that you guys may
have like I said before yeah sorry the
question is what is uh what is the what
is the reason for having a static
reflection as opposed to rent the
reflection if I got it correctly well
for one I can generate runtime
reflection from static reflection I
cannot do the opposite like I said is
there a runtime reflection is supported
I want to add and it can use very
similar techniques to get that the other
thing is that return reflection is
pretty limited because they don't have
access to the types like I said before I
would not be able like it wouldn't how
would you I create over a structure
using runtime reflection there's a lot
of interaction type erasure that you
have to get in place and that that has a
cost at runtime right and also runtime
is also in our reason like we we work in
a you know in a very large scale of
Facebook and we care a lot about
performance by having a lot of the
computation happen at compile time
sometimes it bothers developers and I
completely under
and that because you have to wait longer
for it to compile on the other hand it's
it's like when you put that to thousands
of servers out there there's a lot of
benefit that it can get out of it right
is less time that you're processing all
those services all the server's so yeah
that's pretty much it all right so there
are more questions thanks for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>