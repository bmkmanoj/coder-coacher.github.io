<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Billy Baker “Almost Unlimited Modern C++ in Kernel-Mode Applications” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Billy Baker “Almost Unlimited Modern C++ in Kernel-Mode Applications” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Billy Baker “Almost Unlimited Modern C++ in Kernel-Mode Applications”</b></h2><h5 class="post__date">2017-10-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4AMhgkLjVHM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- [Audience Member]
Every single one of them.
- Thank you everyone
for attending our talk
on almost unlimited C++ in
kernel-mode applications,
and you may be wondering
why're you're here.
I'm sure it's because
you're expecting death,
destruction, mayhem and panic
because that's sort of what you get
when you program in the kernel.
And if you did not believe that
obviously we can step back
in time and see some quotes.
Now I did not verify these quotes,
I did not change these quotes.
But, urban legend says they're true right.
25 years ago, maybe it wasn't a good idea,
and this continued on with saying
exceptions are bad.
Memory allocations we
don't like to see those.
I have plenty of coworkers that
malign C++ for the same reason,
and it's problematic for me.
This doesn't help.
This popped up about 20 days ago.
The left hand side says
I'm going to call through
a function pointer Do.
It's never actually set to anything
but the compiler has assumed
that never call was executed at some point
because otherwise the
program would be ill formed
and if you can read the
disassembly on the right
you see that it's going
to remove all the files,
or at least attempt to.
So if you're here the rest of the week,
Wednesday and Friday, there's a couple
of other talks on undefined behavior.
Now 2004 was a very
interesting year evidently
because Windows had some discussions
about programming with
C++ in the kernel as well.
The bold here is my addition,
and it explicitly says that while
we may not expect to use C++ in the kernel
given the right implementation,
and right execution environment,
all things are possible.
2012, to jump ahead a little bit.
Visual C++ wound up
getting this little option.
And the game programmers that I talk to
love to disable exceptions.
Love to turn off RTTI.
New and delete we're back to there.
The only problem here that I see
is that we also limit the
instruction set that we can use.
So if we really wanted to do something
other than maybe a print
driver, a network driver,
something that used the full
capabilities of the CPU,
we're outta luck.
Unless, you might do some
own Assembly programming
or other things like that.
How lucky am I?
It's just a blue screen.
I'm sure we've all gotten them.
Okay, so 20 years of
programming flight simulation.
This is a smattering of
the different environments
that I've, either directly worked with,
or read code from.
A lot of them are Unix-like.
The three bolded ones
are very interesting.
We're gonna use Windows, Visual C++
and try to do something real-time.
And the first one there On Time
is different than the other two.
In that, it is a pure operating system.
For the InTime and RTX choices there
the system actually boots to Windows
for there is an operating system
on some subset of the cores.
Then you have this other operating system
sort of hanging out in your system,
not quite virtualization, but it's taking
the rest of your cores.
And that's where all the magic happens.
Now, boost.
As of 1.64 these were
the platforms that were
in the platform directory.
I did not look at 1.65, sorry.
It covers half of my list
from the previous one.
For that InTime in RTX Windows options
that I had on the previous
slide, those are mostly gonna be
directed at Win32 here, because
they are trying to emulate
the Windows API.
Alright, has anyone here actually done
Linux real-time programming?
Okay, we got one here.
Pretty common diagram.
It did not take me long to find these.
I coulda found plenty more.
Basically, we look to do
things like separate your
nonreal-time processes from
your real-time processes.
The image on the right
shows explicitly doing
real-time on half the cores
and non-critical applications
on the other half.
So, I will directly ask Jeff.
Pretty common?
This particular...
- [Jeff] I don't know.
I just did it for the first time recently.
- Oh, for the first time recently.
- [Jeff] (laughs)
- It's pretty common, Jeff.
- [Jeff] Okay. (laughs)
(laughter)
(laughing) So, for Windows in real-time,
obviously Windows itself is
not going to be real-time,
but if we look at these two
extensions InTime and RTX,
they're really a lot alike.
They're pretty much limited to
the Intel AMD architectures.
They do the same thing that I
showed on the previous slide.
They want to segregate CPUs
that are doing real-time
from the other CPUs.
There's a big problem, though.
In a lot of this real-time work,
we don't have latest hardware.
We have lots of old can-bus
stuff sitting out there.
And that really is low-volume stuff.
And a lot of the times,
it not does not use
latest interrupt architectures.
So, these two particular
solutions don't allow you to share
interrupts between two devices.
Between a real-time device
and a Windows device.
And it gets worse.
Even something like a
PCI Express Bridge chip
that might take an
interrupt, can't be shared
with one of these devices.
Which is a bummer.
Likewise, you see here the
shared libraries are an issue.
These two platforms want to explicitly
deny you all access to Windows DLLs.
And then, there's the
big difference there.
InTime wants to do user-mode,
lots of protection,
and RTX doesn't.
So, I hope you can see
where we're going here.
If we're gonna talk about C++
programming in the kernel,
and I've highlighted things in bold,
we're probably gonna be talking about RTX.
This is image out of the
InTime documentation.
Being a user-mode application,
they look very much,
toward separating memory
spaces between the processes.
And that gives them a
higher level of reliability.
RTX though, being down in
kernel-mode, not so much.
Shared memory across the
board, Windows apps, RTX,
all access the same memory.
Driver creation under RTX
much, simpler than anything
you would ever do in Windows.
So pretty much, you make one
function call to register
and interrupt handler, and that's it.
Now, couple of weeks ago,
there was this conference,
and one of the consumers
of flight simulators
didn't have some very good things to say
about the products they'd been receiving.
To the point where they really do not want
a Windows product anymore.
Whether it had an InTime
extension or an RTX extension,
and some of these things
that they list here
are not even real-time related.
IOS here, is an Instructor
Operating Station,
not the MAC operating system.
Pure Windows application,
they're saying that they
hate their product basically.
And of course, my
response to them would be,
okay, you want Linux, but
there's plenty of examples
where you can do bad things.
Yeah, Toyota break case scandal.
Anybody have a Toyota?
Nest thermostat, lots
of cold, cold people.
(laughter)
Alright, so there's a book
that's on the table from Chris,
I will not attempt his last name.
Talks about real-time C++
and he, in the preface,
talks about the CPU
environment that he works with
and that's much more
towards the microcontroller.
So, small memory size, small code size.
But that's not what we're gonna work with.
Lotsa cores, lotsa memory.
For a flight simulator,
airplane in general,
you have lots of distributed systems,
sensors all over the
place, lots of black boxes.
And from a simulation
standpoint, that same vendor
that didn't like carrying Windows,
also doesn't want to have a lot of boxes
that they have to boot.
So they really want you to bring in
all of the simulations of different pieces
and put them one-to-one system.
We have lots of cores now.
We have a real-time operating system
that will take advantage of them.
Go for it.
So, talked about an operating system,
talked about CPU architecture, compiler,
we'll certainly be using
Visual C++ in this talk
and there's this issue of
freestanding versus hosted.
If we were only gonna stick
with the freestanding 16 headers there,
absolutely no problem
whether it's in user-mode
or kernel in this particular case.
The other headers, not so much.
And that's where most of
this talk will be going.,
is talking about the
problems that we encounter
in some of these other headers.
Random Device, start
with something simple.
Very simple application.
You just want to potentially
access a piece of hardware
to give us random numbers.
For Visual C++ 2012, the constructor calls
an external function which
winds up calling Rand_S
from the C Runtime, which looks
for RTL Gen Random via DLL.
And of course, that fails.
- [Marshal] Didn't you say something about
never sharing with DLLs?
- I most certainly did, Marshall.
Keep that thought.
- [Marshall] (laughs)
So, for 2012 we return
ENOMEM, exception gets thrown,
we can handle it, as was
shown in the previous example.
You jump forward just a few years
to one of the newer Windows 10 SDKs.
Rand_S changed just slightly.
Now, there's this System Function 036.
Of course, we all now what that is.
It's basically a synonym
for the RTL Gen Random.
In making this change, they also said,
there is no fallback.
Windows will always have
System Function 036.
So we abort now.
And bad things happen.
So, yes Marshall.
You asked about shared objects.
For working in Linux
kernel-module access other kernel-modules,
everything is great, Windows
if you're in export drivers,
all that stuff goes together.
RTX yes, no DLLs, different
entry points et cetera.
But we can still fix this, sort of.
We can supply our own rand_s.
System Function 036 is available
and for the infinite test
I ran of two, it always returns zero.
So, no random numbers there.
Most likely solution here
is just to write rand_s,
always return ENOMEM, be done with it.
So lets move on to the file system.
I know for a bare-metal,
very constrained systems,
we probably don't have a file system.
Most likely, we're just going
to put our data into memory,
it's at address whatever, zip through it.
But here's the, basically,
equivalent of what the file
system specification says for file size.
Basically, we're gonna call stat,
we're gonna get the size of
the function and return it.
So, for RTX, this winds up
giving us eight unresolved
external when using the Windows SDK.
It's a little interesting because,
if you looked at this implementation,
you'd find that Find Close happens to be
in an unnamed name space
with a couple of structs
and tag defs that aren't even used.
So, we have a false dependency.
Peek Named Pipe we might
want to stack a pipe
as well as a file, so it's in there too.
Stack, if that were the only problem,
yeah, maybe we could work
around it, but there's more.
We have no environment either.
So we have no current working directory.
Which means we have no
relative file paths.
We have no directory
traversals and on, and on.
So, from the standard level, Titus Winters
and a few others, came up
with this proposal to say,
file systems in general, are a problem.
We might want to do some
user-injection file systems for testing.
I talked to Titus in Toronto.
And there's a possibility,
whether I implement a full
file system specification
or something like this,
if I really want those things to work.
Still up in the air.
Path, another part of the file system
that's part of our
vocabulary in some respects.
For 2012/2013 Microsoft
shipped an implementation
of path that was, just pretty
technical specification.
The character type was char,
header only, path worked well.
2015/2017 got a rewrite
and now we have this dependency
on some external code.
The external code winds up bringing in
lots and lots of file
system-related APIs from Windows
that just aren't available.
So, no file system functions, no path.
We're back to, probably
mapping files into memory
and going from there.
- [Audience Member] (speaks off mic)
Yes. Marshall was making comments about
not having a file system.
Having file system functions fail
is perfectly within the standard.
Correct? Yeah.
- [Audience Member] (speaks off mic)
- Alright, random numbers, file system.
How about threading?
Anybody wanna guess how
well threading is supported?
That's a pretty simple example.
We're just going to create
a thread that does nothing,
and we're gonna join on it.
Yeah, so for 2012, we wind up
with 17 unresolved externals.
Got a little better for 2017.
Microsoft changed their
Runtime from using Concurrency,
they're own Concurrency
Runtime, to making direct
operating system calls.
Still, a lot of unresolved externals.
Deep down in the layers
of the Microsoft Runtime,
you'll see that creating a
thread winds up needing to do
some sort of synchronization
at the thread-creation level.
So, it's got mutexes
and condition variables
that are going on.
And RTX has a history of about 20 years
and they never had the need
for a condition variable.
So, immediately that one's out.
Mutex, they implement
Windows APIs for Mutex,
but there's something else going on there
that makes that one problematic as well.
Duplicate Handle, we're in the kernel,
we don't duplicate handles.
It's just the thing.
So that's a problem as well.
Boost though, we have to
congratulate Vincente for his work.
Only three unresolved
externals for the same example.
The first one though, is
actually available in RTX.
And the second one, we wanna
know how many processors
that we could use for
concurrency, so we get a call in
to get logical processor information.
The third one's kind of
interesting, Local Free.
Down in the system error,
when we call message
for system error category,
it winds up needing to call
Format Message on Windows
to take the error code
and get a message back.
And if you don't pre-allocate the memory,
that function will allocate it for you.
If it does that, then you
have to call Local Free.
Okay, Microsoft in their
implementation though,
does something a little differently.
They go ahead and pre-allocate the memory
and they do it twice.
First time is a narrow allocation.
The second time, they're actually
calling Format Message W,
so you have extra W chars,
convert it to narrow,
and then up the chain.
Okay, so we're still in threads.
Stacks, Windows kernel 12 and 24K, RTX 8K.
Very small amount of work
that we can do on that.
Although, quite powerful amount of work,
if you think about it.
Currently, for thread in
the standard, we have no way
of actually changing the stack.
And there's at least two
proposals that talk about
at least exploring the idea
of are there requirements
that we should capture
and do things to expand on
our capabilities with threads.
Other problems that we have here.
There's no start, there's
no stack guard pages.
So if you've got 8K, 16K whatever,
you go off the end of it,
you can keep going.
However, since this is
Windows, Visual C++, RTX,
from a testing standpoint,
we can jump back over to Windows
and create our threads with
this stack size parameters reservations.
So, when we say 16K, 32K whatever,
you do get a guard page on Windows.
So, you can test.
If you go over, exception pops up,
you know I need to create my threads
with a larger stack size.
Likewise, there's no memory protection.
So, if everyone's ever dug
into Address Sanitizer,
you'll see that at some
point it's doing something
to manipulate the pages in
memory to make them Read Only.
Not gonna work here.
Alright so, summary on
RTX and C++ concurrency.
Atomics and lock guards work really well.
Just about everything
else, very problematic.
And Gor was supposed to be here.
Coroutines again, very problematic.
The compiler is going to
have to generate calls
behind the scenes for
you, just won't work.
Call Once, I'm listing
here as being unknown
because it should work.
We're gonna investigate
that a little bit more.
Very simple example.
We have a function with a static
and we have to do constructor call.
If you compiled this in 2012, lets say,
you'd get something like this disassembly.
There's two function calls in there.
One's to the constructor
the other is to _atexit.
Not a lot going on.
However in 2015, a new default
was added, Thread Safe Init.
And if you'll look closely
at this disassembly,
you'll see that there's
an Init Thread Header
and an Init Thread Footer that's going on.
We're also accessing TSS.
Lots of weird things going on here.
And in this particular
case, when I tested this
the other day, it actually
crashed the application.
So, not good.
You can disable this ZC Thread
Safe Init minus, it's gone.
Clocks, another of the
RealTime functional areas
that everyone has to do something with.
This is pretty much the
same example that you'll see
from Howard Hinnant in stack overflow.
It's in the RealTime C++
book, a few other places.
Our time duration here's
a 100 nanosecond units.
Windows pretty commonly uses that.
In some cases, I've seen
people implement these clocks
using the timestamp counters.
Just an RETSC for Intel.
And that's great, fast access.
So long as you stay on one
core, you're guaranteed
of having timing numbers
that you can believe in.
Once you start going off
cores, then there is no real
synchronization between these two.
In the case of having Windows
and this other extension,
We see Windows start try and
synchronize all the TSCs.
And then at some point later,
this other operating system
starts up and decides
it wants to synchronize
all of its cores.
So now we have this large delta T between
two operating systems that
are sharing the same system.
There's lots of other
timing sources in your PCs.
There's the DRAM refresh
clock, there is the USB clock.
This one was introduced in about 2004
and gets really squirrelly.
Even if you have 64 bit
Windows operating systems,
a lot of the time it is
put in to the 32 bit mode.
And it's more expensive to
read time values from this,
but they are going to be
one single clock value.
All your cores will be fine.
We're gonna get through a
little bit of the implementation
that I was working on
for this, many years ago.
And this implementation took the view of,
I'm in the kernel, obviously
nobody else is using this.
So, I'm going to enable it
and when I'm done with it,
I'm going to disable
it, set it back to zero,
Because I can.
Anybody wanna guess what happened?
Odin?
So, I'll give you a helper here.
There's two operating systems.
I just made a big assumption
that I'm in control.
I really shoulda done something like this.
If you're familiar with
the title of this slide,
it comes from the movie The
Day The Earth Stood Still.
So, if windows is over here,
using this particular source
for it's clock, and you
go and set it to zero,
you're rebooting, or you're
waiting however long it took
for your system uptime, for the clock
to come back around and catch up.
(laughter)
Exceptions, I have absolutely
no problems with exceptions.
Even in RealTime.
Part of that's because
of other developers.
Certainly being in the kernel,
I wanna know when things happen.
And we have a very simple example here.
An example that I see quite a bit.
The string that's passed in,
once we throw the exception,
needs some place to live, other than...
Well, it's a string, it'll so...
A copy winds up being made
of the string, so we wind up
allocating memory to hold this string.
We're already in an error case.
We're throwing an exception.
We've probably jumped out of our RealTime
deterministic execution, now
we're gonna allocate memory.
In this case of Windows
RTX, Windows InTime,
your memory still basically
comes from Windows.
It has to know what's available.
So, whenever we allocate
memory like this, we have to do
some bookkeeping back over to Windows.
As it turns out, we have to
complete all other threads
that might be ready as well,
before we do the jump back to Windows.
So now, we've had an error condition.
We've decided to throw an exception.
We've needed to allocate memory
and we just destroyed our timing sequence
because, we've executed
everything out of order.
Pretty bad.
Possible solution, just
create your own exceptions
that return the string, in this case.
So now, we still have the error case,
we're gonna throw an exception,
but we're not gonna allocate.
We're still gonna execute in order
and at least some of what we expected,
will still occur correctly.
The other part of exceptions,
getting away from the standard.
On Microsoft, if you didn't know,
we have set unhandled exception filter,
if you compile everything with slash EHa,
which is a different mode
of exception handling,
you can actually catch things like
floating point exceptions,
access violations,
stack overflows et cetera.
If you also happen to be in 64 bit land,
you can do a pretty good job
of capturing all your registers
and your stack backtrace.
So, if it weren't for liability,
this would be something
that you'd want to build in
and something that's very possible.
Now in boost, just recently,
Antony provided a nice
library to do stacktraces
and there's at least three
options that are available for Windows.
In this particular case
though, the first two
that actually try and do
something with the stack,
both want to use COM.
We're in the kernel; no COM.
Okay so, another library
that's not available to us.
Well, unless we just want NO OPs.
Other problem with being in the kernel,
completely different loader
than what Windows is using.
Completely different loader
from what Visual Studio
and all the debug tools
was expecting to be used.
So, now you've got addresses
that are nowhere close
to what your PDB thought
they were gonna be.
So, in this particular case,
we're having to compute
offsets, not actual addresses,
and then, post-process our stacktraces
with those offset information.
Short break here.
Talked a lot about various
things within the RunTime.
Modules really better not
cause anymore heartache here.
They shouldn't be.
Unfortunately right now,
Microsoft's implementation,
since we're talking about Visual C++,
is only providing the DLL RunTime versions
of the interface libraries.
It's not a technical issue.
It's the only thing that they've put out.
They're not supporting RTX,
so they wouldn't see this
as a must need to put that
out, but small issue right now.
So, we've talked about C++,
in this particular case,
there are at least three other languages
that I've managed to stick
into the RTX environment.
Fortran, quite a bit.
D not so much, certainly possible,
and I've had several
functions from D working,
but I won't say that I'm an expert in D.
Lua though, perfectly acceptable
to link into the kernel
in this particular case.
There are some pieces of lua
that are file system related,
imagine that, and I
forget the other piece,
that do create problems.
But if you just want to use a lua script
and do some things, no problems.
Okay so, much like C++ we're gonna do
a little dissection here
of the Fortran runtime.
Math functions, Fortran certainly wants
to use math functions.
And in this case, Intel Fortran
not optimized in the code
most of the math
functions can be satisfied
with a C runtime.
There is, lest say, in the
order of 10 that can't be.
If you look at strings, it's
a little different story.
The Intel compiler for
Fortran, generates at least
three runtime calls to do
comparisons, concatenations
and copying of strings.
And if you've ever worked with Fortran,
things get interesting with
strings because we want
to pad with spaces at the end
instead of null termination.
And so, comparison and
concatenation winds up
with some quite strange algorithms.
Compaq Fortran, slightly
older from the Intel work.
Didn't have any problems as
far as needing runtime calls.
It just implemented
everything right in line.
Fortran compilers, in
recent years have also had
modes where you can
enable bounce checking.
And of course, when a bounce
check violation occurs
it wants to call into some
error reporting function,
and the error reporting function
wants to pop-up a dialogue.
It doesn't happen.
Compaq Fortran did not
have such an option.
So, in this particular
case, taking Intel Fortran,
compiling that into the kernel,
provide a few math functions,
provide the three string functions
and provide a little
something for error reporting.
If you're in a bounce checking mood.
And speaking of bounce checking,
with newer Intel architectures,
we have some new registers,
some new instructions and we can
do some of this in hardware.
And since we're already implementing
our own thread library evidently,
we can then just add this as well.
Currently, if you've got an application
that's trying to use MPX, you
wind up having something else
sitting out there that's
hooking the create-thread calls,
so it can create all
the necessary resources
to do this particular work.
And if you happen to be on
GCC, interesting conversation
that popped up on a mailing
list recently, I guess,
I have not used this on GCC,
but there was a perception
that they were going to deprecate
this, at least one person
thought so anyway.
And upon posting a change to
deprecated, the response was,
no, we aren't deprecating it,
I don't know what's going on.
So its still in GCC if you
continued on the main list trend,
it said that it is
problematic in some ways.
Although, it did not go into details.
For Visual C++ it's
got added in update one
and you can give the nice
command option there of d2MPX
as well as adding the
additional resources to hook,
to create the right calls.
So, performance monitoring.
Absolutely none of the applications
that you might wanna use
are available to you since
you're running in the kernel.
That doesn't mean that you
still can't compile your code
for Windows, compile for Linux,
run the same applications.
But hey, we're in the kernel.
We can execute read-model
specific register
and write-model specific register.
So we can actually implement our own perf,
our own Intel PMU, our own
Vtune, whatever we want.
Likewise, you an go out
to the memory controller
and get your bytes read and bytes written.
You can look at cache management.
You can deal with quality of service IO,
and on, and on, and on.
In the case of performance
counters, you don't really have
the restrictions that you had
with the Hpath that I showed
earlier, in that the model
specific registers are per CPU,
so we can actually collect
per thread, per CPU,
whatever we want.
Memory controller's a little different.
That's per system, if you
have one CPU, it's per system.
So, if you've got Windows and
RTX sitting in this system,
you're gonna have both.
And I'm gonna be done really
early, so I hope you have
lots of questions.
You didn't ask any while
we were going through.
So, the purpose of this
particular talk really was
to try enlighten, I guess.
To let you know that sometimes
you're given scenarios
that really don't work together.
And Microsoft Visual C++
team is not supporting RTX.
Interval zero is not really
supporting Visual C++.
So it's, as a developer I have to do
all of these little things,
like providing a rand_s,
if I want it.
Providing a thread
library if that's needed.
Modifying boost if that's the
decision that we wanna make.
And with that, I will open
the floor for questions.
And Odin will walk up to the microphone
and ask his question.
(applause)
- [Odin] You mentioned that
you are testing by compiling
to Windows proper that has
a page guard to the text,
like stack overflow.
But, two questions there.
If you're doing customizations
like swapping out calls to
DLLs or kernels or whatever,
you're not executing
the same code for one,
and especially in light of
exceptions, you're probably not following
all theoretical possible paths.
So how are you sure that
you saw a max step there?
So, the first part.
If I'm testing in Windows,
I'm not exactly testing
what I'm running.
Absolutely correct.
And I will say that I
spend quite a bit of time
trying to make both environments
as close as possible.
So that I can say, that I am executing
as many of the code paths that
I would in both environments.
The second part was...
- [Odin] Like if something
throws, that could potentially
be, you know, thinking Machiavellian case,
a longer exception sorry, a deeper stack,
than if you didn't throw.
Or if you have some really weird...
- Sure.
- [Odin] Yeah.
- So, you'd like to say
that post initialization,
absolutely no exceptions
are ever gonna occur.
Right? And so our call stacks
will always be the same
and our timing information
will always be the same.
It will always work the
way it's supposed to.
That's not the case.
Some people will use
exceptions for flow control.
Very important to monitor the system.
I mean, if you're not
monitoring, you don't know
that somebody has done
these type of things.
So being a library developer,
I'm not going to be reviewing
millions of lines of code
to know where somebody
actually decided to throw.
I can report that an exception occurred.
I can provide the framework
so that all of the timing
is always being done, so it's constantly
monitoring the system to know
if something is executing
not the way we expected it to.
That's pretty much my answer.
At some point everybody has
to get onboard and accept
that if you're throwing
exceptions, you're starting to
go outside the bounds of what
the system was intended to do.
Yes, Jeff?
- [Jeff] Did I understand you to say
that you're using Fortran in kernel-mode?
And if so, what was the application?
- So, 20 years of flight
simulation, there's even
another 20 years of
Fortran code out there.
Yeah, lots and lots of Fortran code that,
when you're talking about having
an air dynamicist program,
who still knows Fortran,
the execution environment
has been given to them.
They were totally unaware of that.
They compiled the Fortran code.
It produces an object file.
It gets linked into
something, and off we go.
If you switch to something
like MATLAB instead of
programming directly in
Fortran, then you've got
super code bloat and other issues, but...
- [Marshall] (speaks off mic)
- Yes, as Marshall was
commenting, once you start going
through code generators
that produce lots of code,
then you have a whole
nother set of problems.
So yes, Fortran definitely it's...
In 20 years, it's been
trending away from Fortran.
More people view Fortran
as being a dead language.
And so, from a personal
standpoint, they say,
I want to do something that's more modern.
I wanna use C++.
Yes, sir?
- [Audience Member] Just
curious, I mean, in Windows
and DOS to deal with long
call stacks, or sometimes,
when like in case of file
systems on networking,
it's hard to control
how deep gonna be stack.
They introduced, you can
request another stack
as long as you control those
points where they could expand,
you could do that?
Does it work for you or it didn't?
- So, dealing with the stack.
Yeah, pretty much you can
do whatever you want to.
If I had wanted to, I could
have put in my own code
that detected how far we
were going in the stack.
Oh, we're about to cross a boundary,
lets do something else here.
But that gets back to Odin's question
about what are we testing.
Do I want to produce more and more code
that I have to test, that may be different
between the two environments?
Or do I want to sorta do
some faith here and say,
I will test it in Windows.
I will have the stack guard.
Once I've got results, then
I will switch back over.
Now, we started talking
about a flight simulator.
Switches all over the cockpit,
you can't test everything.
- [Audience Member] Sorry,
I probably missed this part
but, when you're saying switch back,
between what two environments
you are switching?
User mode and kernel mode?
Or Linux and Windows?
- So, Windows would
certainly be user mode.
Most of what I was talking about,
was dealing with kernel mode.
- [Audience Member] Okay.
- Yeah, so if I'm in kernel mode,
I can manipulate the thread
block however I wanted to,
and replace stacks and do
pretty much what I wanted to.
I don't want to do that.
- [Audience Member] Oh, but
it's standard, like API now.
It's not that you have to that.
It's just...
- It's a standard API in Windows.
- [Adience Member] Okay, in Linux.
- In Linux.
- [Audience Member]
Okay, got it, thank you.
The other side of the room
can ask questions too.
(laughs)
Yes, sir?
- [Audience Member] What is
the problem with coroutines?
- Coroutines?
- [Audience Member] Yes.
- So, a coroutine to the user
looks like normal function,
would you say?
I mean, you don't see any explicit calls
to anything to, well, you've
got the awaits and yields
and things like that.
What the compiler generates for
those particular spots in...
- [Audience Member]
Allocation, allocation.
- Allocation, yes.
- [Audience Member] (speaks off mic)
So, this board is more
into the business side,
not the technical side in
that, coroutines is quite new.
When we talk about a RealTime system,
we tend back into the old beliefs that,
oh only C cane be used.
I've got this legacy compiler
that's never being updated
on, and on, and on.
The operating system that I
was showing and talking about
RTX, it tends to lag behind.
So even if I was using coroutines,
there is a very good chance
that whatever RunTime calls
were needed to make that coroutine work,
weren't gonna be available.
So you would ger unresolved
externals as well.
- [Audience Member] (speaks off mic)
(laughs)
- So, I was hoping that
Gor was going to be here,
so we could have a little
more discussion on that.
If you want to talk to me
tomorrow, the rest of the week,
I'll code something up and give you
a more definitive answer.
Yes, Odin.
- [Odin] You mentioned in the beginning,
that you are working in
kernel mode callbacks or IOQs.
- So, for the interrupt handlers?
- [Odin] Yeah.
I don't know how the Windows kernel works,
but don't you have like, a really hard
(laughs)
deadline of how much
time you can, you know,
how long you can take in a...
- So, from the Windows side,
we're a general purpose operating system.
We don't want to delay.
We don't want to give an
unresponsive environment
to a human user.
- [Odin] Yeah.
- Most of what I'd been talking
about for flight simulation,
there's no real user involved
as far as through a GUI.
We're processing IO, we're computing
equations of motion et cetera.
So, in that particular
case, the interrupts
are still an issue.
We certainly don't want to
delay some of our execution
because we're handling interrupts.
And I think that really gets
back to knowing the system.
And I can't say, writing
your own network stack,
writing your own network
drivers, when somebody
plugs in another system on your network,
and all of a sudden, you're
getting spanning trees
and other things.
If you're not detecting
those things, all you know
is your system sorta becomes unresponsive.
So, again that gets back
to my response about,
we're monitoring these things, we see,
oh, all of a sudden, we got
more interrupts per second.
All of a sudden, our
interrupt time has shot up.
Something's going on and
something needs to be done.
It's kinda funny because,
when you report these things,
saying that, hey, you know what?
Somebody is sending me
ARP every now and then,
but that system's not on this network.
Some people sorta take offense to that.
Well, you know, I'm using
the operating system
that everybody else is using.
You're not.
And you're the person that's
telling me I'm in trouble.
And it's like, yes, because you are.
(laughs)
Does that answer your question enough?
- [Odin] Pretty much, yeah.
I guess, one sort of, variation on it.
Like, how do you reason about
longests theoretical processor?
- So, worst case execution?
- [Odin] Yeah.
- I think some of the people
that I've worked with say
that I just sort of walk out
and put my hands on systems
and go, yeah it's good.
But that's not what should happen.
In some cases there are systems that are,
so the flight simulation
itself is much more tolerant,
lets say, of higher jitter.
- [Odin] Yeah, yeah.
- Systems that are much
higher frequency, that have
hardware in a loop, they aren't.
Well, we're writing the
same software in both cases.
So, we sort of use that
hardware, very intolerant system,
as our baseline, and
if we can do that one,
then everything else
should fall out from there.
- [Odin] Okay, but it's
still just guessing
and then testing, essentially?
- Yeah.
- [Odin] Okay.
- Guess and test.
- [Odin] (laughs)
- Yes, Scott.
- [Scott] I feel your pain.
I mean, I work on a
lot of strange consoles
and things and ROSs.
They're not really standard
and we end up with similar
issues here and there.
About using NC C++ features
so, interesting talk.
- Thank you.
- [Scott] What do you end up
doing about much of this stuff
is kind of my question, though.
- Are you asking do we
contribute back to boost,
so that everybody could do this?
- [Scott] Sure (laughs)
For example, what do you
do about it? (laughs)
- So as far as boost, I
will say that in the past,
I've talked to plenty of boost developers,
and I've said things like:
Oh, yeah I don't use boost.
And the example that I
showed for boost thread,
actually was worse,
lets say, 10 years ago.
There were more unresolved externals.
It's gotten better.
And that's a big generalization.
I don't use boost.
Boost is huge.
Certainly not everything in
boost uses the operating system.
So, there is plenty of
boost that could be used
in this particular environment.
Beyond, what do I do?
Try and keep the hardware
as long as possible.
Much like a console.
Try and keep the compilers
the same as long as possible.
Which gets back into our:
Oh, I'm a new developer, in school,
I was using a using a newer
version of Visual Studio,
why aren't we using that here, problem?
Hardware, operating system,
likewise, operating system
we try and keep the
same for quite a while.
Flight simulation though, a
lot of military customers.
So, when the government says
everybody goes to Windows 10,
if this particular RealTime
extension isn't currently
supporting Windows 10, it does by the way,
then that's a problem.
So most of the requirements
you can pretty much
nail down and say, much
like a gaming console,
this is it.
I don't have to think about other things.
But then we get those things
like information assurance,
cyber security, that plays
a role in determining
what needs to be done.
Likewise, you know, contracts.
People like to come out and
say, much like my example
where they don't like Windows,
they could come out and say,
provide us a solution on Linux.
And we could either do a
noncompliant bid, we can do no bid.
We can say, yes, we want to do this
and make everything happen.
- [Scott] Okay, cool. Thanks.
- You're welcome.
We're probably about done?
10 minutes?
Still time for questions.
Nine minutes.
Thank you, everyone.
(applause)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>