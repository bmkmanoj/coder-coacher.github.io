<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Ben Deane “A Static Alternative to Virtual Functions, Using Expression SFINAE&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Ben Deane “A Static Alternative to Virtual Functions, Using Expression SFINAE&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Ben Deane “A Static Alternative to Virtual Functions, Using Expression SFINAE&quot;</b></h2><h5 class="post__date">2016-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8jbt-5Qub9E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so I was playing with this
recipe the other day and I thought it
might be interesting to share with you
so we're all familiar with yeah this is
an application of the expressions for
possibly the fastest talk you'll see
with expressions meaning so we're all
familiar with the familiar interface my
dear so whether you call it whether you
use a pimple idiom Hazar or an is a the
idea is you have your interface with the
virtual functions and then your
implementation which is encapsulated and
as the details of you know what you
actually do now this is normal in kind
of object-oriented code so I had this
idea of doing it with all static so the
idea is basically that we're going to
have the interface be a class template
and the implementation will be its
template argument this applies the
functionality and then we have in our
interface a set of basis functions
without which you know which provide our
complete and expressive interface and
then we have a further set of extended
functions to provide a richer API for
the sake of X versatility or performance
it's fairly common so then the
implementation the idea is that the
interface can supply fallback
implementations of the Richer interface
which can be imprinted in terms of the
basis set because the basis set is
complete but the implementation can
supply richer functions add its own
option for the sake of typically
performance so let's see an example of
this right so here's an auto completion
engine and the basis functions for an
auto completion engine would be add a
word to your corpus and find the list of
candidates for a given prefix and then
in the extended set we might want to
also provide functions to say add a
bunch of words because it might be a
faster to add a bunch of words at one
time and complete as far as is
unambiguous
so if if all the words for all my
candidate completions start with the
same prefix I can complete as far as
that prefix goes and you can imagine
that we can implement the engine of this
in a few ways we could just have a
sorted vector of strings type engine or
we could have a more complex tree-based
thing if we had a lot of other
completions is that these are common
scenarios and so the vector
implementation probably wouldn't would
just use the fallback
for the complete function but it would
you know have would override AdWords
because it's it would only have to sort
once whereas the tree based
implementation could well provide a
complete function just resulting from
walking a few nodes of the tree anyway
so that's our that's our interface and
that's the that's the template then
we're going to use this little
expressions via a pattern so this is the
void T detection idiom as popularized in
a couple of talks
so if basically you can see we're doing
spin a detect and we're giving it a name
so and then we're giving it the
expression which gets put into the
deckle type on line three of the toe of
the macro there and the upshot is that
if our engine provides the if this is a
valid expression to call on our engine
then we end up deriving a thing from
true type otherwise you end up deriving
from false type well now that we have
this all that we need to do in our
function bodies in our interface is
overload for true type and false type
and pass it the the macro or the the the
thing that was derived from either true
type of false type by the macro so our
engine is our engine is the argument
that was passed in we say does it have
complete if it does we call the true
type and that just calls through to the
engines version otherwise we have our
full back code and this this all in
lines as you'd expect and that's really
the whole thing that's that's a very
easy pattern to apply so you allows you
to decouple your interface and
implementation everything is defined
statically you don't get a V table but
you get the same kind of separation of
concerns that you get with with
interface and implementation pattern and
everything in lies as you can see when
it provided by the engine it's just a
one-line function so it just works and
because the interface is a template you
don't even get things that you don't use
instantiated so no wastage you can find
the my kind of proof of concept online
at my github thanks very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>