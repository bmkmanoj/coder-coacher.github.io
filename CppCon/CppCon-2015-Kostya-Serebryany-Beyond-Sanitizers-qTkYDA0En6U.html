<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Kostya Serebryany “Beyond Sanitizers...” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Kostya Serebryany “Beyond Sanitizers...” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Kostya Serebryany “Beyond Sanitizers...”</b></h2><h5 class="post__date">2015-10-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qTkYDA0En6U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my talk today is titled beyond
sanitizers but if you want to talk about
something that is beyond sanitizers I
want to first make sure that the
audience knows what the sanitizer saw
please raise your hands who knows what
these tools are good please raise your
hands who knows who actually tried these
tools at least one perfect perfect
you're my audience so I would still
remind you some of the details about the
sanitizer hopefully I will be quick
today and the other two topics I want to
to talk to today is fast testing and
code hardening let's start from the
recap of my talk at CP takan last year
so the same time you said dynamic
testing tools based primarily on
compile-time instrumentation and dynamic
testing means that you actually have to
run the application to test it first the
tool that appears in first and chronic
chronological order is called a sin or
address sanitizer and it find bugs
related to address in memory and I won't
go into details of how the Tool Works I
will just show what it does suppose you
have a program and this light has a very
simple C or C++ program that has an
obvious bug you overflow a global buffer
all you need is to compile this
application with a single switch in this
case it's f sanitize address and then
you run the application if the bug
happens at runtime the tool will report
an error with all the details like the
current stack trace the type of the bug
the dresses and some information about
memory that has been accessed
incorrectly and the tool will abort
after reporting in are a little bit more
fancy example is used after three done
the same thing you compile
the program with the special switch
around it if the dangling pointer was
used the tool will report and the board
a more forensic kind of dangling pointer
we call it stack use of tur turn it's
when you take an address of a local
variable on the stack you leak it
somewhere into a global state you exit
the function and then you continue using
this pointer how many of you have
debugged such bugs in the wild we share
the same pain the tool can find this
bugs relatively simple relatively easily
and it will also show you which local
variable of an egg of a function that
has already exited was used second tool
called TC and thread sanitizer is about
concurrency bugs and concurrency bug the
primarily data races this example using
C++ 11 has an obvious data race we're
accessing the same memory location from
did from two different threads at least
one of these excesses is a right
actually two on this example again you
compile the application with a
difference which you have Sinnott
icicles thread you run it and if a data
race could have potentially appeared in
this execution the tool will flag it it
doesn't necessarily mean that the
particular data race happened during
this execution I mean that the memory
accesses happened in the same cpu cycles
in the same cpu cycle in two threads a
third tool memory sanitizer it finds
bugs related to to the contents of
memory and more specifically it finds
users of uninitialized memory if you
have some memory block either and stack
of heap and if you forgot to initialize
it completely and then if the code is
using this memory block in a way that it
will
the program execution the tool at
runtime will report this fact to you and
it will also show you some details about
the memory location in question if this
is a stack variable it will show you the
function name and the name of the
variable and on the call stack if it's
hiep it will show you the heap
allocation stack trace finally last but
not least you'll be son which stands for
undefined behavior sanitizer it finds
many many many other kinds of undefined
behavior in fact you besides isn't is
not a single tool it's an umbrella for a
couple of dozens of checkers that do
different things and i will show you
just one of them the most obviously the
most well-known kind of bug integer
overflow signed integer overflow if you
have that in your program if it happens
during the execution of a test the tool
will report to you the place in the
program that happens and the actual
values that data part of the integer
overflow the next slide is prepared by
the marketing team of the sanitizers
group and it says what itself sanitizers
has found thousands of bugs everywhere
everyone we try it everywhere our users
try it etcetera and there are some proof
links if you want to go for later
offline but the sanitizers are not
enough and we've learned it in a hard
way we've been applying the sanitizers
too many of our applications finding
tons of bugs releasing the applications
into production and catching more bugs
in production in the hard way this is
because of the two fundamental problems
first the sanitizers are only as good as
your tests and the tests actually tend
to be bad unfortunately and and second
fundamental problem is that the
sanitizers being dynamic tools they're
not any kind of proof of correctness
they're just best of
tools if you find a bug you know you
found a bug and if you fix the bug and
the report disappears you most likely
fix the bug but if you don't find any
bug it doesn't give you any information
you may still have a couple so we needed
to do something else to extend the way
we use the sanitizer so maybe two to
implement something different to protect
ourselves route from the bugs and and
there are many many ways to do this I
will just talk about two things first we
need to somehow improve the test quality
or in other words test coverage and one
of the ways to do it is called fuzzy the
second thing I'm going to discuss today
is called code hardening and it is a way
to protect your code and production in
the assumption that you still have bugs
you you don't know what these bugs are
but you know that there are some out
there and you need to protect your
security from these unknown bugs okay
the first part is fuzzing who knows the
term good and this is what wikipedia has
to say about fuzzing essentially it is
feeding random garbage into your
application and trying to observe what
was going on whether it will crash
whether it will hand well whether it
will consume enormous resources or so on
and the dephasing methodology has been
known for many years now and there are
subclasses of fuzzing in fact one of the
very popular ways of fuzzing is called
generation based it is when you generate
random tests or partially random tests
based on based on some rule of course
fathers can intrude in fact be used
together with the sanitizers so that you
when you run a random test you actually
check for all kinds of undefined
behavior when you generate inputs
sometimes the good strategies just to
generate sequences of sequences of bites
and most of them will be illegal for the
particular target application which is
file you will stress the ability of the
application to handle illegal data
sometimes however you want to generate
only legal data and this is much more
challenging because then you need to
build some kind of specialized logic
into your generator it is often very
very convenient to generate to generate
valid data in the phaser and as an
example one of my favorite fathers of
this kind is called C Smith it's a
father for C compilers it generates
valid but very very random si si
programs you can compile them you can
run them and there is no single compiler
in the world that could stand a good
week of fuzzing with ce smith at least
this was a year ago most of the obvious
bugs were fixed since then the same the
approach of generation based phazon is
very heavily used in industry including
the chrome security team and this
particular way was was used to find many
thousands of bugs in the Chrome browser
so it's extremely effective and
efficient yet it often barely scratches
the surface of of your application
another completely different approach to
fuzziness called mutation based the idea
is that you somehow acquire a test
corpus a set of valid or almost valid
inputs for your application you often
just crawl the web to get the inputs of
your particular type then you want
to minimize this corpus because if you
crawl the web you'll probably get too
many duplicates too many inputs that are
not different from each other you want
to minimize the test corpus according to
symmetric and the most obvious metric is
code coverage / execution time so you
want the tests to be small and very
quick but also you want the tests to
cover as much functionality of your
program as as you can the next step of
mutations based phasing is that you
start mutating the tests and the corpus
and run them of course again it's it's
best to run them with some kind of run
time checking sanitizers or something
else and now experience this kind of
fuzzing very often gives much better
coverage much better results than just
generated fuzzy of course it it actually
depends on on the on the target
application what exactly are you fuzzy a
if for example you want to fast a c++
compiler pure imitation based fashion
may be less efficient because it will
most likely produce lots of invalid C++
programs and all you will be testing is
like lecture or at best parser not the
the interesting layers the next step for
mutation based fuzzing is what we call
control flow or guided fashion or
sometimes coverage guided fuzzy it is a
say same thing as a mutation bait based
fuzzy but with some additional steps so
first first key thing is that you need
to run all the tests with some kind of
instrumentation that provides you the
coverage feedback that tells you where
the application has been running while
executing this particular input and you
need to know when you've hit something
you you need to be able to say okay this
input triggered some new code path
that we have not seen before or maybe
that we have seen before but very few
times and then if this is true if if you
found a test input that is significantly
new we have to take this test input and
edit back to the initial corpus so that
the further mutations will take that
interesting case and mutate it again now
experience this approach is often
several orders of magnitude faster than
plain mutation based facile any talk
about fuzzing nowadays or especially
about mutation based fising is
impossible without mentioning AF alphas
who have tried this tool boy I've heard
about this tool now raise your hands
you've all heard this about this till
now so f alphas it's a control flow
guided puzzle it instruments the the
target binary at compile time so you
have to have the sources the regular
mode instruments on assembly level and
there is a recent addition that does it
with lvm compiler the instrumentation
provides a fix it array of counters 65k
counters and the counters represent all
control flow edges in your application
these are not this is not exact mapping
between counters and the adjacent
application so there could be some
collisions the the counters are in
precise but they're still good enough
and they provide quite quite good
information to to work with the counters
are 8-bit and they represent eight
different states like this path was
executed once twice three times from
four to seven times and so on it eight
different states and if a given input
unit
produced in you beat in this array it
means that this this unit is interesting
we raiding it back to the corpus the
father itself f of us is a driver
process and the target application runs
as a separate process or as a separate
set of processes depending on the on the
set up I will not go into further
details of the FF us but what I want you
to know about it is that it is not a toy
so if you have an application that is
even slightly applicable we're facing is
even slightly applicable try F alphas
this is the list of things that f alphas
of course this is not a complete list
it's just what wasn't there a website
two months ago I want to talk more about
our own baby the little way my team at
Google developed it is called lvm bleep
buzzer and lib here stands for two
things first this is a library and
second lip father is actually targeted
at fuzzing it was in other libraries so
this is lib twice but first I want to
tell you briefly about coverage
instrumentation that we have implemented
an lvm compiler it is under the umbrella
of F sanitized s cash coverage flag but
in fact that implements several
different coverage strategies that
complement each other first the obvious
thing is a function of basic block o H
level coverage one of these three so
with this kind of coverage you get the
information where the given function was
executed at least once during basic
vocal given age the second kind of
coverage is in direct calls it gives you
all the indirect call color clip airs
during the execution and the third
flavor is 8-bit counters just like in FL
which I described earlier this coverage
instrumentation can provide you feedback
both after the process has exited in the
form of file on disk and as in process
API call so that you can query the
current state of the coverage inside the
process itself and the way it is
implemented now the this coverage
instrumentation should be combined with
one of the sanitizers the typical
slowdown of this coverage is very small
usually within ten percent although the
8-bit counters may stand on the way of
multi-threaded applications because the
counters are Global's and there is
contention on them so back back to lib
father it's a lightweight in process
control flow guide advisor this is the
the very short description all you need
to use this phaser is shown on this
slide you first of all you need to
implement your own target application
your target function in other words a
function that does something interesting
using the API is you are trying to test
the function takes as a player as a
parameter and array of bytes second you
need to compile your library with with
the current coverage instrumentation if
you don't know which coverage
instrumentation need you use all of them
in you need to throw one of the
sanitizers into the mix and finally you
just linked with the lib fuzzer library
lib father is much younger than f of us
and it is still not as algorithmically
sophisticated yet it is quite capable as
I will try to show you again it is not
tired it is not targeted advising large
applications it is not good at it it is
targeted at fuzzing small well small
medium sized libraries and api's
suppose you've built a buzzer how do you
use it first of all you want to acquire
test corpus somewhere in many cases an
empty test corpus to start with is
absolutely fine but if you are facing
some kind of data format parser or some
kind of application that that consumes
very complex data input very highly
structural input you want an initial
test corpus you put the corpus in into
the directory one file per input and
then you simply run the feather like
this buzzer and corpus this is all you
need for the for the basic functionality
there are lots of knobs in the father
and the goal of my team in the in the
coming year is to eliminate all of the
all of the knobs and just leave the the
basic the basic way of writing father
corpus but now there are still knobs
that you may want to use first of all
the parallelism how many course you want
to consume and second the the limit of
the size of the input tests how big I do
want the unit the input test to be there
are lots more knobs you can get them
from help if flip buzzer discovers some
you interesting test input it has been
instantly added to the corpus directory
and if there are other fuzzer processes
running on the same machine they will
pick up the new test inputs if a bug is
caught or timeout is detected lip buzzer
will stop the process and dump the
reproducer on disk so that you will have
the error message and the reproducer in
your log file all of it and of course
one father is always much weaker than
two fathers if you if you have some some
interesting application to test
you want to use all the tools you have
so you can take the corpus generated by
one fuzzy lip buzzer for example and
give it to some other father for example
fo it works vice versa as well and let's
go to some examples this is the thing I
was playing with last week in
preparation to this presentation leap
freetype is an open source library for
parsing and handling truetype fonts and
actually all kinds of phones as far as I
understand in the very simple father
feeds not just into one slide but into a
half slide all you need is basically to
pass the array of bytes into the API
function this is all of course if the if
the API function has created some object
you want to destroy this object because
otherwise the father will run out of
memory very soon very very soon second
and here are the results of running this
father for like three days on a single
machine well that machine had quite a
few CPUs but still a single machine you
can see it has all flavors of most of
the flavors of the bugs read a buffer
overflows the most scary from security
standpoint but there are also all kinds
of other things for example some test
inputs consume 17 gigabytes of RAM and I
was running with with limit of one case
0 1 K input triggers 17 gigabytes of
usage and all other weird things by the
way I should say that everything is
fixed by now the the developers were
very happy to see this bug reports
coming now maybe something more
interesting openssl
so the code actually doesn't doesn't fit
on the same slide there is an init
function which I have admitted but so
this is like 20 lines of code and most
of it is boilerplate I have no
experience with openssl I I have no clue
what that's doing inside I barely know
what it should be doing outside and and
I've took these snippets from someone
else the key point here is that all this
all this code is boilerplate you don't
need to worry about it all you need to
worry about is that you actually pass
the data and the size of the data
somewhere how many of you have heard
about heartbleed good how many of you
believe me that lip phaser can find
heartbleed before the end of this
presentation on this laptop raising
hands okay and the presentation is 35
mins from that how about five minutes
raise a hand yeah let us see so I won't
be compiling it it's precompiled here
and I will not be using any test corpus
so the father will be generating the
inputs from outer space it doesn't know
anything about about what it is testing
just throws random data and receives the
feedback from the coverage
instrumentation so what I suggest at
five minutes so just wait done
so this this particular fuzzer was
compiled with address sanitizer and
address sanitizer reports he buffer
overflow it says that the reed was 58 k
ridiculous the reed was done in mem copy
and the second the second frame suggest
something about heart heart beat I
wonder why anyway and this this slope
laptop is is pretty weak on a decent
machine the father finds it in one
second on a single CPU control-flow
guided fasten is not the end it's it's
it's an intermediate state of of these
signs and there are many many more new
things that we want to explore and that
other teams are already working on first
of all I first of all I want to mention
con colic execution and from my my
standpoint of view this is kind of
rocket science very complex very very
scientific and very efficient so what
that is we take the application we
instrumented with some kind of tracing
in it executes on a particular test
input and record the trace then we need
to figure out which branches in the
application which paths in the
applications were never taken and we
want to actually execute those paths by
providing you test inputs so we feed
this data we collected into the
constraint solvers and this is the
rocket science part of the process and
the constraints always give us back they
modify test inputs that have a good
chance to trigger new paths in the
program this is a great thing in theory
and in fact we now see great results in
practice it works this is not just a
theory but still it's it's quite heavy
weight like if you are
a medium-sized co-developer you you may
not have resources of time or anything
else to invest into this kind of heavy
weight testing I wish in 10 years there
would be like common frameworks or
software as a service for forking colic
execution but not today we're trying to
find some kind of middle ground between
this rocket science fuzzy and simple
mutation guided fuzzing one of the
approaches we call a data flow guided
fuzzy so the idea is that you somehow
intercept the data flow in the
application you analyze what is
happening in the comparison instructions
in switch statements in function calls
like string compare and then you try to
modify the test inputs in hope to
trigger a particular comparison to go
into the different direction and then
you observe what actually happened we
have a prototype of this particular idea
in lib phaser and also there is a very
nice buzzer for the goal and which but
it's outside of this conference we
already have some trophies but way a
long way to go to really useful thing
some of the improvements may come from
using paint analysis tools like if you
know where the data is coming from
exactly from the input you may guide the
diffuser more precisely and I think I
have time for a little more demo so I
will not find anybody this demo just
something to show so this is a JPEG
father it it starts from from an empty
image it doesn't have any knowledge
about the JPEG file format and it tries
to discover it well it managed to find
something it's unusual often it just
works like this it tries and tries and
tries eventually it will find the
village jpg JPEG
while and we'll start fussing it but as
you can see this father made a 100,000
iterations and didn't find anything
interesting now this flag enables the
data data flow guided fuzzy and this as
you can see it instantly finds some some
interesting stuff this is because the
JPEG library jpg file format has some
magic bytes in the headers that are
being compared against what what is
actually in the file right and if we
intercept the this comparison
instruction if we look inside it if you
know what is being compared to the what
we can guide the files are much more
efficiently this is the second part of
my talk and by the way do I have any
questions about fuzzy for now yes please
okay I wonder if anyone is shaping
executables with fasting enabled or
sanitizers nothing but sanitizers enable
so shipping by nurses fuzzing enabled
haven't heard about it now sorry that
was wrong yeah shipping binaries with
the sanitizers enabled it's possible we
do experiments with it it is not it is
not a trend it is not a very widespread
thing to do because the sanitizers they
have a cost first of all the biggest
cost is memory and then there is also
CPU cost would do experiments we we have
binaries working with a sign and
production
and the kitchen bugs please so are there
ways to make fuzzing harder especially
make sure that your binary binaries are
not easily fossil Jenna please repeat
the first part I first my own question
okay here we go can we make it so
typically the things like at the input
stage of your parsing or something you
add like a lot of debt go to make sure
that people have a really hard time fuzz
in your application to find problems the
first place so is there are there known
weaknesses in floating algorithms ah
thanks so other other ways to to make
your application fuzzing resistant right
I think that the the fewer control flow
you have in the application the harder
it is to fuzz it like if you replace if
statements and switch statements and
function calls with some straight line
arithmetic in a single expression
without without control flow eat well it
will make fuzzing much harder for for
more sophisticated ways of fighting no
you have no chance one more question
here yes yes please are you working with
any of the efforts to harden some of the
infrastructure one examples linux
foundation's core infrastructure
initiative or are they aware of these if
not i will make them aware of them but
if you're working with them no point in
bothering them again I working with the
was linux foundation yeah core
infrastructure initiative does ah CIA
weren't here so I yes yes I'm trying to
work with core instruction ishit of the
the idea is that we want to encourage
software developers
to use the tools i described here on a
regular basis and the key here is
regular basis because we not just want
them to run the tools once find bugs
fixed bugs want them to set up build
bots was quite a few cpus to run all the
sanitizers was all the father's make
sure the coverage is hundred percent or
getting close to one hundred percent and
that is time consuming and money
consuming business so yes I'm trying to
convince CII to to do to make it work
good a last question before i continue
questions a bit more practical when you
showed a list of bugs that you found in
that one case there was like a lot of
memory access memory usage we're seeing
that a lot as well when we're doing fuzz
testing because we deal with science
software our stuff is designed to use
gigabytes of memory perhaps and the
problem we're running into is quite
practical the the address sanitizer
doesn't allow you to throw STD bad a log
so I'm partly curious why that is why
don't you allow the address sanitizer to
throw as deep a Dalek and are there
plans to work around that every
sanitizer doesn't allow us to throw STD
elek every sanitizer doesn't know
anything about STD elak it knows that if
Malik is not able to allocate the memory
it should do something by default it
aboard but there is a flag that makes it
return no it's not the default flag
because the security well it's a long
story but every sanitizer does support
you use case with a separate flag it
doesn't throw a sweep at a lock it just
returns now on nothing right there
advertiser doesn't know about leap C++
or limo steady C++ it works on the level
of malik if malloc returns now then the
operator you will throw something if it
doesn't work we'll fix it
so let's let's go back to my second part
which is called hardening so as I've
explained previously no currently known
methods of testing your software
including sanitizers and fuzzy are proof
of correctness so there is always a
chance that you have a bargain software
that you don't know which is worse
sometimes you don't know about the bug
but the bad guys do and you want to
protect the application from those bugs
unknown to you but known to the bad guys
I will I will talk about two threads
threat number one is buffer overflow or
use of the free that would overwrite a
vp t our virtual pointer table or a
function pointer in your object by
something that the the bad guys control
and this is not theoretical thread the
Chrome browser was was completely owned
in this particular way in 2013 good news
is that it was done by white hat hackers
that showed the exploit to google to the
chrome developers but how many bad guys
are using similar techniques out there
not just for Chrome our solution is
called control flow and integrity or cfi
for short it is implemented in the fresh
version of clan and it requires two
flags f signet eyes cfi we call and it
also relies on link time optimization
fot oh how does it work first of all at
compile time we treat every disjoint
class hierarchy in the c++ application
as a separate thing we don't do any any
analysis between this joint class
hierarchies of course since we're also
using LTI which means whole program mode
for c++ it assumes that class hierarchy
is a closed system in other words that
you don't inherit from one class in the
main binary to another class in a shared
library that
separate from from the main binder this
is a restriction it makes C++ a little
bit smaller but it works perfectly for
chrome and I'm sure it will work for
many other applications we take V tables
for every disjoint class hierarchy and
we lay out the V tables as a continuous
as a contiguous array so all the V
tables for a particular class hierarchy
allocated in a one contiguous chunk of
memory and also align every table in
that chunk by by the same power of two
so that when when a virtual call happens
we can we can do a very simple check at
compile-time we figure out what what are
the exact functions that are allowed to
be called in this particular call side
and this is just from reading the
standard right you you can call
functions of the same class and you can
call the functions of classes inherited
from this class but you cannot call
functions from from a sibling in in the
hierarchy or some random function out
there and at runtime we perform three
checks range check that we are within
this contiguous re-alignment check that
the virtual pointer is actually aligned
by the power of two we we wanted to be
aligned and then a bit sad look up and
the bit set is is based statically at
compile time based on what functions are
allowed and not allowed it may sound a
little bit complicated like three checks
oh my god hmm but in fact they're not
that they're not that complex first of
all because bit set is one of the best
probably the best and this simplest data
structure out there in the world it is
very cheap right it has constant time
access it requires one memory load per
access it requires very very little
memory / axis ii
then even that simple data structure can
be optimized further first of all if you
bid set is small for example less than
64 bits you don't need to load this data
structure from memory it could be as
part of immediate instruction then if if
a bit bit set contains all ones and in
our case it will be the dissertation
when we work all through the head of the
class hierarchy there is no point in
checking the bit set finally the finally
would do some some optimizations to
reduce the bit cell sizes ever we will
get this thing this slide shows three
three examples of the assembly code in
x86 64 that are generated by by the
compiler to check the validity of
virtual virtual virtual call the blue
part is the rain check it is present no
three parts and it is more or less the
same and the red part is the bits at
look up so if the bit set contains all
ones there is no bit settle cup if the
bit set is less than 64 bit less or
equal up there is a bit sad look up but
as you can see this bit set look up is
just arithmetic instructions it doesn't
load anything from memory because the
bits at is small and you can load it
from the register finally if the bits at
is big and not all once we we do need to
to do this memory load but it's just a
single memory load it's cheap control
flow integrity doesn't stop at virtual
calls we can apply the same technique
the same method to other scary things
first of all to other scary calls any
other non-virtual member calls of
polymorphic types are easy to deal with
the same methodology we just check that
the virtual pointer is still correct we
can apply slightly modified make
mechanism to see style in direct calls
so no C++ classes
maybe not even C++ just plain see with
indirect costs we we can apply the same
mag mechanism we can also apply the same
mechanism for checking for bad casts for
example when a base class is casted to a
derived class we want to check that the
the cost is correct and also from void
star to some kind of pointer class we
can check it as well we have implemented
this teeny inclined llvm and you need
the most fresh version and we were able
to build the full chromium browser with
this kind of hardening a subset of what
I've described virtual calls and all
kinds of costs for today it runs fine on
linux and android and versions for other
prating systems I in flight the CPU
overhead is so tiny we couldn't measure
it we tried hard to measure it we don't
see it of course if you run spec for
many many thousand times with and
without hiding you will see this one
percent somewhere but on Chrome which is
multi-threaded which does some time in
related things you just don't see it the
code size increase is quite possible
noticeable it is easy to measure and we
see seven to eight percent what was
interesting is that making this work on
chromium required huge clean up in the
chromium codebase see if I is not bug
detection mechanism it's hardening
mechanism but it also finds bugs as a
by-product and we found quite a few
while trying to start chrome with harden
there are better or different ways to
make control flow controls or integrity
harden first of all maybe we don't need
a link time optimization the whole
program on the other hand requiring ltos
is actually a good thing in
the cases because el tio brings many
other benefits so I'm not sure we have
to drop this requirement another thing
that we can change you improve or maybe
not improve install our class
hierarchies to cross the boundaries of
shared libraries as far as I understand
the the visual studio 2 2015 has
something similar to what i described
but it doesn't require a whole program
mode I frankly I'm not sure I I have
read the documentation which says how to
use it but it doesn't say how it works
inside but on the other hand maybe it's
not a great idea to allow inheritance to
cross the boundaries of shared libraries
at least if if your application is very
security sensitive the last thing the
last thing I'm going to discuss is is
another threat to security it is one
stack buffer overflows overwrite return
addresses on your stack by something
that bad guys control you don't want
this to happen we have solution for this
for this problem as well it is called
safe stack and again it is implemented
in fresh Clank ready for you to use it
is a very simple tool all it does is
that it places local variables on a
separate layer mapped region and not on
the same function stack that is used for
function calls and return addresses it
means that even if you have a stack
buffer overflow in your application even
if an attacker can fully control what to
write in the in that random section the
return addresses are safe there is no
way an attacker could affect your
attorney addresses of course and the
tactic would still be able to overwrite
your function pointers or v-tail vtable
pointers or etc so these protection by
itself is rather weak but if you combine
it with CF I which I just explained you
get much better protection and again
we don't see any any performance loss
from from this protection so there is
almost no good reason to not use it in
production and for those who like x86
assembly here is an example of what what
saves tag does so in this example we
have a single stack variable and the
single function call that takes an
address of this variable so we cannot
assure that there is no buffer overflow
on the stack variable or use after
return so we have to protect it all the
do is we will get a pointer to the
unsafe stack that separate region we
update it to so that it can be used the
next time we store it back this is this
is all in TLS we do our stuff and we
restore the the unsafe stack back this
this sounds horrible so you you have
only two useful instructions here in the
application in the function and lots of
lots of redundancy but in reality this
is not that bad because in reality the
functions get bigger and the overhead is
fixed / function not / / variable or
something so again there is no no real
reason not to use this protection and
security sensitive applications okay let
me summarize the talk first of all you
do not want to rely on regular testing
traditional testing because this will
just give you false sense of security
the bad guys all have these tools I've
mentioned that the tools open source but
actually suspect that the bad guys had
similar tools for ages based on how
successful the bad guys are so you want
33 things for for your application first
of course I encourage everyone to
continue using the sanitizers
and these tools will give you basic
sanity meaning that on on regular inputs
you will you you will not see undefined
behavior in the applications however for
strong the security and just reliability
you want to use something like guided
fuzzing guided fasten was not simple in
in the past but nowadays with the at
least two fathers I've mentioned it
became really super easy you may spend
half an hour setting up then you start
the process go to Hawaii for for a
couple of weeks you return you get
twenty bucks profit and finally if your
application is security sensitive you do
not want to trust these trust words the
things like sanitizers and fuzzy you
want to harden your code assuming that
the code still has bugs and two of the
hardened methodologies are presented
here a control flow for virtual calls
non-virtual calls costs in direct calls
and save stag foreign addresses this is
not a complete protection and the the
battle continues I hope we will win
thank you and I'm ready to take
questions
the first problem um yeah I was just
wondering when you're using a corpus I
mean some of the examples you showed
we're just you know libraries that
simply took in a buffer bytes and a
length and so the format of the corpus
is pretty straightforward but i'm just
wondering with real usage is it frequent
that you need to kind of develop a more
complex format for what you would store
in that corpus so the question what what
do we store in corpus and what do we do
if the format is complicated yeah
sometimes we just don't do anything and
the father will still find out useful
things the the more the initial corpus
the easier the the job for the buzzer
sometimes however if the data format is
very very structured it is hard for a
father without any any specific
knowledge to penetrate the the upper
layer for example things like xml
operator buffers or some some structured
data format you may fast the parser to
death but you will not easily go into
the logic of the application that that
consumes xml a proto buffs this is why
we have implemented support for for
custom mutators the idea is that okay we
don't care about the parcel of the file
format we want to go on the next level
immediately so what we do is we is lip
buzzer allows you to redefine it's a
virtual function to redefine the way you
mutate your input data and instead of
just flipping bit you parse it using the
regular parser if it doesn't parse you
throw it away it's not interesting then
using either lip father utilities or
your own utilities you can mutate the
fields in your applique in your in your
parsed data like if you have
tree structure that that was parsed you
can now mutate individual fields you can
add fields you can remove fields you can
cross over field then you feed this
modified object to your targeted
function and if you like it you
serialize it back and right disc other
questions is safe stack related to stack
annotations so operating system threads
have a fixed size they can grow to and
then they die the operating basically
the page fault does the safe stack
functionality adhere to those same
limits does the safe stack unsafe stay
safe stack honor the limits of the stack
size yes so suppose we do know the limit
of the current stack what we do is we we
allocate a memory chunk of the same size
as the regular stack which may sound
like would double the memory usage but
in fact why not because the call stack
will use a smaller amount of stack and
the stack for the variables will use
smaller amount of memory for the
variables and the rest of the memory the
virtual memory will be consumed the
physical memory will not so the the
actual memory consumption in addition to
the regular one is very small
duced or spill temporaries on the same
stack no spill temporaries are not even
visible at the time we do
instrumentation and so spill temporaries
are generated by compiler and stored on
the regular stack when do we do the
instrumentation for the safe stack we
make it very late at the lvm
optimization stage before the low-level
code generation so all optimizations
have been done like lining everything
but things like register locations has
not been even started for the for this
new stag do you need a register as a
stack pointer maybe certain young if you
have a new stack you need a stack
pointer as a register for that new stat
so do you have another dedicated
register to that so does safe stack
require next to register yes it does and
we don't give any special register to
save stack it's just what the compiler
decides to use for for this variable yes
it's can it consumes extra register
basically python is it on its time T I
guess I can just touch so basically I'm
wondering can we use some of these tools
to deal with hardware related issues the
context i'm finna cough in particular is
dhiren and things like roll hammer sufi
are familiar with that one but it's
essentially when we have a memory cells
and we repeatedly written all rights as
those memory cells and we disturb the
between the adjacent roles in the deer
on bank and I've can lead to privilege
escalation
issues like if you're disturbed entries
that happen to be page table entries for
example so I'm wondering can we either
use fastened to identify issues like
that or some of it like safe start to
protect us against these kinds of
restoration issues can we use any of
these techniques to find problems in
hardware I have no experience with it I
guess that that fising may just by pure
luck find some of these right but this
is not a tool that is specifically
targeted to find hardware problems sorry
to mmm no I'm not an expert in hardware
testing thank you so I guess we're out
of the out of time but I'm still here
and then i'm free to dance has many
questions as as you have a less why
kicked out of the room
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>