<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Stephan T. Lavavej “tuple＜＞: What's New and How it Works&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Stephan T. Lavavej “tuple＜＞: What's New and How it Works&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Stephan T. Lavavej “tuple＜＞: What's New and How it Works&quot;</b></h2><h5 class="post__date">2016-10-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JhgWFYfdIho" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">ok let's get started so hi there I'm
Stefan T loud and I work on microsoft
visual CS pluses implementation of the
STL yes I know some people say oh don't
call it the STL as an STL maintainer I
declare I have the sovereign right to
call the library what I think it should
be called and that's the STL today I'm
going to talk to you about tuple which
has been in there since yes plus 11 goes
all the way back to TR 1 if you remember
what that was today I'll be talking
about what's new in starting with 11
what was added in CS plus 14 and 17 and
then implementation techniques I believe
I can guarantee that everyone here will
learn at least one thing today and that
includes you fellows standard library
maintains a few things before we get
started please hold your questions until
the end I have these fancy things called
slide numbers that the upper right if
you have a question or correction just
write down the slide number on your
smartphone and then we'll get to it at
the end hopefully we should have some
time for questions also everything I'm
going to talk about is standard I left
and unless otherwise specified in there
just in case turns out I'm not actually
gonna talk about any non-standard
behavior I believe and if I do I'll
mention it and by the way everything I'm
going to talk about is actually
available for you to use right now in
Visual Studio 2015 update 3 the thing
that's actually available right now
except for the stuff that was literally
just voted into the standard CS plus 17s
apply make from tuple and get for cons
to pool ref ref and I'll mention the
implementation status of those at the
end so what is the most important issue
I'm going to cover in my talk today that
is the pronunciation of tuple
this is what the other standard library
implementers need to learn - you
pronounced it to pull not tupple and
there's a reason for this it's super
versus supper there's no such word as
soup bowl but there is the word supple
there is the word suplex versus an
imaginary sub flex tends to pull versus
tupple total ordinary rules for cs+ so
from now on if you catch anybody saying
tupple yeah whenever you - marked at
this point in time and it's pronounced -
pull - pull okay so that was the most
important thing if you learn nothing
else so now let's actually look at some
technical stuff yeah whatever CS plus 11
so tuple actually does a whole lot and
yeah you may have used it once or twice
the unit may not be fully aware of
everything that it could do in CS plus
love them so I tried to think of various
examples that you would use a tuple form
and they range from fairly simple to
fairly complicated
the simplest one that people think of is
oh what if I want to return multiple
values from a function well even back
and see us plus 98 CS plus 98 needed to
be able to return an iterator and a bool
from map insertions you get pair
iterator bool
I think it's that order I always have to
look at the class definition to remember
but what if you want more than two well
that's where tuple comes in so here I
have a function starship I can return a
tuple of a string and string I can say
return make tuple and then in main I can
store that in a local variable I could
use auto for this or I could also
declare tuple string and string and then
I can individually get elements from it
zero indexed of course because zero
index is awesome and then I can print
out in whatever form I like and by the
way all of my examples are fully worked
and verified with online compilers and
the various modes I'm the only thing I'm
mitting are the includes and the using
namespace stood just because I'm trying
to make the code actually visible so
this is sort of the hello world of using
a tuple but you can also make data
structures out of tuples this is
actually something I do fairly
frequently you can make a vector of
tuple you can have a map where the key
is a single element and the data types a
tuple or vice-versa so here I have a
vector of tuples of two strings and an
int I can list initialize it which is
pretty cool I can iterate through it and
again grab the zero one
to an element's and print them out now I
could have had struct with name data
members but I can just say I don't want
to bother naming them I can just have a
tuple now moving into more advanced that
you may not have seen although maybe
you've heard of it before you can also
use tuple to make your own code simpler
so for example say I've got a point here
a point struct it could be a class and I
would like to implement lexicographic
comparison this is something that
programmers are notoriously bad at it's
totally possible to write a correct
lexographic comparison but many people
get it wrong and if you use tuple to
implement it for you well tuple knows
how to do it correctly so all you need
to do is you can say I'm going to tie my
data members XY and Z and then compare
them using operator less than on tuples
to a tie of the other pairs XY and Z and
this will correctly compare the first
element and if it can resolve the
comparison there over turn true/false if
they happen to be equivalent and it will
move on to the second element and so
forth and it's a nice sort of one-liner
way to do kind of what the core language
should be doing for you but doesn't
anyways so implementing comparisons is
one thing you can do a tuple another
much more advanced thing but still cos
plus 11 is you can actually use tuple
with pair now you might think oh you
know certainly tuple is built on pair
and not the other way around but it is
actually the other way around if you
have a tuple of a and B and you would
like to construct a and B from
individual list of arguments well
there's no such thing in C++ as having
multiple function argument lists to
constructors but it turns out you can
pack arguments in tuples and then give
them two pairs constructor with a
special tag called piecewise construct
and the helper function used to do this
is called forward as tuple and this
allows you to do something that would
otherwise be impossible because yeah you
can always assign two things later once
they're in the pair but to construct
them for the first time you only get one
chance and if you want to construct them
with less or more than one argument
fewer or more than one arguments then
you would use for it as tuple so here
I'm just showing vector because that was
the simplest thing I could think of I
can either construct it
in the para from zero arguments or a
couple arguments to say three copies of
1729 and then print out their sizes so
that's piecewise construction now
curiously there's no such thing as
piecewise construction for tuples
perhaps there should be perhaps I'll
write a proposal someday for now you
only get it for pairs and this actually
turns out to be quite useful because
things like maps their actual value
types are pairs and map internally uses
piecewise construction for things like
emplacement and so forth and finally you
can use tuple to store very attic data
members now this is in the example
section there's no actual example here
I'll explain that in a bit so let's
think about the examples that we've seen
I like to say the tuple is the world's
laziest struct and this is not really a
compliment
things like returning multiple values
out of a function or even making data
structures you can always use like a
struct with name data members and if you
use a tuple you're basically saying I am
so lazy I just can't bear to lift my
fingers and type names of data members
is just too much work I just want to
call them zero one and two super lazy
you know sometimes laziness is called
for sometimes you only need it for a few
lines of code but you are being kind of
lazy and you really shouldn't allow
tuples in this sense to sort of spread
throughout your program because now
you're losing things like names on your
data members or class and variants
because tuple is just a struct it
imposes no order no higher-level order
on its data member state and now when it
comes to things like implementing
comparisons there it gets much more
convenient I like to think of it as
compensating for a an outright
deficiency in the court language that it
will not generate comparisons for you by
default that was proposed and rejected
for CS plus 17 maybe we'll get in the
future but in the meantime the standard
library can help you out
things like piecewise construction
that's literally your only choice you
have no other way to construct the
members of a pair in place now when it
comes to very attic data members I
basically say that duple is your only
good choice because there's no way in a
very otic template to say you know types
dot dot dot members and get sort of a
very attic pack of data members would be
really cool if you could do that but you
can't and instead if you ever working
with very attic templates and C is plus
11 or beyond and you would like to be
able to store data members tuple
kind of your only choice it's that or
reimplemented yourself and you really do
not want to implement anything that
looks like a to bolt ever ask any
standard library implementer they'll
tell you no use our stuff will suffer so
you don't have to the reason why I do
not have an actual fully worked example
on this slide is that working with very
attic data members Insider tuple in CS
plus 11 was kind of obnoxious turns out
you really want to have CS plus 14
integer sequence and unfortunately CS
plus 14 is the current standard so I
don't need to write anything as old and
nasty as CS plus 11 anymore if you're
stuck on a CS plus 11 only compiler I'm
sorry
get your employer to upgrade okay so
we'll we'll see actually how to do this
with integer sequence in a bit okay so
that's just a high-level overview of the
things that you can do with tuple now
let's look at all the features in CS
plus 11 so we can distinguish what
existed in 11 and what is new in CS plus
14 okay so there are four different
functions that return tuples in CS plus
eleven non-member functions and it can
be kind of confusing what's the
difference between you know make from
tuple and tie and can CS + Seventeen's
deduction for constructors replace these
the answers actually no people will tell
you that oh you can just say yo tuple
and the deduction will totally replace
make from tuple that's actually
incorrect make from tuple does a little
bit extra work just like make pair it
actually follows the exact same
convention it decays what you give it so
if you say make tuple and that's where
this V types thing comes in that's
actually copied right from the standard
if you say make tuple and you mention
the name of an array and the name of a
function and Const reference make tuple
will decay its arguments so arrays
decayed up pointers functions to K -
function pointers top-level references
and see if we qualifiers are stripped
and this is desirable for various
reasons on the other thing that make
tuple does that not even see us plus
Seventeen's
deduction for constructors does is it
unwrapped so if you have a thing that's
called a reference wrapper which is a
standard library type make tuple
actually says oh I can give you an
actual reference to the
inside questionable whether anybody
actually uses that functionality but
it's there and make duple does it and so
does make pair by the way and this is a
common mistake i ran two years ago don't
help the compiler it's still true don't
help the compiler never ever pass
explicit template arguments to make
tuple because you are defeating the
point either say tuple and then name the
exact types that you want or say make
tuple and let template argue deduction
do its thing
but in no case should you ever give
explicit template arguments to make
tuple another maker of tuples is tie
that we saw before in the implemented
comparisons it can be used for other
things as well what it does is it takes
a bunch of l value references it could
because they could be modifiable and it
returns a tuple of l value references
and it can be used for assignment we'll
see that on the next slide a
significantly more advanced version is
this forward is tuple that we saw for
piecewise construction this requires a
little bit of understanding okay a lot
of understanding of our value references
and perfect forwarding but it basically
takes arbitrary stuff and returns l
value references or our value references
a tuple of them so if you call it with
arbitrary things you get a tuple that
refers to them the problem though the
gotcha
is that because forward is tuple can
take our values and return a tuple of
our value references potentially if you
store that somewhere what if those are
values are actually temporaries that
evaporate now you've got the angling
references so be very careful when you
use for it is tuple that you're
essentially immediately consuming it
that you're giving it to something like
piecewise construct or tuple k out or
something else don't store it for a long
time even you know after a period of one
function call because what if those
temporaries have evaporated there's a
note in the standard to that effect but
I'm going to repeat it anyways and then
there's tuple cat which although its
name is awesome I've never actually seen
a use for in production it is super fun
to implement like unbelievably fun with
integer sequences everywhere but I just
can't imagine an actual use for it but
its standard so they're good ideas +11
okay so I mentioned that tie can be used
for assignment here's an example
so mansion I've got that exact same
function starship returning a tuple what
if I already
have a few variables that I've already
defined your string us into I and what
if I would like to assign to them well I
could always say I'm going to have a
tuple maybe you know defined with Auto
and then say okay s equals get 0 I
equals get 1 from the tuple but if I
would like to sort of step take a short
short cut I could simply say tie s and I
together and just assign starship and
what this does is it constructs a tuple
of string RAF in RAF and thing and then
that tuple which is a temporary is then
assigned to the return value of starship
and tuple it has an assignment operator
that has been defined to work specially
for references and it says I'm going to
assign through to the things that I
refer to so when I assign this tuple of
string and string to my tuple of string
RAF int ref and stuff on the stack this
temporary it's going to sign through to
the string s in the end I then there's
this thing called stood ignore that can
participate in this and assignments to
it are ignored I kind of view this as
over-engineering it's convenient to show
and I know everybody likes to see it for
the first time when they work with
tuples I've never actually used it in my
own code it's now all right wrong but I
don't view it as a powerful motivator
for tuples I'm actually kind of scared
of tuple of references now it's
certainly the case the piecewise
construction and forward is tuple are
super awesome but when it comes to this
assign through a reference thing that's
actually powered by actual standard
library code it makes me nervous when
you have reference data members in a
core language struct there's a rule that
says the compiler generated copy
assignment operator is inhibited I will
not generate such a thing for you you
can write it yourself but the compiler
is not going to help you and the
standard library look at this insist 11
and said for both pair and tuple I want
to be able to have not only pairs tuples
of references I want to be able to sign
through to them because I want to make
stat I work now it's certainly the case
the parent Troop will provide lots of
functionality beyond the core language
like implicitly generated comparisons
and conversions that you don't get with
structs by default and in general these
are super awesome I love the fact
that tuple of Kasich your stars have
secured star will implicitly convert to
a tuple of stood string stood string
that's wonderful
I'm not even of the opinion that that
should happen force trucks by default
but the fact that it happens for tuple
is great however when it comes to this
reference thing it makes me nervous
because it's kind of a hole in the type
system an example I have there in red at
the bottom is that vectors and other STL
containers require actual object types
object type means not a reference not a
function and not void so that means that
it is always and is currently forbidden
to a vector of int rep that's just super
weird and bad don't do it however you
can actually say vector of tuple of T
ref the standard library won't actually
stop you and yet imagine what happens
whenever the vector tries to assign its
elements instead of assigning in some
sense the tuples and repointing them as
a reference wrapper would that's a
totally fine thing to put in a vector
but if you have a vector of tuple T ref
any attempt to assign those elements
will instead assign through to the t's
that they refer to and you're going to
get totally jumbled up things so don't
ever write that don't even think it and
this makes ty sort of scary for me when
used for assignments like this now ty
for comparison is totally fine because
you're not punching through the tuple
and assignment to anything okay the
other things in CS plus eleven are ways
to query tuples you can ask what is your
size meaning how many elements are in
this tuple potentially zero for a two
bowl bracket bracket you can also ask
what is the type ant index I you know
you could of course write these
non-intrusive lee yourself but they're
just so common that the standard library
provides them on the standard library
even though it took a little while to
get correct in terms of what headers
provide these things but they eventually
found the right answers these type
traits ignore top-level cv qualifiers
just like all the primary type
categories do if you've ever worked with
type traits you will be familiar with
the fact that you can say is integral on
T and if T happens to be Const int the
answer still yes like yeah constant
isn't int however references do change
the answers given to the primary type
categories and similarly if you give
references tuple size and Hoopa element
they
look they basically say I don't know
what this is this comes up in perfect
forwarding everyone up to and including
the committee itself in working drafts
of the standard locker the standard
library standard ease has made the
mistake of writing a perfect forward or
inspecting tea with tuple size and tuple
element and forgetting that an l-value
reference can sneak in there so if you
ever worked with these and you're
working in generic code keep in the back
of your head hey maybe I need to deal
with references we'll see examples of
this later and these have been defined
generically to also work with pairs in
the rates so here's an example of using
them I'm actually going a little bit out
of order because I tried to write this
with CS plus 11 and I could but it was
really annoying and made the font really
tiny so I've highlighted in purple here
the things that I sort of borrowed from
CS plus 14 I could write a function
called get back and this is basically
saying what if I had a tuple of three
elements and I want to get the third one
the one in index to the standard library
won't help me with that but I can write
my own so here I write a perfectly
forwarding function that takes some
arbitrary tuple ref ref and I want to
get the N minus 1 element well how can i
express the concept n minus 1 well I
simply say what is the tuple size of
this thing and then subtract 1 but when
I say what does the tuple size of this
thing I can't simply say Capital tuple
because if I'm called with an L value
that could be an L value reference type
so I need to remove reference from it
and in CS plus 11 this would be type
name remove reference of capital to full
double colon pipe that's horrible
so I use CS plus 14s remove reference T
and then I could also form the return
type of this function using only C++ 11
technology it would just need both tuple
size and tuple element and I would need
to remove reference and I would need to
say type name and at that point I throw
up my hands and I said this slide was
getting too dense let's just use deco
type Otto and so this is how I would
write a completely generic get bat
function that respects value categories
we'll see a little bit more about that
but there's nothing preventing me from
doing in CS plus 11 it would just be a
little bit more verbose okay as I
mentioned value categories here are all
the overloads of get by index in CS plus
11 there
three of them four tuples there's also
overloads for arrays and pairs which I
won't be listing here so I'm if I'm
given an l-value tuple I get an L value
reference if I'm given an R value tuple
I get reference collapsing because
remember tuple elements can also be L
value or r-value references in addition
to plain old object types this can this
is actually sort of very dense if you
ever work with tuples into generic
concept at generic context I highly
recommend just sitting down and working
through what happens with the various
get functions when called with L value
or r-value tuples and when they're data
member types are objects versus L value
references versus r-value references and
what happens with the constant is and L
value qualifiers basically what happens
is that if your tuple is an L value that
propagates and that affects the return
type of get saying that oh you know if
you have an L value tuple and you get
the first element of it say the element
is actually int debt will return an int
ref because you can say that over and
over and when you can repeatedly name
something that's an l value whereas if
you have a temporary tuple containing an
int and you ask what is it zeroth member
and say that member is a string then get
will return string ref ref saying oh you
had a temporary tuple and you have an
object living inside it well when I get
it I know nobody else can be referring
to this thing so I'll give you an
r-value reference and this also applies
to reference collapsing bubble box so if
you're writing generic template code
that works with tuples please remember
that get interaction to the value
categories in a very well-designed way
this is wonderful but you also need to
remember it mostly so that you don't
infect your tuples with L value nests
when you don't intend to and the type
here you see here is just for shorthand
I've introduced it is to Palolo and blah
blah blah type okay so if you've ever
worked with boost tuple there's a
difference between boosts tuple and
stood a tuple and it's the fact that get
is a non-member function this is unlike
that first and dot second in a pair and
there is a reason for this it's just not
a very good reason I can't defend it but
it's what the committee chose the
rationale is that if you are ever in
plated code and you needed to say get
you would need to introduce template
disambiguation which i have seen
repeatedly is something that comes up
maybe every year on our internal justice
mailing list Microsoft where somebody's
writing code and it's rejected by a
compiler often clang or something and
they're like why do I need to
disambiguate it and then somebody has to
explain it and it's there's a whole
reason you can read sis plus templates
the complete guide by Vander forward and
justice that's a wonderful book it
explains this in great detail basically
the compiler needs to know what things
could be template names in order to
understand what the left angle bracket
could mean by default it doesn't expect
template names and in this case it needs
to be told hey get as a template so T
dot template get is admittedly ugly and
horrifying and their committee said if
we make get a non-member the nobody will
ever need to say that but the downside
is that anon templated code you still
need to write as a non-member that's
kind of lame I kind of like boost you
know boost gives you both and you can
use jumper form is good so if you care
write a proposal
maybe I'll care enough to write a
proposal maybe not I'm a little bit lazy
okay that's everything all the features
that you could do to tuple in CS plus
eleven now let's move to C us plus
fourteen the current standard this is
introduced a few new things that can
actually be very convenient for your
quality of life um get by type integer
sequence is technically not a tuple
feature but it's always used with tuples
so I'll cover that also tuple received a
lot of Const expert I won't be covering
that if you like context for evaluation
tuple in CS plus fourteen is there to
help you and a one-liner paper basically
that added a template alias tuple
element T in addition of things like
remove reference T and so forth so
what's this get by type thing this is
actually extremely convenient so it can
be awkward in code when you see a lot of
get 0 get one get two and you're like
what's the type of this thing I need to
go look at the tuple and then count zero
indexed what this thing is yet my type
basically says oh you know CS plus you
know the court language is very
convenient sometimes it doesn't always
get in our way and one of the cool
things it can do is you can overload
templates based on type versus non type
arguments so yeah I get takes indices
zero one and two but you can
also overload it to take type parameters
as explicit template arguments and those
overloads actually totally coexist so
here I've got an example where I've got
a tuple of instance drank on secure star
stood string and using get my type I can
say get the int data member out of it
get the cons care star I don't know what
position it is but please get it and
this will totally compile in CS plus 14
now there is a restriction and the
example sort of suggested what happens
if there's a duplicate well in that case
saying get stood string would be
ambiguous like which one do you want the
one at position one or the one at
position three and wisely the standard
library says oh there's duplicates
trying to use get by type for that
specific type will be a compiler error
it's okay then as the example shows to
get int when there are duplicates
strings that's totally fine is just you
can't say get string it's sort of
enforced at the time you mention the
type so get my index is still the
fundamental form but in non generic code
being able to say get a specific type is
often quite convenient so this has
expanded the number of get overloads in
CS plus 14 but they're very systematic
again they're overloaded for L values
versus our values versus Const l value
tuples so it's still propagating l value
miss and cons miss the fact that
sometimes the information is provided to
an index and sometimes the information
is provided by a type does not affect
that behavior of yet so yeah it's more
overloads but it doesn't really add
extra complexity the complexity is
internal to the library where we need to
figure out oh you gave us the type int
what index is it and is it unique but
that all happens internally it doesn't
expose anything on the interface which
is nice and of course there's overloads
for pair there is no get by type for
array for obvious reasons it only has
get by index so but I don't really have
points bullet points for that they're so
integer sequence so integer sequence if
you've ever looked at the standard is a
little confusing because the actual
verbiage it devotes to it is not that
much a lot of it is actually hiding in
the synopsis of the head or utility so
at its heart integer
sequence is a struct it's a tag type
that exists kind of like integer
integral constant except for packs of
integers this could be int it could be
bull it could also be a you know size t
that's a very common one the fundamental
ones are integer sequence and the usage
there would just look like integer
sequence into you know 1 comma 7 comma 2
comma 9 it doesn't care what you give
they could be duplicates they could be
non ascending they could be negative
there could be none of them that's also
totally fine and then there's an alias
template called make integer sequence
and here you could say make integer
sequence int comma 5 and this will
become the type integer sequence int
0 1 2 3 4 counting from 0 up to n minus
1 and then there are some convenience
aliases index sequence make index
sequence in index sequence for that are
specifically for size T's and these come
up all the time I'm especially because
tuple happens to be indexed with size
T's but they're not necessary you could
always just use the fundamental forms
integer sequence and make integer
sequence so funny story making sure
sequence can be implemented library only
you know you recur second pile time with
your Nesta you know rehearse obstructs
inheritance and manually form the type
integer sequence in 0 1 2 3 4 and then
stop counting at some point so we had a
user submit a bug report saying hey this
is kind of slow and if I ever ask for
making receipts like 450 well the
compiler takes a really long time and
then it runs out of memory and then it
crashes I would like it not to crash and
maybe be faster but mostly you're not
crash and I looked at this I said yeah
okay kind of but 450s huge I don't have
a lot of sympathy for this then they
said oh but other implementers are
clever they have a logarithmic
implementation that does something fancy
and only makes log an specializations
and I heard ohm and other implementers
are doing better than I am I got to do
something about this bug
but then I said you know I'm actually
kind of lazy and I don't want to have to
figure out how to make a logarithmic
implementation I know what I can do I
can go to the compiler and say hey
compiler devs do my job for me so I
literally walk over to John caves his
office or Jonathan Emmett I think I
harassed one of them and I said hey
could you do my job for me and they're
like oh okay and then I also had to
request this thing from the other
front-ends that we support
clanging and EDG and so what we are
actually shipping in Visual Studio right
now the definition to make image or
sequence is right there formatted for
white space we simply call a compiler
hook and say make integer seek double
underscore the pipe I want to form is
integer sequence and here's the type and
here's the size and make it for me
because the compiler can spam out the
indices 0 1 2 3 4 5 6 up to you know 499
way way faster than any conceivable
standard library implementation using
less memory and this actually turns out
to be a little important in someone
pathological template code that really
forms a lot of integers sequences and
it's also simpler for me to maintain
because if any bugs come in I just you
know file them under the front end cap
and then I've done I wash my hands of it
you know Oh make Energon seek is broken
what's compilers fault so all the front
ends implement this I also mention this
to GCC's maintainer x' and lipst and CS
plus as maintainer is even though as of
right now our STL doesn't need to target
Jesus yes a day you know maybe they want
to have the same sort of hook so if
you're using a sufficiently updated
compiler make integer sequence is way
way faster and the way that I specified
this I was thinking even though I only
care about the STL
what if boost wants you know to have a
boost integer sequence well this thing
is parametrized so if somebody else has
a third-party library with an integer
sequence like type they can still have
access to the same compiler hook as long
as it behaves enough like integer
sequence so now that we have integer
sequence and make integer sequence what
does it look like when we work with very
attic data moves now I can show you so
although I have ranted that bind is not
very cool in the age of lambdas it is a
very convenient way to demonstrate very
out-of-date members and it actually does
come up in situations like Hall once
stood thread other things that take
arbitrary numbers of arguments and then
need to communicate them elsewhere and
would really like to store them as data
members so
I have a struct which I have inventively
called mini binder and it's going to
store some callable object in this case
I think yeah it's just going to be a
plain old function object F called
member underscore F and then I'm going
to a tuple of Arc's now in the mini
binder constructor which I've marked as
explicit because maybe it could be unary
and explicit as good I am NOT going to
try to deal with arbitrary value
categories I would do that if I had to
maintain bind and I do have to maintain
bind which is awful but right now I'm
not maintaining bind so I got to be lazy
and I'm just going to take my value and
decay and I know it's going to copy if
it's fine I'm just going to store the
stuff then in my function call operator
look at the the bottom one for a moment
I'm going to just be a constant function
call operator I'm not going to deal with
constants and value categories I'm just
always going to be cons the first thing
I'm going to do is I'm going to say okay
I am a mini binder for the function
object F and some number of args maybe
in strain tint I would like to form an
index sequence for the types in string
int or whatever so if we look at the
definition of index sequence for this
says okay we need to get sizeof dot
adoptee so if the types are like in
string end well the size of dot a dot
that pack is three and so it says make
index sequence three and then that
expands to make integer sequence size T
of three and then that becomes the type
integer sequence of size T and then the
indices are zero one and two and these
are exactly the indices that I need to
access to Palau
string and string or whatever the types
that I said three of them would be
accessed with zero one two so now that I
have formed that type I make a object of
that tag type that's that that's those
empty braces in the lower right I could
have used parentheses as well but empty
braces reinforces the fact that this is
a tag object and not a function so once
I've got a tag object of type integer
sequence size T zero one to which the
alias index equals zero one two means
the same thing now I can pass that to my
helper which I've called call and then
this can use size T data it exceeds and
the compiler will now know that it
exceeds means zero one and two and I can
use package
Inchon to say okay I want to call member
underscore F with yet it exceeds of
member underscore t dot and this will
expand for a 3-tuple
in to call MF with get 0 of M T comma
get one of M T come and get two of Mt
and then actually call the function so
usage looks like this imagine I've got a
function add that takes for intz I can
call mini bind and say okay I'm going to
bind to the function add to the integers
1729 this will make a data member tuple
int int int int and then call will form
the integer sequence size t 0 1 2 3 then
actually call my ab function and so then
I can call em B with no args and it goes
through the function call operator my
call helper and it adds them all
together and I get 1729 now I could have
written this in CS plus 11 either by
writing something like make integer
sequence by hand or I could have written
it recursively
but when working with very attic
templates in general and tuples
specifically please do not write very
attic recursive implementations that
peel off an argument and then add it to
something then peel off another it's
terrible for compile time for
correctness it's very difficult to get
right
when you work with pack expansions and
integer sequences it may seem strange at
first it requires a change in mindset
but once you switch over to that mindset
then you can write very efficient very
simple code that forms parameter packs
like index sequence 0 1 2 and then
applies them to a tuple in what I think
of as a single very attic blast and it's
both efficient to compile and simpler to
maintain essentially everything in the
STL that works the two poles is now
implemented with index sequence up to
and including the monstrously
complicated tuple can't so that's very
active members now let's move on to CS
plus 17 so what does this look like
so in CS plus 17 we have apply make from
tuple we've got logical operator type
trades which are strictly speaking not
part of tuple but they're very
convenient in implementing the final
feature which is perhaps ominously
called improving pair and tuple I didn't
make up that name it really did improve
move them and made them complicated but
cool so we'll see that but first apply
and make from tuple so apply and make
from tuple are so simple that I can just
depict the implementation that is
literally in the standard standard
library standard ease so apply take some
arbitrary callable object F and an
arbitrary tuple Loyd it could be a tuple
it could be a pair could be an array and
it forms an index sequence and then it
calls invoke which you may have heard of
from my previous presentation last year
about functional and it gives it the
callable object and the unpacked members
of the tuple so what does this look like
I'm here I've highlighted the relevant
parts so what apply takes and the
eventual invocation and everything else
is essentially boilerplate saying yes I
need to take the type tuple here they're
using decay get the tuple size make the
index sequence then pass to helper which
now has size T dot but eventually it
just unpacks everything so usage is
actually kind of simple so imagine I
have a tuple of arguments and here are
same sort of deal I've got add that
takes for its if I have a tuple for ins
I can just say I want to apply this
callable object which happens to be the
function and to my for tuple of integers
and just invoke it and there I add them
all up and because apply is generic I
can also apply the function object stood
plus two just a pair because pair follow
is the tuple protocol it supports things
like tuple size tuple element and get
and apply will work with it directly so
I can also do this this could be quite
useful if you have a tuple of data
members and you would like to just
invoke some function object on them but
you don't want to write essentially this
stuff the standard library can do it for
you now in the core language there are
what there's one kind of function that
you can't actually get the address of
and that's a constructor what if you
want to construct a thing from a bunch
of elements of a tuple where that's
where make from tuple comes in
essentially the same thing make from
tuple it takes a tuple perfectly
forwarded so it respects value
categories and all that and it takes a
type as an explicit template argument
and it forms an index sequence and then
constructs
tea with parentheses not braces and then
returns that out so if you ever want to
construct an object from a tuple cos +
17 make from tuple can do that here I've
got a very simple example if I have a
tuple of a couple intz and I could say
make from tuple vector int and this will
construct the vector in from 3 + 17 29
and because make from tuple uses
parentheses not braces which all the
standard library uses parentheses in
this context just like make Sheridan all
that I don't get to integers that are 3
and 17 29 I get three copies of 17 29
the standard library may handle braces
at some point the problems you can't
perfectly afford them like - pulsar -
serves that any way I could rant about
this for years make from tuple
parenthesis could be convenient okay so
I mentioned conjunction this is moving
on to the how it works part of my talk
so these conjunction disjunction and
negation they originally proposed as and
or and not I think with underscores
somewhere but the committee got their
hands on it and bike shedded the names
now you have conjunction and disjunction
and negation okay so they're not
ambiguous and they're nope they're never
going to cause confusion with those
bizarre quasi keywords that I so 6 or 6s
so conjunction this is a meta type trait
which sounds super scary and it is scary
but it's really convenient when you work
with type treats for a living you
basically give it a bunch of type traits
and it gives you the logical and of them
but it also short circuits which is cool
and it does this inheritance thing which
may or may not be cool I haven't
actually found use for it myself because
all of my type traits derive from either
true type or false type and I don't
inject extra information to them in this
context but it could be useful and it's
not really any extra cost to provide and
conjunction is defined to be true type
if you say conjunction of literally zero
types this happens to be useful
disjunction is basically the same
biological or of a negation can negate a
single type trait but at the type trait
level without going down to the boolean
level of getting double colon value and
we'll see very shortly why this is
useful so what is this about
short-circuiting so if you've ever met a
programmed you may have encountered the
fact that meta programming doesn't
really short-circuit
everything needs to be evaluated at
compile time so if you ever say
something like you know typed rate one
double corn value and an typed Ray -
double colon value both of those type
traits will be instantiated and if one
of them blows up well you've got a
problem sometimes it's okay if you can
ask the question to both of them but
sometimes it's improper to even ask a
question conjunction offers a way around
this which is sometimes a lot simpler
than writing handwritten code so here I
have a somewhat realistic example
imagine I want to ask a couple questions
first is it the type a the same as B and
is the type a constructible from X and
imagine the overall condition I want is
I want a to be not the same as B
never-ever-ever
and I want a to be constructible from X
conjunction will answer this but if I
list them in this order conjunction will
do something extra special and that's it
evaluates the stuff in blue here first
and says okay is the type a the same as
B and if it is then it gets negated to
false and we know that logical and a
false in anything is false
it's short-circuits right there and says
okay a was the same as B so I am going
to return false and I am not even going
to instantiate instructable ax value I
can still just form the type is
constructible ax that's fine I can
always form that type but I don't ask
for its double colon value this can be
very useful in situations like when the
type you know B and X are the same or so
forth it's a way to avoid asking
questions that you don't want to know
the answers to this comes up in tuple
actually it can avoid infinite recursion
it can also potentially improve compiler
throughput but that's sort of a minor
benefit disjunction also short circuits
as a logical or would and that's also
useful in various situations so how
we're pair and tuple improved in CS + 11
+ CS + 14 there was a perfect 40
constructor tuple of instrument is
constructible for three things and they
will be used in order to construct each
data member perfectly forwarded now this
constructor was marked as being under
conditionally explicit which I've
highlighted and read there why well
because what if you have a one tuple
well a one to Boldwood take one argument
and we all know we don't like implicitly
converted constructors
especially when they take only one
argument because that can be used for
implicit conversions so triples designer
said oh we need to lock this down we
need to make it explicitly totally the
right call in CS plus 17 this has been
lifted so now the standard library
specifies these things with explicit in
all capitals monospace and italic and
this is because it's trying to do
something that the core language doesn't
support yet which is conditionally
explicit constructors there is
conditional no except you can say no
except and then a bool and then that's
either you know yes/no accept or not
there's no way to say explicit paren and
then some boolean condition I wish there
were because it would make my life
somewhat easier there's not but we can
make it anyways even though we're not
compiler knows we can make it with
library only technology and what I refer
to is on offs feigning okay so why would
you even want this here's an example
this example is specific to CS plus 17
and if you go all the way back you need
to use like GCC and suits plus 11 or 14
mode this will be rejected and if you
use a sufficiently new GCC in CS + 17
mode this will be accepted if you try to
use lip C++ with clang this appears to
be accepted in all of their modes I
think because they've got a nan stared
extension yes Eric sitting there he
maintains the thing he knows but
technically this was not valid CS plus
1114 it is valid C is plus 17 and it
will be accepted by the latest versions
of all the standard libraries in CS + 17
mode what is it trying to do well here
I've got a print function that takes
accounts to pull string string string
RAF and then it prints out elements so
if I want to be able to return a tuple
string string string previously I would
have need to say something like return
make tuple of red green blue or return
to full string string string / n red
green blue or similar horrible
abominations now I can use braces this
uses CS plus 11 uniform initialization
but this actually requests an implicit
conversion from 3
arguments 2-tuple string string string
and this is actually a ceaseless 11
thing explicit is now relevant on
constructors that are other than unary
we never used to think like this in CS
plus 90 803 now it matters and tuples
been revised in light of this fact it's
taken sir to everybody a little while to
get used to so now I can both brace
return tuples and I can pass braces to
something expecting a tuple of a
particular type and that will implicitly
invoke the perfect for item constructor
and construct the tuple forming and
whereas previously the the hard-coded
explicit in CS plus 11 and 14 would have
prevented that now this is conditionally
explicit it is implicit only when each
individual element is implicitly
convertible in this case I'm going from
a decayed cons care star to the type
stood string and that is implicitly
convertible that's totally fine however
if the types involved are not complicity
convertible then the standard library
detects this and says okay you can
construct this thing or you can convert
this thing but you must do so explicitly
I will not do it implicitly for safety
so my usual example is vector vector of
anything is constructible from an
integer explicitly I could say vector
string paren 5 and that will construct a
vector of 5 default constructed strings
but I cannot say vector of string V
equals 5 copy initialization is
considered implicit and I am NOT allowed
to implicitly go from an integer to a
vector of anything that's just too weird
so here if I have a tuple of string and
vector int I can directly initialize it
from a string and then the integer 3 and
then this will directly initialize the
vector int inside from 3 and I can print
it out and I get 3 elements all equal to
0 but if I try to print using list
initialization using these braces like I
did in the previous example this will
try to construct a temporary string of
temporary tuple of string and vector int
and that constructor of the perfect 14
constructor is explicit it senses the
fact that going from four to vector int
requires this explicit conversion so
that would be a compiler error the
compiler error is admittedly horrible um
if you do not know what's going on here
but it's stopping you from writing bad
code
perhaps in the far future compilers will
actually be taught to provide
higher-level context rather than or pop
possibly even pop up a youtube link to
somebody explaining what's going on we
don't live in that magical world yet
okay so let's look at all of tuples
constructors before we see how to
actually implement this first off we
start with the simple ones these are
true post constructors and CS plus
seventeen you've got a default
constructor which is concepts per you've
got defaulted copy and move constructors
I'm ignoring the allocator rdt spam you
don't want to know what it is these are
the simple ones then there are more
constructors and there are so many that
I've needed to extract the template
nests and put it under for bullet points
but here you can see actually how
they're highly systematic you've got one
constructor tuple cons types rep that is
almost always out competed by the
perfect forwarding constructor tuple
from arbitrary you ref ref that first
one exists so that people who are being
horrible and saying something like tuple
of double star comma stuff can construct
that from the literal zero and even
though the type int cannot convert to
double star the literal zero can and
this first constructor will be used in
that case I would prefer for it not to
exist but it exists for backup and then
you've got the converting copy
constructor and converting move
constructor for tuples and this is quite
useful this is what allows you to
convert a tuple of con secure star con
scare star to a tuple of stood string
string and finally you have a couple of
pair converting copy and move
constructors that exist only for two
tuples and allow you to convert between
from pairs two tuples which are
convenient but require dedicated
constructors so how do we implement this
capital explicit thing let's see first
how do we even do scheming so as far as
I can think of there's five different
positions where Safina can appear in a
function maybe there's more come up to
me later and tell me but here I've tried
to list them all
so first let's start off with a simple
example this is totally unrealistic add
zero
that takes a tee and an eye as them
together and returns it using deco type
to get the type correct and so forth
what if I wanted to constrain this thing
to exist only for integral types T the
first and oldest thing that I could do
is annotate the return type I can wrap
it in an able of T on the condition is
integral V this uses CS plus Seventeen's
variable templates for type trades I
could also say is integral t double own
value same deal if I wrap the return
type then when the compiler tries to
substitute it maybe the return type of
vanish and the whole thing's fee neighs
classic the other thing I can do which
you probably have seen if you've written
enable if in code is I could add a
default function argument when I've done
this I like to use the type void double
star because that is actually pretty
hard to get anything to convert to
there's other types you could use but I
usually just use void double star and I
can just default it to null put another
more obscure thing you can do is if you
have a function argument that is not a
template you can wrap that type in
enable if now all of these are deficient
in some way the return type one is not
applicable to constructors and
conversion operators because they don't
have classic return types I don't think
you can do it two conversion operators
in any event too weird you the bit about
the default function argument does not
apply to very attic functions including
including very out of constructors
because as soon as you try to put a
default argument now your parameter pack
is non deduced and if you don't know
what that means it's horrible and
finally the bit about Oh what if you
have a non templated function argument
sometimes you just don't have any of
those for example tuples perfect for
wording constructor satisfies all of
these criteria there's no place to put
any of these constraints so the fourth
and fifth ways to spin a are in default
template arguments the first way which
I've used most commonly is to say okay
I'm going to type name and it's going to
be a dummy so I'm not even going to
bother naming it I'm going to say an
able if T is in a row V and I'm done
another way is you can use an on type
template argument you can say enable of
t and if the condition is good form the
type int and then I want to have this
non type template argument end default
to some value 0 it could be 1729
the value doesn't matter I mean I could
use another type than ends I could use
law and whatever but I like int and zero
because they're less typing and I'm lazy
so why would one prefer one or the other
turns out there is a difference and the
first one cannot be used for an offs
Feeny and the second one can so what
does that look like here I've written
what I am just calling me for the
purposes of the side spin a dispatch I
could do this tag dispatch as well in
this case but for Constructors I'm going
to need this so here I would like to
turn on one overload four is integral
and then I would like to turn that off
when the type is non integral and using
another overload so here I've
highlighted the difference one is enable
4 is in a role and the other one is
enabled for not is integral and I've
used the int equals zero form the reason
why this works is because when the
compiler is trying to look at these
things and it sees oh you know I don't
know what T is so I don't know if these
are exactly the same so I'll let them
coexist and by the time I actually get
around a template are going deduction
substitution then I'll figure out what
their actual template parameters look
like and then I'll see ok only one of
them exists if I tried to use the type
name equals stuff form and I had two
identical signatures with the compiler
but C is though you have two overloads
that take the same function parameters
and they take the same kinds of template
parameters and they have different
defaults but the fact that they take the
same kinds of template parameters means
that all you've got like duplicate
overloads I can't handle this and it
explodes so if you use the in T equals 0
form you can turn on and off overloads
widths meaning this is useful for
constructors where sometimes you don't
want to use tag dispatch and you just
want to be able to control them right
there this is necessary for conditional
explicit so here I've got a type called
wrap wrap is going to wrap a single type
T it's like a one tuple and it is going
to want to have perfect forwarding
constructors from you that are
conditionally explicit this is actually
very close to what tuple does except
only for one argument to avoid exploding
your heads horribly so I've got an
additional constraint here not self and
this ass okay is the type u after I
remove references and after I remove
constants is this the same as ramp I
want to be not the same because I do not
want to compete with my actual copy move
construct
then if I want to enable the implicitly
converted constructor I want three
criteria to be true and I'm going to say
enable of T conjunction V meaning all of
these things need to be true logical and
first I want you to be not myself so I
don't want to compete with the copy/move
C doors second I want t to be
constructible from you because I am
actually going to construct the thing
this needs to be well formed and finally
I would like you to believe to be
implicitly convertible to T the order is
from is convertible from two that's why
it appears reversed that is intended and
if all those things are true then I am
NOT myself I am constructible from this
thing and I am implicitly convertible so
it's okay for this constructor to be
implicit the other condition which is
purple here is the condition to enable
the explicit constructor again I require
you to be not myself and I still need T
to be constructible from you because I
am going to construct the thing with
direct initialization but I want to turn
this thing on when you is not implicitly
convertible to T this is what sense is
the difference between cons carest are
implicitly converting to stirred string
versus int not implicitly converting to
stood vector of T and so if I define
these alias templates then I can define
my rap constructors they both take
arbitrary you ref rap one is plain one
is explicit and they're constrained by
enable implicit versus enable explicit
and this allows it to behave just like
tuple does if I have wrap of string I
can implicitly or explicitly constructed
from con secured stars after decay in
this case it will actually take a
reference to array of five character
cons characters blah blah if I wrap a
vector in I can directly construct the
thing from int but I cannot implicitly
construct so this is how we implement
conditional explicit so I have a few
minutes left I'll quickly mention
various tuple issues that have appeared
in CS plus 17 yet has received over
loads for constable ref ref turns out
Const our values are an important value
category you cannot forget them it is a
safety issue although obscure it fixes a
subtle hole in the type system but if
you don't worry if you don't write how
the Jenner code you never need to know
about this
parent ripples default constructors have
been constrained turns out yes you can
constrain a default constructor you just
template it and hope nobody notices the
theme here is that in generic code you
really need to constrain the existence
of your constructors and because parent
Hoople are so fundamental they need this
level of attention the various
constructor is the perfect forwarding
the converting constructors have
received arity constraints so that they
don't exist for wrong argument numbers
there's a lot of controversy in the
committee about this eventually we
realized that Lib C has pluses extension
was evil because Lib C has pluses
maintainer z' admitted it was evil and
they finally realized it and so now we
have these arity constraints so that
this code is now well-formed basically
two tuples are only constructible for
two arguments two tuples are only can
implicitly convert to other two tuples
and so forth it's essentially what you
would expect so you can now write code
that depends on this and it will work
portably across the various
implementations visual seus plus has
supported this for many years there's
been a very complicated code about
ambiguity between perfect forwarding and
converting this has been resolved by
preferring purporting constructors
instead of the converting tuple
constructors this impacts your code if
you are writing one tuples of types that
are omni constructible so we could go
into the issue it's complicated I got to
load it up and remember exactly what's
going on it does it is a safety issue
this was not done lightly and if you
want to ever avoid thinking about this
when you have a type with a templated
constructor please constrain its
existence to exist only when it will
actually compile using enable if if
anybody will ever make a tuple um people
have been complaining oh if I have a
stood tuple of a boo signals type and
the type is not properly constrained
then converting the tuple doesn't work
and it's because of this issue it's
pretty horrible constrain your
constructors and it won't be home and
finally there's something that hasn't
even been filed as an issue yet but it
turns out the perfect 40 constructor can
actually out-compete the copy/move
constructor which is totally not desired
by anybody and although we have not
actually filed an issue yet all the
standard library implementers agree that
the copy/move constructor should win in
this case and we have updated our
implementations to
do that even though the standard doesn't
yet say so this is actually exactly what
the ramp type did in my example with
that not self thing that is taken
directly from our production code this
avoids particularly egregious blow ups
you never need to know about it because
it has been fixed so if you want to know
more I did mention everything here is
available in vs 2015 update 3 the only
things that are missing are things that
are voted into the standard very
recently get for cons tuple ref ref all
of those overloads have been implemented
they will appear in the next version
which is confusingly called vs 15 and
air quotes I did not name it apply and
make from tuple I implemented them
locally on my machine I was all ready to
check them in on Monday so I would not
need this bullet point and a pass my
tests and I ran it against Lindsey s
plusses test with our compiler and our
STL and I immediately found two compiler
bugs Thank You Lib C pool spots so I
felt really bad about checking that in
with those failures so I'm not going to
do that yet I'm going to get back from
secret peek on properly reduce the
compiler bugs then disable those tests
and check the thing in but I do expect
it will get into vs 15 I just can't
promise that yet
everything here I've talked about is as
of the currency of 17 working paper
there's the current length this will
change but as of right now that's what
I'm before me too so if you have further
questions you can email me my address is
there it's very easy to remember I'm
also finally on Twitter so you can
follow me there and I guess I have time
to take two minutes worth of questions
from the audience
anybody have residents yeah bet though
we have the question is how we compare
conjunction and disjunction against hold
expressions and my answer is very simple
we don't have them and see when X X yet
so they don't exist for me yet I imagine
we will look at the difference between
throughput and so forth but right now we
do not we have looked at fold
expressions versus conjunction and
disjunction yeah question net slide 45
oh let's the compiler error if you get
the sort of thing wrong the problem with
spin a is if it goes wrong stuff just
vanishes various compilers differ clang
in GCC now will tell you oh you know I
tried to call this thing but I didn't
actually find any overloads I had to
remove a and B because of criterion C
and D Co and xx just says I couldn't
find the thing that will improve
hopefully in the future but yes
essentially the quality of our matches
message is very and it's a hard problem
because the tools that we have for
constraining constructors like this or
just to make them appear disappear it's
a very blunt instrument and I do feel
bad for compilers when they have to omit
Diagnostics yeah question there slide 36
do these implicit construction behavior
extend operator overloads operator
overloads are just functions so tuple is
only concerned about am i constructing
either from perfect forwarding or by
converting from another tuple it is no
idea what context it is here tuple only
sees a call - it's perfect forwarding
constructor it is no idea that I'm in a
return or in a function call so
essentially whatever context in the core
language you're trying to invoke the
stuff in if it's considered implicit
versus explicit according to the core
language rules that's what will
determine what tuple does with it so it
looks like we're out of time
I'll be available later to answer
questions thanks for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>