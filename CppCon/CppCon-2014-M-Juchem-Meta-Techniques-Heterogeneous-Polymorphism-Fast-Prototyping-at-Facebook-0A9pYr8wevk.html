<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2014: M. Juchem &quot;Meta Techniques: Heterogeneous Polymorphism &amp; Fast Prototyping at Facebook&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2014: M. Juchem &quot;Meta Techniques: Heterogeneous Polymorphism &amp; Fast Prototyping at Facebook&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2014: M. Juchem &quot;Meta Techniques: Heterogeneous Polymorphism &amp; Fast Prototyping at Facebook&quot;</b></h2><h5 class="post__date">2014-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0A9pYr8wevk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so let's get it started hey my name
is Marcelo I work for Facebook as a
software engineering I work on the site
integrity infrastructure team and I do
some some coding on the fully open
source library as well and some of the
common code base for Facebook and I'm
here today to talk about meta
programming so there's a lot of ground
to cover
I'm gonna skim through some examples or
some interfaces for you don't worry you
should not be concerned about
understanding how things are implemented
at first it should just make sense all
of this will be available for you later
so don't worry about taking notes or any
of that I will ask you to hold the
questions in through the end of the talk
again because there's a lot of ground to
cover
ok so this is the agenda for this talk
I'll give you a little bit of motivation
like why do we care about these
techniques I'm gonna give you some tools
that we can use for making this happen
we're gonna give you some practical
examples and then I'm gonna talk about
if they're a genius polymorphism and why
the hell what the hell do we mean by it
and then I'm gonna show you how to
prototype our database so as a guest
we're going to implement a database here
so motivation and expectations I want
you to take a quick look at this and see
what you make of it I mean does this
code make sense to you or let me
highlight it for you just give you a few
seconds in try to make the best out of
it
sorry
oh the great parts are not that
important so but uh is there any way to
make heat darker because I cannot really
change the colors right now but it's
basically using support data types
equals Lib : : type lists we're just
instantiate in a type list that's it so
this is basically a list of data types
as you can imagine those are the data
types we support in our database it is a
database that stores data types rather
than just tables like if you are
familiar with Radice that's sort of what
we're trying to prototype here we're
going to store maps or strings or
vectors in our database and we'll be
able to particular operations on it as
you can see I there's a stir list there
you can't imagine that this is a string
and this is the name of this data type
we have a type associated with it which
is basically it's the factory of string
so this basically means we have a vector
of strings we have a constructor that
takes no parameters well you may guess
what that is and we have operations with
the name like at and we have a method
associated with that which is the math
of add which is a member function and
there is some sort of signature there it
seems like at returns a string and take
this size T as a parameter it's kind of
what we would expect from a vector right
B you give your name to X and you take a
string out of it and the rest of this
code should make sense to you even
though you don't fully understand at
first what it means it should be
intuitive like we are declaring types
for our database we are declaring what
the constructor for this types look like
what the parameter what parameters you
take we're declaring what operations are
possible to to be executed on this data
type and we're associating that with a
functor that is gonna actually execute
at a runtime and we're going
energy-giving the signature for it and
you can see that both data structures
are different
they have different operations we're not
limited to giving the same operations to
all data structures now what do you
think just happened here the great part
is whatever we had in last light slide
so we haven't changed that at all we
just added something new so basically
what it did is we just enhanced our
database now we support a third data
structure which is a map and this map is
implemented using a unordered map of
string to string and it has its own
operations that are not the same as you
other ones above you can use any sort of
data structure and not limited to the
standard library you could you could use
just boost accumulators here if you want
to calculate medians if you're concerned
about distribution is this sort of
things or whatever data structures you
have in your in your company so this is
not new this is a quote from a book from
2001 by andre alexandra SQ he is well
known and if you haven't read it you
should you please PLEASE say that you go
to meetings you realize there are
changes that you need to your project
and you go back you write a single line
of code and you're done you compile it's
runs and everything works as advertised
there are a lot of efforts there were a
lot of efforts in the past to make it
happen some people who got successful to
some extent we have new tools today like
suppose suppose I haven't brought a lot
of meta programming techniques for us so
we don't have to devise that many
mechanisms to make it happen I'm not
saying we we can do everything today we
are still limited the language is not
that perfect but we have a lot more
tools at hand so we can make our lives
easier what if I told you that that code
I showed you in the beginning is
everything you need to support those new
the instructors there's nothing else
that you need all the rest of the code
for database be it for executing
operations for serializing operations
for reading input from a console for
displaying help for displaying at Jason
with all the operations you have in a
database all of that can be generated
from that particular metadata I mean
that's the goal here
we hate boilerplate and we hate
repeating ourselves because that's
error-prone and that's counterproductive
and we want speed so we'll try to get
the best out of it so that may not be a
wise choice but we have a live demo here
is this
I'm just compiling the database and
there we have a console and we can say
help it lists the data structures we
have this is according to the first
slide we still don't have map here you
can see that we have the same operations
that same data structures in you have
the signature over there you could say
Jason and it creates a JSON for you you
could create an XML if you're concerned
about web services if you're publishing
it somewhere I mean use your imagination
but if all the metadata is there and you
can use it however you please but let's
actually use it to use this thing so
let's create a shrink s oh we need a
parameter and if we go back to the
metadata itself the constructor for
string requires a string as we said
constructor for vector doesn't so let's
just provide the string create string
pass with hello seems like it worked so
what are the commands again we can get
the string get s hello we can
- s let's a fan you know underscore
world and let's get this again well that
is it
let's see the size of it flavin seems
about right
okay let's create a factor actually it's
a list right we don't expect any
parameters for this list it's empty so
let's insert into L some string who
let's insert into L R let's guess the
size of oil can
it's too so we have also the add
operation at index zero its who at index
two actually we only have two items
right so I think is one oh sorry about
that
okay this is how to weave generous size
okay their difficulties but anyway we
just see that we're executing code and
deriving that front of metadata that we
have before let's actually change that
code to include the map
so
well why is it not working you know let
me trace this connectivism dragon
okay we'll have to do our best here
I'm gonna add the map the map that we
had before I'm gonna give this and
now we have a map over dere with the
operations that we had before okay so
that's it for light demo so what is the
motivation for this I mean we seen how
how easy it is to add new stuff to our
code right we don't have to write water
plate we don't have to that's bad
we don't have to write a lot of
boilerplate to support new features in
our intercooled we can just there I have
what whatever we want when you're
translating some ideas into code it's
hard to it's hard to figure out where to
put them you have to spread it out in
the code and it makes it hard to reason
about the software you're writing
sometimes you have to replicate logic
depending on how many components you
have if it is if it is a complex system
it just gets worse and worse so we want
to avoid that and if you're writing a
high level ranging that reads stuff from
a configuration file or it may be
process this metadata from this
configuration file it generates some
something dynamically you have to do it
at some point of the execution of your
program and that takes CPU that takes
memory and it takes heat to the cache
and you may have misses and that's
concurrent to the data you're actually
processing and that hurts performance if
you can't do it all of that at compile
time you have a win because none of that
is executing in your code when you run
it and you're saving money in your data
centers so what if you could do whatever
we just seem like describe your your
software as metadata manipulated
efficiently at compile time use
well-known data structures like lists
Maps I mean we use it every day in
slopes or a problem so we do it at run
time why not do that at compile time if
you can and automatically translate this
metadata to code however you please to
implement whatever features you want and
we want to go from runtime to TMP at
some point because you can say all these
data types that you support but at some
point you're gonna have to read the
string from Center input and you're
going to have to decide which of those
data structures are you referring to and
what one of those operations are you
trying to execute and why not give this
power to people who are not that
familiar with template metaprogramming
not everybody you might be able to write
the engine for you but I mean anybody
can understand that thing that we saw in
the beginning I mean it's it's just it's
just the description of your software
it's friendlier than just a lot of
specializations in whatever so
expectations this is not a template
metaprogramming tutorial so I expect you
have some familiarity with it you don't
have to be a world-class expert I am NOT
one but you should be familiar with that
this is not panacea either it solves a
lot of problems but not everything is a
nail for this hammer so when you when
you have a nail it actually helps but
you shouldn't overuse it like any other
feature out there and I'm not gonna show
you extensive code listings I ran this
demonstration for you so you have a
feeling and get a little motivated about
it but it but I'm gonna describe very
very high level what this is about and
how to use it I just want you to
understand the idea and have an
intuitive feeling of how this works I
don't want you to care about how a type
list is implemented if we will Failla be
available for you if you re interested
you can look at implementation there are
tons of other implementations out there
like boost MPL but don't worry about
that too much assume there's a library
that does all of this for you and more
on that later and like I said when you
have neo you get all the benefits that
we just talked about you catch bugs at
compile time because now you're not
processing this metadata at runtime
anymore you made you may go out silently
if you don't look at the logs if you're
processing that are in time but if it's
compiling I mean your software is just
not gonna compile and you were this
footprint because you don't have all
this data metadata anymore in memory if
you will it's just cold after you
compile it it might increase performance
more often than not it does if we have
time I can show you a little benchmark
at the end for a small portion of it so
the goal is having the working prototype
for the video base that stores the
structures rather than tables supports
several operations you we want to do
that with less than 400 lines of code
that's how many lines of code our
prototype there needs
actually 274 and you can add as many
data structures as you want without
changing that and
and it's gonna work just like the scene
and you can't really add or remove types
or operations so let's reach our toolkit
I'm gonna just so show you some mappings
of how you do things at runtime and how
that translates to meta programming here
this is probably not new to most of you
so I'm just gonna skim through it I
don't want to waste too much time here
so we have variables see purple has a
type name and some value associated to
that in TMP we use type Alice's type
apps when you create a struct you also
have a type with a name
when you stand she ate a template you
also have a type so but nothing over
here right so scalars you also need data
at some point you're gonna need integers
you're going to be need maybe
floating-point how do you do that in KMP
well in carob constant is there for
quite some time in boost is now here in
C++ so just use it you should read that
as I have a variable if you will X with
both type int and we has a belt an or
there's no easy way to to to represent
doubles or floats in metaprogramming but
we'll do our best we have stud ratio you
can be creative here but we're not
really going to use it right here I'm
just going just here to show you some
way to do that so lists I mean one of
the most common data structure that is
we can use it is a vector to represent
it at runtime of an array is that array
is the list of wherever you you can
think of I mean nothing new so how do
you do that at the templates you can use
a type list assume there is a type list
implementation in some library somewhere
again this is
I mean this was implemented by Andrea
law a long time ago whose MPL has it we
have our own version here so you should
think of it as your instance shading
alias X with four types in eighty one
two three and four and that's basically
it
you're not we in metaprogramming we
don't handle the values we handle types
we're just exploiting the type system
there you have another list with
Interpol employed and you have a third
list with internal constant to represent
one two and three there is another thing
that will make our life easier to me to
represent integers and whatnot but let's
hold that thought for a moment some
operational lists just like we do
irregular lists in the top we're just
instantiating a list with you one two
three and four so we have the slight
separation which is basically returns
you a sub list with the indexes is just
escape or you can get the size of a list
you can get the character of sorry the
the type at the specific position of the
list here we're taking the middle of the
list so it's gonna return t2 you have
four rich I mean that's something we
usually need if you're handing data
structures so you can either eight
through all the elements of a list it
doesn't make sense to do that a
compile-time because you can't I mean
there's no such thing as iterating you
only create types which are immutables
but at runtime it makes sense so we can
actually have a visitor and here I use a
C++ 14 feature which is the polymorphic
lambda because it's just easier to write
I give it a visitor and for each of the
types in the cyclist it's going to call
this visitor with a type of information
so tag is basically the type itself and
the index of this type you can just use
a tackle type tag Kokomo type and and
call a common value for the index and
that's it and you have another another
method there which is visit that if you
want to you have like an integer which
is an index into this into the data
structure
this this integer is available runtime
so you may have
from standard input and you want to get
the type associated to that so the way
you do that is you call visit you give
this index and you pass a visitor to it
it also gives you the same type of type
information and I mean you you have a
tuple for instance to represent data at
runtime so we could for instance
instantiate a tuple
I mean derive a tuple from this list I
mean we want a tuple with all the data
types from this list so what we do is we
call apply so you give it a template to
the to the apply operation and you will
just create that type for you so list
you one two three and four come on come
on apply tuple we will give you a tuple
of T one two three and four that's it
there's another operation which is
transform it's it's very very similar to
apply but instead it applies this
transform to each of the elements of the
list so it's going to return you a list
with the same size but the elements of
this list is are going to be the result
of this transform applied to each of the
elements so if you have and sorry about
the great code of order III oh I hope
you can at least see some of it but
basically I basically have a list of a
few integer interval constants of type
integer and I am passing it the square
transform which is just gonna return you
an interval concept with the Velo
squared and that's what it does if you
give it a list of 1 2 3 &amp;amp; 4 it's gonna
return you a list of 1 4 9 and 16 that's
it and we have merge sort
why not you if you can give me a
template that compares two types and I'm
talking about types not values and tell
me if one is smaller than the other I
can sort it for you this is quite handy
as you will see soon so especially when
your lists are comprised of integral
constants and if you can sort then why
the hell not have a binary search
templates when you're in generating some
Tampa
or you're calling some very attic
function or aesthetic function if you
will
it relies on recursion and you cannot do
random access with recursion so we
cannot just say visit this guy over here
and give me this value at runtime you
need to do that
in a recursive way so the best we can do
is we can at every step split the list
in the middle and compare to that guy
and either go left or right to save
steps and this is a binary search as we
all know so you can call a binary search
: commonly exact which will look for an
exact value and it's gonna return you a
true either true or false if it finds
the Velo or not and it's if it finds the
value it's going to call the visitor
with the type information that you want
like the type in the index and the
needle itself and we also have lower
bound and upper bound because why not
right it's useful so just so you have an
idea of the code that's generated for
that it's what you would expect I don't
want to delve too much into this but it
looks I mean imagine you have a list
from 1 to 7 here you first look at the
middle element which is 4 and you either
go left or right let's assume we're
looking for 3 so you go left it's the
first if and there are you you split in
the middle again which is 2 and you
either go left or right we go right and
you look at the I mean now we want to
have one element which is 3 and you look
at the element there you go you've found
it or maybe you're looking forward two
and a half and it's not there but the
thing is at every if statement we're
dividing the problem by two like any
binary search so at most you're gonna
have log of n comparisons so it makes it
quite I mean more efficient than a
linear search if you will and this is
actual code you're not iterating over an
a vector you're running code so a list
of scalars because you don't want to
type in zero concern all the time right
so if you have a vector of int it's the
same as saying I have a constant
sequence of int
and those are the values if you want a
contiguous sequence like one two three
four five six nine five five six seven
eight nine you can just use constant
range and give you the starting position
and again just like either hydrators
work and it's going to generate a
constant sequence for you it's just a
handy tool to have we're just building a
toolkit that we're gonna exploit later
so I'm I don't really want you to
memorize these especially because you're
already familiar with most of the
operations here I just want you to get a
feeling of what the syntax looks like
and what does it feel to do this and
programming with this library and since
we already know we have values why not
have some handy way to return an
automatically allocated array with this
values right so it can call a call colon
colon array and it's actually going to
return you a stud array with all this
elements which is automatically
allocated and Z array is just a handy
way to say I want a new Terminator
appended to the end and you can't
actually specify what the new Terminator
is but to the full is 0 strings we have
sequences of values right why not have
strings meaning a string is just a
sequence --is sequence of characters
exactly the same thing as a constant
sequence so the way we do it is with
type string you give it the type of the
characters in each of the characters
this is quite verbose depending on what
strings you're trying to represent so
why not have a heavyweight to represent
that the best way I could do is with a
macro so type stir will return you type
named Y with the type string hello it's
the same as the pineapple of that and
you can do that for different character
types like a white character there and
type stir will just work in return you a
white string and you can have strings of
other types as well but I mean if you
can represent that with a string literal
type stirrup will look work any inherits
from constant sequence so he has all the
methods and it's not it's not
inheritance in the sense of polymorphism
it's just
inheriting the the static methods and in
the member type types so string
operations beside all of that besides
all of the list operations and and
sequence operations as we just seen we
might be interested in getting a stud
string the dynamically allocated string
out of it so why not right
so colon colon string gives you just
that maps like now it's starting to get
interesting a lot of time we're trying
to look up something like I have this
string what is the metadata associated
to that string I have the string map I
want to know what is the metadata for
the map data structure or something like
that so Maps here can help so the way
you represented in meta programming with
this library is you just like you will
do with an order map you say give me a
type map and the elements are the type
pair of K 1 b v 1 and K 2 V 2 and
there's a handy operate a handy function
here or whatever you may call it that
doesn't require you to type type here
all the time so you can just say build
type map of K 1 V 1 K 2 V 2 and it's
gonna get all the elements pairwise and
beautiful you and you can view the type
in Apple strings I mean why not I mean
those strings are just types they are
not stored anywhere they're just types
it's just a type system so it's the same
thing some operations as you would
expect we have fine you can find I mean
finally the method type for this key so
if you pass it k1 I mean the type map
and the top is K 1 D 1 K 2 V 2 so give
me the the method type for the key K 1
is gonna give you one if you look for K
3 it's not in the map is gonna return
you type not found tag which is a
special type that I have or you can say
if you don't fight it if you don't find
K 3 return me TX ok it's handy you can
also get a type list of the keys of this
map you can get a type list of the
mapping types of this map and you can
visit elements of this map like I want
to visit the specific key which is k1
and use this visitor and this visitor is
going to receive the same information
it's gonna be you're gonna have access
to the type air itself and the index eh
it appears in the map actually sorry it
doesn't give you the index it just gives
you the type air and just like this you
can sort the map according to the keys
if you can come up with a comparator for
it
imagine if they were constant and it
becomes clear when it's useful and you
can binary search for it as well just
like we did in business well it's I mean
we have maps we have strings so why the
hell not having a prefix-free right we
want to have a fishing lookup of strings
and we want to build at at compile time
so we don't have to pay the price for it
at at runtime we don't want to
instantiate an order map just to do like
strings which case you can easily
implement a string switch case using
this thing by building a tie prefix tree
and passing it visitor with
specializations for like overloads for
the free operator paren function for
each of the type strings you want to
match so same thing here you you call
tie prefix 3 : color match I want an
exact match you pass the idolator's to
begin in the end of the actual runtime
string and you pass the visitor
so this visitor is gonna be it's gonna
be called we have the type of
information that you need
if it's not in prefix 3 is gonna return
false so variance I I'm in love with
this data structure especially for
template metaprogramming because it's so
friendly to to to type list type apps
just like a tuple where you can't apply
types to it and you have I mean you
cannot it's not it's not a container in
the sense of a list or a tuple you can
only start one type one value at a given
time but the value has to be of one of
these types of her there so it could
either be an int or it
double the way this is usually
implemented is a union so it shares the
same memory location you're not you're
not wasting memory here by doubling the
size of in depending or frankly the size
of in depending on how many types you're
supporting most of you should be
familiar with parents already especially
if you did come programming in the past
or I mean jscript whatever this is kinda
similar to to to boost any it's actually
more more more it's actually just like
who's fearing but if you come from a
scripting background you can think of it
as like just a variable that takes up
any particular type so we instantiate a
variant here we in the second line we
actually derived this variant from a
type list with of int and double so we
instantiate this variant and it's empty
at first and you associate you assign
the value of five to it and it's gonna
actually store there in sumeria location
and you can try to get an intern of it
and you will give you the mint because
there's an in-store there or you could
try to get a double and it's not gonna
give you anything it's gonna give an
exception because yes it's so portable
but there are no doubles store there or
you could try to get a string
I mean strings are not supported by this
variant so is this code is not gonna
compile which is good because we want
this sort of error to be to be readily
available at compile time and you can
try to store a double into this variant
it accepts a double so it's gonna store
it it's gonna replace the int you can
try to get a need from it it's not gonna
give an exception it's gonna give you
either a pointer to date if it has an
eight store there or a new pointer if it
the type store there is not an int where
it's empty and you could also visit this
parent I mean I don't know which type is
there but I want to perform some
operation on this type so here is a
visitor and call this visitor we are
with whatever type is there the good
thing is that value will be of the same
type
the thing that's inside the variant so
you will have type information when you
when you access this element you know
exactly what store there even though you
didn't before you call visit and you
could also say this variant is of is
this variant of type double is it of
type int it's gonna return you either
true or false those are not all the
operations those data structures have
I'm just showing you the most important
or most noteworthy for a purpose here
but I mean it should be intuitive after
you seen this so how do we cross
boundaries I mean going from templates
and types to runtime is easy I mean you
already have this information there you
have a an interval constant you can just
say : common value you have the value of
this of this type it's also easy to
choose templates based on compile type
parameters suppose you have a function
that has a template parameter index you
can easily easily say Oh from this list
give me the Ummat at this index and it's
gonna give you that a compile time
because you have all the information
already in the compiler but is it
possible to choose templates i mean i
want type information but I only have
real time data real time data has no
type I mean the processor doesn't know
types the compiler knows types the
processor only knows code and yesterday
as you might guess is yes we just did
that a lot of times or the visitors but
I've got to give you a few a few rules
of thumb here if you have an integer
index and you want to get the type
associated with that from a type list
what you do is this : come on visit this
index enter visitor there you go you
went from the value real time value with
no type information order than it is
need X and you just have a tag with the
information that you want which is the
type you're looking for it could be the
the order map that we had before it
could be the vector we had before it
could be the boost accumulator that we
that we reran in toward the searcher the
important thing is we have the types
here you can you can have the call type
tag
I word echo type tag Bella 14 a
prototype in the value sorry
type in the index so how do you go from
a string to a type we just did that
before as well with the type prefix tree
you look it up with for an exact match
and it's gonna give you okay this is the
type that's associated to this runtime
string which is going to be a type
string it's gonna have the same contents
you could exploit this data structure if
you want to customize it if you really
know what you're doing with template
metaprogramming without changing the
data structure at all it supports for
instance custom comb compares and and
what not so you could you don't have to
have a stud string and a type string you
could have anything here as long as you
can do them happy and as long as you can
sort it um and there you go we have the
needle over there which is the type
stream type information and what you
could do is now that I have this type
string I want to look it up in the first
map that we seen before in the beginning
of this talk so for the string lists
what is the type string for it it's stir
list
what is the metadata associated with it
and it's gonna return as the data type
structure that we seen before and from
this data type we can infer constructor
we can infer operations we can infer
what are the arguments that this method
need or the what is the filter that I
have to call to executed so a practical
example using all the things that we
just seen let's write an engine I mean
it's going to be simpler than the first
one we seen let's write an engine that's
capable of running by making stateless
operations like I just want to read a
train from Senator input I mean a couple
strings from standard input then I want
to join them I want to see the result
but the thing is I want a single engine
I don't want to have to write this for
every single operation that I want to
support the operations are described
with the metadata just very similar to
the first one you see and it's gonna
have like whatever it is we don't care
and the engine API should look like this
I just call up a method called run
operation
I passed the operation metadata to it
and it's gonna do just what we want how
do we do that so let's just look at the
metadata so little I mean you might see
a little proposed because it's just a
single creation but remember we're
concerned about having multiple
operations without having to change this
thing before so this struct metadata
here won't change
he holds the name which is a type string
or with the name of the operation
he holds a method which is just you know
the the type of a functor it holds the
result which is the result is gonna be
returned from this filter and it has
ARDS with this which is a type list of
the arts arguments we expect to pass to
this to this filter and there you have
the filter which is just a regular
filter class it has an affray Dorper and
every time string takes two strings as a
bram and returns the concatenation of
those strings I mean no big deal right
and we also have the a type string yard
just because we want to name this and
the last line is how you declare this
metadata for a joint abrasion it's just
automatic data it has a name which is to
join he has this filter which is that
thing we just declared and the signature
free it is returns a string and takes
two strings as a parameter what do we
make of it so here's how we run
operation operation is gonna look like
first we're gonna just pray the name of
it I mean why not like and we're gonna
derive a tuple I mean the type of the
tuple to hold the arguments that we need
to pass through this functor in this
case is two strings but it could be size
t it could be nothing so we're gonna do
that dynamically and thereby dynamically
I mean at the bottom we're gonna read
the arguments from standard input into
this top and we're going to expand the
tuples so we can call in this filter
with the Artemis because the tuple is
just one variable right he holds a lot
of data
it's just one variable if you want to
call a function you have to pass each of
the components of a total I mean how do
we do that in an easy way and we're
gonna do a little trick but it's gonna
be easy so print in the name of it is
just we get the metadata comical a name
conk on a string that's it and that's C
out this name derive the tupple is just
the the grayed out things are just
tightening so we say Oh : c'mon arts
which is a type list of string string
comma comma apply to tupple and it's
going to return me type of set up Oh
string string and I'm gonna instantiate
a variable called arts which is this
double now we have to read data into it
right from cerny but we use a for each
so we get the list of arguments for each
of those arguments we're gonna say stud
get the element from the stubble arts
from the index of the type we're
visiting so we're if we have two types
two strings is going to be the index at
the stringer Dinges index zero and
string at index one it does that two
times because the size of this list is
two and we just populated the table
we're gonna expand the tupple I mean a
little bit but what we do is we create a
constant range of indexes this is the
trick I'm gonna show you some of you
might be familiar with it but we have a
sequence of illnesses right if we have
two index two arguments is 0 and 1 of
type size T and we're gonna have a
helper method here called call method we
pass some metadata like the method we
want to call and the result type and we
pass this constant range as not a
template parameter but as a runtime
parameter because we want pattern
matching we want type deduction here we
want the compiler to be smart for us we
actually what we actually want is to
expand this constant sequence
to a very attic pack of arguments so we
can later say sadhya dot dot and it's
gonna do the magic for us and we passed
a couple witches orgs and finally we
call the method which is this thing here
we say instantiate the method I mean
notice that we receive the constant
sequence there with the indexes as as a
pair as a pack of size T it's not a
single size T so the data that can do a
lot of magic for us you are probably
familiar with that I expect you to be at
least and then we say call this method
and return whatever it returns and pass
to it
Stud get of the indexes of the temple
dot dot dot
so this is going to expand Oh what have
added here but it's going to span this
to return method for the example joint
is going to expand to return method of
still get zero of top o comas to get one
of double I mean it's a simple trick
there are a lot of implementations of
apply tuple with and and all that I've
seen so far require recursion which
might or might be elided duty to tail
recursiveness this thing here doesn't
require recursion so okay so we have an
engine to call arbitrary operations they
are stateless and we can say I want to
call this particular operation but we
cannot dynamically choose what operation
we're calling so let's do that right now
I mean that's just what I described here
we want to read the operation name from
stirring pit as well and we're gonna
have some read eval print loop just
because it's nice
so the metadata is the same thing we
have a for we have the stream for the
name of substrate because we're ready
another operation here which is substr
we're going to want to return the sub
stream and we have a filter for substr
as well so we're just adding a new line
to the actually where we're making the
list now and were you ready a new line
to it first we have the line that we
have before for a joint and now we have
the line on new line for sub sir I mean
this is what describes the operations
supported from by this program that
thing here this single line does exactly
what we wanted as a new operation
without touching any new code but our
agent didn't support that before so
let's make it support we're gonna create
create a few auxilary data structures
for us we're gonna build a map because
we want to look up from a type string to
the metadata so we can call run
operation like we did before and we're
we're reading the string from Center
David right so we need a try which is
the griffix tree that we mentioned
before
to do this look this transformation from
runtime string to compile time string
for us
what does our wrap will look like it's
just a loop that reads the string for
centering the for for loop there and it
looks this up in the prefix stream like
is the OP tree colon colon match go
along exact it just converts the runtime
string to a type string for us the trick
that we seen before and it gives a a
polymorphic lambda to it which is our
visitor and what this visitor has does
is it has the type string it has type
information that we derived from runtime
data data so what we do is we find the
string in the map that we created before
so that from the type string we can
derive the metadata for the operation
and now that we have the metadata for
the operation we can just say run this
operation which is the code that we had
before and that's it and if not found
operation Athan I mean it sounds simple
to me
and that's it if you want to add more
operations to it you have the engine
ready all you do is add newlines to this
type list here and you're done you don't
need you don't need to be a temple
specialist to do that and the reason why
it's good is imagining you have this
large-scale service that's really
complex its deploy to thousands of
machines it costs a lot for your company
and you wanna you want to add more more
functionality to it but I mean you don't
have the time to do that yourself and
you you also don't want to be a
bottleneck you wanna have a body to be
to be able to do that I mean some some
guy in our team is to add something to
the service he can and he doesn't have
to have all the knowledge you have about
the system he just adds a new line so
heterogenous poor morphism what do I
mean by that it's just I have different
types we're just to do that with virtual
inheritance I have several different
types but I don't want them to have the
same interface because they are not the
same type they do not respect the Lascar
substitution principle I mean a binary
search tree or a bee tree has have
nothing to do with a hash set order than
they are data structures that can be
used to implement math but for instance
the trees have are good for arranged
queries you cannot do range queries
efficiently in Access
it's just an example you could think of
any types out there but I'm gonna use
data structures because they are
familiar to us so how do I do that how
do I represent that them and store them
in the same place virtually heritance is
not that good for you because you either
have to how are we gonna do that are you
gonna write a virtual method call a
ranch query and when you have a hash set
you're gonna throw or return a special
value or are you going to have some
method that returns some metadata that
says oh I am a b-tree so dynamic cast me
and do what you want I mean it starts
becoming hacky right and expense it
because all of this is happening at
runtime you're not doing this resolution
and compile time anymore
so there's a limitation to - to
virtually inheritance which is they
don't see templates you cannot call from
a base pointer you cannot call a
template method and expect the derived
class to run this for you and the right
types are raised you don't have the
information I mean if you say the base
class is a collection I mean ok what why
is the collection that is in there I
mean I don't know it could be a between
could be a hash set it could be anything
but I have no idea I could write my own
way to add this information there but
it's just more complexity that I'm
adding to my system and which makes it
more error-prone it makes it harder to
maintain and it increases cost because
this day at this this functionality is
actually running so they also have to do
with dynamic location it cannot
automatically allocate the derived class
and expect for inheritance to work you
could do some magic with custom
allocators but that's add the complexity
right and how do you do with factories
are you going to instantiate in an
ordered map that map's a string to a
factory and I mean yes you could many
people do that but that's edit cool
that's running that's more memory that's
being allocated for this another map and
every time you do that you may have a
page you may have a cache miss and had
to reload another memory another page of
memory and the code that you were
executing is not in memory anymore and I
mean page faults are costly right so why
not use variants we just seen that it
has a lot of the properties we were
interested in and we could say well it
stores a hash that stores a binary
search tree he stores the animal based
class so we can say new dog new line it
has nothing to do we have set but we can
and sometimes we want to do something
like that maybe not a dog but anything
else and you can call function templates
I mean it has all the template
information for you you can say called
the range operator and figure out at
compile time if this class actually has
range bridge the range of range scan
operation in there I mean we can do that
with Feeny we we know how to figure out
if a function exists if you guys have
been to two other Browns talk yesterday
you know how to do that and you can
figure out I mean does it have a member
type that does you have a function this
I mean you can do whatever you always
did with TMP the downside is that the
types can't have to be known beforehand
for a particular case here we're fine
because we're defining the metadata
beforehand anyway and the what dictates
the interfaces for methods is just a
visitor or even the types that this this
data structure has the visitor can have
an overload he can have some spin a here
in there it can use enable f2 to to
figure that out for you but you can do
that so how do you prototype the
database that we first seen in the first
example I'm now going to show you all
the code the code is live is gonna be
available to you if you're interested in
that but we're not concerned about that
right we're just we just want to know
how do we do that we want to have the
intuitive notion on how to do that it's
not too different from what we just did
we have the supported app which is just
the map of all the metadata that we have
before I just omitted here because we
already know how to do that we have the
by name which is a prefix tree built
from this supported type list or time at
the pool and we have the variant we
wanted to write a variant out of it so
we get the supported types which map
type string which is the name of the
type to the metadata itself we get the
mapa types which is the metadata we
transform this metadata to extract the
type of the data structure for out of it
so we now have a list of each of the
types of our districts we have a list of
for example before
vector of string another map of string
to string and string or it could have
loose accumulator b-tree whatever you
can think of and you put that to
univariant and this variant can store
any of editing even time one thing that
I didn't mention but I think it was
under one of the previous lights the
very an implementation that we have here
can be smart about choosing whether to
use dynamically dynamic or automatic
allocation if you can say easily for
this types use automatic allocation
because they are small for this order
types use dynamic allocation because
they are big or whatever technique you
want to know it just has to return a
bowl to say do I use automatic or
dynamic allocation you can look it up in
the API later it's gonna be available
for you but it's easy it's easy to do
that things like small buffer
optimizations are not triva but easy to
do and we have all the the engine figure
out but how do we store this I mean I
give a name to each of the instances
right X I said create a string with name
s I create a map of name M we just have
an order map from this name to this
parent and that's it that's how we store
this thing it could be a proxy into a
database and if you need any extra
metadata to to to derive certain ization
code you can add to the first metadata
to itself that we've seen before and how
do we say create create instance it just
uses the things we did before I just
commented out though that I didn't write
code for it because we just did that I
don't want to be gonna repeat and you
know the only thing that we care about
is that now after we're done we call the
creator with parent dot in place the
type were trying to in place and spend a
couple that we know how to expand
already and that's basically that
basically does it for us another thing
that I mean I'm not sure if you have
enough time but it's Qualtrics it's just
a way to instead of using stud bind or
instead of creating our own filters from
their classes most of the time we're
just concerned I mean I want to call a
method
this particular name I want to create
code for that just want to create this
filter here so I have a handy macro for
that that creates this call traits for
you that whatever you're passing if you
look at the operator brand you pass an
instance you pass the arguments and it
just forwards perfectly for these
arguments to the to the method with that
name and returns the result I mean this
no big deal but it's handy any he has a
lot of a few template a few reflection
facilities where you like is this
supported like you know the method name
so you call supportive with the type did
you want to know that if it has this
this method or not in the arguments and
it will do this finish for you when you
you've got to put in saying yes I can
call the signature or no one cannot it
provides a few more facilities for you
but we're just concerned about these
right now because we want to know we
don't we wonder are they our visitor to
the parent to compile and it bites
through the function name not to the
signature its stateless whatever we just
mentioned any provides reflection
information which is given for template
metaprogramming and the usage is this
you say cult rates this is the name of
the cult race class so we actually
creates a class for you this is an
actual class and this is the and foo is
the name of the method I want this class
to be responsible for the rest of it is
no big deal you can say supported so I
want to know if bar supports a method
with no wiring a method foo with no
arguments or with the argument int and
then the last two lines is just so how
you use it to call methods which is use
the per an operator past instance and
pass the arguments we have done first
full circle we came back to the first
example we now know how to implement
this vein we know how to treat the type
strings which are in yellow we know how
to create the the call traits which are
in green and we know how to deal with
the argument list which
are in the signature with which is in
red now we can be happy and be creative
with this if we want but then show you
uses
I haven't implemented this myself I have
some tests that I want to work on that
are related to this so I don't have any
working prototype I don't know for sure
if if it works but I have a good feeling
that it does we could for instance the
finding metadata that says I have an
interface user interface that has a text
field for a username a text field for
password and has a submit button and I
can specialize visitors to render that
using gtk or to you to handle to render
using and curses or to render XML HTML
for us or whatever you can think of we
can you can derive portable database
models like those are the entities that
I have and you describe all the metadata
for the end it is like I have a class I
have a table person with those
attributes and I have some queries which
is like this is the name of the query
it's gonna make a join in this
attributes I have a where clause I have
an output and you can have specialized
visitors to say execute this this query
for me in my sickle or sequel light and
whatever it is that you have to change
for it shows that all of those databases
you already know the metadata you're not
storing as a simple queries a string
anymore you don't have to parse it you
have all the metadata there oh but I
have this specialized indexing my simple
that's fine you know how to use it your
engine knows how to use it and after we
have the engine gone you don't have to
worry about it and you don't have you
don't have to know again you don't have
to no matter programming to write those
queries I mean they're kind of self
descriptive other uses maybe all to
generate stubs I mean you can have a
binary that actually generates code for
you in Java or Python or whatever to
call bindings for your service in C++
you can also generate ideals for
whatever sorry maybe comm IDL or maybe
thrift IDL or whatever IDL you want to
to use so you can to write that from
code you don't have to run a code
generation before you you run your your
C++ compiler and it's gonna always be up
to date because you're generating that
for actual life code that compiles you
can derive the serialization code if you
have enough metadata in your your your
in your software you could drive
concurrency model you can I mean you can
specify I have those components and
those components share information this
way I don't care how you implement that
if you use a mutex if you use a lock
freak you I don't care I just want this
to work and you can have all of this all
of this metadata we process by some TMP
facilities which you have a lot of tools
to use and you can say ok instantiate a
topo or whatever you need with love
mutex here or a lock for EQ there and do
that automatically for me you can have
experts write this engine for you so
that you don't care about concurrency
anymore you just say how you're going to
use this data and what the interactions
of the service can be so questions so I
think the talk was extremely interesting
I think I I'm missing a step and the
first part of the talk where we are
generating the code like when we have
the visitor order for each pattern how
exactly are we going from that lambda to
the generated code if you could
elaborate a little more on that because
for example we had the Exile with the
tree example you showed us an example of
code with the if and else and how can we
get from the lambda to that basically
the way code is generated from templates
I mean runtime code is generated from
templates it's just production you have
time to information that's passed down
the pipe and you have recursive
functions that call other possibly other
functions or itself that's how you
should do it
it should be very familiar to functional
programmers how to do that
maybe C++ programmers are not that
familiar with functional programming I
mean this is changing but it's basically
a recursion there there's there are no
tricks here and and also function
overloads for instance if I have a if I
have a type prefix or a pass it a filter
let's imagine our visitor is not a land
anymore it's a class that we wrote and
we're rewriting the operator paren here
and we can say okay I have an operator
paren there receives a template
parameter so whatever he receives I'm
gonna be fine with it but I want to
specialize it for this particular string
you just create an overload and say when
is this particularly string I mean this
is a more specialized overload right so
this is the one that's going to be
called and that's basically how we do it
thank you very much sorry so I guess the
session is over just or all the time but
I have a small pinch mark but just to
tell you how to get it I mean as we
speak this is being open source by
Facebook it's engage hubs like Facebook
/ fatal which stands for Facebook
template library so you can go there use
it those lights are there the demo
program is there all the libraries there
it's fully commanded so you have the
documentation there and if you're
excited about this we are hiring you can
come to Facebook party that thank you so
much for attack</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>