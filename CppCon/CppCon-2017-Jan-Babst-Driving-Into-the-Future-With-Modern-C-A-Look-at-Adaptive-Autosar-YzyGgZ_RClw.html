<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Jan Babst “Driving Into the Future With Modern C++: A Look at Adaptive Autosar” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Jan Babst “Driving Into the Future With Modern C++: A Look at Adaptive Autosar” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Jan Babst “Driving Into the Future With Modern C++: A Look at Adaptive Autosar”</b></h2><h5 class="post__date">2017-10-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YzyGgZ_RClw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Okay.
Hi, everybody.
Good afternoon.
Thanks for coming to the session.
This is my first experience with CppCon.
It's a great pleasure to be here.
Yeah.
The automotive industry is
undergoing a lot of change currently.
You may have seen that
or read about this in the press,
and this will continue for
years to come, of course.
And we will look at
a very tiny fraction of this change today.
This is what affects us as programmers,
and this is how C++ is used
and it's changing the way
C++ is used in the industry.
A big factor with this
change is Adaptive AUTOSAR.
So I explain a bit about
what Adaptive AUTOSAR is,
and then we'll go into and have a look at
the coding guidelines that
were created within AUTOSAR.
Now, this is a car seen
through the eyes of my daughter
and through her drawing pencils.
And this is what most people in the world
probably think of a car.
It's got wheels.
It's got body, windows,
a light in the front,
exhaust fumes in the back.
That's all you need.
Some people know, few
people maybe, but still,
many people know that if you go inside
and sit at the driver's seat
and you have dashboard instruments,
you may have a meter system.
You may have a map display, navigation.
So there is some computing going on.
There's software.
But even fewer people understand that
really if you look under
the hoods and into the car,
there's a lot of computing going on.
There are these many little control units
which control the airbag
or control the climate,
the brakes, and so on.
And this is,
this is the realm of AUTOSAR.
AUTOSAR is a specification
for the basic software
in these control units.
It's like a platform,
and
characteristic thing of
these control units is
they are small, relatively small.
They're of a single purpose.
They are configured at compile time.
You set it up all at compile time.
For example, there's never
any dynamic memory allocation.
All set up, then, at compile time,
and then it runs.
It's all written in C,
so the classic AUTOSAR
specification is all in C.
Now right now, this is standard.
There's an organization behind it,
and that is the AUTOSAR Consortium,
and this consists of
more than 200 partners
from all over the industry.
Of course, major common factor is
hardware suppliers, a lot
of software companies,
(mumbles) and so on.
And I have to mention this.
Once I worked for this
green logo in the middle,
EB, Elektrobit.
This is a software supplier.
And among many other things we have,
we deliver an implementation
of the AUTOSAR stack
and the tooling for that.
Now what you've seen
in the previous picture
is not what we need
in future cars and sought after cars
which are already on the road today.
Such cars have a need for
central high-performing
computing clusters,
one or many of them.
And these computing clusters, of course,
interact with all the
other stuff in the car,
with a lot of sensors.
They interact with the cloud.
They enable us to implement things
such as automatic driving.
There's also
such functionality as update over the air.
So it's a highly dynamic system,
totally different than
the classic AUTOSAR stuff,
and that's what the new specification,
Adaptive AUTOSAR, targets.
This is, of course, something
which is much more complex
than the classic scenario,
and therefore the specification
requires you to program in C++.
Now, there's more on that on this website.
You can find more about
AUTOSAR and
the road map and the specifications.
So, why do we use C++?
Well, in fact, we use C++14,
so the adaptive AUTOSAR specification
mentions C++14 as the language of choice.
I think I don't have to explain really
why we use C++ over C.
That's pretty clear due to
the enhanced complexity of these systems.
But why do we use C++14?
A few years ago,
if you had come along with C++14
in the automotive industry,
people would've asked,
&quot;Why don't we use C++03?&quot;
You have, in the automotive industry,
you have a lot of
long living code bases typically
because you have long product cycles,
and you have to maintain
software over a long time.
So you have a lot of existing code there,
and you have a lot of competence.
But when you think just
like Adaptive AUTOSAR,
it's clear that we choose
more state of the art.
And actually, there are also
a lot of standards which drive
the software development
within automotive,
for example, safety standards,
and they all require you to use
state of the art technology and tools.
Also, we have to attract developers,
which is an important factor.
And, of course, it's clear that C++14
provides much better
alternatives than C++03
for many other things.
So, which has always been a problem
in C++03 is unwanted implicit conversions.
You can avoid them by just using
auto or uniform initialization,
or the explicit keyword
on conversion overriders.
You have for ranged loop,
which you can safely
iterate over a container
without worrying about
running out of range.
You can create type safe functions
with variable number of
arguments, and so on.
Of course, we do have
to handle concurrency.
Of course, everybody knows that
the support for concurrency
in C++14 is not very large,
but at least there is something in there,
as opposed to 03 that
has nothing in there.
So I'm gonna show you a little
bit what our APIs look like.
There is, in Adaptive AUTOSAR,
there's one API that's called ara::com
That's a communication API,
so that enables you to
communicate with a remote service.
Behind that, there's a huge system
of specification and code
generation out of that,
but it results in code that,
for the perspective of
the application developer,
you have this kind of interface,
remote service and you call a function,
and this function is
executed in different process
or on a different machine or maybe even
in a back end on cloud.
And what it returns is a future loop.
Now, you can,
you get a result, you
can just call future get.
This, of course, blocks.
If you have a very simple application,
then you can afford this.
If you have nothing else
to do in the current set,
then it's okay.
But most likely, you will
need something like this,
where you specify a continuation,
so a function which gets executed
exactly when the result becomes available.
Until then, you can do
other stuff on each side.
That's a common pattern.
A little less known but also possible
is that you have an application
which does the scheduling on its own,
so you have a loop and it's asking future,
&quot;Is the result available?&quot;
And you get it, or it's not
and you do something else.
You grab a task from a
queue and then you go on.
And the nice thing is that,
with one interface like above,
we can support all these models.
Unfortunately, only the first
one is supported in C++14,
and all the others are
not even supported in 17.
So in Adaptive AUTOSAR,
we wrote our own feature.
Unfortunately, but we did do it.
So, why don't we use 17?
17 certainly provides a lot
of interesting features,
but for the automotive industry,
it's just too new at this point of time.
There are compilers.
That's not the problem,
but static analysis tools are not ready.
The teaching is not ready.
And sometimes,
you need special compilers.
You need compilers which are validated
to conform to some safety standards.
And such providers are
hard to find and expensive,
and they're even hard
to find for 11 or 14.
So 17 is, right now, out of the question,
but we hope that we keep up, of course.
So, guidelines.
Why do we need guidelines,
or specifically, guidelines in AUTOSAR?
Why did AUTOSAR create them?
Why do we need it?
Just take them from other sources.
And how did we do it?
Then I will go into, just a bit,
into some of the topics which
are typically controversial,
but in the embedded or automotive industry
see how I handle them.
Okay.
So,
why do we need guidelines?
Just start an experiment.
Start a software project
without one, without them.
The first people who ask you,
&quot;Where are the guidelines?&quot;
are the developers.
They wanna know,
often they only want to know,
&quot;Do I have to write camel case
&quot;or Pascal case or snake case?&quot;
Sometimes they have other questions.
Next thing is project
managers will ask for it.
Quality engineers will ask for it.
You have, again, processes
and safety standards
where you had to.
So they usually require
you to have guidelines
and to check them with an
automatic tool and so on.
It's not a sufficient reason
to just do it because you have to.
This is an old quote
from Bjarne Stroustrup.
&quot;C makes it easy to shoot
yourself in the foot.
&quot;C++ makes it harder,
&quot;but when you do, it
blows your whole leg up.&quot;
That's often quoted,
and that's also in the preamble
of existing guidelines.
I was wondering what he would say today.
I'm not sure.
Maybe something like this.
C++ makes it even harder to
shoot yourself in the foot,
but still you can blow your whole leg off,
so you need something to guide.
I'm still not satisfied with these quotes,
because they kind of convey
the message implicitly that
C or C program gets away easy,
or more easily than C++ programs.
I'm not sure.
So I would ask a C programmer.
Where are you?
Maybe he's blown off completely.
I don't know.
Okay, so we need guidelines,
so where do we look?
We are in a specific industry, automotive,
and we have to maybe refer to
some function safety requirements.
So let's look at the
industry, what's there.
So one famous, also
often quoted guideline,
is the Joint Strike Fighter Air
Vehicle C++ Coding Standard.
That's from 2005.
And that's famous because
one of the authors
was Bjarne Stroustrup.
This, is of course, from an area
where there are many restrictions,
even tighter than in
the automotive industry.
But it's from 2005.
It doesn't address C++14.
Then, MISRA.
MISRA is
the Motor Industry Software
Reliability Association.
They have created guidelines for C,
and they have also created
guidelines for C++ in 2008.
And that's, if you do C++
in the automotive industry,
then you come across these guidelines.
Tools support them.
Customers require them.
They're everywhere.
But, of course,
it's not C++14.
So, covers maybe safety, critical
systems, but it's not 14.
So let's look at more recent work.
There's the High Integrity
C++ Coding Standard.
I've seen them used in the
automotive industry, as well.
It's a pretty good work
focusing on C++11.
But it's not quite
what we need
in detail.
There's the CERT coding
standard, which is up to date.
It's very good work.
Focuses on security.
And of course, the C++ Core Guidelines.
So none of this is to say
that any of this is bad,
but it's just maybe not sufficient
or maybe have a different focus.
At least, what you have to do is
you have to review all of these
and see if they fit to
the industry you have.
And that's what AUTOSAR has
been doing, and is still doing.
So AUTOSAR invested in doing this research
and setting up guidelines
because there was nothing there.
I will cover this data, how
we see this in the long run.
AUTOSAR is not actually an organization
whose main focus is to
maintain such guidelines,
but we do it right now
just to give it a start.
So, our approach was to go
through the MISRA guidelines,
because they are the quality
standard in the industry,
go through them and then
check if they make sense
for modern C++,
delete rules or add
rules for new features.
That was the start, and
then we went through
all the other guidelines
that I mentioned and
checked if we could take
over rules from them
or have to modify stuff.
And the great thing is that
the document we've created
creates huge tables of traceability
to all the other guidelines.
So this makes it easier
for tool developers or tool configurators
to actually map the AUTOSAR
rules to existing rules.
There is a version published,
version from March this year.
There was the first release
of Adaptive AUTOSAR,
and the guidelines also
came along with that.
You can download this on this website.
It's available publicly.
So, at this point, this is my reminder.
I have to give some credit.
There's a group within
the AUTOSAR Consortium
which works on these guidelines.
I'm in this group, but
I'm by far not the person
who does the majority of this work.
So there are a lot
of other people and
companies who contribute, and
I'm just supposed to present
this as the AUTOSAR work,
but in fact, there are a
lot of other people behind
which deserve the credits.
So, let's look at some of the rules.
Single return.
Single return is a rule which you can find
in a lot of the existing older standards,
in the MISRA standard,
even in the JSF standard,
guideline I should, say.
It's not a standard.
For example, MISRA says,
&quot;A function shall have
a single point of exit
&quot;at the end of the function.&quot;
Now, this is a problem.
Because why is this a problem?
It just doesn't work.
In C++, by default,
unless we know explicitly
otherwise, we have multiple exits.
We have exceptions.
So, MISRA has a workaround for this.
So they have an exception to this rule
which covers exceptions.
This is called,
throwing exception that is
not caught within the function
is not considered a point of exit.
I don't know if that helps.
It probably helps MISRA to
work around this effect,
but it really doesn't help much.
And then we did a little bit of research.
What is actually the reason
why this was in there?
And the reason is that it's in
many of the safety standards.
If you look in the safety
standards, it says something like,
&quot;It's highly recommended
to have a single exit.&quot;
But it doesn't give a rationale.
That's a bit of a sorry situation.
So, that's basically the reason
why MISRA keeps the rule in,
but
we decided to do otherwise.
We dropped this rule.
But we have to prepare for some
maybe reviews or audits
and have to give reasons
for this, of course,
and here are some reasons.
Why can we afford to drop this?
This is C++ code.
Very simple, but very common.
So we instantiate a vector,
local variable that
allocates memory, of course.
We call a function that
may throw an exception.
Is this a problem?
No, it's not,
because when an exception is called
the destructor for vector will be called.
This will be allocated memory.
If we just simply go out
of scope, end the function,
we'll also deallocate the memory.
This is,
for experienced programmers,
it's a trivial pattern,
and it's as old as the language itself.
It's called use resource
acquisitions in initialization.
Just have to use it,
and you never have any
problem with resources.
By the way, there's a
generic resource wrapper
that you may wanna have a look at.
That's the link down there.
So, the mantra of C++
training is usually use RAII.
You can turn this argument around.
So since you use RAII,
you don't have to worry
about multiple exits.
But you can see, where
this rule comes from.
It comes from C, of course,
where you don't have this function.
There's another reason.
Code which has a single
return often looks like this.
So you have this,
what's called the arrowhead anti-pattern.
Your code looks like an arrowhead,
and the interesting part is
somewhere in the tip there.
And sometimes, you have bits
repeated on the way out.
It's much simpler just
to write it like this.
And the second reason is
code which has a single return
or forces you to do,
after a single return,
needs to introduce a temporary variable.
What's the problem here?
Well, there is no problem here right now,
but there could be a problem.
If we extend the code or modify it,
we could forget to,
could maybe add another branch here,
so we may access result
without having initializer.
So potentially we have a problem
here, which is bad enough,
and this is called,
with a fancy name, it's called
a data flow anomaly, a UR anomaly.
So you could access a
variable which is undefined
and you reference this.
So, you fix it.
Assign some value,
but then you have to pop
them in a different place
than if in the first
branch you assign a value
and you never used the previous value,
so you have to find it and un-use it.
That's the DU anomaly.
Or you define the same
value it already has,
so that's a double define.
So all three of these are unwanted.
And actually, if you look
at the MISRA guidelines,
they already require you
to avoid these anomalies,
and AUTOSAR guidelines require
you to avoid them, as well,
but AUTOSAR can achieve it.
Okay, exceptions,
another topic which is
traditionally very controversial
in the embedded industry.
Dates back to old times when
compilers generated large code
or generated performance overhead.
These times are long
gone, but sort of the,
the prejudice still sticks sometimes.
What does MISRA C++ say about it?
Well, they say it could be,
could have advantages.
Could be a clear means of
handling error conditions.
But it sort of
leads to code that is
difficult to understand.
That's basically saying,
&quot;Well,
&quot;we don't know how it works, either.&quot;
They don't give any further guidance
on how to use them correctly.
Core Guidelines say, essentially,
there are a lot of language facilities
and assorted library facilities
which just make use of it, of exceptions.
So you cannot typically avoid
having to deal with exceptions.
Maybe in some restricted,
very
tiny subset, very special
programs, you can,
but in general, you cannot avoid it.
So, what we say is
we don't force anybody to use
exceptions in their own code,
but you should be prepared
to deal with exceptions
that are thrown by other code.
But if you use them,
then you have to follow some rules.
And there are roughly 40
rules in the guidelines
to handle exceptions correctly.
One of the major rules is don't
use them for control flow.
And another thing is,
which is sort of characteristic
of the systems we're dealing with,
we have this last ditch catch all thing.
So in the main function and
in every thread main function,
we catch exceptions.
The reason for that
is, if you don't do it,
then
standard terminate will be called,
which leads to exit of the program,
which may or may not
unwind the set completely,
which may or may not, typically won't,
call the destructions of static objects.
We wanna make sure that this is,
a program always exits sanely
so every, resources are deallocated.
So even in a very fatal, unexpected error,
exception that you don't
handle somewhere else
which creeps up through the main function,
we guarantee a safe exit,
which is important,
because often the scenario is then that
maybe your program shuts down,
but it maybe restarted by
some other monitoring process,
and it's important that you
really start from scratch
with all the resources deleted.
Typical concerns that people
have about exceptions.
It sort of introduces
or may introduce a hidden control flow.
You have an additional
exit point from functions.
What can you say about
the state of the program
when an exception is thrown?
And so on.
The important points are
also runtime performance.
What can you say about
worst case execution time?
The hidden control flow
we cover by this rule.
We say, &quot;A function shall
not exit with an exception
&quot;if it's able to complete its task.&quot;
So, that's another way of saying,
don't use it for control flow.
So this example,
there's a function which
computes a CRC from message,
and it computes the
result, completes its task,
so it should not throw an exception.
Instead, it just should return a value,
which doesn't mean that this function
should never throw an exception,
but just when it completes a task,
it should not throw an exception.
It could still throw an exception.
It actually does throw an
exception in the C-STAT.
- [Man In Audience]
(mumbles) message is empty.
- Yeah, when the message is empty,
the at zero will throw an exception,
which is perfectly in line with this rule,
because the function cannot
then complete its task.
Obviously, having a non-empty
message is a pre-condition,
and it is violated here.
Some are worried about
additional exit points.
We have covered this before.
We are not worried about
multiple exit points
because we can handle them by using RAII.
That's the usual rule.
You have to ensure that the
program state is correct,
so you have to provide the
basic guarantee always or
the strong guarantee if you can
and no throw guarantee,
writing no except keyword, and so on.
What about runtime performance?
Now, that depends, of course,
highly on the compiler you use.
If you use GCC or Clang,
then you have a zero cost
exception handling implementation.
That means you don't have,
as long as the exception is not thrown,
you don't have a runtime cost.
So, it depends on what you use,
but these, especially GCC,
have a use in automotive, as well.
Worst case execution time,
that's a difficult topic.
So what happens when
an exception is thrown?
Can you make a statement about,
at least the worst case,
when the program executes?
You probably want to ensure that
even if you exit the
program via a main function,
via this last ditch catch thing,
that this will execute
in a deterministic time.
That's somewhat difficult to say it.
You have to measure it, of course.
You have to, maybe have to analyze
the behavior of your runtime system.
Or you have to
go ask a compiler vendor to
provide its guarantee for you.
You may find that actually maybe the,
the exception handling
or throwing an exception
involves a memory allocation,
and you may find that this
is not usually the factor
which costs us a lot of runtime normally,
but it could cause an
undeterministic behavior,
so you may change the
memory allocation strategy.
So all kinds of things you can do.
The guidelines will say
you have to analyze this
and make a statement about this.
Okay.
This brings us to next
topic, dynamic memory.
This is also
often sometimes controversially discussed,
especially for people which come from
the really hard embedded world
where everything is static, pre-allocated.
But you need dynamic memory.
So often, you have data.
You know the size only at runtime,
or you have data which is
independent from object lifetimes,
especially when you share data
between different threads.
The promise-future pattern requires you to
share data on the heap.
You wanna deploy something
like type erasure,
that typically requires
dynamic memory, std::function.
It has, of course, more
object optimization,
but in general, it requires
dynamic memory allocation.
You use library features,
language features, like exceptions.
You may throw an exception.
That typically causes a memory allocation.
Containers from the standard library.
Of course, you can customize
them by writing allocators.
std::function you cannot customize
because that customization is deprecated.
It's deprecated in C++17,
but effectively this means
it's already deprecated now.
We cannot use this.
You can say the same thing
when I say about exceptions.
Few programs can manage to
avoid dynamic memory allocation,
unless you have very specific programs.
Typical issues, memory
leaks, memory fragmentation,
non-deterministic execution
time, running out of memory.
Memory leaks we handle
easily with using RAII.
Consequently, we forbid,
and that's a rule in
the guideline, actually,
new and delete explicitly.
It should always go via
the standard containers
or the smart pointers.
Memory fragmentation, that
depends less on language
but on your system, on
your operating system,
or on, if you write
allocators on your own,
of course, you have to ensure that
they don't
fragmentate the memory.
What techniques are available for that?
That's a thing that,
that is probably specific
for the automotive industry,
that you wanna guarantee also, here,
a worst case execution time.
And this is
not always easy if you use
a standard operating system,
OS malloc and free or new, delete.
So you typically want to override this,
or maybe you get away with
just using custom allocators
for your containers.
Out of memory.
Well, you have to look at your system.
You have to ...
Typically, you can
specify a maximum memory.
You do that implicitly already
when you design hardware.
You can do it for the software, as well.
The typical thing is you
use pre-allocated memory
and allocate it from there.
Okay, how are we doing for time?
Oh, that's good.
We have some.
I didn't cover many C++14 features,
so let's look a bit at how
we handle these new features.
Lambdas.
That's not a new rule.
You can find this in
the Scott Meyers books,
or also we always
wanna explicitly capture stuff,
not use the implicit capture,
because it's easier to control then
what you actually capture and modify.
A simple rule, we always write
the empty parameter list,
even if that is not strictly
required by the language.
You don't nest the numbers,
because if you allow people to do that,
it leads to bad code.
I've seen it.
Auto is another topic which is,
there's a lot of prejudice
or anxiety among people,
especially when they come from C.
What auto does,
it's not as scary actually.
We allow it.
Well, the rule is we allow it.
Oh, no, the rule is we,
it's actually not,
it's forbidden expect in several cases.
That's the way that it's written.
This maybe reflects the sort of skepticism
which is around in the
industry about auto.
You could also have written it like
use auto to avoid duplication
or use auto to avoid implicit conversions
that you don't want.
The result is the same.
We allow auto when you
want to capture the value which
is returned from a function,
like in this first example, vector size.
We allow auto when you want to
initialize a non-primitive type.
You don't have any other chance
with a lambda, of course.
Otherwise, other
variables like an integer,
we always initialize without auto.
There's another reason here,
because we want users to use int
but always to specify the size,
so use the standard integer
types, int32_t for example.
If you were to write auto i =
42 you would end up with int,
and that's usually not right.
We also require the,
the curly braces.
And I have some other cases
where you actually can't do without auto,
the parameters for generic
lambdas or return type deduction.
So, other stuff we forbid.
There was a lot of stuff
that we actually allow.
In contrast to all the
guidelines, it looks like,
we're very liberal.
But there's also a lot of stuff we forbid.
So we
forbid atomics and threads
and all these primitives
from application code.
We used to have them in special
library code, of course,
but we wanted to get away with them
in typical high level code.
These rules are not ready yet,
but this is the way they will go.
We forbid explicit new, delete.
I've already mentioned that.
Most of the casts,
because they usually indicate bad design.
Dynamic_cast also introduce
some indeterminate,
or could introduce
undeterministic time behavior.
Wchar_t
That's platform defined.
And a lot of the legacy C
style variadic arguments,
standard IO,
that's stuff we
don't allow.
Okay.
So,
I was talking about
change in the beginning,
and this is a major change,
because Adaptive AUTOSAR is like
the first major scale specification
which brings modern C++
to the automotive world.
There has been a lot of C++ already
in other domains outside of AUTOSAR.
There have been, of course,
also projects running C++11 or 14.
But this is a large scale thing.
So expect that in the future.
There will be
more C++ and more modern C++ in your car.
There will hopefully more
talks about modern C++
by people from the automotive industry.
There are guidelines
which are the first ones
which comprehensibly handles C++
in combination with automotive
specific requirements.
The guidelines are still
a work in progress.
They're incomplete and
everything, but it's a start.
So how will it go?
(mumbles) with the guidelines,
we'll continue analyzing
the existing rules from other standards
and complete the traceability tables.
That work I think we will complete
until next upcoming release.
There's one coming up in autumn.
We will work on rules for
standard library usage,
which probably won't
make it into the release.
I've already mentioned some of the rules
around multi-threading and atomics
and threads that are a
work in progress currently.
A big thing is tool support.
We won't be doing that.
At least, that's not AUTOSAR's intention.
But we are in contact with
tool providers
so that the AUTOSAR rules
can be supported by tools.
And eventually, this
is the important thing,
eventually, we want to
hand these rules over
to some other organization
which is more capable and more suited
to maintain such rules in the long run.
Unfortunately, I cannot tell you right now
which organization this will be.
Maybe this will be a profile
in the C++ Core Guidelines.
I don't know.
There are discussions
going on around this, but
I have no information really
which I can present right now,
not even the timing.
There is a release of
AUTOSAR, Adaptive AUTOSAR,
coming up this fall.
It says 10/17.
That will be October.
Don't hold me for the date.
This will
include more APIs
and more enhanced reference implementation
for the APIs.
And also, it will include
an updated version of the guidelines.
Okay. Thank you.
Are there any questions?
(audience applauds)
- [Man in Audience] In the new AUTOSAR,
or Adaptive AUTOSAR standards,
is there intent to work
with the new generation
of self driving cars,
or is it mostly focusing on
the complexity of the control systems
that are already in vehicles?
- The question was if there's intent
of the Adaptive AUTOSAR standard
to work together with
the self driving cars.
The technology for self driving cars
is not something which will
be developed within AUTOSAR.
It will be developed probably by companies
which are also in the AUTOSAR Consortium,
but it's not part of the
AUTOSAR specification.
But the AUTOSAR specification
provides a platform.
It's an enabling technology.
So on top of that,
you could have,
could run an application
which enables self driving.
There is work, or has just
started work in the Consortium
to cover parallel computing.
There will be some API for that.
But the details are not
hashed out at the moment.
- [Man in Audience] The reason people
usually prefer to use plain
C (mumbles) programming
is that sometimes they say the (mumbles)
- Sorry. What?
I didn't get the last part.
- [Man in Audience]
(mumbles) is just (mumbles)
So basically, we don't have some (mumbles)
the structure (mumbles)
In your presentation, the stuff I see
is all on the programming
practice basically,
but it doesn't answer the question
of how this code would
(mumbles) environment (mumbles)
So basically, on 600,000 RPM,
a usual engine does like (mumbles) events,
which is like a manual RAM extension,
but it needs to do it with
(mumbles) redundancy (mumbles)
is crucial in some applications.
So basically, how does this spec
enforce (mumbles) constraints,
or does it even attempt
to target this area?
- It does in a way,
but it's also up to you.
If your task is to write an application
which has (mumbles) requires,
then you would use maybe the subset of C++
which enables you to do exactly this.
- [Man in Audience] So the
problem with the standard
is that, what applications
does it parameter?
Is it (mumbles)
or is it some high level
stuff like (mumbles) systems?
- It's more the high level stuff,
the classic world with
the smaller control units
and with the (mumbles) requirement,
that will still remain.
We will have both worlds for a while.
- [Man in Audience] Thank you.
- [Man in Audience] Is the SAE involved
(mumbles) with AUTOSAR?
- The SAE?
- [Man in Audience] The Society
of Automotive Engineers.
That would be a logical society
that if you were considering
handing off (mumbles)
- I would have to look this up,
if they are in the Consortium or
maybe having talks already with them,
which I don't know if, it's possible.
- [Man in Audience] One last question.
Is Tesla involved?
- No, not to my knowledge.
So, thank you very much, again, for that.
(audience applauds)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>