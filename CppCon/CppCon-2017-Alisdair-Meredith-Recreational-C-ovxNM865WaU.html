<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Alisdair Meredith “Recreational C++” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Alisdair Meredith “Recreational C++” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Alisdair Meredith “Recreational C++”</b></h2><h5 class="post__date">2017-10-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ovxNM865WaU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so the title of this talk is
recreational C++ this is basically me
having fun playing around with our
language if you with or puzzles and
corner cases and things that you but
have amused me over the years so we'll
start with this what it what is this
it's a terrible pun so we've got that
out of the way so what what is
recreational C++ my notion here is I'm
playing around with code for fan because
when we play we're in a great
environment to learn so I'll be solving
a lot of well-known problems I've got
nothing inspiration with you as far as
I'm aware but this just kind of what
amusingly inspired me and hopefully will
amuse me inspire you to find your own
little corner cases and puzzles maybe we
can share some of those as we go through
I'm describing this it's kind of smart
it's lots of more smaller scale problems
if you're familiar with the ideas of
toys and pets toys and pets in
development circles are the idea of
you've got that little go-to project but
every time you have a new environment
you need to learn and understand you
know I'm being exposed to a new
operating system for the first time I'm
going to write my familiar little toy my
pet the typhi the nurturer over the
years so that might be something wagging
your application across the network via
how does that work in the new
environment or a classic example you
know a parser for a simple mathematical
script and these are the kinds of things
that you've Alba over years now they're
a much larger scale thing with them
talking about here and I'm a careless
Guardian I'm afraid all my pets have
slowly with it and died because I got
too busy really hooked up with C++ so
what we're going to look at is a bunch
of my ideas and things I have I just had
playing around
he's certainly implementing little parts
of the C++ standard librarian for the
most part ideas of coding conventions
come up when you start playing and doing
things for yourself some C++ trivia
corners because trivia is always fun
and how this helps me learn about some
of the new language features as they
come through and yeah playing around
with the bug reporting systems of
various compilers as I push them to
breaking point and somebody is about
implementing and testing the standard
library so my own personal bad habit
here that I'm confessing up to for those
who haven't figured this one out yet is
every time I have a new version of the
standard I sit down to re-implement the
standard library again
I've never completed it yet oddly enough
and it gets larger every time I don't
know how I'm gonna get I get caught up
the last few times I really didn't get
much beyond type traits tuple and
perhaps we start on the containers and
so forth the thing that kills me these
days is I got too good at writing test
drivers and to confidently finish
testing something I can probably finish
one typed rate before the next time it
rolls out as an example last time I was
writing my test drivers for the type
traits starting with a simple thing like
is integral I had about 10,000 wines of
different static assertions for the
different types I was trying to test
just for that one trait and that would
try that same battery of types on every
single trait so I had a consistent set
to test and that brings up a new problem
of how do you audit 10,000 static
assertions that they all have the right
true or false value are you testing what
you think you're testing correctly so I
wasn't particularly happy with that
iteration so we go around again and I
start writing meta code to generate my
tests and then so well is the meta
program correct
so keep chasing my tail on these things
you can see how I never quite get to the
end of actually convincing myself up
test to the type traits in order to
start on the next component but it's
always fun to start over here so let's
go and put my theater trades who don't
figure this will be first we start with
type traits because the vast majority of
the library when you're implementing
templates is going to query a trait at
some point off somewhere in that
implementation so this is really the
ground level of the standard library it
will give us an early exposure to
testing our traits and don't worry I
don't have too much on the test drivers
here just insights of what they brought
me
so my first design question thinking
about type traits coming into it new for
C++ 17 is there a minimum overhead kind
of implementation that can come up with
for the type traits
how can I cut out any of that latent fat
that might be there so this is what I
came up with you can see from the top we
start implementing the I'm doing the is
function trait and I start with the
variable template because when I'm doing
all of my boolean predicate logic I want
to be querying boolean values I don't
want to be jumping into types trying to
do funky metaprogramming with type
stupid computer value and then come back
out to the trait I just want to be in
boolean logic all the way so I'm going
to make bit the underscore of the
variable template my primary
implementation and then for the trait at
the bottom you can see I'm now using an
alias template that is function is just
the bull constant for is fun can be so
the question is is this actually
conforming and what does it buy us so
the rules in the standards say your
traits going to have a base
characteristic of integral constant that
was generally assumed to mean will
derive publicly and unambiguously from
that interval constant type but my
interpretation as you saw is I'm going
to try and use an alias template that
means I'm actually creating fewer class
templates in my code because an alias
template doesn't create a new type
everything is just an alias to just true
type or false ID the downside of this is
of course is users are now no one get
able to specialize my trait so and I say
try specializing the underscore V things
which the standard doesn't tell them
about because the style is specified in
terms of the regular class type trait
but the standard also tells users
they're not allowed to specialize them
so if they try and do that they were
actually getting error on my system so I
think that's a win
the same computing underscore V is now
my primary system so I have an easier
time working in my logic with my traits
they'll be a lot simpler so this is what
you get thinking about these problems
not the only problem is some programs
that are actually conforming will fail
to compile if you look at my awkward
template here it derives from is object
T and is enum T so if I have a reference
type of both of those are false type and
I've got duplicate base classes which
I'm not allowed so it's a nice idea but
almost but doesn't quite work but this
is recreational C++ how much do I care
about that I'm not shipping a standard
library so I'm going to do things my
easy way thank you very much
the other thing I did try to test to
demonstrate the wonderful performance
winner me having far fewer actual traits
being generated with your eyes write a
simple test function the function
template took in all the traits by cross
reference and so forth and anyway it
spewed thousands and thousands of these
class templates coming out of my test
driver and I felt very smug because was
trying to emulate the notion of tag
dispatch because one of the reasons that
you have these base characteristics is
you want to do tag dispatch by passing a
func your trait they will sliced by the
true type or false type and that guides
your overload resolution as soon as I
put those actually down to slice into
true type on false type rather than
taking the thing in by value and
querying the type out so doing check
this factors it would be used my
advantage completely vanished so it was
a nice illusion while it lasted but I
still think it's an easier way to
pinpoint these and it's my library I can
have fun so this way would start getting
a little bit more participative we're
going to implement the is function typed
right so nice thing we have C++ 11
almost we have a variable Mary attic
templates so the primary state is an
arbitrary type is not a function and we
now have if I can make the laser work
first I'm playing with these things in
my aim is terrible so ok we're going to
say that ah nope my aim really is
terrible anything that's got a result
the parameter of the form result type
parens and a list of arguments and the
pack can be empty that corresponds to
everything that can be a function it's
nice starting point but how many
problems do we see how many kinds of
function is this missing so I'll start
with the first one because I love this
piece of syntax a C style ellipsis
doesn't match the parameter path so I
need to have this extra signature it
also means I get six dots in a row which
it's a wonderful perverse corner
unfortunately compilers like to warn you
about this so the pink it put an extra
comma in there just a silence to stupid
compilers and I think in C++ 20 we will
now be requiring that comma because
people had certain problems they wanted
to solve with very alack macros and
there's certain regularity comes out if
this comma ceases to be optional but
that's on the road for C++ 20 it's not
in 17 the requirements not in 17 yet
what we do get in 17 of course is
exception specifications are part of the
type system so I now need at least four
of these specializations before my trade
is correct and can we see where this is
going we have these wonderful what I
like to call abominable function types
where the constant volatile qualifier is
also part of the function type if you've
never met these horrible things
be blissful in your ignorance but this
is what happens when you start playing
with your code and people start throwing
the whole test cases at you this is the
type of a member function it can't be
the type of a regular function you can't
make a pointer to these you can't make a
reference to these you can never
actually hold one in your code in the
meaningful way but they're in the type
system because when you have a pointer
to member the type of the pointer to met
that the pointer member points to when
you have a CV qualified member function
is one of these things
and if your perverse you can even
declare member functions using this a
your type depth of these types but that
is really horrible I don't want to go
down that corner so we've now got these
four with the extra ellipsis version and
the extra now except version so what is
that sixteen now and then of course
we've got reference qualifiers were
added in C++ eleven with our value
reference qualifiers versions with the
no accepts and the ellipses and we've
now got an awful lot of partial
specializations in addition to the
primary template just to try to get our
is function template correct this is no
longer looking like the neat quick fix
that I was hoping that wonderful pack
expansion was going to give me yeah the
recreation can sometimes be frustrating
I'm not even spoken about doing the
extra specializations for extra and see
linkage partly because I forgotten I
can't remember either way and we do have
problems in certain environments where
can powers have their own extensions for
function types like Microsoft's got
various deckle spec calling conventions
that also ended up needing
specialization here perhaps this isn't
the right solution after all does anyone
have an idea how else we might go about
this I'm not going to Azkaban there
knows an answer he's nothing far too
happily asked the compiler it'd be great
if the compiler gave us an intrinsic
that is function that is the best answer
unfortunately I'm not a compiler
implementer I'm a library implementer
and I'm working for portable C++ I don't
know I'll have that trick that intrinsic
on all my compilers hmm this is a
jessalynn let me call remove CV now the
problem is that CV qualifier on your
member on your function type is not
actually a CV qualifier if I call remove
CV and pass it one of these strange
function types function types cannot be
CV qualified it's a qualifier on
this pointer when I call the Franklin so
it looks like a CV qualifier if you play
around with macros rather than type
deaths you might just start getting
strange behavior where you could power
tries to treat these things as constant
boil down different places but no that's
not a CV qualifier so it's not going to
help me but it is a nice exploration of
the type system thank you okay this is
how clang solves a problem now I'll be
fair the yellow text is all is object
and the blue is is reference so we can
collapse this down into just three
traits but those traits in turn are
composites that are implemented in terms
of I've basically in lined the whole
operation so if I'm not a floating-point
typing integral type in enumeration an
array a pointer a member pointer not
patottie a class or a union void or any
kind of reference all that's left is I
must be a function and it works
interesting one is you have to check
both is class and is Union the language
says unions are class types but the
library says you care about this
distinction so we gave them two traits
and his class will return false for
reunion you have to query both that was
another one I learnt while going through
this wonderful little exercise but yeah
that works and it's it's nice it fits on
the slide but it's not exactly the
simple solution I was looking for
although it's much simpler than 48
different parts of specializations Eric
nibbler came up with this really neat
solution and posted this online and I
think you can find it on Stack Overflow
start at the top on the bottom we're
creating this priority tag type which is
a type that recursively inherits and I
say I'm going to have this many
different tag types and so I
tacked up we're going to have three or
four of these overlords on our tag type
three derives from tag type to derive
from tag type 1 derives from tag type 0
so I can plug in the biggest tag type at
the top and you all go down through the
overload set and see which thing it
matches which is what we're doing at the
bottom the test is simply saying it's
 import of the size that I get
from calling is function imple for my
tag type says that's what type of T was
going to match
so this is our filtering logic you can
see we're returning arrays of size 1 2 3
4 toes we can identify on the size of
the return type in the unevaluated
deckle type context what the wick of
these filters got triggered and then
we're using little trick with spin eye
we're going to have a defaulted template
parameter for a bunch of these function
templates and in fact function template
matvey is you're going to get your
strongest match and that is the overload
or be selected so if we go see if I can
get the laser working this is going to
match as it says here all array type
coming on down with a say okay I've not
got an array I because arrays can't be
some promotions I'll have anything can
be returned from a function unlike an
array so this will match all other
object types reference types and so
forth in the system but you might spot
as a problem with abstract types because
you cannot return an abstract object
type from a function so we need to
filter those before we get down to this
set before we get down to this set so
this is a property based evaluation to
say we know that function types can't be
returned from functions if I can filter
everything else this way
I'm having the compiler do the work for
telling me what can come out and is an
actual function type so the map you want
to hit is this one at the top I've got
an array of size 1 car so that's what
I'm actually sincere at the end so that
is our is function implementation which
I thought was quite neat then we can go
back to why was I generating 10,000
different test types to throw at these
battery of tests so we can start with
all going to have all the fundamental
interval built-in types and the C be
qualified versions of those and then
point us to those and pointers to
pointers to those and C be qualified
versions of pointers to pointers to
those and then references to those into
the point isn't to the pointers to the
pointers then we can have arrays of all
of the above apartment of the references
and we're going to do two three
dimensional arrays because you have got
a recursive implementation of my trait I
want to make sure that that recursion
keeps playing through correctly I found
bugs and implementations of my code in
the past by going up to the third but
the fourth and beyond it was actually
catching the recursion issues as long as
I went to three and in order to support
the largest possible typing the type
system that
annex B of compiler limitations tells me
I'm allowed a type of up to two to the
eighth have to support the type of at
least two to the 18 bytes so if I make
an array of two two two two two two two
two and I have 18 of those an 18
dimensional array I can have an ID net
that makes a little ray of cos where
each is two so I'll test up to 18
dimensions just because to make sure
we're not falling out of any other
surprising resource limits then we get
to function types so of course without
coming up to 256 arguments with me that
ellipses and no accept nor all those
other wonderful things and McNab
pointers and references to those we
might want those to be taking and
returning some interesting arguments
we've also got pointers to members doing
this same thing then we've got actually
getting down to creating the interesting
things we've got enumerations which can
be in classes or regular enum so it
might just be a forward declared enum
with a fixed base type is so you think
that came in C++ Aladdin so these are
all different parts of the type system
to play with and then we actually get
around to doing the real interesting
stuff which is creating a variety of
classes that are perverse in different
ways
they've got your ambiguous construction
if you try and call them with the wrong
things their move on me they're not
movable at all and so forth
they'll overload the address of operator
but that's much more of a problem deepa
d'amour library so having a battery of
ten thousand test types what do I learn
Eric's got a bug in one very odd corner
if he's got an array of an incomplete
class type which is valid in the type
system and has to be supported by this
meta function he's going to say that's a
function so yes I might be utterly in
saying in the depth of test vocabulary I
use but whoa it does stuff thirteen was
just because I thought this was unlucky
it's a good question now I forget
getting really obscure and finding
something right on the corner but one of
the other funny things I found doing
this which is come down to compile a bug
reports I think I was testing his
integer at the time or is enum maybe
Newseum I had an enum forward declared
with a bool as the underlying
representation and it turned out with a
purely if the enum was forward declared
and only if bull was the underlying type
a debug build of crying would assert so
they've got a nice little bug report and
fixed it before the next release went
out Jamie I expect nobody else was going
to see or reported their buggy and spent
developers time fixing about nobody else
was going to see so this was my approach
which was small enough just having got
on to Twitter I got to fit it on a
single tweet yay so the idea here is
function types as we said earlier cannot
actually have CV qualifiers so I know
that my function type is never Const
references have that same property so I
don't want it to be a reference either
and finally because I know T is not C be
qualified constantiy if I have a
function type will still not be CB
qualified so if I check if T and Conti
are the same I have a function type and
that passes my battery of tests and then
your highness job actually go back to me
said we can actually make this slightly
simpler so this is the final final
answer
coming down the rabbit hole I can just
get is Const of T Const and that means
it solves that wholly same thing so that
was really neat and that really does
pick it a single tweet and then we have
the joy of Twitter I'll have to rate
hang on last test you'll notice
everything in that slide was actually
simple enough apart from some of the
variable template stuff to implement in
C++ 98 so this will work for functions
of any number of argument types with
with ellipses and all these things that
were really hard to do without just
putting imposing arbitrary limits so
this seemed quite neat we're actually
using this now is our implementation at
Bloomberg having me come down this
rabbit hole I thought that would really
neat and of course we're now filing
complaints against all our still C++ 98
in those three vendors about V that you
don't handle them abominable functions
that well or you're actually allowing C
be qualifiers on your references so it
mostly works in 98 C it would work if
you had they were fully conforming 98
compiler but I'm not sure if any of
those ever shipped I think most
conformance came in by the time we had
those had 11 other than those wonderful
folks at EDD who actually implemented
export back in the day and the other fun
thing I had throwing this against my
wonderful battery of tests of course is
yeah I have I'm trying to talk to a
different slide I've got another bug
report that's coming up or the other one
that's right now came up with this and
for unfortunately compilers like to warn
about ignoring that extra cons so
although I've got a nice input
New York implementation of the trait it
might be very noisy when you compile a
large code base against it with lots of
useless warnings yes I know it's being
ignored
so try benchmarking it to say yes I've
got this wonderful neat small
implementation that's testing much less
than that version after clang it's not
doing all the big specializations the
other libraries are doing and it was
very disappointing most compilers even
in debug mode saw through all this and
optimized it all the way anyway and I
didn't even spot a compile time win
which is what I was hoping for so while
it was a fun exercise I'll probably do
my implementation this way I couldn't
actually measure a real real win from it
but that's okay that was the goal of
recreational C pass us by having fun and
more learning things including working
that optimizing the heck out of
something if you've not measured you're
probably not optimizing at all and this
is where I get to find got an
interesting name mangling burg on VC C
but it's getting collisions on
abominable function type so it's things
for the CV qualifiers and no accept
specifications because when they put
that into the type system they didn't
happen to check whether or not they're
hashing algorithm for their types with
or map for the mangling was going to
give a distinct type but they got it
reported in time so that when 7-1 was
released it was already resolved so
hopefully you'll never see that bug but
the joy of playing with crazy things
so this is where Twitter came back to me
as soon as I can fit is function onto a
tweet and the experiment comes back is
can you do his integral and this one was
a lot more fun and this one I am going
to start pulling the room a bit more for
so what is an integral type it's any of
that list of 15 specifically that list
of 15 types at the top and any C be
qualified variations of those of course
and any extended integer types that your
system supports it does not include
floating-point types
enumerations references to these things
so I've got to make sure I can't simply
match the reference take pointers to
these types are rays types convertible
to integer mustn't match either
so how simply can i implement this if
I'm going to try a strategy that is not
just specialized those 15 types shrine
user is a non type temple argument
that's right remember where that went
I mean Google drama enums and pointers
can be done that way so it's a start for
a filter it's not the one I chose
can I try using it as the fixed base of
an enum type because those by the
language are required to be integral
types that was exactly where I started
it turns out that's not a spinner
constraint even with the generalized
spin I rules
I write hard on that for days trying to
float that into a swing I constraint
doesn't work
any other ideas the size of an array an
enum would fit in there but I could just
filter on enum I did not try that one on
that I have a suspicion I must have
tried it and I'm trying to think what
else may meant that was unraveling
before me it's not the answer we're
going to see but it's a good try because
I try to start with a simple things and
become more complicated as we go I have
to get back to you on that when it
failed for more than just the enum case
but accountant on what the other cases
were yeah okay we're going to go with
the first step and just try and do is
arithmetic because if I can do is
arithmetic I can then start filtering
down a bit further so an arithmetic type
those same set of integral types we saw
and the floating-point types
it's a subset of the scalar type so
scalar types are those types plus
pointer types enumerations pointers the
members are not / - see and doesn't
include references classes and the
raisins and so forth anyone getting an
insight with this yet anyone spot
anything distinct about the subset of
arithmetic types from the other types
that make up scalar types multiplication
you're jumping about five slides ahead
thank you key thing I spotted here is
these are all built in fundamental types
and these are all composite types now
one of the properties of a fundamental
type is that you cannot overload the
operators for it so let's take a look at
unary operator plus if I write something
that will match any type or provide the
unit plus implementation in my namespace
for generic type T that will not be
called for any of the fundamental types
but it will match for everything else or
it wasn't a scalar typing it will not go
down there I make sense of what we want
scalar types of match so I'm going to
have a sniffer function that can detect
did I have a type that allows me to
overload unary operator + so here we go
I have a whole list of what don't work
yes I'll have an operator plus that will
match any type and my primary template
they're going to have type name void
here for a reason we will see shortly is
arithmetic is false and I'm not going to
describe it today but this is a
wonderful addition to C++ was this 14 or
17 17 sir 17 bunyan c++ 17
creating swing i constraints on textual
property yeah semantic properties or
syntactical properties of code much much
simple to create so if my condition
matches this choice and void is a more
specialized template i lock my mouse
pointer hmm okay the the lower template
is a more specialized template and
therefore will match in preference to
the primary template so for anything
that has the ability to support how are
we going in unary operator plus on the
default constructed or at value
initialized version of that object that
doesn't hit this operation because that
returns void and I'm not allowed to
create get the hang of pointing this
thing but I'm making a reference to this
so because my operator returns void I
can't create a reference to void so this
is how I force the spin I constraint all
the way through so now I have a syntax
that says this will only match for
arithmetic types no I made a bad
assumption pointers and arrays also
actually it turns out to match here so
we're going to have to do a little bit
more code to filter those out and we'll
use the multiplication operator thank
you so with that to filter out the other
types I now make sure that I've got a I
want to make sure I've not got to use a
different type that implements
multiplication so I've still got to do
my test for was I fundamental type but
this finally gives me is arithmetic and
it works so now I want to do is integral
Chuck I've already given the slide away
unfortunately I've got mom don't want
some jump forward yet I just need to
filter out those float types and I can
do that with the percent operator float
doesn't support this and neither do
arrays and pointers so I don't even need
this other constraint as well so now I
have
is integral implemented as per requested
but in two tweets sorry can only go so
far
but apparently has off today I might be
able to get it into one tweet after all
they're upping the limit so yep as I
said this passed all my tests with quang
it fails for a reason I have not yet
figured out on GCC so I might be ahead
of myself in thinking this is a great
perfect solution or more possibly more
likely I'm preferred to trust the
compiler rather than myself but I might
have another bug report I need to file
on GCC here when it starts trying to do
this when I constraint on this calling
here but some ways it's complaining
about taking the address of a temporary
array now I I have no idea why it's
trying to take an address of anything
nevermind temporary array so I think
it's a compiler bug but I've got no clue
where to start reporting ongoing here
some really wacky codes please find the
bug but that's somewhat to-do list when
I get back to the hotel tonight I've not
tried compiling this with microsoft c++
c++ and 14 week is it will obviously has
to have a tie-break try another compiler
but the last video c++ compiler i had
access to before coming out was nothing
vc 2015 and didn't yet have support the
variable templates so I couldn't just
quickly plug it in if somebody else can
run that in the meantime that would be
fantastic
sorry can you repeat the question is
does this not require T to be default
constructible and to an extent the
answer is yes this will only ever match
true for a T that is default
indestructible and we know that all the
types are required to be supported our
default constructible if T is not
default constructible it's actually
going to fail to form these things here
in the void T and that will immediately
spin Iowa so anytime that's not default
constructible fails in a spin friendly
manner and is filtered out
I can't thank water enough for this
trick is I thought I don't you solve all
the problems in this space I didn't need
this toy but oh boy it's so handy once
you start using it it really simplifies
things
so I'm prompt tells me I might have been
in for that thought I got more content
than I did but we'll keep going and
we'll see how quickly we end standard
pair was my next little point of playing
and we're going to pair through the ages
is back into the trivia domain it turns
out every version of the standard we
tweak pair in some way even in C++ l3
so in fact we've changed the signature
of make pair maybe subtly in every
standard until C++ 17 C++ 17 did not
tweak the signature but it did clean out
the normative wording of what that
signature will actually do to fix some
holes in the specification there there
so we didn't get away scot-free but at
least make pair survived Sigma in fact
so C++ 98 we take pair with make pair
takes two cons references c-plus plus l3
we pass by value instead should anyone
give me a 1 what one my answer for why
that might be useful 403 if I want me to
make pair with an auto pointer I
couldn't pass an auto pointer by
constant reference because I'm going to
modify the thing as I move it implicitly
if we pass by value we support movable
types like Auto pointer of course some
c++ c 11 we're going to go with perfect
forwarding because now we actually know
how to do real move on the types and get
perfect forwarding right and of course
this broke code which I think surprised
a few people anyone know the use cases
that this broke
I have silence around the room okay
imagine I've got a map and I mean
certain I'm hearing somebody called it
here do we want to have a say the
microphone sorry you're being named and
shamed there oh the answer is bound to
be a map of some kind
yes so I'm trying to insert into a map
I'm going to do make pair big I could
just have created the pair directly but
no I'm going to do make pair dammit and
I'm going to make pair because I want to
say the first parameter is definitely a
string and I'll deduce the second
parameter so I do make pair string comma
second up as an explicit template
parameter to my call that now means I'm
no longer did using the first argument
it has to be an R value to a string if
the code I was passing there had an L
value that no longer matches the
function call and there's no easy way to
rewrite that function that is saying I
really want that to deduce one but not
both parameters so there's a specific
idiom there that actually Wiis all the
way in the corner although this looks so
much better than this this would have
continued working and are we saving the
move well you have to movie that yes oh
yeah probably the better answer but it
was an interesting corner that you
uncover as you go look for 14 hits
simple we just add Const x per but the
puzzle that interests me at the moment
is let's implement get because we've
given the tuple API to pair so the
string is fairly simple I've got a it's
called sex perform each time using the
c++ 17 walls of their switch i think
looks the same as no i think yeah all
the same is 14 I think Const that cost
expend might be new to 17 I can't
remember but we're going to call get on
a pair and going pass an index and we're
going to get out of the first or second
out and the obvious way you would
implement this is using partial
specialization on the index
and yes sorry
it's integral we have confirmation works
with visual C++ today awesome that's
freaking back to this okay so the
obvious answer here is use partial
specialization with the obvious caveat
that you can't specialized function
templates oops
so we go back to wonderful C++ 98 here
our technology we create a class
template in this case between your pair
util so I can partially specialize the
pair utila pumpkin and therefore within
that i can call i can specialize the
whole util for 1 and 0 and just have a
function called get within there and it
returns out the first or second and now
that we start need to go through this
whole what we call the tuple elements
syntax kids i know that it's going to be
t or you accordingly so that's a
relatively straightforward
implementation of get any other ideas
how i might implement this in c++ ninety
eighty or a technology safe a standard
library TR one mentioned it earlier we
can do tag dispatch so this gets away
with a class template and that funky
partial specialization i just have to
overloads on 0 and what interval
constant of zero and one so depending
upon your choice of style this may or
may not be simpler preferences my
preference is c++ 17 we now have if
Const x bar so i no longer need to do a
dispatch at all because a low p first
and p second are returning different
types so one of those return statements
is going to fail to compile with if
Const x per only the desired branch is
actually going to be evaluated so this
seems like you know really neat use of a
new language and
is the fun you get when you start
implementing pair from first principles
every time you get a new standard
library you start finding the new
corners where the new language features
can go in but can we get a funkier
there's a strong analogy between pair
and tuple and there's some nice idioms
about how we implement to pool that
might make this implementation fall out
especially if it can reuse the tuple
code so I've got smaller code base so
the basic notion of a tuple
implementation for those of you who've
not implemented tuple before is I'm
going to have I've got a couple of
parameters and I'm going to want to
derive from a wrapper of each element
and that gives me a base just expand
that base class now now got a bunch or
that gives me the data structure for top
one I've actually got it on the next
slide basic idea is I'm going to have an
implementation class which I forward
declare and using C++ 14 type index
sequence which will make me an in-depth
sequence of notes to end well or n minus
1 where n is the number of types in the
parameter pack I will now have two
parameter packs here of index and types
of exactly the same length I can just
derive from my wrap class week you'll
see it on the slide or two which is
indexed by a number and the type do we
everyone know why I need to wrap with an
index number here rather than just using
a base expansion expand all the types
perfect answer if I have a tuple of two
int I can't have repeated base classes
so we need to make sure the taps are all
distinct so I just generate an index
that lets me count up to them and then
might want meditation itself is simply I
derived from that base class using index
sequence for that will generate this
type for me and inherit my constructors
and it just works so tipple is actually
fairly simple all the funnies are in the
Constructors another fun stuff here that
part is not exactly what we're doing for
pair but this is for example what our
wrapped wrap type might look like I'm
going to have a value of type T whatever
I'm wrapping at this index I'm valuing
utilizing it because that's a rule for
constructing tuples
we'll talk about the validity of that
later and creating a conversion to
reference for all the various CB
qualifiers I'm going to be interested in
and in order to call get I really need
to get better at my aiming skills
nope wait at the bottom there we can see
I'm calling my access function with just
my tuple but I'm calling access index n
the access function I've got it almost
this time simply is parametrized on my
wrap type with index and whatever type
it happens to match i will deduce the
type I'm at I give it the index I slice
to that base by reference and then by
returning that value I call my reference
operator overload and that gives me
access to the element I've got all the
different CB quality or constant and
reference qualifiers here are value
reference qualifiers here because we
overload for those four with get calls
we have to ultimately support the whole
set so that's how get works for triple
its does this really nice simple slicing
function so can we do something similar
for pair
if I implement my pair as to rap based
classes and rather than having value as
the data member i specialize for index
zero and say it's called first and
specialize for the second index and say
it's called second and put the
appropriate type depth in there and
appropriately overload the reference
function syntax is I can now use the
exact same implementation that I
actually had for a four tuple it seems
kind of neat
in fact that I've generalized the whole
thing trying to use a deco type Auto
which I believe is the form to return
and preserve the reference on the return
type so I'm not even happy to go through
the whole tuple element stuff and you'll
notice I'm passing something called to
polish this will work with support it'll
work for pair it'll work for not it'll
not work for array because arrays
doesn't build with this particular
scheme but anything that uses this kind
of I wrap for a I inherit from a bunch
of wrappers and now have one function
and it implements all those libraries so
I felt kind of neat how well does this
conform to the standard I've now got a
pair with two funky base classes does
that match and drive with what the
standard says was there hearing a no why
does it not match I don't but the
observation is pair is supposed to be
standard layout I do not believe we make
that requirement we indicate that it
will look like a struct with two members
first and second but we do not mandate
that will be a standard layout strip you
can still have whatever crazy base class
implementation details we want to have
I'm not a hundred percent convinced I
have the layout guarantees I need that
because it's an a struct with first
followed but followed by second these
are two public data members of a class I
can do pointer arithmetic between them
and so forth
I'm not sure that the standard is
required to layout the class explicitly
in the order room with no padding that I
would like here
but I think it works of course the next
one is can we go all the way to say I
want to have my pair use the very attic
template form and we've C++ 20 we can
because now we can say it requires that
the size of types is 2 0 1 1 will not
works 3 or more will not work this will
make only if I have exactly two types
and now I transform my T in you into a
bona fide a parameter pack why is that a
nice idea it means that I can gently
little utley exploit my tuple and pair
to have the same implementation for all
the free functions so the six comparison
operators swap to blow method tuple
sighs Mehta functions and it turns out
when you get to the get overload says 12
for pair and 8 for tuple and I just need
the eight overall so it does give me a
small and neater solution also looks
quite bizarre it's a lot of fun to make
I'm not convinced it's the right answer
but darn it was fun finding out I don't
know you picked up whether I have some
unusual coding conventions there or
whether some of those are begging
interest the general knows you know how
you do modern C++ now but one of the
things I have when I'm playing around
with my code is I get to play with
coding conventions and this is one of
those things you often take for granted
with your code but if you start thinking
about the way you're structuring your
code the choice of layout of symbols and
how you portray things it helps you
understand what your code is trying to
communicate and to a large extent
software development is about
communicating information from the codes
to the reader coming after you so I have
a little bit of fun every time I started
comes out I try and look for interesting
new tweets and perversions I can do with
the syntax most I'm hopefully a fairly
straightforward good choice I can do if
a and B or if a double ampersand B who
prefers if a and
I'm looking for a hands I'm singing a
small number of hands who prefers if a
double ampersand B I'm seeing
substantially more hands okay I'll come
to the second one we've got tracked
death a B or using B is equal to a these
are equivalent sin taxes now since c++ c
11 who prefers to type def i'm seeing a
small smattering of hands who prefers
the using okay so C++ 11 is definitely
winning out on the second one of course
the first ones both are valid in c++ out
98 i on the first one definitely prefer
using my hand because this makes it very
clear that I'm reserving double
ampersand now to always mean an r-value
reference and I have many more are very
references running around my code then I
really would like the other group grep
and see these things quite clearly also
in all Pascal hands so and really didn't
surprise me too much it also means when
I see a single ampersand all that could
be confused with a reference this is
much less frequently that you see a
bitwise operator and it means that if I
see a single ampersand I'm not confused
whether a double ampersand was meant and
accidentally omitted it's a very
deliberate total change of form of
syntax and I find that actually jumps
out and helps me the clarity of the code
and the questions wouldn't using bit
hand also accomplish the same thing and
yes it would be and yes he would mean
that ampersand was much more clear to
preserve for regular references but I
find the use of bitwise operations in my
code base is small enough that the Swick
of symbology is a much bigger jump to
the eye but in having better underscore
in front of the end also you really want
your operators to be small between the
code that you're joining so I can read
the predicates on either side much more
clearly that's what's happening yeah but
I had typed FA B I always have to stop
and pause and go which way around is
this doing the aliasing and the
assignment
operator in there even though it's on an
assignment operator disassemble always
makes it implicitly clear to me I liked
it so much I actually went then push the
change request the ISO stand is actually
available in github if you want to make
editorial change it requests there this
was a fairly substantial editorial
request you don't want to think about
doing anything like this unless you
speaking with the project editors who
will be responsible for landing your
request it's not just gonna go in for
free but yeah it was popular enough to
active the C++ 17 standard is now
exclusively using this form in the
standard library so I'm quite pleased
about that little thing and the other
problem of course being recreational C++
are now getting to recreation where the
thing with standard and I got carried
away playing around with the indexes as
well so if you find the indexes of C++
17 a bit better than they used to be
yeah that's a danger of having this
thing available on github now other
things that come with conventions is our
choice of keywords
we're doing declaring a class template
do we do template classics or template
type name a Supra first class yeah about
the half-dozen hands who prefers type
name but it's longer still seeing a fair
number hands go up okay
next rejection doing a class a template
template parameter since C++ 17 we can
use type name here as well so same
question who prefers class in this
context few more hands for the familiar
syntax who wants to move to type name in
this syntax in this convention already C
is slightly over half the room so bit
more debate on that one for an enum
class do I use enum class that we always
was proposed in the paper or the
equivalent enum struct just because I
can who prefers enum class about 80% of
the room who would still rather use enum
stroke because they can okay I see about
half dozen hands there last one do we
prefer by default to go with classics or
structure
who prefers to default teams in the
class keyword you can go out to provide
member functions and so forth
eighty-seven seventy percent of the room
who prefers going this struct anyway
yeah about 25-30 percent
my suggestion is class is always wrong I
would love to deprecated it if I could
this is what I've been doing in my
homebrew code now the reason is yes
class is shorter I don't care
struct but especially you come to struct
in class correct has the right defaults
because it's going to default to public
inheritance and public inheritance is
the right kind of inheritance I'm
inheriting an interface if I'm using
private inheritance I'm inheriting
implementation details and they're much
better encapsulated and hidden using
composition private inheritance would
really be a rarity and it shouldn't be
our default it also means that when I
start listing members of the class
unless I want to go into a private
straightaway I'm going to start listing
the public interface and this tells me
what I can do with the class it's
information for the use to say how do I
use this thing so public by default
actually tends to be my view when I was
coming with my own brief coding
conventions and thinking and figure out
your value systems seems to be the right
default for me now if you're leading the
class and making everything private
you're saying something different but
you are saying something about the
values of your code and you're saying
the implementation data structure of how
this code composed with other code and
so I can reason about the bits flying
around the system and have a much more
hands-on implementation level view of
the system is what matters to me and if
that is the nature what matters to you
class probably really is the right thing
and that's the reason we use class at
Bloomberg this might look how they
actually work with professionally is
going to be default to class and it's
actually the right choice for what we do
but by sitting around and playing with
this the idea of recreational C++ you
get to better understand what your codes
are trying to communicate to you and as
I heard from the floor down here when
you come to enum struct
struct is the right answer because it
conveys its all public wiki it is so
that's where you go to type name on my
templates now I just want to retire
class from my codebase entirely I have
no use for it nor type def I think the
room says it all where but I did have
fun with this because this is what I
found on the Internet
I love this this is fantastic
you'll notice it's C code not C++ oh it
is both this is funky ideally I can read
down to understand I've got the right
markers they're much more clearly
ynette which code is where it's just odd
to find that the semicolon terminating
this statement is on the next wine but
visually I like my code very
two-dimensional although this gets our
laugh when people see it I really like
it the problem is I tried writing C++
with it and we have too many decorators
in our type system so once you go beyond
the simple wire so you're getting with C
I mean it kind of works but there's too
much noise I'm not getting the structure
out the same as I want it there's also a
small example and that doesn't help
that's a yeah playing around with syntax
is always fun another example for
playing around with syntax earlier on
herb was suggesting this back at CPP con
the very first one I believe always Auto
everywhere which was a bit more extreme
than I was going with my auto usage so I
sat around and I played with it I know
other people have done this as well it's
a really neat idea the idea to got'em to
two ways of declaring my class here if I
use auto the compiler definitely knows
it's going to get the right type most
the time I can just reduce and don't
have to say anything but the time this I
want to be explicit and say you really
are this time the notion is that we just
construct it on the right hand side as
the right type and therefore it's going
to deduce to be that so variables are
consistently and always introduced by
the keyword Auto this basically says
variable now and it gives you a simple
consistent coding style you can be
everywhere and I believe in C++ 17
someone correct me if I'm wrong but with
the new rules on copy of working and so
forth being mandatory I think these two
are now genuinely equivalent rather than
having an implicit optimization to have
to occur there and the requirement that
the type actually be movable I think
this work even four types aren't movable
now my experience was that when you're
writing function templates Auto is
fantastic because did use him the right
type that you're getting reexpress and
you can't write code to do that but it's
always with Panther loved it in code
that I'm frequently changing where I
don't want to keep jumping and changing
types because it's malleable I'm
evolving I'm doing you rapid development
iterative auto was really helpful there
once I moved to a more stable code base
saying okay Mary why be failing maturing
I'm testing it I want this code to be
fairly stable I hate to be found out
like having explicit types in my type
system and I found this syntax was just
a bit too heavy wait for me to get it
but I didn't know until I tried playing
with it and your experience might be
different that's the fun of playing
around with your humbler projects play
around with coding style see what comes
up function declarations I've got the
same overload set for different ways
here first one is what you would get
from C++ cell sorry second one is my
first attempt at switching to C++ 11 I
just went consistently let's always use
the weight specified return type so the
option was well a void function doesn't
have a return type so I'll consistently
use the white space pod return type
apart from void
because don't you just know it
conveniently matches up with auto is
having four characters so it preserves
the property that all my function names
are line which I didn't have in the oh
three property so starting with auto or
void give me a really nice property when
I'm trying to read through overload sets
partly my settings over I'll just make
this wide and the final option of course
was I could go all the way down and say
well ball is another four character
things so I don't want to pay the
overhead of trying to write this extra
thing out the far side maybe this fourth
character symbols might car a blessed
and in practice that's the one I found
that worked well for me hand at the back
sorry would I do the same thing for long
that would be down in this category I
was playing around with anything that
was four characters I would avoid myself
to be this because all I wanted was the
everything lining up property but in
practice I found I preferred the
consistency of a result always went on
the right-hand side and void was the
exception because there is no result on
the right-hand side it's a happy cancer
there happens to be four characters
would I change this if void becomes
regular know because void will not
become regular darn it
so I'm done last life a fan keyword
games I think I wrote it's an April 1st
proposal on camera and I submitted it
was the idea that people were looking
ins around the era of C plus you know
2008 to have some kind of atomic keyword
to introduce atomic variables and I said
we don't want to introduce a new keyword
we can handle it with existing keywords
entirely do not break while using this
so that when it came time for acceptance
specifications we have do not throw a
while using this so the fun game is
what's the longest sentence you
construct using just keywords so here I
have you know a union guy threatening
some poor warrior do not try this law
out Auto Union case or else I am sure
you can do better but notice I'm heating
I'm using not twice and without go out
the end thank you we're done
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>