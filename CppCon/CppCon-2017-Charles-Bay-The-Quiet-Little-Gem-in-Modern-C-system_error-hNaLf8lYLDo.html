<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Charles Bay “The Quiet Little Gem in Modern C++: ＜system_error＞” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Charles Bay “The Quiet Little Gem in Modern C++: ＜system_error＞” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Charles Bay “The Quiet Little Gem in Modern C++: ＜system_error＞”</b></h2><h5 class="post__date">2017-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hNaLf8lYLDo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Welcome, thank you for coming today.
We're talking about &amp;lt;system_error&amp;gt;.
It showed up in C++ 2011.
It's in our standard
libraries increasingly so.
And lotta people are not using it,
but you're gonna see more of it,
so today we're gonna talk about that.
The takeaway is really easy.
Use enumerations, you don't
have to, but you should,
use enumerations, and
if you do, you're good.
If you're users, you're done.
You can leave, the talk's over.
Library authors are gonna implement
with the design that's presented.
And we're gonna talk
about the rationalization
of that design.
Is there a little feedback?
Everybody hear okay?
Okay, so here's the talk,
here's what we're gonna cover.
Introduction, what is message?
There's a lot of conflating
of error codes in messages.
We'll briefly go through that.
We'll talk about &amp;lt;system_error&amp;gt;
that showed up in C++ 2011.
It's being used increasingly
so with the new libraries
dropping, like in 2017, file
system and networking TS.
And then some recommendations,
honest review, but
there's diminishing returns.
The important stuff's up front,
so if we don't get through
all of it 'cause there's a lot
to talk about, that's fine.
So the disclaimer is
these are error messages,
so there is a meme alert.
I put little pictures in the upper corners
so you wouldn't be bored
because error messages are annoying.
Nobody likes them, so this
is so you won't be bored.
You know, you can look
at the bunny or something
while we're talking
about the boring stuff.
'Kay so, what we're not gonna talk about,
what &amp;lt;system_error&amp;gt; does not address,
there are Holy Wars, Hacker
Wars, there are Message Wars
in most of our systems, especially
as the code basis evolve,
there's one, two, three, four
messaging subsystems in there.
Routing, this happened,
I want to do conditional
branch processing on this
scenario that occurred.
I somehow forward that
back up through my API
so that the caller can deal with it.
The caller may be echoing to the disk,
may be popping a box to the
user, may be writing to a file,
may be sending something
to another process,
may be shutting down
the core of the reactor.
There's conditional
processing that may occur
based on that, so these
messages are event notification
mechanisms that we use to
forward back to the user.
It's a way for the implementer
to communicate with the caller.
And there's a lotta
contention on how you do that.
The contention's largely
based on how do you
phrase algorithms, compose larger systems,
and do this branch conditional processing?
The error code is just an enum.
That's how you should visualize it.
It's a really powerful enum,
it's a little bit better than enum.
So this is some of the stuff
that you would ideally deal with
in composing and phrasing
higher order algorithms.
Conditional branch processing
based on a scenario,
an event, a circumstance,
something happened.
Different code bases,
different environments,
you have different house
rules for how people
want to address these things.
Generally, we're not gonna
talk about this today.
We're just talking about super
enum, which is error code.
And clarity, constraints, correctness.
There's a lotta personal taste
in how you're gonna use these things.
So there's minimal infrastructure
for API implication.
You're gonna have an error code
and you're gonna pass
it around, that's it.
So, wars, we have a lotta wars.
There's misunderstanding
and conflating messages.
This is a really overloaded term.
It's like static is a
really overloaded thought.
Messages, on the misunderstanding,
we're gonna conflate stuff.
I'm gonna give you the
result of a scenario,
a message code, an error
code, and you're gonna make
a decision and do conditional
stuff as a result.
And conflating the branched processing
and what that error code
represents is kind of an issue,
so how we compose and how we handle,
that's generally the applicable thing.
And the house rules are
gonna decide how to phrase up
large and larger scale.
So, kinda moving on.
Messages, errors, exceptions,
we have several ways
of communicating with the
caller about propagating up
the results of a scenario.
So the message, it is gonna
provide visibility, right?
We've got, there was a
state change in the system,
better tell somebody.
And something happened,
better tell somebody.
There is this failure scenario idea.
Lotta time, error code,
you're thinking there was
a failure scenario and I gotta
do something in particular
to deal with that failure.
Well, that's a negative test.
Sometimes, a lot of
times, most of the time,
negative information, a
negative result is actionable.
So we're gonna propagate,
inform the caller, hey sorry,
this was good, that was not good.
You know, you may wanna
do some extra stuff.
And then there is this exception idea,
and this is the, you're not
returning from functions,
you're not making forward progress,
this is a stack unwind, right?
You're going backwards,
you're in rewinding,
you're destructing, and you're
gonna hopefully catch it
at some point and reset.
So, these are gonna be the
ways we're gonna start handling
errors versus exceptions.
And kinda key to our
mind because error code
is about composing and
phrasing high order algorithms
based on actionable information from the
communication of the implementer,
I know what's going on,
and I'm telling you, the
caller, here's what happened.
How can foo finish?
Finish, the results of foo,
foo did something and it finishes.
So, well it can complete,
that would be good.
Foo executed and there was a return,
maybe returns boy, maybe it
was some object, who knows?
But success or failure presumes
the function actually completed.
Well, it doesn't have to complete.
You can throw an exception.
Right, that's a stack unwind,
you're gonna go backwards.
Or you can just terminate.
Just hit terminate or exit
or something, you just abort.
Well, now, we've got this
suspend thing coming along.
We're gonna start playing with coroutines
and resumable things because it's gonna be
an interesting way to also start
composing higher order algorithms.
And of course, we still
have to communicate back
to the caller, things were
good, things were not good.
Here's your information from which
you can do your conditional branch logic.
So, we are a very rich environment,
more so than most languages
because of our ability to compose.
Error code is just a
super enum, that's it.
So, operation completes,
success or failure.
Suspends, we've got that, and
then it does not complete.
This is a summary of
what we just saw before.
And all of those are legitimate ways
for a function to finish
and for us to communicate
back to the caller an error
code or some sort of information
about we're good, we're
not good, this happened,
go ahead and conditionally branch.
So, error message, it's an error code.
A lot of times there's an
associated message with that.
The caller's gonna do
something based on that.
And this is one of the things you can do
if you don't wanna use error_code
and this is done a lot.
It's surprisingly useful.
We're gonna call a function,
it's gonna return a string.
Well, what's in the string?
I don't know, there's stuff in the string.
You wanna know what happened,
you parse the string.
Maybe if there's like the word error,
maybe it was an error, and
that's a very open-ended design.
So a lot of the higher order
languages will do that.
APIs that are unplanned will do that.
It allows me to not establish
enumerated results up front.
I can just kinda wing it
as I go and add stuff.
Now it's not particularly well documented,
but if you follow conventions like
the word error means
something bad, and somebody
does a RegEx on the screen,
they see the word error,
they know that's an error, this
actually works pretty well.
This is surprisingly
useful even though there's
no type safety here at all.
And it's hard to document,
it's hard to maintain,
but it's surprisingly useful
how big systems are built
based on just returning a string.
No enumerated state, no enumerated branch
condition processing,
but you pick up a lib,
you see some strings, you start handling.
It tends to work, it tends
to scale at some level.
So those are examples that you could use
if you don't wanna use
error_code, that's fine.
So we'll go down, messaging and logging.
Logging is a big issue and
error_code does not help you
with that at all.
There are frameworks,
there are many frameworks.
There's syslog, there's a
lotta in-house developed stuff,
and most systems of size,
most code bases of size,
there's several of these in there,
several messaging and logging systems.
It just tends to work that
way because of the constraints
of the latency of the notification,
the path by which you route information
back to the interested party.
So I know a lotta people
don't like error codes
in messages 'cause they're
frustrating and annoying.
Well, we all kinda admit
we need logging though,
because we have to suffer the systems
that aren't behaving properly
and figure out what happened,
what's going on.
So this is kinda the
scale we're working at.
So logging is necessary.
It kinda gives you that big ball there.
Logging is helpful, logging is disallowed.
And there are very few systems
where logging is disallowed.
They exist, they mostly
existed 10, 20 years ago
because now even your vacuum cleaner
has a full TCP/IP stack in
it, and you can talk to it.
But there are a few
systems where you can't
do logging at all, but the scale,
we've seen this scale before.
The scale is this.
There's the sun, logging
is helpful is Earth,
and the $100 thousand tool
bag dropped by an astronaut
back in 2008, that's the very end case
where logging is really not
allowed or not possible or
not gonna solve what
you need on the system.
So definition of terms.
We'll go through this
really quickly 'cause
this is intuitive, you
already know this stuff.
So there are message frameworks,
there are tracing frameworks.
There's a lot of overloading of terms
in this messaging space.
So you've got that messaging
across object boundaries,
like the old small talk thing.
And you've got messaging across CPUs,
and we have so many ways
to talk about messaging.
And &amp;lt;system_error&amp;gt; is just an enumeration.
It's just a way for
the implementer to say,
&quot;Look, I have these scenarios,
&quot;and I've communicated, discreetly,
&quot;the scenario to the user.&quot;
So the user can do conditional processing,
initial handling based on
this very specific scenario
that I encountered when
running your request.
So this is just kinda arm wavy stuff
that has nothing to do
with &amp;lt;system_error&amp;gt;.
So here's more &amp;lt;system_error&amp;gt;
messaging framework,
and whether or not you're using syslog,
whether or not you pop up dialog boxes
has nothing to do with &amp;lt;system_error&amp;gt;.
We're going to merely
talk about a super enum
that can pass around through
our code, that's about it.
And it's up to somebody else
to decide whether or not
to pull in your own framework.
So you can do branch logic on it.
You can do very discrete
handling of specific scenarios.
You can have information
payloads in there,
but generally you'll
have to add that on top.
But the framework itself
is something you bring
external &amp;lt;system_error&amp;gt;.
Okay, it is a mechanism, what is it?
&amp;lt;system_error&amp;gt;, it's a little
header, really little header.
There's a class in there
called &amp;lt;system_error&amp;gt;, so,
okay, well the &amp;lt;system_error&amp;gt;
class you will see.
And that mechanism will
have an enum payload
that you're gonna receive
and test against, that's it.
If you're a library implementer,
you're gonna define discrete set,
you'll populate this error,
bang, that you give back to the users.
So it's a single event message,
definition or instance.
Go down.
That's terms for today, event.
I'm just gonna kinda skip through this.
Essentially, bring your own framework,
&amp;lt;system_error&amp;gt; isn't that.
It's an enum, that's
it, it is nothing else.
There's gonna be a lotta
stuff in this slide,
especially at the end that, you know,
you can take the slides and
play with them and review 'em,
but the diminishing returns is up front.
It's an enum, think of it as an enum.
We're passing around and populating enums.
Library developers, there's some tricks on
implementing the super enum.
But users don't have know anything more
than you're using an enum.
This is why &amp;lt;system_error&amp;gt;
did not even try
to take on the framework thing.
It's hard to build a message framework.
So in this case, we got a lotta quadrants.
Generally we're talking
about what is the volume
of information produced,
and what're my requirements
on being able to handle
that at what latency.
So the speed and volume kind of thing.
And there's kind of a scattered
need across the universe
of where you might be in handling
certain types of messages.
In a lotta cases of course,
you don't have the same
requirements for all error paths.
Some stuff is the hot path,
and you have specific requirements.
Some stuff is in user
time, you don't care.
You've got all the time in the world.
So you might end up with
multiple frameworks and we do.
Most of our systems
have multiple frameworks
because that's a hard problem.
&amp;lt;system_error&amp;gt; does not
help you with that at all.
It's an enum.
So this is an example of contrasting
in one product, a network
compliance perhaps,
the data plane from the control plane.
There're different
requirements for latency
and volume of information.
And the framework has to deal with this.
&amp;lt;system_error&amp;gt; does not do
this, you bring that yourself.
&amp;lt;system_error&amp;gt;'s an enum.
So we'll get in
specifically to what it is.
But this is what we have, a
lotta people are familiar with.
Now, let's just go through
an example, what if?
What if I wanna say well,
you know, there's this,
there's this concept of a
message that I wanna do,
a message definition.
So somewhere out there, you
can put it maybe in a header
and call it SIGSEGV, and
maybe you can put some kind
of definition and implementation
file somewhere else.
And you wanted to find what
a segmentation fault message
would look like.
It might look something like this.
Now, this is a little bit hard to read.
That's not the point.
The point is somebody defined
that message ahead of time.
They said, &quot;Look, this is
the scenario that may occur.
&quot;I'm defining that.&quot;
And this happens to be
some code that you may see.
There is the point at which
the notification occurs,
the event happened.
So up above we just defined
it, hey this may occur.
Its scenario I handle in my code.
But the event notification's the idea that
I actually encountered that scenario.
I encountered that condition.
This message could be
created and handed back
to someone to handle.
In this particular case, the
message echoed to system out,
or you know, standard
out or standard error,
wherever it came in from the console.
And you'll notice that
the string down below,
you know, segmentation fault,
is suspiciously similar
to that string up above that was defined
in that implementation file.
So somebody had defined these things.
Some had a priori
knowledge of this scenario,
this condition, as
something that may occur.
So we can do various tooling
to maybe decorate this thing up.
So in a lotta cases, in this
case we're running with,
what is it, Valgrind?
Okay, so you might have
instance-specific timestamps
or key value pairs if you're
doing structured logging,
or instance-specific additional
context, additional state,
that kinda carries along with that message
that might be useful to the
caller, to the user eventually.
So that's ultimately
what's going on there.
&amp;lt;system_error&amp;gt; basically is
about defining a super enum
and this additional
context may carry with it,
in a real world event
notification scenario
to help with conditional
context and branch processing
and logic for the caller.
But this is the contrast
between I defined a message
that may someday occur, the
message actually occurred.
&amp;lt;system_error&amp;gt;, that's
what it does, it does this.
Okay, so for today.
You know, event
notification, it's kinda like
&amp;lt;system_error&amp;gt; is an event,
hey look, there you go.
Maybe it was good, maybe it was bad.
It has no judgment on
you or the implementer.
&amp;lt;system_error&amp;gt;'s just this neutral payload
saying back this scenario occurred.
So your framework, you'll
bring that yourself,
but the idea of event notification,
the idea of giving you an
instance that you may choose
to log or carry forward or
pass on to some other process,
&amp;lt;system_error&amp;gt;'s kinda built
so that you can carry it
through your APIs.
Okay, so error codes and messages.
What are they?
Okay, a message, that's
segmentation fault.
It's typically human
readable, doesn't have to be,
could be a machine interface.
And it's going to be some
kind of a descriptive string.
Maybe there's instance-specific
state tied to it.
That's sort of a carrier
saying this occurred,
tied to this enumerated value,
this enumerated discrete scenario
that we had a priori knowledge
of establishing and then
we forwarded it back to the user,
and they were expecting it because
they read your documentation saying,
this function may cause
these enum errors to be returned to you.
And then you would say, oh,
now I need to handle them.
So &amp;lt;system_error&amp;gt;, that's
it, that's what it does.
So a message is a notification
of a condition or state change.
That's typically why we're messaging.
And what's a little interesting
is message identifiers,
this is kinda one of
those Holy War things,
and some of the tools
are really good about
they'll have a unique identifier
for every possible message.
And some won't do that.
And if you have a unique
identifier, well that's good
'cause you can type it into a web search
and find out what's going on.
If you don't have that, the
whole message implicitly
becomes the identifier.
And it's surprisingly useful
that you can do it like that.
You can have a message identifier
which is the whole message string.
Here's the message string.
So I want the output to be that, that
&quot;error, value must be between 1 and 20.&quot;
That's what I want the message to be.
Well there are a lotta ways
that I can type code to get that.
Now the first bite, first approximation,
I'll just hard-code everything.
And then boom, that's my
message, how hard is that?
Well, I don't have to do
that because you know,
if I have like a min-max bound thing,
sometimes you don't wanna hard-code that.
You would like that to be more
conditional or situational
so I'd like a more reusable message.
I'm gonna lift out some, in
a local context, for min-max,
and I'm gonna serialize out this.
So we're gonna assemble
the string on the fly.
Well, okay, well, printf will do that.
So I can know pull the string out fully
and instead of having
the string serialization,
which when you have big messages,
the string serialization
gets really unwieldy,
which is why Python went to the next one.
Oh, well actually one after that.
From printf to fprintf,
we're changing out target.
This is where the user
is making the decision
on destination.
Now the other ones, the
decision was sort of implied
on destination.
Now the user's deciding,
or the implementer,
the guy writing this algorithm,
is deciding the destination.
So we're talking about what
kinda power are we giving
the implementer in employing this message?
And then, this is kinda
the Python-y thing,
where they're lifting out
these formatting strings,
and then we'll have the
context like min-max,
or the conditional information
that we might wanna drop in there,
and then you can build
higher ordered things
with structured logging and other stuff.
So this is all giving us
ultimately that same output string.
Here's another one.
Now this is interesting,
these last couple.
So the other messages,
we were sort of implying
these are your strings going out.
And now we're starting
to establish categories
or classes of errors.
There's a whole family of errors,
there's a whole family of warnings,
a whole family of informational things,
or maybe debug things or
verbose things or trace things.
You can have as many
categories as you want.
We're starting to apply
categorical information
to this string.
So that's interesting because
now we're giving the author of this code
the ability to say, well look,
you can define min and max
and you can define the format string,
and maybe you can define the destination
or maybe you can define the category
and I'll pick the
destination in the library
or in the framework.
&amp;lt;system_error&amp;gt;'s not the framework,
but these are the attributes
that we wanna start applying
to this thing where whoa, that happened!
What happened? Config didn't load.
What happened, the user
filename was bogus,
it wasn't on disk, it
was the wrong format.
There's a scenario and we're
starting to add context
external to what that thing means.
And the context is not
the same across the code,
maybe sometimes it is, sometimes it's not.
So and then here's another one.
Now this last one is interesting.
Because what we've done is we've
removed from the programmer
the ability to make bad spelling mistakes.
Now there is this enumeration now
in this like this
ERR_VAL_OUT_OF_RANGE thing.
So I'll let you and your context
establish min-max bounds,
I'll let you pick the enum,
but you don't define the enum.
You're just picking the
enum, and you know what?
You can't insert profane
words into error messages.
You ever grepped your
code for profane words
that might show up in front of the user?
Apparently, there are
places that will do that.
There are stories, many.
So this bottom one, that
looks a lot like what
&amp;lt;system_error&amp;gt;'s gonna do.
It's gonna be like this.
Okay, so we want to empower the developer.
Well, a lot of times we don't
wanna empower the developer.
The developer doesn't
wanna form well-phrased,
well-spelled expressions of text
that go in front of the user's eyes.
Sometimes, yes, but we don't have to.
So in these top examples
here, we are giving you,
the first one, infinite power!
Type whatever you want, go nuts.
And hopefully there's a
review by other developers,
but the top one, you have infinite power.
And as we go down, we're
gonna start changing
the power you have to
pick your destination
or pick your error category
or kinda your other stuff,
but this is kinda some of the
things you're allowed to do.
You can pick your level.
Yeah, well for you, opening
that file was a warning.
Look, I was looking for
default, I didn't find it.
For me, it's an error.
If I don't have a configuration,
I can't boot the hardware.
So it's possible the
attribute of the category,
the classification of errors
that's tied to the circumstance
or it's tied to the message,
could be either one.
Lotta times, you'll go one way in one area
and one way in the other.
So, those are overrides.
These are kinda some of the examples, and
the key point on the bottom one is look at
what the developer is allowed to do.
The developer is not
allowed to misspell words,
is not allowed to define a badly phrased,
confusing, ambiguous statement.
Somebody had to do that, but the person
handling this scenario in the code is not.
All they're allowed to do, in this case,
is establish min-max, and pick an enum.
And if you pick the
wrong one, well ideally,
there'll be a check for that,
but you actually have to
pick an enum or it won't compile, right?
We're picking up an enumerated
value from somewhere.
It'll either compile or not.
So this is a maintenance point,
and we've given the developer
minimal ability to override
with this kind of thing.
And whether or not you wanna
break out the classification,
the category of error or not,
that would be a personal choice.
&amp;lt;system_error&amp;gt; doesn't care.
&amp;lt;system_error&amp;gt;'s gonna
give you the bottom one.
Okay, so invoking a message.
Something happened, I wanna tell someone.
Okay, identify and provide field-values.
Now &amp;lt;system_error&amp;gt;, as it
stands, is not really good
at giving you payload
instance-specific state.
This happened, I couldn't open the file.
Well, what file?
Well, I don't know.
That's not &amp;lt;system_error&amp;gt;'s job
in its current incarnation,
so people typically put
a hash or key value set
or something like on that,
and there's a whole world of
structured logging to deal with
state and stuff.
There's some libraries, like
the new Stockholm Library,
that are specifically
addressing stuff like that.
But we are identifying messages
and we are invoking them.
It'd be nice to be able
to override destinations
or override warning or error level,
or maybe kind of make
other fiddly changes,
but it's sometimes
dangerous to do all that
local overriding, so these
are gonna house rules
in your messaging framework to decide
how much power you wanna
give the developer.
But by default, out of the
gate, an enum, an enum.
You should use them.
You don't have to, but you should.
&amp;lt;system_error&amp;gt; doesn't require it,
life is easier if you use enums.
Okay, so making it easy.
You're not gonna get better than this.
This is the least code you
will ever, ever, ever type.
Name a way for a developer to say
this happened, you deal
with it, not my problem.
I'm just telling you,
couldn't open the file,
or disk is full or whatever it is.
Saying mylog with an enum
is the best you're gonna do.
There's nothing else.
Now, maybe it's gonna
be mylog with an enum
and some local context,
like min-max values
or some other information.
That's the best you're gonna do.
There's no way to reduce this further
through implementable code.
But that presumes, that
assumes, that expects,
that demands somebody somewhere out there
made an enumeration, say
these are the discrete states
that may occur, and then you can use them.
And you probably, you don't
have to, but you probably
want some sort of text, some
sort of user-viewable review of
what does that enum mean?
What is the thing, what is
the message that actually
goes to the log file or
goes to the user's eyeballs?
So these, this enum and
this table of strings,
it's gonna have to be defined somewhere.
And &amp;lt;system_error&amp;gt;, that's what it does.
It's just a design.
You could come up with other designs.
This is a simple one and it's using
a little bit of type traits.
But it just presumes you know enums.
Enums are really powerful because
when you have an enum,
especially with C++ 11,
we have strong enums, you
don't need strong enums,
but strong enums are an example of how
from enum I know the
type, and from the type
I have all these traits tied to the type.
And now with the magic of metaprogramming,
you can go nuts.
You can associate all kinds
of things with other things.
And &amp;lt;system_error&amp;gt;'s basically doing it.
What is it?
Well, it's not your logging framework.
You go and bring that yourself.
&amp;lt;system_error&amp;gt; is two things.
It is an adapter.
You can take whatever super
weird, stupid thing you have
and you can shove it into
a &amp;lt;system_error&amp;gt; object,
and then pass that thing around by value.
Safe slicing.
So by value pass around &amp;lt;system_error&amp;gt;.
It's an adapter.
It'll unify across your error subsystems.
That's what it does.
It's also a design, an
implementation mechanism,
where there's this thing
called standard error category
and you're gonna derive from
it to put your enums in there.
It's a decision made by the committee
on how this will occur,
how the implementation will occur.
You'll hook into the
framework, set your enums,
and you're good to go.
But in theory, all your
APIs are gonna be passing
around std: :error_code,
and all your errors are propagated
across third party binaries.
You start loading other systems,
they're giving you error codes.
You're a system, you're giving
other people error codes.
And it's a common interchange mechanism.
That's what it is.
And that's why the file
system TS, the networking TS,
and some of the other
libraries coming in from C++11,
and that's why it's
doing std: :error_code.
Prior to this, we didn't really have a way
to pass errors around in a standard way.
That's what this is doing.
Okay, so what's in box?
It's not a big box, it's a little box.
Open up the &amp;lt;system_error&amp;gt;
header, it's not a big header.
Okay, well if you're a user,
you kinda don't need to know
any of this stuff, it doesn't matter.
What're you doing?
I see enums, I test against enums,
I'm a user, I know nothing.
Cool, that's it, you should
not have to know anything.
If you're a library
developer, if you're authoring
or creating these
things, this is the stuff
you kinda have to know.
And of it, you really only
care about a couple things.
There's this thing called
error_code, use it.
You're gonna receive it,
so you'll have to be able
to decompose or compare it with something.
You'll compare it with
an enum, you're done.
Error_category, that's
for the library authors,
the implementers that
are trying to establish
the finite bounded set of a
priori scenarios that may occur
that you wanna communicate
back to the caller.
These are the enums I may give you.
And maybe there's some
documentation associated with them.
Users will be happy because
oh, oh, you're saying
there are five ways you're
gonna tell me you were upset.
Yes, there are five ways,
here are the five ways.
Handle the five ways, we're all good.
Error_category is for library
authors to implement this.
So we'll go into that very briefly
'cause there's not a lot to know.
And then there's some other junk in there.
And you don't care, it's just gonna work.
It's basically gonna be obvious.
You don't have to know those details.
And there is a confusing
thing that's going on
in the community of is it an error code?
Or is it an error condition?
And for the most part, you don't need to,
you don't need to get
involved in that confusion.
Error codes are in your APIs,
error codes are received from other APIs,
you'll be using error codes.
The library author may
have to make some decisions
whether it's code or condition.
Well, you have this now.
It came in C++11.
It's standard in C++11.
So if you're on a 98 or 03
compiler, you didn't have this.
Oh but wait, you do.
Error_code, it predates C++11.
It's found in Boost, it's
ready to go, ready to rock.
If you're 98 or 03, just
pull it in from Boost.
Oh, you know what?
Asio's got fully
implemented, that's kind of,
this is the basis of the networking TS,
so the &amp;lt;system_error&amp;gt; stuff kinda came out
of the Asio networking TS stuff.
So there's a full
implementation there too.
Pull the Boost implementation,
it's fully ready to go.
Pull the Asio implementation,
it's fully ready to go,
if you're on 98 or 03.
But if you're on 11 and
beyond, you already have it.
So everybody in the room,
we all have this stuff.
We all have it right now, depending on
which lever you wanna pull to get it.
Okay, so, so this is all
we really care about.
I have an enum with my
finite, discrete a priori
established scenarios that
I may wanna communication
with the caller, this happened.
And I probably have some kind of string
or descriptive association to that enum.
Somehow, magically, this has
to get tied to the invocation.
So mylog, and then I put an enum in there.
Mylog, and I put an enum,
maybe some additional context in there.
And the top, you're
gonna use error_category
to implement the top.
And the bottom users are
going to receive error codes.
You as an implementer, you're going to be
populating an error code to
go back, and it's not hard.
Error_code equals this enum, you're done.
It's like not hard.
Okay, how does it work?
Well, I wanna write this code on top
'cause you're not gonna
get better than that.
You're not gonna have
less typing than that.
You're not gonna get better
type safety than that.
I somehow want that associated
with the implementation
on the bottom, which is gonna be
defining the error_category.
&amp;lt;system_error&amp;gt; does that.
So ...
This is a pattern.
It's a pattern we see a lot.
It is, oops, up.
You can call it something else,
I'm calling the handle-in-context pattern.
This pattern is so used that
I'm going to take a moment
to beat a dead horse and say
how much it is used already
in your code.
And &amp;lt;system_error&amp;gt; is
using the same pattern
you're already using in your code.
So, it's magic.
So, as an example, this
is the same pattern.
And don't answer yet
the question what is t0,
let's look real quick at the, okay.
There's a worker and another worker.
And oh okay, int
main(void), I am a thread,
I am the main thread,
I'm going, I am a thread.
Oh you know what, I wanna
make another thread.
Let's call it t0.
No, no, no, I want another
thread, let's call it t1!
I want a million threads!
Go make a million threads, go nuts.
Well, what is t0 really?
What is t1, 0?
It's not a thread.
And you know what, I gave
you a hint, next one.
Hint, it's not a thread.
How do we know it's not a thread?
Before you answer that, you
know it's always good to say,
well, how big is it?
Well, you can just do a sizeof it.
And well, it's little,
it's not big at all.
But well, wait a minute.
I know threads they like have
a name and a control block
and thread local storage
and thread statics.
There's a lot of stuff in a thread.
How can t0 be like so little?
Like the size of a pointer or something?
And that's because it's
not a thread, what is it?
It's a handle!
It's a handle to an
implementation defined thread.
There is a thread somewhere,
somebody implemented it.
It's a handle, it's a handle.
And so we have this light
and fluffy, lightweight thing
called a t0, which is not very big.
And it is a handle to an implementation.
And this is the power of C++, right?
We can stick our
implementation-defined thing
over in that lib that we're not even gonna
load till run time, and
all our code still works.
We don't even have to
recompile, that's kinda cool.
So what pattern is this?
And that's the pattern.
This is the handle-in-context pattern.
And so we're gonna go
through a couple examples,
but this is really the key question.
Where's the context?
Okay, so I have a handle,
where's the context?
So next slide, well okay, if
this is the handle-in-context,
if t0's a handle to an
implementation-defined thread
that's somewhere else,
where's the context?
You wanna take a shot.
It exists, it better
exist or we're screwed.
In this case, the context
is the entire process.
This is the wimpy way to go, you cheated.
You always have the current process.
You can always go to the
current process levels, global
and state, and start
interrogating and doing stuff.
The thread is assuming
there is a context around it
and somewhere in that
context, somebody's saying,
I wanna create threads, but
as these things are created,
they're uniquely coordinated
amongst each other
so there's no thread one,
thread two, thread three.
Oh, I have four thread threes.
No, there's only one thread three.
Somebody is brokering and
handling the unique naming
of all these threads.
The context is doing
a really important job
handling resource allocation
of oversubscription
or the hardware's already
taken by somebody, or.
The context does a very important thing,
but that's invisible to us.
We're just creating handles,
and magically the context
popped into existence.
And so, the context exists.
It may be a singleton,
may be process-specific.
There may be more than one context.
In the case of threads, there's
only one current process,
so there's only one global
context for threads.
A handle is constructed within a context.
You may have more than one
context for some designs,
but the handle only makes
sense within the context
for which that handle exists.
And you can have dead handles,
maybe, with no context.
But the handle's meaningless
outside its parent context.
The system maintains design
invariance through the context.
The context is doing the heavy lifting.
The handle is not doing the heavy lifting.
So design invariance,
we have a lot of 'em,
and this is the power of our systems, but
other things like, you
know, rewrite coordination
or allocating of scarce resources
or you know, other stuff,
there's stuff that you would
want to ultimately handle
always through the context,
and never through the handles
'cause those are just
lightweight little things.
Okay, so here's Alexandrescu's Allocators.
They gave a talk a couple years ago.
Funny story in the
upper right-hand corner,
they did successfully
surgically reattach his hand,
so that was, you know, good.
MyAllocator equals.
So Alexandrescu proposed
these composable allocators
where you can establish
policies for, strategies
for how you wanna allocate blocks
and how it would handle that.
But you created an allocator
and then you would allocate
little things from it,
you can play with them.
And then when you're done with them,
you would give 'em back and
they would be cleared up,
they'd be freed.
Well, this is the
handle-in-context, right?
So I've got a handle to a
memory thing that I allocated,
and then when I'm done with
it, when I wanna retire it,
when I wanna get rid of
it, I'd return it back
to the context and it
would coalesce or nod or
however you establish your
composable allocation strategy.
This is a good example
because this is an example
where the context is in your face.
You are managing the context,
you are managing the handles,
and there is this association
that a handle outside
the context makes no sense.
So in this case, you're
charged with holding
those associations together.
Okay, so why do we do this pattern?
It's done a lot.
We do this pattern because
it is really, really fast.
That's ultimately it.
I want to do centralized
control of design invariance
for something, threads
or hardware or memory.
I mean, we always are dealing
with scarce resources.
So I would like to reuse things,
I would like to coordinate things,
I would like to control things,
but I wanna make it easy.
So we do value semantic
handles being passed around,
but the context is established
in this sort of hidden place.
And so these are kind of example domains,
network file thread.
There are a lot of places
where this pattern's
really, really popular.
And almost always it tends to be
amortization of a scare resource.
That's always a good way
to drop to this pattern.
And well, you know, error messages,
any time you do string
manipulation, that's expensive,
that's very expensive.
It'll impact your latencies.
Amortization of scarce resources
tends to be interesting.
Okay, so shared_ptr's actually
the handle-in-context pattern,
whatever you wanna call it.
So we have this owning
pointer called shared,
and we have this non-owning
pointer called weak.
And they're both referencing objects,
and somehow, they're
both sharing the same,
the control block, the link
count, the object itself
that they're referring to.
All that context, these
handles are sharing.
And magically, it just works.
Well, yeah, because the whole
point of this context pattern
is the context will establish invariance
that are controlled.
And handles are just
lightweight ways to reference
through the controller.
So this handle of context,
we've got owning and non-owning
and we can kinda see the
control block exists,
we're aware of it, but
many, many context exists
because many, many objects may be.
This is so popular, so powerful,
you can really drive a
semi-tractor trailer through it.
You can do a lot of
mischief with this pattern,
but we're already familiar with it.
We're beating a dead horse.
It's light and fast, it's controllable.
I'll leave this, the slides,
but I wanna get to the code
because that's more interesting.
Library developers are
gonna have to be aware of
a couple of things.
Users know nothing.
They receive a std: :error_code,
they test against an enum.
Okay, the message category.
This is what a library
developer cares about.
Users do not care, users do
not care, users do not care.
An aggregation of messages.
Hey, there's this domain of
all these enumerated values,
this is my category, my domain.
I think domain would've
been a better word.
It's error_category.
You'll derive from std: :error_category,
and you'll put your enums in there,
and your associated
strings will be with there,
and that's it, that's all we're
gonna do, this is not hard.
There's like five, well,
15 minutes of work.
So you might have a lot of domains.
Well, these you get out of the box.
C++11, there's more
droppings since C++17 came
a few days ago, but these
are the common ones.
Now look here, namespace std,
we've got this errc thing.
That's your POSIX errors, right?
These are commonly understood
scenarios that may occur.
And they're ready to go.
You can catch an error code and test it
against any one of those,
and if it equates to that,
if it's equivalent to
that, that's what happened.
So you can just use this now.
You don't have to define your
own, these are ready to go.
But some domains, they wanna
define their own errors.
And that's what error_code does.
Have as many domains as you want, go nuts.
You'll probably end up
defining your own domains
for your own domain-specific issues,
and you're just gonna make an enum,
slap it in your namespace.
But these are right there out of the box.
Okay, so, I'm gonna skip through
because you're not actually
gonna write code like this,
but there is a global process-singleton,
kinda like you have one dealing
with your thread allocation
and coordination, there's a global process
kinda thing that is
establishing your singleton
for your category.
So these, these are singletons
that exist in the standard.
You link, you run, these
are there right now.
Each of those categories have names.
It's a process-singleton, it has a name,
it represents a category or
a domain of stuff that may
be interesting as enumerated concept.
Okay, error number, we're
dealing with this a lot.
And this is kinda the old
way we used to do it in C.
You don't have to do an
enum, but it's a good idea
to do an enum 'cause you get type safety,
but lotta code is C.
And C is doing this error number thing,
and that's kinda like the
thread-local global that gets set
when something goes wrong.
So it's set to zero at process setup, and
people can overwrite that value.
So when you call a function
and something bad happened,
like here, open the file,
and you get the file descriptor back.
And if the file descriptor
is less than zero,
well, something bad happened.
Well, what happened?
Well, I don't know.
Well, let's go check the
global called error number,
and we'll test it.
Now there's even this
little formatty thing.
Std: :strerror and it's not thread-safe,
but it'll give you a little
descriptive string saying
what happened.
So that global is set
associated with a lot of
system kinda calls where
there's no error path,
there's no error code
being returned to you,
so you go to the global yourself.
So it's kind of a hidden context
that keeps getting overwritten
as your thread makes progress
so if you wanna know what the error was,
you better hit it quick
because it will be overwritten
by the next error.
So GetLastError is a similar
thing that Windows is using.
Error_code is generally
a better design for this.
The APIs are gonna be more thread-safe.
But also, depending on
your view of the world,
Linux, Linus Torvalds doesn't
like the error number.
He think it's a flaw
design, that's interesting.
But error_code's a better
way to do the same thing.
Okay, here's Asio.
Asio says, look I'm running
this networking kind of stuff,
and you know, I got my own
class of problems here.
Everybody's got their
own class of problems,
so Asio chose to break out
four different categories
of errors, there they are.
And it's not hard.
You just find your little
enum, and then you're gonna get
your category associated with the enum.
And that's it.
When you write one, you're
gonna do the same thing
to find your enum and get your category
associated with the enum.
This is the number one
most confusing thing about
&amp;lt;system_error&amp;gt;, and I urge
you to not be confused
by saying, use error_code,
don't use error_condition.
You can't go wrong.
If you wanna use error_condition, you can,
and then you can explain
to people why you did it,
but it takes more time to
explain than actually do it.
We'll explain why they're different.
And this is part of the design.
It's interesting, but our APIs
will pass std: :error_code.
Our APIs will not pass
std: :error_condition.
Even if you wanna use
std: :error_condition,
your APIs will not pass
std: :error_condition.
They will pass std: :error_code,
error_code, error_code.
Platform specific behavior is
inconsistent across platforms,
by definition.
This contrast between
that which is specific
to this platform or which is applicable
in a consistent way across platforms,
that is the difference between error_code
and error_condition.
Now, developers may get
confused, but we all respect
that this is a scenario we
sometimes have to deal with.
Some of our stuff is platform specific.
So I'll just skip over this, but
message-ID, message code, message values.
You can review the slides later.
This isn't helpful.
I really need to get to
the contrast in between
code and condition.
The reason they came into existence,
and this is C++, this
is not other languages.
Other languages understand
this thing called error code,
the idea of it, we have
one in the library called
error_code, std: :error_code,
but what does not work?
The reason we have this design is
if you say there's this
one class of errors
that we all trust, we all
believe, a committee made them
so they must be smart, so
we'll all just use them.
We'll map our context
into the standard ones,
and everybody'll just
use the standard ones.
That does not work.
That presumes there's a standard one,
but in reality, there's
always domain-specific.
It's supposed to work by
having a common denominator
that we all accept.
The reality is that common
denominator doesn't exist.
That's intractable, it's non-scalable.
So we have a design where we
allow mapping of my domain
to your domain.
Equivalence of my domain to your domain,
that's what error_code's doing.
So a universal enum that everybody uses,
that's not what the POSIX errors are.
Those are just common scenarios
that sometimes happen,
but that's not the universal set.
There is no universal enum.
That's the design of std: :error.
Mapping across enums,
easy, that's what it does.
So, the standard one,
the implied mechanics
is everybody maps to the standard one
and all error scenarios, all
our conditional branching
is based on standard errors.
Does not work.
That's why this design's there.
You can review the slides later,
but it's lossy, introduces
ambiguities, and it cannot scale
because there is no common domain.
It does not work.
What we do is you have a
domain, I have a domain,
lots of domains, mapping
across domains, that's easy.
And that's what error code does.
So we're gonna map
domain-specific to standard,
and this is kinda the same thing.
This is more detail
with what we just said.
But I have to zip on
'cause I wanna see code.
Domain-specific errors must exist.
They always must exist.
All of our code is domain-specific.
Turns out there are a
lot of domains, who knew?
Translating is lossy, that's hard.
The design of error_code is to say
I do not want to do a lossy operation
until at the point of use.
That's this design.
And that's why all your
APIs will pass error codes.
Error codes are a non-lossy
platform-specific,
this happened with your
network controller.
And then you propagate it up,
and if you wanna do a lossy conversion
at the point of test, you go
to the log file, that's fine.
That's up to you, that's at point of use.
So, many message codes from many domains,
mappin' 'em across different domains.
Even across third party libraries
that you had no knowledge
of at system load.
That's totally fine,
error_code is built to do that.
We wanna preserve context,
and we wanna map and
manipulate across domains.
Now this is surprisingly hard.
How many domains exist and
how do I wanna translate
all the weird things that may happen
with that particular hardware device
up to something that my generic library
can present to the user
in an understandable way?
That mapping, that mapping is work.
That's design work.
It's not &amp;lt;system_error&amp;gt;'s
fault that the design work
has to occur.
We're gonna call that
cross-domain semantic mapping.
Cross-domain semantic mapping is hard.
And that's the heavy lifting.
This is done ultimately
through static type checking
of instance-specific, you'll
pass these through your APIs,
code and condition.
Always error_code, always error_code,
never condition through APIs,
and we'll test against an enum.
And if the enum's a code or condition,
you won't know and won't care.
Okay, so, what is?
It's a little thing.
It's 16 bytes.
It's suspiciously similar to eight bit,
or eight bytes for count
and eight bytes for pointer.
It kinda looks like that.
There's sort of this associated state
with an error instance.
You get an error code,
you test it against enums.
That's all you're gonna do.
If you want the string, ask
for the string out of it.
It'll give it to you.
The string's not actually
in that little instance.
It's in your category,
it's in the context,
it's hidden from you.
So the domain-and-ID is the error_code.
This is the API of error_code.
It looks a lot like the
API for error_condition.
What can you do?
Well, you can get the integer out of it,
which is an enum, ultimately.
You can get the string message out of it.
And you can clear it.
You can test it for do
you have state or not?
That's the operative Bool.
And you can get its parent category.
Probably don't care about that
unless you're a library author.
You may care about that.
Users don't care about any of this.
Users will test against
an enum, that's it.
That's all they'll do,
but the library author,
this is the state that
you have, and ultimately,
it's a lightweight handle
into the error category
actually giving you the string state.
So you're gonna take the
category, derive your own
process level singleton.
It doesn't actually have to
be that, but out of the box,
it's easiest to do that.
And you're gonna stick
your enums and strings
inside your category that's derived.
So this is kind of the same thing.
We already have a few
categories given to us.
You can have as many domains as you want.
They're all gonna derive
from error_category.
So here's code, this is normal.
I'll create an error_code and
I'll pass it into a function
to be populated on the left.
Or, I'll just call a
function which returns one
by value on the right.
Totally fine, both those
patterns are widespread uses.
This would be typical.
So error_code, lightweight
value semantics instance.
It's a handle to something,
but it's basically got an enum in there.
You're gonna test against
some kind of enum.
In this case, we're
doing a POSIX conversion,
we're using that operator Bool.
So, hey ec, you have something in you.
Now it could be all kinds of stuff.
Maybe you say, yeah,
I totally started that
asynchronous process just fine.
That's not actually an error.
It's just saying whether or
not there's a payload in there.
Now I find it's interesting
to test against the Bool,
but a lot of times you'll
actually wanna test it
discretely against an enum,
that's gonna be the next slide.
So this is just a value semantic
lightweight little thing.
They're little, they're fast.
This is why.
This slide is all users have to know.
If you forget everything
else, blah blah blah, stuff,
this slide is the slide.
This is all you need to know.
You will create one.
You will maybe get it
populated through a function
or populate it yourself, who knows?
And then you're gonna test
against an enum, that's it.
And as long as the library
author did their job,
that'll work.
And it's not a hard job to
do, we'll zoom through that.
But what's interesting here is
not every error is an error.
This is informed context
back to the caller
that something was populated because yeah,
I hit a decision point, I
have information for you,
I failed to create that directory.
I am so sorry I failed to
create the directory, why?
Because the directory was already there.
Well, I just want the
directory to be there.
This is not really an error.
You know, I'm fine, I just
wanted it to be there.
So in this case here, we have
an optimistic scenario where
as long as you created
it, or the error was,
it was already there, okay,
well then I can continue on.
This is conditional branch logic based on
communication from the caller.
But all we're doing, that's it.
Ec double equals some enum.
Or you could've said ec is
assigned a value of some enum.
And that's it, that's all we're gonna do.
So there are are standard
error category stuff
all out of the box, ready to
go, they're in the standard.
The error_code's historical,
I'm gonna skip through this.
The condition, this is
a domain context thing.
The slides are free,
they're gonna be online.
So you can read them at your peril,
but we're running out of time.
We're gonna map across, through stuff,
but ultimately what
I'm trying to get to is
the simple way, this is me being cute.
This says use enums,
is all that slide said.
Library author, this is not hard.
You're going to make an
enum by define the enum,
write a switch, and sort
of lightweight template
metaprogramming which you can copy paste.
This is 15 minutes a job.
This is what the library author does.
So most people are not library
authors, they don't care.
So the standard use is strong enums.
Asio's using weak enums
'cause they're trying to be
backwards compatible low three.
Use whatever you want,
but both those work.
Your enum is a placeholder
for error_condition constants,
and you're just gonna test against it.
If this error code that
I received from somebody
is that scenario,
and the library author is
going to define the enum,
overload some decision about
I'm a code or a condition.
Almost always, well, the guidelines here,
it's a little arm wavy,
but if you're doing
platform-specific stuff
with your hardware-specific
controller, it's an error_code.
Otherwise it's an error_condition.
When in doubt, just use error_code.
Derive from error_category and
you got a couple overrides.
So given your enum, what string
would you like to return?
That's it, that's not hard to do.
It's often done in a switch.
Given your enum, what string
would you like to return?
That string happens to
be, it's passed by value.
We're returning a whole value string back.
So if you wanted to do a
locale-specific translation
or if you wanted to pull other contexts
from the environment,
put timestamps in there.
The API is conducive to that.
You can access it, so this
is library author step four.
We're gonna get our singleton.
And now you can just get it.
It's just sort of an identity thing
where the address of it
exists in the same process.
Define the factory functions.
These are well known.
And this is not hard.
Anything that can be converted to an int,
and referenced through a domain,
that goes into error_code.
So C errors go in, information
for other processes go in.
As long as you convert it
to an int and a reference to
an error category,
you've got an error code.
So make one, make the other.
There's some overriding of equivalence
and getting of default stuff.
This is what the library author can do.
This is optional, you
don't have to do this.
But this is where the author can say,
look, I got a lotta domain-specific enums,
but you know what, a
lot of these kinda map
to the POSIX enums, you
know, the standard enums?
So this is your opportunity
to kind of map your enums
to the POSIX enums.
Now you can test your failure
scenarios with the POSIX ones.
You know, back and forth.
That's if the library
author wants to do that.
This is cross-domain semantic mapping.
This is design activity.
You have to define your
enums, and you have to define
their mapping, if there is any mapping,
to these other domains.
That's the heavy lifting,
that's the hard job.
And this is just the easiest library
that's standard to give you that.
And that's it.
So that's library author.
Seven steps, one of which is profit.
The one prior six is optional,
so there's really only a few steps.
It's only 15 minutes to make one.
Welcome user.
Oh, so library author.
Anything that can be converted to an int
and a reference to a domain
is an error_code, anything.
So you can make error codes
with an int and a reference
to an error category.
That's really, really simple.
And there's a lot of
mischief you can do with it.
So users, users just need
to know enums, that's it.
I can read and see the enums
that might be handed to me
so that you can put them in
your code, and write an if.
That's it, that's all users should know.
They shouldn't know any of this stuff.
They should use enums.
And ...
This is kinda how and why it works.
This is the type traits
template metaprogramming
design feature that is error_code.
So I have an enum, and given an enum,
I know what its type is.
Its type is whatever enum type it is.
Well, that type can have
traits associated with it,
and that's the mapping.
That's why it works.
Given an enum, I already
know the category.
The attribute for this enum
is it belongs to that category
there, that domain there.
So that's why we just
use enums in our code.
So this is, if you're a template meta guy,
that's really why it works and this is,
in this day and age, really
simple metaprogramming.
So users, this is it.
You're gonna get one populated,
you're gonna test an enum.
That's it, that's all users
should be doing, nothing else.
They can populate 'em.
Users can just populate error codes too.
If you have an enum, just
throw it in the error code
and hand it back to somebody or return it.
So you can return 'em
and populate by value,
or you can throw.
And there's our explicit
conversion, but that's it.
This is all the code we would write.
And so, now there's more
stuff associated with it.
You're gonna wanna test explicitly.
You're not gonna wanna
put 'em in a switch.
And mapping across domains,
this is the library developer thing.
And I'm just gonna kinda go
through this very quickly,
but the original context is preserved.
Error_code is a non-lossy
platform-specific payload
of what specifically
occurred in non-lossy way.
That propagates across
all the APIs you have
into a third party library
and all the way down
for somebody to handle.
And if they wanna test
it at that point of use,
as an error condition or
something, that's at point of use.
That's number two.
But mapping across domains
is the library author's job.
That's basically what we do.
That's the design.
It's a simple design.
It's the handle-in-context design
and we're already using it.
So library authors, they
really have the hard job.
What're your domains?
Gonna define enums for 'em.
That at lease serves as documentation.
And do that mapping.
Users, they use enums.
They don't have to know anything.
They shouldn't know anything.
And you can define an error
code in like 10 minutes.
Users, you know, zero minutes.
They just have enums, they just use them.
So, many domains are
interesting, domains overlap,
mapping across domains is this design.
The error code is a type erased
platform-specific payload.
The type erasure is
because it's referencing
the error category, which
is an abstract base class.
That's the type of erasure
that allows error code to work.
So this is equivalence.
Oh, I'll just say here real quick.
There's more and I'm
not too worried about it
because there's some
really good blog posts by
Chris Kohlhoff and others online
that I'm gonna point you to in a second,
but this comparing of
error code and condition
is an equivalence comparison.
And that's part of their design.
That's the static type
checking the compiler's doing.
I can map any errors, any
enums I want from any domain
into an error_code.
And I can compare that
against any other domain.
And it'll just work, as
long as the library author
did that enum mapping, we're good to go.
And so here would be an example of it.
I have a lot of things that
may actually have occurred.
But you know I'm gonna raise
it to a higher order and say,
there's this kind of domain
where I just wanna know
is it low system resources.
And if any of those errors occurred,
that equivalence to low system
resources will return true.
This is really powerful.
This is a multi-state,
many-to-many state reduction
opportunity, and this is
up to the library author
to design that.
This is overloading equivalence
and this is a platform-specific mapping.
I'm not gonna do it because
you can do the slides online.
There are examples, blog
posts on doing this, but
you can do your cross-domain mapping
in a platform-specific way.
That's this slide.
The link in the corner
is Chris Kohlhoff's blog
that talks about this.
And here's a platform-independent way
to do a cross-domain mapping.
So these are common ways
to do platform-specific
domain mapping and
platform-independent domain mapping
across your domain boundaries.
So, review.
Error_category, error_code,
error_condition.
Users don't need to know any of these.
They're gonna receive error codes.
Always APIs will use error codes.
That's all users need to know,
they'll test against enums, that's it.
Library authors may care about
I derive from category,
I populate error codes,
but I provide users error
condition enumerations.
That's what a library author would care.
If you wanna throw one, no
problem, that's just an error.
You just throw it.
Throwing a std: :error_code will give you
the &amp;lt;system_error&amp;gt; you can catch later.
And the errc POSIX stuff is
ready to go out of the box.
So for users, all you're gonna
do is test against enums.
It can't be constexpr, I
think that can be fixed,
but as it stands now,
it's not a constexpr thing
because the way it's
implemented with error category.
For library authors, this
is all you're gonna do.
You're just gonna pick, am
I a code or a condition?
Just pick code, it doesn't matter,
pick condition, who cares?
And then derive your
domain, access your domain.
And that goes back to
the academic thing of
are you platform-specific
or platform-independent
is the distinction.
But this is it, this is like 10 minutes.
And then you gotta know domain.
And the cross-domain mapping is free.
API-type erasure.
So here's the blog posts,
posted stuff by Chris.
API design, and this is
basically stuff you're gonna know
already, but the power
of enum, it's not just
that it's enum and it gives
you file type type safety,
which is way cool, it's documentation.
These are the discrete things.
And now I've told users what
the discrete things are,
and it's documentation, really valuable.
But your APIs will use error_code.
They will not pass error_condition.
Always prefer error_code.
You can serialize to error_code.
You cannot serialize error_condition.
It gets upset if you try to
serialize error_condition.
Just don't use error_condition,
just use error_code.
Error_code!
Did you hear error_code?
So API should use error_code,
see rule number one.
Don't use error_condition, not hard.
So APIs, error_code.
But wait, don't forget.
Your APIs should use
error_code, not error_condition.
This was an example of why you would
wanna use error_condition.
It's kind of academically interesting,
but it's not practical.
The code you're gonna write,
you're probably not gonna,
you're gonna return by value.
These are lightweight
handles, they're little.
So you're gonna pass them to be populated,
you'll return them by value.
You can throw if you want.
And callback, same thing, now.
Asio tends to pass by reference
when they're read only.
And other people do 'em by value.
There's a debate on that.
And there's all kinds of
opportunities for putting
in sites, std: :optionals
and other things.
So, we're done, but use enum says that.
Error_code and condition,
error_code, don't use
error_condition.
Category defines a domain,
the domain is your enums.
And each module, each subsystem.
Many domains are probably
gonna be what you end up.
You can have one big one if you want, but
we tend to break out many.
And system category, it's
ready to go right now!
All the POSIX stuff, just use
'em, pass 'em, return 'em,
populate 'em, test against 'em.
They work, we kinda know what they are.
It's not the universal
domain, it's a domain that's
establishing common scenarios
that we can all share.
And this is kind of,
the enums are doing our
template metaprogramming
type promotion to get the
association of the magic
cross-domain semantic mapping stuff.
So that's it as a user,
you're just using enums.
Strong enums, weak enums, any enums.
You don't have to use enums, use enums.
It's just easier.
So converting enums to std: :error_code.
And then, so I really am done.
Don't write bad messages,
do write good messages.
This is kinda like public service stuff.
Content, this is what
a message looks like.
Where it came from, what occurred,
how the system responded,
what the user should do.
That's what a message should look like.
These are good messages,
but talk about that.
So I'm done, so thank you to these people.
There's a lotta offline
kinda discussion on stuff.
And what're your thoughts?
Oh wait, should you use error_code?
Yes.
'Kay, and nobody needs to know
anything beyond enums really,
except the library author
who does 10 minutes of
copy paste, and then
now you got a big enum
that just keeps growing, and that's it.
This is like brain dead, the
easiest best you're ever gonna
get for establishing
common error interchange.
So, prior to this, we didn't
have a way to interchange.
Now we have stable ABIs, APIs and BIs.
So you don't even have to recompile.
You can dynamically load in modules
that have their own
domains, not even recompile.
It's just a run time load
and everything works.
'cause the type erasure is
through std: :error_category.
So you can write your own,
and what they were writing
part of this was basically this.
That's why they standardize it.
So, pretty straightforward.
Anybody using it now, error_code?
Yeah, it's in the file
system networking TS, so.
Okay, there's a few.
I know we're kinda tight on time,
so anybody have any questions or comments?
Yes?
- Quick one.
It's actually bit of a technical question.
Halfway through, you were checking
the Boolean state of error_code.
What semantic do you see from
the Boolean state of the error code?
- Yeah, there's a debate on that.
I'm in the camp where the
Boolean state is not helpful.
So a zero value, a default constructed
or one that was explicitly cleared,
that'll have the value
zero so if Boolean test,
it'll return false.
I don't have any state.
It's ambiguous as to whether
or not I called a function
who said everything is
good, and they populated it
with something that's not zero,
but I started the asynchronous process,
I successfully closed that
handle, whatever it is.
'Cause an error doesn't mean an error.
It just means this scenario
is information to the user.
So I would recommend.
You can do the if test ec,
if you wanna then decide whether or not
you wanna discretely run 'em.
But that's all it would tell you.
It won't tell you
whether it's good or bad.
It just tells you whether or
not there's payload in there.
So I tend to not use the if Boolean test.
But that's a pointed debate.
It is relatively new.
We're still kinda working on
the paradigm for composition.
- As usual, is this working?
Testing.
Oh, as usual, it's an awesome
talk and I loved the pictures.
So there's only one fundamental
question I have to ask.
If what you're trying to
do is present something
to people so they
understand what's going on,
and if they can map onto
the message that they get
what's actually going on
in the code, this is great.
The problem is, that I see, is that
you can have a fixed
number of error codes.
And in fact, a long time
ago, I thought about this
because you put all those
error codes at the bottom
of the system and say,
here's my slowly growing set
of enumerated error codes.
And then you go, wait a minute,
I don't have the right one.
I'm gonna make another one.
You add another one.
The system gets larger
and larger and larger.
And of course these error codes
are compiled into everything.
And then one fine day,
you go, you know what?
That's not quite the right message.
It's almost right, you know what?
I don't wanna recompile the
world, we'll use that one.
And then things start to go south.
And then eventually you say you know what?
I'm just gonna say error
because I don't have a code for that
and I'm just gonna use that
and that's when things
have gone way too far.
So the thing that I'm wrestling with is
I like all of this, I think it's great.
It does what you want it to do,
but the tension is when you're
dealing with a function,
there are typically two
or three or four maybe,
five ways that you could
respond to the different kinds
of things that can go wrong.
It either worked or it didn't work.
And if it didn't work, there
are five different things,
but naming them and saying
this is a read error,
this is a write error, whatever,
has to be filtered through
every human's brain
and come out the other side.
And I would beg you that
if we apply that test
to everybody in this room,
it will not be the same enum
that comes out every time.
And that is my biggest concern
and that whole long preface is.
At the other side of the point,
when you have an individual function,
somewhere in the
documentation it has to say,
here are the four flow of control points
that I am going to, as the
author of the function,
knock this name which is a
pure pneumonic onto this branch
that the person will take.
And my question is how do
you resolve what I just said,
which was long winded, with
this wonderful presentation
that does the other side
essentially perfect?
- Yeah, I think that's
an excellent observation,
and if I could kind of
summarize your summary
and see if it maps.
There is a problem with
error code curation.
The curating of
ever-growing piles of stuff
is like the curating of
ever-growing piles of stuff
in a museum.
You have to manage 'em and
redefine them and reclass them.
And that's a maintenance point.
It gets too big and it becomes unwieldy
and then people just pick
what they think is closest.
That's problematic.
The error_code design is
encouraging you to create
new domains when you have these
new localized reason context things.
And it handles the
cross-domain semantic mapping.
But your other point, which
is an excellent point, is
you called me and I'm telling
you this is what I saw,
and for me, my function,
there's only four things,
and it's one of these four.
And if you are very
discretely representing,
in the documentation of the function,
here's how I communicate to the caller
which of the four it is,
you could've had a
domain, an error category,
with those four things,
but you didn't have to.
You could just do an
int or something else.
And that's discrete.
That makes curation easier
'cause your curation
is only for that function.
But the interoperability,
it is now not comparable
to a POSIX error code or
Asio or other domain stuff,
so if you have an error
scenario that's basically saying
disk is full and you have
defined your own local
disk is full, you didn't do the mapping
to the standard version of disk is full.
If that mapping was important,
error_code is useful.
If it's not, that local
reasoning, I think,
is easier to maintain.
- So the quick followup,
to make this all work.
All you have to do in
your function level doc
is say, here's my world,
here are the four things
that can happen and I as the author
have chosen the pneumonic
this, this, this, and this.
And if you get it wrong, it doesn't matter
because that thing maps onto
this thing, and that's a fact.
- Right, yeah, and then the user,
if they wanna do the
mapping, they can take that
discrete, well-understood thing,
and they can map it themselves.
I think that's an excellent observation
because what is not on here,
and I know you guys wanna go,
but error code curation is its own world.
And that's a big discipline
like all code maintenance is.
So this doesn't solve that.
This just gives you an easy
way to make a new domain
that happens to be
mappable to other domains.
- So I just wanted to ask
how well does this handle
many, many, many different error domains?
- Yeah.
- Let's say I had an enum per function,
if we take your example to its logical,
ridiculous conclusion.
And then provided mapping
is between all of these
to like standard error
codes, so that I can somehow
have the users have help in
the Monix and things like that.
But I can reconfigure them
later with stable ABI.
How well does the system handle that?
Like is it built for that?
- Yeah, there are two answers.
The first one is, it handles it great.
If you have a thousand domains,
they're all type erased to error_code
and they're all handled perfectly.
They're all dynamically
loaded, and they all
interoperate just fine.
So on the mechanical, stable
API, ABI-level, you're good.
What's not good is I'm writing a domain
and I don't know all the
other domains that may exist.
And the cheater's approach,
which is a pretty good approach,
and don't knock the cheater's approach, is
I can basically map my
stuff to the POSIX ones,
'cause those are kinda understood.
It's lossy, but once I do that mapping,
I know everybody else knows
what the POSIX ones are.
So as the long as the domain
author does that mapping,
you can kind of be blissfully ignorant
of the other domains out there.
And what'll tend to happen is
some domains will organically grow.
Asio is a networking TS kind of problem.
They have networking domain kinds of codes
at a much richer level or different level
than the POSIX ones.
So mapping to the POSIX,
well, if I'm actually writing
another networky kind of thing,
it could be I'm better
off on mapping sort of
the Asio organically understood ones
and that's a gateway into
other domain mapping.
And the goal would be
equivalence just works
as long as every author maps
to something that's relevant,
like I'm mapping to networking
or I'm mapping to POSIX
or I'm mapping to my
industry's pile of kind of
commonly seen errors.
That's the localized reasoning
that the library author
is supposed to be able to rely upon.
You're not gonna map
to a thousand domains.
That's insane, you
can't, it's not possible.
But you should probably
map organically to some
common, interchangey ones.
Which is all the POSIX one is.
It's sort of an interchangey.
It's not the standard one,
it's a common interchangey one.
- Okay, I have a followup.
How big are these singletons
that exist for each process?
- Oh, it'll be, well it'll
be compiler dependent,
but it's gonna be static data.
If you wanna do the minimum,
it's all static data
and it's your string table,
and whatever the
representation is for the enum,
which is probably nothing.
- All right, so how do
you get a new pointer
out of every enum if you
don't have any strings?
- Oh, the error category is a singleton.
The static linker will establish
its placement in memory
in some one and only one place.
- Is this system amenable
to error hierarchies?
For example, suppose a company
has a bunch of error codes
that all projects in the company use,
but then each project has
some error codes of its own
that have meaning only
within that project?
- Yes, that's a really good observation
and that's the trick of enums.
So you can locally just say
I have a bunch of domains
and you establish the mapping,
but in the hierarchy approach,
the trick with the enum is
this section of enums is kinda
mapped to that other enum
that's already defined.
And you're kind of establishing
an inheritance hierarchy
of enumerated state.
So because it's just enums,
it lends well to enumish inheritance.
Yes.
Anything else?
Thank you guys for coming!
(audience applauding)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>