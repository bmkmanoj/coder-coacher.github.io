<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Matt Hargett “Advanced Unit Testing in C &amp; C++” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Matt Hargett “Advanced Unit Testing in C &amp; C++” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Matt Hargett “Advanced Unit Testing in C &amp; C++”</b></h2><h5 class="post__date">2015-10-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Wmy6g-aVgZI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello um Matt Hargett and some of you
may have gone to my talk at CPP con last
year about unit testing and I just want
to start by saying thank you to all the
people who like either we're here last
year or saw the video on YouTube or
wherever else it is and stuff like that
and send me lots of nice notes over the
last year and asked lots of follow-up
questions and stuff like that I did like
some remote pair programming with some
people who like needed some help with
their specific code I was happy to to do
that so thanks to everybody for the warm
reception and for reaching out so maybe
some of the new attendees this year will
will do the same so this is a this is
kind of a part two to the talk last year
and if you didn't see the talk last year
that's fine I'm going to do a speedrun
through extreme basics but if you didn't
see the talk the 2014 CPP con talk
whether you're here or you're watching
it later on YouTube or whatever you
should probably watch that one first you
can watch it at 1.5 speed or 2x or
whatever you can hear the Chipmunks talk
about you know testing but one of the
pieces of feedback I got is that the
talk last year was a little too
high-level focused too much on the
selling points of unit testing rather
than the technical point of unit testing
so this year we're going to talk about
some more technical point of view no
testing and some of the difficulties
with deep difficulties with real-world
unit testing so without further ado so
though there's a couple things I'm gonna
repeat from the first from the talk from
last year so the only reason to do unit
testing is for a sustainable competitive
business advantage a lot of people come
at unit testing or any kind of testing
from this kind of warm happy fuzzy
quality place well the reason quality is
important is purely for business reasons
right so that your customers are happy
so your developers are working
efficiently so that you have a smaller
small QA team and you can spend you
spending two million dollars on an
extended QA team you can spend that
money on other stuff so in my experience
unit testing is the most reliable route
to a modular / object-oriented design
some people will still have an allergy
to the term object-oriented for some
reason probably not as heat BP Khan but
if you don't like that term you can just
say modular so the the reason why is
because to do really unit testing you
have to be able to isolate each of the
kind of behavioral modules in your
system whether those are classes in a
cpp for a single class in a single CPP
file or a C file that that defines some
module for whatever it does that has a
single responsibility and complies with
other kind of principles even if you're
in C single responsibility principle
still applies at the module level or if
you don't have the source code if you're
just dealing with here's a binary code
file and that's all and you don't have
the source code for it
for some reason because you have to be
able to your testing so you really have
to pull those things apart and get them
super isolated so that you can do proper
unit testing on them mock out their
collaborators and do what you have to do
to get down each of the kind of deep
branches in that module you basically
have to be relatively compliant with
just about every object-oriented
principle and here I'm talking about the
solidus single responsibility principle
open-closed principle this cop
substitution principle etc etc and so
unit testing is kind of the proof that
you're complying with those things
because if the if testing is difficult
for some reason and we'll go through
some examples of where testing can be
difficult chances are you have some
encapsulation violation or something
like that then that's the reason why the
testing is difficult and then the last
thing is that there's a way to do unit
testing in a team or an organisation
full full of teams
where it will very quickly start to not
pay for itself and so focusing on the
ease of consumption of those tests and
the maintenance of those ongoing
maintenance of those tests is key so the
way that I think about this is developer
kind of user experience like what's the
developer experience like even if even
if you are a team who's not publishing
api's I don't mean like what's it like
to program to that REST API I mean what
does it like to live and breathe in your
codebase and work with your team and
there's a whole lifecycle here with
regards to not just your implementation
code but your test code is it easy to
read is it to write is it easy to build
and is easy to debug and if you do you
know two of those things but you don't
do the other two you aren't capturing
the whole kind of lifecycle of what the
developer experience is like and so if
you're right a whole lot of tests that
nobody can read tests that are like you
know 5,000 lines long a piece or
something like that or it's hard to
write tests because every time you add a
test some other test fails because you
have global state or other kind of kind
of kinds of transitive problems or if
the tests are really slow to build so
people don't build them if they don't
build them they can't run them or if the
tests are hard to debug the test fails
and then it you know takes like a day in
gdb stepping through stuff to figure out
what went wrong those are all ways that
you can get an initial start with unit
testing and be doing think you're doing
a good job and then it will fall down as
you try to scale it out to the rest of
your team if you have a large team or
the rest of your org if you have small
teams in a large org it's important just
to take care of that stuff upfront
because if your unit testing is
successful and it's finding bugs or
preventing bugs for being introduced and
all that stuff and people start to have
a quick uptake on it if you aren't ready
for that uptake you could have just like
been like hey you know testing is great
and then it just completely falls over
because it doesn't scale and I ask
people think about these things upfront
because I like to see in a testing
succeed in organizations over the longer
term so here's the agenda brief
refresher I'm gonna go through it very
very fast
and then I'm gonna talk about four
different areas
we're in real teams and real projects
with real ship with real shipping
product three or four areas where I've
seen where it actually required some
real engineering kind of problem-solving
to figure out how do we test this where
it's not just brain-dead easy and it's
not the design problems that I talked
about in last year's talk last year I
talked about when implementations are in
header files or you have template
classes or other kinds of obstructions
that make it make things difficult to
test and how to fix up I talked about
that last year not gonna I'm not gonna
talk about those this year but there are
some some kind of unique problems that
I'm happy to share partial solutions or
summarized solutions so the first one is
unit testing kernel code specifically
unit testing kernel code and I'm talking
Linux kernel here but the same kind of
thing could apply to Q and X or whatever
whatever proprietary operating system
you happen to be using testing that
kernel code in user land and so you know
to inject a unit testing framework into
the kernel to get things to work
mocking standard library functions you
know basically like how do i how do i
mock out receive and send and low-level
lib see kind of i/o calls mocking with
Singleton's and factories which i
touched on one aspect of last year but
the follow-up questions that I got via
people sending me messages on LinkedIn
or Twitter or whatever in an email
illuminate for me that I left out an
important mmm an important deeper detail
of that that we're going to talk about
and then the last thing is is excuse me
framework customization of assertions or
constraints and reporters there's kind
of kind of you know the previous slide I
talked about you know the reading the
writing the
was it reading reading writing building
and debugging of unit tests and there's
other kind of some finer points of
making sure you have a deployment of a
unit testing framework if you're in a
large team or in a large ordered with
lots of small teams that if you're all
going to be on the same framework you
should keep in mind so you don't hit
deployment problems which I'll go into
so like I did last year for the
multitaskers I realize in the modern day
of conference presentations that people
are on their laptops or the tablets or
their cyborg implant devices or whatever
while I'm talking and I have made my
peace with that
so so if you didn't see the talk last
year or you did but you need a refresher
anyway you can go to those URLs and you
can read a little bit about sea greenery
a little bit of about mockito PP those
are the two frameworks that my code is
going to be my sample code is going to
be in if you want to just do that in
parallel with me talking or not
undivided attention is great to remember
the good old days so and you can just
search for YouTube on YouTube for
practical unit testing and C++ and the
CPP Khan YouTube channel and you can
find it don't watch the video on talking
but that's that's not the multitasking
thing I want you to do but the link is
here and when I give the guys the
presentation and they put it up on the
website or whatever they do that link is
right there so you can just click on it
so here's the refresher so the entry
points unit testing for me in any any
team or company or whatever is what was
the last major bug that you had that
especially bugs that got deployed to
customers or got out into the field
somehow right because those are the bugs
that got passed all of your other safety
nuts they got past your QA or static
analysis your code reviews your bla bla
bla bla bla right so if it got past all
of your safety nets assuming you have
this
series of safety nets let's be
optimistic and assume that you do you
know those bugs I get out to the field
they're so expensive to fix you have to
fix it and then deploy a fix and if that
fix then introduces more problems and
you're in a world of pain so so those
are the kinds of pains and costs where
it's like okay let's introduce unit
testing it's not completely automated
like we have to actually think about the
tests that we're writing and so people
go well we don't have time to write
tests and it's like well you're gonna
have time to write tests but you do have
time to like do like emergency deploys
to the field for the customer of three
o'clock in the morning I don't
understand that I mean everybody has
their preferences on how they like to
spend their time at 3 a.m. I'd rather
write a unit test at 3 p.m. then wake up
at 3 a.m. to do an emergency B debug
session on a live piece of hardware so
so here's a here's a condensed example
from a real a real product that I worked
on so the bug report says that there's a
crash when some device is missing how do
we test regardless of the hardware right
because for unit testing we want to test
the code that we're writing in our
development environment right not on the
board not on the appliance or whatever
you can test there too and you should
test there too but the first the first
thing we want to do is make sure that
the code that I wrote is what I intended
it does what I intended it to do not we
got not accounting for on the target
board the compiler that you're using is
going to have a wrong code bug that yes
all that does happen and that's why
integration test and system tests are
good and you should do those too
but for unit level testing we want to be
in the development environment so I can
build run modify build run modify build
run modify in a very very tight loop if
I have to upload to some embedded device
on a 9600 bps UART every single time I
make a modification I'm going to batch
up my modifications have more
modifications every time I upload the
firmware image which means that there's
gonna be more mistakes potentially so
when something does go wrong I have a
larger diff to look through and that
gets in the way of me being a productive
developer so how do we test regardless
of the hardware and I it's big enough I
think it's big enough
for you guys anyway so here's a here's a
small code example regarding PCI devices
and so let's pretend like this is the
implementation source file broadcast dot
see the names may have been changed to
protect the innocent so what we want to
do is that we want to stub out the
collaborators so how do we find out what
those collaborators are well one thing
that we we know what the function name
is so in our main we declare that at the
top because in the legacy code unless in
a legacy code base just pound including
one file can sometimes just bring in a
whole world of crap of static
constructors and macros with weird names
and no namespaces and stuff like that so
when I'm unit testing a brand new system
I like to just here's the function I
want I just want to take the dot o that
contains that function and include is a
few header files as I possibly can so we
declared at the top if the header files
are all fine and you can pan include
them great but if you can't because they
complicate things
then don't and then I just have an int
main I'm not using a test framework here
yet I said an int main my neck I'll get
broadcast ID from network which was the
function on the previous page and as had
to return zero so I go to compile that
and it says hey there's an undefined
reference to PCI fine device and device
read packet this is what Michael
feathers in his book working effectively
with legacy code which I hope they have
at the table excellent this what he
calls leaning on the compiler or leaning
on the tool chain right just like follow
the error messages and that's great it
can be actually quite idiomatic and this
anyway it can be quite idiomatic
which is also tedious potentially
depending on how many error messages
that you have but in this case we have
to it can't find those two things so I'm
gonna make another file where I'm going
to stub out those things I'm going to
call it a PCI mock so I make a PCI dead
struct and
make a PCI fine device and I'm just
gonna return null right I'm just trying
to get it to link before I get it to run
right and just deal with one thing at a
time right so okay we get it - we put
our stubs in place we get it to compile
it links we go to run it right and the
bug was at it crashes than the device as
a present so we expect a crash right but
is this the right crash is this the
crash that we actually expected to
happen so and what if we need to like
stub different values like we just made
excuse me our implementation of that
function that stub just returned null
but what happens if we need to return
not null or have a series of return
values like I want to return something
good something good something good
something bad so we need something
smarter than stubs which is mocks so we
want to use mocks when we need to have a
different return value each time the
mock is called on a / function if we're
talking about C or global functions or
per instance if we're talking about
object instances in C++ we need to do
that so we can exercise robust code
paths right and the the background I I
really come from on this is like parsing
binary networking protocols where
especially if someone is trying to
attack your protocol stack they are
going to be messing with sending you
messed up packets right and instead of
just sending you like the first packet
like the beginning of the handshake
being messed up the real good bugs are
underneath all of that right where it's
like I get so far into the IPSec or the
Ike negotiation and then it's like on
packet number 18 into the handshake I
introduce some kind of funky packet that
causes a buffer overflow or some other
kind of bug so we want to be able to
exercise those robust code pads in these
kind of critical systems and we want to
do that without too much maintenance
overhead right we don't want to have
like a different like link time mock we
don't have like mock PCI that returns
one dot see mock PCI that returns to dot
C mock PCI like that's ridiculous
so it's ridiculous because of the amount
of maintenance overhead where if I
changed
that function I have to now go edit
however many files so don't that want
that to happen and what would be really
swell Anais is if that specification of
like return this return this return this
return this that sequence of return
values and things worth in the scope of
the tests so that I could just look in
one place at the test and see what's
going on so here's an example using AC
green mocks like syntax even though
we're still just in our main function
here so I'm going to be able to write
like expect PCI fine device will return
null expect device get packet will
return null and then I call get
broadcast ID from network so that's cool
because now instead of having to go to
mock PCI Moxie and see what is it what
does that stub return again I don't
remember
oh it returns null I can just see it
right here and if I wanted to return non
null it's all within the scope of that
test it's all within those two curly
braces and this is one of the things
where we're optimizing for readability
for us for our peers or whatever so and
we need we want to prove details of a
fix right so before it was crashing we
don't want it to crash when the device
is a present let's say that let's say
that what we actually expect is that
it'll do a print kay a criminal blog log
print when the device isn't present so
in the second example there I set my
expectations for the collaborators those
two global functions I'm mocking and
then I set an expectation that print K
will be called and in the see green mock
parlance if I set an expectation senton
will be called and I get out of the test
and it wasn't called that as a failure
again I'm going through this very
quickly because I did this this stuff
last year but I didn't want to like go
into this completely cold so so see
green and some of you may notice like
see garena has moved to github so as
machito peepee the other framework which
has really
stated a lot of activity which is great
so all the examples are using C grain C
green is cross language between C and
C++ it's the exact same framework the
exact same syntax where they're using C
or C++ the reason why that was important
to me for the projects I was on is
because all of those projects had
kernel-mode components which were
written in C and then userland
components which were written in C++ and
having two different different
frameworks with completely different
syntaxes and completely different
semantics between those two parts of the
technology stack made the uptake of unit
testing very difficult so C green
basically is kind of one framework to
rule them all across across all of both
of all of those teams they could all
read each other's tests they can all
modify each other's tests and it was
just reduced the kind of beared entry
there the other thing is C green there's
no kind of weird code generators in
between here this is just pure C and C++
there's some macros and stuff but we
tried to keep that to a minimum we tried
to make sure things are names based if
you're using C++ so that everything
plays really nice so so in C green we
say describe whatever the system under
test or the component on your test is
and then we have before each and after
each that's the setup and teardown that
runs before each test and after each
test and then the tests are the tests
are phrase like ensure whatever the
context is in this case TCP parser and
then whatever however you want that to
read it reading is English as a is nice
because you can generate documentation
from it we make a TCP parser and then we
assert that parser underscore read parts
or underscore read when I pass in the
legitimate parser and I passed a null
returns null so cert that parser read
when I pass in parser null is null and
in assert that the parser count when I
pass in the parts pass in the parser
that's hard to say
when I pass in the parser that the
parser count is zero so basically what
it's saying is like oh if I tell you -
if I tell you to parse a read but I give
you an invalid argument don't increase
that parse count that's the behavior
that this test is pinning
so I go to compile that test I go to run
that test and then it fails saying
expected parser count for parser two
equals zero but I got one instead right
I think it's nice about this and this is
that readability piece of this is that I
don't have to set a break point to see
what the return value was I know what it
is the test runner just told me and this
is like the nice thing versus you know
just using like flat out sea level
asserts and stuff like that and and that
little round trip there about what is
what does it like for the developer when
the test fails is a key part of
developer or user experience especially
when you're scaling up an engineering
team or a development team or bringing
in lots of juniors so see green supplies
a mock framework like we talked a little
bit about before and so in the previous
test here nope nevermind so in the so in
this particular thing what we're doing
is that we are gonna mock out the
function called stream read and it
doesn't have to be here in the test file
right it just needs to be there at link
time so that when the consumer of stream
read the consumer of street stream
reidman we're linking it actually gets a
stream read symbol to link to and here
inside of it we're calling the mock
macro of sea greens and the mock macro
takes in the arguments and the argument
name so takes in the names and the
values using some preprocessor magic and
then returns some some value so we're
describing tcp parser the before and
after before each and after each are
empty and we're saying ensure tcp parser
stops reading at the end of the stream
so i make a tcp parser I'm gonna set my
constants end of stream to be negative
one and I'm gonna say expect stream read
so expect that that will be called when
the parameter named input named input is
non null and then I want you to return
end of stream right so what it's saying
is when stream reading it's called I
don't care what the input is as long as
not null and when that happens return
end of stream which in this case is
negative one right and then we call
parser next chunk and the implication
here is that parser next chunk at some
point collaborates with that global
function called stream read and then
write and then we go to run the test and
it says I got more calls than expected
to stream read we only gave it the
expectation it would get called one time
right because if it gets called and then
that returns negative one you shouldn't
get called again you got the end of
stream why are you continuing to you
know why would you continue to call it
so so this is an example of you know
stream read for whatever reason we
wanted to mock it out maybe it had I Oh
in it or it connected to the connected
to the network connected to database did
something computationally expensive who
knows who cares right the main thing
that we're testing here is it is the
interaction right we're not testing
stream read here we're unit testing the
TCP parser and so we're trying to
isolate the TCP parser from its real
collaborators because the more real
actors that you bring in the more real
collaborators you bring into a test the
harder it's going to be to debug the why
to the surface area that you'll have to
debug when something goes wrong and so
by doing these mocks and isolating it
this way we have exactly one file to
look in right which is wherever the TCP
parser object lives our mocks are right
here in the test file we don't go
anywhere to go look for them anything
like that so that's link time mocks with
global functions so what about actual
C++ testing so so there's this other
mock frameworks and I want to like go
into like the pros and cons of each of
them but the one that I recommend and
use is mockito pee pee and basically
with mockito pee pee you can what
mockito pee pee ends up doing underneath
which is like so really just utterly
magical and amazing is it is that it
creates anonymous classes at runtime
based on a pure virtual class that you
give it that's
crux of how it works so here in this
example to have a mouse there a laser
anyway here in this example I have a
struct stream and it has a pure virtual
method on it called read and then in my
C green test I make a mock object of
stream and then I told that mock object
of stream to expect a call to the read
method on stream where the parameter
being passed to it is a zero and I want
you to want it to return zero and
looking at the syntax are like what's
the big deal who cares like yeah it's a
couple lines of code go look at the
implementation for this it's really
really neat Trevor pounds whoo-hoo
authored a mockito PP did a great job
and then so then we need to pull out
that stream type out of the mock so we
say mock stream get instance and that
gives us a stream reference and then we
can pass that into the collaborator in
this case it's TCP parser and then we
call parser next chunk so these are
basically two different examples of two
different examples of the same thing
except in one case we're mocking a
global function and that's what we have
to kind of do our mocks on and and
insert a mock at link time here with C++
and having a pure virtual interface and
stuff we can do that same kind of
composition at runtime where there's
this awesome thing about C++ and objects
so that is the as quick as I could
reasonably make it refresher on the
stuff from last year so now we're going
to get into some deeper topics and I've
hopefully less some time at the end so
that you guys can also just like poke me
in the eye with some really deep hard
questions about like the code you'd like
the own code your own code that you work
on so unit testing kernel code is
difficult because there's obviously ways
you can dynamically load kernel modules
that have unit testing frameworks in
them and load them and unload them and
run them that way
but if something goes wrong you're going
to panic either the VM that you're
running in or your own or your own
machine if you're doing it on your live
machine and not inside of a VM but also
you can't use Val grind you can't use
you know the various address sanitizers
and blah blah blah all the stuff that
built-in the clogging in GCC now either
and so so that kind of demands like okay
we need to bring that stuff into user
land somehow how do we do that because
anybody who has tried and probably a lot
of people here know that if I tried to
compile a kernel mode C file a Linux
kernel C file in user land with a user
land compiler that doesn't work the
kernel has its own idea of certain
symbols certain low-level functions etc
etc so so they just conflict with the
user LAN Lib C so we need to do a couple
of things we need to undefined certain
symbols that are in the kernel headers
that conflict with Lib C whether that's
new Lib G let see whatever you name it
redefine certain things before we
include those kernel headers so that
they don't conflict or so that we can
intercept them we need to supply some
link time mocks for some kernel
functions that are either that or
they're either macros and we don't want
to define the whole macro right in our
you know compiler command line or just
inline functions that aren't macros but
they're inline functions inside of the
kernel header is that thank you that we
need to be able to intercept and things
like that and in a few cases we have to
supply a few alternate data structures
and I don't didn't quite understand why
actually but it's what we ended up
having to do at a company if
years ago to make this work we also need
to use some of the kernel compile flags
but not all of them and I've listed and
listened in here you need data sections
and function sections but you definitely
need to not have the memory model be the
kernel memory model that won't work
super great in user land and I will say
that this is kind of fragile which is
maybe a minor understate understatement
and you may have to tweak your approach
with this every time you do a kernel
upgrade that changes the headers in any
reasonably significant way because
you're really kind of breaking the
encapsulate like you're really trying to
get these kernel headers to do things
that they aren't designed to do and I
don't think it's a design problem
capsulation problem necessarily on the
Linux kernels part that's not I'm not
trying to disparage the Linux kernel or
any other kind of embedded operating
system kernel header files or structure
or anything like that I mean what you're
really doing is you're really breaking
the encapsulation layer is quite
purposefully to try to get kernel code
to run in a way it was not supposed to
so what does that look like and I've put
the more complete thing up at that
github gist so surprisingly you do have
to undef' false and true those
definitions that are in the Linux kernel
handle header files will conflict with
what GCC wants to do with those things
or clang or whatever what to do with
those things undef always in line again
conflict they're changing some of these
functions like and some of these struts
like FD set dev tea timer tea block
count and all these kind of things we're
changing the names of those things so we
can supply an alternate implementation
at link time an effing bool that's right
it's a little mind-blowing to look at
this sometimes and this is cutoff on
mine oh no it's not yeah so various
header files have little things that
will conflict with G Lib C and miss gave
a shout to Alexei who I worked with
at a company a few years ago he you know
the challenge was basically thrown down
where it's like well why can't you just
test Colonel stuff and userland and no
one could articulate in detail why and
he sat down for however many days and
just figured out this header file is
this conflict this fire file is this
conflict this header file is this
conflict it was super tedious but at the
end he was able to do a presentation we
was like we're now testing our kernel
components in user Lane and it's saving
us this much time for each test run
because I won't have to do a bunch of
stuff to get our tests into the kernel
so shout out to him so one thing to note
is that we use the preprocessor that's
pre printed out we use the preprocessor
there to introduce mocks and that's you
got to do what you got to do anybody
who'd watch saw the talk last year I
said that a lot you got to do what you
got to do but preprocessor mocks are not
ideal right and those are also mentioned
in the Michael feathers book working
effectively working effectively with
legacy code and the reason why is
because if in my implementation file I
have to if I have an if death test then
do something else it's no big deal to be
like okay well I'll just you know when
I'm compiling that implementation module
for unit testing purposes I had the dash
D test and that's easy in the bill and
it's easing whatever who cares well the
problem with that is is that you now
can't you're now compiling the same code
twice once for your implementation link
once for your implementation that you're
gonna link it into your final shipping
thing and once for your test and for one
object file that's small who cares but
when you go to when you're when you set
that precedent two things happen one is
one of which is that you get these
weird-ass if that's all throughout a
source file they just clutter up the
whole file I don't like that that's bad
news and impairs readability etc etc but
the other problem the more kind of
operational problem is that if you're
doing that often enough and enough of
your source files you are building
everything twice and if you do this
properly and I'll just be judgmental
properly if you do if you do things
properly
use natural modularity seams at link
time where I can do link time
substitution or at runtime where I have
a pure virtual class or a function
pointer and I can do substitution that
way when you use those seams instead you
compile your implementation module once
and use that implementation module to
link into your shipping code I love that
you're nodding your head by the way you
can use that same object files link into
your shipping code and link into your
unit test harness and I compiled at once
right that's one thing and whether if
you even if I'm using CC cache or just
CC and I just have to speed that stuff
up and you know this is just one of
those death by a thousand cuts things
that's important to get right the first
time but also preprocessor mocks are
often used when you're kind of hacking
around some terrible design problem and
in a legacy system where it's like well
we don't have any tests and we're free
to change anything so we don't want to
make any design changes to introduce
link time seams or runtime seams you can
fall back on preprocessor seems as a way
to get some tests in place so that you
can refactor it to get you know better
more modular scenes in place that's cool
but it's not like oh yeah we have it
some preprocessor seems there's - D you
know test blah blah blah or I renamed a
whole bunch of functions at the
preprocessor level and now I'm going to
enter a bug to go fix it later and I'm
not going to see it for six years
don't do that because those first tests
you're right and the way that you do
that is going to set the precedent for
how people are going to do it in the
future
and if the test is successful and finds
a bug or prevents a bug or whatever and
people go like I'm gonna copy that test
because that's the test that found the
bug if you do a suboptimal job or don't
I don't say that I'm basically if you
don't do things right initially you'll
find that the success unit testing will
fall down pretty quickly because as it
goes out to scale all across a dozen
engineers or a dozen teams or whatever
everybody starts to do the same crappy
stuff that death by a thousand cuts
builds up people go this would know this
would never work and they think its
intrinsic to unit testing so let's see
in this particular case
we have to use preprocessor seems
they're just no getting around it
because we can't read that we use those
object files between the user land
object file we compiled in the kernel
mode object file anyway we have to
compile it twice anyway so so that's why
it's a little it's it's more okay and I
don't know of another way to solve it so
what I would say is avoid preprocessor
seams in most scenarios favor link and
runtime mocking but you got to do what
you got to do realize that we need to
use a preprocessor when you use a
preprocessor seemed to mock stuff and it
has this cost associated with it so next
thing is so mocking standard Lib so in
my experience typically when we when you
want to do this it's not to mock malloc
necessarily that's that's a common
gotcha question people ask me like heavy
a buck malloc smart guy and huh well
there's ways to do I mean I have an
answer I you can and so in in my
experience the real world scenario is
where you do this typically with IO
calls like low-level I like AI calls
like receive F open F close whatever I
wanted a I want to avoid any IO in my
test because any IO is gonna slow
everything way down but also I want to
be able to I want to be able to
basically mock or simulate error
conditions with those IO calls right
where F open doesn't succeed or whatever
but I don't want it to go actually touch
the real filesystem because if I've got
if I've got tests screwing around with a
filesystem
that's effectively global mutable state
and that's bad news for having tests
that are run that run consistently and
all that kind of stuff so so machii-san
your lips so preprocessor injection that
thing that I just said we should try to
avoid it's like well you could you could
and maybe if you're using a compiler
that doesn't have the switch I'm about
to talk about excuse me maybe that's
what you end up doing and there are
worse fates to be sure so what I would
say is favor isolating the system level
interactions and encapsulate those
platform specifics into its own module
and anybody who works on a large enough
codebase has to run on enough machines
and I know the ton of video game
developers here and everybody has their
own cross-platform kind of like
encapsulation layer or and stuff like
that for every majors studio anyway so
most people do this already but if you
get all those low-level kind of platform
specific interactions in this case
platform specific being POSIX ECE kind
of stuff into its own module then we can
take that one module that's the only
module that calls receive directly or
that calls F open directly or that calls
the F Locker lock F I programmed in
hp-ux 9 a long time ago and it wasn't
POSIX compliant and so it was flipped
one way now I can never remember which
way it is in actual POSIX but anyway all
those low-level calls are then in that
one module so we're gonna put those
tests into their own binary and once
they're in their own binary we can
compile those tests with a flag - no
standard Lib so when you use GCC or
clang and you don't specify it to link
against anything it's actually
implicitly linking against a set of
stuff that you're probably gonna use Lib
C being one of them some math stuff
being enough being another one and and
the networking libraries and stuff like
that so when you specify - no standard
live you're saying don't do anything for
me and that means that you may need to
not May you will need to bring in
individual things that you need and I'm
gonna show an example of this in a
second
and for some compilers you may also need
to disable intrinsics if if you have a
weird custom tool chain for a weird
custom embedded thing and they didn't
want to make in lines in a header file
and so they made intrinsic that do i/o
stuff and not just math e stuff
you may need to disable intrinsics I saw
it happen one time so here's our
implementation and here's the test that
we want to write so on the Left we have
a socket stream class it has a method on
it called listen that calls receive on
the right hand side we have our test a
see green test we describe Saka stream
blah blah blah
we want to ensure socket stream calls
the platform receive when listening a
very basic test to be to be sure so I
make my socket stream and I say expect
receive when socket is non null I just
cared that it's called with a non null
socket I could do some more checking
there potentially and then I call socket
stream not listen and just to reiterate
one more time if it gets to the end of
that test and receive isn't called
I set the expectation it would be called
if it's not called the test will fail
and I'll say hey this thing that you
said you said an expectation for wasn't
called so what does our receive mock
look like right so this is what our
receive mock looks like we include sis
socket H we're still using the same
header file under the presumption that
the implementation for receive is an
inline in the header file which it's not
on the platforms that I have worked on I
include the Seagram ox I uses the
namespace C green and I have my own
implementation of receive here that
calls the C green mock macro and passes
in all the arguments and does all that
jazz so then I'm going to is a big one
so you know how this reads up there so
then i say g + + - no standard lib i
give it the include path to the C green
C green includes I'm compiling receive
mock I'm compiling my socket test
I'm statically linking against Lib C
green a I'm compiling a shared library
because that's how I do my test and see
green and I'm gonna output that a socket
test s oh and then we get just ton
of linker errors as far as the eye can
see and oh my god put the gun in my
mouth now what am I going to do forget
testing you forget C green I hate the
universe
thank you so here's and I think I said
this last year too
when you're especially when you're
working with legacy code you're like
getting like you're kind of leaning on
the tool trained leaning on the compiler
sometimes you will see just a
preprocessor or the linker just like
just vomit all over your face and you're
just like oh my god how long is it gonna
take me to fix this and the you know
Hitchhiker's Guide don't panic
right sometimes like it's the same
complaints over and over and over and
over and over again right so yes if they
implement three mocks and the whole
thing goes away or you have to do one
little thing and the whole thing goes
away so in this case I had to add - LC
there was a bunch of things that see
green uses file stuff console i/o stuff
that I said no standard Lib I told it
don't help me and it didn't right so I
just added - LC to bring the low-level
Lib C functions which still includes
just which still excludes the networking
functions I'd have that I would have to
add - L net so still gonna call my mock
receive my mock receive at link time is
the only receive symbol in town right
I'm sorry
so one other cool thing here is that
because we did it this way instead of
with the preprocessor like - D receive
equals receive mock or whatever we are
we using the same socket stream object
file like I just talked about which is
like what we like to do it proves the
modularity of our design as well as
helps keep our build times low and I'm
saying modularity rules when you see
this stuff like work in a real codebase
that's it's like one of the things that
still gets me excited about programming
we can just like plug different stuff
together and all just works because the
interfaces are nice it's ace so the next
thorny issue thorny issue and I touched
on Singleton's last year but some people
are like well what about this scenario
and I realized oh yeah that's a common
scenario and it's just one I didn't
mention last year so what some people do
with Singleton's is that they think the
point of the singleton design pattern
where you like design patterns you hit
the gang of four or whatever
um they think it's an excuse to have a
globally accessible symbol where they
just have to pan include one header
filed and access this one instance all
of place right but it's really what's
risk was to do Stu guarding it's
creating more than one instance of
whatever that thing is it's not to get
global access to it from anywhere all
the time so for non-trivial Singleton's
that you collaborate with and what I
talked about last year is that instead
of just referring to the global symbol
of I don't know statistics : : instance
increment or you know arrow increment or
whatever you're doing instead of just
referring to that everywhere you
parameterize to test statistics into the
constructor of the class it's being used
in so that your interface advertises its
collaborators as much as possible
generally good practice and extract a
pure virtual based class for that
whatever that's single whatever that
singleton class is like statistics
change the parameter of Erised version
to the abstract the paper virtual now
pure virtual base class and then guess
what I can mock that pure virtual base
class I can inject it whatever but what
if you have Singleton's that are just
universally accessed everywhere and the
canonical example this is a logging
system right so if it is universally
accessed you know you don't want to go
adding like you know abstract logger
star to every single constructor in
every single class that's nonsensical
and it's dogmatix I mean seem at times
I'm ultimately pragmatic but I have had
to argue with people to be like no we're
not going to add that to every
constructor that's silly
so if it's university access we can
still do linked I'm mocking and that's
still modular it's not runtime
substitutability which is the awesome
thing about C++ and objects and stuff
but it still proves the modularity at
link time link time substitute
substitutability is still modularity and
so that's still cool
so the way to do this is that we have a
link time Mach that wraps in Fords to
mockito PP so that we can still use
mockito PP or G test or RG Mach or
whatever things you said we can still
use those expectations in that syntax so
the common implement the common header
that we have here for this basic logger
it's an it is it's a singleton with an
instance and a static and it has two
methods Boyd and fatal and notice that
those aren't pure virtual by the way so
that you could also use this if you're
like I can't make a pure virtual base
class for that singleton or for that
whatever I'm gonna do link time
substitution even though thank you even
the runtime substitution but
hypothetically bb-better and then on the
right hand side we've just got a dumb
implement dumb stub implement our knoll
implementation of a logger there so
here's where we have a link time mock
that wraps mockito PP right so we
include logger h PP that interface or
that that header file which is not pure
virtual at all and we pen include the
makita PP mock object thing we use a
namespace etc so for mockito PP to work
it needs a pure virtual class but we
don't want to mess with the actual
logger implementation for some reason
let's say which is perfectly fine so I
have to make a parallel interface that
the actual logger the real logger
doesn't inherit from and that feels
weird because it is weird but if you can
inherit you can't change it or whatever
you can still do this you just have a
little bit more duplication a little bit
more maintenance overhead so I make a
mock objects logger I make a mock
objects for that logger interface ID I
just made and so here I am the next
thing is I have a logger instance which
is going to satisfy that header files
declaration right that I have a static
instance method that returns a constant
logger star and what I'm then going to
do is the the implementation methods
like info
and I didn't implement fatal here but it
would do the same thing what those end
up doing is that they're calling in they
just forward into the machi OPP mock
object for that interface where that
interface happens to have the same
methods and type signature as the longer
class which I had a laser pointer or
that there's a smaller room it's a good
point did I like it I can't see it oh I
okay now I see it yeah yeah sorry yeah
so this line here is what I'm talking
about
note to Microsoft people who are here
the office thing where it shows the the
PowerPoint thing where it shows the
slides over here is full screen in my
notes here that's really cool but I'd
love to see the mouse cursor as the
audience sees it file a bug or a ticket
or whatever at the oh I know the office
team is here somewhere they're here last
year so a polite feature request so so
yeah so I'm satisfying the link time
requirement that that logger header file
setup which is that there is there's an
instance method called info and I'm just
forwarding it on to a static instance of
a mock eat OPP mock object and then the
next example the next topic I have I'm
going to show you how I've been program
that so mocking factories factories our
life Singleton's right there kind of
creation pattern creation object
creation pattern II would be wobbly
timey wimey type things so what some
people will get into is they're like
okay I'm gonna mock my factory
but then that factory has to return
mocks and then those objects that the
mock factor returns
also have to return mocks does it ever
end is it Turtles all the way down mock
Turtles all the way down I'm here all
night so maybe maybe you have to mock
that whole chain when doing deep testing
of error handling maybe but at the same
time if you have to like in your tests
you
you have to know what that whole chain
of collaborators is and exactly like
this returns this and that returns that
and that returns that this is a
violation of the law of Demeter and so
or Demeter
meter thank you and so some people are
have opinions about this where they go
law of Demeter is just dot counting or
arrow counting and it's complete
 and who cares but here's the
thing is that when I have in my tests or
in other parts of my code you know a
arrow B arrow C arrow D arrow whatever
if I go to change that structure in any
way if I insert some new relationship
into the middle that I don't have to go
through my whole code base and change
all those it breaks encapsulation is
what it comes down to right and breaking
an encapsulation is a nice way to say
makes more work for you later that you
will hate yourself for so so even though
you can mock factories thank you and you
can return mocks from those from those
factories maybe you don't want to be
returning mocks from those if you get to
that point you probably have some minded
design issue where you need to have an
adapter source of some kind of some kind
of wrapping clasp which is the thing
that you ultimately mock so poor
encapsulation is harder to test if
you're testing and it seems hard or
verbose probably some design issue not
always probably probably and harder here
means a long list of verbose mocks so I
don't think that this is a bad example I
think that this is a practical
real-world example but I think if you
want one level beyond this I would
rethink really hard about what you were
doing
so this is another sea-green type test
using a Makita PP so I have a proxy
object and it takes a it takes a socket
factory and I forgot to put a good
instance in there
it takes a socket factory and so I make
a mock socket factory I pass it in as a
collaborator adding a get instance on
there if I were smart and I need that
socket factory
reading the name of the test here
insurer proxy logs fatal message when
control socket fails after second
handshake right and these are the fun
bugs these are the fun bugs that come in
from the field and you're looking at the
cord up and you're like what the hell
just happened
it's way deep in the weeds and you're
like well how would I don't know you
know neutrinos attenuation whatever
right the bits get flipped if you're not
using ECC Ram all kinds of stuff can
happen so so I'm gonna make a mock oh
that's right like I have a pointer here
I'm gonna make a mock object of socket
called working handshake socket and I
have some commented out expectations
here where I'm gonna set expectations so
that those things will return values
like they're working okay and then I
have a can see there it is I have a
broken handshake socket and I'm gonna
assess some expectations on that so it
returns bad data and misbehaves somehow
so then I'm gonna tell the where the
mock socket factory doctor seuss in the
house the mock socket factory I'm gonna
tell the creation method I'm gonna tell
the creation method when it's called
to return first a working handshake suck
first to return a working handshake
socket second time it's called return
the working handshake socket again
whoops and then the third time return
the broken one right and then I'm going
to tell the mock log or instance from
back here I'm gonna tell that mock lager
mock lager instance to expect a call to
fatal with a standard string that says
ouch in handshake three and then I call
proxy Connect right so this is an
example of i mocked the factory i mocked
the things that the factory returns to a
good testing end but it's not violating
law of demeter right we aren't exposing
like the whole chain of all of the
relationship between all of these
objects and what I say here one thing to
think about when sit when
these kind of expectations it's reading
the test is one thing and that is
important but think about if this fails
what does the Mach output look like when
the Mach expectation fails like what
does that read like glad to if I have to
go if they me the thing is it'll look
like crap just set a breakpoint or
something like that try to think about
how you can write these things to that
the failures are readable so the last
thing here is deploying a test framework
one of the problems that I've seen in
multiple companies and not just with
sea-green but also with G tests and even
CPU and stuff like that is that when
unit test a Stargate starts to get going
at scale each team does customizations
little customizations to the framework
and then so on the build systems you end
up with 20 30 plus copies of the same
framework with a lot of tiny little
changes and if you could get your LD
library path a little bit wrong or
whatever you're picking up some other
teams version of the framework that
doesn't have your changes or does and
just becomes kind of deployment
nightmare just like a guess a DLL hell
kind of thing so in my experience teams
and at warge will likely want to be able
to customize assertion and slash
constraint slash matters right they want
to be able to write their own assert
equal for their custom object types for
deep comparison of some custom types or
whatever that's pretty common and they
might want to customize the reporters of
the output right they want to do they
want out put it in some file format that
their custom continuous integration
system can slurp up or whatever else so
one piece of advice there's no code for
this but it's a general general piece of
advice pick a framework that allows you
to customize those things without a
recompile we talked we touched it we
talked a lot about modularity and last
year I said unit testability is
modularity is object orientation etc etc
pick a framework that embodies those
values so that when people are using the
framework they won't learn won't learn
bad things so there's the links again to
see green and mockito PP i-- if you're
going to consume those things I would
highly recognize emic if they keep their
tests passing ice maybe they do I don't
know I highly recommend tracking those
repositories and building from source in
your build
thank you um thank you guys very much I
hope this was useful and filled some
gaps for you guys again I'm gonna whore
out my music my musics at the making of
the making of calm and it's on title
iTunes Amazon Google Play and Spotify
that's my twitter handle if you have
questions for me you can tweet at me
you can contact me by email you can
contact me via LinkedIn stuff like that
the next talks that are coming up after
this talk context for introduction is in
this room practical lock-free
programming is in the feeder room which
I guess is downstairs has called design
patterns in C++ are in room 407 C++ and
the audio industry is in room 406 and
expression templates is in room 403
amount of time so if you have any
questions come up to me after the thing
and I'll be glad to answer them for you
thank you guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>