<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: “Building and Extending the Iterator Hierarchy in a Modern, Multicore World&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: “Building and Extending the Iterator Hierarchy in a Modern, Multicore World&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: “Building and Extending the Iterator Hierarchy in a Modern, Multicore World&quot;</b></h2><h5 class="post__date">2016-10-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/N80hpts1SSk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so as we have maybe a couple
more people to trickle in I'd like to
ask a quick question how many of you
this is your first time here at cpp con
that is a lot of people that's great
it's my first time here too and actually
I was it flying in on Saturday I was
greeted with a nice rainstorm that was
great I say that because in upstate New
York one from where action is severe
drought and we haven't had real rain in
a hell of a long time so really if I'm
going to bring something back to see
people from cpp con to my colleagues I'm
really hoping I can bring some rain that
would be kind of great but we're not
going to talk about rain today
besides that instead we're going to be
talking about iteration and you know
it's a 9 a.m. session and I figured the
best way to start a 9 a.m. session is
you have an audience participation
section so I'm going to ask you guys to
just raise your hands if you agree with
the statements you see before you
all right and I'm gonna start off with
I've heard of iterators before raise
your hand if you've heard of it erase
great ok you're in the right place and
in fact how many of you have used
iterators in your projects before that's
a good number
great how many of you like iterators
okay fewer Pearson I saw some on the
fence I mean you love iterators that's a
lot yours I mean you really really loved
it or it is just Marshall right and in
fact how many of you think that
iterators are fundamental to computer
science yeah I see a couple hands well I
actually think all of those things and
I'm going to try to convince you of not
all of them unfortunately but at least a
couple of them so when we leave this
session
you're going to have heard of it arrays
before you how or how by now you're
going to use it arrays before and see
how you can use them to write generic
software and software that will work
across any number of data structures and
algorithms and hopefully but maybe not
I'm gonna teach you to love iterators I
really hope so and although I won't be
we all we talked about how iterators a
fundamental to computer science if
you're interested in that come
talk to me offline and I love to talk
about the sort of stuff right okay so
how are we gonna get there
well this talk has two main sections
alright the first part is iterators 101
and we're going to be building up
iterators from zero and we're going to
be looking at algorithms and seeing how
iterators fall out of those algorithms
and how we can get very generic software
just by looking at these algorithms it's
going to be great I really love this and
this is based on a class that I teach
but the second part here is actually
kind of cool too and I think some of you
might be here for that we're going to be
talking about how we can take the
iterator hierarchy as it is today and
extend it to allow us to write cache or
we're parallelizable generic software
alright and how are we going to be doing
that well we're going to be doing that
with a paradigm called generic
programming now if you've used it arrays
before you might have heard of generic
programming generic programming is what
we see examples of it and the way we'll
be doing that is using the new concepts
Lite technical specification syntax and
we talking about concepts like we'll be
talking about concepts as they relate to
concepts life and what we can do to
write very generic software using this
GS
but I want to make clear that this is
not an introduction to the STL in fact
the iterators I present are not the STL
iterators they're very similar but if
you come out of this talk and write this
new code and just pound include stood
algorithm it's not gonna work all right
but you're going to have the tools that
you're that we use to understand how the
standard algorithm work how the ranges
GS is going to work and how any out any
iterator library will work and
furthermore we have an hour we're not
going to do a comprehensive guide to
concepts like you're not going to learn
all the ins and outs of the syntax and
the semantics of it that just would not
be feasible alright so and finally just
we have a lot to get through one of the
nice things about being in a big room
like this is we have microphones up at
the front so I'm actually going to defer
all questions until the end if I can
and at the end if we have time please
come up at two microphone and ask
questions if not come and find me and I
love to answer your questions all right
so let's start out with iterators 101
right so we're all C++ programs here if
I show you this algorithm next you're
going to be not you're not going to be
surprised at all this is a really simple
algorithm it takes in four pointers to
which form a range and two of which form
another range it loops through those two
points those two ranges and just assigns
from the input range the output range is
anyone surprised great okay so this is
good so this is a really easy to
understand algorithm why am I even
making this a function I mean this is
just a while loop isn't it if you were
writing this yourself you'd probably
just write awhile look you wouldn't say
oh I'm gonna break this out into a
different function call it copy because
the while looks pretty clear now you
actually get a nice benefit of breaking
out to copy and maybe it's worth it we
actually say copy in our source code
when we're looking at the call site we
don't have to parse through a while loop
now the while loop is pretty easy but we
don't have to parse through a while we
can see what's going on that's pretty
nice
but can we do better all right well
unfortunately I know the
high-performance computing guys would
really love this but we don't just work
with arrays in fact I've had to work
with data structures that look like this
I think a lot of you have this is a
singly linked list right it's not a
right unfortunately but we can still
write a copy algorithm that takes some
segments of a linked list in some
segments of another linked list and copy
the values around in fact we can even
take some segments of the linked list
and copy into some segments remember
right this is real easy and again you
would just write these while loops right
why are we breaking this off into a
function well we'll see now some more
interesting data structures that we work
with at least some of us work with we go
out over the network and we write
something out of the network or maybe to
disk or maybe we
something to a console again this is
just a wild isn't it
instead of taking pointers we're taking
an extreme dose seem rough but as we
write this it looks very very similar
now anyone in this room could write any
of these algorithms so why am i showing
you this
the four organs we saw really simple to
write in fact any of the nine of those
permutations are also really simple to
write right and nine functions isn't
that bad right and you know we unit
tested them right we're gonna test them
yeah yeah we're gonna test them so we
know that they work and that's pretty
good I hear some louse okay this is
great unfortunately though I have a
confession to make these are not the
three data structures that I've used in
fact sometimes I use a W linked list too
and sometimes I even use an inorder
traversal of some sort of tree or maybe
a standard deck or any other sort of
data structure you could imagine maybe
we have a function that just spews out
data a co-routine that just spews out
data and we want to write that to an
array 50 functions that's we can started
that right we can stir unit test those
we can still make sure they work we're
good right not that's not that one until
you know we want to pour ting to C++ 11
and suddenly we add move semantics we
want to move from our input range well
or maybe we want to run a function on
that input arbitrary function on that
input before we copy it to the output Oh
150 well okay maybe we want to fill the
the output data structure with some some
value maybe we want to zero it out
that's a lot that is a lot how many of
you want to write 200 functions that are
just while loops I don't I really don't
and in fact I could think of arbitrary
number of data structures an arbitrary
number of algorithms and I'm sure the
users of your software of your libraries
do as well and
turns out that if we want to cover all
our bases we have this number of
functions and they're just wild loops
they're just while loops why are we
doing this and they're all called copy
it's stupid right okay maybe it's not
stupid I guess my slides are telling me
we're missing something so we're
probably missing something so let's back
up all of these while loops look very
very similar right we have some sort of
a schema that looks like this we have an
input sequence we have an output
sequence as long as we have stuff to
work on input and output then we copy
them and we bump our iterators our
pointers then we return the album all
right so what can go in that input
sequence what things can go in that
input sequence well we've seen examples
of pointer a pointer to a node inside a
linked list or an ice-cream or you could
imagine any number of them what about
output what could go in output
well very similar we can't put an
ice-cream in out but that doesn't really
make sense we could put a no stream and
output we could put a a sync function
that just takes in data and does nothing
sort of Deb nor function that's kind of
cool
not very useful but I'm telling but
still pretty cool you can imagine any
number of these and I keep saying these
but what should we call them well we
should call things that kind of look
like this iterators
all right because we're iterating
through the data structure now we're
gonna we're going to start slow down a
little and and see that ice cream and
ice cream I'm not entirely iterators on
their own but we're going to get to that
very very shortly
okay so we take our schema and because
we have things that were changing at the
input sequence things that we could type
that we can use in the output sequence
we template on that instead of our type
shape you are all familiar with
something that looks like this right
this is this is very similar or this is
very easy this is very similar to things
you've seen before it's a little bit
verbose but it gets the job done now we
still haven't seen how to write output
reader input incrementing increment
so let's define now let's define a
function that just reads input call it
source let's define a function that
takes important rights it sync you can
see for a pointer that looks just like a
star for the new data structure that
looks like the carrot or the arrow and
then value and incrementing the output
incrementing the input that's also
pretty similar we can define a successor
function it gives me the next iterator
in this sequence okay cool
this is again this is pretty easy and I
saw the answer that question why are we
doing this like it's a copy of its viola
now of course we only have to write one
of these but we haven't really seen much
power here if you were just doing this
you probably wouldn't go through all
this trouble to take that one line while
loop and expand it to however many ten
lines that we have here now we talked
about in put it over as we talked about
operators we saw that how to have
sources and sinks and they have to have
successors so we can define those for
our types and suddenly our code works
right nothing interesting going on here
except I might add or I might point out
this auto here is a new concept slight
feature so you can actually these are
templates so when you see an auto here
it's just like a C++ 14 generic lambda
who puts this in your mind with template
type name T and that auto replace it
with two nothing really strange going on
here it's just nice and compact nice and
nice and simple to reason about nice and
simple to understand okay so I kind of
just threw that at you right and it
wasn't really really impressive so I'm
glad no one's left yet because we're
going to get a little bit more
impressive and we're going to see how
iterator is actually what we've done
here can actually be extended to an
infinite accountably infinite number of
data structures so let's get formal
let's look at this a little bit more in
depth what do we need we don't just need
sinks since and source functions and
that we
have to define the semantics of them so
let's look at this again this is our
code okay so to make this work
what does input iterator need to do and
what does output it or it or need to do
okay so every time you seem to put it or
every time we see not put it over we're
doing something with it well one really
thing easiest thing easy to see thing is
comparing for equality we need to be
able to do that it's really easy to find
a type where you can't compare for
equality just don't define that operator
double equal or make it private or
delete it so we need to be able to do
that we need to be able to assign
iterators input it arrays and output
iterators we in fact need to be able to
construct input iterators now
predatorists are no private constructors
and of course we need to be able to
destruct whenever we construct all right
but that's not it of course we have
something that looks like successor and
we do that on both input eight arrays
and output iterators so we need to be
able to iterate or it can be an
iterative and of course for input
iterators we need a source function and
output editors we need a sync function
let's arrange these schematically let's
let's have a nice table and we can
actually see that there are they kind of
fall into groups those first four we
talked about those are easy right a lot
of things do those that doesn't make
them iterators so we might call these
regular types because they're regular
they do what we want they're what we
expect things like int follow this
things like double things like iterators
things like stewed string things like
straight vector these are all regular
types the thing that gets interesting
though about iterators is they have this
successor function and then once we have
in Peduto once we have iterators we can
define an input iterator and an output
or the writer an Imperator is just
something you can beat from an operator
is just something you can write to these
are all orthogonal you can have a
regular type that is an iterator
iterator you can have an iterator that
isn't readable you can have a readable
thing that isn't an iterator but for our
algorithm to work we need
these things alright so what this is
what we've just defined is called a
concept and we haven't really formally
defined it yet despite the title of a
section we haven't really fun where we
defined it we just said what what's
there and then kind of hand waved and
then it's great right alright so let's
look at how we define concepts a little
bit more rigorously in concepts like TS
we have syntax that looks like this we
have a template type T and that's going
to be what our concept is on and we have
syntax concept rule and then the concept
name and then some boolean expression so
what is this it's something that takes
in a type T and returns a true and false
or true or a false at compile time
it's a predicate on types so what does
that give us yes ok cool right well for
something like regular we you know we
have type traits in C++ we can use is
default constructible to define whatever
your regular type is is copy
constructible is destructible this
little V at the end if you're not
familiar with it that's a new C++ 14 ISM
instead of having to reach into some
template and do a colon colon value and
have really ugly syntax we can just
instead do a nice variable template like
this so don't get tripped up by this
this is just a value that says at
compile time is T destructible great
we've defined regular except we haven't
because this guy doesn't actually exist
that's unfortunate
right ok ok so this whole concept thing
that bogus right because we can't even
say something as equality comparable we
can't even say that two things double we
for each other we can't specify that
it's bogus right well ok well again
let's back up let's back up what would
we say in math what would we say if we
were describing this to someone what
we'd say for any x and y that is a that
we want to be a regular type we can say
X double equals y and that can be used
in contact says and that can be
converted to a pool we need to say that
double equals induces an equivalence
relation on T so all that nice stuff you
learned about back in the computer
science classes symmetry of reflexivity
transitivity you need to have that
and finally if x and y are double equal
to each other then they represent the
same value because i could define a
really nice equivalence class it always
returns true and that's a pretty bad
equivalence class for equality because
that would mean that all answer equal or
doubles or everything's equal we're all
equal it's great except when we want to
distinguish between values so in concept
light we actually have syntax to do
every single thing accepts a little bit
that we want to do here so that for all
X comma Y and T we write that as
requires and we introduced it with one
of these variable lists here for an X of
type T and Y of type T any arbitrary X
of type T wive type tree these things
need to be true now this isn't super
post plus syntax so let's put it in C++
syntax that's kind of cryptic but what
it looks like is we have x equals y
that's sort of expression and we can
take it to a bore we can implicitly
convert it to a ball which says exactly
what I said in code now how do we say
that W equals induces an equivalence
relation that's kind of tricky isn't it
and we have to know about values of X we
have to know about the bow is why we
have to know about the source code and
the the way the algorithm actually works
that defines equality and that's really
hard
that's undecidedly hard for a compiler
to figure out so we just kind of wallow
on that you know
you know so concept light allows us to
specify syntactic constraints it allows
us to say X double equals y that is an
expression that is allowed and it has
type that is convertible to bool but it
can't do these more semantically things
these things that say well double equals
that has meaning is any any old double
equals could be convertible to bool we
could have one that returns false that
doesn't make it an equivalence relation
all right but what you see before you is
a definition of regular type and even
without that really nice built-in is
equality comparable we have something
that looks like regular type it's a
little bit more to a regular type in
fact we would want something that says
not equals as well because what uses a
type that says equals where we can't use
not equals that's not very useful it's
not very good type either you should
feel bad if you've written one like that
so readable is actually pretty similar
as well we have this new interesting
thing here
we need a type an associated type with
our type key for it to be readable we
need to say that there is a value type
we can write value type and get a type
for our T for it to be readable
additionally we need our source function
it needs to return something that's
convertible to a constant ref to value
type so converting a five value can
return it by a constant ref it's great
and it has to be o of one we can't be
going out and doing a linear time search
or a quadratic search to find the thing
based on the iterator that can just ruin
our algorithms and make them much much
slower and would kind of throw this
whole thing in the sink wouldn't it same
with writable it's actually really
similar as well instead of source we
have sync and instead of a constant
reference there we have a mutable
reference that's great nothing nothing
really surprising going on here new
syntax but things we've already been
thinking about before and finally once
we get to an iterator we got successor
which we've seen before and successor
returns in UI and we have this
interesting closeted successor may
mutate other iterators that's really
scary isn't it that's truly scary if I
call successor
I can't reason about the the state of
the other iterators necessarily so as
I've defined iterator you can only have
one iterator at a time well you can copy
them around the regular types you can
default construct them you can assign
them but you can't store an iterator to
a past value in the sequence and expect
to get that same value out or when you
iterate it expect to see the same things
that you've seen before now why is that
this is a really weird restriction
really strange but if you think about
strings when I read something from a
stream and I read something from a
stream again and I read something from
the stream again there's no way I can
get back to that first value I have to
have stored it already I have to have
work done
it worked done work on it I have to have
had some sort of online algorithm maybe
that just pulls things off and does what
they can with them is that's drawing
them there's no way to store some
reference some past thing in the stream
so if we want to make this work where we
have some sort of AI stream iterator or
old stream iterator that wraps up this
iterator and allows us to read from
something multiple times the same thing
multiple times allows us to copy them
around default construct them we need
this restriction there are a lot of
other interesting and Peduto writers as
well I've been talking about having a
function that just spews out data that's
another example of this we can't
necessarily uncomputable or all right so
there are this is a pretty interesting
requirement here and it's not one that
concept light allows us to express we
could fit a little bit more fine-grained
of course you can't just mutate any
other iterator kind of it can only
potentially mutate iterators in the same
sequence again concepts like doesn't
really allow us to say that so we have
to resort to these constant - these are
we call them axioms these comments in
the
the concept all right so this is our
code great let's make the concepts aware
so what is an input iterator well we
said an input iterator was something
that was an iterator and that was
readable we said now put it or it or
something that's an iterator bowland
iterator in vital great we have just
made the compiler allowed the compiler
to check at compile time whether things
that are in people that instantiate our
templates are in stanching and then the
types that will work with our algorithm
that's great
and you only took us four extra lines
for our one line Wow so why what's
what's the point
all right so we could play some tricks
we we don't need iterator everywhere I
mean I love iterators but we don't need
them everywhere we can just say in out
because we see iterator and we see
iterator for out we can play tricks like
that but that still doesn't really solve
the problem that doesn't make it much
better concepts light provides a nice
shorthand though that we can use to make
this a little bit simpler and a little
bit clearer and say more clearly what we
mean really what we're trying to say is
in and out our iterators so let's say
that we replace that type name up there
with the name of a concept and replace
that time name right there with the name
of a concept we still have the readable
and writeable and requires clause but
this is actually very easy to read and
it's only one more line so we're doing
better now these iterator concepts are
defined if we're just doing copy that
again this wouldn't be very useful
because I just write that Wow but as we
get more and more as we see more and
more algorithms we start to see this as
a pattern that these sorts of things
happen all over the place we could have
a fill algorithm that just writes the
same value over and over and over again
something like mend set but type aware
and will work for streams work for sync
functions or work
vectors and lists and data decks and any
sort of data structure that you guys
have in your code base great we could do
a fold function myford function in C++
we call this in our king no way in the
STL but it's something that takes a
value and kind of squashes them all
together applies an operation in between
them and folds them all together into
one so this op op here you might think
of as something like plus or something
like times or something maybe more
interesting I think there was a talk on
accumulate today or tomorrow you should
all go to other communities are great
I'm calling them folds but it was just
something morning unfortunately and you
should all should have gone to it all
right
we could also have something that looks
and finds the first value here in our
sequence something that's equal to this
value you know we want to constrain this
a little bit more of course because
we're comparing value for equality or
inequality here that's fine
let's ignore that for the moment we
would have some sort of constraint that
value type of it is a regular type easy
but as we see iterators and eatables and
writable x' they're everywhere and this
will work with any of the data
structures we talk about any data
structures we haven't talked about this
work any data structure that's pretty
cool and of course there are infinite
number of them so let's see as a story
say I live on the East Coast I write my
cool data structure Patrick structure
it's a really core data structure I
think you all should use it all right so
someone out here on the west coast they
write their cool algorithm that's called
their cool algorithm because they
weren't as creative as me and as long as
we both provide it or it or I provide
iterators and they use their writers
some 115 years down the line can just
hook them together and their work how
many of you here have used some library
from 15 years ago that didn't work with
some other library from 15 years ago
had to write a lot of code just to make
them work together I don't see any hands
that's that's a little bit disappointing
yeah okay there some people were really
unashamed of it and some people yeah
it's very tricky with something like
this this will work with the minimum set
of requirements that we need we looked
at earlier our algorithm and said what
do we need to make this work and we're
only requiring those instead of saying
oh you have to derive from this class
over here and and then you have to
implement this virtual function and oh
by the way if you have some class that
you want to use with it that isn't
derived from it you have to make your
own derive type and that's a little bit
disappointing we don't have to do any of
that here so we have a lot of algorithms
we have a lot of data structures they
have a lot of use of it still kind of
while loops but as we see something like
find first looking in a code that says
fine first out of the sequence that's a
lot better than something that looks
like this so we can write this once we
can unit test it once and we know it
works everywhere as long as they follow
our concept so that's not the end of the
talk that's probably the most important
philosophical bit of the talk it's not
the end of the talk because we can go
further we can move forward so consider
this album it's called max element it's
a really nice algorithm it takes a
sequence and returns the maximum element
it's very aptly named it does or sorry
if it turns an iterator to the maximum
oh thank you Marshall every turns an
iterator to the max another one that's
kind of important so I want to step back
and notice that that we say it takes an
iterator and a readable iterator is this
code correct cricket's no one well okay
let's let's think about it I'll tell you
the answer actually it's not this code
is not correct and I don't need to think
about any specific type I don't need to
write any tests to make sure this
doesn't work to see whether this doesn't
work I can just look at it and say this
obviously doesn't work
why does it obviously not work well
remember our iterator type and remember
that really scary comment that we
determined that we really need but we
don't want you eat it but we don't want
so let's so that machs element is a real
useful algorithm you can't just say well
that's that's an outlier you don't need
that iterator we've determined as of
alias for concept so I guess we can't
use an iterator and a max element so
instead let's define another concept so
we have something here let's take it
away hmm now our code works we didn't
change anything except remove a comment
but suddenly our code works that's
that's a great killing isn't it
we call this the multi pass guarantee
because what this means is I can take an
I an iterator I and it's a regular type
so i can copy around i can save it on
the stack i can do whatever i want i can
increment one of them and then when i
increment the other it hasn't been
modified so it's incrementing just as if
the other the other iterator hadn't been
incremented we call this the multi pass
guarantee for data writer is a little
bit of a misnomer it's really a multi
pass editor so we take and we add that
one word there and all that one word is
leave a comment somewhere and suddenly
it works that's great isn't it but this
is actually really powerful i say that
kind of flippantly but what we did is we
looked at the code we didn't test it we
didn't run it we didn't compile it even
we looked at the code we looked at the
constraints that it says it needs to
follow and we determined that there was
a bug that's an incredibly powerful way
of making software correct we're not
using proof techniques for not using
automated theorem provers we're not
using compilers even we're just looking
at it saying this can't work so I have a
proposition for you guys any type key
that models forward iterator that type T
also models iterator now if we go back
to our concept for forward iterator it
doesn't say anything about that does it
but I mean it's pretty obvious the
forward iterator is just an iterator
that allows you to to iterate through
multiple times and if remember iterator
may mutate other returns it doesn't have
to be pretty weird concept that says
iterator has to modify every other arrow
iterator wouldn't it be kind of weird so
many find use for that I don't know I
certainly haven't so it's pretty easy to
see that all right now actually before I
move on forty-eight arrays are really
useful as well what sort of models
afford iterator do we have well we have
things that are backed by memory that we
can iterate through multiple times we
have a singly linked list the doubly
linked lists we have our pointers in an
array we have even something that's
computing values on the fly say that
computes the next Fibonacci number we
could have an iterator that stores the
previous two and then computes the next
one when it increments and as long as we
saw those previous two we can implement
it again Fibonacci numbers are kind of
cool and they're a really CSE sort of
thing to say and sometimes you find use
for them but you know use it as you will
but there are a lot of really useful
concepts of forward iterator and now
that we can save them on the stack and
reason about that use equation reasoning
on them we can actually make a lot of
interesting algorithms for example we
can reverse a list we can search for
something in the list we can do a binary
search it would be a pretty efficient
efficient binary search we'll have to
loop through each time that's like N
squared or n log n something like that
algorithm that's not very good algorithm
but we can do it and that's important we
can do it so it's back up all right
literally let's back up I talked about
reverse and with for iterator you have
to go and you'd have to go to the end
and then copy them to the beginning and
they have to go and you have to go to
the one minus end and copy em to the one
or almost the beginning and so forth and
that's an N squared algorithm but that's
not what we do with something I could an
array right we wouldn't do something
like that
so this reverse algorithm has a
different function here it has a
predecessor
intuitively we know what that means it
means if I call a successor of something
the predecessor was the thing I call the
successor and of course we can't call
predecessor on the beginning of the list
or a beginning of a sequence rather we
call this a by direction or a river and
it's again very similar to the the
forward iterator except it has this
prejudice prejudice predecessor function
and prejudice the prejudice I cannot say
that so I'm not going to that function
there when when applied on the result of
a successor returns the same thing have
an identity there and that's really
important because otherwise anyone can
define a predecessor function which I
said correctly this time and it can do
whatever it wants I can just return the
same iterator that's not a predecessor
next one so we write that word
bi-directional there and suddenly we're
all good and for something like a doubly
linked list we can just write that
predecessor real easily something like a
singly linked list we can't do that we
can't write this algorithm for a singly
linked list because it means yeah right
we can't write this algorithm we can
write the function signature that does
the same thing but we can't write the
actual implementation that we're using
here alright so bi-directional iterator
it's surprisingly not very useful for
the rater iterator and random access
iterator are all very very useful but
another proposition it's pretty obvious
though if T models bi-directional
iterator it also necessarily models
forward to the river because all we did
was add a predecessor function so okay
but something more interesting can go on
if we have a type key that models
bi-directional iterator it's dual also
modifier not models bi-directional
iterator so what do we mean by that if
we're walking forward with successor and
we're walking backward with predecessor
you could make a type that instead you
walk backwards with successor and fords
with predecessor now that's also a
bidirectional iterator and we call those
reverse iterators in c++ the term dual
is one that we might use in modern
algebra wonderful
sequences and defining relations but
it's just a reverse iterator excellent
so um this is all pretty cool
okay iterators are pretty cool i like
iterators great for a lot of you this is
probably not new so why am I even saying
it well let's look at this one so we can
define any algorithm with four day today
for example that reverse I described how
you'd write a reverse sequence with a
forward iterator now unfortunately
something like this this increment we
can do it we can implement an iterator n
number of times but it takes all of n
operations whereas if we were using a
pointer it would only take oh one
operations it's a single thing to do
there but unfortunately we have no way
of saying that because our iterator is
wrapped up in this successor function
right and so unfortunately we're not
making use of the full power of our
pointer so that means our binary
searches are not going to be log N and
that's just not acceptable
right that's this whole iterator thing
would be horrible if we couldn't make a
log n binary search some way for a
decrement of course so let's define
something that makes use of the full
power of a random access iterator and
this is a lot more stuff here on a lot
more comments and comments are great
right so we have something where we add
n to an iterator and it takes o one time
it returns an iterator that's the
syntactic constraint but that means
something so when we add zero to that
iterator it returns that iterator when
we add some positive end that iterator
it's like applying successor that number
of times and when we add some negative
end to that dude it's like applying
predecessor that number of times
similarly we can define subtraction
which is the opposite and we can
subtract their raters and figure out
what the distance is between them so we
can do something like a binary search my
actual favorite algorithm here is a an
upper bound so an upper bound takes in a
sequence ordered sequence and we'll
return to you the first element that is
greater than the thing you provided that
X right there so it's going to say
sorted sequence and we're going to look
for all the x's and as soon as we get
some pants greater than an X we're going
to return an iteration to that so I I
don't want to convince you this is
correct because it's really easy to get
off by one errors and that's in fact why
I wrote this recursively instead of
iteratively just for my own sanity but
you could easily transform this into an
iterative solution that's constant sack
space but we couldn't have done this
with our bi-directional or afford
iterator this will take all of login
time rather so random access it away is
pretty cool this is something like a
vector write we can just jump anywhere
in the sequence or something like a
counting iterator that starts at some
natural number and as you call successor
it increments and calls predecessor at
decrement so we can do that and random
access time we can't do something like
that for a linked list though
so another proposition when we have a
random access iterator it also models by
direction whether ever really simple to
see right we defined successor to
increments by 1 we defined predecessor
to decrement by 1 so what we have here
is a set of syntactically unrelated
concepts but they form a sort of
hierarchy the iterator hierarchy and
this is what we've had since 19 1993
whenever the STL was was created and
then added to the standard we've had
something that looks roughly like this
this is the state of of iterators for a
very long time now so you're probably
all used to this although you might not
have thought about in this sort of
abstract or algebraic sort of way but
you're probably using useless ok so I
have about 20 minutes left 20 minutes
left and so we're going to talk a little
bit about how we can extend them we're
at the status quo right now how can we
get further alright so as a pop quiz
the
is our second audience interaction
section so I do want responses can I men
move some sequence some random access
sequence and bytes can I call men move
on it I see some head shakes no you know
we can mm-hmm so let's look at the
concept let's make sure all right
just to convince the rest of you who
haven't shaken their heads yet so for
something to be valid we need to look at
the concept and see what the concept
says is about because anything else is
is totally fine we cannot be here we
cannot rely on it
so our concept for random access says we
can add some number to it we can
subtract it some number to it and we can
find the distance between them also we
have a nice order in there it doesn't
say anything about member right doesn't
say anything about pointers it doesn't
say anything about that so the answer is
no now why would we want to use memory
about it at all right numbers a squared
C function I don't know if any of you
have used it before it's fast cuz it's
fast
exactly memmove is optimized by our
compiler vendor by for your specific
architecture in a way that our simple
copy loop might not be depending on how
good our optimizer is our men move is
probably much faster so the answer is no
but we want it to be okay so actually
let me present a counter example so if
if that to convince you that sort of
reasoning because maybe something more
subtle is going on there that there is
some sort of way we can use men move
let's store an example of a segmented
array an array that is a vector of
vectors and show that we actually can't
calm and move on this so I'm going to
have a vector of vectors and I'm going
to add this invariant that each
interrupt the last has to be the same
size so it's like we're taking a
sequence a vector and we're splitting it
up into constant size chunks and just
putting them off on the heap so we can
find iterate for that we can even make
it random access I've I'm only showing
you the plus here but the minus is
similar and the subtraction between
Twitter it is is also
pretty easy convince yourself that this
is a one-time like we need for our
random access to debater this is a ugly
integer divide here and potentially on
some architectures maybe another ugly
integer divide but it's still fine
it still will work and it's still a
one-time so we're still satisfying
constraints even this is even if this is
a kind of suboptimal implementation
okay so that's what our segment of your
River has but what does mem move need to
work well we need trivial recap of your
data we had that with our bytes so
that's fine right we couldn't do this on
something like a standard string because
standard streams not trivially copyable
and we need those things to be
contiguous in memory now what does that
mean we have a way of describing memory
now we have iterators we have a way that
describes any sort of memory you can you
can imagine so we can describe this in
terms of iterators alright so if I have
an iterator I and I have an iterator J
what I want is some function pointer
from say that when I do something on the
iterator it's as if or it's written
convert it to a pointer it will be the
same thing as converting it to a pointer
and doing that off that opera is it that
operation
similarly for - and distance computation
so in other words we want pointer from
to be an isomorphism that preserves the
algebraic structure of our memory and we
want that to be an isomorphism from our
iterator to pointers in document so
pointer from for pointers is pretty easy
right that's a pretty easy function to
write I'm dead confident that I got it
right a slightly less easy one to see is
maybe for some reason you have a
iterator that is a pointer in an offset
maybe you were like me and you're
experimenting and seeing if that help
Airways analysis and your compiler and
you find
it doesn't so but then we have our
pointer that's first and our pointer
that's a second we add them together
it's still not a hard I Sam or something
but it's still an isomorphism and you
can you can look at that and see yeah
there's a one-to-one correspondence
between pointers and dividers and that
if we do some addition in our iterator
space and we convert it to a pointer
it's as if we did the the we converted
it to a point at first and then did the
operation okay that's great so actually
before I move on this what we've just
seen here shows that segmented array is
not does it can not have such an
isomorphism because we have arrays
living off all the way in the heap all
here and there and we can't connect
bridge over those gaps using pointers
because if we increment our pointer and
we're at the end of the segment then we
might be what we running off into memory
doing whatever we whatever we we're
going to do and an undefined behavioral
and it's just not good so we have a
different set of constraints now we need
this pointer from function and that's
something that returns a a pointer and
that pointer has to be an isomorphism as
we've discussed so we have a nice
comment there that says that we trust
that people are going to do that
all right so we write our contiguous
enter iterator we have to make sure that
they're trivially copyable and they have
the same type so we don't have weird
slicing problems and we can use our men
move and it's going to be fast this is
going to be fast for things that it can
be fast for for things that can't be
fast for it's not going to be fast but
it will work because we're overloading
our copy and we're specializing our
templates
excellent so this is actually in C++ 17
not as I've described it here with this
pointer isomorphism but something that
does the same thing contiguous iterator
and you can use this today you can write
your trivially copyable algorithms and
do all this this wonderful fast bit
bleeding on any data structure as long
as it's
it's contiguous so as long as there
exists that isomorphism you can do that
it's coming in C++ 17 so I really like
that segmented data structure I think
it's just really nifty we have one of
those in the standard actually but it
goes by a unassuming name called
unordered now unordered set names like
that those are actually just arrays of
arrays they don't have that additional
restriction where we say they have to be
the same size but this actually comes up
quite a lot and debt too yeah yeah
that's a great way to implement a deck
of it's not a great way but it's a fun
way to implement a deck we have an array
of arrays you could do a ring buffer or
something like that but it's a great way
to implement a deck so our second to the
Raygun simple nothing great going on
here but if I were to write will use
just the iterator we provided before I'm
not going to be able to take advantage
of that contiguous iterator optimization
that we just did I mean we spent a whole
five minutes showing that we couldn't
take advantage of that but I want to
because I know those inner arrays are
contiguous because they're vectors so
really if I were writing this by hand
I'd say something like ok so if we're in
one one of these inner arrays let's call
it a segment say if we're in the same
one then just copy it we don't have to
worry about segmentation at all if we're
traveling across segments
first we get out of the partial segment
that we're in we do a really fast loop
across all the inner segments and then
we clean up at the end that may be
partial segments that we have at the end
that's what this function here is doing
and this is how you'd write something
like this and this is a really common
pattern when you're dealing with
segments of any sort so this is how I
want to write this but unfortunately
that segment function there that local
function there that begin in that end
there that's not something that we have
in random axis iterator that's something
something we're exposing our reader
writers they're just saying we have a
flat sequence and I don't know anything
about the structure inside of it except
maybe for contiguous we know that it's
laid out in memory and
certain way so we can define a segmented
iterator concept and the segmented area
concept allows us to write that code we
just saw so okay what do we have let's
let's back up right
we need a segment iterator and that's
going to be the iterator on or outer
type we need a local iterator and that's
gonna be the iterator on our inner type
those both need to be iterators they can
be stronger they could be contiguous
they can be random access they could be
forward but they at least need to be
iterators and I'm kind of alighting this
but we need segment iterator to provide
it
begin function that returns anywhere and
an end function that returns an iterator
we call such a thing a range you might
have heard about them they're kind of
popular nowadays we also need these
functions local that will take a
segmented iterator and return what it's
currently pointing to in the local the
inner array and a segment that gets out
of that segment to do better the pointer
to the segment so actually let's let's
look at that that might be a little
confusing so if you remember our segment
today diretor was a struct of a outer
array which we said was a pointer to a
true vector of T an inner inner iterator
which I just defined as a size T offset
from base so let's let's do something
here size T isn't a readable iterator
it's an iterator because we can define a
successor function on it but we want it
to be readable and writer right of order
writer so let's let's take it and
convert it to a type T star and so where
we do that is down here in this access
function you write this gnarly thing
once and we can get the local iterator
out of that pair of segments and local
iterator we can write a segment iterator
which is even simpler it just returns
the segment ater error which we've
called spline iterator and we have this
thing here where I'm defining a begin
function on a pointer to a vector and T
that's kind of ugly but um anything else
wouldn't fit on slide so um you're not
gonna have to live with it don't write
this in your production code please
please so
this this type now our segmented
iterator works and we can write that
function we saw before on segmented
iterator and we get advante can't adjust
all before because we're just delegating
to an inner copy function that can
figure out what the iterator category is
based on the concept that the iterator
satisfies and just do the right thing so
if in our case our inner iterator is
contiguous so excellent we get that bit
bit bleeding stuff if it were not maybe
we have a doubly linked list inside
something like a hash table might do
that then this will still work and it
will still do the right thing it won't
take advantage of the optimization that
it can't take advantage of it will still
be correct but back up segmented
iterators are exactly how we want to
paralyze operations on this data
structure we will want to take one of
these segments and feed it off to some
thread and take another segment feed it
off to some other thread and take it
notice I gonna feed it off to some other
thread and wait until they all do all
the work and converge back together
that's exactly how we want to paralyze
this in fact we can almost write that in
the C++ 14 now we don't have a task pool
implementation our futures are not good
enough to really do this well but if
we're using something like TVB until TBB
we can write something like this if
we're using a less impoverished futures
library we can do something like this so
I'm gonna write this in the abstract
let's get a bunch of threads that we can
use let's do our normal segmented stuff
the wouldn't fit on one side so we have
two branches are various the first
branch if we're in the same segment why
why spawn and out to different threads
just do it do it in place on this thread
or if we have a segmented iterator
inside a segment to data rate or well
maybe you can do that that we pretty
cool you can have that Abitur any number
of times and really confuse your friends
you can there so if we're not in the
same segment we have to do something a
little bit more interesting but again
it's always the same structure that we
saw before instead of calling copy we
I'm out on task call for a thread to
Kakaako and for each of those three
different segments iterators we talked
about before so when we're done with
this
this is asynchronous we could add maybe
a task or go or something like that
maybe these are blocking however you're
at your library works but this will
write to out the value that we want and
we'll paralyze it in exactly the way you
want fortunately as an author of this
algorithm I didn't need to know anything
about that I just needed to know I can
break it up into different segments and
I just going to trust that the the
author of the data structure knows how
to break it up into different seconds so
I don't know how many of you use a
segmented arrays very often they're
there unfortunately not common when
we're doing paralyzed algorithms often
we use vector Y we use vector because
it's all contiguous in memory and we can
reason about the cache behavior that we
have
fortunately actually weight segmented
iterator is great for parallel
parallelization we wrote that algorithm
and it's suddenly parallel and it's
parallel and it's correct and it will
work for any segment to data structure
contiguous iterator is great for just
blasting out bits copying them if we
know they're they're contiguous we can
do some really nice optimizations on
them okay no los dos why not both so we
call something this a cache where
iterator and it's an iterator that is
both segmented and contiguous because
it's segmented those segments could be
cache lines or really we want multiples
of cache lines because our type team may
not fit nicely in a cache line and we
still want correct behavior but if it
does then those segments could be cache
lines are great and it's contiguous so
we can we know that it's all in memory
so we can say any pointer any vector is
really a segmented iterator so if we
write our album as we did before each
thread is each thread is fed its own set
of cash flow
by the way we sweat them up and we know
that no two threads then will be writing
to the same cache lines so if we do this
and if our segmented iterator is correct
then we have absolutely no false sharing
now I didn't write my algorithm to do
that it just happened
that's really nice
this just happened and as someone who is
not a guru in parallel algorithms I can
still implement this and and have in
pointers and seen performance benefits
now it's nowhere near something that you
might do in high-performance computing
but if you're just writing a desktop
application or some small application
you want your library to do this for you
and just spawn them out to different
threads you know you could have a more
articulated library that allows you
control that a little bit more but we
have this nice benefit to no false
sharing and false sharing is one of the
really really problematic ways that we
have with performance so that is how we
can extend that and unfortunately it to
actually make that work requires a lot
of code and it requires a little number
thirty minutes and I don't have another
thirty minutes so instead what I'm going
to say is I've started to write these up
in a series of articles going from zero
and saying everything you could possibly
want to know about iterators something I
can't fit in this one-hour talk and
culminating in this cache aware iterator
and what performance benefits we can
gain in real actual numbers so if you're
interested in that at the end I'm going
to have my webpage off the introduction
- that should be going up tomorrow
assuming conference doesn't get in the
way it's all written I just need to
become a web programmer
but of course no good work happens in a
vacuum and these are that there are tons
and tons of resources on this but these
are three things that you might find
really useful so if your your interest
in that Google then accept elements of
programming that's a book by it
the iterators I presented here are based
on but a little bit different than the
the iterators in elements of programming
and I think never me Brewers here so
thank ok so he's not here but email him
and thank him for contiguous iterators
because they're great they're really
wonderful
and they're in C++ 17 I guess that's my
cue to leave so um we were exactly an
hour in I don't you probably want to get
to the plenary session so if you have
questions I'm going to ask you to come
up and ask them to me now so we can get
everyone else sleeping if they oh thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>