<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Giuseppe D'Angelo “Effective Qt (2017 edition)” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Giuseppe D'Angelo “Effective Qt (2017 edition)” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Giuseppe D'Angelo “Effective Qt (2017 edition)”</b></h2><h5 class="post__date">2017-10-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uZ68dX1-sVc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Okay, it is time to start.
Hello everybody, good afternoon,
I hope you have been enjoying
the conference so far.
Yeah great, thank you.
My name is Giuseppe D'Angelo,
I work at GitHub,
I'm a software engineer,
I work on a lot of
Qt-related projects so I
decided to share a little bit
of my insights about what is the best way
I think you should be using Qt these days.
The title of the talk says,
Effective Qt: 2017 Edition.
What's the deal with that?
Well the title, effective, of course,
pays homage to Scott
Meyers' series of books.
So in this talk I'm
going to present advice,
just one sentence or two sentences,
and then I'm going to explain
why I think you should be
using Qt in one way or another.
And the 2017 part is about
the fact that the advice
I'm going to give you
is about today.
It's the best thing that
we can do at this moment,
but especially you, if
you're watching this video
in 2039, please reconsider
what I'm just about to say.
Yeah, please verify that
what I'm going to say
still applies.
So what is it that we are going to say?
We're going to discuss
a few areas in which
Qt and C++ as a language
and as a library are moving,
in particular, the areas that intersect -
the two are a little bit
of a gray zone right now,
so I would like to shed
some light on what to do.
So we're going to discuss a
little bit about Qt containers,
what's the deal with them?
In particular, we're going
to discuss something we call
implicit sharing, a tool called Clazy,
I discuss a little bit
about Qt string classes,
and then if there is time at the end,
or if you ask the right questions,
I've got bonus slides as backup.
Alright, so let's get started.
Suggestion number one.
Understand the Qt containers,
and prefer the Standard Library ones.
Don't use the Qt containers
unless you have to.
So you already look shocked.
Come on, you use Qt and you
already immediately say,
don't use Qt containers, what?
There must be something good in there.
No, there is something to say about this,
there is a whole story, so
let me explain this point.
Qt, if you don't know --
so I'm just asking, how many
of you are using Qt as of now?
Yeah, I'd say the big majority.
So you should know that Qt ships with
its own set of containers.
The reason that Qt
ships its own containers
are pretty much historical.
Up to five years ago, Qt
needed to work on platforms
without a Standard Library.
As surprising as that sounds,
it's also, such platforms
that existed still exist.
The second reason was that
Qt didn't want to expose
Standard Library symbols
from its binary interface.
So Qt had to basically
reinvent the containers
to work around these limitations.
Luckily, these reasons are historical,
because now, since Qt 5,
we require you to have
a working Standard Library.
But nonetheless, Qt still
has its own containers.
These containers are exposed by Qt APIs,
and the things is this.
These containers are eventually available
for your own applications.
So people who are using
Qt naturally just find,
oh, okay, I got these
things coming from Qt,
why don't I use it also
in my business logic?
Right?
Well, let's think.
That &quot;right&quot; part is not
quite entirely accurate.
Let me discuss about these Qt containers.
Where do they come from?
Qt containers are not
just a re-implementation
of the Standard Library
containers, something like that.
Qt containers are drastically different
from the Standard Library ones.
In particular, some design
decisions were made back then
to focus more on ease
of use and productivity
of the average developer, rather
than being extremely strict
and accurate and correct,
like the ones that come
from the Standard Library.
This deeper code shows a few differences,
a few qualitative
differences that you may see
between the Qt containers
and some library ones.
So for instance, I'm
here creating a QVector,
so vector integers,
and there is only one
template argument to QVector,
that's the data that bit holds.
There is no allocator,
there is no advance-use case.
Just, okay, that's a
vector of integers, period.
How do we fill it in?
Oh, there is this nice,
overloaded left shift operator
that you can use to chain,
basically, push_back s
into a vector, yeah that's nice to write.
I can take a copy of a vector,
so create a vector, v2 from
v1, from the first one,
and that copy's cheap.
We're going to see why that copy's cheap,
but basically, that's not a deep copy,
that's just a refcounter increase.
How do I check if a container
contains a given value?
Well, the answer for
the Standard Library is,
use an algorithm.
In Qt we said, perhaps its
nicer if we could just add
a few convenient member functions,
right on top of vector.
So you can write something
like, if v2 contains
a certain value, do something.
And finally, Qt favors
certain kind of wording,
a certain kind of
expressiveness, so to check
if that container is
empty, you write &quot;isEmpty&quot;,
you don't write &quot;empty&quot;,
which might be ambiguous.
So they're very different
as you might see.
If you're used to see the
C++ style of writing things,
this style may surprise you.
So what containers do come with Qt?
I made here a brief list of Qt
installed library containers,
in particular the linear containers.
They're not even all, but
from the Standard Library
there are even more,
there are also adapters,
I just made a few.
So in Qt we have QVector,
which is a rough correspondence
of std:vector, it's a linear container,
elements are allocated in
a contiguous memory region.
We've got something called QList in Qt,
which has no Standard Library equivalent.
That is that.
There is a Linked List in both
Qt and standard libraries,
and libraries have now
also got forward_lists,
so single, linked lists.
And there is in Qt another
guy called QVarLengthArray
which does not have a
corresponding container
in Standard Library, then the
Standard Library has many more
such as deque, array,
so-called, all the adapters,
such as queue, stack, priority queue,
there is value array,
those don't exist in Qt.
When it comes to associative
containers, Qt also has them,
of course, there is Map,
there is MultiMap, there is Hash tables,
there is MultiHash tables,
and there is QSet, which is
not like the standard set.
It's like an unordered set.
So a QSet is not ordered,
it's just a set of elements.
Let me spend just a couple of words about
the couple of containers that Qt has
and a Standard Library does not have.
In particular, the first
guy, QVarLengthArray,
what is it about?
QVarLengthArray, perhaps
you have heard about it
under another name like small_vector.
It's a vector which preallocates
a buffer internally,
so that if you don't
need to grow too much,
this guide may avoid hitting the heap.
It can store all the elements inside of it
without allocating memory
from the free store.
Otherwise it will reallocate,
it becomes just a vector.
So this is extremely
useful when you can know,
you know, in advance, yeah,
I think that on average,
I'm going to require up
to a certain small number
of elements, let me
preallocate them right inside
the VarLengthArray object,
instead of allocating
on the heap every time.
This can have some significant
performance advantages.
The other guy that Qt has the
Standard Library does not have
is this guy, QList.
So first and foremost, what is QList?
It's not a linked list,
it's got nothing to do
with linked lists.
It's like a vector,
it's an array vect list.
But its behavior is very surprising.
Depending on the type
you put inside QList,
this can either be just a plain vector,
so elements are allocated
to continuous memory,
or can become an array
of pointers to elements.
So each and every element
gets allocated individually
on the heap, using a virtual node,
and then the vector store points to them.
These differences, the
fact that QList has this
surprising behavior,
depending on the type you put
inside of it, and especially
the fact that this
may turn out to be just a
vector of pointer things,
so it will have terrible performance,
makes me recommend you to just avoid it.
In case you're very curious,
I've got some bonus slides
about how QList exactly functions.
The recommendation for this
one would be, just avoid.
So let's go back to the
beginning of this section.
I said, understanding Qt containers,
so here they are, and avoid them.
But why?
There's a huge number of reasons
to avoid them these days.
I have to say that the first
and most compelling reason is
they're not actively being developed.
You should not be using
something that is not actively
being developed while, on the other hand,
on the Standard Library
container, we've got
a lot of activity, a
lot of things going on.
In general, the standard
containers are faster,
expand to less code,
are more tested, because
they're also used outside of Qt,
they're used by the broader C++ community,
and of course, typically, the
Standard Library containers
you're using coming from
the very same people
that are writing your compiler.
So you know they're pretty well-optimized.
The features of the Qt
containers are greatly inferior
to the Standard Library equivalents,
I made here a brief list
of them, but actually,
it could go on for slides
and slides and slides.
To give you just a sample, the
datatypes that Qt containers
hold must be default
constructible and copiable,
which as a requirement, these
days, is really laughable.
They have no exception
safety guarantees whatsoever.
Yep!
Several C++98 APIs are still missing
for reasons, you don't
have range construction
and range insertion inside Qt containers.
Most of C++ APIs are still
missing, for instance,
there is no emplacement,
and all the post-C++ APIs
are missing, for instance,
all the node-based APIs now,
map and unordered_map, as we've got
in the Standard Library.
In addition to that, of
course, you don't have
any flexibility when it comes
to allocation, comparison,
hashing, as I told you.
All the various template
arguments that you can use
to initiate as a standard map,
they're not there.
You just allocate a map
with a key and a value type,
that's it, yeah.
Inside Qt, also, you've
got inconsistent APIs,
so for instance, there is Qvector append
overloaded for R values,
there isn't one for QList.
Some people just forgot it, or they didn't
consider it was a good idea.
In general, yeah, so, all these reasons
should make you very aware
that you should avoid
using Qt containers for your own code.
So which ones should I use?
My recommendation would be
for many important metrics,
you stick to the Standard
Library containers.
This recommendation is
so good that, actually,
Qt is already using
Standard Library containers
inside its own implementation.
However, there is this thing
that Qt has a very strong
API contract, so we can't
just change our APIs
to take and return to
Standard Library containers.
And for that reason, Qt still
exposes its own containers
at the API level.
And my recommendation
would be, do the same.
Prefer the Standard Library
containers for your own code,
especially for your business logic.
Use Qt containers only if
you don't find anything
in the Standard Library that suits you,
but that's very unlikely these days.
And use them when you must use them,
that is, when interfacing with Qt itself.
That's the only moment when
you really need to create
a Qt container, to pass
it through Qt APIs,
to receive it from the APIs.
So there is that.
Consider using them when
interfacing with Qt,
rather than converting back and forth,
because that's pointless.
What advice, what's going to happen
in a couple of years down the road
when we're going to release Qt 6,
the next major version of Qt,
where we can break some API?
I don't think we're
going to break anything.
I think that unfortunately,
Qt will need to stick
with its own containers and its APIs
for a very, very long time to come.
So, there's that.
We're just going to accept it.
I hope that in a couple years,
we also have much better
refactoring tools,
so eventually we will be
able to give something
to developers to move away
from the Qt containers
in their own code.
But until that moment
comes, unfortunately,
the Qt containers are here to stay
for the foreseeable future.
So don't worry about them
disappearing tomorrow
just because I told you,
hey, don't use this stuff.
We're not gonna remove it,
don't worry about that.
Okay?
Alright.
Suggestion number two.
If you do need to use Qt containers,
for instance, for interfacing with Qt,
remember to use declare_typeinfo.
Remember to declare some type traits
for the Qt containers.
What's the story with type traits?
Nobody told me that you needed type traits
to insert a type into a container.
Qt uses a few type traits
to basically just optimize
the handling of datatypes
inside their own containers.
And the most important
optimization that Qt can do
with a given container,
with a given datatype,
is this one.
When growing an array of
objects of a given datatype,
can I just use realloc?
Let me actually rephrase that.
If I open a C++ textbook,
and I open the paragraph that
explains how a vector works,
what happens when I come
down to an explanation
when a vector needs to
grow, needs to realloc?
The paragraph says this.
The paragraph says, what
a vector is going to do is
allocate a new chunk of memory,
it's gonna move the elements
from the existing chunk
of memory to the new chunk of memory,
plus we'll, by using
the move, if or accept,
or something like that,
if that works, vector is
going to destroy the elements
in the older copy, and
it's going to deallocate
the other copy.
Those are all the steps that
are necessary in order to
resize a vector, right?
If I open that C textbook,
and I come to the paragraph
that discusses more or less the same,
how do I reallocate an array,
they just say, use realloc.
Realloc, what does realloc do?
Realloc reallocates a
bigger chunk of memory,
and if needed, it will
then copy the memory
from the older one to the newer one.
So we just apply memcopy to the contents,
and move them in the other position.
There's no need of calling a code
that invokes move constructors
or copy constructors
and destructors, right?
However, there is a catch.
Is it always safe to use realloc?
Well, not always.
This is safe to do, only if
the type is what we call,
relocatable.
What does that mean?
Relocatable is not a C++ trait,
it's not a C++ definition.
Relocatable means you can
move this type in memory
by using memmove, by using memcopy,
without breaking instances of that type.
It turns out that many, many datatypes,
especially old Qt value
classes, most of them,
benefit from such optimization
because they are movable,
they are relocatable in memory,
and therefore, you could
just grow arrays of them
by using realloc.
So let me discuss this property,
this relocatability.
I will never be able to say that.
Re-lo-cat-a-ble, okay, whatever.
Is this, can we relocate --
yeah, better -- this type in memory?
Suppose we've got this type,
which is a vector of integers,
not templated, right.
It's got a size, it's got a capacity,
and it's got a pointer
to the actual array.
Can I move instances
of this type of memory
by using memcopy or memmove?
Pretty much, yes!
I mean, assuming the
implementation is reasonable,
it doesn't do anything crazy,
I could just copy these
elements byte by byte
in another position, and
obtain something that works.
Let me ask something else.
Can I relocate instances of this type?
So this is like a Pimpld type,
the type is just a pointer to a struct
that contains the actual data,
it's somewhere in memory.
Can I relocate this type?
It's a yes, but the actual
answer is, it depends.
It depends on something,
it depends on whether
the parent part has a pointer
back to the public one.
Because if that's the case, you
cannot relocate this memory.
You need to patch the point,
or you need to run some code.
So it depends.
You need to more about this.
If the parent is a link back,
the type is not relocatable.
What about this one?
That's like a node in some
kind of tree structure,
so the node itself has some
data, then it's got a pointer
to the parent node, and a list
of pointers to the children.
Can we relocate this?
You see too many pointers,
no, this is not safe.
Indeed, this is not safe
in general to relocate.
We say that the address of
such a node is its identity.
We identify such objects by
actually its addressing memory.
So that is definitely
not safe to relocate,
because moving it in memory
would break the pointers.
How about this type?
So this is like a string class,
it's got, again, a size,
capacity, a pointer,
and a buffer in there,
like, 32 bytes of data.
Who says yes, who says no?
Who says depends?
Depends still who is good.
Yeah, ultimately, again, it depends,
because the answer, the real deal is,
what's the data thing there for?
If the data is some sort of
short string optimization,
then you cannot move
these types of memory,
because begin may point to data.
This is such an example of
self-referential datatype.
A type that points into itself.
So if you move it in memory,
you're going to break it.
However, if I'm using
data from some extra data,
that's just attached with a string,
that's nothing to do with
the actual string payload,
then yes, this type is now relocatable.
The point I'm trying to make here is this.
The compiler cannot just look at a type
and figure out if it
is relocatable or not.
You must tell the compiler.
Only the authoral class knows.
That is just a decision
how you design your type.
So for that reason, Qt and other libraries
decided to add the type
traits to tell the containers,
yes, this particular type is
safe to allocate in memory,
this other type is not safe to allocate.
The way we do that in Qt is by using
that Q_declare_typeinfo macro,
eastl, which is a
permutational Standard Library
by Electronic Arts, has
something which does
exactly the same thing, it's called
eastl_declare_trivial_relocate.
Surprisingly, the Standard
Library's still not figured out
how to do this in itself,
so there's still nothing
in the Standard Library
supporting this, I guess that adding it
would make so many breakages
all over the place,
but yeah, I would try to insist,
because we want this into
the Standard Library.
So how do we use that Qt macro
or that Q_declare_typeinfo macro?
We use it this way.
We just write the macro,
Q_declare_typeinfo,
the type for which we
want to declare the trait,
and another tag, which says
something about that type.
We've got three kind of tags,
let me start with the bottom one.
The default is something
we call a complex type,
a type from which you
cannot assume anything,
you must call all the
constructors, all the copy and move
constructors, all the
destructors, that's the default.
Or, you may decide to
declare the type movable,
meaning you can move this type in memory
by using memcopy or memmove.
So you only need to call
constructors and destructors
while creating instances,
but if you have any existing
instances that you want to move
to memory, just memcopy
it over, that's fine.
And there's also a further
one, called primitive_type,
which is even one step beyond that,
which means that every bit
pattern is a valid object.
So a primitive_type is also movable,
but that's something
else, I'm not going to
discuss it right now.
So in practice, this
is how you should work.
You declare something,
like that IntVector struct,
which is our vector integers,
and after it you declare
type traits using the macro.
Remember to do it, because adding a trait
&quot;after the fact&quot; you forgot,
yes, it's certainly possible,
but it's a possible binary
compatibility break.
So if you have strict ABI guarantees,
like Qt S, you cannot
just patch after the fact,
you must remember it
when you create the type.
So for each and every type
you're going to put into
a Qt container, remember to add this.
There is a solution for this,
I'm going to show it in a few slides.
Okay!
Let's keep talking about Qt containers,
or in particular, about Qt value types,
and let's understand one
of the design features
of Qt containers.
Qt containers and Qt
value classes in general
are implicitly shared.
So the title here says,
understand implicit sharing,
understand what it means,
and be careful about
something that we call
hidden detaches, be
careful about what happens
when things go wrong.
So what do I mean by &quot;implicit sharing&quot;?
That's just a buzzword, yes it is.
Implicit sharing is a fancy
name for reference counting
combined with copy on write.
Do all of you know about
reference counting?
Yeah, that's pretty much
an established technique.
Do you all know about copy on write?
That's also an established
technique, yeah.
So implicit sharing is the
combination of the two.
It's nothing new.
A Qt value class
implementation is typically
something very simple.
A Qt value class implementation
is just a pointer
to a payload.
Inside that payload, we've
got a reference counter
plus the actual data of the class.
And during an object's lifetime,
we're going to manipulate
that refcounter in the following way.
So when you create an object,
the refcounter is plus one,
when we copy an object, what
we're going to do is put
another pointer to share the payload,
and increase the refcounter by one.
When we destroy an object,
we're going to decrease
the refcounter by one,
and if it goes back to
zero, then it means, okay,
now it's safe to reallocate
the whole payload.
When we call a const member
function on a Qt value class,
then we just call it, there
is nothing to go about
the refcounter, but
here's the important part.
When we call a non-const member
function, then we must copy.
We must check if the refcounter
is greater than one, yes,
then please deep copy this structure.
We call the operation of
deep copying detaching
from this sharing the
structure into my own copy.
So here it is in action.
I got a vector of int,
the vector itself is just
one pointer, it's a very
small class, that points
into the actual payload.
The payload contains
the reference counter,
some bookkeeping, and then the data.
So that's the situation.
Now I take a copy of a
vector, and taking a copy
is nothing more than setting a pointer
and increasing the refcounter.
That's surprisingly cheap
to do in general, right?
Unlike standard vectors, for instance.
Then what happens if I want
to modify these containers,
for instance, I want to change v2?
The operation of the subscript operator,
that's a non-const member function,
so as such, I need to detach
from the shared structure.
I need to make a deep copy.
So what I do, is I do
a series of operations,
I will deep copy everything,
decrease the refcounter
of the original, now we've
got a new allocated chunk,
so the refcounter is
one, and then I modify
my private chunk.
So v2 is now correctly
modified and contains 99.
Everything clear?
Yeah, that's pretty much straight forward.
Why is this good, why has
this been adopted by Qt?
Well, first and foremost, because C++ 98,
we did not have move semantics,
so we wanted to make writing code simpler,
we wanted to make extra
term containers like value.
In C++11 that's for granted,
yes, we've got move semantics,
but back then, we didn't.
So we used this mechanism in order to cope
with the complexity.
We said, let's make it
easier for developers
to pass containers around,
to determine their value,
to pass their value, sometimes,
take copies without taking twice.
Because most of the time,
you're just going to do
some refcounter manipulation,
and not actually
do any expansive deep copy.
For this reason, the great
majority of Qt value classes
are implicitly shared.
All the containers,
except for VarLengthArray,
QString, ByteArrays,
Variants, you name it.
If it's a value class, 99% of the time
it is implicitly shared,
and therefore cheap to copy.
So all is good, right?
Where's the catch?
The catch is, there are a few subtle bugs
that may lurking,
that mean these classes
are using implicit sharing.
I collected a few of those here,
so let me discuss them one by one.
The first one is a
subtle bug that has to do
with returning references to
some data into a container.
Here's the problem.
If I have a reference to
some data into a container,
in theory, that container should
be marked as &quot;unshareable&quot;.
I should not be able to take cheap copies
of that container any longer, yeah?
And now I have some code
to back up that statement.
The problem is that we take
references to data into
a container all the time,
when we use iterators,
when we use the subscript operator,
so for that reason, basically,
a trade-off was made
to shed away correctness,
in this case, for speed.
So let's see, where is
the correctness problem?
Here I create a vector with
three elements, and I take
a reference to the first
element in that container.
That's safe, that's okay.
Then I copy the container.
What's the situation at this point?
The situation looks like this.
I've got two vectors, v and v2,
pointing to that shared segment
with the refcounter two,
and r pointing into the shared segment.
That's because I took
the reference required
before getting the second copy to v2.
So what happens now, if I
modify the container through
the r reference, well, it's
going to affect both containers
so this situation will end up like this.
By modifying r, a reference
to v, I modified v too,
a container which should be
a complete copy of v, right?
That's not the case.
So sometimes these may bite you,
especially if you start
having problems with aliasing
or you're just taking a couple
of containers by reference,
you're not sure if they're
the same container.
You may end up modifying
one container accidentally
instead of the other one.
So that's one problem, sure.
What's the other problem?
Suppose I got a function,
this function is called
calculateSomething,
and this function returns
a vector of integers.
Okay, fair enough.
Then I call that function, I
call it calculateSomething,
but I'm not really interested
in having all the results,
I just want the first one.
So I just call it &quot;first&quot;.
If you call it &quot;first&quot;, it's
like &quot;front&quot; instead of vector,
that's the same thing.
What's wrong with this code?
Apparently nothing,
apparently this code works.
Indeed, this code does work,
but there's a subtle thing
going on there, that is,
first, just like front,
is a known const member function.
If the vector returned
by that function was
implicitly shared, and the
refcounter was bigger than one,
this code right here just
caused an accidental detach.
So what I did was deep coding the vector,
getting the first element,
and then destroying the copy I just made,
all in one statement.
Not bad, right?
So there is a solution.
The solution is easy, don't call &quot;first&quot;,
call constFirst, which
is const member function,
but it will not detach.
But these things are not so easy to spot
in ordinary code, not easy
to spot in code reviews,
typically these things start to appear
in heap profilers.
If you have a heap
profiler, this appears like
a transient allocation.
You've got a transient allocation heap
that lasts one statement.
So you see a peak there,
you say, what's going on?
Oh, I'm accidentally
detaching, that's bad.
We can go even one step further.
Not only is this a performance problem,
these accidental detaches
may actually introduce
subtle bugs in your code base.
So let's see an example of that.
I've got a map of integers to integers.
I populate it somehow, and
then I ask, does this map
contain a key?
So I use find, of the key,
the letter to the iterator
is the iterator at the end map.
If this, then, of course,
the key was not there,
otherwise the key was there.
Right?
If this was a standard
map, then you would be
absolutely correct, but
this is not a standard map,
this is a Q map.
So what could go wrong here?
The thing that could go
wrong here is that cend
returns a considerator, so
that's not a modified map.
What does that mean if the map is shared?
Find is going to return
a known considerator.
So in order to do that, it
might need to detach the map
and deep copied.
So what happens?
You can cend the first,
and that returns, perhaps,
the variant of the map.
Then you call find.
The first thing find is going
to do is deep copy the map
right away, and then it's
going to perform the find
algorithm, and perhaps it's
not going to find the key.
So it's going to return the end.
The end of what?
The end of a new copied map.
So basically, you have now
two different ends returned
on the two sides of deep collaborator,
the two ends will be different,
so this code is going to be &quot;found&quot;,
even if the key is not there.
Yup, this is extremely subtle to find.
Haha!
Is extremely subtle to
find doing the code review,
but basically, okay, again.
We got a solution, the
solution is always called
constFind, but actually
dealing with this code
with bugs in production
code, is very, very tricky.
There is a solution
coming in a few slides,
don't worry too much, but yeah.
These are the kinds of
things that may happen.
So my advice here is this.
You need to understand implicit sharing,
because if you're using
Qt, all Qt value classes
are implicitly shared,
just be aware what you're doing,
be extremely aware not
to fall in these traps.
The position of the Standard
Library in this regard
is very, very clear.
Some containers in the
Standard Library were
or could be implemented using
implicit sharing in C++ 03.
Since C++ 11, Standard
Library basically forbids
implicit sharing for all its containers.
Qt will not move away,
don't worry about that.
There is simply too much
code written out there
that relies on these
mechanisms, relies on the fact
that you can take a copy of
a vector, and it's cheap.
So implicit sharing,
again, is here to stay.
Okay.
Let me add another nail in the
coffin about implicit sharing
just to do with iterational containers.
So Qt has something called Q_FOREACH,
that's its own version of
iterating over a container.
Just don't use it.
In C++ 11 we got something better,
which is called the range based for.
Just be careful about how you use it,
and let's see why.
Here's the very definition,
well, it's not the actual code,
it's the exposition of Q_FOREACH loop.
Again, this made sense
in pre-C++ 11 world,
where we didn't have range for.
So we had a macro that more
or less expands to that.
I got, for each variable container,
kind of the body of the container,
the body of the loop,
what for each it's going to do is
evaluate the container expression
and assign it to an object.
So basically, make a
copy of the container.
By the way, first thing.
There is no reference there.
That is taking a full
copy of the container.
This copy's const, by the way.
Then I'm going to basically
open up a couple iterators
along with that container,
actually, over the copy,
and then I'm going to
iterate over the copy.
Do you see that?
Yeah, I take the copy,
I drag this over the copy,
and perform the iteration.
And code the body every step.
What is the problem with this?
Well, this has endless problems.
First, it takes a copy.
So if I'm accidentally passing
a Standard Library container
there, this is going to cause
a full copy of the container.
If I pass a standard vector in there,
this is going to copy a standard vector,
and perhaps I don't want that.
Actually, I almost never want that.
The second problem is, this is iterating
over a const copy of the container,
so a mutating loop is possible.
I cannot modify the container
because those i and e
would be const iterators.
And what's worse, those
are const iterators
on a copy of the container,
so they have nothing to
do with the original.
Yeah, so, it's just bad.
Don't use this, ever, okay?
Con, con, con, just don't use it.
There is a pro,
and I put it between quotes,
you know, Doctor Evil pro.
It's always safe to modify
the original container
from the body, because you
are iterating over a copy.
Just don't do it, forget that this exists.
Don't use it in your code
base, if you're using Qt,
define that macro, QT_NO_FOREACH,
which will disable the FOREACH loop,
and I'm going to personally
remove this from Qt 6.
So, yes.
So just don't use it, okay?
Why, also because we have
a better solution for this.
We've got a much better solution.
The better solution, of
course, comes with C++ 11,
it's the range-based for loop.
The syntax looks like
that, it's for, variable,
colon, container, then the body.
This looks, when evaluated,
again, just exposition,
that's not the actual code,
but will turn out to
be something like that.
So you evaluate the container expression
and assign the result to a reference,
not a copy, a reference.
Then you call begin and end
of whatever you just obtained,
and then you iterate.
This looks good, right?
So let me ask,
what happens if that
container is, for instance,
a standard vector of objects T?
In this case, so.
C is going to be
a known const reference
to standard vector T,
and i and e, the iterators,
are going to be mutating iterators.
So now we can mutate
the original container
from within the loop.
That's great!
So let me ask one further question.
What happens if container is QVector?
In this case, c is going to
be a known const reference
to QVector, and i and e
are going to be mutating
iterators into QVector.
So both, by definition, we
need to detach the vector.
Because I'm possibly modifying the vector.
And this decision takes
place before even considering
what's inside the body.
So what if, inside the
body, I'm not modifying
the container at all in the end?
I'm just reading from it.
Sorry, the syntax does not say that.
The syntax says, you're
about to call begin and end
over a non-const container,
I'm going to deep copy it if it's shared.
End of story.
So there's a possible
detach happening here,
even if you don't modify the container
from putting the loop on the body.
Sorry, within the body of the loop.
Got it the other way around.
That's just the way it
is, that's the syntax.
And finally, what happens
if instead the container
is a const standard
vector, or a const QVector?
Well, in that case, c is
going to be a const reference,
begin and end are not
going to detach anything,
because what they need to
return are known const,
known mutating iterators,
so const iterators,
so everything is fine.
So to recap.
This is the situation.
The situation is that,
if you use Qt FOREACH,
and you accidentally pass a
Standard Library container,
that's going to deep copy it,
because Q_FOREACH takes a copy.
If you're passing a Qt
container, everything is fine,
because taking a copy
of a container is fine,
because it's cheap.
Forget the first column
exists, don't use it.
Use the range for loop,
so the second case is where
you have a mutating loop,
in which case, of course, I must pass in
a known const container, in
which case it is okay to detach
if I'm using a Qt container,
because this is a mutating
loop, I need to modify the copy.
If I'm creating a
non-mutating ranged for loop,
then beware that this
may detach the container,
even if you're not attaching
the container from without
the body, from within the body.
How do we work around that?
There is a solution in C++ 17, yay!
A solution is basically if
you've got a non-const container,
make it const, and then pass
it to the ranged for loop.
A way to make it const is by using
a standard as_const,
which is a new library feature in C++ 17.
In Qt, we realized many
people cannot wait for C++ 17
in their own tool chain,
so we also have qAsConst,
which does exactly the same thing,
converts a non-const L value
to a const L value reference.
That's perfectly fine.
So this is the way
you're supposed to do it.
You create a vector, you populate it,
and then you call a ranged for loop,
by calling qAsConst vector.
These will never detach,
because the vector return
will be const.
For various technical reasons,
this qAsConst does not work
with r values, so if
you've got an r value,
the easiest solution is,
just capture this out
somewhere in a local const variable,
and pass it to the loop.
Alright.
So many problems so far.
Can we see some positive news?
So this talk is not just a downer,
but let's see something good.
There is some good news,
there is some light
at the end of the tunnel.
Run clazy on your code
base and fix its warnings.
So what is clazy?
Clazy, it's an opensource
clang-based tooling
that will detect all the
mistakes I have just shown you.
It's opensource, just go
on GitHub, download it,
it's pretty much like clang-tidy.
How many of you have heard of
clang-tidy or have used it?
Yep, so it's a linker.
Something that you can
run over the code base,
and these will fire warnings
about Qt-specific usages, or
should I say, misusages of API.
And everything I've just shown you
about detaching temporaries,
about mixing iterators,
about forgetting typeinfo,
about using FOREACH
in your code base,
clazy, these days, detects that,
and reports to you back from its warnings.
And if you believe that
you're so good that you're not
going to need this, okay, maybe you are.
But let me just leave you some numbers.
We, just as an experiment, ran clazy
on Qt itself, and as of yesterday,
there were over 9,000 warnings
detected over Qt. (laughs)
Yeah, that number is the important part.
So please be aware, it's
extremely easy to fall into
one of these traps.
Luckily, now we've got this tool.
Something awesome about
this tool is the fact that
it also supports fix its.
So for situations in
which there is also a case
that will suggest how
to fix it, or possibly
automatically refactor your code
in order to fix the potential problem.
Okay, right, that was great.
So, now for something
completely different,
let me talk a little bit
about Qt string classes.
In particular, about a new one,
which is coming in Qt 5.10,
which is due to be released
in a couple of months now,
which is called QStringView.
I'm pretty sure that you have
heard in this very conference
something called standard
string view, right?
Isn't that the most awesome thing ever?
Yeah, it's also coming to
Qt, under this other form
called QStringView.
But before we get there,
let's discuss the first part,
understand the Qt string classes.
So, let's count altogether.
In how many ways I can create
a string when using Qt APIs?
Well, one first, yeah,
too many, yes, too many.
(laughing)
Yeah, in fact, these kinds
of slides is also misleading.
So the first way is just like if you want,
try literal, I'm not
going to consider this
because this has nothing to do with Qt.
So the first one would be
something that would go like that,
QByteArray string.
Or perhaps something called
QByteArrayLiteral string.
Or maybe something like QString string.
Or QLatin1String string.
Or QStringLiteral string.
Or maybe Qstring fromLatin1 string.
Or maybe Qstring fromUtf8 string.
Or maybe tr string.
Or maybe QStringView, and now
we need Unicode UTF-16 string.
That's lots and lots of ways
of creating a string in Qt.
Okay, so let me clarify a
little bit about what's going on
in this slide one block at a time.
But you will let me discuss the classes
that have been involved in here.
The first class to
discuss is the first guy,
called QByteArray.
QByteArray is basically
just a sequence of bytes.
A byte array.
It's not a string, because it
does not specify any coding.
And we know about something like this in
the Standard Library,
that's standard string.
This is just a collection of bytes,
it does not have any coding,
and therefore, as such,
it's not a string, it's
a sequence of bytes.
It is implicitly shared, just
like all of Qt value classes.
And in particular, its
constructors will allocate memory,
just as you would expect.
Yes, there is a clutch,
there is something called
QByteArray fromRawData
to avoid some allocation,
just don't use it, it's time for standard
string view these days.
In order to build a
QByteArray without allocating,
there is direct support for something
called QByteArrayLiteral.
That's going to build a QByteArray object
without allocating memory.
That's great, indeed,
so if you have a function
that expects a QByteArray
and you just want to
pass an instance of it
without creating it every time,
use the literal part of it.
And in particular, use
QByteArray in general
just to store byte arrays.
Don't store strings in there, thank you.
Okay?
So similar discussion about QString.
QString, it is a string,
because it is encoded
in more specific encoding.
The encoding that was chosen for Qstring
a long time ago was UTF-16.
You may disagree with that decision,
sorry, it's too late to change it,
this decision has been made 20 years ago
and very simply, too much code
out there relying on that,
we cannot go back and change it.
The good news is, this class
is fully Unicode-aware,
so it supports all sorts of
Unicode-aware manipulations
unlike the Standard Library counterpart
which, yes, stores UTF-16 code units,
but has no full support for Unicode.
You will need an external
library for that.
So QString in particular, again,
it's implicitly shared, its
constructors allocate memory,
and in particular, its named constructors,
such as fromUtf8, fromLatin1,
that allocate the memory.
It has the same clutch,
just like QByteArray has,
like that fromRawData to a
non-allocating constructor,
ignore it, there's QStringView these days,
and if you need a way to build
a QString without allocating,
there is QStringLiteral.
QStringLiteral will decode
the data passing there
from UTF-8 to UTF-16,
and will build an entire
string which is then
going to be stored in,
typically, the readonly segment
of your binary or your executable.
So QString is the clutch
that you are supposed to use
to store strings - Unicode strings,
and particularly, all
strings that the user
is going to see on the
screen, or interact with.
Never use QByteArray for that.
How about the third one, QLatin1String?
This is kind of unique in the sense that
it is just a thing wrapper
around a pointer and a size.
And nothing more.
It does not manage anything,
it's actually a literal type
according to C++ definition.
The reason why this type exists is because
we can implement things
better when we can do
some optimizations related to the fact
that we know a certain char style sequence
is a Latin-1 string.
So for instance, if you
take a look at the QString
documentation, you will find
that the startsWith function,
the function that detects whether a string
has a certain prefix, has an overload.
For another QString, or for QLatin1String.
Why is there such an overload?
Because we can implement the second one
in a very efficient way.
So if you just need to
check whether a string
starts with a certain sequence
of Latin-1 characters,
you may avoid building
a QString just for that.
QLatin1String has virtually zero overhead,
actually it has zero
overhead, because it just
passes a pointer and a size, nothing more,
we can do some serious
optimizations in the code
that starts with, for Latin-1 strings.
If you're curious, ask me, but basically,
this, on good processors,
boils down to one loop
around the capital processor instructors.
It's just a cmd unpack and comparison.
Apart from this, in QString,
QByteArray there hasn't been
much development, so if
you're really, really curious
about the usage, there
is another great talk
that has been given a couple years ago,
that just deals with QStrings.
I'm not going in further
detail about QString,
QByteArray, because I
want to talk very briefly
about the new guy, which is QStringView.
So QStringView is basically
standard string view
over QString data.
Actually, it should say
over QString-like data,
because QStringView is
basically just a view,
just a non-owning container
over anything that looks
like UTF-16 strings.
So you can be like
QStringView over a QString,
over another QStringView,
over a standard UTF-16 string,
over an array of char16_t,
you can pretty much build
these guys out of anything.
And the good news is that,
just like standard string view,
this offers, basically,
the majority of Unicode
const QString APIs without
the need of constructing
a QString first.
So if you need to do const
Unicode manipulations,
you can apply them on top of QStringView.
How do I use it?
Well basically, the parameter
use case for these guys,
for QStringView, just like
string views in general,
is as an interface type.
If you've got a place in
your code where you expect
some Unicode string data,
but you don't need to store it anywhere,
use QStringView.
Examples with API, we have
something other than Qt,
suppose you've got like a document class.
This document class, you
need to find a substring,
and if you find it, return
an iterator of where
that substring appears in the document.
So what kind of data should you pass?
What's the type of the substring
that you want to pass in?
You can choose, it can be QString,
but if it's QString, that
means you need to allocate
that string every time
you call that function.
That's not exactly good.
It could be QByteArray, but
QByteArray should never be used
doing string manipulations,
so don't use it.
It could be QLatin1String,
that works if and only if
you want to limit yourself
to Latin-1.
In general, this is not
good for finding any sort
of Unicode substrings.
The proper solution for
this would be QStringView.
QStringView basically is Unicode-safe,
it never allocates, and moreover,
you can build it from a
huge variety of sources.
So for instance, I have a document,
and I call find, passing
a Unicode string literal.
Just like that.
No need to allocate anything.
Or, perhaps, you do have
a substring allocated
in a QString that you want to find.
Just pass that QString in,
it will implicitly convert
to QStringView.
Or perhaps you want to
just pass in a substring
of a bigger string.
There's no need to allocate
anything, you just build
a QStringView as a substring
of a bigger string.
That won't allocate memory.
It's great, so we're going
to use it everywhere.
Another example that I
have that I have been using
QStringView for in Qt, will
be as an alloc-free tokenizer.
Suppose I've got a big string,
and I want to run a
regular expression over it.
And every time I run the alloc expression
I want to extract the
substring, capture it,
a regular expression.
There is no need to allocate anything.
The memory's already
allocate in the string,
the first line, right?
So now we can finally return the views
into a regular allocated data.
That's just great.
So basically, QStringView
will be a game changer in Qt,
pretty much just like standard string view
is going to be a game changer
in all of your C++ APIs.
We have a problem, however,
which is that in Qt,
we already have a huge number
of APIs that take a QString
and don't need to store it.
So in Qt 6, in theory,
they should all be changed
in order to adopt a QStringView.
If you're looking for some contributors,
contributions to an opensource project,
this would be great.
So we need to go, to take
our patience and go around
and fix use case everywhere.
In Qt 5 there is also another
class, which I didn't discuss,
called QStringRef, which should
be what QStringView is doing
but it doesn't for a number of reasons.
I would recommend against using it.
That's another guy that's
going to be killed in Qt 6,
so just stay away from that.
Download Qt 5.10, it's
coming out in one month,
two months, that would be just great.
And now I think I've got five minutes
for taking some questions, thank you.
(audience applause)
No questions.
Yes please!
There's a microphone in the middle,
so if you want to use it, thank you.
- [Questioner 1] I'd just like to add to
the classes that you're using there.
You have to keep in mind that the index
is an int.
Yeah, yes.
That's one, yes, yes.
That's something
that's maybe quite important.
Yes, so that's another of
the convenience thing,
that was made a decision
based on convenience,
because it was thought
that many people would be more familiar
about having a signed
integral type, not unsigned.
Actually, that discussion
is still going on
in the C++ community, whether
the unsigned is a good thing,
but yes, it's just an
integer, you cannot change it,
because it does not depend on
your allocator or anything.
It's just everywhere.
Yes, you're absolutely
right, it's one of those
convenience decisions.
So in practice, if you're
using QVector for building
a GUI or something like that,
that doesn't hurt too much.
But yes, for business
logic, it may hurt you
very, very hard if you
expect it to be big enough
to store the big numbers, yes, definitely.
Thank you.
I was wondering,
do any of the Qt containers define
cheap initializers for
their SCL counterparts?
For example, make a
QVector for a standard --
Unfortunately not, because
there is no way of doing it,
really, you need to deep copy the vector.
There is not, as far as I know,
there's not an API
possible to steal the guts.
It would be good, yeah.
Sorry, yeah.
Yeah, so you mentioned
some of the view containers
were using STL allocations
internally, hoping,
well, will there be a way
to take advantage of that?
Well, it's not that the
Qt containers specifically
are using STL internally.
Some parts of Qt are
stopping using Qt containers,
and they turned towards the
Standard Library containers
because they're better.
They're faster, they expand to less code,
they're better-tested and so on.
The Qt containers still have
their own implementation,
which is incompatible
with the Standard Library
implementation, and as far as I know,
there is simply no way
for somebody to take
a standard vector and like, okay,
I'm going to steal your
data now, you're mine.
I mean, we could add some
crazy stuff about that
if there's really the need.
All you have right now
is really QVector from
standard vector, which is
like a named constructor
which will deep copy the data anyhow,
because it needs to use
it in the Q-specific way,
sorry about that.
You're welcome.
This question's about clazy.
Will it fetch QStringLiteral
and QLatin1String misuses,
when one's a non-optimal
choice over the other?
It does have some checks
about that, yes, indeed.
I think it will, now,
I don't want to, I need to double-check
what's the current states of the checkers,
because it's got, like, 70 of them.
I think it will suggest
deleting one string
whether you're calling a
function which is overloaded
for killing one string, and
you're passing a string literal,
so it will tell you, please
wrap these in one string,
because in this case, we
can enable the fast path.
You can also disable
the QString constructor
from const star star if you want to.
There's just a macro you can define,
in order to basically see that
at a certain point in time
you're building a QString, and so, okay.
I'm allocating memory at
this line, you know that.
So maybe you're aware
about what they're doing
and perhaps decide,
okay, let me wrap this up
into a QLatin1String or
QStringLiteral, if needed.
So a combination of the
two things is possible
for you to be able to
detect what's going on, yes.
- [Questioner 3] The second question I had
was also about a QString.
So say QString is our
string class of choice
throughout the whole code base.
Is there a level or
some sort of demarcation
where standard strings start
becoming a preferred choice?
You said you use QString
for Unicode string,
or storing Unicode strings.
Yeah, and also for manipulating them,
that's the big advantage.
I mean, if you just need
something to store UTF-8, UTF-16,
code units, then any
container will be good.
But the problem, what QString gives you,
is the manipulation,
which is Unicode-aware,
so you can uppercase, downcase,
compose, decompose, all
sorts of fancy stuff,
which needs to be Unicode-aware,
which is the stuff that the
standard is still lacking
in certain corners.
So if you're using QString
throughout your code base
because you need to do these
manipulations eventually,
that's the reason.
Otherwise you don't need a string class,
you just need a container of bytes.
So the question was
about, is it a good idea?
Or ...
Um, yeah, basically.
Yes it is, because, if you
have a QString around it,
it means, I want this
to be a Unicode string,
because I need to deal with
it as a Unicode string.
So use it, definitely.
Thanks.
Thank you.
They say that world domination
starts with the strings.
(audience laughter)
- [Questioner 4] I just
want to add something
about the QStringLiteral.
Are you aware that
allocate, it's not allocate,
but it stores data in the data section.
So if you have a ...
Yeah.
Can ...
Get you in trouble, but that's available.
Yeah, so this particular
remark was about the fact
that, where is it?
QStringLiteral is going to
store the string that he creates
into the readonly data segment,
actually, of your binary.
So what if you create such a string into,
coming from a DLL, from a
plug-in, from somewhere,
and then you go into unload plugging
that's going to unload the string.
So if you still keep some reference around
that's going to crash your program,
yes, that's true.
We haven't found a good solution for that,
but I think, this is discussed in detail,
if you're really curious, on that talk
that I'm just going to reference,
because I don't want to repeat
content which is already
good on the internet.
So please go watch that talk if you're
specifically interested in all
these quirks about QString,
and QStringLiteral, so yes,
thank you for saying that.
I have so many projects
which use, simultaneously, standard,
continuous and Qt containers,
and don't you think it's
some kind of competition
between all the frameworks
and what do you think about which classes
should be used, and if it makes some
tests, which class is now
faster and more efficient?
The Standard Library ones.
They regularly beat the Qt ones
because they're more tested, more used by
the bigger C++ community,
and the number one reason
is, the people writing
the Standard Library
containers are the same people
writing your compiler.
So those people know how to optimize
those little structures, because ...
There is just that.
So that's why, also, Qt is
using the Standard Library
containers inside itself,
because they're better.
Which would you decide
to use, because it's very convenient plus,
and then no one will say, are we with it?
And the rest, switch off.
Um, pretty much yes.
So keep containers are here to stay,
because we cannot break applications.
Sorry, I mean, you should thank
us or something like that.
Because we're not going
to break your code,
but consider moving away.
So just keep using the Qt
containers at the interface level
when, from your code, you're
going to to Qt or vice versa,
for everything else, especially
for your business logic,
stick to the Standard Library one.
Thank you.
You're welcome!
And now the session is finally over,
so I'm going to just say thank you to all!
(audience applause)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>