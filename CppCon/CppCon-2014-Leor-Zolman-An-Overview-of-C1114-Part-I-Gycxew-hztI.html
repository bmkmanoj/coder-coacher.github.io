<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2014: Leor Zolman &quot; An Overview of C++11/14, Part I&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2014: Leor Zolman &quot; An Overview of C++11/14, Part I&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2014: Leor Zolman &quot; An Overview of C++11/14, Part I&quot;</b></h2><h5 class="post__date">2014-10-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Gycxew-hztI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome my name is Lee or this is a
super flows 1114 overview and this talk
has evolved over the past four years or
so it's been taught in various lengths
and each time it's just a little
different with other difference that it
could strength so for today it's a
two-part talk it could be two hours long
and covering just the language so we're
not really delving into the library at
all
basically just the language C++ 11 and
with some 14 stuff the agenda start with
a brief look at the most commonly stolen
slide in C++ this equals plus timeline
briefly cover the goals and it is a
high-level abstract description and then
we'll go into the actual features I've
organized them into the following
subsections part 1 the simpler features
of the language each of them very fairly
self-contained and doesn't interact too
much with the other part our two
facilities for class design is to make
the interact the relationships between
classes a little bit clearer and harder
to make errors that need to run time
debugging are three to the larger
features so that's broken into features
relating to initialization move
semantics and lambdas so what I've tried
to do here it's a breath not deaf
approach to these features my goals to
mention every feature that I'm aware
about of at least once and go into a
little more detail on the ones that have
a little more meat to them well will
impact your transition from old to new
C++ the most whenever practical
introduced a feature by showing what a
limitation was in old to C++ 90 803
basically and then introduced the new
C++ 11 work 14 solutions and am specific
by say 11 it's available in 11 and if
it's 14 only
so codes been tested but it won't run
exactly as you see it on the screens
because I've left out things like
includes and standard and usings in
order to make the text easier to see so
if you imagine all those things were in
there it should actually so always nice
to start with a bird's-eye view where
C++ was being first standard C++ 98 of
course and the point that I think
everybody at this point is pretty aware
of is that there was no major language
update until C++ 11 was a bug fix
versions what's actually so the point of
the slide is that the committee decided
it's not really a good thing to go this
long between revisions and introduction
of new facilities into the language so
from this point forward the increments
will come more often with a little bit
less you know overwhelmed in terms of
the number of features that are
introduced for each of these so it's a
plus 14 is almost set and I don't know
what's going to be in it and it's
considered a minor release it's really a
completion of the vision of what sequels
plus 11 was supposed to be because
usually runs out of time sometimes and
has to defer some of the features so 14
will be kind of a completion of that and
then with 17 major features but not as
many that were major in C++ 11 as
opposed to 1903 and the same sort of
things happening with the libraries and
other both language and library
subsystems instead they're being just
kind of one official standard committee
action the TR one which I'll call it the
library TR but that was TR one that was
a significant publication of the
interface for new facilities in the
library which allowed the community to
learn those facilities to get
comfortable with them before they were
officially standardized over here
now there's going to be a lot of these
little TRS now called TSS for technical
specifications and Pablo this morning in
his talk had a great term for these
problems for pseudo standards so they're
not official standards yet but there's
close as
a document can be to the official
standard without actually having it
ratified by the entire committee of
course you realize the status committee
is an international like working on
international treaty because of all of
the politics so that's why those things
take a long time so all these facilities
will be published and folks can start
working with them then then we
standardize them around here and that's
what the transition and openings work
goals the new C++ makes c++ easier to
teach learn and use and it succeeds on
all those levels the one as a as a
trainer and a sequence plus educator the
teach one was pretty exciting to me the
feature that was supposed to primarily
facilitate that was concepts which was
dropped from simplistic so even without
concepts I believe it still is easier
without as much easier as it will be
when concepts in standard at some point
in the future maintain backwards
compatibility of course that's always
important you want to break existing
code bases and for the most part they've
done a pretty good job there are some
breaking changes but again when you look
at the specific cases it's code that
probably should have been fixed for
other reasons and the fact that sequel
Swiss 1114 breaks it is not that big a
deal because it's not great code in the
first place that's I think that captures
the majority of cases it's not actually
that much compatible improving
performance so it's a good thing
strengthen library building facilities
it's the features for class design allow
a programmer to be a lot more explicit
in the relationships between types so a
whole bunch of error is that the
compiler would not be obliged to catch
an old C++ now can't catch if you if you
empower the compiler to do that by using
these facilities and the last one
interface more smoothly with modern
hardware that's really code for
concurrency modern hard was moving to
multi-core environments the language now
supports that directly through
standardized multi-threading major goals
lifted this little tidbit from yarns FAQ
on C++ 11 pieces just fit together
better than they used to I find the
higher levels that I would program more
natural than before and as efficient as
ever
little understatement there because it's
actually more efficient alright so this
is what we're gonna cover in part one
the smaller features instead of telling
you I'm going to tell you I'm just going
to tell you let's look at a piece of old
C++ code so this is a function template
called find null it's not an algorithm
right you look at that and sort of say
that that doesn't count as like an STL
type algorithm because it doesn't take a
pair hitter it was just a function
template but takes a container at some
time and it assumes that it contains
pointers and it returns an iterator to
the first null that it finds or if there
is no nulls it returns and meaning the
end of the container which is the STL
convention so in old C++ we need a
return value what's the return on what
could be an iterator time giving we have
a container we can derive the iterator
type by knowing there's a nested type
called
Const iterator and use Const because
we're not intending for the client to
make the change
we're just located about you so
concentrators appropriate type to return
and then we have to throw this type name
oh my so how many of you just to give
you give me some idea how many of you
know why you have to put port type thing
here and how many not really know or you
may have seen unfortunately an old C++
this is stuff you have to understand or
else you get compiler errors
name of a nested type inside of this
type of contact haunt itself is a
template parameter so when the compiler
is compiling this code the first time
seeing that code for the first time it
doesn't know how it's going to be
specialized it doesn't know what type of
container is actually going to be passed
in here when the client calls this thing
specializes the template so the compiler
can't possibly know within this type
cont
what configurator actually is it's just
a name here and we know it's in the
scope of that thing there's two possible
things it could be if that's all you
know it could be a name of a member like
a date a static data member for example
or it could be the name of a type well
data members and types are used in
completely different statements and tax
forms they're not interchangeable so the
compiler has to be able to make a choice
of whether this is supposed to represent
a type or its most represents the static
data member and the language rules
actually stipulate the compiler must
assume that's the name of a static data
member by default so if I didn't say
type name here the compiler would listen
this is the name of the static data
member which is of course wrong and then
based on that this would immediately
become a syntax error in the early days
of C++ 98 compilers tended to forgive
this error because they just read read
the mind of the programmer and basically
put the type name in for them and that
was actually to service because code
would pass the compiler actually work
and later when compilers got a little
more strict about this that same code
would yield compile errors when it was
you know wrong on the first place we
shouldn't ask alright so that's the
story listen how long it took to explain
that the return value was going to be an
object of that type so again I have to
repeat that yeah I could use the type
def or something but considering actor
name it first up here typed up for the
wouldn't of safe and keystrokes we've
been actually more
then I do pretty much simple loop
looking for that value when I find a
mall in there then I return the iterator
to it and I never find it and it ends up
equal and and I returned that so that's
my C++ 98 old C++ final function
template how would I use it in old C++
well first I have to throw some data
into a vector so I define my vector
negative end pointers and here's a bunch
of ends and I throw their addresses in
there and then I put my knowledge so
quite a bit of rigmarole just to stick
some simple values into a vector but
that's what it used to take okay in real
life a lot of time you're not pushing
back known value as you're computing
them and all that in this case awkward
but first it's simpler the example the
more awkward it ends up looking when
there's no simple syntax for
initializing a vector so the client here
is going to call a function capture the
result of a variable what's the type
well it's a vector of n star consider
ater pop quiz why don't I have to put
type name here we're not in a template
therefore it can't be a dependent type
dependent types only happen inside of
template so that's holding our variable
if it's the end iterator there were no
null pointers otherwise now we found a
null pointer and we'd like to display
the index position of that null it's the
second one in there it should display
index number 1 sounds simple all we do
is we subtract the beginning iterator
from the iterator that came back from
fine now but what's the type of
something like that
chances are you would type size T as I'm
sorry size T is that right yeah size t
as the position and it would probably
work it would probably work but
technically that's not kosher officially
the type of subtracting to iterators is
the difference type which is another
nested type in the class that the
container producing these iterators has
so to be completely legit i need to
declare pause as a vector of n star
difference type and then i can display
the value so I'm going to start by
showing the C++ version of that slide we
just saw how would we adapt C++ 11
features to use fine now first of all
thank goodness we can just brace
initialize the vector thank you
I actually wrote a library that sort of
made up for the lack of this for people
taking classes learning about the STL
for the first time to be able to just
stick a bunch of values into a container
with such a pain that I actually wrote a
little template library just to do that
and now we can just do it in the
intuitive way good
we'd like to obsolete things that should
never have been necessary in the first
place
what does fine null return we don't have
to know the compiler does of course in
C++ you can't call a function until it's
been declared previously write that
declaration could be the form of a
definition or just a declaration but the
compiler must see that or it's an
illegal call so we know if this compiles
this call even compiles the compiler
knows the return type why not just let
let the compiler plug in what it knows
that's what Auto says in this context
and it just figures out it deduces of
course you all saw a whole lot about
that this morning from scott right so
first new feature alright nothing
different here now if we want to display
that index position again instead of
having to know about difference types we
just subtract the iterators and stick an
auto on there and it figures out that's
a that
Duren star call and call indifference
type and it just works
alright we'll return back to find all
shortly take a little bit of a detour
here here's a function template that's
impossible to write in C++ 98 it's
called product it returns the product of
two values of unknown type what do you
put for this three question marks if you
know nothing about these two types
there's no syntax to properly stick a
type in here that's going to represent
the result of that multiplication all
right if T and u were the same type we
could just pick one but if not we just
don't know and what if T in your matrix
types right the result of multiplying
two matrix might be a type that's not
either of the two original operands it's
some different type yeah way to do that
so new C++ offers a solution it's a
different use of the auto keyword so in
this case Auto is not deducing anything
Auto is used in conjunction with the
syntax called trailing return type and
that may be a familiar looking token
that's not a coincidence
committee likes to reuse existing
keywords and tokens so this means I'm
going to supply the type the function
returns back here rather than up here
the benefit of that being once we get to
this point in the translation the
compiler now sees the declarations of
tnu and it can you can use those in the
specification of the type of the return
type what's the type that this function
returns it's the type you get when you
multiply T and u or T and U or the
function parameters that's it
this generates no code this is a compile
time operation it evaluates that
expression internally without actually
generating code purely for the purpose
of determining the type
then we can use that this this part of
the code doesn't have to be a deco type
declaration it could be like int and
it's legal but that would be kind of
silly because you can just put into here
right so usually you'll see trailing
return type used in conjunction with
something like deco type which is what
is the type of this expression
the syntax of deco type is similar to
the syntax of size of and if you recall
size that has two farms size of a type
size of an object one of them you need
the parens when you don't if you can't
remember which is which just always use
parens and it always works and basically
the same rules apply to deco type in
this context just always use print
alright so now we can take a look at a
new C++ version a final will leverage
the trailing return type here and we can
pick C begin C end whatever they both
return the same iterator type whichever
strikes your fancy and that's the return
type and nothing else in here yet we
have to talk about but we will shortly
so in old C++ begin and end were member
functions that's what they were in new
C++ a non-member style of begin and end
was introduced and it allows things to
be written a lot more generically so
let's say we have a function called
string length greater than 4 that takes
a C string returns of its length that's
greater than 4 and we want to apply it
to find algorithm call actually we're
not applying it yet so here's a fine
call that just searches through this
vector this container for some value so
this is the non-member begin and end and
you look at that in and of itself and
it's well ok we've saved a keystroke
right and that seems to be about it well
that's that's good
unless you're paid by the keystroke but
that's generally a good thing make the
code a little bit cleaner alright so
here's a here
is being used again to determine the end
iterator of the vector but you still
have a choice of using the older the new
form of begin here we could have said V
dot begin open closed and that would
have been equivalent hundred percent
equivalent but now the non-member form
actually works with things like built-in
arrays as well and there is no
equivalent member version of that for a
built-in array you can't say names dot
begin open closed that wouldn't compile
so if you have this old C type array you
can say begin its name and its name and
it gives you a pointer to the first
element in a pointer past the end so
here's the end pointer being used again
so you can see the general generality of
that right old c++ had four types of
iterators i a regular iterator a
concentrator reverse iterator reverse
const iterator but only provided begin
and end which returns one type of
iterator C++ 11 adds C vegan and CN to
immediately give us a Const iterator
without having to jump through hoops to
get that for say a non-constant
container an our begin in RN to get the
reverse iterator corresponding types and
controverse iterators we can get with CR
begin CRN so here's why this is useful
in so in C++ 11 oh this is a sequence
list 14 feature sorry so these are added
for 14 actually so in 11 if you have a
container that is not a Const container
and you wanted to get a Const iterator
for it you would have to actually
declare it explicitly and then the
appropriate conversion would happen in
C++ 14 you just say see them again and
it knows you want a Const iterator so it
saves you from all that typing and
having to put type name in
so this is a 14 only feature alright
back to old C++ and you and C++ 11 so
the concept of a null pointer has gone
through a lot of evolution over the
years they had him in C write null
pointer was any point or equal to 0 or n
ull but we don't really know how any
well L was defined and it was sometimes
defined in different ways across
platforms so the code that worked on one
platform might not work on another I
might be an int or a long at some point
I think some platforms may have to find
it as a void 0 cast a void star or
something there was there was some
nebulous Ness about its type and if
you're reading somebody's code and you
see a 0
do you really know without thinking
carefully about the context is that
person thinking null pointer are they
just thinking the value 0 right it's not
always obvious so there's some so
imprecision there in that syntax here's
2 overloads of a function f1 takes a
long one that takes a pointer to care if
you specify your argument here
explicitly as along it clearly binds to
that but if you say 0 this is an error
both in the old and new C++ because 0
converts to both long or any integral
type and to a pointer type right so the
compiler doesn't try to read your mind
but which of those you meant and it's a
compile error nature abhors a vacuum and
C++ is the poorest ambiguity so you'd
have to do a cast and once you did that
then the compiler was happy new C
post-loss introduces a new keyword null
footer which acts like an object that is
a null pointer and only converts the
pointer types but not ever to integral
types
so using null Twitter in the place of 0
is always a good thing when the 0 is
intended to represent a null pointer
it's only going to improve the quality
of your code
so that's before I've given the same two
functions overloaded if we pass zero L
it still binds to long
if we pass null pointer it binds to the
care star completely fine if we say zero
it's still ambiguous and that's a
backwards compatibility issue right you
want things like that to work the same
ways they used to but you start moving
to using a null pointer instead of zero
here then you leverage that in that
facility so here's the final C++ 11
version of final I just replaced these
with non-member versions of begin and
end and then I replaced the 0 with null
pointer because after all I'm checking
for a null pointer usually I mentioned
this in case anybody is confused by the
fact that I'm do you referencing it and
we're still looking at it as a pointer
remember this is a container of pointers
the iterator then is like a pointer to
pointer right so the dereference here is
on the iterator which gives us the
underlying type pointer to something and
it's that that we're checking against
null footer just in case anybody was
thrown by that C++ 14 and as Scott
talked about earlier adds function
return type deduction and that allows us
to simplify this a little bit more you
can just say Auto and then return
whatever and the compiler figures out
what the type is and plugs it in there
for you
so that's sequence plus 14 only
in exactly two ways right to do the
function return type we could say Auto
as in the last slide or we could do is
use deco type ATO and I talked about
that this morning as well so you've seen
it again
if it if it uses plain Auto then it's
template type deduction rules apply so
for example you couldn't return an
initializer list it wouldn't compile in
that situation if you use deco type ATO
then they'd use this deco type type
deduction which is an exact match for
the type of the return expression and so
it's got talked about some of the
situations where you might want one or
the other just pointing out that there's
that choice and a lot of the time auto
is fine when it's not tickle type idle
might solve the problem all right let's
move on to iteration so old C++ code for
iterating across a native array here's a
native array of intz now notice I've
defined this by providing a brace
initialize a list of values and the
flexibility of something like that is
you can go in and change the code by
adding a few extra values at some point
right without wanting to have to change
anything else have the program just work
and the traditional way of dealing with
that is kind of a hack like this where
you think the size of the whole array by
the size of one of the elements and
that's the size and now if I add an
extra value or two this will
automatically adjust and all the other
loops will work correctly and then I use
that size as my loop limit so here I'm
going through and just displaying every
element of the array and then I'm
initializing a list from all the
elements in that array then I'm going
through and doing something but adding
100,000 to each element using a loop and
then going through and displaying all
the elements from that list so the idea
here is these are pretty straightforward
types of operations iterate through all
the elements that contain or do
something but there's all these
potential spots for error here
one little slip of the finger and you've
got off by one conditions
and potentially undefined behavior right
it's a very very simple thing you're
trying to do but it takes kind of a lot
of rigmarole in order to express it so
that was addressed in new C++ with the
range based for loop it's not a silver
bullet that will work to eliminate all
four loops ok there's situations you
still have to use for loops for but a
lot of them can be cleaned up by using
the syntax so if I have this array or a
container I just say for auto I I read
that as in for auto I and AI and in this
case it's going to take each value copy
it into AI and then use you have access
to that variable through that iteration
and compiler takes care of that if it's
a type that's expensive to copy which
intz are not but if it's a widget or
something that's 10,000 bytes worth of
payload and you don't want to have to
copy each element into the loop variable
you can put an ampersand in there you
can decorate this thing with auto ref so
this tells the compiler I want this to
be a reference so now each time through
the loop we've got a reference to that
corresponding element and we can do
things like modify it going to be
careful if you don't put the reference
in and then you try to modify you'll be
modifying the temporary and then it'll
get thrown away so you've made no change
to your actual data not the one you're
gonna see at the end of the loop anyway
and you can have constants in there as
well so you can decorate these all
anyway you want and you don't have to
use auto I'll use auto on the examples
to try to support auto is a good idea
but yeah you could certainly have just
used the exact type and it would work or
you can even choose a different type and
it'll do conversions but Auto is kind of
this path of least resistance for this
kind of thing and just to throw a lot of
curve you can even have this initializer
list here as the set of values to
operate upon and that works it'll
properly display each value so I haven't
introduced those yet official these
cavities err
so that's the range based for Lube
oh I mentioned there's cases where you
can't use it if you need the value of
the loop variable after you exit the
loop it's not going to work for you so
it has to be the case that that variable
is only useful in the loop body itself
and you can't need it once you're out
here and you can have a variable you
declare out here and in the loop you're
going to sign it over or something and
so you can see it outside but the scope
of that variable is limited to inside
the loop and in all the times I've used
range for I'd say about thirty percent
at the time I've been bitten by that and
couldn't use it because I just wanted to
keep it simple and I wanted that
variable visible outside the end of the
loop okay well here's one it's pretty
easy to describe you used to have to put
the space there now you don't any
questions good it took a while so how
many familiar with the assert macro the
old c library assert macro alright
that's a runtime test for some condition
you expect to be true so in C or C++ you
can assert and put in some logical
expression if at runtime that expression
is true it evaluates to true
this becomes a no op aside from the code
to actually perform the test but nothing
happens if this assertion is false then
it actually stops the program and prints
a diagnostic with filename line number
and the text of this assertion and this
is actually a macro so it'll print this
exact text and say assertion fail so
that's a very useful debugging feature
and it has the additional benefit of a
single symbol symbolic definition the
compiler command line or at the top of
some header file will make all
assertions turn into pumpkins they just
go away completely and have no overhead
no code no runtime no nothing so in
debug mode the assertions are usually
active and then right before you release
you flip that flag end debug all right
and all the assertions go away
then of course you get different
behavior and you go oh my god but if
that doesn't happen you're good
there's been no compiled time equivalent
of that until now so a new C++ adds the
static assert and that allows us to make
these assertions that are active at
compile time and we can simply have an
error generated if an assertion fails
and then you can go and modify the code
accordingly so the syntax of static
assert your condition here which must
evaluate to a bool and be composed of
nothing but compile time expressions so
things like constants and symbolic
constants and cons expert expressions
can go here and if the compiler reaches
this point and this thing is true it's a
no op if it's false it spits out a fatal
error at that point but then it keeps
compiling so there can be many of them
that show up in a single compilation and
you can deal with them all at the end of
the compilation as opposed to the
runtime which is you know one that gets
triggered and everything stops so this
can be a productivity boost in addition
to giving you functionality you didn't
have you can also accumulate a whole
bunch of them to fix all at the same
time and they'll all show up join one
compilation as an error message so let's
look at some useful applications of this
some use cases let's say you you want
your code to only be compiled on
platforms that have you know there are
32-bit platforms so you can nip that in
the bud by just asserting that the size
of an int is at least four as long as
this is true it's silent nothing happens
if this is false you get an error
message with that diagnostic and
compilation is awarded what linkage does
not performed or whatever here's another
kind of interesting example and this is
a an adaptation of a technique that I
learned from Steve Dewhurst first you
know in an old C++ environment if you
wanted to illustrate how you'd write a
little function template that will
perform a conversion but it would flag a
potentially aroni
conversion with a fatal runtime error
well that's useful but it generates all
this code at runtime now we can do it at
compile time so the syntax is safecast
so this is an attempt to safecast from
whatever the type of El Valle is to the
type it and if that can be performed
safely we know it's always going to
succeed no matter what the value of l
val l eval is it does the cast otherwise
it should be a compile error and this
gives us that result so there's two
template parameters here one for the
result which the client always has to
specify because it can't be deduced from
anything in here and one is the type of
the expression being passed which the
compiler can deduce from the call so
when I say safecast - n - val val the
compiler deduces the type of e is long
and we've told that the type of R is int
so then it performs the static assert if
the size of R is greater than the size
of e greater or equal to then we have a
potential problem no I said that
backwards
as long as the size of our is greater
equal the size of e were good and if
that's not true we have a potential
problem sorry and if we get past that
line then we know we can do this it's
casting safely so as a couple of nice
little uses of static assert all right
object file code bloat so normally I
spend a lot of time talking about this
because it's an interesting story so I'm
gonna try to laser today so we can get
through everything to process include
files or to process templates sorry
there's there's basically two ways to do
it and the industry is settled upon the
approach that everything in the kitchen
sink is in header files and it's all
compiled at that particular moment as
opposed to having separate compilation
so every translation unit includes the
full header for all the templates that
you're going to be used used in that
translation unit the problem with that
is that a lot of the time the the
functions that are actually instantiated
are duplicated across translation units
if you have a large code base with a
thousand source files and you have a
template like vector that you use
everywhere how many of those modules use
pushback probably a lot of them you have
all these redundant instantiation as a
vector of and push back then the linker
knowing that that's the way the code was
generated ends up throwing all of those
away except for one it seems it would be
better if there was a way for the
compiler only have to instantiate that
vector of it push back function one time
even across a large code base so that
was the problem and the the solution
that didn't work very well was called
export and it was excised from the
standard and that's how I'm going to say
because you get me started on that the
right solution is X turn template I'm
not sure if anybody thought of that
earlier it would have been great if they
thought of that before export but anyway
presume most folks are familiar with X
turn on intz for example right you say X
turn anti it means I is being defined
somewhere else
and I can use it here and it'll link
with the actual definition in some other
module this concept has been applied to
templates so we include the template
header file as before an old C++ and
then we take the specialization that we
know is going to be used in a lot of
different translation units and we
declared extern extern template class
vector of widget what this tells the
compiler is do not do not instantiate
any member functions of a vector of
widgets just assume they'll be
instantiated somewhere else so if you've
got a thousand modules in your
application nine hundred and all 1000
will have this statement because this
isn't a header file basically and then
one source file one CPP file somewhere
will say this so it's already seeing
this stuff and then the compiler sees
this line of code template class vector
widget and this is not new for C++ 11
this is just explicit templates
instantiation it tells the compiler
generate all the member functions of the
template vector for specialization of
widget and they're all generated right
there
in one in one place only and then the
linker will still discard the ones that
aren't actually called anywhere so when
it does settle is you get the same exact
code that you had in C++ 98 but you've
wasted a lot less compile time and disk
space and Link time to get there and
that's extern template it's very elegant
I think all right so old C++ had these
dynamic exception specifications they
weren't called that back then in 98 they
were just called exception
specifications because that's all there
was and it lets you specify what
exceptions of function might throw
there's some languages where that's
actually useful that feature Java for
example if you have a specification of
the exceptions your method is going to
throw the compiler enforces that if the
caller doesn't somehow take note that
there might be a foo bar exception
thrown it won't even compile but that's
never even been true in C++ I can
specify two or three exceptions I'm
going to throw here the collar of this
function doesn't have to even think
about that the code will compile so
there was kind of a limited usefulness
of exception specifications in the first
place then when templates were added
into the mix exception handling I think
was come up with little before templates
with templates it's impossible to even
specify what the exceptions a member
function of a template might throw
because we don't know what the type T's
member functions do or what kind of
exceptions they throw because we don't
know what's he is yet there for it in
the c-plus was 98 standard the only type
of exception specification you ever see
is the empty one because it is useful to
say I'm not going to throw an exception
and if you know something about this
mechanism you know that not even what
this really means it doesn't mean an
exception will not be emitted from swap
it means if code inside of swap tries to
emit an exception then that will be
translated into an exception that says
that exception it's still going to
propagate an exception so the whole the
whole thing was kind of kind of ticky
tack and not all that useful
the real usefulness of the empty throw
specification was for optimization
purposes the compiler can generate code
take advantage of the knowledge that
we're not supposed to throw an exception
and generate some better code but the
whole thing wasn't very well it didn't
evolve very well during early c++ as
evolution so taking that all into
consideration the new fangled way to
deal with exception specifications is
the word know except basically it's the
moral equivalent of throw open close I'm
not throwing an exception but it's
simpler to implement and that helps the
compiler know that this the code that
calls this function can be optimized
with the knowledge that it's not going
to legitimately emit any exceptions
ironically if you do throw an exception
out of here it's not illegal it'll just
terminate the program so I mean it's not
illegal at compile time and at runtime
it will terminate so that's not quite
the end of it sometimes it's difficult
to be able to say whether a particular
member function is going to throw an
exception or not because it's really
dependent on the exception throwing
behavior of the functions it's calling
subordinate Li there's a way it
expressed that so if you're familiar
with the pair struct
well it's a class but it's used to hold
elements of a map as well as other
things if you have this pair class and
you want to supply member function for
swapping and the types that make up your
pair are t1 and t2 and you don't know
anything about their characteristics how
can you promise swap is going to be a
non-throwing operation for all you know
the member function swap of the first
type t1 and the second type t2 might
throw so there's a way to deal with that
and this is called conditional now
except so it's no except open paren
close paren with a boolean expression in
the middle if that boolean is true then
it's like saying no except and if the
boolean is false it's like not saying no
except and you can make this thing's
know except be conditional on the no
accept status of swapping T ones and
swapping T tubes
so this is actual code with some of the
clutter eliminated out of g+ + pedophile
i found on my machine to look for a real
world example you get the idea why that
can be useful it can be complicated the
syntax is not as pretty as it might be
the no accept no accept seems there
ought to be some cleaner way to say that
but this is what we've got and it works
alright next problem let's say you
wanted to write a function to find the
average of a bunch of values you don't
know how many the user is gonna want to
supply well even in c there's a way to
do it it's called very attic functions
alright what's the poster child for very
attic functions in c printf the whole
printf family right so this tells the
compiler in c there can be 0 or more
arguments passed there's 1 required
arguments an end and there's no
requirements on how many additional or
what their types are and then there's a
interface to actually access the values
of those types as long as you know what
the values of those arguments as long as
you know what type they're supposed to
be so that's the problem here there's no
compiler checking for those types and if
the user supplies the first parameter
here is the account write if the user
actually only supplies fewer numbers
than the count there's no way for the
for the competitor know that you'll end
up with some undefined value as a result
of that so you have to write one of
these for each type which is pretty bad
you have to provide the count which you
might mess up and no type safety so
that's one approach that's the seed link
approach not very good another can use
default arguments well not really for
certain functions may be like for a sum
function yeah but not for something like
average because a function in c++ cannot
ask how many arguments were actually
provided even if there's some that are
defaulted there is no interface for that
so you can't do an average of you don't
know how many values were provided so
that won't work there's some
combinations
overloading and templates that might
solve the problem but it's going to be
ugly so let's see if there's a better
solution
well C++ 11 does provide it
it's called very attic templates very
otic templates are a little bit
mind-blowing if you've never seen them
before
think of the classic example of you know
calculating the Fibonacci number
recursively or something like that
except it's a compile time mechanism
involving functions but instantiations
rather than the calculation of a
Fibonacci number it's a recursive
mechanism so in any recursive mechanism
you have the general case and then the
terminal case right for Fibonacci
numbers the terminal case is the first
or second Fibonacci number has a known
value the general case is Fibonacci n is
the sum of N minus 1 stable animal n
minus 2 very attic templates have the
same structure there's a terminal case
which is the simplest one and then the
general case that we don't know how many
arguments are provided but eventually it
devolves into the terminal case so to do
average first we need to do some we're
going to spend most of our effort here
to figure out how to do some and once
we've got some working average is easy
so how do we do a sum of some unknown
number of values sum of 1 2 3 4 5 6 7 so
this code correctly calculates the
results of this expression this this
code all this together correctly gives
you the result of that expression notice
some things here all the types are the
same and there's nothing about the way
I've written that that requires it for
the compilers point of view but for
correctness we'll see how it won't work
if you mix types but this just gives you
the initial simple case so how does this
work so this is the one the general case
that's tricky there's a special syntax
type name dot dot dot this is called a
template parameter pack and then there's
in the function header there is the name
of the parameter pack followed by dot
dot dot and this becomes a function
the function parameter pack parameter
packs the the template parameter pack
and the function our parameter pack work
as a matched set they're synchronized so
they go together you can't have one
without the other
there's no syntax for that they always
go together and think of it as a whole
set of arguments of different types the
first one has type args and it has a
value the second one has type args and
it has a value and so on but they can be
different down here if we use the name
of the function parameter pack with
three dots that expands to that list of
all of those parameters their type and
their value so if we have this case here
this turns into sum of int n and all the
rest of these which is from two to seven
and then it recursively unwinds until
eventually gets just one and all this
happens at compile time the generated
code for this is the same as if you
threw the number which is the sum into a
register and displayed it
there's no calculation there's no
addition there's no recursion at random
I'm sorry at runtime so it's all a
compile time process here so those two
work great but not really so great if
you mix types we run into a problem
because notice that the return type of
the terminal case is the type of or or
of any case is the type of that first
argument so if we have something like
sum of 1 and 2.3 we're locking the
return type to be in it not very healthy
we're not gonna get the right answer so
that's at this point it's a logic bug in
this in this approach it's going to
yield the wrong the wrong value it's not
a compiler error it'll the compiler will
happily compile this and it'll give us
the wrong value so you think we can
solve the problem using trailing return
type in Auto so here's the correct
approach the return type of summing all
this stuff up is the deckle type of
summing all this stuff up so here's the
expression that
calculates the sum I just want its type
makes great sense but it doesn't compile
and the reason it doesn't compile is a
little bit of a surprise the recursive
reference to sum is illegal because the
compiler doesn't really know the type of
sum yet so if we go back here you know
how can it determine the type of all
this if it doesn't really know what it's
a chicken or egg problem and the
compiler rejects that and you get a
compile error the next surprising twist
is that this restriction is lifted if
the function name is a member function
if it's a member function you can get
away with that chicken and egg problem
so all we have to do to make this work
is make some be a member function and if
we make it a static member function
it'll have the same behavior of a
non-member function so all we do is wrap
this stuff in a strut and it compiles
and works this is the way the language
is specified don't ask me why I've never
been able to get a straight answer about
that and I've tried somebody knows why
this is so this is the workaround that
so the question is the static is the
same as a standalone yes for all intents
and purposes the same code is generated
as if it would have compiled as a as a
non-member function but because the
language stipulates you can't do that in
a non-member but you can and remember
you just make it a member and it works
okay don't shoot the messenger this is
just the way it is all right well now
doing average is easy we finally got a
sum that works so to create the average
of this set of values we can specify the
return type as the same as the type of
the sum right because all we're going to
do is divide the sum by the number and
we're going to keep the same type and
then we go ahead and we calculate
but we need one more little twist which
is how do we know how many items were in
the parameter pack well fortunately the
language gives us size of dot dot dot is
a special size of that applies only to
parameter packs and it gives us the
number of items as opposed to you know
the amount of storage taken so it's a
special form of size of that's designed
exactly for this purpose question
question is will that use integer
integer division now it'll use the
appropriate division for whatever this
type is and an integer so if this was a
double that's gonna end up with a double
it's a double over an integer if this is
a you know I'm limited precision int the
result is an unlimited precision int so
it's just normal
normal conversion rules apply here so
now we can mix up its you know average
works when they're all the same type it
also works when they're all different
types which is good of course there's a
caveat it must be possible to add these
together so if you put you know a string
in there a standard string it's not
going to compile but will it no you
can't standard you can't use Plus on a
standard string and an integer or a long
if you wrote it the question is what if
you yes if you provide enough overloads
to make all your cases work of course
it'll work but just given the standard
string interface no it won't work okay
so we know about Const Const has been
around for a long time
here's a simple constant called size and
it can be used in situations where a
variable can't for example as the array
as an array dimension so W array is an
array of this many elements and that's
fine what if we want to compute a
dimension for an array unfortunately if
it's something that's truly a runtime
variable like Val down here is a runtime
variable you can't use that as an array
dimension but C++ 11 introduces constant
X for functions a constant expert
function
acts like a whole bunch of different
functions depending on whether the
parameter passed is a constant
expression or not so okay this has
happens to be a template but even if it
wasn't a template you can still have a
context per function that will behave
differently depending on whether its
argument is constant or not if it's
constant it's compile-time evaluate and
the result is a compile-time constant if
the argument is not the compile-time
constant it turns into our ordinary
function and then the return value is
not constant and that determines what
you can do with it so square of a
constant is a constant and that becomes
fine uses an array dimension square of a
non constant is fine to put into a
variable but it's not fine to use an
array dimension so that's constant
expert functions
the context where functions have evolved
from supercilious 11 to c++ 14
so in 11 the bodies of those functions
were limited to just a single expression
and you couldn't have if else's or loops
although you could simulate them in C++
14 a lot of those limitations are
relaxed you can now have multiple
statements in the context per function
and it works so BR characterizes as
roughly a concept for function now we're
talking about 14 can contain anything
that does not have side-effects outside
the function and you still can't to go -
you can't have exception handling
you can't call non extra functions
essentially but it just give you more
flexibility of what you can do it we're
getting pretty close so let's see if I
can do like six or seven slides here
template alias there was a an omission
in the template declaration mechanism
such that there was no way to specify
that I want to create I wanna be able
declare a template that always has a
specific template parameter say in the
second position so there was no way to
say I want something that acts like a
set of T that always uses greater as the
comparator and now there is so set u by
saying using set GT and then supplying
this with a specific second parameter
the client can there shorten that to say
can just say set GT of double and it
automatically puts in standard greater
of T as the comparator so there were
several different proposals to do this
this is the one that ended up getting
used and it used to be called template
type def but rather than making type def
be the syntax for everything it's kind
of gone the other way and using has
become the syntax for everything and it
even replaces type def so instead of you
know declaring a pointer to a function
this way and typed f'ing it now you can
say using void func equals and i think
this is actually clearer and imagine
this was a lot more complicated we ever
had the situation of looking at a
they typed up and trying to find the
identifiers to know what it is it's
actually being declared there right so
that goes away by using and then you
just put the name of the identifier for
your type def so these are equivalent so
from going forward you can stop doing
this and just using start doing that and
it works all right so now just some
miscellaneous things I probably cover
these in a minute Unicode strings of
different kinds raw string literals this
is really handy in conjunction with
regular expressions because now there's
a regular expression library so instead
of having to you know be look real
carefully at all of your back slashes
you can just say our quote open have
anything in here be exactly as you be
literal exactly as you as you write it
and then close quotes M&amp;amp;E so this is the
opening and closing delimiter for that
and that covers every possible set of
text you can put in here except for one
the one that would contain a closed
quote right so as long as you if you
don't want a close quote as literal or
then you're fine but if you do then
there's an alternative syntax where you
can specify an arbitrary delimiter that
you put at the beginning in the end and
that can be up to 14 character as long
as I think should cover just about
everything in line namespaces it's
always been a little tricky to try to
revise libraries and make it user
friendly clients have to go in and
change their include statements and that
sort of thing when I when a sub
namespace has been updated so inline
namespaces provide a default namespace
within another namespace that is hoisted
up into the parent level implicitly if
this is my company BD soft and I'm
supplying these three versions of a
library this is the one that people are
currently using and this is like an
experimental version and this is an old
retired version and when I evolve it to
the next level I'll simply move the in
line from here to here and ship it
client code does not have to recompile
it just works with with the current
version
I'm gonna skip this over we're running
out of time
I want to just give me another two
minutes okay I want to want to cover the
rest of these so they don't get a good
stopping point I was planning for so
like I said I want to feel these mention
everything scoped enums or enum classes
have a bunch of benefits over the old
enums their enumerators don't leak into
the surrounding scope and you can
specify the underlying integral type if
the default which is not something you
could ever control is not appropriate so
that scope D numbs long Long's and you
type it's official you can control and
query boundary alignment for various
types and Pablo gave an example of that
in his talk this morning if anybody
attended that generalized unions in
general iPods kind of go together unions
and plain old data types had a bunch of
restrictions like they couldn't have
constructors and destructors
well they realized you could still let
them have constructors and destructors
without breaking any of the constraints
for what these things are used for so
now they can have constructors and
destructors they still can't have things
like virtual functions and all of that
but the restrictions have been
significantly relaxed in C++ eleven
there's a garbage collection interface
there's hooks for a garbage collector
but no actual garbage collection
provided but at least it provides the
opportunity to build one in a standard
way
user-defined literals if you wanted to
have a binary type and you wanted a be
to be a way of users writing a literal
you can actually program that to be
legal code and it's all kind of a hack
it basically passes this as a string to
a constructor you provide and then you
provide the code of how to do the
conversion in conjunction with Const
exper it's very efficient because these
I'll be ready
no underscore
you might be confusing that with this
literal binary really okay I'm not
familiar with that so I just never seen
it the question I have to do with you
need to put an underscore here no over
here under Barbie okay again I guess I
have moved enough code I thought I took
this out of an example maybe not okay so
in 14 there's also official binary
literals it's kind of funny I used this
example of binary and then this slide
was added later where now there's a way
to do binary literals that's built-in
right so you wouldn't probably need a
user defined binary type you just or at
least you can specify binary values
that's what this is about and you can
also use a slightly displaced comma
inside of numerical values it's an
apostrophe lets you read the numbers
better all right that's where I want it
to stop great so we'll be continuing at
3:15</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>