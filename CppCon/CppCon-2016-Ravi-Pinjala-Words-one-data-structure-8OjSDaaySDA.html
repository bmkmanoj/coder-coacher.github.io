<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Ravi Pinjala “Word's one data structure&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Ravi Pinjala “Word's one data structure&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Ravi Pinjala “Word's one data structure&quot;</b></h2><h5 class="post__date">2016-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8OjSDaaySDA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi I'm Ravi pan jela I manager on the
word team and today I'm going to tell
you about words only data structure may
be there we go okay so let's talk about
the poem that we're trying to solve
right here we want to take arbitrary
objects we want them to attack we want
to attach them to a stream of texts and
objects could be images pictures
comments basically anything you could
think of that you might want to attach
to a document it turns out that you can
implement just about any feature in a
word processor by sticking objects to
text and having them stay there and we
want the objects to move around with
text so like if I'm typing that I want
everything else later in the document to
actually move along with me and not
shift around and so let's try to build a
data structure that actually does this
so we'll start with something that looks
like this warning for the faint of heart
this is going to have a lot of C code in
it it turns out the use of this data
structure actually predates C++ by quite
a bit so I'm showing this as it exists
so we have basically a mapping of
positions to arbitrary objects in the
way you would do it and see there's a
size there's capacity there's an element
size then it's just raw pointers
everywhere don't worry about that if
you'd like you can just think of this as
sort of a flat map positions is going to
be a sorted array of character positions
in the document data is going to be an
array of objects that align with those
positions so like the first element in
the positions ray matches the first
element of the data array and then
element size is just the number of bytes
to copy instead of using a template here
like I said C so let's so how do we
update this when we actually add text
the document we could go through the
array of positions and just increment
all of those that's order n that's lame
we don't want to do that boo so instead
let's just keep trying
of where the last update was and how big
that update was and just sort of work
around it so here we just keep track of
the index of the last adjustment that we
made and the distance that we adjusted
things or that we would have adjusted
things basically we're treating every
position after a just pause as though it
had a just sighs added to it even though
we're not actually going to rewriting
the data structure let's also add this
search ain't here don't worry about what
that does I'll explain it later so when
the document is changed we record the
adjustment let's say that we had a table
that looked like this with these
arbitrary objects attached to them and
we make this adjustment here so that
we're adding eight characters after the
second position in this array and you'll
notice that the real positions recorded
changed but the virtual ones that were
hanging on to are actually updated so
wait a second this works but what
happens we want to make a second change
do we have to go through and actually
update all the things for the last
judgment before we can record it no we
do not so this is kind of the clever bit
you start out with something that looks
like this and you want to make another
change to the document let's say that
you're adding four characters at
position 15 in the document so what we
can do is we can actually just move the
adjustment point around and sort of
fiddle with all the positions between
where we were before and where we are
now rather than having to actually touch
every item in the array so you'll see
that in this case we only needed to
actually update the value of one element
and now in the new one the position of
the adjustment is one the size the
position the size of the adjustment is
increased and the whole thing's still
consistent so in general with a scheme
like this adjustment is order of the
distance from the last edit inefficiency
and lookups our order log n because it's
a sorted array or technically it's two
sorted arrays stuck together so you can
find a research both of them
but it turns out that in a word
processor most edits actually happen
pretty close together and especially
while you're typing and it's happened
really close together and it turns out
that people really care about the
performance of typing so while you're
typing adjustment doesn't change any
positions it only bumps the size and we
cash the result of the last binary
search in that search hint that i
mentioned earlier and so we check that
first when researching that's always
up-to-date while you're typing and so
everything that happens while you're
typing with this data structure it
happens in constant time so in word it's
actually not called that I think I'm
getting kicked off the stage so I'll
just breeze right through this slide and
say that you can actually implement just
about everything in word of this which
is why we sometimes say that it's words
only data structure because just about
everything's based on it so in
conclusion standards data structures are
pretty cool but sometimes with the
domain specific data structure you can
do some pretty neat stuff thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>