<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: David Sankel “Variants: Past, Present, and Future&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: David Sankel “Variants: Past, Present, and Future&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: David Sankel “Variants: Past, Present, and Future&quot;</b></h2><h5 class="post__date">2016-10-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/k3O4EKX4z1c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello okay thanks
so I'm from a little town called New
York City and I work at Bloomberg and
we're gonna talk about variance today so
before we get started just a get an idea
how many of you guys use variance about
half maybe three-quarters of you how
many of you guys don't know if you use
variance or not okay a few all right
well we're at least gonna clear that up
and the answer is probably that you
don't use variance so this is about the
past present and future about this nice
data structure here so in 2004 boost
variant was released in boost 1.30 1.0
and that should tell you that we've had
a lot of experience with this thing in
2016
variant was voted in the c++ 17 2016
being this year for those of you who
don't realize that that just happened
recently and it was a very awesome thing
to get into the standard and it took a
lot of work to get get it there and
sometime in the future maybe there's
going to be a language based variant
support in the next some next revision
and I'll just touch on that at the end
of what we're going to talk about so
first off motivating examples who cares
about very why do we need it you're
gonna see you've seen code like this
before so basically what you have is you
have a person ID a person ID can either
be a name of the person or maybe a John
Doe number and it's never both you
either have a name for the person or
he's got a John Doe ID and it's done
like this so you have your getters up
there you have some boolean which says
which of these things is actually active
at the right point and then you have
your string for the name and your int
for the John Doe ID so far so good
right you need to document your
undefined behavior though because if
this person ID happens to be a John Doe
then you shouldn't be calling the get
name function so you might document your
undefined behavior with something like
behaviors undefined and less has name
equals true so I got to add that to your
interface
okay this happens a lot it's in a lot of
different kinds of code and it should be
completely replaced by a variant and
we'll see how later the problems with
this approach we don't get any compiler
help for checking those preconditions
like there are no guarantees that our
users using this code are actually going
to make sure that the preconditions are
met
not at compile time anyway there's waste
of space because you have the string and
you have the int where you really only
need one of those at a time so you just
got this waste of space and there's just
a bunch of boilerplate which is error
prone so these are drawbacks with this
approach here's another example
sometimes you'll see this kind of things
what you have is an abstract base class
so this we have like a commands like
maybe some kind of commands in a game or
something like that you have some kind
of virtual function this in this case
called put which is just outputting a
something useful to the stream that's
put in there and a virtual destructor
and then each of your commands are going
to inherit from this abstract base class
and specialize the put function and you
know this has a double the set score
function in this example so that's what
that's all about
the problems with this is if you're
using an abstract base class to model
this you're going to have allocation
memory management to worry about so it
just adds another level of complexity to
your API or you're gonna have to use
shared pointer unique pointer what kind
of questions those kinds of questions
you have to answer every single
operation that you want that works on
all of the different things which are
commands needs to have a virtual
function in the base class so that can
kind of be annoying so I say functions
are split here and what I mean by that
is you really think of this put function
as one function but it split between a
whole bunch of different files usually
translation units because of it needs to
be implemented in each particular thing
that inherits from it and there's just
lots of boilerplate here
and finally this is open instead of
closed because if I could give an
interface if I provide an API which has
this command abstract base class then my
clients can inherit from it and add
Colet commands sometimes you want this
sometimes you don't like in this kind of
case I don't want them to add their own
commands my I don't know that doesn't
make any sense for my game so that can
be under silent desireable so people get
around some of these issues you've
probably seen this kind of pattern
before so yeah so you have your abstract
base class and it has a type inu and
this thing just basically enumerates
every single possible thing which
inherits from the space class you have a
get type function which will tell you
which when you have an instance of it
you can tell you which thing which
inherits from it is currently in your
objects and and then each of the things
which inherit from this abstract base
class get type you return the
corresponding enum for this so if you
want to use one of these things you call
get type in figure out which type it is
you downcast to the right thing and then
you can write your functions that way so
we still have allocation and memory
management required for this functions
are no longer split like if I want to
write a put function I could write that
in one spot I don't need to add anything
to the abstract base class there's even
a more boilerplate now and this time
it's error-prone if you return the wrong
thing from set from this get type
function you're going to get some kind
of error at runtime and it's still open
instead of closed not exactly what we
want and the third example here is just
a simple binary tree this one is
recursive because if you have a branch
right and you have the branch and the
leaf both inherit from that from the
base class the branch refers to the tree
node at the top there so it's a
recursive thing I'm not going to go into
a lot of this particular example right
now we're going to get to it later but
just keep it in mind as this is another
thing that you should be using bearing
for him so what is variant
the way I like to think about this is an
vs. org if you got a struct and it has
two members in there an ex-member and a
y member it has an X member and a Y
member key word there is ant if you have
a variance with an x and a y it has an X
or a Y so it's either going to have an X
or it's going to have a Y it will never
have both so it's and versus or so going
back to our person ID which is either a
name or a John Doe ID the way that you
put that into a very easy saying okay
using person IDs is really fancy
sleepless 11:00 stuff here you could
also use a type def using person ID is
equal to variance string int so a person
ID is either going to be a string or an
int as as simple as that so let's look
at our command example so we had again
our abstract base class and our set
score thing which inherits from it the
way you do this now is you figure out
all the things that are commands like
set score give it the data member that
it needs in this case the double value
and then say using command equals
variant set score fire missile all the
other kinds of things so a command is
either a set score or if say fire
missile or it's a fire laser or it's a
rotate right simple enough and here's
just a slide that talks about the
different names of Berrien cuz you'll
hear it come up under other names and
different conversations I'm not gonna go
into detail on this but just so you know
some people call it the or type some
people call it the some type of here
conversations about some types we're
talking about variants discriminated
union okay this is like a mathematical
term for it and it has like the Union
sign with a little plus in the middle
there they took all this the algebraic
data type pipe operator or a one-of type
these are just different names for the
same thing that'll come up every now and
then so we have
we have inheritance when would you use
one one would use the other well just to
look at some of the differences a
variant are if you're using inheritance
it's open to new alternatives all right
someone can come along look at your
abstract base class and add more things
to it a variant is closed once you have
that using whatever equals variant
you can't expect some client to come in
there and shove another type in there
right it's set when you provide it to
them
inheritance is close to new operations
generally speaking you only have that
set list of virtual functions where a
variant doesn't have any of these
functions defined when you declare your
variant you can always add new
operations to a variant over all the
different alternatives it has
inheritance you have this multi-level
thing variants are only single level you
just have that list of types inheritance
is an object-oriented construct whereas
variants are more a functional
programming type thing and you can take
that as based on mathematical analysis
they come up with these ideas
inheritance is very complex you think
about public private protected all this
kind of stuff
variants are very simple at their core
it's just this or this or this or this
so boost variant has been around for a
long time
let's review their implementation of it
so we know we can create a variant and
when you make a variant the default the
default constructor
just initializes to the first
alternative so if the first alternative
like string has a default constructor
which it does then the variant is going
to initialize to a string which is empty
all right that's just the rule
assignment so I can say V equals 3 it
says okay I'm assigning to an int that
means I need to switch to now I'm
holding an int or V equals hello world
in a string that it'll realize that that
needs to be a string and it'll do the
right thing that's how you change the
value of a variance extracting a value
is a little bit more complicated in this
case we're going to write our output
here and you use this boost get
thing boost get takes a single template
parameter which is which type you want
to pull out of it
and it can take in a pointer to a
variant it will return null if it
doesn't have that particular alternative
active or it will return a pointer to
the active thing and then you can do
stuff with it boosts yet also takes in a
if you pass in a reference as opposed to
a pointer to it now you're going to get
an exception thrown if the type you
requested happens to be the wrong type
it doesn't actually have that one on the
inside so that's how that works there's
another way to do it and that's where
the visitor so what you do is you make a
struct and you define a call operator
for it and you overload it
one overload per type per alternative
type which is in your variant so in this
case we have two here we have one which
takes in a string the other one which
takes in an int and you have the special
using result type equals void because
these operators here can return
something so it needs to be figured that
out and then you call boost apply
visitor you pass in an instance to your
visitor and the variant and it it does
the right thing is which selects it for
you so would you use get or visitor and
so the benefits of visitor is that you
get a compile time guarantee that all of
your cases are handled which is really
really nice because if you happen to
miss one and you don't have an overload
for something you'll just get a compiler
the benefits of using get are the code
is right next to the usage right you can
have it in the function you don't have
to make this separate struct somewhere
else this far away and you get this
really nice succinct syntax my
recommendation is to always use the
visitor just because it gives you a lot
more confidence when you have to
refactor your code if you if you always
use visitor for example if you add
another alternative to your variant type
let's say you add a new command or
something like that
a compile error in every single place
where that wasn't handled properly
whereas if you're using get runtime
errors so we got 12 years of experience
with variant since it came out what what
kind of stuff did we learn so the
examples that I gave this using whatever
equals some kind of variant there these
are problematic type tests in general
are problematic but this in particular
we don't have a forward declaration of a
of a type def so if you have headers and
you want to just say I'm gonna use this
variant type or whatever you have to
include the other header that defines
the variant you can't just forward
declare it and then get your improved
compilation speeds so that's really
annoying the error messages are
completely unreadable because
everything's gonna refer to this variant
template of all this kind of stuff where
I really want the error message to
mention command and if we're really if
we have a unique type that corresponds
to the data structure we're trying to
define that really matches that are
intended semantics right we want to have
it a command be a thing it's not just a
variant of these things no it's a
command so we'd like to have to be able
to define a name for our variant that's
like a real name so one way to do this
is to use inheritance this works okay so
you make your struct give it a name so
this case commands you inherit from
variant and then you define your three
constructors with some boilerplate code
and you just pass on the different
constructors to the varying constructor
underneath this works you can do your
forward declarations you get better
error messages but there's a lot of
boilerplate involved especially when
working with older compilers this
boilerplate I showed here works with
newer compilers another way to do it is
to wrap it so I just make a struct
struct this case called command and I
just have a single member which is the
variant on the inside this is a lot
simpler but users need to unwrap it by
using the value field so if I happen to
take into command as
argument and I need to do some kind of
get the variant on the inside I have to
call valya okay not that big of a deal
but it's something so back to that
example the recursive example how do we
make a variant for this well you can't
if you're using the type def thing you
can't refer to the type def that you're
assigning to or that you're defining on
the right hand side of the type def so
just using direct recursion is gonna
work
what boost variant did is they provided
this special make recursive variant
function so what you do is you define
your alternatives with a template
argument which refers to the overall
variant that you're defining you call
that magic make recursive variant
template and when you refer to your
recursive alternatives on the inside you
have this boost recursive variant thing
that you just call it so you get a
really tight syntax when you do this
there are hidden allocations on the
inside when you do a recursive variant
which makes sense right if you're
defining a tree there's no way you're
gonna be able to make a tree without
some kind of allocation there so it
hides all that for you
the other alternative to this is doing a
direct recursion in this case we're
making our binary tree our template
argument is the leaf data so I forward
declare the binary tree which is going
to be our thing which we define overall
and we define our branch here and here
we have a shared pointer to the binary
tree of leaf data which which is why we
needed to have this for declared and
then I just do that similar pattern
which you saw before on the other slide
when I want to get a new type out of the
thing so this works pretty well we've
got complete control over allocation in
this case see we got to decide that we
want her to use a shared pointer or you
can use whatever kind of pointer you
want the boost thing doesn't give you
any power over that we can do our
forward Eckler ations to boot and it's
more straightforward to
so if you're going to do a recursive
variant this is the technique that I
would recommend to use it is really not
that much longer than the make recursive
air anything so the assignment problem
if you have a variant of a and B and you
initialize it to an a value of type a
what happens when you assign it to be so
conceptually the variance a is
destructed we have an index instead of
two because every barrier needs to keep
track of which kind of thing is
referring to so the index is updated and
then the B is now initialized to the
right hand side value this can be
problematic if when I try to take that B
and initialize it from the right hand
side value I get an exception thrown
okay now I'm in trouble because I can't
go back to the a that I just had before
because I destroyed it right because I'm
using one space piece there I can't
initialize a B or an A because that
might also throw an exception so what
the heck do I do
so boost variant made a decision on this
and I'm not gonna go into detail to how
it works but essentially what they do is
they allocate on the heap extra space
every time you do an assignment and they
move the current contents up there in
the heap then you initialize the B and
if that throws and I still have the old
thing and I can put it back in there so
this can be problematic and we'll talk
about that later so the way that people
work around this because people hate
allocations especially when we're
talking low-level stuff like a variant
you can ensure that all the types are no
throw copy constructible right because
then you just know that it's not gonna
throw on copy so you don't have to have
to do the the heap allocation you can
ensure that one type is no throw default
constructible if you happen to have an
INT in there then you just say okay well
if this special thing happens that I'm
just going to initialize the int to zero
I know that's not gonna throw an
exception so that way you can work
around the issue or you can always use
this type called boost blank
the first alternative for the Burien
type that's essentially like an empty
state so that's boost variant now let's
talk about stood variant so axial Newman
is the one who's been working on this
that's the paper number if you want to
look it up and there are two fully
conforming implementations that are
available I use Anthony Williams one and
he's run this conference so if he's
there if you see him thank him for that
cuz it's awesome so you just take this
variant header from his github site and
you just plop it into your project maybe
change the namespace and start using it
works awesome so so what's the
difference what do they do overboost
variant so number one they the apply
visitor function was renamed to visit
okay and there's one little subtlety
here note that you don't need to do that
special type def in our output visitor
thing anymore because we can figure out
the right return value these days so
that's nice just a little bit shorter
it'll make the code a little bit cleaner
maybe cool the second change is that get
was reworked so you know how if you took
get any pass that a pointer would do one
thing and if you pass it a reference
that would do another thing well they
decided to split that into two different
functions so we have get if and get so
if you want to see if it if it might
have a string in this case then you use
get underscore if and it will return a
pointer you can query whether or not a
small change three is you can use get
using an index now so instead of having
to specify the type and get you can
specify oh the zero with alternative or
the first alternative or the second
alternative this is something you would
normally want to use in encode but if
you're doing generic programming it can
be quite useful and along those same
lines
this fourth changes you can have
duplicated entries in a variant which
can kind of be confusing you've pretty
much got to use the index based access
when you when this comes up and you
normally wouldn't want to do this and
user code but again if you're doing some
kind of
generic programming it's nice to be able
to have a variant which can handle
multiple had handle repeats of the same
type there's no more special recursion
support as there wasn't boost but that's
okay because we didn't like the special
recursion support the boost had anyway
so just do what I was suggesting earlier
when you need to have a recursive berry
change six we're not calling it boosts
blank anymore we're calling it stood
mono States okay so this is a cosmetic
thing stood mono state can be used in
other ways besides just in variant it's
just basically a type which has exactly
one value has less than and all these
operators defined for it which do the
thing that you would expect it to so you
have that so the allocation and
assignment that was removed so just to
give you some background on this stood
variant was a very contentious thing on
the standardization committee there were
literally over a thousand emails spent
discussing the design of this thing and
most of them were unchanged severn
everybody wanted this allocation and
assignment to go away everybody but not
everybody wanted to go away in the same
way so that is where there were some big
discussions so there were two main camps
one is to have an explicit empty these
people said that you know if there's an
exception thrown on assignment the
variant goes into some empty state so
any variant with alternatives you have
this empty state you can to make it
empty you can make it not empty or
whatever prose about this predictable
space usage right there's not any kind
of double buffering or anything that got
going on it always goes to the empty
state if it needs to
and it's teachable and that it's easy to
explain a variant can be empty the cons
here is that this is Error poro
error-prone so imagine you're you have
your tree structure and every single
node in that could be empty so
how many different empty states does
your tree have like a whole ton of all
different kinds of empty states that's
really not what the programmer intended
so that's you really want it to not be
empty for that kind of case and the
semantics become complex as a result so
every single function that you're right
which takes in one of your variants you
have to have a precondition which says
the thing isn't empty
those were the drawbacks with this
alternative the second alternative this
is the alternative that I was pushing
for but nobody on the committee ever
guess what they really want so this one
has the never empty guarantee and you
just make it double buffered if it has
to be double buffered if it's a friendly
type you know if all the alternatives
happen to be no throw a sign or no throw
constructible all that kind of stuff
then you don't double buffer so only
double buffer exactly when you have to
you get these really simple semantics
never empty is what most people need the
cons here is that it's difficult to
predict and control your space
requirements because what defines a
friendly type I put that in quotes
friendly because it's so hard to explain
so it's just really hard to look at a
variant like this and decide oh is this
using double buffering or not and you're
paying a high price how often does an
exception get thrown on assignment like
hardly ever and when it does get thrown
it's usually because you're out of
memory in which case you're gonna just
blow up your program anyway this you
don't really recover from that there may
be three people in the universe who care
about that scenario so what we got is a
compromise which is a variant which is
rarely empty so the empty state is
called valueless by exception that long
name was specifically engineered to
scare you away from it don't think about
it if an exception is thrown on
assignment you put the variant into the
valueless by exception state and
friendly types cannot get into the
valueless by exception state it's just
impossible for friendly types but the
pros here is you get the predictable
space usage is not double buffering it's
teachable
there are simple semantics in normal
normal usage if you're doing abnormal
things first stop like you shouldn't be
doing that second okay we're giving you
this flag so that you can do your
abnormal things and the biggest concern
about this approach is that we got
consensus and very is in the standard in
my opinion many many many years late
so the cons here is that in the
exceptional case when your assignment
does throw you have to make sure that
you think about your variant being in
this value list by exception state so
when do you what does this actually come
up so it turns out you don't really need
to know if it's invaluable exception
state because you already had an
exception thrown which said something
along the lines of variant had an
exception being thrown so you don't even
really need something to query it if
you're querying it you're trying to
reconstruct your data type that's been
corrupted in a certain way which you
shouldn't be doing so in the end you
don't really ever have to deal with
bayless by exception variance in normal
code if you write a function you don't
need a write precondition that it you
know what the special usage is for
bayless by exception just all of them
are not in this state
and they only get into this state in
your exception handling code so that was
the decision they're in to somewhat up
stood variant these are mostly
incremental improvements overboost
variants nothing really spectacular out
there the handling of exceptions on
assignment was the big change from boost
variant and this is in the c++ 17
working paper coming to a compiler near
you so before I go on let me just take a
quick like maybe two questions if you
have any questions on this come and talk
about something else real quick question
the question was did I have to use
shared pointer in the example usage with
the recursive variant because it had an
incomplete type and the answer is yes
what happens if you don't use exceptions
I don't know if you don't use exceptions
and nothing ever throws an exception
then you never go into the venue list by
exception state it's a non-issue if you
visit a variant in the vein this
exception state bailiffs by exception
state first off you shouldn't be doing
that second off you're going to get an
exception
okay I'm gonna move on so language
support for variant this is this is my
pet project here I think that variants
come up often enough in code that having
language level support for them would be
very beneficial and I'll explain why so
first let's just look at what it looks
like so it looks a lot like a struct so
in this case we have a variant that is
used for a JSON object I assume you're
all familiar with those and each field
works exactly like a struct except
instead of putting and in between all
those lines we're putting or in between
all those lines so the command either
has a set score size T or it has a fire
missile mono state or a fire laser or a
rotate if you want to create a value of
this command type you just call the
field after : : now all the syntax is
you know subject to change is just very
early design stage the committee's only
seen there's a couple times so far we
have basic pattern matching so instead
of having to put your struct
some crazy place you can put it right
there in line with an inspect statement
so in this case we have a commands you
inspect it if it's set score then you
bind value to that size T I'll put it if
it's fire missile you do something and
and so on and so forth pretty
straightforward one thing that came up
is you know why do we need a language
based variant is a light library
solution sufficient let's see so here we
have a variant exactly like what we were
doing with the L variant there so we
have to visit options we have type based
we can get you know which alternative
based on the type or we can do it based
on the index
so indexed based visit is kind of nasty
right because you got to remember the
names of the indices so maybe you're
gonna want to like make these constants
to say which thing in there corresponds
to the index mr the requires more
boilerplate it's error-prone if you if
your indices wrong not really too nice
type based visit is also kind of nasty
so if I write stood get of unsigned what
happens because size t could be a type
def to unsigned will it compile does it
give me the set score alternative is it
platform dependent all the answers are
bad right this is no good so what people
do to work around this problem is they
make these special tag structs so you
have the different types in there so you
have a struct for your set score or
struct for your fire missile and so on
and so forth this requires more
boilerplate and it introduces these
types which really don't make sense in
isolation they really only make sense in
when they're all put together so that's
not too nice either so another way to
think about it is the struct tuple
connection because we have stood tuple
and we have struct here's a point type
with the x y&amp;amp;z field and using point
equals stood tuple double double double
so these are two different ways to make
a point class you can make it with a
struct you can make it with a tuple the
tuple version has all the same problems
as the indexed variant though you know
do you get by it you get by index which
index corresponds to x y&amp;amp;z maybe you can
remember maybe you can't for a more
complex case so then use type based
dispatch and make these special struct x
y&amp;amp;z and then you have using point equals
a tuple of that so then what you have
the strange field X like what are you
gonna do with that that's doesn't have
any meaning and isolation I don't think
so now would anybody recommend doing
this with a tuple instead of just using
a struct
no I don't think so so that's not saying
that tuples don't have their use but I'm
saying that Struck's have a use and
tuples have a use it's nice to have them
both l variants relate very closely to
structs so you have an L variant and you
have the corresponding stud variant of
it and this is a Co point this is like a
mathematical thing which says you know a
certain amount of direction along X or Y
or Z you get the exact same problems so
same reasoning what's an X would anybody
recommend using this instead of an L
variant I don't think so
so stud variants have their use but so
do L variants and we're working on
bringing these kinds of things another
language so just a sampling of the stood
variant problems if you use them a lot
you get unhelpful error messages a lot
of times because this is template
programming the code for visitation is
kind of ugly and there are portability
of issues so like if you have this
database handle thing there is this code
future-proof mmm not likely because what
if Oracle handle and Berkeley handle end
up having the same underlying type at
some point in the future that would be
better
so variants are simple and a common need
but a library only solution is too
complex but if that's all you got use it
it's gonna make your code a lot better
so our proposal is to make the basic
language based variant pattern matching
is closely tied to L variants so if you
have an L variant here you do your
pattern matching and you'll note that in
the second one here set position I'm
doing a pattern on the thing on the
inside so if the position is like a pair
of doubles then I can go ahead and match
on the doubles and say that matches
those and so on and so forth
so the idea with the pattern matching
proposals is that I can match on
integrals and enums
so if I have an in second do pattern
matching on that
I can do it on structs so if struct here
I'm inspecting this one which has a name
hit points and coins and my inspection
statement I'm finding n2 the name h2 the
hip points see the coins which is kind
of ugly so we should really be able to
match on the fields and and we do
propose to do that
so that way the code gets a little bit
more clear however we don't want to just
have pattern matching on structs and L
variants because what if I have my own
custom type which has private data and I
want to provide a way for my consumers
to match on that thing so the idea is to
also provide an opt-in if you have your
special type like in this case a a pair
where the first and second members are
private I should be able to make an
operator extract that provides the
compiler this information to say that
when someone matches on this this is how
I want it to behave I'm not gonna go
into more detail than that because it's
still ongoing work in terms of pattern
matching what we're gonna do with that
but this kind of gives you a hint in
terms of the direction that we're trying
to head into so let's see how much more
time do we have 20 minutes okay
good thing I brought some extra slides
so there are a couple of other proposals
that are out there related to variance
that I think are interesting so this one
by Vincente the idea is to make a
function called stood overload what this
will do is it will take a bunch of
lambda functions which each have a
different kind of argument and combine
them into one function object which acts
like the kind of thing that you would
use the stud visit on what this buys you
is instead of having to make this struct
in some other area of the code you can
do your visit in line like this so this
is not in C++ 17 didn't make it in time
but the libraries available this is
something that you can use and play
around with and it makes the code
a little bit nicer to work with and
second bonus slide visitors with extra
arguments so a lot of times you need to
do a visitor but you you want to have
other data available to you when you're
going through your different alternative
types you want to have like extra
parameters that apply to all the
different alternative cases so there's a
nifty way that you can do that the first
thing you do is so this is just a design
pattern you you forward to Claire your
function in this case put and in your
your struct which is your visitor here
are you guys seeing me scroll down
is that working hierarchies don't work
there okay so you forward declare your
thing your your visitor and then each of
your operations you add the extra
argument that you care about in this
case the Oh stream is the thing that we
want to make sure is there in our case
statement and then finally when you
implement your function you can use
stood binds to take your visitor and
bind this to the second argument of it
or the first argument of it in this case
and use that with your visit function so
it comes up every now and then it's a
good thing too now so this this is a
very contentious subject on variant so
I'm sure lots of you guys have questions
comments and insults so let's let's
let's get that let's do that right now
so the question is are you going to be
able to define like member functions
into an L variant so or a default
constructor so this is all stuff that's
being investigated right now so probably
yes so the question is how would the
compiler underneath do this kind of
pattern matching and the model that I
have in my mind is you can take that
pattern matching code and break it up
into switch statements and nested switch
statements so if that helps understand
it but I'm further compiler does more
crazy things was that this seems like a
huge change in the language for justice
variant feature okay
so the question is what are the
performance implications of using visit
compared to other ways of doing this and
the answer is when you look at the code
which is generated based on using visit
it's basically in lining all that stuff
so what you get is the optimal code at
the end it's wicked fast oh sorry so the
comment was in the database example I'm
assuming that the visitor is not
visiting based on index and the question
is is there a way to make one as far as
I know there isn't a way to do that just
yet to do a visit
based on index only is there a way to
use em place as opposed to copying yes
you can you can do that the question is
well you have to will it be smart enough
to realize that my variance in my ell
variance in enum and that's like way
future like I have no idea my guess is
yes
ah the comment was that maybe you can
use concepts for IFTA to do something
like this he believes that we can so I
will I'm encouraged so the comment was
that it looks strikingly like structured
bindings shouldn't we like share some
kind of syntax and the answer is yeah
definitely so we want to make sure that
it's they're the same
at the end of the day the question is if
element were accepted with library based
variant go away and the answer is no
just like having struts doesn't mean
that you don't need a tuple anymore so
the question is are there any plans to
have the pattern matching be exhaustive
and to have a complaint if it's not that
hasn't really been investigated too much
yet but if it's not exhaustive and you
use it in an expression then that's a
big problem
it's like undefined behavior or throw an
exception or something I don't know
we'll panet pattern-matching work
withstood any there are some folks who
would like it to work with stood any I'm
not sure if I'm one of them or not yet
what the committee has definitely said
they want to be able to switch on a base
class match on a base class and have
different cases for the different
derived classes personally I find that
to be an abomination but if we need to
do that to get it in then you know
compromise so the question is are there
anything used inside of I I assume
you're talking about of student that we
have available or in the interface
itself that require you know special
compilers or newer language support and
the answer is no you you can implement a
version of stood variant with C++ 11
stuff or you can implement it without
like the Special Move semantic stuff
with C++ 98 there's nothing really
special that it needs in terms of those
implementations of what they use I'm not
really sure
I think they need at least C++ 11 cuz I
know these very addicts questions are
one of the leat the minimal changes
required to implement L variants o plain
variants I don't think that we need any
changes to implement stood variant so
still variant could have conceptually I
mean it's going into C++ 17 right but it
could have conceptually gone into C++ 11
there's nothing it doesn't require any
special new features to implement
although the new features are convenient
when
want to implement it so are we talking
about L variants like just stood
variance yeah I don't think we need any
language special sugar or anything to
use it it's it's available you can use
it now so the question is what do I see
is the biggest obstacle of getting this
kind of open pattern matching into the
language you know it all kind of boils
down to getting consensus like the way
the committee works you have to have
like 80% of the people agree that this
is the way to go forward and you know if
you have just thirty percent of the
people who say I don't like it
I'd rather just not have it then it's
very difficult to to move past that so
it's really coming up with a compelling
argument which everybody agrees with or
at least 80% questions
I'm sorry Nikesh day
that anybody understand that and maybe
Nessa pattern-matching
oh yes
so nested pattern matching is definitely
part of the plan to be able to have
nested patterns in there yeah that's
really important so the question is how
does the language based matching stuff
handle multiple visitation things and
the idea is is that in your match call
instead of just putting one thing in the
parenthesis you can put multiple things
with commas and then you know match
based on that so just the exact same way
that stood visit works the question is
our new keywords required for the
language based various stuff maybe so I
started out with a proposal calling it
an enum Union like in the enumerated
Union and that was not very well liked
so we'll see what we come up with there
might be a new keyword or two
coming as register is available now
there you go
will calm registers any other questions
okay so the comment was right now the
ordering matters what if we made the
ordering not matter and you know a
variant in two comma string is the same
thing as a variant string comma int so
this is something that we discussed on
the committee and it turns out there are
a lot of problems when you're trying to
do template logic for that because we
don't really have an ordering of types
so we can't come up with a unique
sequence given any kind of type that we
can compare against another sequence so
the implementation of that's really hard
but also along those lines there was a
desire to model a discriminated union
where you really the ordering does
matter with the discriminated Union it
and what you're talking about is
modeling a union so we just decided in
the committee that we're going to go for
modeling discriminated union and that's
that affected all the rest of the pieces
of the interface question is am i
proposing underscores a match all or is
that just a regular variable name so
like the exact concrete syntax isn't
really been something that I've been
proposing yet maybe question mark would
work better there there are some
comments that underscore is used in
other libraries so there would be a
conflict so we'll figure out something
that works with existing code and
doesn't break anything that's the goal
anyway
have I considered what an implementation
of optional would look like with a l
variant yeah so it would be that it
would have two fields one would be of
type stood mono state and the other one
be of the thing that you want to the
value of the optional okay I think we're
done thank you guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>