<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: David Sankel “Functional Design Explained” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: David Sankel “Functional Design Explained” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: David Sankel “Functional Design Explained”</b></h2><h5 class="post__date">2015-10-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/x9mIAT-CAwA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so my name is David's ankle
I'm a software developer Software
Architect at stellar science and we're
gonna talk about functional design so
before we get into like what that is I
just want a show of hands for those of
you who've ever worked on a code base
and you've had this you know hairy code
that you're working with and you have
this AHA insight and you simplify your
code by figuring out like one particular
function or one for two particular piece
and you take these huge swaths of code
and they become tiny little pieces just
composing this little piece that you've
created so how many of you guys have
come across that scenario right okay
almost everybody and this is really the
idea behind functional design as we're
going after these aha moments we're
trying to find these extremely small
composable powerful pieces that we can
put together to make our software
components and usually when you do this
you know a normal programmer who is not
familiar with functional design you just
kind of like discover these things in
practice but when you're doing
functional design you're actually trying
to find them directly so let's see here
so just to kind of like put where this
is in context of things I love putting
up these two circles so we have one
circle over here which is the
engineering circle people who are
engineers they are trying to solve real
world problems right they have a problem
to solve
where's in the mathematical more
theoretical circle you find people that
are just trying to do interesting things
trying to push the limits of knowledge
but these two branches kind of intersect
in the middle and for example an example
this intersection here would be
asymptotics you know run time that's a
real pure math you type thing you know
Big O notation and such but it's
extremely practical practical when
you're trying to solve a problem but
there are other things and that are out
there and math and they just don't
really have a use for it yet so what I
try to do is I'm trying to explore put
more math into the practical engineering
or engineering to subsume or math so
that we can you know take advantage of
some of these theoretical concepts and
we're gonna really build up to
functional design so it's not going to
be I'm not going to give you the formula
from the get-go will kind of build an
intuition as we get there so here's a
quiz and just
shout out the answer you know do you
think that the following two C++
programs are the same okay there was
some know some yeses now now look these
two things could be in completely
separate files right you know there is a
difference between them well they're in
two different squares here but
fundamentally there's nothing in these
programs we can say that they're the
same if I write these out to disk and I
use the diff program it's going to say
hey these two things are the same right
assuming that there's not spaces and one
and not in the other or something along
that line but anyway so we're trying to
build this idea of sameness so we'd
agree that this is the same for the most
part what about these two programs what
do you think are these the same program
I heard a yes anybody think they're not
the same program it depends and it does
the pen it depends on what the meaning
is of the sameness right and we're
trying to build an intuition here so
these things are not that if use the
diff program they're gonna say these are
not the same right there's extra spaces
in one but syntax wise if you build a
syntax tree for these two things they're
identical
there's syntactically equivalent so what
about these two programs here we got a
program written in Python and for those
of you who aren't familiar with Python
all three of you in here that if when
you print something it automatically
appends the new line so are these two
programs the same what do you think
okay good great so we had somebody say
that this is this they have the same
output sort of the same okay and that's
good
so these guys so we're building this
idea we can even talk about the
equivalence of programs if they're
written in different languages and one
criteria could be that that they have
the same output but is that good enough
for us what about these two programs
there's no output are these two programs
the same the shout it out real loud yes
yes they are the same there is there is
an idea of these being the same because
you know for every input they're gonna
have the same output okay so how can we
formalize this because you know we can
come up with a bunch of different
situations they have the same output
they have the same functions but we
would like to get
idea of you know what is the essence of
a program and how can we talk about
programs being the same as each other so
here are some properties we'd like to
have we would like whatever our essence
is to have strong equivalence properties
so we can say this is the same as this
or this is different than this because
without this we're not really talking
about same loop sameness so we need
strong equivalence properties we want
something that we can write down when we
talk about the essence of a program so
if I'm talking to a programmer and they
say well in my head they're the same and
I say in my head they're different if we
don't have a way to resolve our
difficulties then we're kind of stuck so
we'd like to have something we can
communicate with each other about the
essence of a program and finally we
would like to be able to take any
program apply a set of rules and reach
the essence of what the program is so
just go ahead and think about what what
kind of language we could use to get the
essence of a program anybody have an
idea so the comment is we can use
functions and yeah and that's part of
that's only going to get us a subset of
the way but like going even more basic
mathematics exactly so here we have
strong equivalence properties in
mathematics you learn in grade school
three plus two is equal to five right
they're the same thing it's just another
way of writing five and five equals
three plus two so this idea is a very
old idea is to take mathematics and map
your syntax to mathematics and this is
from Dana Scott and Christopher Stracci
and here's an example of how they do
this you have this function mu which new
stands for meaning so the meaning of
this syntax so when you see the double
brackets we're talking about syntax is
equal to now on the right hand side
we're talking math the meaning of this
expression plus the meaning of that
expression so the plus on the left is a
syntax plus the plus on the right is a
pure math plus and then the meaning of I
where I is some integer like
one-zero in syntax the meaning of that
is 10 in mathematics so we can start
building these strong mathematics but
then we have you know a function and
what are we gonna say is the meaning of
a function in mathematics how are we
going to have a strong equivalence for
something like this well it's actually
not really a problem because we can have
infinite sets so we can say a function
is just a set of pairs mapping the input
value to the output value so if we have
two different functions we can talk
about their sameness by looking at the
set of values and you can represent this
in a few different ways
there's the lambda know K notation and
for those of you who are unfamiliar with
lambdas that lambda see that's kind of
like a C++ anonymous function with C as
the input type and mapping that to C
plus 5 or you know something else like F
of C equals C plus 5 you know that's
something you'd see in grade school that
kind of notation but we do have a way to
talk about the equivalence of functions
mathematically but what about this how
are we going to map this into math well
it turns out there's a problem there
isn't a straightforward way to map this
into math so this is the kind of
problems that they ran into when they
were trying to make a mapping from
programs to their essence in math and
what they said is well we're going to
make a new symbol we're gonna call this
bottom and if it doesn't return we're
gonna say it returns bottom and just
like when you work with math and you
have they first started discovering you
know Oh what are we gonna do about
square root of negative one and then we
get I then you can build a whole algebra
out of that well the same kind of thing
with bottom here and you know I'm not
going to go through all the different
examples of things that we need to add
to base mathematics in order to be able
to grab the essence out of a program but
just get to give you an idea so that you
can do this you can extend your math to
be able to represent the essence of a
program now here's another idea
so Landon in 1966 I wrote this
programming language if you see what I
mean is what it was called and it was
just a purely theoretical language it
was just for the context of the paper
nobody implemented this and here's an
example of
from his paper his big idea wasn't let's
try to extract the essence out of
programs into math he just likes math a
lot and he'd prefer a program in math
than the program in a language like
Fortran so does anybody recognize this
code does this look similar to any kind
of modern language that you guys know
about Haskell yes
so all of the modern functional
programming languages derived from this
idea the essence of functional
programming languages is to program in
math because math has a lot of neat
properties so you see this and then ml
got derive from this and eventually
Haskell but all modern languages look
like this because they're trying to copy
math so great we can program in math why
are we here
because if we can just go Haskell then I
can just stop talking now so here's one
reason let's say we're doing a quicksort
on its and if you've looked at Haskell
at all on the internet you'd see this
really beautiful quicksort
implementation it just turns out to be
four times slower with optimizations
than the first implementation I can find
in C++ without optimizations this is a
problem now you know some people who are
really good at Haskell to be able to say
you know you can tweak that you can make
it on par with C++ and I'd agree you
probably can but what it ends up looking
like is your program starts to look more
and more like an imperative programming
language and you're defeating the
purpose of Haskell in the first place
right if you want a program in math
programming math if you want to program
something efficiently you're going to
have to know a little bit about the
machine that you're working on and
program that way so this this graph is a
graph of abstraction so on the far left
of the graph you've got that guy over
there and very low level abstraction so
he represents assembly language you know
you can get some stuff done in assembly
right that guy can you know put a roof
over his head and hunt and eat but
you're not gonna expect anything
extremely interesting about him then on
the far right side you've got you know
one of these amazing new programming
languages
you know it's esoteric even among the
Haskell users it's just a crazy language
that's so intense and neat that nobody
actually writes real programs in it and
then to the and then to the left of him
you've got Haskell right so very high
levels of abstraction and then who's
that big guy
C++ right that guy is able to span the
low levels of abstraction all the way to
the extremely high levels of abstraction
no other language that I know of does
that so we have on the low level you can
twiddle bits you can do device drivers
on the high level you've got template
metaprogramming which makes extremely
interesting generic programming and then
with concepts we get even further but
basically any kind of abstraction that
you can do in Haskell without any
special extensions C++ can do too
although more verbose that's that's what
we pay for that functionality that
feature and then finally we have the
idea of semantics discovery so this is
Connell Elliott who you see on the
screen here and he's a very he's a
modern proponent of this methodology but
basically you have a problem and you're
trying to find out what the problem is
mathematically so Newton he did this
right he's trying to figure out gravity
how do we model gravity what's this
problem and he had to come up with
derivatives and integrals in calculus
all to figure out how to model gravity
and the different kind of problems that
he was solving so the idea of of Connell
here is you take me you try to figure
out what the essences of your problem
mathematically and then derive an
implementation so for him he would write
his essence into like Haskell based math
and then try to derive a more efficient
implementation in Haskell so now we have
some ingredients here so the idea of
math augmented with some extra
constructs can represent the essence of
code we have the idea of writing
programs in math we have the idea of C++
how it straddles all these different
levels of abstraction and finally we
have the idea of trying to discover the
essence of a problem using math and then
deriving the implementation and that
leads us to what functional design is
so the first part of functional design
is you want to discover the mathematical
essence of a problem and write it out
the second part is you derive and
implement an efficient implementation in
C++ with the same interface that you
describe that you discovered in step one
and if you nail it it works really well
so we're gonna look at some examples but
first we need to improve our
mathematical vocabulary with some new
things so the first thing we're going to
talk about is algebraic data types how
many of you guys are familiar with
algebraic data types okay so maybe 10%
of you so I'll go kind of quick actually
maybe I shouldn't go so quick for the
90% of you so here's the zero type so
we're talking about a type it has no
values here's how you implement that in
C++ now there's a more theoretical thing
this doesn't come up very often in
practice but it's good to know about so
you cannot make an instance of zero so
that type has zero instances so can you
guess how many instances the one type
has one and here's how you implement the
one type and C++ you just make any class
or struct with no members you can make
an instance of this how many different
instances are there of this one right so
that's the one type those are our base
two things there now we have operations
to put our different types together
so the comment was the fact that you can
only have one instance of it doesn't
mean that you can only instantiate at
one time and yeah I think we all
understand that right we're just saying
there's one unique value of type one
and the key there is unique yeah when
we're talking about sameness when it
comes to that that's that's what we mean
look how many different integer bellies
do you have you know and you can make
lots of different instances but you're
gonna have a set range of intz you can
make on a computer all right so now we
have the idea of a product so given a
value types a and B the product of a and
B is the type who types whose values
have n a and a B and if you didn't like
that explanation you'll really like the
next one because it's simple just a pair
right a pair has a value of type a and
the value of type B an instance of a
pair has a value of type A and a value
of type B but that's not the only way
you can represent the product type in
C++ you know you can use a stood tuple
it's essentially in essence the same
thing or you can use a struct now here
we're naming them but that doesn't make
any difference to you know to the
essence of what it is it's still in a
and a B and when you do your semantics
like this and you drive your
implementations you're gonna have lots
of different options and that's where
the engineering part of this comes into
play
so what about this would this be a
correct implementation of a product B
what you guys think no I hear no why not
okay so there's the got it so the
comment was that the difference is
because these have different memory
locations right one is pointing to a
piece of memory memory where the other
one isn't
but in semantics world memory doesn't
matter right that's that's an
implementation detail so okay and then
there was a comment that it is a product
type and I think it isn't but for a
different reason
because it can be null exactly we're
introducing an extra state and you got
to deal with that so the way you can
deal with that is you can just write a
little comment next to it saying that
it's an invariant of this struct that
these things are not ever null and then
it models it properly but generally
that's how it is the comment was a
pointer to an a is not an a well the
thing is semantically speaking it is a
unique pointer in particular right so
it's only there it's only identified by
that construct when we map it to a
mathematical thing the only problem is
null not the fact that it's a pointer
all right so the some type this one
isn't really supported in C++ very well
but basically you have a discriminated
Union a some type where's a product type
you have a value of type a and a value
of type B with sums you have either a
value of type a or a value of type B
it's one or the other and you can
implement this using something like this
so we have a little tag here and it
tells us whether the Union has an A or
has a B and and you put this little
invariant saying you know it's a one has
a equals two otherwise B so that's one
way to implement that and that's fine
and dandy is kind of nasty or you can
use boost variance so a boost variant is
going to have a value of type a or a
value of type B and give you a nice
interface and how many of you guys are
not using boost shame on you
use boost just kidding
no not really all right so we're working
on having a standard variant and I put
hopefully that I'll represent because
there's some discussion as to whether
they want standard variance to also have
an automatic empty state and that's a
very contentious topic right now and I'm
hoping that it won't have an empty state
and it'll correctly model the sum type
okay and so that's our basic algebraic
data types and now we also have a
function type and this is pretty easy a
arrow B that represents a function that
has an input of type a and an output of
type B this kind of maps to our
intuition except for the little point
here that these are pure functions so
remember when we looked at a function
and we try to map it to a set you know a
pair of different values if your
function does something strange like
output or change a global variable or
the same input can have different
outputs depending on the state of your
program it's not pure it's not gonna be
able to map to that nice mathematical
representation so we have to be clear
that when we're talking about a Tero be
in the mathematical sense that it has to
be a pure function in the c++ sense all
right so moving on now we want to talk a
little bit about meaning so here we have
that syntax we've got introduced to it
before so we have mu of this syntax is
equal to some mathematical expression
all right the meaning of that syntax is
equal to this mathematical expression
and then we have down here when you have
an expression in C++ there's really two
things you can say about it right you
can say what it's type is and you can
say what its value is so we have to
distinguish when we write out our
mathematical expression here so we use
this colon here to say we're talking
about what the type of this
C++ expression is and we use the equal
sign when we want us to talk about its
value so in the case of int this isn't a
C++ expression right this is a type that
so we use the equal sign to say that
this is equal to Z so Z is the
mathematical representation of the
integers okay so we're saying the
meaning of int is the integers and then
the meaning the type of the meaning of
three is the integers but the value of
the meaning of three is
three in the mathematical sense of three
so looking at some examples here we have
boost optional of verse e sub one is
some kind of type expression the meaning
of the boost optional is the meaning of
that type so if it's ant it'll be the
meaning event it'll be Z or the one type
so an optional is either going to be
none you know how many different values
have none are there there's just one
confusingly enough so it can either be
the none type or it can be a int so that
gives us the meaning and mathematical
form boost optional and you'll see that
when you take these really useful things
that are in the C++ language and you try
to figure out their meaning you end up
with very simple things and that's what
we're trying to go for remember getting
that simple essence of something and
then if you look at a pair the meaning
of a pair is the meaning of the first
type expression product the meaning of
the second type expression you know this
is just the reverse of saying that
products are pairs we're saying pairs or
products and double can be real numbers
or maybe you really want to say that the
meaning of double can be the real number
is plus these three other states and
these three other states would be
negative infinity positive Infineon not
a number right because those otherwise
don't belong in the real numbers all
right so let's do some denotational
design
okay so so the question was do you have
to express the limits of the numbers and
your types so usually when you're doing
design work you can live with an
approximation you don't have to have
like the extreme rigor but sometimes you
do depending on what you're working on
yeah
so let's do an exercise what what do you
think is the mathematical essence of a
movie okay
one comment was a set of frames there we
agree with that and we have a different
idea what's that moving in a particular
speed was another comment very good ah a
function from time to frame yeah but but
what is a frame a picture a function
from X Y to a color can be a friend
that's like that's a great one
but we can go even more abstract than
that we can say a movie is a function
from our you know the reals time to some
other type it doesn't have to be a frame
we can make an int movie why would you
want to do something like that well
we'll see but we can come up with some
basic operations here so the meaning of
always is so this is the lambda notation
for this we're just saying that always a
creates a movie that for all time is
going to have that value a so if you
want everything to be blue all the time
it's gonna be a very boring movie you
can say always blue boom you got a movie
of blue we can take a snapshot of a
movie you know given a movie at a time
you know we can take the movie the
meaning of movie which we know is a
function and apply the time to it so in
our mathematical world we can say that
taking the snapshot of a movie to
particular time gives you the value with
that that time level we can say
transform things so this one's kind of
fun so transform takes in
something which converts an a to a B
takes in a movie of type A and returns a
movie of type B that's kind of fun so
let's say you have a a black and white
movie and you want to give it a little
purple hue or something like that but
now it's not a black-and-white movie
anymore now it's the color movie so you
can transform one movie type to a
different movie type and time movie this
is this is interesting so we talked
about you can have an INT movie well
here's a double movie that represents
the time at every point so this movie at
time 4 is going to have value 4
all right this is kind of strange but
let's let's try to take these semantics
and now assume we have an implementation
of these things and how would we make a
gray flux movie so a grey flux movie
this is where it starts out as white and
then in one second it goes to black and
then white again and then black just a
gray flux movement so we start out with
our time movie and then we call
transform with our our function which
transforms a value of one type to
another type so so time and seconds is
going to be the input to that and then
we use this stood mod F to basically get
the part after the decimal point for the
time in seconds and then return a gray
image with that kind of grayness and
that's it and we've made a fluctuating
movie so you can see that we were come
up with these tiny little pieces but you
put them together and you get an
extremely powerful language for defining
movies and if we had to find it in
frames and all this other kind of stuff
we wouldn't get this kind of power so
again we're trying to get to the essence
of the problem that we're trying to
solve let's look at another example
what's a stream I'm not talking about
one in a river anybody have an idea what
the essence of a stream could be
so I heard the idea of taking the next
one yeah so we're getting kind of a
sense maybe not extremely concrete I'm
sure you guys would figure it out if we
you know have more time to brainstorm
this but here's one way to do it start
out with the idea of a sink so a sink
we're introducing this term action it
just means it like does some kind of
computation or stateful thing in C++
world and we can do that we can send our
math with that it takes in some value
like let's say it's a a double sink and
it will produce some kind of action
it'll do something okay
and then we have the idea of a source
now what that does is a function that
takes in a sink basically and does
something so the only thing can really
do is just call that sink over and over
and over and over again you know if you
want to have a source that you know
consists of five 5s then it would just
call the sink five times with five as
its argument the comment was in the
notation why not use sink of E as
opposed to the expanded form well you
could use mu of syncope and that would
be equivalent so that that's fine so we
could directly map these things into C++
there's no problem with that this isn't
the only way to do it though you could
do it with concepts as opposed to using
stood function here and that would work
just the same except be a lot more
efficient actually so now we're going to
implement some sources and some sinks so
we have our source which is now our
console input and it takes in the sink
that's what sources do and it's just
going to use C and get and call the sink
with it into
there's nothing left simple enough and
then our console output is a sync and
this just is a function which takes in a
character and outputs as a standard
output of course sources and sinks are
not very interesting on their own be
nice if we have some way to connect them
together so we can do that we'll
introduce this idea of connecting a
source in a sink so the connect function
the meaning of that it'll be a function
which takes in a source and it'll take
in a sink and it will do something so in
this case concretely if the source is s
O and the sink is si we take the meaning
of source now remember that a source
takes in a sink as an argument and we
pass in the sink and that's it so we can
directly implement this in C++ and
that's what it looks like and now we can
connect our console input in our console
output and it just connects them a
comment is is the source a special kind
of sink because they both do an action
and I'd have to think about that so
anyway we have this this connect
function this is this works what other
kind of things can we do well we have
you know here for reference that a
meaning of a sink is something that
takes in a value and does an action what
about the idea of transforming so a
transform from A to B takes in a sink of
B and converts it into a sink of a and
you'll see why I reversed a - B - B - a
in a second here which is the same thing
as saying the meaning of a sink to a
sink here that's like one function but
we can just say this is a single
function which takes in a sink and the
value of a and just does some kind of
action we're just moving things around a
little bit so a transform here we can
say that
it's just a function which takes in a
sink of B and an A and that's all a
transform is so transforms by on their
own art very interesting we we can apply
it to a sink and that's what it was
intended for and I'm not giving you the
implementation this is an exercise and I
encourage you guys to you know just do
it it won't take very long but it'll be
very rewarding so we're just applying
this transform to a sink and it produces
a new sink but we can also take our
transform and apply it to a source
that's not a problem and it's actually
really fun and try to figure out how to
do this so we can apply this transform
to a source now we're introducing some
extra syntax here just because we like
to do operator overloading in C++ and
we're saying that if you have a source
and a transform this syntax source arrow
or source right shift transform the
meaning of that is the same thing as the
meaning of applying that transform to
that source and taking the transform and
right shift to the sink that's just
applying the transform to the sink and
if we have a source and a sink and we're
using the right shift operator we're
just connecting the source to the sink
so let's look at an example let's say we
have this get lines transform and these
are also exercises for you guys and what
this does is it'll transform a source of
char into a source of that should be
string sorry yeah transform a source of
charts with source of string and it'll
just basically take that char source and
convert it into a bunch of strings
representing the different lines that
got read from whatever then we have
unworried Sissel take a source of
strings and convert it into a source of
chars and it'll just take each of those
strings and then make you know that
source
you know output the string and then a
space and the next string and then a
space and the next string and so on and
now we can use some of our neat little
syntax we can say okay input lines we
just take the console input and we apply
this get lines transform to it
and boom we got the lines or we can have
this word outputs Inc now we're taking a
transform and applying it to a sink and
then we got a string sink and then we
can take input lines and put that to
word output and it does what it needs to
do so another thing that would be
interesting is we can take a transform
and apply it to a transform as well
there's nothing stopping us from doing
that in mathematics and again that's an
exercise so here we just make a new
Transformer out of these two
transformers where it just uses the get
lines transformer and it binds it to the
Unwerth strands former and boom you get
a new transformer so my hope is that
you're getting the sense that we get
these pieces that we can put together in
all these different ways and we get a
very powerful domain-specific embedded
language essentially so that's what
happens when you start with the
mathematics and you try to build your
way down to the implementation so I got
one more example what is command line
processing so I'm sure all of you guys
have used some kind of a command line
processing library like whether it's get
opt boost program options something or
other and I'm always very disappointed
with them because it just asked the
question you know well let's say I don't
want to use double dash I want to use
single - well then you got to make a
modification to the library and you know
add new features to it well let's say
you want to you know only have these
options enabled if this prior option is
enabled well then you might have to add
a feature and then your library just
grows and grows and grows and grows
that's a good indicator that whoever
wrote the library didn't nail the
semantics in the first place if you nail
the semantics you can take these you
know strange cases and it can do it it's
perfectly capable of it so command line
processing when you think about it
you're really just taking a list of
strings and converting it into some kind
of value that makes sense for that
program and then you're saying oh well
that looks kind of similar because I
know that the semantics of a parser
like an a parser here where a is like a
char or something like that it just
converts a list of some type into
another type so maybe a command line
processor is really just a parser of a
list of strings so a string part so
instead of char here like you'd normally
have with a parser now you have a string
and so an example of how you'd use
something like this is let's say you
have your help flag in your user flag
and the user flag you know needs to
specify the username or something like
that you can use what you already know
about parsers and make a little parser
Combinator library that works for
command-line arguments so here we have
mix args here so if you have - - help
it'll have the help flag object if you
use - - user followed by a string and
then convert that string into the user
flag now you just have a simple parser
fully capable of doing anything you can
possibly imagine expanding on this a
little bit let's say you have your list
accounts mode so git is a good example
of a command-line program that has
different modes so only if you have a
certain mode open like get sub module
will you get certain options available
for you we have our total command-line
parse this is the result of all the
command-line parsing first you have your
global flags we already had a previous
parser which handled that and then you
have a variant which is either you know
the list accounts mode or the list job
mode and we take the parser we defined
on the previous slide and that should be
followed by one of these two so we use
the or here to say either this argument
or this argument and it just works
extremely powerful there's not much you
can't do with it that's what we're going
for so some of the benefits of this
design methodology you get highly
flexible systems it's hard to find cases
that you can't use whatever you know
programming came up with is hard to find
case
where you need to add a feature in order
for it to actually work for a problem
domain and the pieces are highly
composable because mathematics is highly
composable so you're going to come up
with these little pieces that can be
used in all these different ways to put
together complex programs but the
underlying pieces are very small all
this stuff is really typesafe if you do
it well and the underlying pieces are
simple when you put them together you
get more sophisticated things so this
concludes the talk and I wanted to give
some time for questions but the idea is
you're discovering the essence and
you're deriving the implementation and
there's so much more to this like the
mathematics behind it are just things
that are extremely interesting so with
that we'll ask s answer some questions
so the question was is there a sample of
this code online there isn't and that's
because I want you guys to implement
this stuff so okay so the comment was
that why isn't that unique pointer
example just why isn't that a valid
product type and the reason is because
of the null case because if I try to map
a value which one has null and the other
one has null I can't figure out the
mathematical equivalent of that in the
product type and the map doesn't work
both ways so that's the problem other
questions
okay so the comment was you know what
are some good sources if you want to
read more about this there's a book that
I really like
it's called denotational semantics I
believe it's written by Schmidt it's an
old book you can find the source you can
find the PDF online is out of print and
if you can get a hold an old copy then
the question is is this a standard
denotational semantics it's been around
for decades and the answer is yes any
other questions so the question was how
does C++ relate to value or how does
functional design relate to value
semantics you know and I think the
answer to this is that it Maps very very
well I think it makes C++ very
well-suited because it has value
semantics to doing this kind of design
whereas if you only have reference
semantics it's a lot harder to get those
mappings yeah can I point to programs or
libraries that have using this kind of a
designing I think are well done well
there's another talk on boost spirit
that's going on exactly at this time so
I'd recommend you watch oh I just can't
do that but there's there's quite a few
things out there so generally like boost
optional you know it nails the semantics
but generally speaking this is something
new in the C++ world in particular
you'll see a lot of this in Haskell but
not so much in C++ and I can tell some
of my own libraries like
SF RP if you look that one up on the
internet you'll find a good example of
that so the comment was what about an
embedded world you know when you just
have to move things you know for things
that are more difficult to express in
pure math and that is the that is
functional design right so you have to
take a look at your problem and see if
you can find the mathematics behind it
there are some problems that might be
too complex to be able to find the
mathematical essence of it or they're
just too difficult you know people are
discovering these things all the time so
it really depends on the particular
instance of the problem to see you know
can we find out the a good mathematical
essence for it so the comment was have I
played with syntax that's even more
mathy so that someone would see someone
who's not a C++ person can work on it
and I think the essence of the
mathematical language is pure
mathematics the only time when C++ is
getting introduces on the left side of
that meaning function over there so and
I'm using a very simple mathematical
language here so most of what I do in
practice I use the language Agda for
defining my for as my mathematical
language for semantics
also a comment it was you know for the
mathematical language that was used can
we get slides or something and I think
that all the slides are published online
for this conference I could be wrong
about that but if not I will make them
available yeah so the comment was it
seems like functional programming
requires a garbage collector and
functional design doesn't require
garbage collector there's a lot of
functional programming that doesn't
require a garbage collector so that's
more in the functional languages kind of
area and you can do reference counting
and you know there's there's lots of
different ways you can handle that
problem if you're trying to implement a
functional language but you don't need
it when you're mapping stuff to C++ I'm
glad you asked that question the
question was is functional design
incompatible with object-oriented design
my answers to that is it makes
object-oriented design look very bad so
generally if you can come up with a
functional design it'll be very hard to
argue that an object-oriented approach
would be better but it's certainly not
compatible you can mix the libraries
together you know just because we're
using plain C++ functions so there's
nothing inherently incompatible but I
think it does supersede things like
those design patterns and other design
methodologies
okay so uh the question was you know is
there an example of how I use this in my
company where I work so one example was
I looked at this one class it was called
calculation and it was a terrible
terrible class boy is this being
recorded um but anyway we were trying to
figure out how to refactor it so what I
did is I tried to figure out what is the
essence of this calculation class and it
had like ID and all this other kind of
stuff and we had the aha moment that oh
this is really simple this is just a
function of some kind and then we
reworked everything and we realize that
we didn't need an ID because we're just
doing function equality which is fine in
math so we overloaded the equal operator
and everything just got a lot simpler so
doing the design process is something
that requires someone with a little bit
of mathematical knowledge and discipline
can do but the resulting library is
something that anybody can use highly
consumable so the comment was in a lot
of these higher level functional
programming languages like Agda you have
a way to type check soundness is there a
way to have an automated proof that
proves that your c++ which is derived
from it correctly models what you're
trying to model and there's nothing that
I'm aware of yet for that so all the
proofs would have to be manually for as
far as I know well they're not hard
proofs to do
all right well if there's no further
questions you'll find me afterwards if
you have a question but that's the end
of it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>