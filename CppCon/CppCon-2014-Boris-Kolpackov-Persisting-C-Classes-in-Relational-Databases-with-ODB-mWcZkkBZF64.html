<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2014: Boris Kolpackov &quot;Persisting C++ Classes in Relational Databases with ODB&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2014: Boris Kolpackov &quot;Persisting C++ Classes in Relational Databases with ODB&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2014: Boris Kolpackov &quot;Persisting C++ Classes in Relational Databases with ODB&quot;</b></h2><h5 class="post__date">2014-10-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mWcZkkBZF64" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you for coming to my talk my name
is Boris and I am a found and a software
designer at code synthesis where we try
to make some interesting tools and
libraries possible as plus and the topic
of today's presentation is ODB which is
an open source cross-platform and cross
database object relational mapping
system for C++ the topic is actually as
has two parts the first part which is
now we basically have an introduction
and cover basic operations while the
second half which is right after this
one is is about advanced techniques and
mechanisms that are often necessary when
the whole ORM idea falls apart so what's
an ORM anyway it's actually a good
question and the term is has become
pretty useless these days because people
call RM anything ranging from massive
frameworks that cover the relational
nature of the database completely such
as hibernate for example for Java and on
the other end of the spectrum we have a
thin wrappers of SQL and they call
themselves our aims as well so but so
why would be using RM now there are
several good reasons I'm sure you've
heard the term object-relational
impedance mismatch basically the idea is
that in in C++ you are dealing with
objects were classes data members while
the database deals in terms of tables
columns and so on then there is type
type and name safety if you are using
plain SQL to access the data in the
database you are spilling it out as
strings as a result a new pass your data
as strings as well or in some binary
form depending on the API so
the problem with this is that the
database will only be able to detect
type and name is matches at run time
then this parameter binding in a result
set extraction I'm sure those of you had
the privilege of accessing a database
using some low-level SQL API can say
this is not fun
then this database schema evolution I
like to think of it as dentistry now we
don't like to talk I think much about it
but without it life will actually become
pretty bleak so if we have to if we have
to write a piece of SQL like that every
time we add for example a data member to
to our class then you know you will
start thinking twice we wanted to make
this change so it's not fun we'll see
later some more examples of that why
wouldn't we want to use an RM that's
also a good question
in fact our aims have been getting quite
a lot bit of flak lately and there are
some good reasons for that or I'm so
often hide too much you know you might
have an innocently looking call in your
C++ application which translates to
thousands of underlying database
statement executions which affects
performance so it's easy to shoot
yourself in the foot poems are often
also what we call frameworks they assume
that your application is going to build
around the way things the author of the
framework thought how things should be
done and then of course it's always fun
to roll your own RM right it's only half
of it
that's a signature from the auricle OCI
API so sometimes it's fun sometimes not
so much
so if our aims are not know we choose a
relational database and then we need
something else to make it work for us
why would we choose a relational
database in the first place and that's a
good question
and the answer is there's not really
many aren't really many alternatives if
the data that you store is important to
you
relational databases are mature and a
reliable there is also tooling support
and alternative so if if you know if you
favorite database gets acquired by an
evil corporation at least there's some
options relational model is also fairly
flexible it's not that difficult to map
say a cluster table especially if you
compare to mapping for example a close
to a key value store so if if the data
that you store is important to your
relational database is up at that at the
moment pretty much the only choices
there are some alternatives such as
document databases like a MongoDB or
everything DB but they are not mature
yet so what's what's ODB then ODB is an
object relational mapping system and the
next natural question to ask is what
kind it is what level is it does it
completely hide everything or is it a
low level SQL wrapper well I like to
think of what EBS working on three
levels at the highest level it hides the
relational database completely and you
can just you know store an an object in
a database see in a sense you get an
object-oriented database then when this
and hopefully most of your code will be
written in at that level then sometimes
things don't quite work out in the pure
object-oriented way and in this case you
can step down a level you
still working with classes it's it's a
little bit less pure object-oriented but
you are not dealing with a scale or
queries and stuff like that we'll see
some examples of that
finally for some really low-level
database specific work you can actually
go way down and write native SQL queries
and all IDB will do is provide support
for result set extraction and parameter
binding ODB is not a framework
it doesn't dictate how you should write
your application particularly there is
no special base class that you have to
derive from or special data members the
other thing that we try to avoid in a DB
is is Magic particular we try to stick
to one-to-one or rm2 database operation
mappings and I think we managed to do it
in most places enough in a certain
places it's not exactly possible
and I'll and in for those cases those
cases are clearly identified their
warnings in the documentation and they
also make an ism for dealing with that
we'll see quite a bit of examples of
that kind in the second half of the talk
ok so what are the you know
game-changing main features of ODB the
most important difference between ODB
and other our aims for C++ that
available is automatic generation of
database mapping code from your class
declarations you don't need to write any
mapping or registration code for class
or a data member danno macros this the
another important feature would be is
the ability to target multiple databases
this ranges from having a few specific
ones selected and using the static
interfaces to dynamically loading the
database support code in the executable
and executable action not know not even
knowing which database it's working
with finally this the database schema
evolution this is actually most RMS they
don't provide much support for that or
they kind of say okay well you can
execute an outer statement yourself but
ODB we we try to provide a fairly
comprehensive support for this and we
will cover some of it at the end of this
half and some more at the at the
beginning of the next half okay when it
comes to C++ ODB supports both 98 and 11
when it comes to C++ 11 it uses our
value references they support for range
based for loops we'll see some examples
of that it uses it allows you to use
lambdas and integrates with the C++ but
I dish with C++ 11 additions to the
standard library and I'll use quite a
bit of C++ 11 examples in this and next
half of the talk that makes code nice
and clean as we will see as I mentioned
ODB is also cross database currently it
supports this 5 databases it's also
cross-platform you can use it on Linux
Windows Mac OS X Solaris and compiler
wise you can use GCC visual C++ clang
even Sun Studio anyone here had the
pleasure of using Sun studio I see some
people laughing well if you can you know
if you come if you can compile a project
but sound studio and you know you can
compile it with your mother's toaster
probably ok who knows what that is
right that's that's our asbury part
little embedded Linux computer and ODB
runs on that as well turned out that ODB
and SQLite is quite a popular combo for
a mobile and embedded systems just to
give you an idea a statically linked
hello world example
query support and by statically I mean
everything
SQLite itself or DB runtimes and
application code is about 500 kilobytes
the tool chain is cross-compiler
friendly and their guides for Android
and raspberry pi me also mentioned some
performance numbers and some idea about
performance ODB was was designed from
grounds up for high performance in mind
that uses prepaid statements throughout
and it caches connections statements and
even memory buffers and comes to the
database access it uses low-level
low-level capi so then no wrapper
overhead so you saw that Oh see I've
function signatures so we have the only
BS to deal with that stuff finally there
is 0 for object memory over here in
other words you're persistent classes
they don't have any special members that
take up extra space in fact a funny
thing is some users write and say look
we compared our DB and and we in our
handwritten code that goes directly
directly to the API and the ODB is
actually fast and why is that so it's
quite a funny question to get to to get
I don't know why your code is slower
than all you be just to give you some
ideas about performance numbers this is
what it takes to load an object but
about half a dozen members you can see a
scale light being an embedded data basis
is quite fast licensed ODB is dual
licensed under the GPL and a commercial
license particularly this means if you
are using ODB based application in your
within only within your organization for
example you run it on your company's
service then you don't need to really
worry about any of the GPL restrictions
we also realises this is not a
particularly
neither of these two options are
particularly suitable to other open
source projects that might have
and more liberal licenses such as BSD
for such cases will grant a licensing
exception to any open source project
that that is interested in using ODB and
we've done it a couple of times already
and that works fairly easy you can read
but all this on the DB licensing page in
more detail okay so how does I mentioned
that ODB generates the database mapping
code automatically from our class
declarations so how does it do that
well these days you don't really
surprise anyone by being able to parse
C++ there's clang and then there's the
GCC plugins ODB underneath is
implemented as a GCC plugin the nice
thing about GCC that's really make sure
it's very portable means readily
available it's hard to find a platform
these days that doesn't have GCC on it
it's also one of the most complete C++
11 implementations so that's a nice
bonus the idea of body of the ODB
compile is that you give it standard C++
your class declarations and it generates
C plus standard C++ as a as an output as
a result you can use pretty much any C++
compiler to build your application so
you don't have you don't have just
because you are using ODB don't have to
use GCC as well even some studio and
this turned out to be a really difficult
port point to get across tomorrow I'm
gonna get an email from someone asking
you if they have to use a GCC because
they're using odbc so just to repeat
standard C++ in standard C++ out can use
any compiler to compile the output ok
let's see some code shall we so we can
try to write a little bug tracker
there aren't enough out there already so
great our own so very standard stuff
we have a bug ID status summary and a
description let's see what it takes to
turn this into a persistent class that
we can store in the database okay the
first thing is we actually tell our DB
that this class is persistent so it
knows that it needs to generate database
mapping code for it
next thing is this friend declaration
you can see all our data members are
private so this declaration grants only
be generated code access to these data
members we also add the default
constructor strictly speaking you don't
have to but it makes working with
persistent objects easier then we mark
the bug ID as an as an object ID again
you know in ODB you can have persistent
classes that they don't have an object
ID well but most of you probably
familiar with the relational databases
so underneath it's mapped to a primary
key so in ODB you can have a class that
is mapped to a table that doesn't have a
primary key if you want to we also have
say that it's an automatically assigned
object ID which means that the database
will assign it's a unique value for it
for us so we don't need to worry about
that so these are all the changes quite
a bit of stuff okay normally when you
have private data members you will also
have accesses and modifiers to work with
them in this case ODB will be able to
magically discover and use them in your
in the generated code so we can get rid
of that friend declaration already knows
how to you know it it has built-in
knowledge about quite a few naming
conventions you can see we used get a
little bit different spelling doesn't
know about this one but what you can do
is you can provide a regular expression
that will pick it up so you can add a
custom naming convention for accesses
and modifiers
now some of you might not like the idea
of you know peppering your beautifully
crafted glasses but those pragmas so in
fact you don't after you can move them
into a separate block out of the cloth
you can't even move on to a separate
here the file so this is an example this
shows that you can actually convert an
existing C++ class to a ODB persistent
class without any modifications to the
class itself recall it's here the file
let's now take a look at the build
workflow once we start using ODB he's a
typical C++ application we ever hear the
file they have a source file and source
source file includes the here the file
and then it's compiled by some C++
compiler to build the final executable
once we add once we start using ODB we
compile the header file that declares
our classes persistent classes with the
ODB compiler the output of the ODB
compiler set of C++ source and here the
files you can also ask the ODB compiler
to generate a database schema for us
basically the tables for for storing our
classes we'll talk about that in a bit
the C++ the application source code
includes the January that he had a file
in other in order to get access to the
database mapping code finally the
generated source code is compiled along
with the application source code to form
the final executable
right let's take a look at some
invocations of the ODB compiler here we
are generating database database mapping
code for the Postgres if we take a look
what what gets generate you will notice
this bunch of - ODB files these are the
this is the database mapping code some
example the more examples in a sense of
the be a real C++ compiler in that that
you know the input is is C++ as a result
it supports the standard options for
example - I and - deep is another
example here we enable the C++ 11 mode
and also make the standard sheet pointer
the default object pointer I'll talk
about object pointers in a bit you can
also add this generate schema option and
if we now look what gets generated will
notice Daisy there is this bug dot SQL
file and if we take a look what's inside
and you'll see a table like that which
looks like it could store our bugs in
MySQL so we have we were our persistent
class and then we generated the database
map in code what else do we need well
another thing that we need is some
notion of a database in our application
added in other words the representation
of the database to which we are
connecting so here's how we can create
one for Postgres so we pass a user and
password and database name or for a
scale light we just passed database file
name normally you wouldn't use this in
this interfaces directly and rather
would use the common interface in your
code this has several benefits first of
all you will be able to switch from one
database to another if tomorrow you
decide you know other one to use my
skill anymore I want to use Postgres
then it will make your life easier
this is also how we support multiple
databases you'll see that in a moment ok
let's talk about schema a bit there are
two
options generally you can either
automatically generate it or you can
write your custom schema or maybe you
already have a schema in case of a
generative schema there are two options
we can have it as a standalone SQL file
we saw it early in that bug that SQL or
we can embed it into the generated C++
code so that you can create the schema
programmatically from within your
application when an if necessary this is
how we would do that so there is the
schema catalog object and it has the
create schema function if if we already
have a schema we prefer to write it
ourselves and our DB allows us to map
classes to tables and data members to
columns and we can also specify custom
SQL types for our data members so let's
take a look at that let's say we already
have this we have a database for bugs
the table is called bugs and you know
the column names I'm named a little bit
different and instead of using an
anomaly we use a small int instead so
this shows how we can map all this to
our C++ class so but Adi B you can eat
you can either not worry about schema
whatsoever
and let it generate everything that's
necessary or you can have a custom
schema and map your classes to this
skill okay so I think we are ready to
file our first bug report so I think
that's pretty easy create a bug called
persist let's talk about this
transaction thing I'm sure most of you
are familiar with the notion of
transactions you know dB all database
changes transactional they are made
within transaction and transactions have
this nice properties the acronym for
that is acid sure most of you are
familiar about with that but let me just
recap so acid stands a in the acid
stands for atomic
ann's action is a single unit of change
it's either all succeeds or nothing at
all so for example if this persist
function this persist call fails then
the changes made by that first persist
will be reverted the transactions also
consistent which means that each
transaction changes the database from
from one consist from one valid state to
the next valid state transactions also
isolated means that if several
transactions are running in parallel
they don't see partial changes of each
other and finally they are durable which
means that once the transaction is
committed the changes are permanent for
example if our application crashes
immediately after this commission
returns then the changes that we've made
just a few calls before they actually
permanently are stored in the database
so for example our application Aristotle
be able to see the subject stored in the
database okay so these are transactions
backed up persist call nothing really
tricky here passing the object getting
the object ID as a convenience in return
it's awfully useful to be able to see
what it what is actually executed
underneath so that you know we know it's
not a thousand database statements and
we're not shooting ourselves in the foot
OTB allows us to trace to trace data by
statement execution on transaction level
connection level and the database level
so here's how we can enable tracing for
just for this transaction once we do
that this is what we'll see I think
pretty good
should be something that you will expect
insert all the values you can see we are
actually using prepared statements here
and using a returning to get the ID back
that was assigned by the database
okay so if we have an ID you see we got
the ID here so if you have the ID then
we can use the load function to load the
park from the database this is how we
would do that and the alternative so we
can see we get we are we get the
dynamically allocated object this is
another way to do it we can pass an
instance to the load function instead
remember I told you that the default
construct is actually not strictly
necessary well if you don't have one
this is the this is how you will have to
load your objects in otherwise you will
have to construct it yourself somehow
and if we enable statement racing on
this transaction then that's what we
will see updating the state of a of an
object in the database is also easy it
is a simple transaction will load the
bug report change the status to
confirmed and call update nothing tricky
again this is the statement and executed
underneath okay clearing the database
for some objects if we don't have an ID
for an object and we can use queries to
find an object or some objects that
match a certain criteria when it comes
to queries there are two additional
types that are involved it's the query
and the result queries basically
represents the condition that we that we
want the objects to to match and the
result is a container like result object
which which has a which supports forward
iteration and this is how we can iterate
over it or in C++ eleven much nicer way
to do it we use the range based form
okay let's see how we can find I can
load all the objects that all the open
bug reports in our database this is how
we can do that it might notice that we
use this status member to create the
condition
that is that this query type it has data
members corresponding to the data
members in our persistent class that
which we can use to form a query
condition so in this case we say find us
all the bugs that are open and this is
how we can iterate over it that we that
part we have seen already C++ 11 we can
actually streamline this thing and get
rid of that result although altogether
and do the query inside the range based
for loop this is a nice and clean way to
do it and that's the statement that is
executed underneath let's take a look at
some more interesting examples of
queries we can use logical operators to
combine several conditions to form more
complex ones so for example now we are
looking for open account from bugs you
can also use by reference parameter
binding by default all the parameters
are bound by value but if we want to
execute the query several times that we
can find some variable as a parameter
and and initialize it to different
values and execute the query this is an
example of a native query essentially
you can write your completely custom way
close for it for the SQL select
statement nodb provides your way to bind
parameters conveniently they don't need
to actually convert your stuff to
strings the last line shows the dangers
of native queries remember I told you
about name and type safety so this is a
good example when we use native queries
it's easy to misspell stuff or compare
incompatible values and such errors will
only be detected at runtime when this
stuff is actually executed ok the last
operation that we haven't covered is
deleting persistent objects from the
database we can pass an ID or we can
pass an object itself in which cases the
ODB code just extracts the ID and delete
by D or we can use a query condition to
delete a whole bunch of objects so for
example we can delete all the clothes
part reports our database again the SQL
statement executed underneath for the
first two cases I think nothing
surprising here okay so so far our class
is clearly basic and the first thing
that we would probably want to add is
some kind of timestamps you know when it
was created and when it was modified so
what what can be used to represent a
timestamp now there's nothing in the
standard yet unfortunately how about a
boost
well this boost date and libraries so
maybe we can use that so we can add data
members but the question is will it just
work and the answer is it pretty much
will we just need to talk briefly about
profiles would it be profiles are a
generic mechanism for integrating ODB
with popular third-party frameworks and
libraries essentially a profile is a
glue code that allows us to seamlessly
persist value types containers and smart
pointers from these frameworks and
libraries you know from our persistent
classes OD big as built in it includes
profiles for boost and cute you can also
write your own profile so for example if
you are in your company you implement
that you're on a steal then you can
write a profile for it it will just work
just like a standard a steal to enable a
profile we use the dash P option so for
example here we have enabled the boost
profile and a cute profile so going back
to our question we'll just work well it
will as long as we specify this - P
boost option which enables the boost
profile which contains the code
necessary to persist the map and persist
this timestamps to the database I'm
gonna talk about smart pointers and
continiously later when we cover that so
now I'll just focus on value
so when when it comes to the boost
profile the value types that are handled
automatically by it is a unique
identifier so we can just use that type
in our persistent class and it will just
work now special action required then
they are date/time types and it is
optional what do you think is optional
map to in the database in the idea well
optional is basically either value or
nothing right so what would be an
equivalent in a relational database
button now now now column right so by
default an optional boost optional is
mapped to a column basically but are now
semantics when it comes to the cute
profile again basic types string unique
identifier byte array so you can use
byte array to store blobs and date/time
types standard stuff so for those here's
the cute version of our class
so we use cute strings and date/time
types again this will work if we just
enable them cute profile okay moving on
so far we've used simple types that map
to columns in our class and that sooner
or later we'll want to persist something
more interesting like a container ODB
has built-in support for standard
containers such as effectively set map
and so on so it just used us and it just
works and comes to C++ 11 we get arrays
and unordered containers and the boost
profile covers an ordered versions of
from boost as well as the multi index
container this one is quite cool Ida now
for those who are familiar it was quite
a tricky way to map it but works quite
nicely then we have this cute containers
again
we match the standard one once it's also
easy to support your own container so
you can add support for your custom
containers will work just like any of
the other ones so as an example let's
add a list of comments to our bug report
and also a set of tags again we just add
the containers and magically they are
stored in the database this is the cute
version let me know if I'm going too
fast okay just trying to fit another
kind of data member that we will want to
use soon or late is what we call a
composite or multi column value type
it's basically a class or a struct that
maps to multiple columns in the database
a composite value can contain other
composite value source can derive from
composite values it can contain
containers and pointers to objects we'll
talk about pointers to objects a bit
later can also be used as an object ID
so we end up with a composite primary
keys as an example let's extend our
comments with a timestamp so the first
thing we do is create a class called
comment say we tell or debater that's a
that's a composite value and then we
have a text and a timestamp and then we
just use it in our container so pretty
straightforward I think the a very
interesting kind of data member that we
might want to use is a pointer to object
pointers to object in objects in our D
be used to represent relationships again
all the standard C++ 98 and 11 pointers
are covered the boost profile covers the
it's version of SharePoint and cute
version cute profile covers the huge
SharePoint it's also again similar theme
to containers it's easy to add support
for your own
some SmartPoint and it'll work just like
other ones okay it's an example let's
say we want to keep track who reported
our box right at a reporter so we add
the user persistent object nothing
really interesting here we use the email
as an object ID and we have the first
and last names once we have this other
object we can create a we can add a
shared point to it to our bug reporting
quality reporter so this is an example
of an easy directional to one
relationship so we basically have a park
that is reported by a specific user also
be useful to know which bug is a user
reported right so we can add a vector of
pointers to bugs and call it a reported
bugs so in other words we know which
bugs were reported by the user this is
an example of a budget bi-directional
many-to-one relationship so the park is
reported by a single user while a user
can report multiple bugs okay we have a
bit of a problem here anyone can tell me
what it is right
so we have as an ownership cycle right
we have a shade pointer in the shade
pointer here so we have a ownership loop
well luckily we know how to fix it right
just use a weak pointer easy stuff okay
we have another problem actually this is
the database schema that would be
generated for this relationship anyone
have any idea what the problem might be
any database experts the problem is we
we basically have two foreign keys for
the same relationship in in C++ if we
want you know we have two classes and we
want to point to each other we have to
add a point in each one of them but in
the database a foreign key or a
relationship can always be traversed in
both directions so this is actually
redundant so if you show this to your
database administrator he will scream at
you and say that's not the way to do it
and the way to fix this in ODB is to
actually need to tell a DB that one side
one point in our relationship is
actually an inverse a mirror side of the
other and we do it with a pice by saying
that it's worse and by specifying the
other data member general it's always a
good idea to make the container side in
the purse because then you just get rid
of that whole mapping table okay so we
just tell already that the other side is
inverse and everything is magically
fixed and the DBA is now happy this is
just for us interested a cute version of
our relationship again we using cube
datatypes pointers and containers we can
also use relationships and queries for
example we can look for all the bug
reports that were it
by a user with a last name doe and you
can see here we use this it's basically
looks just like plain C++ we when used
pointer dereference operator for port
for object pointers okay let me mention
quickly multi database support as I
mentioned earlier we can they
essentially two flavors there is a
strike
static multi database support and
dynamic but static we pick a few
specific databases and we use them using
perhaps their concrete interfaces but
the dynamic support we work with with
what the database using the common
interface and in fact the most of our
code will probably not even know which
database it's dealing with then there is
also the mix support the idea is that
sometimes using a dynamic support you
need to step down to the static support
and do something really database
specific so in ODB you can do that put
it another way the dynamic multi
database support is actually built on
top of static so anytime you actually
need to do something database specific
you can always step down to enable multi
database support we use the - M option
and then we specify the flavor and you
will also see this common database which
is kind of strange
essentially this is a common code that
is shared by mapping code for all the
specific databases now if we look at
what what gets generated then we will
see a bunch more files I think
everything is pretty clear this is the
common code and these are the database
specific files let's take at the static
multi-day buy support and here's an
example let's say we have we want to use
a scale light as a local cash for for
objects and then Postgres is a remote
storage so you can use saw a scale light
much faster because it's an embedded
database it's running in the same
process as the application while
Postgres is a remote client-server
application so here we created two
database instances we call one store and
the other one is a cache stores Postgres
database and caches in SQLite database
first thing we do we try to see if there
is an object in the cache if there is
then find great stuff if there is none
then we actually have to go and check
the store which is probably quite a bit
more expensive operation this fine
function is the same like Lord except
instead of drawing an exception if there
is no object it just returns a null
pointer the same logic implemented using
dynamic multi database based support now
we now we write common code it doesn't
even know which database it's working
with so we have this function find bug
you can see we are using a common
database interface and again we have our
two stores and then we just call this
function first for the cash if the
object is not found and we call it for
the store but dynamic support you can
actually package the database mapping
code into separate dll's or shared
objects and load matter on time even
when necessary so this this is basically
an idea how that will look
and we have some tests of that and it
works really well so you can ship some
extra database support for your
applications separately if you want ok
database schema evolution this is the
stuff is quite interesting I think in
fact not many ARMs provide problem
database schema volution support and I
don't believe any other ORM in C++ or
other languages implements anything that
is similar to what a DB does scheme
evolution is a sensitive issue because
normally this production
data involved you have all data and now
you changed your classes and but you
still care about that data that is that
that is stored in the database as a
result the idea that we had with schema
evolution is that we want to make simple
easy to understand building blocks that
we can trust in fact my recommendation
to people dealing with schema volution
support if you if you see an evolution
step from one version and into the other
and it's not immediately obvious that it
that it's valid then it's too complex
you know if you need to think for a
moment does it do the right thing or not
that's too complex already because trust
me this stuff can get really complicated
very fast and we'll see some examples of
that schema evolution consists of two
tacit schema my schema migration and
data migration schema migration is
essentially changes the database schema
from from the old format to the new one
so for example we add or drop tables add
or drop columns
well data migration is actually
converting the data from the old format
to the new one by the way there you
probably familiar heard of this noise
scale databases and schema-less
databases and these people think that
now that because they don't have a
schema they don't have a schema
evolution problem well in reality they
just have a schema evolution problem in
the whole new level so not not having a
formally defined schema doesn't mean
that you don't have any of these issues
ok so let's say we want to enable scheme
evolution on DB to do that we specify
the version actually two versions the
first version is the base model version
it's it's essentially the version the
earliest version from which we'll be
able to migrate I think the idea is
pretty clear you know if you develop a
application for five years in the 1 to K
carry all that migration code from
version one so you kind of want to
specify the cutoff from way you can
migrate well the second version is the
actual current version of your object
model so as an example let's say we want
to add another data member a platform
say that bug effects so we increment the
current version and we add the data
member once this happens well once the
ODB sees this version pragmas it it
essentially tells that he become pilot
and now needs to keep track of changes
to that to the object model and it does
that using a change log a change log is
an XML file why did why is it XML file
why did we decide to use XML well the
change log while it's maintained
automatically by the ODB compiler it
needs to be human readable and it also
would be nice to be able to write
third-party tools that analyze merger or
review the change logs so XML was
actually telling natural choice in this
case a change log contains the base
model so basically the model from for
the first version as well as a change
set for each version starting from the
base well the ODB compiler maintains the
change lock automatically you would
normally want to store to store it in in
a source code repository along with your
with your source files so this is a bit
of a an unusual thing because you know
ODB generates and maintains it but you
still want to store it in the source
code repository this is what a change
lock might look like for our object
model so we have some base model that is
not shown exactly and then we have a
change set for version 2 which seems to
do the right thing well it says what
needs to be done which is throughout
that table bargin add the column
platform so it looks kind of
again just to repeat some people saw
this XML nice-looking XML and assumed
that they have to write it by hand no
you don't need to write it by hand ODB
compiler maintains the changelog but you
want you might want to review it and you
would want to store it in the source
code repository okay once the bundle is
the changelog that would you become
paladin generates schema migration
scripts for us in fact it generates two
for each version the pre migration and
the post migration scripts the IDs and
this is quite an interesting feature the
pre-migration script relaxes the schema
so that both the data conforming to the
old and the new version can coexist
during this step we add new tables new
columns and drop old constraints the
post migration script tightens the
schema back so that only the data
conforming only the data conforming to
the new version can exist in the
database so during this step we drop the
old tables drop all columns and we add
the new constraints so who can guess now
where the data migration fits into this
so in between the two so I think the
idea is pretty clear we kind of we make
make sure that we can store both all but
but the old data can remain in the
database and we can add new one then we
convert the alter new and then we
execute the post migration step we just
make sure that all data can no longer
exist let's take a look at that so this
this is the pre migration step that was
generated for our version two expected
things the only thing that looks kind of
strange is that the column is now while
our you know we didn't ask that we
become partly we didn't say that our
data member can be now well the
reason we do that is because there might
be data in the database already and if
in in the in the back table already and
if we try to add an on now column with
in to a table that already has data that
that addition will fail because they
obviously database cannot figure out a
new value for for our column for all the
existing rows so what already B does
remember I told you it it first it
dropped all constraints and it only adds
the new constraints in the post
so what only B does is it adds initially
the column as now so it then gives the
chance that the data migration code to
assign some meaningful value to all the
existing bug reports and then in the
post migration step it changes it back
to not now okay so let's take a look how
we can implement the data migration here
I'm using again I didn't mention that
but well similar to schema creation
schema migration scripts they can you
can either generate them as a standalone
SQL files or you can embed them into the
C++ code so here I'm using the embed
assuming that we embedded them into the
city last class code and I want to show
how everything fits together so first we
call the pre-migration step 2 version 2
then we load all the bugs all the
existing bugs and the set platform to
some meaningful value and store them
back into the database so now our all
the platform all the new all the values
all the rows in our database that have
the platform column have some the
unknown value to it
and then we call the post migration
script which changes the column to not
now as we've seen before rather than
doing all this ourselves we can rather
register data migration function for
steps that require them and
just do the whole thing and do the whole
migration automatically with a single
function call please
here we are using C++ 11 lambdas very
convenient for that specify the version
and the lambda which has exactly the
same code that we've seen before and now
we do the data migrate the whole schema
and data migration with a single call
let's take a look at another example
briefly let's say we want to you know we
store the username as to two components
first and last name let's say we want to
change it to to a single single data
member now for some reason realized
without it that wasn't such a great idea
or rather store the name as a single
column so let's see how we can do that I
can we increment the version number and
we deleted data members and we added a
new one looks straightforward right this
is the chain this is the so we now run
the DB compiler on this and it updates
the change lock and now we go and we use
D for your beta get your favorite source
control - normally you can review the
changes so we can see okay so this this
is the this is what god added it's a
change set for version 3 changing the
user table added a column and drop -
looks good right ok now we are going to
write a data migration function for this
for this step and also again fairly
straightforward write load all the bugs
and combine the two named components and
set it in a new name anyone see a
problem with this line
they are a much bigger problem drastic
it's actually that the funny thing is
it's it's so the problem is so obvious
that you know people don't realize it
until they actually try to compile this
this code in fact I haven't realized it
until I actually tried to implement it
and compiled the example and and then I
saw it so you see so we what we do is we
get the first name and the last name and
we assign to the to the new name but
remember we deleted the data members we
don't have first and last name right so
in other words you know remember this
this code will write between a pre and
post migration schema migration steps so
the data is actually in the database we
just don't have a data members in our
persistent class to access them so a
question is how can we fix this and yeah
I will finish the first half with that
question and let you think about and
stew on it a bit thank you yeah have
questions
yeah it does I'm actually gonna talk
about that in the second half yes I have
a question okay I the question is is ODB
compiler able to Endel non-standard C++
for example maybe this sum sum here is
included that uz that use compiler
extensions and the answer is not out of
the box so in other words if you try to
compile something like this it will fail
but what it's fairly easy to work around
that as you might have seen at the
beginning that was an even if or D
become policy there is actually when
when you compile your source code you
hear the file where the ODB compiler
defines this they become polymer macro
so as long as you don't use non-standard
c++ extensions in your persistent
classes you can always kind of disable
those special includes just for the ODB
compile so it's all it's doable question
the question is is there support for I
think that the common term is pagination
for this so basically is it possible to
get the first ten elements of the cui of
the result and then maybe next you know
there is usually a offset and a limit to
the query the answer is this stuff is
actually database specific and not all
of them supported
so there is no built-in support there is
no nice function like limit in RGB but
remember I showed you you can notice you
essentially with ODB you can always drop
down to native SQL and and just you know
add whatever database specific stuff you
want so it's it's if if the database
that you are using supports attack for
example post grace it has offset and
limit you just add you know offset and
again you can specify how many very
return and limit how many return so it's
doable it's pretty easy to do question
update queries okay so the question and
a comment was that if we if there was an
ability to kind of update objects in
place in the database rather than you
know loading them into C++ and doing
some manipulation and storing them then
that would be possible and the answer is
yeah well two answers first of all there
is no what we call this a mess update
so basically update a whole bunch of
objects in the database this is not yet
supported but there is a plan for it so
this will be probably in the next
version of two but the problem with a
suggested approach yes it will work in
this case but what what if we need to
implement a more complex logic you know
you're basically saying okay I cannot do
data migration in C++ I always have to
do it in the database and you know some
of them for some of them you might want
to do it that way but generally you know
we can we as an OD be developers we
cannot always assume that you will
able to implement the data migration
inside the database like for example
SQLite doesn't have stored procedures or
anything like that so you know the the
things that you can do in inside the
database are pretty limited okay any
other questions I think we are done then
but there is there is a solution for
that so you can come in about 20 minutes
and learn about it thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>