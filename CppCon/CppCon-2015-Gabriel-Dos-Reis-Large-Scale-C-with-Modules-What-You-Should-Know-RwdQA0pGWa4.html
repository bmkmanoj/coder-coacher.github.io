<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Gabriel Dos Reis “Large Scale C++ with Modules: What You Should Know&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Gabriel Dos Reis “Large Scale C++ with Modules: What You Should Know&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Gabriel Dos Reis “Large Scale C++ with Modules: What You Should Know&quot;</b></h2><h5 class="post__date">2015-10-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RwdQA0pGWa4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay good afternoon everybody
I wanted to give you a brief update
about the module efforts that's going on
I know I'm hearing a lot about the
modules for at least the last 15 years
or so what are you trying to do is make
you free all this time so where we are
today today here taking an example from
the Anna's book Cintas class usually 80
is this data type called dates which is
quite interesting because if you really
want to represent dates in C++ you get
quite interesting design problems to
solve in terms of data structure
abstracted attack design and server on
the left hand side know the screen I
have very small program which is what
I'll call a consumer of the data type
date okay so all I have to do is to
include calendar date of H I include is
3 because I'm going to do something I
owe and then the rest is quite
straightforward right
on the right-hand side is basically what
we call a header file the interface
header file that gives you this abstract
the time your notice it's silly bit more
involved and you'll tell me well it's
supposed to be this library so it's
supposed to be more involved the very
last we have this thing we all deal with
it so if they have this then do other
stuff just to guard against multiple
inclusion just first week and I know you
learn when you learn C or C++ I would
like us to be at a better place which is
if you look at the slides the only thing
I change was just to remove the hash
includes and we replace that v of fancy
word calling imports okay and if you
have been using Python or any of those
contemporary languages
familiar with this the left-hand side
doesn't change much the left-hand side
change little bits you don't have the if
death kind of things now I have fancy
key words you know imports module and
experts and so you ask me why what is
the big deal why do you why would I want
you to be there well the first thing
ability is that if you take the client
code it's only about 176 bytes if I can
trust the only tool that gives me that
number then you run back through the
compiler so this is what the user sees
okay
the interesting thing is that today that
is not what your compiler sees this is
what your compiler sees okay this you
see hopefully expands the old program no
pre-processing into about half gigabytes
time we'll see well I'll give you full
bigger bites and and and VC plus twice
is just behind okay and you know it's
cats I don't know what I would call it
compression or expansion or inflation
just know look here I turned those
numbers into some graphics you just
getting an understanding so the baseline
is the program so it would be just one
bite and everything else is percentage
of the fact that we have this
compression of 5 more than 500,000 is
impressive right now why is it a big
deal now the problem here is that every
if you have a large team or company
people writing program using consuming
this at a time what they're going to do
is most of the time include the iostream
because that's what did you see out a
bunch of other stuff and then it will
encourage the dates had a file so every
hit a fire so every source fire in your
program or everybody think
to this comparable to it's going to to
do that right and what happens is that
well
the preprocessor once they hash include'
what actually does is they hey good a
look at that head of that file and give
me the content it's copy and paste we
are rail against copy/paste programming
we did orator at least we've had from
the air compile okay and look at it very
carefully this is one of those places
where we fail or the language fails us
in this you know motor which is you
don't pay for what you don't use when
the compiler goes and copy the contents
of that file it doesn't just copy what
you need the cop is everything right so
the compiler goes on and in process
listing legs parsing you know it cannot
really precede us what you're doing
template instance issues of resolution
all those things so this time
ninety-four support of symbols and then
linked here comes in saying okay I can't
have to throw everybody out let me
except one so forget about that now we
have powerful computers this at least
you have to care about the planet this
is not dream programming okay so where I
want us to be is place where we don't
have to worry about copies because this
is copy it is quite possible that you'll
get slightly different version of what I
have we got knowing of that asking for
it and even ask for you should get this
slightly different copy right and this
happens either because someone defines a
macro that's not expand rename something
you didn't ask for oh you get a genius
on the team who comes and you wanted to
modify slightly you do
litter obstruction dicks and you say no
guess what he did when a copy we have a
file in a new directory slightly modify
and then splash the include directory
right in front of yours now whenever you
fix bugs in your own hand of fire you
don't get it because something is got a
better idea
okay and there it is it's very difficult
to get tools to enforce things so this
sounds like a joke but I'm just
abstracting from reality this is things
that no people faced there today and I
talked to Dave that's what it taught me
okay the other thing is new mechanism is
based on C preprocessor it makes parsing
or analyzing super stress
extremely difficult if not impossible
the reason is if you want to correctly
personalize in a fire you need to know
is set in the full set of macros that
you need to do this food bill you can't
just say oh this won't affect you know
I'm going to get different codes so I
guess what I want to say is that we do
have pressing needs in front of us and
this is a charge set of challenges for
for C++ these days you hear a lot about
cloud computing and cloud build that
kind of stuff well if first thing is if
you want to take advantage of the cloud
you must be very disciplined this is
where you really want to component and
just for school you want to have
dependencies because you know what you
look at your first fire and if you can't
tell them how things I use semantically
not just the timestamp of the fire but
how things like what is used what is not
used and if you just slight modification
maybe you don't actually need to
recompile entire world you just need to
compile that's tiny part that dependent
something you change okay to get there
we need exclusive dependencies in the
source program we need computerization
and we really need to move the language
place where we can have better developer
tools okay I cannot emphasize this
enough and again is the room so you'll
back me up I'm pretty sure so that the
fact that we have macros have stiffle
development for the developer tools no
it made it very very difficult to build
tools thanks and the interesting part is
that in most cases we don't need these
macros and it wasn't a well behaved
looks like they could go to show the
earlier was for the first slide and
there's no configuration and if we can
only have those will be in fantastic
place and that's where I want us to be
that's where I want you to believe you
can be in the year not more okay so the
end of this module efforts is to bring a
module system that allows you know I
can't repeat this enough okay this is
not just about build improvement it's
very important but you need to benefit
from the build improvement you first
need to get your house in order
you need controller transition you need
isolation from bathrooms this is very
important for the tools they built
instruction gives you in the best it can
it must be able to analyze your source
code right if you depends on macros
forget about it and of course once get
back you can now now take advantage of
the cloud build this we did build and we
get much more much better built recruits
and and of course all these depends on
developer tools you know that no takes
into account semantics to earlier this
morning you saw I guess it's herbs talk
and most of it was based on analysis
and trying to give you this safety
without changing the language if your
library at all for that to work
yeah we need to do program in a way that
is easily analyzed oh okay the same
types of seekers West does not define
super spies
it is the semantics it is quite possible
to have very nice syntax I guess what I
want to say is have a very nice you know
program expression of 30 years in C++ we
got using all the other parts that make
it very very difficult and modules
actually help you do that and I'm going
to illustrate that she moved oh yeah
one last thing I am not proposing and
I'm not suggesting that we try to remove
or replace or included preprocessor it
has me there for more than 40 years and
people have found creative ways of
abusing it and we cannot get rid of that
in the next 12 months and let's not try
that okay so I guess one thing I want to
say is if at the end of this effort we
end up improving a preprocessor
somewhere we have failed
okay so first question is it it's all
sounds nice and you know works but when
can I use it we're gonna have some
traditions in trying and of that but now
today this happen I can announce that
you get an experimental implementation
from a Microsoft compiler and update
their 14 update one timeframe
I'm not imposition of 10 exactly the
exact date because but I can tell you it
is in that timeframe you'll be able to
test what I'm going to to show shortly
and of course I want feedback from you
guys because this is the only way we can
ensure that we get it right
ok at least close enough know when get
out I want you to try it
and send
spin back have fear lives you say oh
this is so complicated we shouldn't do
it in some insane no we can and we
should we shouldn't wait so what is the
problem that we're trying really to
solve so the program organization that
we inherited from seed is this idea that
you compile source files but what a
compiler sees is in society the code
translation video so essentially it
takes a source file looks at all the
includes and expands them by doing copy
and paste and sometimes they have
conditional inclusion so we have
conditional expression basically have a
huge pile of things now what are those
things most of the fire will see
definitions and then declaration
especially why don't you have your
programs you have several translation
units and you have to communicate
between themselves so that became know
do something useful the way the
currently between themselves is to say
oh I think I know about the function foo
it takes an it and returns eight the it
is not a provider of that function foo
like to say that it is the user so
someone is just claiming and there is no
here the compiler is very fine I know
what it is please make the call if he is
a guess right
it's okay it's strong getting disaster
and we all know this okay
the the other thing is the linker when
compiled as its magic and and put a
bunch of simple definitions link it
always sees is shrinking bites our 4x4
by good go ahead right that's not good
this will be getting other problems as
an illustration here you have the basic
linking model I have three source files
on this slide the first so let's look at
the middle
you know in red you see these
declarations with that translation unit
is the one brandishing this declaration
hey another body function quad it takes
two in some returns an eight and I'm
going to call it and compulsive okay
then it will remit
no please satisfy this simple definition
a link time so if you bring in a source
file it's a soft by one dot C see the
thing I like here quant is just the sum
of the squares of the argument you link
them good get a program another that can
come in say hey I have the quad it only
adds the absolute values of the argument
you can see from hostage get another
program the only thing you cannot do is
to put all three together something
that's quite interesting here is that
the the consumer of quad is one claiming
that it knows something about quad right
and this little things that accompany
linker can actually do to verify all it
verifies oh we have only one definition
so if for example in in Sourcefire one
to CC the return value was double guess
what happens most of the time get
garbage we have no way of verifying that
and there is no fundamental reason we
can't do better we can't with modules we
can do better
a person who is what to consume
something has to request who is the
provider in providing say here are set
of things that you can use dot that way
the linker get to see you know the
entirety of what's going on and can
translate no transfer information from
one transition into the next and and
into verification okay root cause is the
one definition rule something that we
hold very dear and I'm told that this
was actually meant to be true also for C
but in synthesis is even more
fundamental so we're told mehe
ask Dennis Ritchie in 79 I think I was
probably somewhere in primary school or
something of that and I didn't say well
the idea was that you have exactly one
section of so sticks that define
something okay today years of what you
want official you're supposed to copy
things wrong and in fact that we have to
include these at the time just a quick
hack to get something up and running
okay now when you take that very simple
no design principle and you're looking
for it in the standards document God you
you you get pages of obscure text
telling you how this one diffuse you're
supposed to work sometimes compiles
actually get it wrong wonderful finds me
wrong for her oh haha but to get a lot
of bugs and compilers based on one
definition rules sometimes they are too
eager sometimes naughty enough and part
of nice obscurity of the text is the
fact that we don't actually have a
module system okay and the fact that the
Texas obscure is just the reflection of
this work around the lack of module so
let's get modules okay so what is the
module I don't have time so I'm just
going to give you this you know 33,000
feet view and I hope that is sufficient
for you to get going or really using
this stuff so essentially let's look at
the example I started with the from a
consumption point of view you just
replace your hash includes with imports
if let's say I'm taking dependency on
you know module studio
I'm dependency on module kill under the
things and then you do the consumption
now what really is going on is that a
module is just a collection of let's say
object files you have compiled of source
code and then you have declared sets of
entities to be the only entry point into
this castle okay within that module you
can have as many source files OBJ's as
you want right it is not the motor is
not necessarily just one file you can
have many file just like we do today but
what you get is you get one single place
where you declare the entry point into
that module anybody will want to consume
module will have to depend only on those
k-tec we can't get a a function name
because you look at the header file
right you can use only the things that
modules would you provide it gives you
so as a symbolic name here I propose
that you use if you are about naming I
call it my module and on from the slide
you get to the two dot IO Canada update
it's kind of naming module names are not
in the same namespace as classes or
class names or namespace names they're
completely separate names if you don't
risk having clash of names between type
names and and module names I think
that's essential so only on
implementation side here's what you can
do right you go to use today or to
implement no formatting so say I'm going
to take dependency on studio I'm also
going to take dependency of I'm still
string because I'm going to give
representation string representation of
the date and then you declare module
Sony the first line there module
calendar the date is the line that says
this source file is part of the module
calendar
and anything that comes after that line
is part of the module
anything that is before is not part of
your model okay so before you have the
module declaration you can't have
include files it worked too
so here on on this slide then it gets a
namespace all namespaces are always
exporting because today what we have is
that a namespace you know expands across
several source files right so the only
way you get your local namespace is
either you have a animals namespace or
you put the namespaces seven on English
names that's how you make names they
still owe it all to two module we don't
change that and then they'll put your
declarations the only thing that is new
is you stick the keyword exports in
front of the definition or Declaration
dot okay export is an existing keyword
that doesn't have any meaning in
super-stressed 14 i'm just repurposing
it for for forego jewel coach if you
feel like you're tired you don't want to
put expert on every definition you can
you can just put the experts on the
namespace and everything that's between
the opening brace and closed breaks get
exported it's just a shorthand and of
course you can also use in code files
and so I say you can include any header
file that we have today as soon as you
do that before the module declarations
then they are not owned by a multi
declaration so my recommendations is
money have modules you write in your
source file whether it's you're
consuming on producing first if you have
to use it could include file first put
the includes always second puts the
import statement if you're taking
symbolic dependency
thirds right promoted occurs in module
name then exports whatever you need to
explore okay if you do that systemically
you will not get any surprise okay
surprise you I mean we know today that
you have to be very careful about the
order of inclusion otherwise you get big
surprises it's hard to debug so that is
basically all you need to know okay so
we're done quite summary what um now
this design is promising is that you get
complete isolation from macros when you
import a module so let's say bought
module studio the way the compiler bring
it to you is as if that module has
already been compiled so in the standard
jargon we say has been processed through
from translation phase one through seven
don't worry about it just meant it has
already been compiled in some form if
you if someone defines a macro in that
module in that interface you don't get
it if you define a macro in your source
file before you dream import because you
have some good file that play that in
you don't disturb the the model was
given to you because that module was
already processed before you get to
consume it so you get complete isolation
from microbes this is not science
fiction
it's what you're going to get from the
visual C++ implementation the other
thing is that now we actually have the
OTR in this sense that every entity that
is defined in exported in module as a
unique place you go and look okay you
don't get these header files that you
have to include that gets copied in
several places no you have defined your
entity only one place as dentistry to
say it
and then when you when you compile in
both your interface the compiler
generates some metadata to remember how
the corrosion looks like what is the
type of the argument or it's a class but
I remember is that kind of stuff but you
don't get to process that thing's as if
you're parsing lexing over and over
again it's really really no already done
the other thing is whatever we do I
really hope we don't come up with a new
name lookup row I don't know how many
name lookup rules we have but I think
you have too many and we don't need
another set I haven't seen any
improvement to simpler stuff Denver cop
rules that didn't backfire
so we'll try very hard to stay there and
not bring you the other thing that you
need to remember is that I want you to
prefer modules over header files however
we are not going to get rid of Paper
Scissors there are situations where the
best thing we can have today when it
gets modules is still include five
circles if you get to generate just text
you know sometimes you have these little
things that you want to generate just no
state you include the file several time
right that's not modular a you just want
to generate it you continue using those
include files and if you define macro
they will not escape from the module it
will be completely encapsulated and
real-time will be faster
now many people modules how do you get
interact with this whatever you know the
rules of engagement anything you have to
expect and really want to emphasize this
is that you get Odia
to the best that we can approximate
because we still have to use no good
files for certain things but entities in
general are defined all in one place
so you get to be able to develop tools
that would be less painful to write
right today when you're looking for a
class you have two classes to first five
distant source fires even you're
supposed to just say oh it's the finally
ones you still have to go and compare
the fish and eventually say oh they are
the same as how you get these abysmal
performance for things like our ttio
dynamic cast where some implementations
will just go and compare strings instead
of comparing pointers right because you
know you have these talking things going
on
the other thing good news is that if hey
so sorry
remember I said when you're consuming or
producing modules you put your input
files import statement both of
declarations and your definitions right
so imagine for a second that you don't
care about header files now you have
import statement the order of importance
meant will not matter anymore
I became permeate you don't have to know
to worry about Oh which one have to
import first no it's irrelevant
okay again modules are easily from
macros and the other thing that are
pulling out earlier is that with the
include file we pay for things with on
you with modules we pay only for things
we use if we repair all right so you
have this kind of you say import what
the compiler does is it's Liz Lee brings
into life the entities in fact doesn't
matter as anything it just brings any
name when you happen to reference stood
vector Oh someone is asking for stood
what is too documentary is good what is
vector or given vector anything else
that was in their source file is not if
it is not used
life so really pay for only four things
to use and and this is places where we
getting the improvement spinning profit
the compiler will generate metadata use
you can use these to transfer
information from one source five the
next and and the other thing is
ownership so what I call ownership is go
back to the OD are the when you have a
an entity class function a variable
global constant that is exported from a
module B that entity has an entity right
and the module where it is defined is
part of it okay
this is specially true for things that
I'm not exported but for tailor exported
this is what I propose I know that we
still have some work to do in a turret
have agreements among the implementers
but the idea is that the modules have
strong ownership of the entities that
will allow you to have better
performance in terms of you know a
dynamic past four classes that it occurs
several modules you don't know you don't
have to worry about what area it is same
when it happened to be in distant
modules they are different they
understand it cannot possibly it same so
we get some transport there just a quick
submarine it based basically under some
terminology we we need modules to work
with things we have today things we have
today is that you include hello fire to
define you know entity using server
concepts you need so you have to match
them together but when we have modules
modules own stuff the own stuff that are
in their purview so what I call it
purview of a module is every declaration
that appears after mode
so the new class month here isn't a
purview of module calendar that month so
it is owned by that mode and that comes
before if I had some profile that
defined some software they are not owned
by however if you don't follow the
guideline si which is you put the
include fire after the module
declaration remember what hashing to
this it goes and copy and paste the
content so you accidentally bring
something that is owned by an alum but
you get into trouble so please don't do
that that's why you put all your include
first the ending in course any module
declaration so this basically probably
only really to pay attention to really
happy you poor declaration I've said
earlier that I don't want a new set of
numerical rules yet we have namespaces
that span several modules and Sourcefire
so how does that work the way it works
is we have to go back and look at what
it really is we're doing today and say
well when you complain your source file
the only thing that the compiler really
sees is the portion of that namespace in
your source file right namespace STD
spans several from special units right
but when you compile source file it's
only that portion of namespace that the
compiler sees it doesn't know whether
list exists unless you bring list in yet
you'll be different on special units you
get lists to make the nimac approach
work properly just the winner today we
get to define you know introduce this
notion of namespace partition we just
formalize this notion that well a
namespace
a namespace partition is the portion of
a namespace that is defined in the
purview of the module so it all rules
you know about namespace today if you
replace names days with news these
partitions they work exactly the same
and you're done that's the only thing
you need not
okay so ownership I said earlier that
every entity that is defined in the
program is owned by some module and I
know this is a point design point that
we see working on inside I actually pass
first committee but it comes from you
know needs today we talk what are you
talking about these ownership thing we
you know the only vocabulary that the
language give us is linkage you see
external linkage symbol that's visible
by everybody else internal linkage
there's only one translation units and
then no linkage so if you define local
clash that little class has no leakage
but when you're in module you get to
define some symbols like you know it's
used by source files in that module but
you don't intend for them to be used of
to be visible by folks outside that
module right so you get a formation of
linkage and you can go on I I don't like
the notion of linkage I think it is a
very low level abstraction something
that's very implementation orientated
and the proposal as it stands so far as
try very hard to stay away from module
also from not so much
from linkage so what we have to do is
just you know biting strings and and and
interning cage externally kids
the reality is that a component we have
I already aware that these three linkage
certs
don't don't work they had this notion of
you know visibility you know this is
theologian clung allows you to put
attributes on declaration say Oh
invisibility of this symbol so
visibility here is a little incredible
is the default which means whatever
language says I say oh it is hidden so
it's actually it means that this symbol
is defined in this module and you cannot
lexically use it in a different module
but you might be able to take the
address of that entity and pass it along
to another module internal really safe
it cannot even take the address of this
entity and give it to another module so
this allows you faster link and you can
import things like you know Artie is an
Democrats that are kind of no very
efficiently because now you know the
boundaries of your entities you don't
need to do these three compare you know
where you are so and of course if you
C++ has its own set of visibility rules
we've really important experts I was
looking to guarantee is that when you
get receivers plastic rotation for of
modules the only thing you have to care
about for now is DLL export because the
11-part is automatically handled by the
compiler it's something that I know is
folks so you get them very confused so
to support I talked about know the
general view aspect things you can
expect and how does it work
I'm not going to do live them all
there's a lot of time I don't have
everything set up but I'm going to give
you an overview is that kind of dot
which what's going to happen so when you
have your first file and use modules the
way you compile these
invoke your CL as usual the - see for
example and to enable the module
cymatics you have to supply the switch
module right / module all - module what
happens when you do that is as usual the
component is going to produce the obj
file however because you have modules
now we can actually generate metadata it
is essentially the you know a semantics
drive of the all the entities that you
have exported from that module right you
have this distinguish suffice module
interface and compile it it generates
that me to do that all I have c5 and
that's the only thing that you need to
consume that module so imagine using
compression you compile the source file
contains the interface file it generates
an IFC file then you can continue in
parallel compiling the source file in
these modules
sorry net module but you can also start
compiling all the consumers after that
module because all they have to care
about is the set of expert it is there
so you get this kind of built in little
person so now we have a source file you
really want to see this source file is
the one that contains the the interface
explicitly supply the street slash
module interface and only construction
site all you have to do if you combine a
source file that imports a module you
have to supply your first enable the
module semantics but you also to supply
a switch that says oh I'm referencing a
module in that file okay
in fact we can have any file okay today
when it's all we think about source
pinna fires visually helps you say
include Canada
dates / div dot H we expect somehow to
have a file or if fascism somewhere name
dates of H in the folder calendar that's
under something let's search somehow
right with modules there is no
requirement of a kind of one one-to-one
mapping between the module name and the
binary file that contains the module
interface diffusion it's purely
content-based and we find this very
important the circle options you have
essentially have no / module that turns
on mono semantics you have module
interface that that's the the fly that
you use to compile the designated source
file that contains all the expert any
given module can only have one source
file that has the exports all the others
are just incrementation units one that's
interface and once you compile it into
some binary format if you use module and
that module interface is in some binary
format you will reference that in a
command line is slash module so even
slash module reference that fine name
any compiler will use it you know and
try to find module interface definition
if you can find it will tell you and
then you'll see in fourth option which
is there essentially to help folks who
do build on one machine and deploying a
different machine where you can actually
reference the binary files by absolute
path because when it deploy it's going
to be in a different file system so you
can tell the compiler here is the set of
directories that you can search for
these files that I'm referencing on the
command line okay and you know one thing
that comes bonus is if you happen to
have the same reference files in
different directories then the compiler
will tell you some
we don't do today with a good fire which
allows geniuses to create havoc so we
have an affianced today
some of them like system header files
they are not mojo at all what I mean by
modular is there a lot of macros you
know if they have it's it's insane okay
take Windows dot H it's nightmare
now I'm not picking on my employer take
uni STD dot H same nightmare okay so it
is just system header file but if you
happen to have something like infected
like Canada dot H which is the you have
a compulsory that allow you to consume
it as if it was a module they will you
do it is just included in the source
file and compile any compiler please
export this source file as if it was a
module and the only command line you
give a command you know the name of your
module and what the compiler will do is
well I'll pretend that every top-level
declaration top level meaning namespace
scope no next to them as if they were
exploited if something is declared
static it's ignored if something is in
unnamed names which it is ignore but
anything else that top level is is
compiled as if it was prefixed with the
keyword export this is to a folks moving
from header file based architecture to
module architecture and has been used
internally at Microsoft so I made a huge
first about matters yet here we have a a
compulsory say that's a Oh X for this
Metro
in the ideal world I don't want to hear
about macros but only in the idea words
I have to you know do with what I get
when you get some system verifier you
get macros that cannot do with that
right so let let take two IO dot H from
see this Easterners say is that you can
either have they're defined as an object
o as a macro so the first experiment I
did with the Microsoft compiler say hey
let's turn to the IO dot H into
something you can consume as a module
great works now imports today oh no F
printf stood out oops
I know what stood out is what do you
mean you don't know what stood out is
never getting in a fire
oh it is defined as a macro so for
transitional you know when we want to
turn things and a header files based on
macros into you know something that you
can consume it is not automatic
modularization it is you just compile it
can consume as a module sometimes it is
necessary to have these selected macros
as okay you know I you know all the
other macros except these no these few
and and export them now I have to be
very careful there is no depe dependence
analysis but whether you explain the
right thing or so forth so it is there
just to eight you for you know in
transition transitioning from source
file based architecture to module thank
you okay so this metadata and I recall
in IFC so essentially now when you
compile a module interface source file
which generates what I call the abstract
semantics graph of the x4e declaration
it is a different representation I can
think of it as a different presentation
of of signals class right with these
metadata file utility needs a C++
anymore it is just a binary simple
binary format and even with you know the
community that you can write a parser
for in any language you want and if it
is all complete probably get about two
or three hours of homework done you
can't write the C++ structure pastoring
in two hours okay
so these go lots of something and say it
is that you have to take super spice and
its semantics is very different from the
surface syntax the user interface we
have to be right the I have scenes gives
you a super space in a different
notation okay and this is actually the
ideas for doing this is pay something
that I did with biani back when we were
in Texas but ten years ago called the
IQR you say something that we only
studied before I try and and you know it
gives you a complete representation of
C++ programs and in it was a small
library but was generally enough and
efficient enough that you know you can
represent our Terrace across bus isn't
very just using a few numbers no because
now you have super stress related in
slightly different way it's that's
easier to manipulate I hope that we'll
see more more developers ruling the
implementation that will come with VC
will come with manipulate manipulation
tools for Phi FC is gorgeous I have C
dot XZ it allows you to embed to take an
IFC module into compiled interface embed
it into a static clip or a DLL and
that's what you give your consumer so
that now we have just one single thing
and it is self descriptive it is both
the executor code and also a set of
declarations that you need to consume it
and so this is how DLL yeah I have see
they have seen
FC - - embed that in bed your FC into
study clip or DLL you know the battery
formerly I have the binary former you
can embed it in just about any binary
form we can consider its its so this
basically what you can expect from a VCS
implementation no the two side so we
give this to internal developers food
really really wanting we know ya means
Dan means of module ready very well it
today and the feedback so what do I get
this feedback the first thing is of
course syntax they the impart ways to
make sure that it doesn't turn into
something you don't recognize I will try
so the of course they get to use it
they'll find it they like they find it
very useful they like it and they
worrying about being locked in yet
another Microsoft extension and so the
worried about standardization and they
really really wants the devs have been
talking to they really want module
yesterday so you're asking is it going
to be in 17 we are trying I don't want
you to be scared not just because it is
new means it is so impossible to do know
this is something that we implemented in
a visa compile okay those of you who you
see know all details about what we see
right doesn't have HD that kind of stuff
but what you have in the AFC is an
abstract semantics graph right I
suspected
in May the other compilers and we can't
do it before 17 comes out so we can get
it miss Tanner they they worry also
about the IFC format they they want to
know whether clang or GCC will have the
same binary format I don't know I don't
think it is ready yet for iesous style
but I think it is ready to consider as a
technical specification you know a place
where we we experiment more with the
binary follow we know what the semantics
should be they know the semantics of
module that there is no very low things
together that we just have to find
agreement on what I call secondary
points and write these numbers but we
leave banner if formerly file the binary
file that is produced as part of
metadata that will need more work than
to do today so I'm not touching that
binary format as soon as it was part of
sequence or 17 however very very much
want us to have modules first and then
work on the on the binary formats
technical specification that follows
almost immediately and so what I say no
not right now maybe the reaction I get
is incredible that really giving me any
telling that you guys can't agree on
having a a common format for
representing the compiled binary you
know modules look you're not guys have
it know Java has something sous chef has
something you guys can tell it so maybe
this is a place where not as bold as I
should be maybe because I'm so focused
on getting the semantics
you know the modules to the programmer
so please help me and so last word
about visibility people usually ask hey
if I experts in class that has private
data members protected a member in
accessibility are they also export it my
answer was kind of they color what does
that mean kind of well I try to turn a
community that it'll be really useful if
we don't export also the our private
data members and I was unable to
convince the committee like come on be
serious
so again help me help me make the case
to the committee that this is something
that is important it enables things that
you know will be really useful to have
you know if give you an example take
card build for you it is possible for
this guy to give us amazing speed up if
only you can guarantee that certain
things are not used or they do not have
any semantics impact so if all you do is
to change a a private function parameter
time that doesn't have any semantics
effects outside the module why do you
need to recompile everybody who is
consuming that module it doesn't have
any impact
okay so and if you can give him that
they will give you huge speedo right
because they do you know did the
finale's is on things that I use they're
not used outside the motor it is this
policy that we need to worry about
so as finance fine I want you to know
I'll encourage you have to go to Steve
Steve Carrell and evens talk on Thursday
that no gives you more perspective on
what
what's coming in what's new in C C++
2015 and the future directions of these
you know C plus were to set coming from
a pure steel that will be my last slide
and immediately questions
so yeah so the question is where have
consider ability to consume the you know
the module fc5 the binary format it with
the data from source files there at this
transmission unit we do hope to give you
API that allows you to just open a file
and just read the declarations or
definitions yes
at this point there is no language in a
Collingwood supporter says oh just
magically make this metadata data type
or sorry did this structure in some
special unique which will give you some
compile time reflection at this point
there is nothing that but you have to
know I'll just say about what happens if
I try to compile a consumer before
compiling the module so the question is
what happens if I try to consume a
module before I combine so the answer is
in the correct model
you're supposed to compile the
multi-surface first okay there is this
notion of that when you have wanting to
deform a dag directly speak right so at
each of this level you cannot have a
sizable but the implementation level
know in prodigy
implementation vinick's
can have cycles but you still have to
compile the module interface first then
what about cycles between modules so we
don't have cycles at the interface level
but you have you can't have cycle type
implementation level
now the in general I what way you will
have these architectures were you you
feel the need to have two module
interpreters back reference each other I
feel like there is probably a design
error that you have tried too hard to
have to find drain modules that's my
general position but I also know that if
you take is on a library for example the
reason one we have is forward and I will
stream is that you have this dependency
between our streams and strings right so
you need to have this forward apportion
but again I will argue that that makes
my point that we probably decompose
header files in to find gray if we had
become that did impose these cost of
copying everything it is not clear to me
that we will have this composition of is
forward I've streams and string we just
have one thing really
one cannot function without the earth so
really now beyond incident one sister
but I also know that there is needs when
you bringing existing system because
today you have 40 version of 1 plus here
and then you find there and then you
have lots of sigh closely I also know
that there is need to find something to
handle that so you'll be able to say
that hey I'm going to use this
functional class it doesn't belong to
this module it belongs to read separate
module you
mechanism to say that but you won't have
second appearances okay okay one more
question I'm sorry
whooping I consider that a good
suggestion and I'll put you on the list
of things that we</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>