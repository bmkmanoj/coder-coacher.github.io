<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Alfred Bratterud “#include ＜os＞: from bootloader to REST API with the new C++&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Alfred Bratterud “#include ＜os＞: from bootloader to REST API with the new C++&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Alfred Bratterud “#include ＜os＞: from bootloader to REST API with the new C++&quot;</b></h2><h5 class="post__date">2016-09-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/t4etEwG2_LY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody I'll let you guys settle
down my name is Alfred I started this
project include OS really glad to be
here
it's a fun project I want to show you
but keep in mind you guys are probably
the language experts I'm just making an
our operating system so this first line
it pretty much sums up what we're trying
to do we're trying to make this
statement a reality include OS so this
is the first line you'll write in an
include OS program so what we want to do
is to put some operating system inside
your elf binary and of course the
important word here is some I don't
think you want all of Microsoft Windows
into your elf binary that would be crazy
so what we're making is called a unit
kernel so let me just give you a few
points about what unit kernels are the
term was coined in 2013 by Neil Madhava
pedy Richard Moore dear and others from
Cambridge so they're making something
similar to what we're doing but they're
doing it in Oh camel so the most
important property probably is that it's
single purpose we're making something
you can use for a lot of purposes but
only one purpose at a time and in order
to achieve that we make it into a
library operating system so what we're
doing is a library and your program will
pull in whatever it needs from the
operating system from this library so
essentially this turns your binary into
a bootable disk image obviously that
means you can't run you can expect
include OS to be your next operating
system for your laptop I mean your
laptop needs something general purpose
but for virtual machines especially in
the cloud or for IOT a lot of the times
servers are single purpose anyway you
set up a web server it's usually
a full-blown operating system in their
general purpose but it only does this
one thing so include us it's a minimal
resource efficient implementation from
scratch it's a unicorn and is written
from scratch in modern C++ this
reference is from a paper that's when we
released include West for the first time
I was in December last year and you see
some interesting results there but a lot
has happened since then so some
interesting facts look at the graph
there the blue dots at the bottom that's
included with so it's about 300 times
smaller than our Ubuntu disk image if
you build a hello world program and
include just enough operating system to
boot that hello world program with
include OS turns into about 1 megabyte
of disk and for memory I mean we could
get we could probably manage with about
1 megabyte but we're running on x86 so
the first megabyte is reserved for etc
etc so about 3 megabytes so this is a
lot of savings in memory and disk size
so it's single threaded by default
doesn't mean will be like that forever
but there's a good reason for that I'll
come back to that later it's also faster
and it's more efficient for single core
VMs so these are some results from the
paper a little bit of improvement in
speed and resource efficiency very
importantly is boot times so for virtual
machines in the cloud it's really nice
to scale fast if you have a lot of
traffic to your website you know you
need to spawn new virtual machines to
handle the requests that's one of the
interesting properties of cloud is the
elasticity so good time is important 300
milliseconds of boot time is pretty fast
so when you start an include OS program
or you boot up a virtual machine it's
like this
and if it feels like starting a program
on the terminal so we're not trying to
Pete with Ubuntu it's a fantastic
operating system we use it all the time
but it's a general purpose operating
system and include OS is designed for
special purpose appliances that you want
to wrap into a very safe environment so
you all know what virtual machines are
right everybody you know what it is and
you can tell me at the instruction level
exactly what it is well I'll go through
it so there are many this is a very
heavily overloaded term right so I like
to go back to this definition that was
provided in a grey paper in 1974 it's by
pop akin Goldberg
so they say that our virtual machine is
an efficient isolated duplicate of the
real machine so it's supposed to feel
exactly like it feels to boot on
hardware to boot inside that virtual
machine so this is a statement it
doesn't it's not really precise but in
the paper they give a mathematical model
of exactly what it means to be a virtual
machine essentially boils down to this
all sensitive instructions have to trap
so the hypervisor on the side there
that's the whole host operating system
it can be Windows the can be Linux it
can be Mac OS it's the the operating
system you installed onto the physical
machine so very important to notice is
that according to the public goldberg
requirements for virtualization there
isn't any software layer between these
VMs and the hardware they run directly
on hardware instructions are executed
directly without some layer in between
so we start out we boot the physical
machine and we're in the hypervisor we
start a virtual machine in our some
instructions in there these instructions
are not dangerous it's just addition
multiplication moving stuff around
they're not sensitive so they don't trap
they execute directly on hardware and is
fast there's no overhead no layer in
between there's no emulation if it was
emulation it wouldn't be a
machine according to the definitions by
Papa Goldberg now we come to the m2 well
here's something sensitive at the end
here I'm saying out and out means send
some byte over the bus to some device on
the hardware so this has to trap so what
happens then we we switch to the
hypervisor the hypervisor gets notified
of what you want it to do and it can
either emulate a physical device or it
could pass your instruction on to a
physical device we don't really know and
we don't have to know so but obviously
you need the trap you can't just ignore
these sensitive instructions like like
what's the case on very early Intel
processors you need to trap and once you
do you can provide virtualization same
goes with virtual memory it's it's the
same principle of virtual memory that
you used to for user space but in this
case you also have to trap and we use
this mechanism in order to for example
talk to memory map devices so this was a
great paper all I always said now was
from this paper and it takes 30 years
until Intel says oh that's a good idea
let's implement that so finally in
2005/2006 hardware virtualization was
popularized into Intel CPUs and now all
your laptops have it so the point is you
can run direct on hardware there's no
software layer in between the VM trap is
pretty much a glorified context switch
so since we're also 100% self-contained
we run directly on hardware we don't
share any code with a hypervisor we
don't share any executable code with
other virtual machines that means when
you build as an elf binary with include
OS you can run the same binary on
Windows Linux or Mac so that's also
pretty cool it's like a java runtime
environment for c++
hardware support I also want to stress
that we look at these virtual machines
like processes I mean they're not they
don't have to be huge machines that you
log into the terminal it's just a
process and the virtualization layer
around it it's it's just a glorified
complex traditions essentially yeah so
since it's running directly on Hardware
you know you have to have an operating
system in order to do something
interesting you could do a computation
of digits of pi or something but when
you want I oh you're going to have some
operating system in there so this is the
build system this is essentially what an
include West virtual machine is and how
it gets built so there's the OS a that's
the library where we put all the parts
of the operating system that you can
pick and choose from and you pick and
choose just by mentioning this in code
if you want to use TCP you mentioned TCP
and the static linker will pull TCP into
your code drivers we've separated I'll
mention those later so what's
interesting now is that we can increase
we can keep adding functionality just
like the standards commit Standards
Committee does to C++ right you can just
throw more features in there we can do
that without having the size of the
virtual machines to grow because it just
blows the library and your service still
just pulls up what it needs
the last part here it's actually
optional you can boot without this but
this this makes it the most
self-contained if you add a bootloader
so we have a tiny little program that
just adds the 512 byte bootloader to the
front of your elf binary and that makes
its bootable so why C++ it's completely
obvious to me and probably to all of you
guys but since some people are asking
let me just mention
some things C++ I mean you can say so
many things about it but for me it's
obvious that it's the most evolved
independent system language and by
independent systems language I mean
something that can write arbitrated data
to arbitrary addresses and that's
something you have to be able to do to
write an operating system you also need
access to the full instruction set I
mean you have to tell the CPU how to
handle interrupts you have to talk
directly to devices you have to have
access to the whole instruction set in
order to be an efficient operating
system so in my mind I can't see how you
can have a completely type safe language
and do all this it's a contrast right so
the Mirage guys the the ones that are
writing operating systems in all camel
they will have a C layer you'll see a
lot of high-level unit kernel projects
and they will have a C layer what I
think is great about C++ is that we can
do everything we can do the high-level
abstractions we can also do all the
low-level so this is hello world
it looks probably unfamiliar because how
about main so the reason why we didn't
use main for this starting function of a
program we could have but we didn't
because the signature doesn't really
live up to the expectation the signature
of main returns an int right so in the
unit kernel where's that's supposed to
go so there's no parent process it's
only your process right so where should
it go
should it go back to the hypervisor well
it could but then if you're running in
the cloud where does that go right it
just goes down to some server that's
running in a data center somewhere so
it's not obvious
so for us we thought well let's just
make a new signature we might do main as
well but when we do I think it's most
appropriate to actual
we do what you expect with mains so
another interesting question is where
does standardout go so let's just
address that right away so by default
since there is no parent process we
can't just return standard out data to
the shell right there is no shell it's
just the process
I mean it's running in an hour other
operating system but not in the context
of a shell so by default we route this
to the serial port and that means when
you're running include OS from a
terminal it behaves like a normal
process because usually at least on
linux with key mu which is the
virtualization program you use in linux
then you can get the serial port output
just redirected out to your terminal so
when I write programs it feels I start a
program and the output whatever I do in
printf for C out it just comes out in
the journal like you expect but you know
that's not something you always want so
we're using delegates everywhere so
these delegates I mean as you probably
all know they much more about this than
I do but essentially a delegate it's a
pointer to a member function so the
delegates we're using are compatible
with standard function so when you have
an interface that takes a delegate as a
parameter you can give it a pointer to a
member function or you can give it a
free-standing function or a lambda or
any other standard function so I think
we owe this user something because we
found this code just posted on Stack
Exchange so if anybody knows this user
or if you're you seeing this please let
us buy you a beverage of your choice I
mean the code is really cool it really
works it's compatible with everything
and it's written in modern C++ 11 it
makes my head explode a little when I
try to read all of it
but it works so now we can route
standard out to anywhere so in the first
case here we're routing it to VGA you
know that's also a strange concept with
with virtual machines what's with VGA
right
I mean you boot up a virtual machine
whenever you write to video map memory
it causes a trap so then it's up to the
hypervisor to say okay you want to write
to this memory mapped video device what
do I do with it right so usually what
happens if you write if you're on the
desktop and you start a virtual machine
you get a little window and this window
represent the VGA output from that
virtual machine but there's nothing to
say that you have to have that and in a
server in a data center obviously that's
just useless you don't need that VGA
output so you can write it there because
it's nice we have a snake game you can
play using this kind of graphics but
it's not really you it's not really
necessary but it can be nice so in this
second case we add a custom Handler
again this just takes a delegate as a
parameter in this case we're using a
lambda and we're writing standard out
two in this case it's from the web
server we'll show you later and it's
writing it to a ring buffer in memory
that can be harvested later so what's
different about an operating system for
virtual machines in principle like I've
said it's almost nothing but I'll just
give you a brief idea of the hardware we
have to deal with so this is not
complete but this is like this is some
things we have to deal with a lot and
that's mostly exactly like an operating
system for physical machines because I
only interface with these devices
through physical through the CPU
directly through the CPU there's no
shared code right so inside the CPU we
have timers we have interrupt
controllers we have registers we need to
deal with we have access to all of
memory which is nice and then we have
serial ports and the PCI bus and on the
PCI bus that's where I find most my
devices i probe the pci bus just like
you would in an
normal operating system and what I find
there is something that usually our
virtual devices that's the most
efficient when you're running a virtual
machine we have custom memory mapped
ways to transfer data in and out but the
point is that we use a hardware
interface to establish this kind of
exchange so the interface that I use to
talk to these devices it's a physical
interface are in the sense that there
are instructions to the CPU and then we
negotiate direct memory access so that
the device can deposit packages directly
into my memory without me having to do
port I all the time so the point is the
virtual devices but they could have as
well have been physical devices
I don't really know so talking about
devices is kind of interesting to see
how we include only the drivers you need
so I talked about static linking that's
the way we get most the stuff in and we
in the beginning we use that also for
drivers but you know you kind of want to
be able to replace a device driver
without having to reroute the
application code right so I thought it
was kind of interesting we use global
constructors now for that so the
ordering of global constructor is
undefined so you don't really know
what's going on when but of course we
know exactly when to start calling
global constructors and we know whether
when they're done so what we're doing is
that we are we can now link in a driver
and if it has a global constructor this
can register with the PCI manager and
give it a delegate so it just gives the
PCI manager a delegate that's a pointer
to a function or a member function in
this case it's the initialization
function for the network driver so I'm
telling the PCI bus that here's the
driver so whenever you encounter a
device that has
this vendor ID or this device ID you can
initialize me so that's slightly
different than from the static linking
approach but it makes it possible for
you to specify from right outside now I
want to run on that kind of driver now I
want to run on that kind of driver and
the IP interface or the network
interface is abstracted from the drivers
so now the deployment tools and SUSE
admins can apply appropriate drivers and
you can relink without having to rewrite
so let's look at the core of the kernel
like I said it's single threaded by
default so it's completely event based
so this is the event loop essentially
what's going on I mean I do a lot of
initialization initialize stack heap BSS
etc called global constructors
initialize hardware and then I call the
service start which could have been
called main if the signature wouldn't
have been lying and then I go into this
event loop where what we're all I'm
doing is to ask the irq manager which
interrupts have happened which of them
were subscribed to and if they both
happen then we're subscribed to then
call the delegate that they registered
so obviously this would be spending a
hundred percent CPU if there wasn't
something more going on so there is so
after the I or queue manager has called
all the delegates that were waiting to
be called the halt instruction will be
called so essentially yeah and the halt
instruction it just means put the CPU to
sleep until there's a new interrupt
that's what it means so what's nice
about that is that there is no
preemption here it means when this unit
kernel is sleeping and not doing
anything it will use exactly zero
percent CPU it will be just scheduled
out and will use absolutely no resources
so you can have a lot of these in memory
they are sleeping and they are not
spending any resources so notice that
when you subscribe to interrupts that
get handled in this manner without
preemption there will be then you don't
have a guarantee
of exactly how long it took from when
the interval was called until your
delegate was called because that might
depend on other interrupts having been
handled before you so you can also do it
the hard way and make pre-emptive
interrupts we do that for a stack
sampler I'll show you later but you know
this takes you a long way
it actually takes you all the way up to
making an internet-enabled application
that can serve a lot of requests on
different ports and on different
protocols at the same time so this is
how you subscribe to interrupts I told
you these delegates were nice they're
not pretty to declare but they they work
very well so I declare a delegate I'm
giving I'm saying this is a signature
that returns void takes no parameters
I'm telling telling it which class this
delegate points to and then I tell it
which function with which member
function of that class we point to and
then I give it an instance so having
made the delegate now I can just
subscribe to an interrupt number and I
pass along this delegate so what happens
here is that whenever this interrupts n
happens of course I didn't hard-code
this in include OS but I did it for the
example but now whenever interrupts n
happens this delegate gets called and
then the network driver is notified that
okay I have new packets probably in
memory so you don't have to worry about
subscribing to interrupts I'm just
showing you how this is done we provide
a lot of objections on top of this so we
also made our own IP stack and I thought
that was crazy when we started I thought
I would never do that I thought it just
poured something from somewhere else but
then you know I couldn't help myself so
I started with Ethernet then that wasn't
that complicated
because it really isn't it's a small
header and it's just just essentially
you have to switch on packet type okay
so we started and then I got to our bin
IP 4 and UDP and it all went kind of
nicely so
we thought what the hell so what you see
in the picture all of these boxes are
classes class instances and they're also
representing one protocol all the
connections between them are delegates
so that means the ethernet object it
just knows okay I have a packet and now
I'm passing this along through this
delegate all I need to know is that the
delegate is a function that has a
signature that allows me to pass a
packet through it I really don't know
how I don't have to know anything else
about that class so Ethernet doesn't
know about IP it just knows that I have
a handler for that kind of data and this
handler can I can send the packet to
there so we use the delegates both up
and down so all of this wiring it's
pretty simple it's like two lines of
codes for each wire so yes it's a lot of
wires but it's quite simple and this
also makes it possible to write custom
versions of this IP stack I mean I'm
concerned with minimality so if you just
want a network stack that only talks UDP
you know I want you to be able to do
that so you can reuse these same
components take out the parts you don't
want and make another wrapper class that
has kind of a minimal custom-tailored IP
stack for your purpose you can also
rewire during run time it's only a
matter of shifting these delegates so
here's an example where I insert an IP
filter so if you can see here there okay
animation wasn't so good but an IP
filter was just put in between ah the
ethernet object and the IP for object
just by rewiring the delegates and you
can see on our website you can see an
example of how to do that in code in a
few lines so like I said I'm concerned
with the minimality so I want the
defaults to be minimal
so we're single threaded by default
this is due to actually our
interpretation of the null operator
principle because in virtual machines
threading is more expensive it's quite
another involved topic I'm not an expert
on this but you can quite easily imagine
that when you have scheduling and thread
synchronization already going on on the
hypervisor and then you have another
layer of scheduling and threads and
synchronization inside the virtual
machine then these can interfere with
each other so this is one reference
there are several references to research
showing that threaded applications
inside of virtual machines are
significantly significantly slower
compared to bare metal than single
threaded applications now I'm not
against threading at all I just want you
to notice that when you boot up a
virtual machine and you say that this
virtual machine should have five CPUs
then you already get five threads
because that's how you make a virtual
CPU is by making one fed on the host so
we're kind of looking to make interfaces
where we can utilize that so that the
physical machine only has to deal with
one set of threads one level or layer of
threads and not two so in order to do
single threaded very efficiently and
cheaply
everything is isync so that means
currently there are no blocking POSIX
calls but we know people like to say F
read and they expect to not have to move
out of the queue and just stand there
and say I'll set every you'd and I'm
standing right here until I get my data
right it's your constitutional right I
realize that so of course we will take
care of your stack and we will set it
aside and we'll create a new stack and
and we'll fix that for you but we just
want to show the full potential of the
single threaded version of this first so
this is how we write a tcp server the
POSIX interface for networking is are
more involved than this so I think it's
quite intuitive I'm starting my service
I'm saying that I want a server and I
want to and
in turn I pee for Internet stack so I'm
asking for the stack and from the stack
I'm asking for the TCP object and on the
TCP object I'm saying that I want to
bind to port 80 so I get a server object
that's bound to port 80 so now I can
attach delegates to events on this
connect on this server so I say
unconnect and I provide a delegate
doesn't have to be a lambda it can be
and it usually probably maybe it
shouldn't be but you know it could be
probably a server object that you write
and you point this on connect function
to there so now you say on read and you
say how much you want to read and now we
get two buffers it's kind of complicated
this is a shared pointer to a buffer it
has to be it has to do with a
synchronicity why we had to do it like
that I know you don't like the buffer
and size interfaces and we're really
trying to outlaw them throughout so this
is kind of a special case it's a it's
the buffer is lives in in shared memory
so anyway every time you connect to this
server now over telnet you'll get this
response
it's a TCP server it works another
security so how do you break into this I
mean I have no idea
right so that makes it secure no of
course it doesn't but think about this I
mean if you do get in you're in a
hardware protected sandbox so at least
let's talk about that I mean if you were
able to break in the hardware is
protecting the physical server
underneath you
that's why virtualization was invented
in the first place it was to isolate
services from each other and it's been
working well at that since the 60s so if
you're worried about damage or infection
to the rest of the system that's
contained by hardware which is the main
reason for wanting to do this at all
there's also no shell no other ad hoc
system access you can't get root X
get to a terminal because there is no
one no terminal in there right it has
minimal attack surface because it's
really really tiny all little parts your
serve is explicitly needed or that was
injected as a driver only those parts
are in there there's nothing else so
there are no tools left for the thieves
everything inside can be randomized
we're already randomizing stack and heap
locations you can do a lot more with
that so that once you get to know how
one unit kernel works that doesn't
necessarily translate to how the next
unit works so somebody said leave no
room for a level low level language
below C++ except for assembler and you
made it we didn't need any other
language except for assembler and we try
to use it as little little as possible
but do we need another language above
C++
I find that C++ the new C++ is really
really good at high level as well so
we're going to show you what we built on
top of include lists so we're now
introducing acorn we're open sourcing
this this week for this occasion it's a
web server that we built on top of
include OS but it also has a C++
framework for building restful api in a
very modern way it's inspired by nodejs
and Express so these JavaScript
developers that are now running
server-side code they invented some
pretty nice techniques it's all async
and single threaded so it kind of
resembles our scenarios so we thought
let's try to do that in C++ so if you
download ACORN it's a include web
service it requires you to have
installed including Wes library but
there you get a couple of fancy or a
couple of simple web pages let's say so
the first one here
you know we serve static content from a
fat filesystem that's the basic case it
can be served from a memory disk or that
lives inside the elf binary or
it can be served from an external block
device there's also a demo of something
more interactive where you can post
stuff so this is a Ajax application
using kind of a modern front-end and
then there's a little repository of
repository of books so this just shows
you also that you know we have an
abstraction that allows you to just list
the directory contents and show that as
HTML so that's great it's a web server
and then somebody said this morning C++
is not the language for putting up a
simple web page okay message received so
how about a fancy web page and we have
that how about a dashboard with live CPU
stats and live profiling of the code
that's running the web page does that
qualify it's surprisingly easy with C++
so here's the dashboard now the reason
why I'm showing you this it's not
because I think all units should have
this dashboard but it's a really cool
useful tool so what you see here that's
a live interactive CPU graph it will
update nicely and if you put some load
on there you'll see the load so this
particular picture is taken from ten
thousand HTTP requests you know it
doesn't break a sweat it's it's fine
this is a memory map it looks all red
that's because all of memory or almost
all of memory goes to your application
and not to the operating system so this
is also an interactive memory map
because somebody at cpp cast asked me if
we had a memory map and I thought oh my
goodness
we should probably have one so this is a
STL data structure that map's all of
memory so you can ask the operating
system what does the memory map look
like and then it's easy to then
serialize that and now it's also easy to
provide a restful api endpoint for that
data
this is tcp status connection shows you
who's trying
to break into your server if they get in
you know think of the damage they can do
with no shell well so this is another
thing look at the rights the left side
of the screen here you have stats so
these are centrally located statistics
that anyone can or that your service or
the operating system any lambda anything
can can say I want to haven't use that
and you give it a name and in return you
get a reference to a counter that you
can decrement or increment and since
these are centrally located you can also
easily serialize all of them so if your
application now says okay I injected
this little IP filter as a lambda or as
a delegate that goes between the
ethernet and arp four layer you know
that can have its own stats as well
telling you how many packets it dropped
of course maybe the most interesting
thing is live stack sampling that's
something you get from running in a
single threaded environment with only
one stack so what we're doing here is
that we have an interrupt timer we have
a timer interrupt going every
millisecond and the timer interrupt is
just a function called figured by the
cpu so it will go on the top of the same
stack that's already there so all you
have to do is just look down at the
bottom of the stack and see what was the
previous function so we record that
thousand times per second it's not
expensive or at least it doesn't show up
in the in the stack sampling and we
record that data so all we do is we
record the function address in a data
structure and then afterwards when you
want to extract that data to to look at
it in a datastore data structure to
serialize it then you find the name of
the function so this is live its heat
mapped in a way so that if you do run a
lot of load on here you will see which
function is the bad guy that's found the
most times we also do the same with logs
this is where we routed the standard
output from the from the hello world
example or right after that I show you
we could route it anywhere now we're at
into a in memory
in buffer and then we have a timer again
that just harvests this data and puts it
on a restful endpoint so yeah this just
shows you that you can also access the
data directly and obviously the
dashboard is just a way to demonstrate
how you can expose parts of this
machinery easily over the web and we
composed all of this into a dashboard
but of course they are all individual
routes the operating system doesn't
expose anything this is just something
the application is doing but we have to
show you how we did it we have some nice
abstractions that we took from
JavaScript and nodejs so this is how you
make one of these routes so our route
that's essentially a way to tie in some
functionality to a certain type of URL
or actually to a certain path in the URL
let's so let's just view URLs as an
abstract tree structure and then you can
tie functionality into certain parts of
that tree structure so in this case yeah
so this is kind of a reg expanding based
mini language that's very popular for
web applications to express routes so
it's essentially this language gets
parsed by standard reg X and it produces
a new reg X that you actually use to
match the incoming requests but the
convenience of this is that now I'm
again I can say I want serve this I want
to run this functionality whenever
somebody goes to API slash users slash
colon ID and you can actually get this
ID part of the URL by value and by name
so so now we so what's happened is that
behind the scenes this router it's
parsed the URL and it found out that
okay it matches one of the it matches
this pattern so let's extract the idea
from there and provide it to you by
value through the request object this is
a default route so we use the same kind
of principle but in this case we say
okay for just slash it means you go to
just
mydomain.com / nothing you know so if
that's what you're going for then in
this case we will just look at the file
system and we will try to find which we
will actually just serve index.html from
the slash public / index.html on the
file system the next thing is middleware
so middleware is a way to pre-process or
to kind of get to pre-process the
requests when they're coming in so it's
essentially a stack of functions or just
a list of functions that the request has
to pass through in order to reach up to
the routes so one typical example of
middleware is JSON parsing so say you're
having a ajax web application the user
will typically give you data in form in
the form of JSON now when you want to
work on this data you just want it to be
parsed for you you don't want to have to
deal with that so usually you just apply
middleware so that you know whenever the
request is coming in the JSON is already
parsed so this just checks if the
content type of the request on HTTP
level if it's Jason well then you know
we parse the data and we attach the
parse JSON data to the request so that
when it comes up to the very lazy
application programmer writing the route
the JSON is already parsed yeah exactly
what I said and this last part this is a
async pattern that we have to use so I'm
calling next here you see that gets
passed in and this is because of the
async nature of these of our system
everything is I sync so you know if you
inside of this middleware you want to go
asynchronously to the file system and
fetch something then you have to wait
and then you want to call next to call
the next middleware in the stack you
know for that reason these this
middleware has to live in resident
memory so you get past the
in this is some let's just say it's some
basic magic going on you don't have to
worry about it unless you're
implementing your own middleware but we
have some ready-made middleware there
was a JSON parser we have we also have
the thing that makes the directory
listing of the contents of your
filesystem which is pretty cool so you
can replace the contents with your own
favorite content and you can use that as
a way to list the directory contents and
so when you apply middleware you just
say where you want to use it and then
you give it the middleware there's a
cookie parser parsing on all the cookies
that might come on request so that you
can have a web application using cookies
etc and I know you will worry about
performance so let me just remind you
that virtual machines aren't faster than
bare metal they're ideally or optimally
they're the same right so if you just
run decimal compute as moles of Pi you
can probably get almost identical
performance but for i/o you know there's
it's a little bit more wayward so our
motivation for this is to make an
architecture where it's easy to write
thousands of microservices and that you
if you want concurrency at a large level
you can scale up with thousands of these
little virtual machines now that being
said of course I'm happy to say that we
do beat a party as a web server on this
little acorn that we're introducing so
we did some benchmarking where we put a
party web server inside of Ubuntu turns
out we are 11% faster and that's for a
proof-of-concept application our HTTP
parser is using a lot of string copying
it's pretty straightforward C++ with no
optimization can be optimized a lot so
there's a lot of more stuff we can do
but we're already faster which is just
due to the simplistic design I think and
it's also 79 percent faster than node
you might say well obviously you'd be no
because that's written in JavaScript
well most of it is
e or C++ javascript is used if I mean if
your application code is very heavy then
yes there will be a lot of JavaScript
running but for just serving a static
file mostly it's C so the HTTP parts are
in no that's pure C and it's very ugly C
so we actually ported that one into
include OS but then we saw a boost up
down one so you know we probably want to
do that instead so I'm happy with the
results so far it's faster to run
include your application on include OS
than it is to run it on Ubuntu to deploy
in the cloud I don't know if that's
scenario you are that's very useful to
you but it's incredibly useful for us
and that's kind of the audience we're
targeting primarily and secondarily IOT
so I just want to show you that these
include OS instances can easily be
uploaded and booted on OpenStack which
is the most deployed cloud architecture
it's the the most common way for
business to get like their own private
cloud so what you do is say that you
want to create the image so you upload
this image that just the single make
command from include OS produced and
then you say boot the image and what
happens is that you get an IP in return
because include OS will get an IP from
DHCP and you know it will just serve web
content from there we'll be adding
support for all the big cloud vendors
gradually OpenStack is just the easiest
one to work with because it's open so
but eventually will run on all of them I
think it's not going to be that long so
the status is we want to reach 1.0 but
you know that communicates that we have
a stable API now I showed you a lot of
things I showed you include our score
and then I showed you this web
application framework very briefly on
top of that so I think
we want to I think where we can have a
production ready include away score by
the end of the year but then whether or
not this the API is stable and you know
decided that really depends on what kind
of feedback we're getting so if you're
at all interested in this please let us
know how things should have been done
how we did everything wrong how we
didn't do sufficiently beautiful c++
here and there you guys are the c++
experts so we really want to invite you
to come and just voice your opinions we
can improve if you help us so acorn is
open source and alpha today or tomorrow
what we're missing is TLS I mean
transport layer security for encrypted
HTTP connections we're going to add
POSIX and multi architecture support and
then we need more tooling but we have
there's a project by EMC that was
recently acquired by Dell that actually
you know it makes it pretty easy to
deploy lots of different unique animal
projects on lots of different platforms
so we integrated with them and this is
going to be a tool you can use to deploy
unicorns everywhere we need package
manager ce mec builds etc so this is
what you can expect in the near future
so to recap virtual machines are not
heavy operating systems are and include
OS is faster and more efficient and more
secure for single purpose applications
C++ has turned out to be fantastic for
both the low level and the high level
stuff we've been doing please contribute
follow us on Twitter we'll notify you of
what's happening there there will be a
demo and in an open content session that
shows you an IRC server running on
include OS it will show you some code
and will show you something live so get
to that if you're interested on Thursday
but really give me expert advice you
guys our language experts I'm not so
please tell me what we could improve and
we will be much we'll be very happy for
that also focus on github chat with us
on jitter thanks any questions yeah ah
that was yeah that was super hard yeah
oh yeah sorry he asked how did we make
the standard library available inside
the UD kernel so well it's kind of
involved you have to build well I
started out having to build a custom GCC
compiler like a custom designated tool
chain just for building for this
particular platform and then I was able
to get the C library which we're using a
new Lib in there and the C library new
Libet just has a few system calls so
it's that it's an implementation that's
meant to make it easy for you to you
know provide the system calls underneath
so that was that was not so hard I mean
making the cross compiler thing it's a
lot of work but you know you have pretty
decent guides on on sites like always
they have dual org now to get the c++
library was much harder so we ended up
dropping the GCC one because it was so
hard to just get that library out of the
whole rest of the things so we ended up
doing the Lib C++ from LVM turn out when
we went there it was much easier to just
get a clean compilation for just 32-bit
architecture which is what we're
currently using so yeah so essentially
when we switch to LLVM it was not that
hard but still we do provide ready-mades
for this because takes a long time to
build all these things so we provide
binaries
the C library C++ library and then you
use those to build the include OS
libraries on top of that yeah yeah ah
interesting so the question was Internet
of Things can I see this going to
microcontrollers well I can certainly
see going to arm and raspberry PI's so
and I mean yes Internet of Things
usually you'll have a small device with
a single purpose
so in principle that fits now
microcurrent microcontroller is very
very memory constrained and while we try
to be very minimal when I started the
project we looked at a lot of for
example we looked at IP stacks from
these minimal IOT operating systems and
it turned out that they were usually
designed when you design for that much
that little memory I turned out to be
that they have to sacrifice performance
so I'm guessing that you know if you
have a reasonable amount of working
memory you know then you could port
include OS over there yeah how do we do
bug
ah excellent question how do we debug
it's we use gdb just like you would do
bug a normal process so that's so
debugging um so the gdb can and you can
probably use other debuggers as well I
just haven't needed it
so you just chemo which is the process
that controls the i/o for the virtual
machine and so essentially when you
build a virtual machine what you'll see
in your list of processes that's a key
mu process and it's it's communicating
through a kernel module with with the
guest so it can expose a port so that
it's it acts as a debugging server so
that gdb connects to that server it will
get I guess what it needs is like the
instruction pointer the location of
memory etc and then you can just provide
the binary because there's an elf binary
right so you provide a binary with or
just the
the symbol tables on the other side and
put student two together so you can get
step wise you know walk you through
exactly the code while is running in the
inside the virtual machine so yeah so if
the user code does not yield what do I
do well there is no I mean everything is
I sync so currently all you do I mean if
you if you just run a for loop or you
run a computation of Pi forever well
then that's what the thread is doing so
yes then everything will be unless you
implement preemptive interrupt handlers
like a stack sampler we have that's a
pre-emptive interrupt Handler so that
will do a proper interrupt and it will
actually do work so I can't but but you
know then you have to take care of
saving your context and then you can
switch back so yes so currently we want
to just show you how much you can do I
mean you can have several protocols
listening on several different different
ports and the thing is that network
traffic is kind of naturally scheduled
because everything is already chunked up
into packets right so we I felt you know
I was surprised at how much you could do
with this model but yes we will add the
normal context switching threading so
that we're POSIX compliant and you can
run whatever and also do blocking calls
etc yeah other questions yes all right
so uh and what was the advantages of
putting all the device drivers and stuff
like that into the virtual machines as
opposed to paravirtualization so if I
understand the question correctly yeah
so paravirtualization that's kind of
well not to be rude but it's a band-aid
for for creating virtual machines before
the C
use actually had the ability to do this
virtualization themselves I mean so well
so Xen hypervisor is very popular and
very good they have this pair of virtual
mode where essentially your code is just
user space code so in order to run
Windows or Linux on top of there which
is what they wanted for example when
Amazon started out they were very early
promoters of this virtualization
technique so then you have to modify the
guest so you modify the guest so that
the operating system isn't actually
dealing with hardware it's dealing with
a thin software layer so for me that's
just the security vulnerability that
just isn't necessary so to be honest I
just thought you know that I was looking
for the perfect way to isolate services
from one another because cloud is kind
of our context so I want your server
service to run on my hardware as well as
your service so so I just thought well
the most secure in my mind is the
isolation mechanism that doesn't share a
single byte of code so that's I guess
that's the advantage of doing it like
that and yes as a as a result you have
to have like PCI interface etc now I
think later in the week on Thursday
we'll hear about a new hypervisor
project where you know you can probably
find interfaces where you can throw away
the PCI and all that and make simpler
interfaces between guest and host
without having to go through all these
legacy interfaces but still keeping
hardware virtualization so what did it
answer your question ok thanks anything
else ok yeah sure doing without the host
so so you mean running ah this directly
in userspace Oh a bare-metal well I
haven't but I did oh sorry
have I tried to run include OS directly
on physical hardware is that where
you're asking right
yeah no I haven't tried to run include
us directly on physical hardware but I
had some experiment projects that I did
before that which kind of was precursor
to include us that booted up on hardware
and everything behaved exactly like it
would in chemo so you know it will boot
on hardware pretty confident or I am
confident because the point is that you
are running directly on Hardware you
know you're just running in a
virtualized context so we probably might
have to do some adjustments to I mean we
definitely need to add physical device
drivers in order to get internet
connectivity etc but booting I'm pretty
confident we'll just start up and then
you have to attach a serial plug to get
the output data etc out but yeah so it's
a goal of ours
any other questions okay then I guess
thanks a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>