<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015:Marshall Clow “Type Traits - what are they and why should I use them?&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015:Marshall Clow “Type Traits - what are they and why should I use them?&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015:Marshall Clow “Type Traits - what are they and why should I use them?&quot;</b></h2><h5 class="post__date">2015-10-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VvbTP_k_Df4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yeah and here they talk about type
traits now there's been a lot of talk at
that at here at the conference about
template metaprogramming and Sanae and
throwing a bunch of things around and
this is meant to be a gentle
introduction to those kind of things if
you're the kind of person who spends all
your days writing templated code or
maintaining a standard library this is
probably going to be a little slow for
you but if you're wondering what what
all these things are and why do you care
and so on then that's what I'm here to
tell you about okay they said I work at
Qualcomm I have an occasional blog that
I post on it whenever something you know
inspiration strikes I seem to be
averaging about one or two posts a year
so if you're interested there you go so
let's start off right away so what are
type traits there's a whole bunch of
words typed rates are compiled time
template meta functions that return
informations about types that doesn't
really help so so what why do I care one
of the what do they do why do I care and
the answer is maybe you don't if you are
writing code that is so we say about
concrete types but your concrete code
you're not writing templates you're not
writing algorithms that work on generic
different types of different type data
types if you're not working on things
that you're not writing a container that
can hold any kind of type you probably
don't care about trait type traits and
that's fine but on the other hand if
you're writing code that is designed to
work on different kinds of types at
different times sometimes you need to
know about that how many people here
have seen some of Shawn parents talks
besides the one he did this morning
there we go one of the things that he
likes to talk about is he has given
talks about algorithms writing
algorithms and basically one of his
goals
no naked loops he said basically you any
time you write a loop in your code you
should think about this and this says is
this something that I'm gonna do more
than once or more than twice and if so
you should factor it out into an
algorithm which is usually a templated
function and give it a name because well
things are much easier to reason about
when you can look at it and say oh yeah
I know what that's doing that's doing a
rotate rather than looking at a loop
that's shuffling things around and
trying to figure out yes this kind of
looks like a rotate that maybe it's
something else maybe it's you know and
interleaving thingness or something like
that but if you see the word rotate
unless one of your co-workers being
really evil and trying to mess with your
head you say oh I know what that does
and you move on so that's one of the
cases where people are spending writing
a lot of generic code these days anyway
but the point is is that if you're
writing code that has to deal with
different kinds of types if you're
writing a template that might be
instantiating a different type sky
sometimes you need to know something
about a type and that's where type leaps
traits come in okay so quiz little quiz
how many different kind kinds of types
are there in C++ you know there's
there's effectively no end to the kinds
of the the number of types right and I'm
not even saying how many types are
defined in the standard there are
hundreds right but there are a taxonomy
of types in C++ and in particular there
are different classes of types for
example you excuse me if all you use or
class there's there are classes there
are references there are well there are
two kinds of references l value
references r-value references there are
pointers and so on anyway
so there's there's a is a recently small
and now and well-defined number of kinds
of types now some of these types
contains between all different kinds of
concrete types even if that sounds
really odd doesn't it concrete types
they there are some of these these
classes of types have a few members few
specific members and we'll see that and
some of them are open-ended like class
because you can define your own but in
case it turns out there are fourteen
just so you know and there they are
interestingly enough you can have fun in
trivia contest if you want and try to
name them void and no putter are in fact
the two that everybody has trouble with
no putter because it's probably the
newest one and void because that's the
class nobody thinks about are that the
type nobody thinks about right you can't
have any any variables of type void so
why would you think that you would have
a you know why would it be one of the
types but it is it's one of the the
fourteen kinds of types you could have
so no putter void I only have one one
element one member of those sets of
classes array and pointer and class are
open-ended and Union an enum and
function floating point has three
numbers yes question here class yes
struct struct in class are this the
question is what about structures
structures and classes in C++ are are
really the same the only difference is
what is the default access you know by
default everything instructors public
unless you say otherwise and by default
a class that everything is private
another question yes what's the
difference between array in pointer a
pointer points to a pointer doesn't
actually have any storage it points to
something allocated somewhere else and
an array is actually while it's an array
it's a storage you know it lays out
storage a contiguous collection of
elements and
in fact you know decay you know when you
pass an array by a value it decays to a
pointer or if you use the the type trait
decay you can tell how things decay you
know how things get converted but yeah a
pointer is is just a pointer there's no
there's no actual elements that are a
pointer can be null array can't be no
you can have an array of zero elements
but it's still an array any other
questions okay this is a really handy
slide that Howard Hinnant made up
several years ago and is kept up to date
and it talks about the different kinds
of types those 14 kinds of types and
some of the a few other things that you
can see in it we'll talk about it a long
way you see that for example this big
circle up at the top those are the
integral types and there's actually a
few more now since this has been made if
you google up this is available on
github on high in Howard's repo
github.com Howard Hinnant kind of look
around in there or just Google up you
know a net type chart it's actually
quite handy but if you look for example
look at you know fundamental types
arithmetic types integral types you see
there's a whole bunch there int long int
unsigned int and so on and now there's u
+ 8 t + + 8 t and so on
fundamental types Boyde know better
floating-point types you know and when
you think about types you know you
realize that it really aren't that many
kinds of types I mean obviously classes
there's an infinite number of those
anyway so how does this sum how does
this get back to type traits okay
basically what a type trait is is a
structure a template instructor that
when you specialize on a particular type
it has members and or nested type tests
that tell you information about the type
sometimes you know it's
sometimes the the result of a a type
trait is another type
sometimes it's about sometimes it's a
value and we talk about both of those
I'll give an example here
whoops area okay real simple type trait
is floating point basically is floating
point you you specialize it on a type
some type can be any type at all and it
has a and this expression instead
floating point of whatever type value is
true for the three floating point types
if we go back to Howard's chart here
you'll see up here under floating point
there are precisely three members there
there's float double and long double and
it's true for all of those and false
otherwise this is not working as well as
it could so
next one it the results of a titrate
does not have to be just an integer or a
boolean I should say just I don't have
to be able in here we have rank rank is
for working with arrays it will tell you
what the what the rank or the
dimensionality of an array type is so
for example if you if you say rank of
int colon colon value it gives you a
value 0 because it has no dimensions and
int has no dimensions it's just a single
variable int 5 for example is array of 5
hints about rank of that is 1 because
it's a one-dimensional array and so on
for 2 3 4 whatever okay the way this
works is that the whole value thing is
that these templates trucks have
constant non-member static basically
static member variables they have static
member variables associated with the
struct when they instantiate it and it
holds the value the nice thing about
them being constant is that you can deal
with them in C++ 11 later you can deal
with them at compile time and the
compiler can use these too it's to
control the instantiations but a lot of
a lot of the type traits we consider we
use a lot are on the ones that are the
ones that are just basically boolean
things is this is this a floating point
type or maybe does the particulars of a
type have a particular property is is
this type default constructible is this
tight assignable from this type and so
on but we can also do things like
generate new types one of the ones that
we use a lot in the standard library is
remove Const or actually a another one
of these which is remove CV which were
who is both constant and volatile and
this is what what it does is it takes a
type and it gives you another type
remove Const of constant colon colon
type is is defined to the int move
constant of int is also int because
there's no constant remove and so type
is in it is going to be a nested type
Def in the inside the struct so you know
if you look if you were to look at this
you can see you know struck remove
constant and this and basically in C++
14 and beyond they're short hands for
these you can say remove const
underscore t for constant which gets rid
of a which means you it's a shorthand
it's an alias for colon colon tight and
remove and you know rank colon
underscore v for for the value and this
saves a lot of typing if you get really
complicated in there because otherwise
you look at your stuff and it's late it
seems like every 20 characters you have
to type colon colon type or colon colon
value and it makes it hard to understand
what you're doing but it doesn't change
what you're doing is just a little
syntactic sugar okay there is no reason
that a type trait has to return just one
result structures can have any number of
non-static member variables they can
have any number of nested type deaths
there's no reason that you're limited to
one i'm bet there's I can think of one
off the top of my head that that returns
what five iterative traits how many
people have used iterator traits or know
what they are yeah there we go
honey iterator traits has five nested
type deaths pointer reference iterator
category value type and let's the other
way
difference type that's what it is
difference type but so you know tells
you if you're a random access iterator
or forward iterator and so on and it
tells you for example value type will
tell you what's if you dereference this
Ettore or what's the type of the thing
you're getting back and this is really
handy when you're writing algorithms for
example if you were gonna write
something like say some okay you write
something that takes a pair of iterators
begin and end and it's going to return
the sum so conceptually this is really
simple right you you start with zero you
had the first one in you at the second
one then you add the third one in until
you're done and then you return it
really simple but but you start with
zero of what an answer as you start with
the zero of the value type of the
iterator anyway I'm getting a little
head of myself because my site is yeah
yeah this is fun but why would I do this
and so yeah I'm just I just get three
slides head why would they use them well
because you're when you're doing when
you are doing generic code sometimes
it's really handy to do that and yeah
writing algorithms I talked about some
where the where you need to know what
the type what type to return and also
what type does you know what zero to
start with if you wanted to do a
factorial you know you know what what
type to start with one right you start
with one and you multiply same kind of
thing but the other thing is is that the
iterator classifications iterator traits
are really really handy when you're
writing some kind of complicated
algorithm that has to do with traversal
because the different kinds of iterators
can give you different kinds of give you
different categories or capabilities a
real simple example is is permutation is
permutation is a very useful call that
says is this sequence a permutation of
this sequence they have the same
elements
but in a different order and this is an
expensive operation to do I mean it's
basically it's an N squared operation
which could be very expensive if this is
you have large sequences but sometimes
you need to know that and if you have
but if you have random access in arrears
there's a quick out in some cases the
first thing you do is you can look and
say how long are these sequences and if
they're a different different length or
you're done you know that they're not
one's not a permutation of each other or
the other because the shorter one is not
it's not going to have the same elements
as the longer one because there's at
least one missing sorry I'm gonna try to
not walk around so much but in any case
and that we use that in permutation
mismatch equal a bunch of other ones but
because forward iterators or
bi-directional iterators calculating the
length is that is a linear operation
which can which in a long sequence can
be expensive we don't do that for those
and so it's an example of the kind of
things where iterator traces of handy I
talked about the return returning a
value from a sequence of past byte
iterator is you want to know what you
want to return well what type do you
want to return it to and the other thing
is it gives you information about about
the objects that you're dealing with and
it can tell you what kind of operations
you can or might not be able to deal
with oh I forgot remote blue litter
excuse me I'm having a hard time talking
today and I'm not sure why rotate Shawn
mentioned rotate this morning rotate is
the least current implementations of
rotate are actually quite a bit easier
if you have random access iterators
rather than you have just forward or
bi-directional iterators but now he
suggested that today that he has a way
of dealing doing it with forward
iterators that's just as simple which
means I have to have some reading to do
in some experimenting do which is fine
so any questions about out whether this
thought I saw had nope okay
another use for typed rates reducing
restricting templates using enable if so
this is going to go we're gonna have to
do a little background with this if
you're writing a let's say a template
function and you want it to work with
only a certain certain kind of certain
set of objects there's a facility in the
standard library called enable if and it
has to do with well using the the second
ugliest acronym in C++ called spin a the
first Akron ugliest the ugliest one for
me at least is are AII because I can't
actually say that without spelling it
out but they're both kind of silly so
basically this is enable if is a
packaged up version of a soon a
technique to restrict your the compiler
from using your templates for certain
kinds of types and I'm gonna run through
an example and we're going to talk about
how this works so it comes down to when
the compiler is looking to call a
function or make a template make a type
or something it builds what it's called
a candidate set it builds a set of all
the possible overloads that it might
that that match the call and then it
goes through and ranks them and picks
the best one okay in this case I have
three different functions named
unimaginably
func yeah I know I have no imagination
the first one it's a C style their arts
function right it takes anything this is
that's not a you know C++ 11 variable
argument argument pack list at all and
it returns zero and the
the third one down at the bottom takes a
float and returns two and then one of
the senator is a template and and has a
hope is decorated with a whole bunch of
stuff standard enable it ball buh duh
buh buh duh buh buh buh so let's pretend
for a minute that that enable if is not
there okay and if if we didn't have the
enable if and we just ran this code
anybody have any idea what we would get
you'd get one every time I that is not
quite right but certainly we'd start
that way we would get that way in
particular yeah right the the third line
there is an exact match for the third
call and the compiler will always
pervert an exact match over of a non
templated function over a templated
function that takes everything but yeah
the first call would return would one
the second call would print one the
third call would print two and
surprisingly it's it's a double but it's
also implicitly convertible to form to
float yeah anyway so but you say no no
no I want I really want it just to be
integral and so it with the enable if
there what happens is that if the
condition in the enable if the standard
is integral t : value is not satisfied
this actually generates a compile error
inside the template and causes the
composite a compiler to drop the
template from the overload set that it's
building which is where the the ugly
acronym comes from stands for
substitution failure is not an error so
when it substitutes float in there
the the template fails to instantiate
because of a syntax error and the
compiler just drops it out it says SF
and AE substitution failure is not an
error anyway and so what happens is the
set the first line null putter it's not
integral it's not a it's not float it
falls back to the the SIA style of air
args which the compiler uses the
compiler considers C style of air args
to be the pretty much the lowest form of
matching it will try pretty much
everything else first anyway or it will
let me rephrase that it will prefer just
about everything else to that so but no
punter is not float and it's is
certainly not integral so you'll print a
one yes
okay the second template parameter on
there is in fact the return type of funk
and basically what happens is what
enable if does it takes two parameters
takes a condition and a type and it
either causes that the substitution
failure or it it defines inside of
itself : : type which is the same as
that is the second parameter and so it's
basically it is set up to use you know
in the preamble of a function for the
return type now in the defining the
return type so yeah you end up with you
just say standard enable up condition
return type calling hole and type and
it's always the same as the return type
or it fails to instantiate anyway the so
yeah
the second call says is integral yes and
it it will pick the second the second
function because because that's a better
match than float and it's a better match
than the ellipses okay the third call
2.0 F now that's that is not an integral
type and besides it's a exact match for
the for the third call so it will print
two and the fourth call interesting
enough will also print two it can't it
it cannot actually satisfy the second
call that they the templated version
because it's not integral but there is
an implicit conversion from double to
float and the kind Pilar will prefer to
do an implicit conversion rather than to
choose the the C style ver args depends
depends on your compiler depends on how
good your compiler is the question was
once you get a narrowing warning from
your compiler and it depends on how good
your compiler a really bad compiler no
narrowing warning okay a better compiler
you'll get a narrowing warning a good
compiler will say there's no loss of
value transfer doing a floating point a
double - to a float - no warning so if
you have a bad compiler or a really good
compiler you'll get no warning and if
you have something in the middle then
you'll get a warning yeah warnings are
kind of funny is like you know we like
compilers put in warnings because they
catch things but as the compilers get
better and better you know that that
would be a false positive on the warning
you'd say yeah I'm Warren I'm I'm
converting a double to a float maybe
there's a loss of precision there but
but it's a constant value and there's no
loss of precision there so a warning
would be a false positive there yes
without the OOD
so the question is without the enable if
guard will it pick the template or do
the conversion and I believe that he was
correct that it will choose the template
because it doesn't have to do a
conversion if you're going to do this
it's really good to spend a little while
experimenting and you know and find an
article about matching of overload sets
so you can be sure of what's going to
happen because basically what you're
doing is you're saying as you set these
up you're saying I want this to happen
in this condition and this can happen in
this condition this can happen in this
condition and you want to make sure that
those actually do happen that the things
you want to have happen happen hand here
thank you yes I'm sorry I meant zero
this print zero one two two
yes okay so the question is if you if
you set this up so that the you know you
can do this I have an able if here can
you have multiple functions with each
with enable if on them and and will the
compiler complain about that no the
compiler won't complain about that the
most common thing I see actually is two
of them one that says enable if
something and the other one says enable
if not something but if you can have you
shouldn't be able to have as many as you
want as long as you're not ambiguous the
compiler you know the compiler has
strict rules about which is better but
all the templates are going to be pretty
much the same and so if you had two that
match something the compiler would say
um this is ambiguous I don't know what
to do
so the comment was if if I had another
one there that where the enable this
statement said is floating point would
it pick the floating point calls here
and it would certainly pick this the
fourth one the bottom one but not the
third one and the reason the third one
it wouldn't pick the third one is
because there's a better match there's
the the final function down there that
that is non templated and takes a takes
a float it it will the compiler will
choose that again I mean the compiled
language has a set of rules for matching
out of candidate sets and if you're
going to do this kind of stuff you you
really want to look at those rules and
and be very clear on them but one of the
rules is if you if it has a direct match
that's not a template it will - it will
take the an exact match for the template
over the template question here so the
question was are you allowed to do
arithmetic operations on on the
conditions there and say is integral
something or is floating point total
close out yes you are and in fact we in
the standard library we have various
ones of those you know like is you know
is not a reference and is not you know
something else say or you know is not a
reference or is a pointer anyway right
yeah the course common is that anything
that is a constant expression it's true
and it yeah it has to be known at
compile time okay other questions
okay we're gonna leave the spin a
example and go on to different a
different example of why you want light
want type traits you can if you're
writing generic codes sometimes it's
worth your while to be not be generic
okay you can provide optimized versions
of your generic code for some types or
types that can that hold particular
properties and I'm going to use the the
classic example from the standard
library which is vector pushback okay
I'm doing this because it's an
interesting example and because
everybody wants to write vector at some
point right how many people have tried
to write something like vector yeah sure
I mean you know it's it's like it
everybody knows they can do better than
the standard library and then they try
it and rediscovery it's really
complicated there's lots of little
corner cases anyway vector push back
vector push back has a strong exception
guarantee that's written in the standard
it basically says that pushing back
something either completely succeeds or
it throws an exception and the vector is
left exactly the you know is left in the
same state as it was before it has the
same that has the same capacity it has
the same size it has the same object
okay a vector has both capacity and size
actually it may not actually guarantee
that has the same capacity but everybody
that's that's the way it's always
implemented vector has capacity in size
a vector allocates some space and then
fills it along the way so there may be
unused bytes at the end of the vector
waiting for that you to put more objects
in okay most of the time when you push
back it's really straightforward right
whether the vector looks and says yeah I
got space on the end further up another
object and it copies it in and we're
done
that's fine okay that's not the case
we're going to talk about because that's
the easy case the more general cases
when the size is
is there isn't room at the end of the
vector for the object you want to add
and you know this applies to insert and
and all those other calls where you
might be adding more than one but would
push back as simple as a one okay you
allocate a bunch of new memory some some
some amount bigger right you copy the
objects one by one over into the new
memory if any of if any of those copies
throws fails for some reason throws you
say fine and you destroy those the
objects you copied and deallocate the
memory and we throw the exception the
original vector is unchanged right you
haven't done anything with the original
vector and this is this is the way
things worked in C++ so three this is a
this is a very good way of dealing with
it it's wise the strong exception
guarantee that's fine
everybody good with this so far so what
if but C++ eleven Howard's not in here
is he we we have mu semantics now moving
is supposed to be an optimization of of
copying right moving is supposed to be
faster than copying and you think we can
do better than this we can get better
performance by using move semantics okay
so fine but there's a catch remember the
strong exception guarantee let's just
talk about you know a naive way of doing
it right and we allocate some more
memory a bigger memory and we move
things over from one to the other to the
other to the other to the other together
but what if one of the moves fails right
we say
we've moved five and the sixth one
failed okay well let's move these five
back what if one of those fails we're
stuck right we are just stuck we cannot
satisfy the strong exception guarantee
anymore because we've just start we've
done a destructive operation and we
can't get back okay but but we want to
be able to move things things that are
expensive to copy we want to be able to
move things you know if you have like a
vector of maps all right copying a map
is expensive you have to do plea you
have to reallocate all the nodes in the
map and everything that's in those pairs
and so on and you really want that to be
fast and so what vector does is it does
this operation but only if the the type
that's in the in the vector is no throw
move constructible if the type is
willing is can guarantee that moving it
will not throw then you can do this
operation safely because you just you
move move move move move and then
destroy destroy destroy destroy destroy
and update the pointers then you're good
to go and you get the speed-up and the
exception safety but you have to be able
to move construct something without
having it throw ever important safety
tip if you are if you are writing a type
and you expect to put it in a vector or
actually just in general you really want
your move construction and your move
assignment operators to be no throw or
to be no except if at all possible okay
some sometimes it's not possible but in
general you want them to be no throw
move except no throw move assignment and
new construction and this is only one
reason okay everybody good with that but
we can do better sometimes
what if you have a vector of intz okay
what if you have a vector events what if
you have a vector of of struts that
contain an int a float and a care okay
what you really want to be able to do
what people come to me all the time is
like what I really want to be able to do
is I always want to be able to allocate
some memory and men copy them from one
to the other just pick up the bytes and
lay them down and don't even I don't
care what the structure is just put them
down there there's a typed rate for that
it's called trivially copyable so if in
fact your type is trivially copyable and
there's a if you there's a list of
things it has to have basically all the
mets obstruct it has to have all the
members be trivially copyable and i
think it has to have a trivial
destructor as well but basically whereas
a trivial constructor excuse me
and basically if that happens what you
want to do if you're in your
implementation of vector is allocate a
bunch of memory mem copy from the the
old memory to the new memory and then
destroy the old objects and update your
pointers no worries about exceptions
right mem copy never throws and no
worries about your destructors throwing
because destructors can't throw so this
is almost certainly faster than anything
else although if you're writing a vector
replacement you should have tests that
measure this and make sure that it
really is faster than it's worth doing
because it is adding extra complexity
but this is an example of where a type
trait can really be a win for you both
the move semantics and the and excuse me
and the trivial and copyable stuff yeah
as I said these are all these are
optimizations okay you can make your
users happy with these optimizations but
none of them are necessary for
correctness your program you know your
your vector will be correct if it does
things copying the objects one at a time
and then destroying the old ones that is
not an incorrect
implementation this is just a faster up
in faster implementation in some cases
okay and you do this by comparing you
know it when when kind comes for
pushback you know you you can say you
know is trivially copyable T : : value
if that's true call one routine if you
know if no throw move constructible call
another routine else to the third one
you can do that you can use some kind of
templated tag dispatch or you just you
know just have a branch set of this
anyway
this is um this is the kind of thing
that yeah a lot of containers do they
help you write out so this okay we're
good for time right 15 minutes this is
the kind of things that people do with
tight rates this is you know this is the
first first kind of level about typed
rates doing comparing and testing if you
want more information these are two very
nice books about type rates they're both
about eight or nine years old this one
is called modern C++ design by ander
Alex and Rio legs and rescue Andre is
here at the conference and he has giving
a talk I believe it's tomorrow might be
Friday but I think it's tomorrow and and
I borrowed these books from the
University Bookstore out front where
they're selling them this one is uh this
one is actually signed by Andre but I'll
be returning it so if somebody wants to
wants it to buy a signed book well there
you go but this is the this book was
written ten years ago and it does not
talk about mu semantics or a bunch of
other C++ 11 things or 14 but it talks a
lot about template metaprogramming and
it builds up a framework
for doing template metaprogramming there
are lots of frameworks this was this one
was called Loki this was one of the
first but you can learn an awful lot of
principles on this both of these books
this one is by Dave Abrams and uh Liske
this is a little later and they're
they're more examples this is this one's
based off the boost type traits library
and the boost metaprogramming library
both of these books go quite a bit
farther than I have in this talk they
build up very very intricate and
complicated frameworks for doing
intricate and complicated things but
when you you know if this if what I've
done here today has given you an
appetite to learn more these these are
good places to go okay
oops sorry I thought I was on that one
okay other questions yes in the back
sure zero one two two
yes
okay for the for the video the question
are withdrew his question yes the
question is basically can you generate
your own type traits absolutely there
are few type traits in the standard
library which are really hard to
implement in the language okay and
basically we depend on compiler support
for them but in general most of the type
traits are just are just written I mean
you can imagine how to let's look at
let's look at is floating-point okay
whoops too far is floating-point alright
think about how you would implement this
you have a primary template that sets
that has a static member variable set to
false and then you have three
specializations one for float one for
double one for long double that set the
fact the static member variable to true
done okay
there's there's nothing preventing you
from writing your own type traits
sometimes it's you have to go to more
work than that to figure out how to do
them but frequently it's very simple
there's Walter Brown gave a talk last
year here about using void T to do to do
basically detection of capabilities on
types and you can certainly use that to
to create your own type traits even you
can say you know does does a particular
type have a member function named food
that takes an int and a float and return
a stud string you can write type your
own type traits like that
okay in the green and then in the brown
well okay the question was if you have
it if you have an old Stan old code base
which has a lot of you know passes
around void pointers and has a bunch of
c-style cast and so on
what happens there well the thing is
once you convert something to avoid
point you've lost all the type of
information and so any of the type you
try to do any type trace stuff they're
going all they're going to see is void
star and so you're going to end up with
working with well if you do a C cell
cast
okay the type is now going to be the
result of the cast no I doesn't do any
checks it doesn't it doesn't look past
the cast yes okay so the question was
for this for the spinny thing is there a
benefit to having it as part of the I
went too far
there basically there are two ways to do
this
okay there's one with enable if and
incorporate it into the return type and
the other way is you can define a second
parameter to this that is a pointer to
you know some type that I was only
around for or integral types basically
and and then default it to zero and so
when you call it you know that that zero
gets filled in or the the substitution
failure happens and the the question is
is there any benefit to doing it this
way as opposed to that way in general
this is this way is considered cleaner
the other way is necessary for some
things like constructors which don't
have a return type but if you add a per
a default parameter to a function
somebody can pass a value to that okay
and you probably don't want that and you
know it's it's kind of it's one of those
things that that you just if you do it
this way you do not give your users an
opportunity to misuse it whether whether
due to error or malice either one and so
you know it would be terrible to see
somewhere in your code see a call to
func 2 comma 4 and you wait what just
happened there ah the question is can
you can you put it as part of the
template signature the template
parameter list instead of the function
signature and in in many cases you can
but then again somebody could say func
bracket type list it's it's not it's not
an awful way to do things it's just this
way is you know it it leaves off classes
of errors that are rare but still I'd
rather not have to actually explain to
people that
it's not yes I agree the the return type
figuring out the return type for the
second function up there is is not
exactly trivial as the gentleman in the
back who was asking me a question about
it and then said oh no no I see it I
agree
better indentation would help here
actually I tend to this is kind of more
slide wear than anything else but I tend
to when I'm writing these I tend to
break after the comma after is integral
value so the line the line below funk is
you know int colon colon type and so I
know where to look but that's a
convention I use rather than a universal
kind of thing who is up first I see hand
here hand there anybody know you go
ahead you'll be next yeah concepts are
going to change the way this is done a
lot because what you'll do is you'll
write a concept that says requires
something to be an int yes over here so
the question is can you do can you use
the arrow syntax and put the and put the
return type somewhere else ooh I've
never considered that for enable if
because because then you know you still
have to have the enable if phrase
somewhere in there and and this lets it
fit right into you know a function
declaration where you have template
return type function name parameter list
you had a question behind you yes
yeah that's well I don't know about the
two lines two lines disappearing but the
rest of it is very accurate so that so
to rephrase
rather than rephrasing your question I'm
going to try rather than answering your
question I'm going to rephrase what you
said and then agree with you now what
happens is for the fourth call here 2.0
double it attempts to instantiate the
template template there with double as
the type okay something goes wrong there
okay
driven by the enable if okay the
substitute substituting double in for T
there does not end does not create a
syntactically valid function and so the
compiler just drops it on the floor as
its building its overload set and so for
the fourth call there the overload set
consists of the first function and the
third function go ahead
so the question was does yeah I said I
get that it doesn't actually enter the
the overload set but the compiler
actually tried to pump to parse this
without the without those two lines in
between and and the answer the answer is
yeah that's an implementation deal
detail what I suspect happens that I
haven't looked in a while is that if the
condition is false okay
there's no nested type def named type in
in that struct and so what happens is it
tries to generate type gets a says no I
have known type that so mark said as a
substitution failure and you know does
not add it to the overload set because
the the template failed to when I
substitute double in there I cannot
actually generate a syntactically valid
function yes in the back yes yeah well
yeah this is in so yeah in if we were
doing this all in C++ 14 yeah I'd be
using instead of value and type I'd be
using the shortcuts for V and T which I
mentioned briefly earlier we write this
as standard in and is integral V T comma
in and it would be standalone enable if
if t underscore t instead of the colon
colon value and it would be noticeably
shorter but it would be c plus plus 14
only and so i didn't want to do that
okay any other questions perfect 50 oh
there's a question okay
the comment was he tried to reach a
trailing return type what did putting
the enable if in the trailing return
type okay
yeah he's tied with clang and it worked
so it's probably legal right his comment
was and sometimes it's necessary because
if you want to check something about the
parameter list in the return type then
you have to do things it as a trailing
return type and that's absolutely
correct so that would imply that yes it
is legal and you need to be able to do
it all right thank you everybody for
coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>