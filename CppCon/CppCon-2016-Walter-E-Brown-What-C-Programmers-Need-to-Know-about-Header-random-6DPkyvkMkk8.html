<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Walter E. Brown “What C++ Programmers Need to Know about Header ＜random＞&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Walter E. Brown “What C++ Programmers Need to Know about Header ＜random＞&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Walter E. Brown “What C++ Programmers Need to Know about Header ＜random＞&quot;</b></h2><h5 class="post__date">2016-09-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6DPkyvkMkk8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">afternoon everybody thanks for coming
we're gonna talk today about the random
header in the secret clear standard
library it came in with C++ 2011 it's
essentially been unchanged since then
there are some things on the horizon
that I would tell you about toward the
end of the talk before I actually get
into the technical details although it's
customary to give thanks at the end of a
talk I would like to ask your help in
thanking somebody very important to me
someone who hardly ever gets thanked and
that would be my wife
who actually fabricated my tie that I am
wearing today so please help me thank
her I appreciate that
thanks very much so we're going to talk
today as advertised about the ideas that
went into what became the random header
they'll demonstrate the most common
correct usage pattern I will show you
the most common incorrect anti-pattern
and I'll explain what's wrong with it
what's really wrong with it is
sociological it's just too simple it's
too attractive but thou shalt not do
this we will explore some toolkit
designs and you can extend that if you
wish we're gonna have a little random
fun some of this material is taken from
some paper I wrote a few years ago those
are the there are the paper numbers are
there in case you want to look them up
and there are going to be some extra
slides that I've had to hide because
otherwise I'm I would go over time but
the files that I will upload will have
all of the slides so if you happen to
notice that there are some gaps in slide
numbering there's some hidden slides
there so if you're interested in just a
few more little details please do
download the slides or at least look at
them at your convenience so first a
little bit of background
information on the general topic of
randomness yeah they're a pain in the
butt I said it was background
information good night okay and of
course there's the famous statement by
Don Knuth this has been known for a very
long time and yet the temptation is
almost irresistible to roll your own
please don't do it
please don't roll your own unless you're
an expert it is interesting that the
first known algorithm for generating or
pseudo generating pseudo-random numbers
dates back to around 12:45 a Franciscan
brother Edvin wrote about it it was then
I believe independently rediscovered by
John von Neumann around the middle of
the last century it is considered a a
crude but very fast algorithm they had
ideas you start with you know a big
number you square it you chop off a
quarter of the digits at the end the
quarter of the digits at the beginning
and what you're left is the middle of
the square and that's your next number
that's very fast very crude but it's
very fast and the failure modes are
obvious if you ever happen to get a zero
you're done right okay but nonetheless
this algorithm was in use at some point
back then in particular it was used back
then in support of what has come to be
called the Monte Carlo method it's an
unusual name it turns out it was a
codename during the post-war years all
right they were still actively involved
in the Manhattan Project back then was
developed by you Lamy and actually coded
on the e me app by John von Neumann the
process however known as Monte Carlo is
still in heavy heavy heavy use today and
it relies intimately on the generation
of random numbers the idea of course is
you simulate a process and then do
statistical analysis on the measurements
you take as a result but nowadays there
are many more uses of random numbers
I'll just give you some highlights
there are Monte Carlo and other
simulations and yes it's called Monte
Carlo because of where the casino is
there are genetic algorithms randomized
algorithms hashing algorithms not too
many people have discovered know about
something called Zobrist hashing it's
interesting that it applies to board
games for example rearranging which most
of us know better as shuffling is a very
common application of randomness for
most of us or many of us at least we use
it to test sort algorithms but it is
used in so-called randomized
tournaments which covers everything from
sporting events to the military draft if
you want to see some fascinating history
look at the first random draft of the US
military it's a horror story there are
jurisdictions in which the preparation
of a voter ballot is randomized so that
no candidate is obviously favored by
being first for example random numbers
are used for selection purposes
obviously in gaming there are teachers
who use it to make sure that they call
on students fairly eliminating personal
bias don't just call on the most event
on the best-looking student choosing
performers on open mic night for us
choosing a pivot and quicksort is often
done randomly a lot of applications and
statistical sampling in manufacturing
quality control and drug screening drug
screening drug screening auditing trials
for new medical treatments etcetra
etcetra it's a very long list and one
item I want to call out specifically of
course random numbers have a role to
play in cryptography but I want to let
you know at the outset that this is not
a goal of the in the design of the
random header cryptography has
additional
requirements that were not considered
when this header was designed design
goes back almost 15 years we did not
consider cryptography so please if you
have the cryptographic application this
is not a good place to start to look you
can look at it for inspiration but these
are not the facilities you should be
using at least not without some extra
work on your part so let me start with a
with a with a leading question suppose
you have an Oracle of some sort I don't
care if it's a crystal ball and if you
if you you know look at some entrails or
whatever you do you have an Oracle and
you ask it for some some random numbers
and ten times in a row it delivers to
you zero did you consider that random I
suspect most of us would say no and yet
there's not enough information to answer
the question you don't have a big enough
sample to know whether that's random you
just don't Pete back Pete Becker was a
was a well-respected member of the C++
standards committee he was the project
editor for C++ 11 and he's now enjoying
his retirement
SMI there's another way of expressing
the same notion this is perhaps a very
well-known cartoon but I felt it
appropriate at this point as always
scott adams cuts to the heart and it
turns out that getting a computer to do
anything randomly is not just difficult
but astonishingly difficult far more
difficult than most of us would like to
think it's not just hard for computers
it's also interesting the problem is if
you look at the literature of the past
6070 years as I have done I don't claim
to have read all of it but I've read a
fair amount of it I am not exaggerating
it is littered with algorithms that were
just plain
wrong but that people have been relying
on and because it was it has been
published you know people think
therefore it must be good and some of
these things are still in use today
please don't don't rely on anything
until it's been exhaustively tested
there are so many pitfalls this is a
very nice statement of the facts as
proven by history you don't want to
write code that's embarassingly bad I
sure don't here's a nice summary of the
return message and this is really at the
heart of why we designed and ultimately
specified the random number library in
the random header I'm the center of the
principle author of the papers if you do
arbitrary stuff on random numbers you
don't get random output you might but
you'd be lucky and then of course xkcd
comes along so what you asked for not
what you wanted I am often asked what
was wrong with the ran function in
instead of Lib dot H and of course which
we absorbed as C stood Live Well if you
haven't I encourage you to go read what
the C standard says about it in C 11
here's the quote it's a footnote there
are no guarantees about the quality of
what you get and it is known that some
implementations give you not just bad
distressingly non-random bits that's
what it says I'm quoting the standard I
did not make this up C++ standard C++ 17
at least says it I think a little bit
more genteel
the algorithm is unspecified which of
course means unported unpredictable
quality and performance and oft
questionable right I think that's a
little gentler but hey it's a C function
they get to say whatever they want about
anyway here is one man's opinion I wish
I knew who this was this is what he
calls himself on his blog in me which I
thought it was kind of flattering so
whoever you are thank you
so let's actually have a big picture
look at what's in the head of it this is
what we are in a comments but he's
quoting somebody else
I believe he's quoting Andrei Alexander
s Q not a hundred percent sure but this
is from B Arnaz or was on B Ana's
homepage or one of his home pages but
every random number library wants to be
when it grows up I love that phrase so
at least in my opinion there's something
there for everybody whether you're a
novice a casual user all the way up
through expert there's something there
for everybody so for those of us who are
casual users which you're probably most
interested in is the one pre-configured
engine type and I'll make sure we all
know what if that means all the words in
green we will discuss and then there are
two uniform distribution
class templates they are configurable
can't pre configure them because we
don't know your application so you have
to configure them but for intermediate
and advanced users we have nine more
engine types 18 more distribution
templates there's a class in case you
have access to some environmental source
of randomness we'll discuss that briefly
there's a class that was supposed to
help you with engine seeding and for
true experts we have some class
templates if you want to play with the
template parameters and there's actually
even a function template to help authors
of new distributions if in case that's
your thing
so there's something
for just about everybody on the on the
programming spectrum this perhaps the
single most important takeaway for now
are the next few lines the nomenclature
that we use it is generally not
particularly well known that the
traditional term random number generator
actually encapsulates two very different
kinds of algorithms it's almost like an
old-fashioned computer terminal that had
a keyboard that had a monitor but they
were all under one dust cover we just
said it's a terminal but you've got two
very different pieces of equipment there
under one cover same idea here if you
talk about a random number generation
there are two algorithms and we need to
talk about them separately so we use
nomenclature that's a little bit more
precise and if you're going to work with
this this is what you should know best
the first piece of nomenclature is the
is the term engine engine is what we
mean by an algorithm or something else
perhaps that lets you obtain a sequence
of unpredictable at least ideally
unpredictable bits in particular uniform
is the important property and what do we
mean by uniform
it's the statisticians way of saying
that probability of a 0 is the same as
the probability of a 1 every single time
that's the uniformity property at the
bit level okay and the second piece of
nomenclature is the idea of a
distribution which is well known to
statisticians but not necessarily to
computer scientists and programmers the
distribution is a means of obtaining a
variant we think of them as random
numbers the technical term is a variant
and it's not just any variant we want
variants for our applications such that
if you aggregate
and you plot them you get a particular
shape but what shape do you want I can't
answer that you have to answer that for
your application here are some
possibilities there are lots lots more
it's not important that you see what
these are but just the you know a little
bit of the possible variety of what I
mean by aggregated shape the the first
one at the bottom left is called the
normal distribution a lot of us know it
as the bell-shaped curve but that's
parameterised how wide is it how high is
it where is it left-right etc etc okay
so these are things you will have to
supply you have to know your application
well enough to decide what kind of a
distribution you want for people who are
casual users almost always what they
want is a uniform distribution if you're
you know playing cards or you're trying
to simulate rolling a fair die or
something like that
what you want is a uniform distribution
if you want to roll two dice
you don't want a uniform distribution
unless you roll them one at a time okay
so you have to know what you're talking
about
this is a classic example where two
times X does not equal X plus X okay so
beware of even simple refactorings that
seem obvious they don't necessarily work
you have to know what you're doing so
let's talk a little bit about engines we
use the term engine both to refer to
certain kinds of types and then to
objects of those types all right so
let's postulate that we have an engine
object lowercase e whose type is capital
e and it's a function object it's
callable it has an operator parents
every time you call it you're going to
get some number of bits uniformly
distributed ideally random bits okay by
the way don't assume that n has to be an
integer
don't assume it usually is it typically
is nothing in the definition says it has
to be once initialized this object has
typically deterministic output and
therefore we if you want to be precise
you're actually getting pseudo-random
numbers okay but not every engine gives
you deterministic output we have
interfaces for environmental sources of
randomness so don't assume it's going to
be pseudo-random depends on your choice
of engine the ideal is unpredictability
but when you have a computer you
typically have to settle for very very
very very very very hard to predict
that's the key an inability to predict
that's the key now there are some
details right when you call an engine
what you get is often called a bit
string in other contexts it has a
nonzero length it's encoded as some
unsigned type there's a reason for that
long long ago when we were designing and
experimenting with this stuff our
initial idea for an engine was you make
a call you get a bit one another bit you
make a second call the performance was
horrible as you can well imagine so we
said okay you know let's allow engines
to give you up to 32 bits at a time or
you know back then that was that was the
obvious result okay but we don't require
anything other than there be some men
and some max value both unsigned of
course and you can ask what those are
min is almost always zero but it's not
required to be most importantly for
users you probably don't need to know
any of that really don't do
intent of an engine is that you get to
pick which one you want your choice of
algorithm you get to initialize it
however you want your choice you may
want to reproducibility you may want no
reproducibility it's up to you but once
you've done that all you do is pass it
around literally that's almost all you
ever do with it I mean an engine can do
other things I'll tell you about some of
them later but the single most important
thing you want to do with an engine is
hand it off to something else so let's
talk a little bit about distributions
the purpose of a distribution object is
again you call it and it gives you a
result and this is what you want you
want a very random number you do it by
calling a distribution okay so you have
to create a distribution which
distribution depends on your application
how do you create one depends on your
choice of distribution typically these
are templates so you have to tell it
what's the type that you want to get
back if you want integers and you want
to float if you want to double what do
you want their distributions that give
you bools
okay and huh and then what are the
constructor arguments well it depends on
your choice of distribution here are two
examples the uniform into distribution
is one of the ones that that beginners
typically need if you want to roll a die
or shuffle cards or something so this
example says I want variants of type
long and I want them in the range load
to high inclusive low through high okay
so if you're rolling a die that'd be one
and six if you want the normal
distribution the bell-shaped curve again
you tell it what type you want as a
result but it's parameterised according
to a mean and standard deviation from
hi so how you instantiate this depends
on what you choose okay
so here's sort of the canonical example
it's very simple and once you've seen
this and understand it you know at least
90% of what you need to know to make use
of this header so the idea is you roll a
fair die
of course you include the header I'm not
going to bother doing that ever again
you need to instantiate an engine and a
distribution and there's something
called a default random engine I'll say
more about that shortly and then the
uniform int distribution as I showed you
above I made them static for simplicity
here of course you get to control their
lifetimes however you want if you want
you can do shared pointers and you can
pass around shared pointers if you want
that's it that's entirely up to you I'll
give you some tips about management in a
little bit and then what you do is you
call div and again as I said all you're
doing what the engine is handing it over
to somebody else in this case the
distribution and for 90% of the use
cases that I've seen in the last 15 or
20 years this is what you want to do
this is necessary and typically it's
sufficient now one of the nice things is
that once you package a distribution and
an engine perhaps like this you get to
do other kind of neat things and just to
give you a hint suppose I make you know
a native array of size 1,000 I'd like to
fill it with a thousand rolls of the
fair die okay so generate will do that
for you fill the array a from 0 up to n
and each time it calls roll a fair die
which is a kind of function object
that's a function but that the function
is a function object and it takes no
arguments so you can pass it off to
generate and now you have a thousand
grant rolls of at that fair die ok
the little taste of some things that you
can do now let's explore a little bit in
more depth there are ten pre-configured
engine types that you can choose from
I'm going to pick first on the default
random engine it is special in a couple
of ways it is intended and then you can
read the quote yourself casual in expert
or like waste use you don't know what
algorithm it uses it's deliberately
specify that way your vendor gets to
choose the algorithm as a result the
output of an engine of this type is not
portable across platforms because
different vendors can make different
choices I know there are vendors who say
I want this to be fast other vendors say
I want this to be high quality etc okay
but for the other nine they are nailed
down and you are guaranteed bit for bit
portability across platforms it's a
requirement your vendor has to do this
if he's going to conform to the standard
now I've named them for you here you
know don't feel you have to memorize
them I'm also not you know going to give
you a tutorial and you know what are the
algorithms because there are lots of
places where you can look that up if
you're if you're curious about the names
we did not invent these names they come
from the standard literature except
Boothby which I had to invent because I
didn't know how else to say this is
coops algorithm beam from his book okay
I mean I think that's kind of an obvious
thing but all the rest come from various
places in the literature okay and some
are 64-bit some are 32-bit etc etc so
why did we pick those nine algorithms
because we didn't want to innovate and
those nine algorithms are
really well known they have reasonable
quality they have widely different
characteristics linear congressional
algorithms for example are typically
very small and very fast but they don't
give you the greatest quality of
randomness on the other hand if you want
quality Mersenne twister is what you
want it comes in both 32 and 64-bit
variations but the price you pay is it's
not nearly as fast and perhaps in some
applications more importantly it's 600
times bigger okay it has a lot of state
that's how it gets the quality so there
are trade-offs to be made novices
generally don't care so they just used
the the default random engine but once
you get into more sophisticated
applications you may very well care a
great deal I'm gonna collect questions
at the end if you don't mind because
otherwise I'm gonna run out of time I
was right now you should know that these
engines are actually aliases for
templates that are also in the header
hardly anybody should muck around with
those templates unless you're an expert
because it turns out I mean you can tune
these templates as much as you like they
all have knobs typically template
parameters but very few combinations
comparatively give you anything
approaching decent quality by we have
output coming up with a new engine is
hard work and computer scientists are
typically not the best people to do that
but you want our mathematicians and
statisticians and so forth okay
we did you know this different training
that goes into that so it's okay to know
that these are there but I doubt that
many of us in the room or listening to
this on video later really are
interested in those templates but you
should know that they're there I told
you that engines can actually do more
here are some of the additional things
that an engine
do some of these are more useful than
others
engines are streamable in case you want
to interrupt the calculation and then
restore and come back and pick it up
where you left off
that's useful reproducibility as I said
earlier is very important in certain
applications let's do it again
so you may need to store and then you
know restart engines can be compared if
they're of the same type two engines
compare equal if they're gonna give you
the same outputs from that point forward
and of course you can therefore compare
for in equality as well engines can be
initialized and the the correct term is
ceded in more ways that I'm going to
show you during this talk some are
better than others engines have member
functions named this card because some
people really want to well the most
common thing people want to do is I've
initialized this but I really wanted to
to run through the first thousand our
first million before I would start to
use the results so just throw away the
first thousand that you generate you do
that I call them discard some engines
can do this far more efficiently than
others that's why the member function is
there it does it in the manner best
suited to the engine it turns out that
distributions don't need any of those
extras and so we actually in the
standard have a two-tier approach I've
only told you about engines that's
actually the second tier if you bundle
up the requirements that a distribution
imposes what you have is something that
we now refer to as a you are BG we
change the nomenclature very slightly
for c++ 17 a uniform random bits
generator it's the only thing you should
ever use one of these things for is as a
source of uniformly distributed random
bits and as I say
take it pass it around to some consumer
of those bits and then you use the
result of what that entity gives you now
if you have it you are BG that also has
all these other extra capabilities such
as streaming and so forth
the nomenclature now is engine so engine
is a strict superset of you are BG okay
it's important to know the distinction
because there is something in the
standard that is a you are VG and not
also an engine okay it's called random
device and what it is designed to be is
a standard interface to something that
is not standard if you have access to an
environmental sometimes called a
physical source of randomness for
example dev random or dev you random
depending on whether you care about
blocking or if you have access to a
device for example the samples
atmospheric noise I can transform that
into zeros and ones for you
this is a standard interface to such
things now by its nature
we can't supply much of the body of this
it's an interface in particular and the
way you use it is implementation defined
your implementation has to specify how
you gain access to it and what we've
said is there's a constructor that takes
a string I mean you may have multiple
sources of randomness right so
user-defined string SR implementation to
find string lets you choose among them
for example dev random versus dev you
random you may have access to both etc
etc okay
interestingly there is also member
function here named entropy designed to
give you an estimate of well guess what
the entropy of your device so if you
haven't seen it before that's the
definition of entropy there's actually
somebody in Europe whose headstone on
his grave
has a version of this formula you can
find it in the slides if you download
them but please understand if you call
on this function you're getting an
estimate because sometimes getting it
exactly right is incredibly hard to do
depending on your source of entropy okay
which means effectively it is possible
that when you call this function you're
being lied to so don't rely on it too
heavily there are some vendors who
supply this and you call entropy and
you're always going to get zero okay so
don't take it too seriously but you know
you can ask your vendor to do better um
it is interesting as a historical note
that way back in 1951 according to Don
Knuth there was a machine called the
Ferranti mark one that had a built-in
instruction that gave you twenty random
bits into its accumulator using a
circuit called a resistance noise
generator and that that feature had been
requested by Alan Turing himself I just
thought that was an interesting
historical note in case you haven't
looked into this I'm just letting you
know I'm not chilling for anybody here
but there are commercial sources of such
devices and they're relatively
inexpensive these days they come with
various kinds of interfaces USB
interfaces or you know it looks like a
stick PCI boards etcetera etcetera and
recent CPUs support hardware
instructions to do to do random related
things
there are also some online services that
are free I haven't done this but based
on what I've looked at which was a just
a couple months ago it should be fairly
straightforward to put together a
an interface that that will grab numbers
online and if that's good enough for
what you need please feel free but one
word of caution be careful about your
online service okay III wouldn't rely on
psychic services for random numbers okay
but they'll happily give you numbers
okay
I've told you all about all the engines
in the standard library let me tell you
a little bit about the distributions
there are 20 of them that we categorize
them in five families two of them or the
uniform distributions one for int one
for floating-point no one is real four
of them are classified as Bernoulli
distributions five of them of croissant
distributions six of them are normal
distributions three of them we classify
as sampling distributions again this is
not a tutorial and what the differences
are among them this is something you
need to know for your application you
don't go find a statistician okay it's a
fair question to ask why these and not
others and by others I mean there are
hundreds of others maybe thousands I
haven't done count
they really are so we wrote a paper I
think the author was actually one of my
then colleagues but I contributed
heavily to it way back in 2004 things
have changed a little bit since then
this was long before C++ 11 but the
fundamental rationale is in that paper
if you're interested please do feel free
to have a look at that now I've already
told you that the standard distribution
is by and large with one exception or
class templates and the template
parameter is the type that you want when
you call upon the distribution some
distributions are integer types only
most of the rest are floating-point
types only and one the Bernoulli
distribution is bool only and it's not a
template therefore there's no choice
you're going to get
Buhl okay I told you a little bit ago
that the standard engines are bit 4-bit
portable with the one exception that is
not true for distributions we do not
specify the algorithm by which a
distribution gives you a variate your
vendor gets to choose and there are lots
of choices that can be made there are
literally not just dozens but hundreds
of algorithms for almost any possible
distributions of course the better-known
distributions have more options and if
you look into this don't just look up a
particular algorithm go to that journal
and make sure there aren't Corrections
in later issues please do that if you're
gonna implement your own distribution
based on our article make sure it hasn't
been corrected it would be astonished
astonished at how many times corrections
to ostensibly correct algorithms have
been published in the literature okay
but the reason we didn't nail it down is
we wanted to give implementers the
freedom to make these kinds of choices
based on what they know of their target
platforms okay I would like to stress in
particular that one of the very very
strong features of the facilities in
this header is interoperability and
extensibility just within the header any
engine type that you choose to use will
work with any distribution type you
choose to use and if you or a colleague
or some other source provides more
whether it's engines or distributions if
you adhere to the published interface
in the standard the requirements so to
speak it's going to work and we have
evidence that this in fact happens you
are allowed to provide your own you
RBG's or engines if you want to go to
the extra trouble your own distributions
and it will seamlessly interoperate if
you write your own engine you can use it
with a standard distribution you write
your own distribution you can use it
with a standard engine of your choice or
if you write both it should just work
and we have as I say we have evidence of
this
in particular pointed to moderately
recent developments there's a new engine
called PC G by Melissa O'Neil fairly
recent there's another one that's just a
little bit older a random 1-2-3 bhaijaan
Salman and his colleagues you're welcome
to look those up we're thinking about
putting them in the standard someday but
they haven't been around long enough to
build up a body of trust so to speak so
if it goes on the standard in some sense
we're recommending it we're just not
ready to do that yet we have reason to
believe that these are good quality but
we're just not sure just haven't had
enough experience with them and then if
you're a DCC user as I am you may
already know the DCC ships with about a
dozen additional distributions that you
know one or more people have contributed
last time I look this is what I found
there might be more by now for all I
know and they just Interop it just works
ok so if you have a need for one of
these GCC who let you have it
I can't speak for any other vendor but
you know it should work if you are one
of the few people in the world who
actually is interested in writing your
own distribution as I say there's one
tool in the header that you might want
to use it's named generate canonical it
takes aur BG and calls that
as often as necessary to get as many
bits right it's a source of randomness
so get as many bits as it needs and then
maps those bits as uniformly as possible
to the real type range of your choice
all right
and of course here it's half open the
zero is included one is excluded and
there are very good reasons for that I
keep getting asked for those for that
you know why are integers inclusive and
reals or or half open there are very
good reasons for those decisions we can
talk about that some other time if you
would like it is described in the
standard as it is often a useful step in
the process of transforming a value from
a u RBG into a value that a distribution
can deliver to the client and was
getting a variate okay all right so I
promised to share with you the
anti-pattern right code from hell as we
informally refer to it please don't do
what I'm going to show you what's
important is not the fact that it's bad
code even though it looks innocuous
what's important is that I mean as
professionals you know this but I'm
gonna give you sort of an extreme
example you don't know where your code
is going to end up in a 1 year 5 years
10 years 20 years you may write code
today and in 15 years it may end up as
part of a code base that runs an x-ray
machine delivering treatment to a
patient get it right
you don't know where copy and paste will
end up with your codes we'll send your
code I wrote a library in 1998-1999
two years later I got an email from a
national laboratory saying we found your
library we really liked it we're gonna
put it on the on the on the rocket to
Mars I should not write my library to
run on Mars but I'm told it is
trust me you never know when your code
is going to end up okay I'm sorry
I got it right okay I'm serious get it
right the key here is we deal with
random numbers you have to avoid bias
and that's not a vocabulary term in the
usual undergraduate computing
curriculums
okay as usual xkcd gets the last word an
an random generator there's no such
thing as getting the software almost
right okay
so let's look at the bad code don't do
this I'm just going to do it very simply
we're gonna mimic the role of a fair die
call your engine whatever number it
gives you take the remainder after
dividing by 6 that's going to be in the
range 0 through 5 so add 1 now you get 1
through 6 wonderful way to roll a die
right no this is wrong good this is
wrong
it is so innocuous how could it possibly
be wrong and yet it's horrible you don't
have to believe me I'm gonna give you
other quotations I'm you know so it
turns out there are actually two things
wrong with it
I'll classify the first as a relatively
minor potentially serious but typically
not and the second one is major okay so
what's the minor issue the minor issue
is that there's an assumption in this
code and you don't know
it's true or not what's the assumption
the assumption is that your engine gives
you at least enough bits if your engine
gives you one bit per call
you're never gonna roll other than one
or two are you you think that's fair if
your engine gives you two bits
you'll never roll a five or a six now I
grant you that's unlikely
that's why I call this a minor problem
but you know you may not control the
engine somebody may be handing you an
engine so you know you're making an
assumption so it looks documented okay
here's the major issue typically n is an
integer and therefore when you call the
engine you can get any one of two to the
nth different results there is no value
of two of the ends that's evenly
divisible by six
I'm sorry three is not a factor of two
to the nth right I mean I think you've
known this for a long time right I sure
hope so
now one of our good friends and
colleagues has said it's somewhat more
strongly than I have so I'm gonna quote
first thing he says this is really awful
and then he went ahead and found a
similar piece of code that I don't want
to reproduce today but obviously someone
had recognized the issue and said oh but
I can program around this let me use
floating-point heaven help us which our
colleague says is hilariously
non-uniform love that phrase hilariously
non-uniform and then he goes ahead and
he explains it in his inimitable style
it's the pigeonhole principle if you've
got two to the thirty second pigeons you
can
distribute them into six pigeonholes
without putting some more pigeons in one
hole than others and of course this is
our friend SPL who's here at this
conference
Stefan wobbly so you know don't do this
one of the problems though is that it
seems to work remember one of the early
things I said it's hard to recognize
when you do or don't have randomness
right if somebody does this and it's
been done thousands of times in the last
50 years they're going to be rewarded
with something that looks random and
they're going to be incredibly excited
that they're clever solution really
worked but it doesn't work when you
force the range it eliminates any chance
of having a uniform distribution this is
unfair and the technical word for that
is biased if you have a bias of any sort
you are being unfair right and to be
correct you have to work with the
distribution and not destroy it which
means you have to understand what
uniformity means and respect it now are
we going to get a concept that describes
that I don't know we'll find out
so my plea to you who are listening
today and in the future let's avoid
bigotry and programming please okay so
how do you do it right
that's be virtuous so let me just sneak
up on this by example suppose I want a
variant an integer very attuned the
range one through five at home what
would I do I grab a fair guy and I'd
roll it and take whatever he gives me
unless it happens to give me a six in
which case I roll again all right until
I don't get a six but and that's you
know there's the code now I'm not aware
of many curricula that teach categories
of algorithms called rejection
algorithms but it is a classification
for algorithms right where you do the
work
see if you like the answer and if not
reject it and do it again okay so let's
take this and just slightly tweak it
suppose I don't know it it's gonna be
one to five let's say I've got some
lower and some upper bound low and high
then here's sort of the obvious I've
labeled it naive way to do rejection
call the engine which you already know
is the wrong thing to do good call the
engine and if what you get isn't within
the range you wanted reject and go back
and do it again right oh there's so many
things wrong with this I'm just gonna
give you a small tiny sample of the
things you haven't thought about that we
haven't thought about yet you may have
what if your engine doesn't give you all
the numbers and lo through high what if
gives you some of them but not all but
it gives you number of none of them we
have an infinite loop you're going to
reject forever you're never getting it's
something you like and what about the
performance all right what if he gives
you numbers from a very very large range
much larger than the one you care about
you're going to spend most of your time
rejecting okay etc etc etc I deal and in
the final analysis when you go through
this exercise you're
inventing by the time you're gone if you
do it right you're reinventing standard
the standards uniform into distribution
which of course is already part of the
header so there's no need to do this
exercise except for academic reasons
perhaps I mean if you're interested in
the algorithms fine okay but not for
production purposes okay
I mean there's a certain there's a
certain level of arrogance in our
profession you know you find the same
sort of thing and lots of professions
like surgeons for example you have to be
sort of ultimately confident in your
abilities to get the job done but a good
surgeon knows when not to cut a good
programmer should know when not to code
if you don't have the expertise either
get it or say no it's the professional
thing to do okay so if you want a random
variate typically what you're going to
do is instantiate an engine and a
distribution you get to choose which you
get to pick the parameters of the
distribution both the template argument
and the constructor argument and then
for each variate that you want you call
the distribution object and you pass it
the engine object so that the
distribution can use that engine as a
source of randomness and the canonical
example is you know declare auto variate
equals duv okay and it's really that
simple and for an incredibly large
number of applications it suffice us to
have one engine and one distribution
okay why do you need the distribution
for the last time because it makes no
sense to ask for a random number without
context you
to specify random according to what
distribution people who don't know
better think that all distributions are
uniform and it just isn't so uniform
distributions are incredibly useful but
there are lots and lots of others so my
suggestion if you should get any any
kind of complexity at all start thinking
about engines and distributions as
resources we know how to do resource
management we do memory management we do
file management we do new tax management
we treat them all as resources our AII
for example is the way to go
in many cases right if you get into
anything that is all sophisticated treat
these objects as resources and do it the
same way you may need to take explicit
control over lifetime ok but if your
application is fairly straightforward
you can often combine the engine with
the distribution and you've got lots of
tools that your disposal to do that here
are some of your choices pair couple you
can write your own class you can write
your own class template you can write
you can use bind you can write a lambda
you can write your own function you can
write your own function template there
are lots and lots of ways to do this we
didn't put any of them the library
because we can't make that choice
for you there is no one-size-fits-all
there isn't even a one size fits many
that we were able to converge on you do
need to keep in mind that engine objects
are stateful and mutable so if you're
going to pass them around to other code
do not pass by cost reference because
they will be impotent when they get
there ok they're not cost if you're
using concurrent code you need to
serialize or
you can consider multiple engines one
per thread for example it is less well
known but the same is true for
distributions distributions can be
stateful they don't have to be a many
aren't but they may be as one example
there's a fairly well known algorithm
called box Mueller named for the people
who came up with it it gives you
normally distributed variants except it
generates them two at a time gives you
one cache as the other one
call it the second time it gives you the
one cached so it's stateful okay and you
don't know whether your distribution
uses it I mean I don't know so you don't
know you need to know that an engine
state is influenced by providing a
starting value that we've referred to as
a seed if you put in a fixed seed you're
guaranteeing reproducibility the engine
size is a factor it is really hard to
initialize excuse me Mersenne twister
with a single integer there's something
in the library called seed sequence seed
seek that takes an integer and tries to
make more entropy out of it it's doesn't
do it particularly well it's probably
best avoided feel free to experiment
with it there are better things on the
horizon you have to know whether your
application does or does not care about
reproducibility for some applications
it's critically important it's faithful
for others if you have a game I think
your players will be disappointed if it
plays the same game again and again and
again right it is common to take the
current time or the process ID these are
considered low quality seed data one of
the problems with time is if you need to
seed a lot of things you don't know the
resolution of your clock in all cases
you may think you're getting nanosecond
resolution and you're getting one second
resolution this is bad okay let me tell
you quickly some of the other things you
can do with random we have a new
algorithm and C++ 17 known as sample
the declaration it is actually under the
cover it's two different algorithms and
it picks the right one based on what
kind of iterators you give it okay so if
you have up what's what the
statisticians call a population you can
just think of it as a range begin and
end you give it that range that's gonna
draw from that population you tell it
where to put the copy of what you sample
is how big the sample size you want and
it just does it okay and we're in the
process of proposing an in-place sample
which will do partitioning rather than
copying I want to sample these things
just partition it put the sample at the
beginning and the stuff I have not using
at the end okay so that's sort of in
process we can shuffle now I don't have
time to go through all of this code but
when you look at it later what you'll
notice is that I'm I am mimicking
creating a deck of cards shuffling it
then displaying it all with standard
facilities you should know that the
original stepping offs STL has an
algorithm called random shuffle that was
deprecated in C++ 14 it is gone in C++
17 so best avoided in favor of shuffle
shuffle was designed to ensure operator
random header random shuffle predated it
it is not well known but the parameters
to a distribution can vary per call
here's an example of how to do it and in
fact this is an implementation of the
shuffle algorithm in the standard
library again I'm not going to go
through it in detail but it's
interesting to note that in the call to
the distribution which is near the
bottom for the screen where it says D of
G comma stuff you don't have to
instantiate a new distribution just
because you want to change the
parameters of the distribution for this
one call shuffle it turns out needs to
change the parameters every time it
calls and we do it all with one two
tribution and just some things to think
about for the future you could write an
insert an iterator interface to the
facilities in the random header suppose
you had one for a second what could you
do with it okay here's something
tentatively known as a variate iterator
and you hand at the generator of your
choice and the distribution of your
choice and if I had that then I can
populate a vector by calling a copy or
copy n a whole bunch of variants in one
call or I had I have a friend who's an
engineer and he said you know I really
need to to do a dot product and I need
to do a dot product with a random vector
okay there it is you're done if you have
an iterator interface or an engineer
friend of mine he says well you know I
want to simulate noise so I want to you
know adjust my values with some random
values okay done one line of code okay
if you're interested I encourage you
again download the slides and look at
this more carefully and this is what
such an iterator interface could look
like so this is the first page of two
it's this is basically declarations
there's some design issues you have to
figure out I've just said you know non
owning distribution and you RBG but you
can put in shared put ER or something
like that if you want to take ownership
in part and that's it this is all you
have to produce all right and I know
somebody's going to ask you know why I'm
a inheriting from iterator which is now
deprecated that's because I wrote this a
year or two ago okay so a couple of very
fast closing thoughts please
be wary of resources that you find in
random places okay
the original spec of random was part of
technical report one net which was the
year 2007 why did we do that because we
wanted feedback from a wider community
of users and boy did we get it and what
we ended up with in C++ 11 is much
improved over the original sometimes in
subtle ways okay a couple of things just
vanished outright and a couple of new
things appeared so forget about the
original interface don't even go there
the problem is the early adopters
started offering advice so before you
rely on it
please check the source I have seen
published accounts of the history of
random flat-out wrong just flat-out
wrong people think that this originated
with Boost wrong it originated with me
and my colleagues and boost random
header which was written by yen's Maurer
he hardly ever gets credit for it did a
beautiful job he actually came to our
institution and spent a week with us
learning our design before he went off
and it produced the boost random header
so that's what's really the proof of
concept okay I found all kinds of
programming advice but you know written
by people who understand neither
randomness nor the header but don't know
what they don't know be careful
so I urge you look at the sources
carefully look at the dates carefully
before you rely on what you read there's
good stuff there's also a ton of bad
stuff out there here are some places
that you may want to look that play
random.org I've mentioned before there's
a recent proposal by Moritz Clem ler
that we are looking at in committee to
enhance and simplify the seating over of
random engines it's in process Melissa
O'Neill has a website
and has co-authored a proposal based on
what she did there she's a mathematician
statistician seems to know her stuff
really well I've been in touch with all
these people the news is that there is a
very good chance that in the reasonably
near future once we're done with C++ 17
we will start working on a new technical
specification for an improved random
facility for a future standard library
so in closing again quoting our friends
explicitly quoting Andre if I were a
random number I think I died and went to
heaven all right thank you all very much
I'm do we have time for questions I we
have five more minutes I'm willing if
you're willing I'm sorry I don't I
didn't see who was first let me just go
around the room sir process ID yeah
right yeah I'm not the position to make
a recommendation for you go to Melissa
O'Neill's website she has written
extensively about this so she has some
code there take a look at that as a
source of inspiration okay I'll take one
more question that I'm told there
session is officially over sorry about
that sir oh that that would take much
longer than we have time for here I'm
sorry okay let's talk privately some
other time okay all right thanks thanks
again people
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>