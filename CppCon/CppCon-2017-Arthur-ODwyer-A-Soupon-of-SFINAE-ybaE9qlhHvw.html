<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Arthur O'Dwyer “A Soupçon of SFINAE” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Arthur O'Dwyer “A Soupçon of SFINAE” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Arthur O'Dwyer “A Soupçon of SFINAE”</b></h2><h5 class="post__date">2017-10-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ybaE9qlhHvw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Hello everyone,
I'm Arthur O'Dwyer, I'm
gonna be talking today about
SFINAE, about just a
Soupcon of the SFINAE,
small quantity of it.
When I submitted this
talk, I think that the most
concrete piece of feedback I got on it
everyone was like SFINAE, that's awesome.
Can you change the title,
people aren't gonna know
what that means.
Not the SFINAE part, the other part,
the french part, yeah.
But yeah, I kept it.
So here's what we're
gonna be talking about
that basically the first half of the talk
I'm gonna introduce the general concepts
that we're talking about.
Introduce SFINAE
and talk about the three kinds of spaces
that I have on that opening slide or,
nope, not that opening slide.
Sorry, this next slide.
And then in the second case,
in the second part, I'm gonna talk about
some particular case studies
and give you some anecdotes.
So let's talk about
template meta programming.
Let's talk about writing
our own type traits.
And a way that I think about this is
that there are sort of three spaces in C++
that are all sort of
orthogonal to each other or
we can map from one to the other,
we have value space, the
space of values like 42
and true and false and hello world.
And then we have type space,
the space of int and bool
and stidstring
and true type and false type
which we're gonna talk about.
And then there's also
this sort of SFINAE space
which I'm not sure really has a name.
I'm gonna call it SFINAE
space in this talk,
where things can be
well formed or illformed
and that's the salient thing about
things and entities in this space,
is are they well formed C++
or illformed in a way
that makes them not exist,
do they exist or not.
Let me show you an example.
Here's an example of a
couple of utility classes
that are in type traits that
we're gonna be using a lot
in this talk and I'm gonna
put them on this slide
just so you see how they're implemented
because they're gonna
come up over and over
and if we don't understand
these, we're not gonna
understand anything else.
Struct integral_constant.
It's a class template
that is two parameters.
It's got type parameter
that says what is the
type of this constant
and it's got a value of that type
which I'm calling V here
and it's got a member
value that expands to V
and some other members that don't matter.
And particularly, we can
make an alias for that.
bool_constant is just an integral_constant
of some bool value
and in particular, we
have two of those that are
particularly interesting
because there are only
two values of type bool, true and false.
So I can make a bool_constant
which remember, is just,
now this is a specific class.
It's a particular class
belonging to this class template
whose value is true and
one whose value is false
and I'm gonna call those
true_type and false_type.
And so what I've done here
is basically take the values
from value space true and
false and raise them into
type space.
I now have two types,
true_type and false_type,
that in some sense
corresponds to true and false.
But there's nothing special about these
other than they got into
the standard library.
I could write this entire code again
and just change all the identifiers,
change integral_constant,
integral_constant two
and bool_constant two and true-Type two
and false_type two
and that would have the same
claim, the same dibs on
representing what is really
the correct type mapping
of true and false.
So there's nothing magic
about true and false,
true_type and false_type,
other than that we've
by convention decided
that's the true_type and the false_type
and the things we're gonna
use when we want to take
the values true and false and raise them
from Boolean values into types.
And so I'm gonna use a
lot of these when I define
type traits like this here.
We're not using SFINAE yet.
No SFINAE yet.
Partial specialization map.
I have here a type trait
which I'm gonna call is_reference_v
and I'm gonna make this
an inline constexpr bool.
It just expands the value of
some is_reference type trait.
The is_reference here
is the old school C++ 03
type traits.
Each type trait is a
class template and we
have a base template here.
So for any T where it's not
partially or totally specialized,
is_reference of T is gonna
be inheriting from false_type
which means about,
it's gonna have a member named value
which it inherited from false_type
and that value's gonna be false.
And I'm gonna make two
partial specializations.
One for T ref, one for T ref ref
and both of those I'm
gonna say are true_type.
So now when I ask the compiler,
I say I would like to know
what is is_reference_v
of int ref,
it goes and says ah, well that's gonna be
is_reference of int ref, co
and co in value and int ref
and it's gonna do a little
bit of pattern matching
on int ref and it's
gonna see which of these
is the best match for it.
Is it T ref?
If I have int ref,
does that look like a T ref or some T?
Yeah, T could be int, okay.
Is it T ref ref?
Well, T could actually
in that case be T ref ref
but we're not gonna use that,
there's a better match with T ref.
And if there were no match that made sense
we would just fall back
to the base template.
In this case we don't fall
back to the base template,
the partial specialization
for T ref looks great so
this is true.
In this case, int doesn't look like T ref
and int doesn't look like T ref ref,
so we fall back to the base
template and we get false_type.
Alright.
And we don't have to just have
things that are boolean-ish
that return true and false,
we can return other types as well.
So here's remove_reference.
Looks exactly the same as the last slide
except that we've
changed that from having,
from being true_type
or false_type to having
a member type def named type,
which is either the removal
of the reference qualifiers
from T or T itself.
So again, in int ref looks like T ref,
so type will be T which
is deduced to be int
or if we give it plain old int
it doesn't look like either
the partial specializations
we'll take the base.
The compiler is looking to see
which partial specialization
looks like a good match
and if it doesn't find
when it will use the base template.
Now what happens
if we try the opposite operations.
So not removing the reference
but adding reference.
Here we have add_lvalue_reference,
you can make an
add_rvalue_referernce as well.
Here, it seems like we don't really need
partial specializations.
All we do is, we take the
T that the user gave us
and we add a single ampersand
to it and it all worked great.
And some people in the
audience might be thinking
well this doesn't really look great
and that's because you don't
know reference collapsing
so go watch my talk from last year.
Reference collapsing is not a problem.
But there is a problem.
And the problem with this is void.
I put void in here and I
say I would like to know
what do I get when I
add an L value reference
to the type void?
And that should be a void
ref but that doesn't exist.
So that is ill formed.
And that means the compiler
gives us a hard error
and therefore it doesn't compile.
So if we want this type trade,
add_lvalue_reference_t of
void to be well formed,
we have to do something special.
Does that make sense, that
we can't make a void ref,
we make a void star
but not a void ref okay
that's like the only type
where you can't do that.
Every other type I think you
can make a ref but not void.
So if you ever wanna know
if something is void,
now you know how to do it.
Alright so we could do
something like this.
We can use partial specializations here.
We can say add L value reference
has a base template that just adds a ref.
But then we're gonna
partially specialize it
so if someone gives us
something that looks like void
maybe with some CB qualifiers on it,
we'll pick up the partial specialization
and we'll just say well
when you try to add
an L value reference to void you get void,
when you try to add const void
you get const void and so on.
This actually works.
But it is pretty tedious, and
it's not really future proof,
it's kind of weird that
void is the only type
where you can't make a ref to it already
and maybe three years from now
there'll be another type
like that, unlikely,
but it could happen,
rules sometimes change.
And what we really want is
something where we can ask the
compiler, the compiler knows,
'cause it gave us the
error in the first place
and said you couldn't do this.
So it knows whether it's okay
to put a ref on a type or not.
Can we just ask it somehow?
Would this be well formed?
Can we ask questions about SFINAE space,
about well formed versus ill formed?
Turns out we can.
Let's do this.
There's a bit of code on this slide.
So here I have a base
template called ALR_impl
and it takes now two template parameters.
And if you're reading ahead,
yes this is more complicated
than it needs to be.
T and something I'm gonna call enable.
And I'm gonna partially specialize it
for the case where T is deduced
and enable is remove_reference_t of T ref.
So when this pattern is the best match
for the things that the
user actually gave us,
we're gonna use the partial
specialization there.
So let's see what happens when we say
add_lvalue_reference of int.
add_lvalue_reference of int is going to be
ALR_impl of int comma
remove_reference_t of int.
Well this is just int.
So we have ALR_impl of int comma int.
And that is ALR_impl of int comma
remove_reference_t of int ref, yeah,
remove_reference_t of
int ref is actually int,
that checks out, the partial
specialization is a match,
we always prefer to use
a partial specialization
over the base template if we can
so we'll deduce T as int
and we have type be int ref,
which is what we want, it added a ref.
Skipping down to the last one though,
add_lvalue_reference of void,
here remove_reference_t
of void is just void,
that's not a problem,
so we have void and void
and here we look at the
partial specialization again
and we have ALR_impl of
void comma remove_reference_t of void ref.
Now is this partial specialization
a good match for void and void?
Well void is a great match for
void on the first parameter
but on the second parameter
we're trying to match
void to this thing that's spelled
remove_reference_t of void ref.
And that's ill formed,
that's not even a thing.
So no that's not a good match
but not even a thing is not a good match.
So no, don't use the
partial specialization,
we fall back to the base template
and we have using type equals
T, using type equals void.
So were those the right thing?
So yeah here this enable is indicating
that the thing that would go there,
it wasn't even ill formed,
we'll fall back to
using the base template.
Alright but this is really complicated,
like we're implementing add reference
in terms of remove reference,
we can actually do a little bit better.
What's it say, when we want
to use the specialization,
the bolded expressions in
the partial specialization
and in the point of use in the call site
have to evaluate to the same type.
So the remove_reference_t of T
and the remove_reference_t of T ref
have to come out to be the same thing
then we'll use the partial specialization,
if they don't come out
to be the same thing
we use the base template.
Alright but can we devise
a simpler pair of type expressions?
The type expression in
the partial specialization
has to be ill formed exactly
when T ref is ill formed,
otherwise it has to
match the concrete type
used at the point of use exactly.
And so we had a problem there
that figuring out this pair of types
where one of them has to be ill formed
exactly when the other one is
and otherwise they have to
match exactly was complicated.
We would like a simpler
type expression for this.
And we can get it, we use void_t.
So up at the top of the
slide, this is new in 17,
you can write it yourself
and it looks just like this,
there is no code omitted here,
those are literal dot dot dots.
Void_t is just a class template
that takes any number
of types and it is void,
it's an alias for void.
So now what I've got here is
add_lvalue_reference is
ALR_impl of T comma void.
So now I've taken my
remove_reference_t of T
and I've replaced it with just void.
So this is well formed.
Up here in my partial specialization,
I've got void_t of T ref.
Now this involves T ref
so it's not gonna be well formed
if T ref is not well formed.
So if T is void,
this partial specialization
is basically gonna disappear,
it's not going to participate,
it's not gonna be a good match
because it's gonna be ill formed.
And then I have my base
template, same as always.
I'm gonna go on through this.
Well once I have this void_t
is now a tool for really
stamping out these,
just mass producing these type trades.
It becomes very easy to write a type trade
without having to really think about,
without having to think too much about
the particular gymnastics
that you have to do to
make something ill formed.
I can just say for example,
here is add_lvalue_reference,
which we saw before
and it has that same form of T comma void,
and up here in the partial specialization
I have void_t of T ref
because that's the thing
I'm interested in the well formedness of
so I sort of test it right there
and then I use it and otherwise
I'm gonna fall back to T.
I can add_rvalue_reference,
that looks exactly the same,
I just say T ref ref in two places.
I can say add_pointer,
that looks exactly the same
except I say T star in two places.
So this is easy for really stamping out,
mass producing these type
trades with very little code.
But what if the thing
that we want to know if it's ill formed,
we wanna do something based on
the ill formed or well formedness of it,
what if that thing is not
a type expression like T ref or T star,
what if it's a value space expression?
Like A equals B or the
ability to construct something
or static cast something.
So we add another function.
We add declval.
Declval is a function
whose declaration exists
but whose definition doesn't
because we don't need it.
We're only ever gonna call it
in the context of something like decltype.
But we're not going to
actually evaluate it,
we're not gonna need to know its body,
we just need to know what does it return
and what it returns is
something of type T.
And we use it like this.
Here I have a type alias,
a template type alias for
the result of an assignment
of something of type U
to something of type T.
I'm gonna say let's suppose
that I had something of type U
and let me just suppose
I had something of type T
and let me do the assignment from U to T.
And that let me just suppose part is
what a declval is doing.
It means that I don't actually have to say
how I would get something of type T,
I don't have to say
well what if I did T
with like curly braces,
because T might not be
default instructable.
I'm leaving out the details
of where that T comes from,
I'm just saying
let's suppose I had a thing
called declval that gave me a T.
Now I don't have to worry about that,
I just care about this
assignment expression,
what is the type of that
assignment expression?
And in this case we see that
it tells me the right answer
when there is an answer
but when the assignment
would be ill formed
such as trying to assign
an int star into an int,
then I have a problem, I've said
I want the decltype of this thing
but that's ill formed so
I gotta compiler error.
So I can use SFINAE again,
I can use a thing called
expression SFINAE.
I've heard that Visual Studio
has historically had
trouble with this thing,
but I've tested this code,
even MSVC is happy with
this code we've got here.
We've got a type trade,
it's called is_assignable,
it's gonna return either
true type or false type
and I'm gonna do the same thing
where I have a point of use
for this is_assignable_impl,
and I have base template and
the partial specialization.
And the base template just says
by default I'm gonna say
no it's not assignable
and in the partial specialization,
I'm gonna have a template parameter
and that template parameter
is going to come out to void
but it's going to come
out to void in a way
that depends on the well formedness
of declval T equals
declval U of the assignment
that I'm interested in
the well formedness of.
And in that case
if this partial
specialization is well formed
it will definitely come out to U void
which is what I put in and so
it will be a very good match
and so it will get
selected and we'll get true
and if it's not well formed
then we'll have no choice
but to use the base template
and we'll get false.
So again I've taken the well
formedness, ill formedness
of this expression and
I've managed to sort of
project it into value space,
well really the type space here
where I'm getting out
true type or false type,
but I can take that
and project it into value
space and get true or false.
So I'm taking the well
formedness or ill formedness
and projecting it into
a space I can work with
without having to worry about
getting compiler errors.
Just about testing booleans.
Now I used the little
weird expression here
where I just took the expression
and cast it to void and
flipped the decltype of that,
there has to be a decltype
in there somewhere,
'cause we got an expression
and we wanna get a type,
but yeah I could use any
of these formulations
there at the bottom with
the expression factored out.
And they're all about the same length
and I've been tending
to use the shorter one.
Alright so now we have this decl type,
we have the idea of expression SFINAE
and we can start mass producing things.
We can mass produce,
here's is_static_castable,
I wish this were in the
standard, I always write it.
Is_static_castable just says
can I static cast from T to U?
I can stamp that out.
I could stamp out is_polymorphic,
a type is polymorphic if and only if
dynamic_cast works on it.
So that's how you tell if
something's polymorphic,
you just try to dynamic cast it.
But you do it in a way where
when it fails you don't
get a compiler error,
you just get false type,
you get the base template.
Let's see and in this case
you'll notice I've actually,
I'm using void star and void star
'cause I already know I'm
casting it to void star,
I don't need to further
then cast it to void.
Here's is_constructable,
can I construct the T from a bunch of Us,
that's a variatic, they're
variatic params there
used as a pack of types,
not a problem, works great.
Is_nothrow_constructable,
exactly the same as the last slide,
it SFINAEs under the same conditions,
the partial specialization
becomes ill formed
and I fall back to the base template
under the same condition
but even when we select the
partial specialization here,
I then actually want it
to sometimes be true
and sometimes be false.
So the stuff on the right
hand side of the colon here
is now coming out to
true type or false type
based on the no exceptness
of this expression.
So that's no problem either.
Alright, new topic.
Conditional_t.
Conditional_t is like
the ternary operator for type expressions.
Like the question mark.
It takes two types, T and F
and it produces one or another of them
based on boolean condition.
Now just like the ternary operator,
if you put in something ill formed,
the whole thing becomes ill formed,
you can't compile it
unless you know what all the pieces mean,
if one of them is ill formed,
the whole thing is ill formed.
So now what if we just
simplify this a little bit
and we just cross out the type F there
and simplify this down?
We get something called enable_if_t.
This looks very similar,
let me go back to here,
we're just taking out class
F through all of this.
We just keep the bool, we keep
the T, we just killed the F.
And that means
we also killed the type alias
for type in the false case.
Then we end up with this,
enable_if_t takes a well formed type T
which defaults to void but nevermind that,
and produces either T
or something ill formed
depending on its boolean argument.
Either T which is well formed,
I hope it's well formed,
or produces something ill formed,
something that doesn't exist.
So this is actually a way of
going back the other direction.
We saw partial specialization
as a way to go from
something which might or
might not be ill formed
to a boolean, now we're taking a boolean B
and we're going backward
to say if the bool is true,
I want this expression to be well formed,
if it's false, I want this
expression to be ill formed,
this type expression to be ill formed.
And I like to have this little
convenience type def here,
bool_if_t where the default enable_if_t
is more like void_if_t
but I find it useful to be able
to get values of this type.
Somehow sometimes we'll see that NE
when we get to the anecdotes.
Alright, so as I just alluded to,
now we've gone in both directions.
If we have a boolean that
we know is well formed
it's either true or false
and we want to map it
into the SFINAE space
of well formed or ill formed
that we say enable_if_t B,
and that will either void or ill formed.
If we have a value expression
that might be ill formed
and we want to project its well formedness
into a boolean true or false,
then we go the other way,
the first step is we
make sure that we have
either void or ill formed,
and then we use a partial
specialization here
to turn that back into true and false.
And we can just go back and forth
and back and forth if we want to.
So now we know how to go
both directions, value space,
type space, the SFINAE space,
the type space, the value space.
I went through that real fast,
are there any questions about this part?
Awesome.
Let me catch up to my notes here.
Alright.
Let's talk about some case
studies, some anecdotes,
some things I have found
to work or not work
and what I did about them.
So here's case study number one.
SFINAE away a function that
is not currently a template.
So here's my motivation.
Here's my motivation
for this so in C++ 17,
there's a new header
called memory resource
and in it it has a couple of things
in the std PMR namespace.
I assume by this point at CPP Con
you've all seen at least
one talk about unallocators.
And if you haven't
I don't know where you've
been all this time.
So std PMR has this class
called memory resource,
it's a classically polymorphic interface
to an allocator or to a heap.
And there's this function
get_default_resource
that gets you the global heap
which is terrible by the way,
global variables suck, don't use them.
And there's this template
class polymorphic allocator
and it has a pointer to a memory resource
and it has a default constructor
that gets the default resource, okay.
Who knows what this is?
(audience member speaking off microphone)
This is a fancy pointer.
(laughter)
And I'm not the first one
at this conference to use that joke,
I was highly disappointed
I was beaten to it.
Alright so let's fancy
pointer all the things.
So what a fancy pointer is
it's a pointer like type,
behaves like a pointer, you can star it,
you can plus plus it, but
it's not a native pointer,
so and C++ 11 allocators
are allowed to have
pointer types that are fancy pointers
but PMR allocators are
not but we can add it,
it's easy, let's just do it.
So here I have a fancy_memory_resource
and it's templated on
its void pointer type.
It might be void star, it
might be something else.
I have a fancy_polymorphic_allocator
templated on T
it allocates Ts and it also
has the same void pointer
as the fancy memory
resource contained by it.
And I can make type defs then
for polymorphic_allocator
and for memory_resource
but now I also can make type
defs for shared memory resource
and shared memory allocator coming from
boost interprocess offset pointer.
And nevermind what that
is, doesn't matter.
But now we have a little bit of trouble.
Now in our fancy polymorphic allocator,
which is now templated on
the fancy pointer type,
we now have a pointer to
a fancy memory resource
but our default constructor
is still trying to initialize that pointer
from get_default_resource
which is this global function
that returns the memory resource stock.
And that works great as long
as you don't use fancy pointers
like much of the STL.
But in this case if you
try to instantiate it,
if you try to instantiate
the shmem allocator we
saw on the last slide
that tries to use boost offset
pointers, you have a problem,
you can't convert get_default_resource,
this fancy memory resource
which is a plain memory resource
to a pointer to a fancy memory resource.
Which is okay.
I'm actually happy about this
because I don't like that global variable
and I do actually want it to go away,
I'm totally happy to say the user of this
if they want fancy pointers
then their allocators will
not be default constructable.
That's okay, you don't want
a default constructable
polymorphic allocator,
doesn't make sense.
So I want this constructor,
this default constructor to just go away.
I don't want to see it
unless that expression
would be well formed.
And there are some usual tricks
which I'm not even gonna
talk about here such as
you can put the SFINAE on the
return type of the function,
but you don't have a
return type in this case,
you can make it an argument type
but there's a default constructor,
there's no argument types to put it on.
You can make it a template parameter
but this isn't a template.
So what do we do?
Well we can just make it a template.
So we make it a template.
So here I have my same default constructor
only now it's a function template.
And it takes one argument
and that argument's gonna
default to enable_if_t
if void pointer is the same
as the native void pointer,
then I would let this
be enabled and otherwise
I would like that default
argument to be ill formed
in which case you will not be
able to call this function.
'Cause there's no way to give
it a non default argument,
it's a constructor.
And so I want it to be
ill formed, so I try this,
and I try compiling it,
and it doesn't work,
and Clang gives me a very
helpful error message that says
I see you tried to use enable_if,
enable_if cannot be used to
disable this declaration.
Doesn't tell me really
what to do about it,
just says I see what you're trying to do,
and I'm not letting you.
(laughter)
Alright, let me catch
up to my notes again.
So what's going on here?
Why is it telling me that
it can't do what I asked?
Well, turns out doesn't work
because there's nothing
in the enable_if_t,
which you can see under the big X here,
that depends on the point of use.
And the compiler when it's
trying to figure things out
will generally be as eager as possible
so things like template default arguments,
the compiler will try to
resolve that if it can,
at the point of the declaration.
And it won't wait until the point of use
unless there's some reason it needs to
like if that expression,
enable_if_t is is_same_v
void pointer void star,
if that depended on an argument
to another template argument, for example,
then it would have to wait obviously
until it knew that argument
but in this case it knows what
void pointer is at the time
that it starts instantiating
the whole class body.
It says oh a void pointer,
that's boost interprocess
offset pointer avoid
and so it is not the same as void star
and so you want the default
to be enable_if_t of false
oh that doesn't exist
and it throws an error.
But we can do a mechanical transformation,
to kind of trick the
compiler a little bit.
This is the first trick here.
We make a bool, we just add
another template parameter,
bool B and we initialize
it to that whole condition
and then we just have
our same little class at the end there,
class equals enable_if_t.
And this tricks the compiler.
The compiler can now do
all of the same evaluation
it was doing before,
it can figure out that this
bool B defaults to false.
And then it can figure out
that this class in that case
would default to enable_if_t of false
if you pass the default
through both arguments.
But the compiler doesn't
know C++ as well as you or I,
it doesn't know that you can't pass
non default template
arguments to a constructor.
So when it sees bool,
bool B defaults to false but
the user might pass true.
They can't, but it doesn't know that.
So it can't actually
evaluate enable_if_t B
until the point of use
at which point it will find out
whether the user is actually
using the default false
or whether the user has figured out
how to shoehorn a true in there
which again they can't do.
And even if they could
we're not really concerned with
users misusing our library.
So there we go, that was the trick.
And it works.
So now we can instantiate our
fancy polymorphic allocator,
it no longer throws a hard
error when we do that.
And it does throw a fairly nice error
when we try to default
construct one of these things
which we have now made no
longer default constructable.
I say fairly nice, it's not really.
The error message from Clang says
requirement false was not satisfied.
But we can actually make it nicer.
So we can start with,
this is what we had
before that was too eager,
it evaluated eagerly, it was ill formed,
and we got a hard error
when we tried to make that declaration.
Here's the trick I just showed
where we pull out this entire condition,
we take the condition out,
we name it B, enable_if_t B,
that gives us requirement
false was not satisfied
which is true but not helpful.
Another thing we could do is
we could leave the condition as it is
and just and it with bool
B which defaults to true.
Again, the compiler has to
wait until the point of use
to find out whether the
user might have somehow
managed to pass in false for B.
So this also works.
Or probably the best
trick that I'm aware of is
make one dummy parameter of just
one of the template type
parameters you're gonna be using,
in this case I say void pointer,
that's the only one I am using
but if i had like T, U, V
I would only have to copy one of them.
Name it the same thing
with a little underscore
and use the underscore one down here.
This gives me a fairly
nice error of course
in this case I'm using boost
interprocess offset pointer
so the error is like crazy long
but it's actually telling me
what the thing is that
wasn't satisfied there.
Yeah.
(audience member speaking off microphone)
Would a template deduction guide
alter anything about what's going on here?
I've no idea.
(audience member speaking off microphone)
It is certainly written into
the rules of the language
that yes this trick works,
it's not like a missed optimization,
I think it's a little
quirk of the language
that even though there's no
way to express the passing of
non default template
arguments to a constructor,
yeah the compiler is still required
to act as if there were some such way.
(audience member speaking off microphone)
Can you call the constructor directly?
I mean you can use placement new
but I think that has the same problem
otherwise no you can't get a,
a constructor is not a
function or anything.
No you can't get a function pointer do it.
Anyway.
I'm gonna go on because we have,
the moral of this story is
if you're running into a problem
where something is happening
too eagerly, split it up,
add a level of indirection
that solves all the problems.
Pull out just a bit of
it and by doing that
you can get the compiler to sort of
wait until the point of use.
Case study two, conditional explicit.
Here is motivation, we're
sticking with fancy pointers,
I was looking into fancy
pointers a lot lately.
So here's a fancy pointer, this
is now boost offset pointer,
it has a bunch of stuff
I'm not showing here.
This is also completely irrelevant
how these things are implemented.
But the interesting thing
is that what I want is
just like a regular T star
I would like to have a
conversion from T star to U star
or in this case offset putter
of T to offset putter of U.
I'd like to have that conversion exist
whenever those pointers
would be convertible
but I don't just wanna
have implicit conversions
between all possible
kinds of offset putters
'cause that would let you cast away const,
it would let you do all
sorts of stuff implicitly
and I don't want that.
So I would like to have something
which is always available
but sometimes you have
to explicitly say it,
sometimes it's an explicit constructor
and sometimes it's non explicit.
And another place this comes up
by the way is also in
optional and probably tuple
and some other utility types like that
have conditionally explicit constructors.
So let's see so our first
attempt, here's our first attempt.
I have offset putter and I have
a non explicit constructor,
if U star is implicitly
convertible to T star,
and I have an explicit constructor,
if U star is convertible to
T star with a static cast.
And we try to compile
this and it doesn't work.
Because we just put the
constraint in the comment.
That's not gonna work, we
actually have to write code.
Constructor cannot be redeclared,
okay so it's treating these
as the same constructor,
just one of them has explicit
and the other one doesn't
but it's saying you're trying
to redeclare the constructor.
Not only that you're
trying to redeclare it
with a slightly different signature
which is certainly not gonna work.
Alright so let's put in code.
We do the same thing that we did before,
we've now figured out that
if we want to constrain a constructor
we just make it a template
and here it already was a template
and in fact the condition,
the enable if condition that
we're trying to use here
is dependent upon U which is not known
until the point of use
so we're following all the rules
and we try to compile this
and the error message has not changed.
Alright so the answer here
is that the SFINAE that
we've been using here
is only in the default
template type argument.
The default argument to
template type parameter.
So if we forget about
the value of the default
argument for the moment,
our signatures still
look very much the same.
We've got a constructor
which is a template that takes
two template type parameters,
one named U and one unnamed
and it has some default
but we don't care about that right now.
And then it has these arguments,
const offset putter UF
and then the other one
looks exactly the same,
it takes two template parameters
and we don't care about
what the default is.
So we give the second class parameter
a new default value in
the second declaration.
But that's just a violation
of the one definition rule,
that's not actually a
change in the signature
of the fundamental
entitiness of this template.
What we want here is to have
not just our repetition
of the declaration,
we actually need to have
two different templates.
And so we need to make sure
that they are really two
separate entities somehow.
One way we could do that is
we could just add a dummy parameter.
Now they have different parameter lists,
one of them takes an
offset putter F and an int,
the other one takes an
offset putter F and a double,
they're now different and
it's totally fine to do this,
this works, but it's not a great idea.
At least I don't like it,
philosophically it doesn't seem right
because we have to invent
this new ad hoc tag type
for each mutually exclusive overload
and also because it involves
default function arguments
which are awful, please don't use them.
So we can do better.
A better but subtler solution is to change
not the function argument list
or the function parameter list
but the template parameter list.
We need to make it so that
these template parameter
lists are somehow different,
they can't just be like class and class,
they have to be different somehow.
And this is where I bring in my bool_if_t.
So here, this first one
has the class U as usual
and then it has a parameter of this type.
Now this type depends on U
so it's not gonna be known
until point of use so it
can't be evaluated eagerly,
we don't have to worry about that
but at the point of use
the compiler is gonna be
trying to make up the overload set,
figure out which constructors
are relevant to this use.
And it's gonna say okay
I know U star and T star
at this point so if they're convertible,
let's say that they are
not convertible at all.
In that case,
is_convertible_v of U
star T star will be false
and bool_if_t of false is ill formed.
So here we have a constructor template
which takes one type parameter
and one non type parameter of
oh yeah that type is
ill formed, nevermind,
that's not gonna be a good match,
if it's ill formed it's
definitely not a good match
and so we'll just ignore this one.
If it is convertible this one will be fine
and it will take a template
type parameter plus U
and it will take a bool argument
'cause bool_if_t of true is
bool and the bool will be true,
will default to true not that it matters.
And in this case if it is static castable
but not convertible, then
this one will take a bool
and the other one will be ill formed.
And so this ends up working.
At the point of use the compiler
computes the overload set
which evaluates bool_if_t of
each of these expressions,
these expressions are mutually
exclusive which is important,
they are never both be
true at the same time
and we can tell that because
one says is convertible
and the other one says not is convertible.
So they're mutually exclusive
and so only at most
one of them can be true
and so we don't have an ambiguity anymore.
So to kick an overload
out of your overload set,
we need to not only have
something ill formed somewhere in there
but it has to be somewhere in there
that's gonna affect the
fundamental name of that entity,
its signature somehow.
It's not enough to put
in a default argument
or somewhere else that is not
contributing in some way to,
I think of it as name angling,
I had a slide in here saying
think about name angling
and then I thought that's
just even more confusing,
don't think about name angling.
Problematic parameter types.
Who can guess what
the motivation for this
example's gonna be?
It's fancy pointers.
Fancy pointers have this
thing called pointer_traits,
it's in the library, and
actually in this case
I'm interested less in
the fancy pointer one
as just the pointer traits for
regular old native pointers.
We have a base template
and it has some stuff
in it but we don't care.
The base template, let's
just assume that it exists.
But there's a partial
specialization for regular pointers,
T star, and pointer_traits,
you can tell by the
name is a traits class,
it's a place where the library can sort of
hang a bunch of traits,
relevant details about a class
without having to reopen that
class and stick them in there
because you might not always
have access to that class,
where that class might not
exist, in this case T star,
is not a class, it's a primitive type
and so if we wanted to ask T star
hey what is your element type
we can't ask a member type def of T star
it doesn't have member type
defs it's a pointer type.
But we can ask pointer_traits of
T star colon colon element type
and it will tell us oh
the element type is T.
So there's this partial
specialization in the library
and it has the pointer type itself,
it has the type of the
thing it pointed to,
it has what you get when you
subtract two of them, it has,
this is cool, the ability to
rebind a pointer type to say
I have this kind of pointer
but to a different type,
that's a alias template there.
And then it also has this other function
that's new in 17 I
think called pointer_to.
Pointer_to takes the actual
native address of an object
and gives you back a pointer
of this type to that object.
And it just returns, in this case
it just returns the address of R
but if we were trying to get let's say
a boost interprocess offset
putter to a certain object,
that would involve constructing
an offset putter somehow.
So in this case, I'm
only interested in this,
does anyone see the problem with this yet?
Problem's on the slide.
Seen it before.
(audience member speaking off microphone)
T ref, T ref, yes, the
problem is void always,
always the problem is void ref.
So a pointer-trait's a void star.
If I try to instantiate that class
it turns out I cannot instantiate,
I get a hard compiler
error when it gets down to
trying to make the static
member function pointer_to
because pointer_to wants to
take a parameter type void ref.
Alright.
Right cannot form a reference to void.
Alright what do we do?
Well we follow our recipe.
We're gonna SFINAE away
the non template function,
this is a non template function
so step one is make it a template.
Step two is we wanna SFINAE it
away when not is void_v of T.
We want to SFINAE away when T
is void, we want it to exist,
we want it to be enabled
when T is not void,
but we know that T is known already
at the point of the declaration,
we need to trick the compiler into
waiting until the point of use
so we add our level of indirection,
we make this bool B
and we've now followed all of
the guidelines we've learned
and we've done this great
and the compiler error
message doesn't change,
it still says cannot
form a reference to void.
So it doesn't work because
the function's signature
is also being eagerly evaluated.
Let's go back here.
So this T ref right here
is being eagerly evaluated.
So regardless of all the
stuff in the template
that cannot be eagerly evaluated,
this can be and it evaluates to void ref
which is ill formed so we
get a hard compiler error.
Alright so let's try this.
We're gonna say
okay well here's the first
thing that jumps to mind,
at this point we're just
banging on the keyboard, right?
So I'm gonna add another parameter,
class TR and I'm gonna say look if--
I'm gonna take a parameter now of type TR.
So ha ha I've now made it
so you can't deduce
that until point of use.
Because that depends on B
which depends on the default arguments
so okay and it's only
gonna be T ref if not B.
I try this and I get the exact same error.
Exact same error, this
error is not changing.
It's not being more helpful,
it's not being less helpful,
but it's not changing,
can't form a reference to void
and that's because
right here I have T ref.
The compiler can see
this, it knows what T is.
T is void, T ref is void ref,
that's ill formed, that throws an error.
This is the same thing that
would happen with conditional_t.
Conditional_t takes the bool
and the type T and type F
and they both need to be well formed
and if one of them is ill formed
then the whole thing is ill formed
similarly with enable_if_t.
It takes a bool and a single
T and if that T is ill formed,
the whole thing is ill formed,
so the whole thing here is
ill formed, still not working.
Alright here's what we're gonna do.
We're gonna take the T ref
and we're gonna add a
layer of indirection,
I'm gonna split it up, ha ha,
there we go, suck it compiler.
Got enable_if_t not B of T
and now you don't know
what that type is compiler,
you don't know enable_if_t of some stuff,
you can't compute that,
but whatever that is,
I'm gonna take a ref to it.
So now you definitely can't evaluate that
until the point of use.
And we do this
and finally the compiler
is happy and it compiles.
When we run our code it segfaults.
(laughter)
We lost track of what
we were actually doing
other than getting the thing to compile.
Now when we have pointer_traits
of a non void pointer type
and we try to call pointer_to
on the address of a variable
like X, we get a segfault.
We'd forgotten to pay attention
to the meaning of the
syntax we were using.
We provided this default,
enable_if_t of not B comma T ref for TR.
But template defaults are only used
if we can't deduce that
argument from the parameter list
which in this case we
certainly can right here.
If we pass in a X, let's say X is an int,
what's TR gonna be?
It's gonna be an int.
And we're gonna return
the address of that int
which is a argument, which
is in the parameter slot
and it's gonna be gone
returning a danging pointer,
we're certainly not returning
the point of the original X,
this TR is gonna deduce to int,
we wanted it to be int ref,
it would've been int ref
if you used the default
but it was deduced so it's int.
So what we need is not really
this new template parameter
although we could make that work actually
but we need not a new template parameter,
we need a new constraint on
the existing function parameter
so that the existing function parameter
can match either T ref or ill formed.
So we could do something like this.
So here again enable_if_t of not B comma T
is something that cannot
be eagerly evaluated
until we know what B is
and we're not gonna know what
B is until our point of use.
And then we're gonna take the ref of that
and now this whole thing,
this is a concrete type,
it depends on B and T.
It doesn't depend on anything
the user is passing into us
so it's not gonna be deduced,
it's gonna evaluate to
something like int ref
or it's going to evaluate
to nothing at all,
it's gonna evaluate to avoid
ref which is ill formed
and so you're not gonna be
able to call pointer_to.
And this works and it
has the right behavior.
When T is not void the
call site of pointer_to X
sees that B was not provided
so it uses B equals false
because T is not void and
enable_if_t of not false comma T
is just T so T ref R, and
we get the right thing.
When T is void then number
one there are no call sites
'cause no one can ever
pass in a reference to void
and we're actually done.
As long as this doesn't cause
problems, which it doesn't.
So lesson three is don't lose sight
of the meaning of your code
when you're trying to get it to compile.
(audience member speaking off microphone)
In this slide you still need
the default template parameter.
(audience member speaking off microphone)
Yes you do still need it
because if you got rid of bool B
and you moved this void VT down into here
then this whole expression
would depend only on T
which we know you know and when T is void
this will be ill formed
we'll be back where we were.
(audience member speaking off microphone)
At that point it wouldn't
be a template function
which would be fine,
we actually don't want it
to be a template function
but if we want it to SFINAE away
we have to make it a template.
(audience member speaking off microphone)
Right.
(audience member speaking off microphone)
I strongly suspect
you can make it even
simpler than this actually
I think you can just say
template class U equals
T pointer_to U ref of R
and that probably does the same thing but,
one more question then we gotta go on.
(audience member speaking off microphone)
Oh his question was can you
rewrite this in some way
and my answer was I'm not
gonna think about that
but yes you can rewrite it differently.
Yeah.
So even as you're trying to
do all these SFINAE tricks
just to get the thing to compile,
remember to go back after it compiles
and actually look at the code
and see whether it does the
thing that you expected it to do
in the first place.
Sometimes you get a
segfault and then it's very,
it's nice that the computer reminds you
to go back and look at your work
but even when it doesn't segfault
you should still do that.
Alright, does anyone know what this is?
(audience member speaking off microphone)
This is four pugs in
aviator goggles and top hats
and they're smoking cigarettes.
I didn't actually think
we'd have time for this
but we have ten more minutes
so I'm gonna try to get through this.
Ton of stuff promised in the
abstract, didn't make it in.
Let's suppose, so in our second test case
we saw that we needed the
conditionally explicit thing
where we had two mutually exclusive cases,
either it was convertible
or it wasn't convertible,
we want it to be one thing
or the other but never both.
What if our dispatch cases
are not mutually exclusive?
So here's an example from the STL,
no more fancy pointers at the moment,
we've got here a distance, std distance,
it takes two iterators and
tells you last minus first.
But you can only actually
express last minus first
if they're random access iterators.
Luckily we have this thing
called iterator category,
and so we can say tag
dispatch on iterator category,
we go to random access iterator tag
or if it's not a random
access iterator tag,
at least it will be an input iterator tag,
technically maybe we need
one for output iterator too,
I'm not sure, go see last year's talk.
But the idea is that we have one overload,
these are no longer
partial specializations,
they're separate function overloads,
they have different argument types.
But one of them
takes a very very derived class
random access iterator tag
and the other one takes a base class
and so statically overload
resolution will prefer
if it can see that
you're passing something
of that very very derived tag type.
It will call if we want expecting
the very very derived type
and if you're doing something
a little less derived,
then you'll have to call the one
that takes the base tag type.
The first overload match is better
because the required
conversions base class
is fewer levels deep.
So this works great if
you have this hierarchy
that's already been made for
you like iterator category.
(audience member speaking off microphone)
That bottom should be
using iterator traits
but there wasn't enough room on the slide.
But yes straights classes.
They appear everywhere.
Alright so this works great
if you have your iterator
category imposed on you
by the library but what
if you were the one
making up the rules?
Here's an example of me
trying to make up the rules.
Here I make my own tag types.
I have this in the header,
I called priority_tag.
Priority_tag zero is
just an empty tag type.
And priority_tag one is
just an empty tag type
that happens to inherit
from priority_tag zero.
And so on all the way up as many as I need
and I just make a template.
And then however many cases I have,
I have this priority_tag in
this case I own two cases
so I just have priority_tag one and zero.
And I dispatch, I go up here if I can,
I'm passing something
of the most derived type
so I'm going to prefer this overload.
But I'm gonna prefer this
overload only if it exists.
And now this is a template
and it's got this default argument
which may or may not be well formed.
I've taken the type trait
is_random_access_iterator_v of it,
that's gonna be true or
false in value space.
I use enable_if_t to map
that into SFINAE space,
this default is now ill
formed or well formed.
If it is ill formed
then this doesn't participate
in overload resolution
and so priority_tag one will have to be
cast down to the base class
and I'll get this less
specific implementation.
However, if is_random_access_iterator_v
of it is true,
then this is well formed and
of course then I will prefer it
because it is fewer levels
deep and so I will do this.
Now in this case I'm
just sort of duplicating,
I'm really going back and
forth and back and forth
between value space and SFINAE space
'cause I'm duplicating work
iterator categories done for you
this is more useful in cases
where there's no
hierarchy provided at all,
I don't have this random
access iterator tag business.
In this case I have allocator traits,
even more traits, and
still allocator related.
And here's the implementation
of allocator_pointer
or allocator traits A colon colon pointer
so allocator_pointer_t is going to be
the decltype of what I get
when I call the function
allocator_pointer of A
and I pass in the most
derived priority tag.
So I have three different
functions allocator_pointer of A.
Three different function
template overloads here
taking different argument types.
The most specific one,
the one I would most like to pass
this particular most derived object to,
this would be a perfect
match if it existed.
But it exists only if its
return type is well formed.
So if A colon colon pointer
exists, awesome, I will use it.
If it doesn't exist,
then this one goes away,
this allocator_pointer overload goes away.
Well what's the next best match?
That one didn't work out so well
well this one is pretty good,
it's not that many levels
of casting the base,
it's just one level of casting the base
oh but it's only well
formed if A has a value type
and I can make a star of it
if the value type were a
reference that also wouldn't work.
So maybe I can use that one
and if that doesn't work,
well then I guess I
could just call allocate
and get the type back from that,
that's supposed to be a
pointer, I'll use that.
So here I have things that
may not be mutually exclusive
so I have imposed on them the ordering
I would like to use pointer if it exists,
then value type star after that,
and then I would like to use
the return type of allocate.
And if I decided that i want
to change those rules later
and maybe value type star
is more important than
pointer for some reason,
all I have to do is swap around
these priority tag numbers.
And I can add more cases and one place
that I used a lot of this
was in my dynamic cast from scratch talk,
I didn't show that code
but that code is in the repo
where there are just so many
of these different cases
and some of them take
priority over others,
they're not all mutually exclusive.
Of course if you're in 17,
this is good if you're in 14,
as most of us I think are more or less.
If you're in 17, you can use if constexpr,
you can just do something like this
and when you do that
I recommend write your own type traits
such as is_random_access_iterator,
don't mess around with
is base of random access
iterator tag nonsense,
just write something
that takes whatever question
you're interested in
in value space and just give it to me in,
or sorry in type space,
give it to me in value space
and then I can if constexpr on it.
But if you don't have this, if
you don't have if constexpr,
if you do have it it's cause
where you can just list out the cases,
if, else if, else if, else if
and it'll do the thing naturally.
If you don't have that
you can use priority tag
to get the same approach.
And I'm totally out of time.
Thank you.
(audience applauds)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>