<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lukas Bergdoll “Web | C++” (different) VIDEO AVAILABLE WITH IN SYNC SLIDES | Coder Coacher - Coaching Coders</title><meta content="Lukas Bergdoll “Web | C++” (different) VIDEO AVAILABLE WITH IN SYNC SLIDES - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Lukas Bergdoll “Web | C++” (different) VIDEO AVAILABLE WITH IN SYNC SLIDES</b></h2><h5 class="post__date">2017-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/J4_pbat8Urg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">web and C++ are not an iconic couple my
name is Lucas I know bug has full stack
software engineer at P Pro today we try
to understand a C++ fits into a modern
web service how did C++ never find
widespread adoption in the networking
segment a market dominated by C both no
js' and python essentially implement a
networking stack with c network
applications being prone to malicious
input makes this particularly ironic
given C Security track record the vast
majority of today's security breaches
boil down to someone blindly calling mem
copy the days where such thing was
purely a stylistic faux pas are truly
gone today these kinds of bugs have an
ever-increasing impact on real people's
lives we all know modern C++ tries to
address many of those historic
shortcomings surely this translates into
applications if you got questions just
raise your arm first we try to see where
C++ application makes sense then a quick
look at the client side of a web
application and finally we'll compare to
compare implementing an example servers
using popular C++ libraries I'll assume
that you have some knowledge about
networking applications and of course
the stock is no definite answer
Mellie subjective observations if all
you want to do self static content and
those five lines oops
okay those five lines of Python will
most likely be enough import HTTP server
from the standard library create a
socket socket server listening on a port
and start the event loop hosting
something like a blog does not need to
be complicated
in this talk I want to focus on web
services quoting w3c web service is a
software system designed to support
interoperable machine to machine
interaction over network
what makes web services so popular the
service is just one click away basically
everyone can use it the tools to
interact with the application installed
and widely used on the vast majority
today's consumer platforms that leads us
into web development I want to take some
time talk about advantages and
challenges of modern web development
coming from a C++ background let's talk
about advantages feature-rich ecosystem
with NPM at its backbone a variety of
tool coming from the assemble at
yourselff world that a c++ tooling the
feeling of just writing the word
debugger in your code and that followed
by a sane and intuitive debugging
experience inside your browser is a
welcome breath fresh air after years of
fighting tools wits to achieve seemingly
simple goals and all that without having
to install anything special frameworks
react angular you name it there's so
many that even sites like to do MVC
exist ok challenges given a system that
was never intended to be used in today's
manner and even less at such scale no
matter what you do at the end of the day
your tool chain will be spitting out
JavaScript that leads to a lack of
interoperability with all the languages
and tools however that might be a
completely different story once
webassembly gets dumb bindings the
neverending story of browser support
this brings us to the development cycle
after editing your source files you
compile to JavaScript our way the same
ok you compile to JavaScript avatar
ACMA script version and plane ceases the
S version usually dictates browser
support however even older browsers can
support modern features with the help of
polyfills polyfills try to emulate
missing language or library features
usually the first check if there's
native support and then use the
appropriate version of javascript you
have the unique problem you need to send
source code over a resource constraint
channel so there's a notable advantage
of shorter variable names and no white
space of course we don't want to write
source code where all variables have
single character names ok now comes the
step where we use a tool to uglify our
code the name says it all it makes our
code more ugly popular choice is ugly
Friday s epatha with the goal to produce
the shortest possible JavaScript while
it's retaining the same logic and their
github page they have an example like
the original file is 450 kilobytes and
turns into 220 kilobytes mangling
enabled gzipped original is 109
kilobytes and the minified version only
takes up 73 kilobytes and finally we
bundle the produced files this comes
down to application preference
some people like single page
applications they bundle all their logic
into a single file often called main dot
KS with this approach we can quickly
interact of the application as
navigating to a different section does
not require fetching new source code
however this quickly leads to bloated
websites with a horrendous first load
experience the average website these
days sends you more bytes source code
and you'd need for the entire doom
binary another approach is to split up
your application into a set of sections
and bundle only the code required for
each section I can help to drastically
reduce the average bandwidth usage to
give you a practical showcase of the
technology we'll be talking about let us
create a small example service
I want to focus on two major
requirements persistence user
interaction will have lasting changes
otherwise could just chip a client only
solution which could be much easier and
we'd save server costs bi-directional
communication you want to keep the user
up-to-date without requiring him to
proactively request new information ok
now comes the moment where you have to
make a leap of faith to trust me to
visit us non HTTP address ok anyone
feels like doing it ok also go there
look there we go as you can see it's a
small straw poll service and to stay
impartial I'll vote for turnip
but I'll okay that's unlucky yeah I'm
not sure what happened there see what
happens
ok so now can some of you go there and
try to vote you can see should update
automatically ok there we go that's ok
ok maybe one more vote and then we'll
continue ok so I think you get the idea
people can vote and we directly see what
happens we don't have to like this side
does not fetch new information it's the
server sending information and the site
reacting to you let's go back to
Malaysia persistence is easy as soon as
you have a server bi-directional
communication is a little trickier who
of you has heard WebSocket about
WebSockets before okay so like half the
audience nice and how many of you have
used them in applications before ok so
like that's like 10% or so now
for those new to WebSockets they are
thin wrapper around TCP introduced by
html5 of course we don't want to
reinvent the wheel ourselves we'll use a
WebSocket library rather than using one
library I want to compare three popular
open source choices beast new WebSockets
and include was we compare their
interfaces the code needed for example
service attack vectors and of course
performance if three main requirements
are a request handler each user request
should trigger a call to our function we
want to send a message back to the
client WebSocket and finally we want to
broadcast a message to all open
WebSocket connections let us start with
a batteries included it's library new
WebSockets directly provides support for
our three requirements the setup is easy
and straightforward we construct a hub
attach a request handler for bind to a
port and start the event loop each time
a user sends a message our request
handler is called with the WebSocket
itself
pointer to the message buffer plus its
size and the message opcode usually text
or binary before we continue with to
talk about serialization both the client
and server needs some kind of shared
language of course we could use Jason
that would lend itself very nicely in
the front-end JavaScript objects are
basically tracing objects however Jason
and C++ requires a library and we lack
validation not to mention performance
that's why I decided to use flatbuffers
flatbuffers is a schema based
serialization library and what makes
flatbuffers great is the virtual lack of
deserializing and serializing instead of
deserializing the message and the
message and constructing an in-memory
representation we offset jump to the
place we care about
and just read the memory compared to
Jason we can be three orders of
magnitudes faster and less memory hungry
the profits are usually used with a
schema representation a schema allows
for more efficient message encoding and
also validation all this makes for easy
out-of-the-box message validation as you
can see here however this does not
validate application logic it can tell
us if a boat is present or not it
doesn't know whether vote is in bounds
or if the client has voted already here
see the entire schema for our user
requests flatbuffers supports pods
structs enums
unions and tables in this case all we
need is a type in um representing the
request type and optionally a port back
to you have segments in order to send a
message
we need a WebSocket the message pointer
and size here wrapped with flat papa ref
and the opcode this call is synchronous
that means the function will return once
the message was sent sending a message
to every open WebSocket connection is
very similar instead of calling sent on
a WebSocket object we need to help get
default group returns a group object
representing all open connections
conveniently this group object provides
a method to broadcast messages they call
to broadcast and same this ascends
shared a same signature
finally to tie everything together
the requests which after validation will
switch based on the request type this
works given that request type is an enum
to keep things simpler we not talk about
the poll data object for now just know
it takes care of creating and managing
or flat buffer objects in case of the
pole request we send back our constant
pole object in case of a result request
it should come with a vote you try to
register the wok and give it two
callbacks the first should be triggered
if the board is invalid the second it
with what was adjusted successfully the
walrus registered successfully in our
case you want to broadcast the updated
voted rain otherwise we send an error
stating and unrecognized requests and of
course we need a client in our case a
static web application the two
requirements we have for our client our
web socket support technically not part
of any atmos crypt version yet however
has been implemented in nearly every
browser by now giving us 93 percent of
the global web browser users and we need
support for our choice of serialization
language flatbuffers currently ships
with bindings for eight languages
including Java Script okay again we will
take a look at a setup first we create a
new web socket set its binary type to
array buffer and then add our event
listeners a WebSocket connection usually
has three event types open they request
triggered once the HTTP requests upgrade
and hate handshake who are successful
message the event triggered each time
the server sends a message and close the
event triggered by either the server
sending a closed frame or a fade
ping-pong request again we switch based
on an email this time of the response
type there are three non response types
poll result and error unless there's an
error will just trigger development
object update
okay join me on a short expedition to
the land of Jason what I'll take a look
at a highly complex task of sorting an
array containing numbers okay
what does options contain now anyone
willing to guess one to ten then okay
now turns out it's one 10 2 and 21 okay
so yep
obviously sort reads numbers as strings
and compares them based on the Unicode
points okay let's give it a lambda we
want to sort right like this looks very
similar to C++ we just tell it okay
please sorta based on this rule on those
rules okay so what does it look like now
now it's either of those two depending
on your browser implementation okay the
standard saw it expects a comparison
function to turn either a positive or
negative number indicating larger or
smaller so what we need to do is
subtract the numbers from each other
that'll do the trick yes okay of course
this has historical reasons like if they
the people that are in charge of today's
standards would get to design this again
I'm pretty sure I wouldn't do this but
like you thought C++ implicit
conversions are bad yeah okay so what
does this valid piece of jeaious
evaluate to okay
forty-two no well let's find out right
okay let's yeah let's copy inside a
browser so we can open to you console
the string it's fine oh it's not really
okay
turns out you can express the entirety
of JavaScript with just six symbols okay
back to the occasionally less insane
land of C++
let us take a look at our second
high-level WebSocket library however
include us is much more than a WebSocket
library who went to Alfred's talk
earlier this week for those unfamiliar
with include OS it's a young uni Colonel
project which allows you to create
applications that are compiled into
bootable special-purpose operating
systems all the relevant pieces of the
OS aesthetically linked into your
application result can be a bootable
image of networking stack the size an
area of a megabyte at boots in
milliseconds under why someone would
want this later
first we include irrelevant OS
components Retriever reference to the OS
internal network stack attach our
request handler and bind to our port and
again start the event low this time we
have to trigger the HTTP upgrade
ourselves we try to upgrade if the
request this both get and comes from a
WebSocket
address I'm not entirely sure this is
100 like our C compliant I just saw it
on there in the example might be that
there's some edge case where this is
wrong our request handler will only be
triggered each time a connection is
established so we still need an event
handler for the client messages this is
what a simple echo server could look
like
for those of you thinking they're having
a deja vu yes
sending looks very similar to you
WebSockets interface again we write a
pointer size and opcode include s does
not have native broadcast support we
learn how to implement that once we look
at the Beast example part of the
upcoming boost versions beast is by far
the lowest level library of the three
setting up a beast server seems harmless
enough a couple of includes writing
creating and I all service subscribing
our events and starting the event loop
let's look at listener implement
implemented by us before we do that
let's Russ revisit event loops to recap
the event loop model we'll take a quick
look at a synchronous Beast example and
our top level loop each time we create a
new TCP socket accept should block until
we get a connection once we have a new
session we spawn a worker thread and
transfer ownership of the socket and you
can see it's an endless loop first we
construct the WebSocket stream by moving
in the socket then a block until the
handshake was resolved again we go into
an endless loop the read function should
block until we receive a client message
here we just echo back the message oh
okay of course we want to take advantage
of our SEOs as an interface for those of
you unfamiliar the concept of as in Ko
the core idea is rather than blocking
until now event is done to start
operation and to query the result state
usually this means that synchronization
bubbles up to some kind of event loop we
need some
loop that resumes at arbitrary points
now therefore or while are going to cut
it
what can a loop be reduced down to
switch Oh more low-level malala yes
go juice there we go okay only problem
as children we've all been told about
the story of the like the big bat go to
soar maybe there's a better way of doing
this using cyclical using a cyclical
goal call trough you can see ba calls
foo and foo calls bar this has the
advantage that we can suspend our loop
at arbitrary points and give back
control to the parent which then can
resume it at a later time of that let's
take a look at the actual beast example
of course to keep things manageable as a
lot of code missing constructing
listener starts the event loop housing
accept takes a socket reference to move
into and the continuation Handler strand
is an executor okay this creates a new
session
not that unaccept always calls to accept
which in turn calls on accept anyone
sees a loop okay okay so let's take a
look at we have something that requires
response to all the incoming connections
but we still need a session loop that's
what we done what we did earlier by
spawning a thread and telling it to loop
endless again so this is the entry point
for our session and it should look
familiar
it's basically the same as the listener
constructor kick-starts the session
event loop the session event loop is
more elaborate so I split it up to three
core components just being the start
here the reading part of our event loop
of
clearing our target buffer we subscribe
a read operation once the read is
completed our handler should be called
in this case on read note that a zinc
beast and Accio used a much faster error
code pattern instead of exceptions
because in the synchronous example there
was an endless loop and how do we access
that exit of course exceptions writing
looks very similar one thing to note
beast expects to write a range of
buffers however there will not be
represented as individual messages the
purpose is to avoid copying buffers if
possible okay all this I'd seem a little
overwhelming let's recap the session
let's recap the session event chain
unaccept calls do read which in turn
calls on read which calls to write which
calls on right and that calls to read
again
and you can see this closes the loop
yeah okay so the question was how am I
not just growing this stack well the
function does not okay you saw this
strand wrap and then you add a function
that's basically how you do the
continuation and that's an executor
right so you don't it's not a linear
call stack we just at some point to do
stack the exhaustion
no no it's there's this element in there
executors that takes care of like
managing who work who should call when
and at the end it doubles up to the IO
service event loop which then takes care
of like I go down this path at some
point our loop somewhere and there goes
returns it knows how to continue but
that's the part of someone else to call
that function again
okay earlier I mentioned Manuel
broadcasts we store all our sessions in
an unordered map
that way we can quickly add and remove
sessions a broadcast queues a message
for all open sessions of course now that
we add messages from the outside and
sending is a link we have to take care
of the case we want to send the message
but there's a write already in progress
in our application add message is only
called by broadcast so that we can avoid
adding the message either the client
hasn't voted yet or if there is already
a write in progress but we assume that
every right after a vote is a result
response which should refer to the most
up-to-date result flush message queue is
called both externally and internally
replaces the position of do right
conceptually it starts a write event
chain that should deplete our message to
queue if this event chain is already in
progress flushing is a no op notice this
that as soon as we queue a write
operation with a zinc write we set our
internal state to write in progress
let's look at the after right call Dec
triggered by the write operation first
releases our conceptual lock then calls
on right which depending on the queue
size cause either flush message queue
again or do read similar story for
reading I abbreviate it as in treat call
but conceptually after read the same as
after write for this model to work it's
imperative that we avoid fragmenting our
event loop for each session there should
only ever be one chain of events the
whole chain forms one big loop and at
the same
time some of its segments may
temporarily form a smaller loop with eg
with each other
however given enough time it should
always unfold to our overall session
event loop
ideally having built an infinite loop
there's a way to exited having completed
a read it can set the error code to that
socket era closed in this case we call
listener and erase the session with our
Associated ID essentially destructing
ourselves things like there are
responses or the poll response are
created once given that our poll data
object is owned by listener we guarantee
a pointer lifetime for those objects
that is the same as the lifetime of the
server using a synchronous of all
synchronous interface abouts many
pitfalls before sending an object we
serialize it then send and extend called
blocks until the descent happened and we
and we destruct our object via write of
azing interfaces this gets trickier we
have to guarantee a lifetime until all
right operations are done okay
shared lifetime many would now suggest
using a shared pointer yes that would
work I believe we can do better let's
see how we can avoid heap allocation the
only dynamic response in our application
is the result response new votes update
the vote array however we know that
serializing this object will always
create an object of the same size by
copying the new object into the previous
location any of our pointers we avoid
any of our pointers avoid being
invalidated we avoid heap allocation
and as a result Wright will always write
the most up-to-date result that way we
can reduce the amount of messages we
need to send saving both bandwidth and
local resources okay to give you a quick
idea about the effort required to use
each library I ran our example
implementations through word count you
web sockets it's at a company 1.6
kilobytes include OS isn't far away with
roughly 3 kilobytes and beast however
being a lower level library results in
nine kilobytes of source code that we
had to write ok the question was how
many lines of code is that I think W the
new WebSockets one is less than a
hundred and four beasts is more than 400
ok let us now compare a big productivity
factor the incremental compile time note
results on the 90th percentile compiled
with clang for you WebSockets is linked
as a static library making it a breeze
to work with I couldn't get included as
to build as debug so I measured the
default settings from 90% being under 3
seconds still nice to quickly iterate
with well beast being part of boost
carries the burden of the template heavy
had our only approach right so in terms
of documentation you web sockets valley
has any it's a little better for
including us still if you'll find
yourself reading source code most of the
time beast on the other hand has
excellent documentation to keep the
examples smaller and simpler all our
examples were purely single threaded
that gives me little experience in this
context however beast has clearly been
designed with multi-threading in mind
still very complicated and easy to get
wrong not sure about you web sockets
I've read
being reports like people claiming it's
amazing people claiming it's like breaks
all the time and include us currently
does not support any kind of threading
both UF circuits and beasts have native
support for SSL via open SSL however it
should be easy to put to put an include
OS application behind the reverse proxy
like nginx that then takes care of the
SSL looking at possible attack vectors
both beast and you WebSockets are
regular binaries allowing for a wide
variety of exploits paired with amateur
set of tools for reverse engineering
include Asus unique execution
environment makes that harder
what include west's can't protect you
from is application flaws let's say
there's a bug in our registration code
that way someone could perform vote
manipulation a unicorn is not going to
protect you from that what it can do is
limit damage of things like remote code
execution many exploits rely on finding
Lipsy and then using it to spawn a shell
it can mitigate a set of non exploit
propagations like the aforementioned
system call remember the biggest attack
vector is and remains social engineering
okay as my first time benchmarking a
network application please take me as my
results with a bucket of salt again
results at a 90 percentile from running
you web sockets scalability test locally
unfortunately I didn't manage to
benchmark include OS I ran the benchmark
in two settings first with 100
concurrent connections no big difference
in terms of users based memory usage
both sitting at around 4 megabytes on to
the connections per millisecond at this
small sample size this shouldn't be all
that representative
now with 10,000 concurrent connections
if it's extremely special purpose
implementation new WebSockets manages to
have an impressively small memory
footprint using only in the initial two
megabytes for 10,000 concurrent
connections that rate can host Google
esque traffic with less RAM than your
phone beast does well enough at this
time scale your application is much more
likely to become the bottleneck this
laptop managed to request and serve
10,000 connections in a third of a
second of that kind of traffic we should
be able to afford better hardware for
sure so who's the winner which library
is the best wrong question three
libraries are presented all aim to
achieve vastly different goals the
better question is what do you want to
summarize I'll associate each library of
a key strength if you want an easy fast
and lightweight solution take a look at
your web sockets I'll bite being a young
a young project include OS shows
promising progress towards being a solid
choice for security or security oriented
services if it's aimed to be as modular
and adaptable as possible beast comes
with an inherent complexity and
trade-offs given its aspiration to
become part of the standard library it
could very well be core of many well it
could be could very well be called many
upcoming libraries C++ is seldom the
best at anything - has more convenient
syntax
C reliably beats us and the computer
language benchmarks game rust has better
type-checking
elixir has more convenient
multi-threading and all the new
languages have a central package
manager' facilitating a shared ecosystem
so what's c++ a snitch libraries like
you have circles so there can be a nice
batteries included experience getting
outstanding performance and efficiency
fulfilling the long-standing promise of
safe high-level constructs compiled down
to efficient low-level components we had
with static type checking no need for a
runtime and mature compilers and tools
that's a sweet spot of versatility no
other language hits of course C++ does
not stand still let us look at existing
issues and how they might be solved in
the future most glaringly the complete
lack of networking in the standard
library addressed by the networking
tiers lack of execution control just by
the executors TS and a lack of suspender
Bowl functions addressed by the court in
CS also a lack of unicode support but
there are a couple of papers but it does
not seem to be a unified vision software
you'll find a source code for both the
presentation and example here if you're
watching this video and you want to tell
me how wrong I was here you go
okay let's take a quick look at the word
result again maybe some of you voted
right now okay I'll leave this up who
won never okay so we all hardcore fans I
see well you can vote the address is
down there like it's not particularly
hard just pull out your phone okay okay
any remaining questions
can you okay to be honest I think until
you reach the limits like it's fairly
lightweight right you don't do is
context switching in there and
everything is basically like delegates
calling each other yes at some point
you'll reach a limit right but I'm
betting there's like maybe two handfuls
of companies on this camera on this ball
that actually reach this kind of traffic
you can easily handle something like
1020 thousand connections at a time
well still a single threaded approach
but they have plan a plan to add support
well there's a talk at meeting C++ this
year this year we talked about okay so
the question is if there are binary
compatibility guarantees made between
releases okay I'm not sure to be honest
I know it has like they know about these
kinds of issues and I think the answer
is yes because each field is optional
for example in the table each field is
optional and if you just add ones you
can even tag old ones we've deprecated
but I think they guarantee the same
level but I'm not sure between version
it's still a fairly young project
I believe so yes but please look it up
okay I think that wraps it up thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>