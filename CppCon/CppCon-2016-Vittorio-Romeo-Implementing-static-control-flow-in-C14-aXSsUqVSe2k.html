<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Vittorio Romeo “Implementing `static` control flow in C++14&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Vittorio Romeo “Implementing `static` control flow in C++14&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Vittorio Romeo “Implementing `static` control flow in C++14&quot;</b></h2><h5 class="post__date">2016-09-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aXSsUqVSe2k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you very much for coming my name
is vittorio Rommel I currently work at
Bloomberg as a software engineer and you
might know me for my video tutorials
Emira conference talk today we're going
to speak about static control for in C++
14 and this is what we're going to do so
I have as part that's just light and are
we going to look at static control flow
in general then we gonna learn about
compile time branching and we'll have a
little history lesson about static if in
C++ we're gonna take a look at if Const
expert in C++ 17 and then implement our
own version in Sobotka's 14 then we're
gonna switch to coding comments and
we'll see the mutation details of static
if and we'll also deal with compile time
iteration using two different techniques
for each arguments which you may know if
you have if you're following shown
parents on Twitter and Static 4 which is
a glorified fold with a lot of
synthetical sugar so what is static
control foe so static is a specifier
that has multiple meaning C++ but it's
also word very commonly used by
developers to refer to compile time
control flow languages such as D if you
have ever used it you should know it as
a very very powerful meta programming
facility called static if and there are
also other languages to do that the
goals of this talk are understanding the
benefits of static control flow looking
at the history static if in C++ and also
analyzing the constructs we're gonna
implement this about those 14 assert
with an example of another language so
this is static F in D if you look at
this it's pretty weird because as you
can see we're kind of having this kind
of template where we're passing a
compile time integer and we are
compiling different analysis depending
on the integer we passed and we also
have a static assert over there which
will only fire if the conditions are not
met so in this case you can think about
the decompiler completely ignoring
branches that are not matched by the
conditions so how would you implement
this in C++ anyone
okay yeah that's probably the easiest
way of implementing it you just have a
normal template and you specialize it
over the integer and you can already see
the difference so indeed it's very it
doesn't care about the Scopes well in
C++ it's easier to understand because
the compiler has to specialize between
the two templates and there are no weird
rules about static if this is an example
from C++ 11 where we have a periodic
function called F and this is the
traditional way of angling with a very
attic pack of arguments we usually have
a single step that handles one of the
arguments and then we have the poetic
version that calls the single argument
function and then handles the tail and
keeps repeating until the tail is empty
so as you can see we have to repeat that
function twice if we had some sort of
construct maybe called if Const exper we
could avoid defining two functions and
we could do something like this this is
very nice because it's localized we have
the single function call and then we
handle the tail only if it's not empty
so it's quite easier to read and to
maintain as we have a single function
our example is constructing objects
let's say we're building our own version
of make unique and what we want to do is
switch between braces initialization and
grandparent initialization that allows
implicit conversion all the stuff and if
we want to check that at compile time
we might use something like this which
is in a belief or if you're using some
nice libraries such as fit or Hana you
would do something clever but as you can
see we have two fact two versions of the
same function and it's really noisy
because we have all that enable live
stuff if again we add this magical
construct called if constructs / all of
that would go away and what we will have
is just a single function which is
really really straightforward and easy
to read and as you can see we're
switching between a compile conditions a
compile time condition and just
returning depending on the result of
that condition so those examples are
actually real examples that were taken
from this proposal over here by Bill
volcanion and it was called construct
with and the paper was originally called
created as a resurrection of Cheever
controversial silicate proposals by
Walter Lee Brown and Walter bright herb
sadder and Alexandra school so these
proposals were created in 2011-2012 and
they were considered harmful by we are
now Gabby and and each other because
they had very unintuitive scope rules
they were similar 2d static if and they
weren't you know consistent with the
rest of the language in 2015 we had this
static director proposal that changed
the name to constructs per if I made it
more in line with the rest of the
language so will improve the proposal
several times and in 2015 we got two
more proposals that improved the wording
and that 16 we finally got to the
version that you seen on the screen with
the if construct or syntax in Oulu we
got the final revision we was accepted
for super for 17 and I'm really happy to
announce that you will be able to write
that beautiful code pretty soon
hopefully so these are is the same
example seen before and this is valid
suppose puzzlement in you can write this
if you have a super 17 compliant
compiler and I think that clunk SVM
should be able to handle this quite
nicely and again this example that we've
seen before is not hypothetical you can
write this in suppose pass 17 there are
some rules so if Const expert is always
restricted to block scopes is always
going to establish a new scope and it
requires that exists value of the
condition so that either coalition
branches were fault so the first two
rules can be summarized as that you know
if you ever used the normal if statement
you need you will introduce a new scope
you cannot do crazy stuff like D so
everything that you do inside the scope
is going to be limited to that scope the
third rule is the most important one and
it says that practically all the
branches need to be is possible and they
will only be instantiated if the
condition is matching so as long as you
have it valid support was code in there
even if it's even if the class maybe
does not support an operation that
you're calling inside a branch the
branch will only be instantiated and
cause a compile error if the condition
is matching otherwise
it just needs to be well-formed doesn't
matter if we will compile if the
condition is not true
so if you remember this no we cannot do
that instead well plus and I I think
that's a good thing you can chain
together if Const exper like this which
is very nice to see and the question
that you are asking is do we wait you
have to wait until she was 17 to do
something like this and if you're here
obviously you're interested in a C++
protein solution which we can implement
with a slightly less enticing syntax so
let's get to the spot was 14 construct
and I want to start with an example
let's say we have multiple food-related
classes that have slightly different
interfaces so we have a banana and
peanuts that we can eat and then we have
water in juice that we can drink our
goal is to create a generic consume
function that will accept any kind of
food instance and we'll print something
to a CD out depending on the type of the
food one way we could do this is using
if constructs were or my static if
implementation and what we need is
obviously a compile time condition in
order to branch a compile time so we can
specialize some suppose 14 very attic
with variables in order to categorize
these classes and you can think of this
as manually having a concept in manually
specifying what is satisfying the
concept so in the case of this solid
concept we're specifying that banana and
peanuts should satisfy hit and for is
liquid with doing that for water and
juice once we have that and our magical
study cave in suppose for 14 we can
write something like this so this is
quite weird it's like a chain of lambdas
with some synthetical sugar in between
that allows you to implement something
that's completely equivalent to support
or Seventeen's
if comes sex for construct so as you can
see we're using this weird bull b which
is a variable template that allows us to
wrap the boolean value in a compile time
wrapper so that the branching can take
place and yeah that's what Wolvie is for
and it is implemented like this we have
an interval constant and a concept
variable template in order to make it a
little nicer so we don't have to use the
braces
the end afterwards I'd like to say that
this kind of idea of rapping types
inside values and vice versa is what
allows amazing libraries such as putana
or fit in cheek to create extremely
powerful and nice to use metaprogramming
facilities and you can learn more about
about this pattern in the links here the
slides are available on github so feel
free to check them out later and you can
click on the links and visit the
articles also you can see that the scope
rules are what you would expect because
we have those lambdas that are
restricting the logic of the branching
only inside that scopes and the idea of
thinking about this construct is that
every branch is like a template function
that will only be instantiated if the
condition is matching so it doesn't
matter if for example Y that it does not
exist for our current acts in the
consumed call because we won't get a
compilation error unless the branch is
accentuated so that means that the
conditioner should have matched so yeah
you can think about this as a bunch of
template function and which we're like
linearly searching the one that matches
and as soon as we find it we take in and
we instantiate it otherwise it's never
going to be instantiated so this pattern
works thanks to see pastas proteins
generic lambdas this is one of the
branches and the compiler does some
magic transformation and it becomes
something like this so it's an anonymous
struct with a templated operator call
that's taking our argument and then
doing something and this is the
important part because since the
operator call is templated it will only
be instantiated if it's called that's
the important part if we didn't have
generic lambdas we wouldn't be able to
do this cleanly so any questions so far
and feel free to ask because this is
very important yes
okay the question is why would you use
this very convoluted syntax instead of
using a base food class and maybe doing
something more traditional so this is
just an example
I mean you I wouldn't obviously write
anything like this for such a simple
class hierarchy but when you're dealing
with meta programming and we did with
complex code it's really really nice to
have a localized compiled branch inside
a single function instead of jumping
everywhere over the code and maybe this
is a not an excellent example but it
gives you an idea how you can use
different interfaces in the same
function without having to use
specialization and stuff like that so
yeah you wouldn't do this for such a
simple example but we're seeing more
examples in the code that might be more
interesting sure yeah
well the question is why do you consider
not being able to do the crazy stuff you
can do in the in C++ and maybe I didn't
express myself very well I don't
consider that to be good
inside C++ because it's kind of
inconsistent with the rest of the
language but if I were using D I really
love the meta programming stuff you can
do indeed I just think it doesn't fit
with the rest of the language sure so
the question is what if I wanted to
disable the invalid specialization of
compile time and instead of printing
cannot consume just get rid of the else
that's it so it's an elite and analyze
this technique step by step the first
step is obviously calling consume so
we're passing this value inside a
function and after that we are going to
look for a matching branch so we start
at the top of the if and we test the
condition if it's false we completely
ignore the corresponding branch and as
soon as we find a real valid condition
then we don't care about anything else
we found our branch we stopped there and
this is what we're going to instantiate
and call so this is a very nice
animation take a look at static if and
this what happens everything we don't
care about that we're just collapsing
the whole construct into a single lambda
call so again we found our matching
condition everything else we don't care
about it we've got this lambda and this
function call operator and we were just
gonna you know stick them together and
call the lambda so this is what happens
the argument we pass to consume will be
passed to the call and say static if and
the static if call will forward that
argument to the lambda and then this is
practically what we get it's just the
call inside the match branch we don't
care about anything else oh sorry about
that
yeah FWD is just a macro for forward
that I defined which gets uses the call
type to get the types of the arguments
you until specify that again it's just
so I have another question for you why
don't we just capture the variable
instead of you know passing another one
and calling it again does anybody know
why sure exactly so we cannot capture
both variables when using static if
because we need to the very instant
ation to a letter step if we had
captured the variable the compare would
generate something like this and since
operator call is not templated this will
get immediately instantiated and it will
not compile because obviously we cannot
eat juice we can only drink it okay so
this was the slides part we'll get into
the code and see some more interesting
examples and then implementation of
static if and iteration constructs okay
hopefully you can see that okay so this
is the example we just seen in the
slides I just wanted to make it complete
and as you can see here we have our
classes here we are defining our fake
concepts or manual concepts and then
inside consume we have this static if
construct and we're calling all the
different methods if it matches the
branch and our main looks like this so
we're just calling consuming instances
of every kind of food and if we compile
it you can see that it compiles and it
prints what we expect so for banana we
will install it in liquid solid liquid
and for in turn float we cannot consume
if we add suppose plus 17 what you would
write is much nicer but it's
conceptually the same so this is what
you would write in service plus 17
you'll write if Const acts per the
conditions and you can just have health
for the default case and as you can see
we avoid a lot of noise and we don't
have two variables we just have the X
and what the compiler does is it takes
care of deferring the enunciation to a
later step so let's take a look at
implementation of static if
firstly we will define some interesting
snippets and alysus and stuff that's
useful so this is this FWD macro that
was talking about is just a city forward
with deco type of the arguments of the
macro and is passing them inside vehicle
type inside for work oh I like this
because it prevents you from having to
repeat the argument types and it's also
very nice when you use in generic
lambdas so you don't have to say deco
type of X and then X again it's just a
simple macro then we'll define our bull
compile-time variables so this is a type
Alice from Super Plus 11 and this is a
variable template for co-stars 14 if we
define this we don't have to call to
instantiate the bull type we can just
say will be with a value inside the
angle brackets and that's fine in sales
plus 17 will have bull constant which
can be used to replace this alias over
here so my my static if implementation
was inspired by this article hover here
that you can check out later and also by
the comments on its reddit thread and
this following typical guidelines issues
so it's just that mix and match of
everything that's has been saved there
and those are really interesting
discussion so I really advise you to
check them out if you're interested so
the implementation is composed of three
different things we have an interface
that Akif function that will take a
predicate and we return another struct
and then we can call and we'll trigger
the whole compile time branching stuff
we will have an outburst rack called
psych if in pull which will allow you to
chain then and else and will eventually
return a result when when a branch is
fine is found and result struct is
another implementation details which
will ignore all the other chaining calls
and it will give you the operator call
of the branch that you have matched and
as soon as you have that operator call
you can instantly the lambda and call
the function so the interface function
will be called static if and it will
take boolean constant as a parameter as
you can see here instead of specifying
the boolean directly in the template I'm
using the type value encoding paradigm
so I'm passing it as a value and then I
can always check what the compile time
value is
because it's wrapped inside an interweb
constant so that's that's a very
powerful pattern and after that we will
further declare our implementation
struct which will take the result of the
predicate and this will be used to this
will be specialized depending on the
result of the predicate afterwards we
have another struct that's called static
if result and it will be templated on
the function to call which is the branch
that we're passing to static it and we
will actually use inheritance to expose
the operator call of the function and
before we get we get into the details
let's reiterate to make it absolutely
clear static its input will be returned
by interface function and every instance
of this static a simple represents a
single branch the type will be
specialized as you as you may recall
it's a bull template depending on
whether or not the predicate is matched
static if result will ignore all the
subsequent chaining methods will hinder
it from the lambda which is our branch
and it will have exposed the operator
call in order to allow you to call the
matching branch it will be returned by
the true specialization of staticy
simple if at then branches matches or by
the fall specialization if announced
branches matches so I also have this
make static if resolved function here
that allows you to do type deduction for
the lambda which is pretty nice but we
won't need it in suppose plus 17 thanks
to the constructor template argument
deduction how should we and here we have
the specialization of our implementation
struct so this will be instantiated when
we find a matching true predicate if we
found that we don't care about the else
predicate so we can just ignore it we
collapse it if you remember the
animation it became transparent we don't
care about it and we return the the same
structure that we're actually checking
now and the same for else if so if the
breadth is the branch is true the
predicate is true we don't care about
you know anything that that we
implemented to catch the false branch
condition so what we care about is the
fan which contains the matter
in branch lambda in this case we we
found we finally found our condition and
we can return a result with the lambda
that we're going to call and then just
for one digit lambda into the function
then we'll get something that exposes
the coal operator for the fall
specialization we don't care about them
because the predicate is false we only
care about else and else if so if we
find else we will just return a result
because we don't have any order else if
that we have to check otherwise if we
have else if we will just return a new
static if that will check that predicate
so it's kind of chaining together
multiple study caves be behind a very
nice interface and we also have to
ignore operator call because as Jackie
said if we don't have a default case we
might actually have just a Nathan and
Dan and we we are returning ourselves if
we don't have another else so we need to
ignore any possible call to D to learn a
mesh branch the static if result is what
will be returned in indicates that we
find a matching branch or an else branch
and it's very simple we're just getting
our branch which is the lambda we are in
rating from it so that it exposes the
coal operator and we're forwarding the
branch inside ourselves in order to
initialize the lambda as soon as we find
a result we ignore everything because
all we want to do is call that that
branch without you know caring about the
rest of the static if construct and
these are this syntactical sugar
functions which are very simple this is
just for type deduction to create the
results and this is just to get the
predicate as a value to make a nice
function like interface and this will
instance it implementation by expanding
the compile time integral constant to a
compile time boolean value everything
clear so far
feel free to ask questions okay nice so
let's see some additional examples in
the next Mexico segment hopefully there
will be more interesting than the
previous one so this something I had to
incur encounter were calling a generic
data structure
to have this grow function and keep
track of how many copies and moves I was
doing and I wanted to check if the type
I was copying to the new buffer was move
constructible so instead of having two
separate functions and maybe using an a
belief or a third-party dependency what
I did is have a single function I put
the static if directory inside the
copying loop I check if it 'smoke
constructible then I increment my move
counter and use STD move explicitly
otherwise I increment my copy counter
and you know just use a copy so as you
can see this is very nice when you write
in generic code where and you don't know
the types you can just put inside your
implementation function it just works
well and doesn't pollute your code with
in a belief and another stuff I also
think static is extremely useful when
writing compile time algorithms another
thing I was doing for my thesis is
creating a compile time fold and this is
a left fold and I wanted to control the
recursion without having to specify all
the parameters again and maybe have a
different lambda or a different
interface function so what I did is I
returned this fold function here which
you don't have to care about the the
good part is that I'm using static if to
control the recursion so I'm checking
through more items we have to fall down
to and if there are not we can just
return the base case and this works very
well at compile time without any an
extra function that's just avoids the
the recursive case you can think of this
like the very Attic part argument
example that we seen in the slides it's
slightly more complex and it's a compile
time but I think this is way cleaner
than having an explicit specialization
and having to duplicate the function
signature two times so yeah two again
being able to branch in an almost
imperative way in compile time code it's
something that might be more familiar to
programmers who are not experienced with
functional programming and it's it can
be subjective but again I really think
it's cleaner in these contexts
another common operation we do any
project code is that for each loop so is
there a way we could implement that at
compile time as well and the answer is
yes
obviously so I'll start by analyzing
this amazing for each argument snippet
that Sean Penn posted on Twitter a few
years ago and I've analyzed it already
asleep young 2015 it's a 30-minute stop
dedicated to that but I'll try to you
know be short and show you this cool
snippet there is that we have this
function called four arcs that takes a
callable object and a bunch of arguments
and what we want to do is call F on
every single argument so what do we do
we use a steel initializer list event
casted to void and inside that we call
the function with the parameter pack by
forwarding every single argument then we
have the comma operator as zero and
we're expanding the things inside the
initializer list so this seems really
contrived if you haven't seen the
sleeper before but it's conceptually
very simple so the initializer list is
here because we need a context where we
can expand the very attic pack in order
to have the left to right a guaranteed
execution order we are using we are
calling the function on every single
element here by forwarding the element
as the argument of the function but
since our initializer list is of type
int we want this function call to
evaluate to a valid into expression so
that's where why we're using the comma
operator here and after evaluating every
single call to an int expression we're
using the ellipsis operator to expand
everything inside the initializer list
so in the end the initializer list is
just for 12 pass expand the function
calls and it's just an implementation
detail so if this is not clear this is
an example for for article which is
taking a callable object that will just
forward the argument to see out and here
were passing hit your genius values we
have a string and a bunch of ends and
what we expect is to print hello 1 2 3 2
st out and this roughly expands to this
crazy thing over here
it's analyzer lists casted to void
containing four elements and every
element is a call of the color object we
passed with a comma and 0 in order to
evaluate to a valid end
and since instead underneath a large
list we're guaranteed to be to have a
left to right evaluation order this will
do what we want it will print hello one
two three and the comb operator will
allow it to be via the compile time
because it's they're actually int so
they can be inside the initializer list
and this is the same as writing a CD out
hello one two three so this is a zero
overhead obstruction that you can use to
call a function over an entire genus set
of values just to show you a possible
example there is a call of the frogs
function with the same arguments as we
seen before and if I compile that
hopefully it will print what we expect L
1 2 3 s in see also 17 again this will
be much cleaner this is the
implementation see what 417 is just a
fold expression over the comma operator
and fold expressions guarantee left to
right evaluation order so that's all you
need to do in order to call a function
of aerobatic back sure question okay so
the question is that they have a similar
implementation of four arcs in their
company and what did is they returned F
at the end of the function in order you
know to be more composable and I agree
with that that's probably a better
solution because it's similar to a CD
for each or CD that allows you you know
to mutate the functor and then do
something after yeah so an alternative a
better alternative will be returning the
decodable object that you pass to for
arcs so you want to learn more about for
the expression just go and see BP
reference it's a very concise and
well-written PI page and in an Xcode
segment will exploit four arcs for
compile-time iteration so this is how it
looks like without comments and you can
see why it fits in a tweet
it's very short very concise and very
cryptic so this is an example I came up
with let's say we have a template called
buffer the
it's templated over a number of bytes
and we can allocate and deallocate the
buffer this totally valid allocation
de-allocation code and we will write to
run some tests with different amounts of
bytes without having to write a lot of
repetition and you know just have a nice
for loop so if we had a runtime buffer
where we can allocate the number of
bytes at runtime
this is what you were right you have a
range for over a set of numbers you will
allocate a buffer we will perform a test
and then the allocate this is very clean
very straightforward in order to do that
a compile time we need to generate this
code somehow so for arts cannot do
cannot pass doing that if you remember
our previous static of implementation we
use something similar to boot constant
to wrap a boolean value inside a compile
time wrapper we can do the same with
numbers
we can have a size T interval constant
and its own constructed variable
template and we can wrap a value inside
this construct value this way we can
actually iterate using for arcs over all
values here and every single szv
instantiation is a different type that
will contain the size T value and inside
our function here we can just call
buffer angle brackets oops angle
brackets with n and it will unwrap the
value for us and essentially it at
compile time with the correct amount of
bytes so this is not as clean as the
runtime test but it's very similar
conceptually you just have a bunch of
values you are iterating over and for
every value you're doing something in
compile time which is instant serial
buffer with that amount of bytes and
allocating the allocating and performing
your test so it's not as pretty as the
runtime version but if you want to make
it prettier you can use some addition of
instructions and maybe have a for values
function here that takes a bunch of
values it will wrap them for you inside
an integral constant and then do do
something with a callable object so is
this pattern clear to everyone about
yeah sure question
okay the question is why do you need
this compiled time as we were up there
instead of passing the integers directly
so if you pass the integers directly and
you lose the compiled time information
about the value of the integer it's just
an int you don't have that information
at compile time what we want to do is
not pass an int but an 1/8 a 16 and 32
at compile time in order to do that we
need to capture that information and
wrap into something that can hold it at
compile time and then we can unwrap it
later so if you pass hate here when you
get here inside the lambda and you try
to make sense it buffer it will not work
because this is like runtime information
it's not a valid compile time value if
it's not clear yet think of it in terms
of types what if you wanted to
instantiate a buffer with a specific
type you need like to wrap the type
inside an order like type constant and
then pass it to the buffer okay let's
move forward and we'll see an example of
using static if and four arcs together
so let's say that we have as we're just
saying we want to iterate over different
types and what we can do is the final
type wrapper which will be a simple
template struct over here containing the
type and we also define a concept
variable template that will allow us to
pass it around as a value so what we're
doing we're wrapping a type inside of a
value and this is an empty value it's
really nothing at runtime it's just a
wrapper for us to play with at a compile
time and we also have this kind of
utility mehta function called unwrap
that will take a rock type and it will
unwrap it for us and these are you can
use it
imagine you have a couple of vectors
which is a set of buffers and you want
to do something on every buffer all at
once maybe if you had suppose for 17 you
would use a CD apply in order to apply
the double inside a function do
something with that but another approach
is just iterating over types getting the
corresponding buffer from the topple and
performing an action over that and we
can do that before arts so these are
frogs call here
where we're passing a very alikum ount
of rap types because if you remember
those are actually values or those are
empty values but they contain compile
time information important for us and
every single type is going to get passed
inside a lambda so it's going to take
the value of T when we have when we are
inside the lambda body we can unwrap the
type and get the real T which in this
case is int float or double and after
that we can use a city get to get the
corresponding vector and maybe resize it
or do something on it
so as you can see by wrapping values in
two types and by wrapping types in two
values you can iterate over numbers
types or whatever you want a
compile-time and I think this is really
powerful because it doesn't look too far
off from a runtime loop and again the
same concept as static it applies it's
localized easier to reason about and
easier to read in my opinion if you
combine this function I we static if you
can I'm really powerful and simple
algorithms let's say we have a to
function want to initialize a small
object storage and want to initialize a
big object storage and we want to check
out compile time whether or not a set of
types is bigger than a certain threshold
and switch upon the threshold in order
to initialize a small or a big storage
so what we will do is have this four
arcs here we have a bunch of types over
here as you can see you have an int
float double and an array and inside the
for arts lambda body we can unwrap or
type check if the unwrap type is
matching your threshold and in this case
either initialize the small object
storage or the big object storage so by
convening combining these two constructs
together you can get really clean
compile time algorithms and codes that
you know it's pretty easy to read it's
just like the runtime version but this
is all happening at compile time so for
for our this is very very cool but there
are so many limitations it's not
possible to get the current iteration
index easily you need to pass it
alongside your arguments it's it's also
not possible to produce a result value
and there are no break and continue
equivalents to the compile time
so what are we going to implement is
another version of static iteration
called static 4 which will be internal
implement expose 14 and will allow you
to do all of those things
static 4 compared to 4 arts will indeed
add the ability to get the current
iteration index as a compile time number
it will give you the possibility to
produce an output value so an
accumulator and it will allow you to
break and continue out of the loop quite
easily so if you are familiar with
functional programming this is just a
glorified fault the idea is that we're
trading off compilation times in order
to use our recursive implementation so
that we can have all this nice sugar
because with for arts we get the
ellipsis operator so it's expanded by
the compiler which is very quick but if
you want to do this stuff we need to
recurse so it's going to be a little
more impactful on compile times but it's
more powerful so those are two
alternatives depending on what you want
to do so before diving into the
implementation let's see a very
contracts ample that will show you
everything that you we can do with
static 4 so we'll write a static 4 that
will accept any number of compile time
numerical values it will accumulate the
numbers and return our results at
compile time so the sum of all numbers
in a compile time wrapped value and it
will print every even number and I
trashed in index and will it will
immediately break when we find this
strange sentinel value which is minus
999 so the idea is the static work study
forwards by passing its current state as
a parameter to the to the loop body
every iteration and you can query this
day to get the current iteration the
next action that we will happen which is
either continue or break and you can
also access the accumulator variable
that you can override with your new
value inside the for loop body so this
is how it looks like we have this static
for function and the body is a lambda
that will take two parameters the first
one is the state of the static for and
the second one is the current argument
we're iterating upon and since GCC
doesn't really like when we use state
and
inside a construction constant context
sorry we need to use this kind of weird
pattern where we take the type of the
state and immediately instantiate it in
order to get across x-value clank does
not force you to do this but it's just a
workaround in order to take this value
and convert it to something that I can
be you can use a compile-time and we are
not losing any information because
everything is in the compile time
wrapper so there is nothing we're losing
by race and simply type again so we can
also assign names to our predicate so
the must break predicate is when our X
is equal to the weird sentinel value
that which shows and even predicate is
obviously when X when the remainder of X
+ 2 is 0 now we can check if we have to
break and if we have to break we will
use return state or break so we need to
we need a way of telling the for
iteration that we want to break
immediately so we're going to return
this special value that will be caught
by the implementation I will stop
iterating otherwise we will have a
neuropsych if here that we'll check if
the number is even and if it's even we
will print something to us to be out and
that will be the iteration the current
index of the for which is stored inside
the state and the number itself
otherwise we will continue iterating and
we will increase our accumulator with
the current value so all of this is a
lot to take in but I wanted to show you
an example that uses every possible
feature of static for and in the end
this is just a very glorified fault that
has a lot of syntactical sugar for you
to use inside the loop body you can see
that we can also produce runtime side
effects so this is not a purely compile
time construct you can get a compile
time result but while you're iterating
you can also produce an generate code
that will be run at runtime so in this
case we're printing stuff and also
getting a compile time accumulated value
that you can use in order compile time
algorithms the above code is slightly
equivalent to this run time generator so
what we're doing is we're catching an
accumulator and binding it these are
initial
value then we returning a very attic
lambda that takes a bunch of values and
for every value we are doing the same
thing we were doing the static for we're
breaking on our Sentinel value we're
keeping track of the iteration and we're
printing if the number is even and we're
accumulating the value and incremented
iteration as you can see this is way
easier to read but conceptually is the
same control flow so we have the same
structure for a static four and a
runtime for the price we have to pay is
obviously syntactical clarity but if you
know how to write a compiler
sorryi runtime for you know how to write
a compile time four and that's the point
of this of this talk so we actually are
using kering here to make it a lot more
flexible the first call to static four
will take the body of the lambda and
simply return a wrapper that wrapped up
body so we can call it multiple times
the second call will take an initial
accumulator and will not yet called will
not yet start the iteration so this is
just binding the body and binding the
accumulator and we can set this aside
and we can call it multiple times with
different argument paths finally the
third call we'll have our own body we'll
have the initial accumulator and we'll
have the very attic pack and this is
where the iteration will start over this
body with this initial accumulation
value so we do it this way because it's
a lot more flexible let's say that you
want to call the same body with the
circulation value multiple times with
different argument paths you can just
bind those and then call the result of
that with different arguments so it's
pretty powerful as an example we are
taking our print even accumulate
function that was the example we seen
before and we're binding the initial 0
value to the accumulator in this
variable over here and then we can call
this variable with a bunch of values
multiple times and the result of that
will be a compile-time value that will
sum all these types together and you
know it will do the usual logic of
breaking if we get our sentinel value
and it will print even numbers so as an
example i'm calling both the compile
time version of the loop and a runtime
version of the loop and just checking if
values the returned are the same in
order to make sure that the control flow
be logically the same we can compile
that and hopefully it will work
okay yes as you can see we get the even
number printed in both versions and we
get the same compile-time and run-time
result the important thing is that you
can use this compiler and result which
is the accumulation of the value in any
other compile time algorithm because
it's wrapped inside integral constant
well in the runtime value you lose
obviously the compile time information
so we will implement static for from
scratch in the next code segment before
we do that I want to make sure that it
is clear what's happening so if you have
any question or any doubt please feel
free to ask sure so the question is
could you use fault expressions okay now
you couldn't use full the expressions
because you have no way of breaking out
of it and also no way of getting the
iteration index if you think about it
the previous code snippet the for art
snippet is actually a fold expression
instead of a 17 so that's the trade-off
you have to pay you either use something
that gets expanded by they compared
directly and it's very fast at compile
time or use a recursive solution that
allows you to do more stuff basically
sure the question is is there any way
this could generate a really crappy
runtime code no I did as I tested
compiling to assembly and with
optimization level 1 for GCC and
optimization level 2 for clang it
completely goes away it's just like
generating code it's very nice sure
so the question is if you are the arrows
you get with this clear no they are
horrible all right let's move on to the
implementation I think it's more
straightforward and for arts one if
you're familiar with recursion and
algorithms so what we're using is a
state class that keeps track of the
current iteration the current
accumulation value and the next action
we will perform so it's like as which we
either break or continue and the
iteration will be tracked using an
interval constant as you should know
this is now our pattern every number we
use a compile-time we have to wrap it
the accumulator will be provided by the
user code by the second code so that we
can bind an initial accumulator and work
with it and the next section will be
implemented using two empty text drugs
so we're going to tag what the loop is
going to do in the next iteration either
breaker continue we also need to iterate
a compile-time and this can be
implemented using recursion and I'm
gonna use lambdas to recurse which is
pretty cool so the action classes are
over here there are just implementation
details in a hidden namespace
there are empty tag classes and we will
just use a CDS same to check if we want
to continue or break inside the
implementation of the for loop the state
class is a templated class that will
store our iteration our accumulator and
our action now we need to know all of
those values at compile time so it needs
to be a template but we also want
syntactical sugar that will allow the
user to grab them very easily so we
define context / auto methods that will
instantiate the template value and
return it and this is very nice because
we're using 2014 type deduction so we
don't have to specify the type ourselves
and is it the compiler can usually
automatically convert it to our runtime
values so like we're using esidisi out
with the iteration value there's no need
to unwrap it manually the compiler did
that for you so it's pretty convenient
now we also have to define two methods
one to continue and want to break and as
you can see here I have two overloads
because we want to continue with the
same
in accumulation value without mutating
it or we might want to give the static
for a new accumulation value in order to
pass it forward to the next iteration so
depending on what you want to do you
either want to pass a new accumulator or
just use the current one and this
methods here will change the action
inside the state so that the next
iteration we will check using static if
whether or not we need to continue a
break in order to simplify the
management of the state
I created this make state function in
this advanced state function and the
make state function will probably not be
needed in civil 417 but all it does here
is just take the values by regular
parameters for the function so that we
can deduce the types and it will just
instance it a state the advanced state
will just take the current state an
accumulation value and then in the next
action I will just increment the
iteration for you very easily
so one thing you that might be
interesting here is that when you want
to increment a compile-time value you
need to wrap it again because when we're
doing this +1 over here we're going back
to the runtime realm so we want to wrap
all that into the compound 10 room again
so we use a CSV if you had your own
interval constant implementation which
is what boost Ana does you can overload
the plus operator for to interval
constants and you will do the wrapping
and unwrapping inside implementation of
the over operator overload so it's a lot
cleaner but you need a lot of
boilerplate that didn't fit on the
slides on the code writer
ok let's implement the state methods so
for continue what we want to do is just
advance the state with our current state
and either give you a new accumulator
that was provided by the user or the
current accumulator and we're going to
signal the for recursion loop that we
want to continue and not actually break
the break function is pretty much the
same if we don't want to have a new
accumulator we just passed our current
one and we want to signal the for body
that we want to break instead of
continuing the next piece of the
implementation which is the most complex
one is the recursive lambda that is used
to actual
execute the loop and as you can see this
is wrapped inside aesthetic for function
that will bind our body so this is the
first scale of the function and here
we're binding our body by forwarding the
body inside lambda so we're capturing it
and this lambda call step will be called
multiple times with every argument at
compile time and in order to rehearse
with lambdas we need to use this weird
pattern where we passed the lambda to
itself because we don't have information
about the lambda until we call it so if
you were doing this around time you
might use STD function because a state
function erases the type and allows you
to recurse inside the lambda but since
we can have used at a compile time we
need to pass the lambda to itself you
know in order to recurse this is kind of
weird but it does make sense if you
think about it then we need to pass the
current state to the lambda the current
argument that we are iterating over and
rest of the arguments inside the step
body what we're going to do is we're
going to compute the next state
immediately and how do we compute the
next state we call the body function
that we captured earlier with the
current state and the current ex
argument so the next state will tell us
whether or not we had to break what the
new accumulation value is and it might
generate code we also need to check if
this is the last iteration we're doing
by checking if we have any remaining
argument in the argument pack that's
very easy to do we just check the sides
of the argument pack with the size of
ellipsis operator and wrap that into a
compile time value that's very important
now we need to make sure that if the
user is going to call break in the next
state we want to immediately break so we
don't have we don't want to generate an
extra step of code or modify the
accumulator value for an extra step so
what we are going to do is checking if
we must break by using STD the same with
the type of the next action in the next
state and comparing that to the break
action so if in the next state the user
is going to call break we want to
recognize that a compile time by using
deckle type on the next state we check
what the type of this action will be and
if it will break we set this value here
to a compile time
boolean true value in order to avoid
going an extra step in our static for
now it's time to deal with recursion if
you remember the previous example of you
code segments ago I use static if to
recurse instead of lambda for our fold
and this is basically the same thing
what we're implementing is a syntactical
sugar for left fold so what we want to
do is static if to control the recursion
if we have to break because the user
wanted us to immediately break or if we
are the last iteration this is our final
step or base case we are going to return
the current accumulator and that's it
otherwise what we want to do is recurse
and this is the very cool thing about
lambdas you can pass the lambda to
itself in order to allow recursion
without knowledge of the type of the
lambda at compile time and we can also
pass the next state and the rest of the
arguments ignoring the current argument
so this is a lot to take in
but I hope it's kind of clear what we're
doing if the user wants to break or if
we have no more argument just return the
accumulation value otherwise we call
ourselves this itself will be basically
the step function with the new state and
the rest of the arguments so that was
the step function now we want to return
something that allows the user to bind
an accumulator to the state function and
to do that we move the step function
inside an extra lambda that will be
returned and this lambda will just take
the initial accumulation value bind it
and we'll provide the user with another
function that will take a bunch of
arguments and I trait over those
arguments using the bound accumulation
value and a bound loop that's going to
be used for the static four and what we
need to do here is we need to explicitly
check if the user is passing an empty
parameter pack because otherwise we will
get a compile time error during the
sensation of the step lambda and so if
the user is passing no arguments
we'll just emit a return the accumulator
otherwise we start our iteration with an
initial state that begins from the zero
iteration index from the bound user
provider accumulator and with the
continued action by the
once we have all of that we can finally
call step with the initial state and
forwarded where the argument back and we
can actually invoke static if with our
step and our argument back so throughout
this talk what I've been doing is just
defining x and y's the the reason I do
this is to allow the firing of the
static if branch matching at compile
time
so if you see XS here and YS here is
just because I'm calling static if and
passing it back to the static if in
order to allow template enunciation to
take place only if the branches match it
so we can test our implementation this
is an example code we're using static
for with our body hover here and this
will just bind the body after binding
the body with bind an initial
accumulation value so this is second
function call and the final function
call will execute the loop and give us
our accumulator result so if we analyze
the body what we're doing is we're
printing everything at the beginning of
the loop then we are computing our new
accumulation value by taking the old one
over here and incrementing it with with
the value that we're iterating over and
wrapping all of that inside a
compile-time constant again this the
cool types that it's required because of
GCC for some reason so if u s-- clang is
way nicer and after that we will return
the continue action from our state with
the new accumulation value so this is
just a sum over the elements of the
static four with an initial zero value
if we compile that we should get the sum
of 10 20 30 and 40 oops ok as you can
see we get every iteration value and
sorry iteration index and current value
printed and the current value of the
accumulator so we can track where the
four is doing and again the point of
this construct it's a that it's
conceptually the same as a runtime for
in terms of
control flow and how you will think
about it the difference is the horrible
syntax but that's just what we have to
do for now
sure exactly
so the question or comment was what's
inside the for-loop is code that will be
generated at runtime which is directly
in the body and this will be the color
we're generating in order to compute
stuff at compile time we're exploiting
argument passing to the recursive lambda
and returning values that have special
like compile time sentinels that will
tell us whether or not we have to
accumulate and to continuum break is
that right okay perfect
so yeah sure exactly is no overhead at
runtime just for C outs
sure
yeah
okay so the question is you're using
recursion to break out of the loop
what if you capture the state as a
mutable lambda value and you directly
like a sign break to it during the body
is that what you're asking you're
thinking the in the runtime realm
because you can do that at runtime but
if you are signing it inside the body we
are not really changing any anything at
a compile time
we need a way but the lambda is not
constructs true it might work in space
okay I see what you what you get into
maybe it's a 4:17 where we have
constructs two lambdas we could do this
in a cleaner way but he supposes 14
since we don't have contacts from
lambdas I don't think you can use
runtime like syntax to control the
iteration we we might transfer facility
that's an interesting point sure yeah
okay
the point was so yeah the question is
how did you get away without specifying
the explicit return type of the lambda
using recursion I just use auto because
as you said I'm passing the lambda into
itself so I don't need to know what the
lambda is going to do or it's going to
return or D or the type of the lambda
itself during the development of the
outer for loop since I can explore the
type deduction here as you can see when
I'm rehearsing I'm just using return
itself calling self again over and over
but the return type is known in the base
case of the recursion so in the end the
author that you see here is the type of
the lambda which we do not care about
the thing we care about is the return
like the base case of the recursion and
we are aware of that type in
staticky fear which is the base step so
I understand your question but you don't
need to know the like the recursive type
of the lamb that you implement on the
recursion if you use this pattern what
you need to know is just what the type
of the value you're going to return is
and you can deduce that from the
accumulator in this case or anything
else I hope that answer your question
sure okay okay yeah exactly yeah yeah so
the comment was it's not actually a real
recursive function you're coming a
different function average duration and
that's completely correct I just like to
think it in terms of recursion because
you know it's it's practically what are
we doing but yeah it's not the same
function we're just generating any one
and calling it's every time any more
comments okay I think we're at a time
let me check what the order okay let's
go very clearly through this this is my
conclusion and in the github repository
where I that I show you the link at the
beginning of the talk I have the
assembly generated for just both paths
5.3 6.1 and chronic plus plus three
point seven three point eight and they
produce identical assembly for unwritten
code and Static for four arcs of static
if starting from this optimization level
onwards so this is effectively raucous
obstruction you might pay in terms of
compile time a compilation time impact
depending on whether or not you know
you're using a very big static for that
user recursion or a lot of static gifts
if you want a production-ready solution
you can check out boost Ana I cannot
stress this enough this is a beautiful
library that makes meta programming
amazing and it provides some evil if
construct here which you can use to
implement the same pattern as you can
see here you just have a compile time
condition here and a bunch of lambdas
that represent the various instance
yishun depending on whether or not
you're matching the compile time branch
also it provides that for each here that
takes a topple instead of a very Adak
amount of arguments and it will applied
it about the topple inside the pass
function so you can achieve the same
thing as four arcs of static for without
the iteration index and all out
the syntactical sugar another cool
library is both false fits which is a
modern functional library and you have
something similar to study gift which is
called evil and conditional by composing
evil and conditional together and using
that special if object you can implement
the same thing as static if and this is
a production reading solution it's a
different syntax different approach but
it does the same thing basically also
you can use fit compress and fit apply
to create a callable object that will
call a specific function over a set of
arguments and instead of passing them as
a very attic set you just call it
multiple times and you can use
metaprogramming facilities to make this
nicer and equivalent to static for so I
hope you enjoyed the talk thank you very
much for attending</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>