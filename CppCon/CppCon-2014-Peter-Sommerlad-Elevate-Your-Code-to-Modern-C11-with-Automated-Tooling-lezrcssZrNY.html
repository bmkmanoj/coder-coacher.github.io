<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2014: Peter Sommerlad &quot;Elevate Your Code to Modern C++11 with Automated Tooling&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2014: Peter Sommerlad &quot;Elevate Your Code to Modern C++11 with Automated Tooling&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2014: Peter Sommerlad &quot;Elevate Your Code to Modern C++11 with Automated Tooling&quot;</b></h2><h5 class="post__date">2014-10-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lezrcssZrNY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning I was told to start 9:00
sharp fortunately we are early enough to
not that I don't have to contend with
Apple's presentation that's a good thing
I but also it's very early in the
morning so we all had a long night last
night at least those who went to the
evening session and I will try my very
best to entertain you and shows you some
of our tooling that we created to make
C++ code better what I also have a
lightning talk this night but if you a
brief preview I say I want you to write
simple C++ code simple not in the sense
of simplistic but really make simple
things simple and that's the topic of be
honest talk later on and my mantra is
less code equals more software so it's
important to know the language and the
idioms you shouldn't be afraid of
templates and sel and start small and
tools can help even if you have a huge
legacy code base it improves by one edit
at a time and some of the edits can be
faster with the tooling that we provide
come on
doesn't work okay
let's start with hello world that is
something everybody knows about so let's
see is that simple code is that simple
C++ or simplistic who can find what's
bad in this piece of software render so
using namespace STD on the namespace
scope is hurting you and it's even worse
if you do that in a header file but it's
convenient you don't have to write SD :
: what else
ideas yeah what's that the Commons is
really redundant if someone needs to
write a comment like that you better
take away the license to run the C++
compiler what about the top-level
comment is that a good one well that's
actually what's Auto generated by
eclipse CDT yes so there's a lot of
duplicated information and exactly
what's up there is no longer belonging
in source files you know that comes from
an age when we printed source files
first printed source files in the last
week Oh No
it's no longer that useful people even
put form feeds between functions and
some source code that was is technique
of the 80s all this information up there
should belong in to the version control
system let's see that's what I want to
say the version the author who is a
single author file that's no longer
happening
we have collective code ownership
multiple edits and all that information
is available in the version management
system the comment was ridiculous or the
else out that we don't need to return
zero that's redundant the main function
and that's a special one is defined to
return zero or whatever the success code
of your operating system is
automatically the compiler will generate
that return for you so the return zero
is redundant code so we had that already
and who knows and will who uses angle on
a regular basis do you know what angle
does it does a flash and it's really
neat when you write a web server where
you put every line over your socket with
handle you get the worst performance can
imagine flashing over the network for
each line is not what you want been
there done them so handle is inefficient
redundant because when the program ends
C out is flushed anyway so the better
practice get rid of handle and only use
it very deliberate when you for example
write a code that interacts on the
terminal with the user and you want to
write something else so the user can
enter it input something useful
otherwise and/or has no use in your code
unfortunately everybody is using it
because hello world contains it
there's another thing we used a global
variable see out is a global variable
even so it's standardized it's very bad
why
well global variables except for the
main functions are occurs you cannot
test or easily unit test your code if
you're using global variables especially
those that are immutable like see out
that have side effects if your code has
side effects and global variables
it's almost untestable at least in the
sense of unit testing so if you would
work for me or study at my university
and you would be using c out in any
function that is not main i would be
call use a stick or a whip to hit you on
any body part that you desired and tell
you not using c out but passing in an
old stream to your function so that you
can actually replace you out with
whatever you might need for example unit
testing and it might even make your code
much more reusable so no global
variables except for main namespaces
using namespace is so convenient who has
used using namespace STD in the past
week who deleted using namespace STD in
the past weeks how tedious was that
does it mean you have to adjust you have
to add the namespace okay let's see what
happens here we got our hello world here
we are in line using we get a nice
preview that is unfortunately the
projector is okay instead of using
namespace STD we get STD colon colon in
front of these things getting rid of
that cool isn't it would that help you
I'll come on I know you can do that it's
playing as well what's a skit it will
today it's not as clever but we could
make it work to figure out where it's
needed or not it's student project but
it we always try for not for 100%
correctness but for use useful things
that we can implement well enough you
can even go the other way around by
saying
where is it extract using namespace Oh
wrong name selected maybe
that's the demo effect Oh
extract using declaration which is much
much more so if you have a single
identifier that comes very often like
Andale in your code that I learned you
can actually get a using declaration and
get rid of the sed in front of that
identifier so in this in the current
scope you can use end without sed in
this example it doesn't make much sense
because it's only used in one place but
that's the opposite way to go for the
refactoring so it's very convenient to
use using namespace and then get rid of
it and have the code clean up I'll
commence
that's more than truly I know people are
good enough to do that in VI or Emacs
but it's EE if it's still much better to
use modern IDE to help you with that
you
so what do we get from our tooling we
can inline the using namespace or using
declaration we can extract Li using
declaration fve scene and we can even
extract Li using namespace but we
wouldn't put that in the global scope
but in the most local scope that
surrounds the place where we say select
that and we can also even if we keep
using names with SV we can qualify an
unqualified name individually to show or
Chandler ask for in front of swab to
show ok it's actually STD as well
especially pro to prohibit ATL who knows
what AVL is who doesn't know what ATL is
I would say get some books and learn
about it that's one of the most
intriguing things that makes actually
operators overloading work I have about
several thousands on my shelf and I read
most of them so I forgot where I learned
about that maybe the best thing to learn
about it is go to the standardization
committee and work with them then you
will recognize people like Chandler who
will tell you oh no this wouldn't work
because of ADL oh no we cannot break ADL
because of that that's how I learned
most of that let's connect look up yeah
argument dependent look up sorry for
that not spelling out okay so one thing
you learned you know that you don't know
everything about C++ but it's a very
common thing even Brianna confesses that
and I have to confess it as well
now back to namespaces we had for a long
time but C++ 11 brought us auto and you
might have learned yesterday from Scott
Myers the intricate rules about what
auto actually does and means and there
are several uses for that I always
recommend if you use order to define a
variable you seek equal sign
because there are some reasons why you
want to do that and use the equal signs
without initializer list curly braces
and that's how it's supposed to be used
all other uses where you get interesting
parses and interesting type deductions
better step away from that in your day
to day code so don't use Curly's
together with Auto and use an equal sign
to show that you initialize the variable
there there are uses for return type
deduction that we got easier in C++ 14
so in C++ 11 you can write Auto in front
of a function definition or a
declaration but then you have to specify
this little arrow to say what the return
have actually is for a function that
returns an int it's not really helpful
because you have to type more and get
nothing out of it and it's even more
confusing to see that but the syntax has
to be regular that's why it's allowed
the useful thing for Auto for return to
have deduction is when you write generic
code like on the right hand side a
template that takes two arguments adds
them and then you say okay regardless
what T and you are I want the return had
to be what comes out of the operation
the bad thing is we have redundancy
because we have overlap the good thing
is in C++ 14 that's no longer necessary
and if you write code
like that and if you need to write code
like that you better know how to deal
with that otherwise don't do it
so in 14 we can make this much easier
and care and
get things like for example adding if
tnu are metrics types you might be able
to add them multiplication of matrices
might be more interesting because the
resulting type might neither be t or you
and that's the interesting thing might
even be an expression template that you
later on actually evaluate what is
useful Otto useful Otto happens to be
whenever you use to write something very
that included colon colon iterator who
has written code using Const reverse
iterators you no longer need to spell
that out
there are several option for that first
use algorithms that you can use today
without having to spelling out the
iterator type names because you've just
passed the iterators down your home
second option is use arrow to get the
type did use of that iterator that
you're using the third option is use the
range for loop and there I usually
recommend two things or there are
several options on what to do if you
actually want to change the elements in
the range use auto Rev if you want not
to change the elements and you want to
copy them use auto cons or Auto contrast
then you make sure if you just would use
Auto X you can change X but it would not
have any effect to the element and
vector or whatever be is I believe the
vector out there
questions who has used auto
okay but the IDE provides whenever you
use Auto to define a variable it will
actually show you what it means the
compiler would abuse I don't say it
doesn't what the compiler actually does
because it's not running the compiler in
that case in a case it does its own
parsing and figured trying to figure out
what the let's see if I can show you
that you shouldn't be surprised to see
something let's use that hello world
and it says long double to me
you
you
let's see oh it even came to do as an O
Street cool that's what
surprise I thought I would get a very
lengthy name like sed something so maybe
that's an optimization there to spell it
out so also something evened out just
hover and it will tell you send your
little mouse bone the drone there and
observe what's going on there and you
will see what's in there
cool thing isn't it another C++ 11
feature uniform in visualization
who can tell me what happens on the left
yellow box with X&amp;amp;Y all right and X and
sin it's me why less of hand in the bag
you're almost correct but it depends and
that's always hard enough if it would be
your namespace code
X would be initialized Y is always
initialized but you're only because you
know that standard string had has a
default constructor that actually
initialize the string to an empty string
if it would be in local scope function
local scope X will not be initialized
but why we'll using uninitialized
variables R objects is often a curse
because using it causes undefined
behavior and undefined behavior means
the pink elephant might drop from the
ceiling and sit on your lap or it might
mean your deep hue burns out and your
computer is killed
let's undefined behavior I know general
selling can tell you much more about how
compilers can use undefined behavior to
optimize a very broken code and that's
also something that can happen so
undefined behavior is something we want
to get rid of or not take part
so another thing what's on the
right-hand side I write sed string a
quotes to get an empty string then my
colleague says okay no that's that's too
simple empty string is the default so I
just delete the empty string get
efficiency and what happens then right
yellow box a and B he tends to become
now a declaration of a function because
it no longer has an argument and it's
even more there are more interesting
cases where my students struggle with
failing compiles especially it compiles
when they start out with their program
declaring something like B and then they
use it and they get strange interesting
compilation errors so this is called the
vexing pars and C++ 11 gives us the
means to relieve us from that burn by
using curly braces because to empty
curly braces will never parse as a
function declaration they were always
parsed as a value ratio and we have a
plug in the elevator because we have C++
11 that will allow you to change the
code with X&amp;amp;Y on the left-hand side to
code using curly braces also
guaranteeing that X will be initialized
and so you can create code that always
uses the curly braces for initialization
except for some case that I come back in
a moment so you can see whenever you see
and X without curly braces that's the
problem in your code
I know there are people who care a lot
about efficiency but correctness is
first and then efficiency if you really
care that the compiler initializes X
needless go to Chandler he will be able
to update to optimize away that needless
initialization I believe so is that true
Chandler
in some cases okay
so for those who come from see using
Curly's have been around for ages but
only for plain old data types
and again I mix these slides we already
learned that F and T are functions and
the bad thing is when we use curly
braces now we can actually initialize
vectors with the sequence of elements
but if this sequence in the elements
match also with an existing vector
constructor like a vector in I can say I
want 10-inch initializes 0 if I want
that use that constructor I have to use
parentheses again
that's why uniform initialization is not
universal who has been hit by that
who has never used it
who's using compiler that doesn't allow
curlies
or vaping update your compiler so that's
one of the corner cases where curly
braces will not always work if you would
have a vector of string writing me curly
10 quote hello would actually initialize
the vector with ten hellos it's only
words ambiguous that the curly braces
will match with the initializer list
constructor that gives you the list of
elements otherwise it will match the
regular constructors and we couldn't
change vector with respect to that
without breaking existing code because
the parent theses are still allowed then
we also learned last morning from
Scott Myers if we use Curly's with auto
and the values with the curl it within
the curly braces are
the same hype we will get auto reduced
standard initializer list eight for
example for three and it might be fixed
maybe in c-plus for 17 and we also so
that you might be able to write Auto I
curly brace five curly brace but that's
not yet available in the sender and I'm
not sure if there are compilers who are
already implementing that it might be
with the option for new code that you
can already get that but that's
definitely not portable yet the Google
guys there is that already implemented
in clang no it's not in the standard
there are papers supposing that for the
sender but it's not there yet no equal
three that's my recommendation anyway
okay just to get you an interesting
thing there my students struggle who can
explain why the left-hand side code
doesn't compile
who has written code like on the
left-hand side who can understand what
it should do there was a hand you're
standing next to the microphone can you
send to that or
come on who is not using vector
so caveat ID my compiler doesn't support
this yet but the right-hand side is
going to call a constructor I believe or
the left-hand side of vector and ed for
the variable V it's going to call a
constructor in the right-hand side is
not I believe or it'll get confused
sorry I couldn't understand exactly what
you say the right hand side is
constructing a vector by reading from
standard input
and it using a nice trim iterator who
has ever used a nice roomy generator in
his code only a few one who has a guess
what it might be was never heard of an
ice-cream iterator
go back to your books it's not that
comfy cuz you might not use use it to
read from seeing but but whenever you
read values from a stream there are
similar identical ice to iterators can
help you to create a vector with all the
values in there without even having to
think about the parsing and the looping
and so on so this program will actually
read all numbers or integers from the
Senate input until either it fails to
convert the characters to an integer or
the end of file is reached and then it
will just spell them out again that's
what this program does if you look back
C++ Oh 3 using this program will not
compile or that's 11 if you would write
it incremental without the loop it will
compile
and it will give you a function
declaration of be taking two eyes
through iterators s-parameter and
turning a vector in
however that function is nowhere defined
and it will not link if you use V in
your code the interesting thing is the
for loop almost compiles if you would
call out me and that we exists so you
get the compile error here but the
problem you create here is up there
because you get the compiler always take
something as a function declaration if
it can parse it as a function
declaration that's a rule that's
inherent in C++ and that's this thing
where you have the this int X Brown
parent the parent pieces where you
actually end up with the function
declaration
it comes well actually if even if I
would pass in something here it would
take it as this one yes then if you have
a separate variable for either the first
or the second argument then it will no
longer be the vaccine powers and that's
the means to treat that in C++ oh three
okay there's another option to put
parent pieces around from here to here
from around these okay and then and then
you will no longer get the vexing cars
with thing yes but it's really hard to
get it right
okay clang is great who is not using
clang maybe you better should switch
over
but readability is not read easy so my
recommendation was he plays with eleven
code use curly braces so you don't have
to care about things like putting extra
parent pieces to avoid getting the
vexing parts
and I should show you something that we
can do
you
where is my source file that I want to
show
you
you
all right let's get picked to hello
world that's an easy guinea pig
you
you
I see this little green white things it
tells me okay
and I'm ill Alicia initialized variable
found that's running actually the
elevation code and with control one or
on the Mac command one I can replace it
and I will get and can also do it with
the menu quick fix and it will
automatically add these curly braces to
your code so that's something you don't
have to do everywhere but it's
convenient to have these curly braces
added for you automatically in show your
code readers that you will actually use
to initialize a variable
another automatic tooling that can help
you defining stuff
macros who loves macros in C++ code come
on
macros are occurs and in C++ 11 they are
almost obsolete and I damned them and
even for the places where we still need
to use macros like getting line and file
information there is work in the
reflection study group in the
standardization to get rid of the needs
for that so we want to get rid of macros
for C++ the only means we have macros
that are I would say are still allowed
are as include cards and even that might
go away with modules so there might be a
future I dream of I might be even live
long enough to to to see that cut to to
see it or to get it where we don't need
macros in C++ anymore
we will still have them because we want
to be compatible with C and C has no
means to get rid of macros but we want
to
get rid of macros for good sir pastures
and there has been a paper by iana syrup
and some of his colleague students
former students Hendrik were you on that
paper
okay one of the authors is back there
and we we got the inspiration from that
paper okay why don't we replace let's
say cleanly written macros by C++ eleven
mechanisms where we have constant expert
and console explore functions and that
can be used for to eliminate some of the
macros that are written just a little
bit of example code you have some more
or less clearly written macros that are
not that splendid
for example the run fungus has some
issues but I use it as an example and
even a lot of code especially C code
tends to have tons of macros that are
never used in the code does anybody of
you working in embedded systems
they're you 10 there I've seen several
compiler vendors or processor vendors
giving you away your the infrastructure
to compile for your processor but these
processors come in many flavors so you
can configure them and how much RAM you
get how much how many a DC convertors or
any kind of periphery that's built into
the hardware and you got and say
zillions of variations of how an
individual processor could work and they
put all the possible combinations in a
single header file that gives you all
the parameters to access the hardware so
what you have to do is configuration
mech management for your hardware using
macro settings and the code tends to
become heavily if deft and I've seen
embedded programmers to mimic these
style of ugly ridiculously large and
understandable header files in their own
code base which is the curse that will
have to live with and something we need
to get rid of so macros are evil
and for example our macros up there we
might be able to replace and I know at
least one person who knows what the
replacement looks like and to make it
more interesting I show it in the IDE if
I can find the correct source file
you
we also get these little stars here and
it says okay macro definition can be
replaced with the constants extra
expression
cool let's try it
you
and what we get this context for
auto-type is automatically reduced and
we get pie in the pipe whatever that is
and maybe even the hover will tell us
let's see if it can do that oh it's a
type double cool we replaced an unsaved
macro with the save use of PI as a
context per the constant that is
compiled and evaluated
you
Square
the good thing about square is it works
regardless what data type you put in you
will get the same data type out by
multiplication cool that's why people
use macros well we've got template
functions in which get even template
context Pro functions that can be
evaluated at compiled and where needed
and we can replace that as well
it looks a little bit ugly because
that's C++ 11 code so we get a template
function that takes a template argument
and multiplies it and we get redundant
code in the data type and the return
statement but this thing now is type
safe as efficient as a macro
and it wouldn't get you into trouble if
you place the marker use the micro in
context where it might not be that times
typesafe replacement the good thing
about that the existing code should
still compile and run and see with us
you've seen I'm using clang here given
under the disguise of zip lock picking
now that's the wrong program I ran
you
okay who was called the square of 42 and
his where of pious something okay this
we also can replace and
you
this definition is not used so one thing
is we can make it a function the other
thing is we can try to get rid of that
at all
you
let's see if if I can find that
you
yeah that's it yeah I'm there's a little
back there and I have no idea what that
back says now our statement has no
effect but that's that's the false
positive of the checker that wasn't
written by us maybe it was your
colleague Sergei
well it's the tool doesn't do it on its
own it's on your behalf so you're
responsible and it's actually it's not a
back it's just the IDE telling me it
might be a back and if you're not happy
with that
there's always undo I even got a batch
see there's always undo here undo yeah
and the I have a work I don't say we are
producing 100% tools I know that Google
has different approach with offline
tools we don't see what's happening if
I'm not happy what I'm getting just undo
it
you can keep your macros I don't force
you to get rid of them
you
run away so instead of the green thing
you get a yellow thing I was wondering
if I can show you how to get rid of the
macro definitions at least what you can
instead do instead is where is that
should be able that's
so you see the macro expansion is shown
to you if you have recursive macro
expansion it will you will be even be
able to see that as well but you should
be able to replace it
sure we're somehow lost in my IDE now
screen is too small
you
therefore therefore we do something else
with that that I wanted to show you that
it didn't show I can get rid of the
macro like that and that's correct
so I just didn't find it in the pop-up
menu it's in the top-level menu get rid
of the macro by been lining it
explicitly okay there are means that
still can be improved for getting rid of
macros
another thing is a race who is using
arrays in C++ plane C like arrays
don't
most of the time the usage of a race or
I would say a large percentage of any
kind of buffer overflows or security
incidents have been
influenced by the use of arrays
there is a c++ 11 means of getting
better behavior by use not using arrays
by using stupid array you can get almost
the same benefits plus and if you're not
using C++ Levin use boost array which is
the same it's the same benefits but you
get additional features like being able
to pass them easily to SL algorithms
even before C++ 11 where you have begin
and end now plus you have the option to
get range check you don't have to but
you can and that's also a big thing so
how do we get rid of these arrays
you
I hope that works better
let's see okay arrays are bad and we can
get rid of that
by easily refactor that way
and you see we have to add additional
Curly's to make it work with the
initializers some compilers might allow
you to leave out these additional
Curly's and warn you about and now you
can see it's almost the same code it's
not exactly correct because
it will create wrong code here because
we use the array name in a context where
it's never up a lot so yet it was a and
you
like that
you
but we still can use you see it will
introduce the data called get to the
original array address that it was it
was used so not perfect but doable and
get rid of arrays
you
Oh
pointers pointers are almost as evil as
arrays who's using pointers on a daily
basis that are not smart don't get rid
of way I know you have reasons for using
pointers yet an on owning corner is okay
ish it still can be now
yeah but well using smart pointers helps
but using plain pointers especially in
the sense and I know Google has
recommendation to use pointers for
reference argument the reference
parameters which I believe is bad but
using pointers mindlessly is really
really bad and people use them wrong
especially my students would then use
them wrong I teach my students almost
all of the semester without plane
pointers and I show them okay here be
dragons be aware you will see where that
code is it's hard to get rid of them but
we try hard to help you with that we're
not there yet that we have the perfect
point terminator yet but we have tried
to work in that direction
for example replacing that swap function
with references and that automatically
adjusting the call sides as well it
doesn't work perfectly but it's the
first step in the right direction
mapping so
whenever you see pointers in your code
especially when you pass arrays as
pointers to functions that are noticed
nuts to the array be aware you lose the
dimension you lose a lot of information
you can misuse pointers don't do it yeah
that's wrong let me show you why it's
wrong no no no you don't want that
because let me show us you'll see when
you have a call site here okay these
strange address of things but what you
see you see the function declaration or
definition where it's called
so whenever you in doubt that you pass
something by reference and it's rare
that you pass something by reference
then you will see that it's passed by
reference yeah but be using the wrong
tools that's my message you see on this
place whenever I want to see okay it's
called by reference and the good
function name like swap will tell you
that you might want to have reference so
and yeah
you
are you let's see if we can back
what we had and say something like a
plus size it's not perfect
so what's broken here that begins stays
broken but the origin code wouldn't have
used that anyway but this is still okay
no it's not okay that's broken yeah but
that's that's a known fact we're working
on that
you
okay but I I need to show you something
more I've seen the star that someone was
wearing a Star Wars t-shirt they have
other students who work on something
called they they nicknamed char Wars
character pointers and character rays
are even more evil than regular pointers
and arrays because we have standards
training for most of their valid uses
and there might be a future where we
have a standard string view the type
that is actually getting all the
performance of character pointers and
character rays plus a safety of string
without the need of copying and memory
allocation and things like string cat
safe string cat for example is slower
with character partners and with strings
because character pointer doesn't know
the size of the string the safety like
the too short array where you plant a
string copy into and it's easy to make
one of a multiple of errors there we
have a lot of mappings optimizations
like comparing for equality with string
compare is a little bit hard to read
you
so we just instead of a compare use
equality operator and just an example we
have a string array
and try to replace something there is
dot txt first thing that is done by the
tool is include the string header if
it's not there yet
second step replace the definition to
the standard string because we had a
buffer with 100 elements we will reserve
that that might be manually deleted away
later on then the search this replaced
by find first off and you see there is
something where we have to actually it
adjust the not found condition it's no
longer an output or by string and pause
and instead of the concatenation we run
write as equals
you
a final thing
sometimes functions like this my max can
be used
or can be generalized to a more generic
version where you can say okay my max
should work for all types that can come
be compared or for example enter for
entering is in single variable from an
entire stream could also be created in a
way that will could use the shift
operator for all kinds of types where
you can input that and deliver a
corresponding value and these things can
also be automatically adjusted with an
extract template refactoring
you
where this code is automatically
generated for you and if we have a
minute I try to show that to you
you
this is our example code let's see if I
can make it correct
extract template and it suggests us okay
we have three different occurrences of
an int do you want that int to be the
same template parameter and that's okay
in the moment we catalyze preview so we
generalize the function that used a
deliberate type to be useful with all
kinds of type and because it's the
template function and uses template
parameter the type deduction will
actually work we don't have to change
any of the call sites for using that now
I promise you can also do that with
Enter
you
here we don't want the stream to be an
argument but we want the return type and
the local variable to actually be the
same type so we can call enter with
angle brackets give the type and read a
value from them ice cream of that type
regardless what type you pass in to
generalize the code like that and we get
a nice preview and you will see that the
call sides where we use the previous
enter without the end that use Justine
will have automatically added the now
required template argument of end to do
that
cool isn't it and we if it wouldn't have
at the definition up there we can
actually pull the definition from into a
header file by using a refactoring we
also provide that's called toggle
function body that Andrews question
I have a student working on concept
light support next semester on starting
on Monday but I'm I kind of tell you
what comes out of it yet students have
the right to fail and it's it might be a
tough thing but we have actually we have
for our mock object we have a
refactorings that will actually
determine the required function calls
and we'll add them to a template
argument so it's not concepts but it's
figuring out what is required to be
called but I cannot show that to you
because the time is over and I'm not
prepared to show that to you now okay
that's what you were asking for okay we
can use that extra template refactoring
to introduce compile time dependencies
for unit testing and there's another
talk on unit testing where I also cannot
show that to you because of time I might
be too short but I will put the slide up
there so you can extract the type and
what brings the future we have plans for
more eye my personal goal is to make
develop a better idea for C++ then
eclipse for Java is for Java we're
working on that when I started out in
2005 or C++ refactoring everybody told
me you're crazy that will never work
we now have things that work maybe 80%
of the time and that can be a lifesaver
and we believe in interactive tooling
because then the tooling can actually be
made to work somehow and you are in
charge to see if it does work correctly
or not
if you don't have a tool like that try
it I place all over the place eats these
little memo cards to give you the chance
to download it easily more questions I
answered some of them it will be able to
use the question is I use the I use
Xcode and Visual Studio how can I use
develop well get rid of Xcode and Visual
Studio and use their compilers
underneath so savelic can work with CL
dot exe from Microsoft and also with the
Xcode compilers it's a different ID it's
not an add-in so the question is can you
plug in develop in into Visual Studio
with a large code base to refactor well
what you can what you can do is actually
try to put you load your code base in to
develop and refactor it from there and
either use the visual studio compiler or
then we
rerun the compiled from Visual Studio
with the change source code it's not a
back-end tool it's an IDE where all the
language information is part of the IDE
it's like it has one could say it has
similar architecture to what Visual
Studio to us with the with the
intellisense part where it's a separate
parser and separate infrastructure and
then the compiler back-end so we have
Eclipse CDT and our extensions that make
heavily use of an own parser of C++ to
get a hold of the information it's so
intricate intertwined with with all of
that the CDT stuff that it's impossible
to disentangle that if you want to go
that way go with clang
and people have tried that as well I
have no idea you should ask
Chandler offline I believe any more
questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>