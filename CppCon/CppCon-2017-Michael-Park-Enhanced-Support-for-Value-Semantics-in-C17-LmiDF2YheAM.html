<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Michael Park “Enhanced Support for Value Semantics in C++17” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Michael Park “Enhanced Support for Value Semantics in C++17” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Michael Park “Enhanced Support for Value Semantics in C++17”</b></h2><h5 class="post__date">2017-10-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LmiDF2YheAM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Okay, thank you everyone for coming.
This is enhanced support for
value semantics in C++17.
My name is Michael Park,
perhaps better known as mpark.
I'm a software engineer at Mesosphere,
where we're trying to figure
out what it would look like
to have an operating
system in a data center.
Outside of work, I'm a member
of the C++ Standards Committee
and I am also the author
of the Standard Variant
Implementation in lib C++.
So, this is the agenda
that I have for us today.
We're going to cover the basics
of what it means to have value semantics
for some of us who may not
be familiar with the idea.
We're going to cover
three new library types
that were introduced in C++17,
which are optional, variant, and any
in that order.
Then I'll just go through a little summary
of what I think, how they
relate to each other,
and things like that.
So value semantics.
Before we get into value semantics,
I want to first talk about distinction
between values and objects.
So, it's important to note,
that when I say objects,
I'm talking about objects in the sense of,
in the C++ object model sense,
as opposed to the object-oriented sense.
So a value is an abstract entity,
most typically representing
a mathematical entity.
So things like integers and matrices.
Right?
We have, and they don't,
they're abstract, and so
they don't actually exist
at a specific location or time,
they're just exist as
an idea, as a concept.
On the other hand, an
object is a concrete entity,
and they exist to represent a value.
They are concrete in memory,
they're made up of a
sequence of bits in a type,
for us to figure out what those bits mean,
and they come in and out of existence
as times flows.
And so naturally, values don't
have an identity in memory;
whereas, concrete objects such as, sorry.
Objects, which are concrete,
have an address in memory,
and we can identify them.
And with this addresses,
is how we identify objects.
So we actually have formal
ways of describing this in C++
through value categories.
So values, as I've defined it just now,
is categorized as prvalues;
whereas, objects are
categorized as glvalues.
I'm not going to go into details
as to how the value categories work,
and what the conditions are,
but if you go to Nicole
Mazucca's talk on Thursday,
she's planning to talk about
object models in detail,
so she'll cover that there.
So for us, let's just
take a look at an example,
and figure out what I'm talking about.
If you put your C++ hats back on,
on the left we have 42, for
which we can't take a value.
Which we can't take an address, right?
Because it's a value, they
don't have an address.
On the other hand, on the
right we have int X = 42,
where we actually store that
value in a concrete entity
called an object,
and we can actually
take an address of that
and refer to it.
So what is value semantics?
Value semantics as a whole is
really a programming model,
in which we want to focus more on values
and operate on values
as opposed to objects.
And in order to enable such a model,
a systematic approach to deal
with these pesky objects,
which come in and out of
existence is necessary.
So these are two strategies
of managing objects
that we really care about,
at least for this talk.
The first one is deep-copy semantics,
and the second is automatic lifetimes.
So let's take vector as an example,
since that's everyone's
favorite type, right?
When you copy a vector,
you get an entirely separate copy, right?
You get every one of your elements
copied into a new vector,
and if you modify the
old elements, old vector,
your new elements aren't
changing, don't get affected.
And it effectively severs the relationship
between your new objects,
and your old vector object,
and that's what allows us
to actually perform local reasoning
with the state of the new
vector that was created.
Because you don't care what
happens to the old object
once you've copied it.
Automatic lifetimes,
also known as resource
acquisition is initialization,
is a technique where we achieve this
by binding the lifetime of the array
that's stored on the heap,
and the lifetime of the vector
object itself on the stack,
which is managed automatically.
And so, we can have the heap get managed
by the lifetime of the stack,
and we can bind those lifetimes together.
So some benefits.
Why do we even care?
So first thing is that value semantics
is the default mode in C++, right?
It's been promoted for a long time,
and as a community, we have
a lot of experience with it.
The fact that the compiler tries so hard
to generate special
member functions for you
is indicative of how badly C++ wants you
to use value semantics.
And we don't get a lot
of defaults right in C++,
but I think this one is the
big one that we got right.
And without value semantics,
trying to read an academic paper,
which typically is written
in some form of mathematical notation,
and transforming that to a
program without value semantics
is typically very difficult.
And it's very difficult,
not because the algorithm
is particularly complex,
but you have so much more to worry about
than the algorithm now, right?
You have objects that
you have to deal with
in terms of like how to
deal with their memory,
lifetimes, their memory
management, and all that stuff.
It's a lot of burden
that isn't really actually
related to the problem statement.
And so, what that means is,
getting value semantics,
and getting closer to
mathematical notation
actually facilitates us
in reaping the benefits
of the existing work that's happened
in mathematics and computer science.
The next thing is
referential transparency.
So we really get this
from performing deep
copy semantics, right?
When we copy a vector, we get a new copy,
and we can manage to not
perform non local reasoning
all over your code base,
and performing non local
reasoning is, I think,
one of the hardest things
to do in programming.
And, so deep copy semantics
actually helps us increase opportunities
for local reasoning in our programs.
And we also avoid pesky issues
like manual memory management
like we see in vector.
And all three of the
types that we'll see today
bring value semantics to constructs
that you already know about
in the language today.
So this brings us to optional.
As I mentioned, optional was added
to the standard library in C++17.
The design was largely
based on boost optional,
which was introduced in 2003,
and boost version 1.30.
So the conceptional model for an optional,
is that it represents the
notion of an optional object.
Put another way, we can also say
that it models a discriminated
union of T and nullopt_t.
Nullopt_t is a tag type that indicates
that the optional does not hold a value,
and so by discriminated union, I mean that
it can hold either a T or
a nullopt_t, but not both.
Another way I like to think about it
is that this is actually a pointer to T,
wrapped up into a value type, right?
So if we think about how this looks
as illustrated by this diagram,
I've declared some pointer
P to some random type T.
It points to nothing at the moment,
and then we can create a new instance of T
and assign it to P,
and P points at T, and
this is what we have.
Now if we move it over to optional,
what we see is that when
we declare an optional,
now this thing needs to hold,
is required to hold a value in place.
So the optional needs to be as big,
at least as big as the largest,
in this case, it has to
be at least as big as T.
So it's going to be, it's
going to increase in size,
namely as big as T,
and then we're going to store
the T inside the optional.
Are we cool on that?
Okay, so here's a quick
overview of the API.
I've got optional string x here,
which gets assigned the string hello.
The first assert is going
to use the operator,
the implicit conversion the bool
to test for whether the
optional holds a value or not.
The second assert is
using the operator star
to perform unchecked
access into the optional.
So we're going to get the
string out of the optional,
and test for, test that we have
the value that we expected.
There's a second set of APIs.
The default constructor for optional
will default construct
into the disengage state
where disengage means the
optional does not hold a value,
and we can use the has value function
which performs exactly the same operation
as the implicit conversion the bool.
The value or function is used to
used to provide a default value
if the optional happens
to not have a value,
then give me back this default value.
One thing to note here
is that the value or will actually copy
or move the value out of the optional.
Right, so typically if you
go to access an element,
sorry a value inside an
object, inside an optional,
it's going to get you back
a reference to that value;
whereas, value or will actually give you,
not a reference, but a value.
Okay?
Alright, and the value
function is checked access,
and so what that means is if
the optional doesn't happen to
actually store a value,
then it's going to throw an exception.
Specifically it's going to throw
the bad optional access exception.
And as I mentioned, optional
has value semantics,
as well as everything we're
going to talk about today,
so if you assign x into y,
then we're going to, we're
performing a deep copy assignment
and y no, holds a value now,
and it's going to hold
the same value as x.
And the comparison will
also be deep as well.
And most importantly, automatic
lifetime we talked about
an optional knows how to
destruct the string properly.
So I want to talk about some use cases
where you can actually replace
some existing practices
with optional,
and the three use cases
that I want to cover are
optional return values,
function parameters,
and data members.
So first let's talk about magic values.
A magic value is a valid value of type T
that is used to indicate
the absence of value T,
the absence of a value of type T.
So that should sound weird,
and should be concerning.
But we actually have this all over,
we see this all over the place, right?
We have, some of the examples
are we use negative one,
we use string npos, we
use an empty string.
We also use the end iterator
for somethings that aren't
necessarily range related.
Sorry?
(audience member asking question
outside microphone range)
I couldn't hear you.
- [Audience Member] N-A-N.
- N-A-N?
Oh yes, right, right, right.
Yeah. The comment was that the nan
the nan value for double is
also another special value,
and we'll talk about that one later.
So some of the problems.
It's really easy to miss,
and the reason why it's easy to miss
is because it doesn't
show up in the API, right?
When you see a function that
takes an int and returns an int
it's really difficult to tell
that that int that you're getting back
might not actually be an int, right?
And if we're lucky, maybe
it'll be in the documentation,
but people are bad at writing
and reading documentation,
so I'm not all that hopeful about that.
And secondly, we don't always
have a value that we can steal, right?
If the function F takes,
if the function F's return
value, let's say is an int,
and all of the values
of int are valid return
result of that function,
then which value do you steal?
We don't always have this option.
And we have an example of this, right?
We have strtol, which is a function that
tries to convert a string into a long,
and every value of long is
a valid result of strtol,
and so we return zero for
variations of the string zero
with spaces in it, or whatever,
as well as situations where
you can't actually convert,
convert the string into a long.
And yeah, it starts with
a value, an error node
to communicate the error,
and the user is required
to know about this,
and this is even more subtle
than knowing about the magic value
and trying to check for it.
Okay.
So this is an example, this is
actually my favorite example
of where this becomes a problem.
So in this code, I have a fork call,
where we're going to fork
the process that we're in,
and as you probably
know, we get back a pid,
and we can test for the
value of the pid to say
if it's zero, then I'm the child process,
and if it's a positive number
then I'm the parent process.
Now fork can fail, so when fork fails,
fork will return negative one,
as most Unix functions do.
So we have negative
one, we check for zero,
and we get it through this else,
and we think we're a parent
except we failed actually,
but we're going to proceed and
try to kill the child process
which we failed, so pid
is actually negative one
in this case.
So what happens when you
call kill negative one?
Does anyone know?
(audience members
answering over each other)
Kill yourself. No that would be better.
Kill all.
If pid equals negative one,
then sig is sent to every process
for which the calling
process has permission
to send signals,
except for process one, init,
but see below.
See below, what?
I mean, this is what's below.
Right, we killed every
process in our machine.
So what happened?
Well, we got a negative
one back from fork,
which meant that it failed.
And then we propagated
that value, accidentally,
through the kill function,
and the kill function
said, oh negative one,
oh yeah that means everything.
So there's this completely
different interpretation
of negative one by what fork
meant, and what kill meant.
Right, it's kind of weird that kill
would even take a negative one and say,
rather than meaning nothing,
it means everything.
Okay.
Let's see if I have
covered everything here.
Alright, so the accidental
propagation of magic values
is what's so dangerous here.
So let's talk about
optional return values.
So here I have a parse function
that's going to take a string view,
C++17, fancy stuff.
We're going to take the
result type explicitly,
and we're going to attempt to
parse this string into a T,
and that's what this function wants to do.
So okay, what happens if sv
cannot parse a string into a T?
The current solution is that,
at least I know about
that I'll review right here,
is that one is obviously to
throw the store exception.
Two, we could return a smart pointer,
or a dumb pointer, whatever,
some pointer to T.
We could return a pair of T comma bool,
where the bool indicates
whether the T is valid or not.
We could return a bool
and take a T ref as the out-parameter.
There are drawbacks to
all of these approaches
that I'll iterate through quickly.
So throwing an exception
doesn't really fit well
if we don't consider it an error.
Right?
Let's say I want to try three
different types of parses,
and if it fails, it's not a big deal,
I'll just move onto the next one.
Getting through an exception,
is essentially using these
exceptions for control flow,
and we frown upon that.
Number two, if we return a pointer,
then immediately we lose value semantics,
and we accidentally also
pay for heap allocation.
Pair T, bool.
This one's interesting.
The T always has to be constructed,
which means that oftentimes
we end up adding default constructors
to types that we didn't really want to.
So the other, so that's one
thing that we don't want.
But the other thing is that,
the interpretation of
what pair T, bool means
is actually ambiguous, right?
So what I said is that pair T, bool,
if bool is set, then T is a valid value,
and we can use it.
If bool is false, then
it's an invalid value,
and we can't use it.
Well map insert returns
a pair iterator bool.
Well what does it mean?
Does it mean that when the bool is false,
that the iterator is invalid,
or the object that the iterator
is pointing to is invalid?
No.
If the bool is false
coming out of map insert,
it just means that it wasn't the object
that you had tried to insert
that I'm pointing at right now.
So it's always a valid iterator, right?
The interpretation of what pair
T, bool means is ambiguous.
And the last one.
This one may be the most obvious one,
still needs to be default constructed,
or constructed into something,
and it leads to a very awkward API.
So what happens if we introduce optional T
as the return value?
Well we don't have exceptions,
we maintain value semantics.
By value semantics, I mean when we copy,
we copy the whole value
and it manages lifetime.
We don't get heap allocation
because optional is not allowed
to perform heap allocation.
T is only constructed if needed.
And the intent is clearer,
and we get a clearer API, cleaner API.
And I say cleaner because
I can't really call it a clean API,
and the main reason for that is because
trying to propagate the optional returns
through a for loop, through lambdas,
through different function calls,
is very manual and explicit.
Which oftentimes explicit is good,
but verbosity is another concern.
Optional function parameter.
So if you have a function parameter
that has, that takes a type by value,
so in this case we have some function f,
taking a light by value,
and we can transform that
to take an optional light,
and this will take an existing optional.
It will also take an instance of light,
and it will just convert it,
and within function f,
you can handle both logic.
It's kind of nice.
But what happens if we
have some heavy object?
And we're using const ref
in the function parameter
because we want to avoid copying
because the thing is heavy?
I've seen this code a lot,
and I'm not sure that everyone
understands the implication of it.
So if we just transform the
heavy there into optional heavy
where the cost ref is on the outside,
what happens if we pass an
instance of heavy directly?
Well we're going to perform
implicit conversion from heavy
to optional heavy,
and then we're going to
bind to the temporary
optional heavy that was constructed.
And the heavy needs to,
and the optional heavy actually
needs to store the value
internally,
and so we're actually
going to incur a copy,
or a best of move,
in this case.
So this can actually be a copy,
so watch out for that if
you're making transformations.
Optional data member.
I have some person class here.
First name, last name are mandatory,
and some people don't have middle names.
I don't have a middle name.
And I've also been lying to you guys.
My real name is not actually Michael.
My real name is is actually Chanyoung,
and that's my Korean name.
That's my legal name.
So I need to submit some forms
to register for a new name,
add a middle name, or whatever.
And once that process, then okay, fine.
Then I can actually get the name Michael
as my middle name.
Show you a few more things.
Relational operators.
We haven't talked about them much at all,
but they're important.
Because there are some subtleties here.
So nullopt_t, as I mentioned,
is the tag type that represents
the empty state of an optional.
And it compares less than any T.
And that's, sorry.
So the nullopt_t being less than anything
makes optional, by default,
tor orderable, right?
And so what that means is that you can,
practically what that means
is that you can toss optionals
into a map, for example,
and then operate on
them as if they were Ts,
and have nullopt_t as just another value.
All the operators compare
the engaged-ness of optional
then defer to corresponding operator T.
So what this means is that
you can't just define
operator equal equal,
and operator less than,
and try to get away with it.
Because a lot of other types
will actually do the
inverse for you, right?
Whereas, optional T, if
you perform a greater,
operator greater than,
then it's going to actually
invoke operator greater than
on your T,
so if you're going to use
optional T for some T,
you have to define all
the relational operators
if you want to use them.
And mixed comparisons are allowed.
Optional T of optional U are allowed.
You can compare also,
optional T to optional.
Optional T to some value U.
And the optional T and U comparison,
the last one there that I showed
is actually really dangerous,
and we'll see an example of that.
The only benefit that I know of
that comes from the
optional T to U comparison,
is when you're doing heterogeneous lookup
on associative containers.
So if you have an optional
T inside of a map,
and you want to just lookup by using a T
without having to construct an optional T,
like we saw in the
functional parameter example,
for instance.
Then you can use this comparison operator
to actually perform that comparison,
but it's
it's a questionable use case, I think.
So I talked about relational
operators being there
in order to allow storing in containers.
So, yeah.
- [Audience Member] I have a question
about the comparison.
In one of your earlier slides,
you were comparing optional
string to construct star,
is that safe?
- Yes.
- [Audience Member] Isn't
that optional T to U?
- It is. Right, but there's.
Oh, so sorry. The question was
I had an example, where
I had an optional string
comparing to a construct star,
and is that safe because that's clearly
a optional T to U comparison.
And the answer is that,
in that particular example it is safe,
and we'll go through an
example where it's not safe.
So storing in containers.
So what I want to do here,
is vote on ice cream flavors,
and this is the flavors that are available
at my favorite coffee,
sorry ice cream shop.
Excuse me I live in San Francisco.
They're pretty elaborate flavors.
But some people don't like ice cream.
Okay, so then they don't have
a favorite ice cream flavor.
I don't understand it, but fine.
We'll make an optional
ice cream flavor for them.
And we want to take the votes,
let's say that we're storing in a vector
of optional ice cream flavor,
and we want to collate that into a map.
And we can just iterate through the votes
and insert it into a map in increments.
And this works because you can
compare optionals to each other,
and a map will just use that operator,
and you'll be fine.
Okay, so this is the example
where it's not safe.
So optionalizing, by
optionalizing, I'm talking about
transforming a T into an optional T,
and I thought I made up this word,
but Miriam Webster says
it's actually a word,
so okay.
So this example,
I have a car instance,
and I have some max speed,
and that's in kilometers per hour
because I'm Canadian.
It's going to have a get speed function
which will return the current speed
in kilometers per hour.
And we have some function
that determines whether
we can accelerate or not.
And imagine this is some self driving car
that determines whether it
can speed up or not, right?
So we can say get speed
less than max speed,
trivially correct.
Now the speedometer might be broken,
what do we do?
We can't just stop operations
just because the speedometer's broken.
Maybe we just don't speed up, right?
So let's say we make that be an optional,
and we return a nullopt if the
speedometer is not functional
and let's say that we don't know
about this use of of can accelerate.
Now we're going to invoke the behavior
where we have optional T less than U.
And because nullopt compare
is less than everything,
we'll say yeah, we can accelerate.
If your speedometer is broken,
you can't accelerate.
This is not good.
So my recommendation here is
that when you're making the transformation
from T to optional T,
either introduce an intermediate type,
which tries to delete
the relational operators,
so that you can catch
the instances of these
and make sure they're correct.
Or be really careful.
But at least I wanted you
to be aware of this problem
so that you can look out for
them if you run into them.
And here's a summery of the
delta from boost optional,
for those of you who
may be really familiar
with boost optional.
Most of them are just
incremental improvements.
The one that I find is the most important
is probably the forwarding constructor.
Boost optional doesn't have
a forwarding constructor,
and what that means is my
example of saying optional string
x equals string literal
doesn't work in boost;
whereas, in C++17,
that example will work,
because we'll forward the string literal
onto the string constructor.
I'm not going to go through all of these,
but this brings us to variant.
And let's see, where am I?
Okay.
So the conceptual model for variant
is that it's a type-safe union.
The way to look at it is that
it's a discriminated union
of the type that it was given.
And another way to look at it,
that I like to look at it,
is that it's an abstract base class
wrapped up into a value type.
And I'll show what I mean
by illustration here.
So again, we have some shape S,
and we construct a
circle and assign to it.
And on the variant side,
similar to optional,
it's going to store the value in place,
so the variant is going to be
at least as big as the
largest alternative,
and then we're going to store the circle
inside the variant.
Quick overview of the API.
I have variant int string
assigning a string literal,
that's going to initialize
the string alternative.
We have a holds alternative function
which tells you
whether the variant is holding
the type value that you asked.
The get function is a checked get function
which gives you access into the value
that the variant is holding.
Variant default constructor.
I don't want to get too deep into it,
but variant default constructor
is enabled if the first alternative
is default constructable.
So in this case, when I
default construct a variant,
we're going to initialize the int
and default construct that to zero.
We have the index function to check
which alternative is currently active.
Not particularly useful
unless you're writing some
kind of generic program.
And a get if function,
which is another checked access,
except it gives you a pointer failure
as opposed to throwing an exception.
So throwing an exception,
the get function is a checked access
that will throw an exception upon failure.
And again, value semantics,
constructor called correctly.
Use cases.
These are the three cases
that I want to cover.
We have union like class,
flat, closed class hierarchy.
Closed in quotes.
And visitor pattern.
So this is what a union
like class might look like.
We're going to implement
an animal hierarchy.
It's a generic example
so that you can relate
to it, perhaps easier.
So we have cat, dog, horse,
and we're going to create
an animal hierarchy,
a flat hierarchy.
And we're going to use a
union to store the values,
and use an enum to keep the discriminator.
Then we can destroy the objects correctly,
construct correctly, et cetera.
And with that in place,
we can implement this get sound function
completely outside of the
class definition, right?
We can switch onto animal kind,
and then look into the values
and do whatever we want with it
to implement this get sound function.
Now this code is, this
is a lot of code, right?
This only supports
construction and destruction.
We don't support copy.
We don't support move.
We don't support accessors,
assignment, visitation,
et cetera.
So after we add all of that,
we would get value semantics.
We are able to add new
algorithms non intrusively.
What I mean by that is
the animal class doesn't have to change.
But it's error prone due
to the manual pairing
of enum and the value.
We have to get the enum and
the access into the value
matched up perfectly,
otherwise we have a bug.
This is probably a example,
perhaps more familiar to people.
In this, we have an abstract
base class called animal,
and we have three classes
that heir from it,
cat, dog, and horse.
We're going to implement the
virtual function get sound.
So immediately, well
we lost value semantics
because we can't be passing around
inheritance hierarchy like
this without a pointer.
We incurred dynamic allocation,
where we have to manage the memory.
Yeah, we can use
a unique pointer and shared
pointer for that now,
but it's still a memory
you have to manage somehow.
Dual citizenship is difficult,
and by dual citizenship, I just mean
membership in multiple hierarchies.
And that leads to multiple inheritance,
and yeah.
Not a lot of people like multiple
inheritance, me included.
And it's intrusive to add new algorithms.
So to add a single algorithm,
we have to actually go to
every subclass of animal,
and add a separate function.
When you're trying to reason
about the get sound function,
you might have to open
up 15 separate files,
and jump across them to see,
oh is the get sound
thing really a mistake,
the correct thing.
So it's grouped by type
as opposed to algorithms,
and sometimes you want
them grouped by algorithms
so that it's easier to
see what's going on.
So if you want to learn more about
why classic polymorphism is not great,
Louis has a talk on Thursday
that you can go and check out.
Visitor pattern.
So visitor pattern exists for a long time.
A lot of people have used it in the past,
and this is kind of the ceremony
of how to set it up, right?
We forward declare the final classes,
we declare the abstract visitor,
then all the final classes
define their accept functions
where they pass along themselves,
so that we can figure out
what the final type is.
And then the usage of it,
of using it with get sound
would look like this.
Where we define a get sound visitor,
which inherits from the base visitor,
and now we can't actually
return the result directly
because the visitors can't
return results directly,
so we have to have this
intermediate result thing
that we propagate the result out to.
It works.
It allows us to,
so yeah we got back the ability
to add new algorithms non intrusively,
and that's more or less
all we get with it.
It's a lot of boilerplate, right?
The ceremony was a lot.
And it's also inefficient
because we have to do two jobs.
So here's what it looks like with variant.
We have cat, dog, horse,
variant cat, dog, horse.
We're done.
We need help with the get sound function,
we use the visit function,
which allows us to write
essentially the same code
as what we were writing for visitors.
So what did we just do?
Well we got back value semantics
because variant has value semantics.
It's going to store
cat, dog, or horse fully
within it's object.
You can add new algorithms
non intrusively,
as we just saw.
No manual pairing of the
discriminator and the value.
Dual citizenship is easy.
If you want horse to be part
of a transportation hierarchy,
toss it in there, and it's just a horse.
There's no association with
either of the hierarchies.
It just exists.
One minus.
Maybe there's a code bloat.
I haven't actually seen this in practice,
but having four pluses
seemed overly optimistic.
Alright, a few more things,
and it's not all pretty, right?
Because we're going to talk
about valueless by exception now.
So valueless by exception state
happens if an exception is thrown
during a type-changing operation.
So if I have a variant T, U,
and I'm in the T state,
and I try to assign a U,
and what we're going to do
is destroy the T, try to
construct the U in place.
If that throws, well, we have nothing now.
What do we do?
So there were probably,
I want to say probably around 2,000 emails
sent around in the internal mailing list
in the standards committee
as well as a public forum
that I started the fire on accidentally,
to discuss what to do here.
There were options like double buffering,
always making a variant be emptiable,
and what we got is, a
rarely empty variant.
So if all of your types
are noexcept movable,
then you can't get into a
valueless by exception state.
How many people think this is true?
How many people wish this was true?
Alright, not a lot of people, okay.
So this is not true.
Any variant can actually get
into a valueless by exception state,
and this is quite unfortunate, I think,
so if we have some nasty struct,
that implements the
implicit operator to int,
we have a variant int float,
which we think is innocent.
Neither of them can
throw their construction,
except we can, right?
We can have this nasty object
when we try to emplace,
it's going to throw
during an attempt to construct an int.
Sad.
Okay, well, so in what situations
do we actually have to deal with this?
Well you already had an
exception thrown, right?
You would have had to
catch some exception,
and then you would have to
proceed to ignore that exception
and leave the variant in a
valueless by exception state
in order for it to have
left the catch clause,
so my recommendation is
don't let valueless by exception state,
leave the catch clauses.
So if it ever were to happen,
keep it inside the catch clause,
reset to an some dummy state or whatever,
but don't let it propagate.
And let's not be checking
for valueless by exception
everywhere, right?
Not every function
needs to check for valueless by exception
at the top of its definition.
And my argument for this is pretty simple.
When you get a reference
to an int in a function,
alright?
Can you check whether that
thing is uninitialized?
No there's not even a way to do that.
But if you were to use it,
it would be undefined behavior.
So there are some cases
where we don't even allow you to check
for what the state of
the object you've gotten.
Another example that came up earlier
is that nan is a magic value,
and if you get a double,
inside every function that takes a double,
do you check for nan?
If you check for nan,
if you're the type of person
who checks for nan in every function,
alright, yeah, go for it.
Use, check for valueless
by exception everywhere.
But if you're the type of person like me,
who kind of trusts others
and assumes that doubles
probably aren't going to
be nans all over the place,
then we really don't need to be
checking for valueless by
exception all over the place
for variants either.
Let's cover a few more things.
Monostate is similar to boost blank
if you're familiar with that.
As a first type, it makes any
variant default constructible
because variant will try to
default construct the first type
and monostate is default constructible,
so if you need your variant
to be default constructible
when you don't have anything else,
when none of your types
are default constructible,
toss monostate in there,
and it will become default constructible.
It's a unit type to add an
empty state to a variant.
So it allows you to,
so variant is supposed
to be a distributed union
that holds exactly one value
of the given types, right?
And in this case, we want
to actually explicitly
add an empty state,
because we have some situations
where it could be empty
and it makes sense for our case.
And the existence of
monostate doesn't change
any behavior for variant.
So it's not going to say,
oh, you have a monostate,
so when I throw an exception,
I'll try to see if I can
construct that monostate instead
to give you some more
deterministic behavior.
There's no special casing
for monostate whatsoever.
Monostate just exists outside of variant,
well it happens to live
in the variant header
for not a great reason, I think,
but it has no association
with the variant class itself.
The forwarding constructor
I think is also interesting
that I should tell you about.
So in this case, we have
some variant T0, T1, T2.
I don't know what T1, T0, T2 are.
They can be, they can't be references,
but they can be class
qualified for example.
So I have some foo,
and I want to initialize
it with the result of foo.
I don't even know what
the result of foo is,
so which alternative is chosen?
There must be some
sequence of steps we take
to figure out which
alternative is chosen, right?
So this is what we do.
We have some ID class here,
which just saves the type
and not construct anything.
We're going to have this fun class,
which is the, has operator overloads
for T0, T1, and T2,
and we're going to attempt
to call this function
with the result of foo,
and whatever comes out is the winner.
So when you have variant T0, T1, T2,
and you're wondering,
how do I initialize,
which one of these wins
through what algorithm,
it's overload resolution.
So toss them all linearly,
vertically in an overload resolution,
and figure out, well
that's a whole different
set of steps you need to study,
but at least it's leveraging one another.
Okay, so let's take a concrete example.
We have string, we have a bool.
We try to initialize it with
a string literal A, B, C.
What's the result here?
We're performing overload resolution
with string and bool as candidates,
and we're trying to invoke
it with a const char array.
Which one wins?
Bool.
Yep.
So here's Eric's opinion about that.
Variant string bool initializes
the second alternative.
Yeah, okay I agree.
Here's a Delta from boost variant.
The important parts here
that I've bolded are dynamic allocation
during type changing operation,
and valueless by exception,
which I essentially tied together,
but I thought would be worth pointing out.
Reference type support is
not in the standard version;
whereas, boost supports reference types
and some other ones.
I don't think the other ones
are all that important, actually.
Excuse me.
Okay, so shameless plug here.
If you want to use variants,
and you don't have C++17.
Let's say you were back in C++11,
Mpark.Variant is a
library that I've written
to make variant more available for people,
so this is C++17, standard conforming,
backforwarded to C++11 and 14.
So feel free to reach for that
if you don't have access to C++17.
Last type of the day.
We have any.
So the conceptual model for any
is that it's a type safe void star.
I don't actually have really
good use cases for any,
but I'll show one.
And another way to look at it,
is that it's a void star
wrapped up into a value type.
So again, another illustration
that we have some pointer v to void
pointing at nothing.
We can point at anything.
And on the any side,
we're going to,
actually have the same picture.
So any doesn't hold the value in place,
because, well, how big should it be?
It should be able to hold anything.
So it actually holds a pointer.
It's allowed to do small
object optimization,
but in general, it's going to create,
sorry it's going to
perform dynamic allocation
to be able to hold
anything that it needs to.
Okay, well, so what's the point then?
Well the point is that any keeps track
of the type that it's actually storing.
So if you pass around a void star,
and you cast it to
whatever you need it to be,
you have no idea whether that's
the final behavior or not,
and void star has no idea
what it's pointing at;
whereas, any will actually keep track
of the type that it's holding,
and when you go to access
your value out of the any,
if you get the wrong one,
it'll at least give you an error.
And as the other two types,
we have value semantics,
so if you wanted to pass
around arbitrary data
through binary boundaries,
and you wanted to have value semantics,
and not have to manage memory,
then you could use any for that.
So,
here's another overview of the API.
We can have any x.
Notice that this is no
longer a string literal,
because if it was a string literal,
then any will decay that
into a pointer,
and store the pointer instead.
So I've got the string, the,
well string literal.
The x suffix,
which constructs a temporary
string out of a string literal
will allow us to actually
store the instance of string
inside of an any.
Any has a has value function,
similar to optional,
but it doesn't have an
implicit convergent to bool.
You can use any cast
to get the value out of the any.
In this case, we're getting the string,
the reference to string,
and then we can compare
for the expected value.
Any is default constructible.
It will hold nothing.
The type function will
return type ID of void
if it holds nothing,
and if it's holding something,
then it's going to return type info
of the type that it's holding.
And there are two forms of any cast.
This form of any cast
that I'm showing here
is the pointer version,
and it works similar to dynamic cast.
So in dynamic cast, if
you give it a reference,
and you get a reference back,
if it fails, throws an exception,
if you give it a pointer,
you get a pointer back,
if that fails, you get a null pointer.
So those semantics are similar,
except any cast doesn't say,
give me int pointer,
it says int,
and you get and int pointer back.
This is not how dynamic cast behaves.
You don't ask dynamic
cast to give you an int,
and it gives you an int star back, okay?
So that's the minor quirk,
I think that you should be aware of.
Any cast is checked, as I mentioned.
So in the y case, I'm
not holding anything.
Try to get an int out, can't do that.
We'll throw a bad any cast exception.
Again, illustrating value semantics
where the string actually
gets copied over deeply,
and any doesn't provide
any relational operators.
And as always, automatic lifetime
destroys the string correctly.
Yeah, use cases, I only have one.
And I categorize it like this.
If and when a template can't work,
and you can't use a variant.
So what do I mean by that?
Where could you not use a template?
Getting through the
virtual function, right?
A virtual function can't be made template,
and so you can't just pass arbitrary data
through a virtual function.
And let's say variant isn't enough
because it's actually truly open
to whatever type of
value you want to hold.
So in this case,
we have some consumer class
and a virtual notify function,
and we could use any
to pass arbitrary data
through the virtual function.
This is a delta from boost any.
Not much.
Boost any, I'm sorry instead any
is mostly boost any kept in tact.
There weren't much that happened
between those.
And honestly I think it's because
not a lot of people use it and need it.
So here are some minor differences
that I found.
So here's a summary of what we saw.
These types that I introduced today,
well that we introduced today.
That we introduced in
C++17 have value semantics.
And I mentioned that these
are the corresponding
reference semantics that
exist in the language today.
And the number of possible states
of each of these types
look like that.
So optional T.
The number of states in which
that optional T can be in,
is the number of states
in which the T can be in,
plus the nullopt state, so plus one.
The variant Ts.
If you have variant T, U.
The number of states that you can be in
is the sum of the number of states in T,
plus the number of states in U.
So this is that described
in C++17 fold expressions,
because why not.
And any, the number of states is infinite.
You can literally hold anything,
so I have, there's no bound
as to the number of states of an any.
So this is my summary
of how I think these
three things are related.
I'll point out again,
that optional and any can be empty;
whereas, variant can't be empty,
but it can be valueless
by exception state.
And this is the last thing I'll say,
which is the empty state
and the valueless by exception
state is really different
in that, you don't, for example,
when you visit a variant,
if your variant has an empty state,
you need to handle that
empty state in your visitor;
whereas, the valueless by exception state
is not a state that you actually add.
It doesn't appear as
a case in your visitor
because it's an invalid variant, right?
As opposed to an empty state,
which is actually a valid,
perfectly valid state
that you actually are benefiting from.
So that's everything that I had today.
Oh, one more, okay.
So order of preference.
When you're choosing which order of these
do you think you should reach for,
I think you should go
for, start from optional,
see if that'll work, you
have too many alternatives,
you should try to use a variant.
If that fails, then use an any.
So I think that should be
the order of preference here.
Okay, so that's everything I had.
Any questions?
I think we have ten minutes left.
Perfect.
Do I just, like conduct this myself?
I guess, okay.
- [Audience Member] So
for a variant of T, U, T,
the forwarding constructor,
does it just --
- Before?
- [Audience Member] Your constructor
that was the forward constructor.
Does it simply, as you're trying
to figure out the algorithm
which to construct, which ID of T.
- Right.
- [Audience Member] Is
it the first index of T
that you end up with?
- No, so if you have duplicates,
and you have, and you try
the forward constructor,
the forward constructor
is actually the safe,
so the question is,
if you have duplicate types,
for example if you have variant T, U, T,
and then you try to use
the forward constructor.
Let's say you try to initialize the T,
initialize the variant T,
U, T with an instance of T,
what happens?
What happens is, it doesn't compile.
It doesn't just magically
initialize the first one,
or anything like that.
- [Audience Member] Great. Thank you.
- Yeah.
- [Audience Member 2]
Alright, so I see that
the standard vocabulary types,
as opposed to boost,
don't support references
as a parameter.
I know that, you know,
technically it will
never store a reference
as a reference is not
a destructible object,
but is the solution right now,
in the standard to use
explicitly a reference wrapper
or a similar type,
if we want reference semantics?
- Yeah, so the question is,
why is, or the vocabulary types,
these I think refer to,
qualify as vocabulary types
don't seem to support reference types,
or references directly.
Is the recommendation
to use reference wrapper
for when you need references?
And the answer is yeah,
but it's not good enough.
At least in my opinion.
But the answer is consistent
throughout the library, right?
So this is one of the questions that I had
when we first considered
references an optional in variance.
Why is it good enough for us to say,
well if you have a vector,
and you want references in there,
then use reference wrapper,
but for optional and variant,
it's not enough, right?
So I think it should still be consistent,
but the part where I say
reference wrapper is not good enough
is that if you, for example,
have a function parameter,
and you want to say optional
reference wrapper int, right?
Because reference wrapper deletes
the rvalue reference constructor,
I can't actually pass
temporary ints to that.
Right, this is not what you expect
from a regular, well
const T ref signature.
Right, you should be able to pass rvalues
to that as well,
so I think yes, that's the recommendation,
but I don't think it's sufficient.
Does that answer your question?
- [Audience Member 2] Yep.
- Okay. Ben.
- [Ben] Hey Michael.
- Hi.
- [Ben] This might be an
implementation question,
but is there any size overhead
of an optional T over T?
- Any, sorry?
- [Ben] Any size overhead.
- Any size overhead to the --
- [Ben] Yeah, in the optional T.
How much bigger than
the T is an optional T?
- So from the implementation,
is that of, so, sorry.
The question is how much
size overhead is there
for an optional T compared to a T.
From the implementations I've seen,
it's generally just a bool,
which, with alignment might
be bigger than just a byte,
so yeah, there is size overhead,
and there is some ideas
to figure out how to
steal one of T's values
so that we don't get that size overhead,
but still provide optional,
optional like API.
But yeah, optional as it stands today,
does have a, typically
just a bool overhead.
- [Ben] We're pushing
the magic value problem,
is now the implements' problem.
- Essentially, well except
the user has to tell us
which magic value they want us to use.
Right? Because we can't just guess.
It might be a valid value for them,
so they have to tell us which one to use,
but aside from that, I think
the API could stay similar.
Yeah.
Hello.
- [Nicole] Hi Michael.
- Hi.
- [Nicole] I just wanted to say,
as to the optional ref thing,
- Yep.
- [Nicole] You all should come to my talk
on Thursday,
because I will talk about that.
- Okay, cool.
So there's a talk on Thursday,
what's your name?
- [Nicole] Nicole.
- Oh, there's a talk on Thursday
with Nicole that I mentioned, yeah.
So she'll be talking about
optional object lifetimes
and stuff like that,
and optional references as well.
Cool?
- [Nicole] Why it makes sense,
and why the C++ community
should support it,
and how you have to think about references
in order to get those.
- Why it makes sense.
Why the C++ community should support it,
and what was the last part?
- [Nicole] How you have
to think about references
in order to support it.
- Ah, how you have to
think about references
in order to support it.
Okay, see you Thursday.
Hello.
- [Audience Member 3] Hi.
My question is, you mentioned
there's an invalid state
to the --
- The invalid state?
- [Audience Member 3] The
empty state, so to say.
- Over variant, or optional?
- [Audience Member 3] For variant.
- Variant, okay, yeah.
The empty state, or the
valueless by exception state?
- [Audience Member 3] Excuse me?
- The empty state,
or the valueless by exception state?
- [Audience Member 3]
Yes the valueless by --
- Okay. Yep.
- [Audience Member 3]
What happens if you visit,
try to visit it while it's in that state?
- Yeah, so if you try to visit
a valueless by exception state,
it will throw a bad
variant access exception.
- [Audience Member 3]
Okay, so it's another,
you had an exception to begin with,
and then if you try to visit it --
- Right, so yeah.
So you had an exception that was thrown.
You got into the valueless
by exception state,
and then we escaped the catch clause,
or maybe within the catch clause
if you try to visit it,
if it's, and then it'll throw
another exception out of that.
- [Audience Member 3] Okay. Thank you.
- Hello.
- [Audience Member 4] Hi.
What is the state if I,
regarding the double buffering
problem for optional?
Do we have the same problem there,
or what happens if I assign a value,
do we throw an exception
when we assign the new value?
- Sorry, double buffering
for optional, did you say?
- [Audience Member 4] Yeah.
So I mean, what's
happening if my optional,
I assign a value, and the
assignment throws an exception?
- Oh, I see, I see, yeah.
So this is actually part of my abstract
that I didn't actually cover in the talk.
The subtle difference between optional T
and variant nullopt t, well
variant, nullopt, and T.
If the optional is in the T state,
and we try to initialize, assign to it,
we don't have this problem in optional
because our alternatives
are only T and nullopt_T.
So whereas a variant would
actually go into an empty state
if we were storing a T,
and we tried to assign a
empty state and we throw,
we go into a valueless by exception state.
An optional would actually
stay in the T state.
Yeah, Michael.
- [Michael] Okay, so since
valueless by exception
is clearly a state that's
known to the object,
is there a reason that a
type, like monostate type,
but a valueless by exception type
wasn't just decided to
be held by the variant,
and used.
I'm sure there was reasoning behind that.
Do you know what the reasoning was?
Like why not construct
the variant on failure
with some type that
represents a valueless type?
- Right, so the question is,
why doesn't the variant inherently have
a valueless by exception state?
And I think, what happens if you do that,
is that a variant implicitly
has an empty state.
- [Michael] Correct.
- Right, and so it becomes a
valid state of the variant,
and it's embedded into the variant now,
and yeah it's a type you have to cover
when you visit it, for example.
- [Michael] Well you have to cover
the exception when you visit.
- You have to?
- [Michael] Cover an
exception when you visit.
- You have to cover an
exception when you visit?
- [Audience Member 5] You
can't write an overload
that takes the exception.
- [Michael] No you can't, that's right.
You can't write an overload
that takes the exception.
That's my point, actually.
- Okay, I think I'm out of time,
and so we can talk offline if that's okay.
- [Michael] Yes.
- Alright, great.
Okay, cool. Thanks everyone for coming.
(applause)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>