<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Michael Caisse “Boostache Exposed : the internals of Boost's template engine&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Michael Caisse “Boostache Exposed : the internals of Boost's template engine&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Michael Caisse “Boostache Exposed : the internals of Boost's template engine&quot;</b></h2><h5 class="post__date">2015-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8zVqbLeG-vw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">if you're in YouTube land and you don't
have a boost Asher and you want when you
should be showing up to conferences
there we go now my name is michael case
I'm with Kira consulting we we do in
addition to software consulting helping
people solve problems or a group people
who are heavily involved in boost and so
if you're looking for the software of
that type of quality and skill level
that's what we do I mean we also do
training for C++ some of the things that
we'll be talking about today really are
the techniques that we utilize
internally within we think here to solve
problems we've we write things like
ideal compilers and other
domain-specific languages and compilers
to go with those and a lot of things
like that that will lend themselves well
to the patterns that we're going to be
seen in this presentation but we'll get
a little bit more to where this code
came from but this is less about boosts
- hopefully that made sense inside of
the abstract and more about what's
underneath the hood and hopefully some
techniques and ideas that you can take
away for solving problems okay so we'll
start off with boost - all right boost -
not boost ache though that is very
appropriate at times that is not it so
for a while people are thinking you know
maybe if we just color it boo stash then
people might figure out how to pronounce
it
we had one recommendation that we should
make it with a curly bracket but have
you ever heard somebody play a scale on
a piano and then not the last note yeah
it's kind of irritating and that's what
it feels like to me - so that's not
going to work this is what ended up on
the sign but I don't know I don't like
that either the best suggestion we've
maybe I've had so far was caterpillar
might as well write what else did a mitt
so naming for with boost - at the moment
this library came about from C++ now
2014 library and a week challenge
library in a week at at C++ now formally
boost con is a session that begins at
8:00 in the morning and goes to 9:00 it
runs every day of the week it's only for
those who can
get up early I guess I don't know it's
it's a time where we're going to try to
develop a library in a week and there's
a challenge that comes from Jeff Garlin
he puts it out there the first day we
try to throw some ideas out and then we
just break up into teams whoever wants
to work on it throughout the week and
and we like just like hash away at
trying to trying to get something that
makes sense and of course it's not
reasonable to write a library in a week
but we came fairly close for this one I
thought but the group did a pretty good
job and this is the work of of that
group
it's a C++ template engine is what Jeff
says and we're all like what what does
that mean and a C++ template engine what
he meant was moo-stache is a text
template processing engine so it's going
to take a text document and data in and
it's going to produce an output and so
boost - gets its name from mustache
because mustache was the first one that
we modeled the template language off of
so you're probably familiar like
mustache handlebars is of all these
different things where you take a
template that describes what you're
going to want the output to be some data
structure and then you apply those to
and get something out well here are a
set of some existing libraries that do
this type of thing this is the original
original cast that made it through to 8
o'clock in the morning by the second day
there's a lot of people fall off by that
point Jeff be me the the one who leads
library in a week now there were a few
other people who wanted to remain
anonymous and in mcnerney they're
showing these are the design goals to
integrate with the STL easily type
safety template parser error handling
provide customization of markup
languages make configuration simple any
data structure convertible to text
should work some of the features
compiled templates for speed was a
feature request and there was a design
decision early on to use C++ 11 this is
what came out of like within the first
you know 10 minute
so if people are just throwing ideas out
and there had to be a a decision made
right away and the decision was do we
force a model on the user are they going
to use like a hash of strings to
describe the data structure are they
going to use JSON what a property tree
what kind of a data structure does it
look like coming in that you're going to
feed to the template in order to produce
your output or are we just going to
somehow magically accept a user-defined
model whatever the user gives us will
just take and use and of course because
this is a group dealing with boost
things we pick this and we're going to
accept any user-defined model that comes
in and we mean any as well as possible
so we're gonna see how that mechanism
works that that's one of the trickier
mechanisms in the system so here are
some examples of a mustache type format
so that we can kind of get an idea of
what we're trying to do and here's the
template so the template is hello curly
curly name this will expand to some
variable lookup this is a variable here
we have the section in which if this is
true it will take this and it'll do
something inside here here's the end of
it so here's the data it's going to get
passed in we would get named a value in
California true and they have some
expression here and then it prints out
this result sections can actually relate
to a list of items and if they do then
this section will be repeated for every
item with inside that list so not just a
boolean test should I take it or not but
also if what it resolves to is iterative
all then we will go ahead and iterate
through that and so here this repo maps
to a bunch of different things and those
things then will be able to be iterated
through and pull out name for each of
these and this is the output so basic
idea of what's the BAM
it's a spam email generator that's right
but we want to do it faster so we can
get more of them out there alright so
let's look and see how you would use
Boost - if you were just a user what
would you do with this thing so the
first thing you're gonna do somewhere
you're going to have your template you
loaded it in from file you've got it as
text somewhere this is ours at the
moment so you can see our double curlies
here are going to get replaced then with
some data
we're data at the moment we're just
going to use a map a map with string
versus string let's initialize our map
we put a name in an age we'll get an
iterator to the beginning part of our
template and we're gonna pass that and
the in iterator
to this load template which we give it
the flavor of the template which is
stash is what we call the mustache
flavor internally so we pass it this tag
called stash and out from this we get
this temple we then call generate
passing it the stream that we'd like it
to generate to the template and the data
this template at this point is the
compiled template and then we pass it
our data in this case it's this map here
and we just output it or whatever we
want to do okay so this will now
generate into the string so let's take a
look a slightly different example inputs
a little more complicated it has a
section now we're going to print out
some invoice information it looks like
this time our data looks a little more
more involved we have we have an item
which is a map of a string to a string
and here's an item list which is a
vector of these items and an invoice is
a map of strings versus item lists so
kind of made a more complicated data
structure and in order to shove some
more information into it and this is the
information we're going to shove into it
so these are our invoice items like the
list of our lines and then our invoice
when you've got lines and then this
thing inside there we just kind of set
up our data structure to shove into it
well what we do the same type of thing I
get the beginning the end of our
template this compiles it you now have
the compiled template out we tell it to
generate and we just pass in the top of
our whatever our data is so notice we've
got now a very look very different
looking data structure that we're
passing in we just pass it in so from
the users point of view this is what we
want we wanted to look like magic
because that makes us feel good we just
want them to be able to pass in whatever
data structure they have all right let's
get one more complicated here's an
invoice invoice number some more more
sections that we can if there is a
company we're gonna probably do these
things and then some lines underneath it
now we're gonna make this out of an
extended variant so a value is going to
either be a string or an object or a
list where a list is a vector of values
these things so it's recursive that's
cool and an object is going to be a name
versus a value and so you know this is
like almost like a mini JSON type
looking structure and we're just going
to define it we don't have numbers but
we've got this now recursive data
structure extended variate from from
spirit looks just like boost variant
except that boost variant is not really
a type it's a type def and this gives us
an object to deal with so we can
actually forward declare it and then use
it recursively later so it makes
recursion easy of of Berrien types now
let's just fill this in all right so
we're gonna fill this thing in with that
information you know if you're blue your
eyes just write it kind of looks JSON
you write all right and how do we use
this like magic we just drop it in and
it's gonna magically somehow figure all
this out all right one more example if
you're not convinced yet so I have this
author thing here and a template and all
this looks the same right
it's unchanged what is this author thing
I mean it kind of looks like I am
initializing some data structure and
indeed I am author actually is just a
struct and the way that we take care of
the magic of the struct is we use fusion
adapt struct what this does is it
creates a tuple reference of the things
that I say that we wouldn't like it to
adapt so this is basically saying author
has this field called last name first
name and library them interested and I'm
not interested in email I'm interested
in these three and they're of type
string and it's going to under the hood
with some template magic it's going to
create a tuple a referal of references
to those types so that I can access them
later so if I can be able to TechEd that
I have a tuple of references or a tuple
of any sort I can iterate so-to-speak
recurse through this thing and then pull
data out and utilize it and if you've
not used this facility it's part of
fusion fusion is like library for tuples
you can do the same type of thing with
member accessors getters and put and so
you can adapt anything you have to look
like a tuple so we've pretty much
covered all the types of things that we
might be able to see there's some that
we haven't covered yet and we'll talk
about how to extend things so we can get
and get even more complicated right well
let's just have a company type in a line
type in an invoice then now is an
invoice number and a company is actually
well you know this thing and we've got a
vector of lines this looks more like
code we might want to really not see but
you know it's getting closer this look
like code now as opposed to I'm forcing
the user into my own data structure and
I just need to fusion adapt these and
bam I can just call it I can pass in an
invoice type and it just works alright
so this is the magic we wanted to get to
this was our goal so whether this is
here where we're generating this invoice
or we've actually now gone from using
stash and we just want to use Django's
templating format and we want to
actually compile the template using
jingo type formatting for the input and
we have a compiled part on the inside so
notice that the idea is that the
compiled representation is independent
and we can call these things well let's
dive into this what does it look like
inside so inside we've got the template
the description of what we want to plug
things into we are basically this is the
load template call that you saw has a
front end that's going to parse this in
it's got a back end that's going to take
care of compile make creating a compiled
template the compiled template and the
user data are going to be applied via
the engine that's the generate call we
saw and that's going to create the
output so let's get these different
stages starting with the first part this
first stream through so the idea is that
we're going to have the template come in
we need a front-end parser to convert
that into the front-end ast so what is
the abstract syntax tree the data
structure that represents whatever the
format is I came in from mustache from
there the compiler doesn't really do
anything more than translate one ast in
event into another that's what compilers
do so we're going to transfer this this
front-end ast into the engines ast that
will what we're gonna call them two
compiled ast
what does load template look like well
load template takes two iterators or it
takes a stream and one way or the other
it's going to call parse of the thing
and it's passing the result of the parse
so that's the ast coming out of the
parts it's passing that into compile
which then is going to result in to some
ast that's being returned out notice
this format format well where is this
coming from format was what we put into
the angle brackets to say this is stash
this is Django and what that is is
really just a structure that helps us
hold some type Deaf's it helps us put
some some other types in there so that
we can yank them out and do things with
them later on
for example which grammar should this
use because we might reuse grammars over
and over again or more likely we'll
probably reuse
a sts and the grammars might change
slightly
what is the skipper look like how what
does whitespace get me look like for the
front end for this versus something else
all right one of the things that came
out from day one that almost made me
just fall on the floor laughing was
booths or we could use booth spirit for
parsing or maybe a reg X would work and
anybody who's ever seen any of my spirit
talks reg X often mix it in there as the
ad hoc way to pretend like you're going
to parse something reg X is not parsing
at some point it falls apart and and
you're just like you have no idea what
you wrote anymore and nobody else does
and it's not many people reading X is
great for what it does right but if you
want a parser you should probably use a
parser and so we might as well use one
this is what parse looks like so it
doesn't it does nothing more in parse
then start using this format that we
passed in to try to figure things out
we're gonna get an AST we're gonna get a
top node so we can start filling it in
we're going to get the grammar of what
the grammar is specified for this thing
and we're gonna call into phrase parse
for spirit giving it the begin in the
end the grammar what skipper we want to
use in the top node of an AST so it can
start filling this thing out how many
people have used spirit okay couple
people so the idea is that we want to
actually declaratively specify what our
grammar looks like we we want to create
parsers in such a way that it makes
sense and they're easy to read this is
the organization inside a blue stash of
of the parser for stash the AST is going
to be what the user of the AST once it's
like the struct definitions of your ást
ást adapted we just put the cruft inside
there this is where all the fusion adapt
calls end up macros end up just stick
them all in one spot for organization
grammar this is the lightweight version
of the the declaration of what the
grammar is the definition is inside this
grammar def this is a trick that we use
a lot in kierra so well the Guzman who
is the author of
of spirit is on part of Kira and one of
the techniques that we use internally is
that we would like to instantiate
templates somewhere else when we know
what the types are most likely that
they're going to be used so that we
don't keep reading Stan shave them over
and over and over and over again and so
this is by separating the two out this
allows us to instantiate something into
the CPP file and then not keep rien Stan
cheating it increases our compile time
quite a bit decreases our compile times
quite a bit we're really good at
increasing them we want to decrease them
decrease them and then now we're gonna
have some printer so let's take a look
at this stash parser what does it
describe well it describes a bunch of
rules rules or rules inside of spirit or
things like this where we're gonna have
a notice rule in a stash node and an
identifier in a comment these are just
the declaration of the rules and what I
want you to notice are these things are
actually the data types that the rule
when it's parsed is going to synthesize
so the parser is going to synthesize a
data type these are the data types we're
just telling these are the data type so
you're going to synthesize you're gonna
synthesize these different data types
we're gonna look at those in a moment
that's not the important partner the
first part is a node list so this says a
node list is zero or more stash nodes
whatever a stash node is well what does
a stash node well mustache is either
going to be literal text or a comment or
a variable or a variable that's in
scaped or a section or a partial those
are those are things that make up
mustache we're gonna leave this down
here just so we can keep this in mind
what is literal text well literal text
is one or more characters that are not
the double squiggly what is a comment a
comment is a double squiggly followed by
not followed by zero or more characters
that are not the end followed by the end
so declaratively we just said this is
what a comment is in doing this in
spirit this produced a parser for us to
do this using expression templates so at
compile time this is producing the
parser in a nice way that we can read
it is really cool I don't know who just
said that but it's really cool you're
right so here's a variable a variable is
the open EE and then this is the escape
character that's utilized with inside of
moustache to say whether you are whether
you were using applying formatting or
you're not playing the formatting and
then here there's gonna be some identify
ER and then the in squigglies okay well
what does identify identify ER is oh
please turn off the the skipper
it's an alpha followed by zero more
alpha or numeric characters potentially
with an underscore what is a section a
section is it's going to look to see
whether this is basically saying it is
an inverted section looks like a knotted
section instead of thing being true if
the things false and it takes a section
it's gonna have a section begin followed
by ooh zero or more nodes of course
right because it's a recursive data
structure followed by the end the begin
looks like this or seen this and the
thing the in looks like the end of
whatever the section name was yes you
may there's a question is why does the
section have the modular looking thing
earlier versions of spirit so this is I
should have mentioned this room so
there's lots of us writing code that's
going to cite it's all at the same time
we all have different experiences and
early versions of Spirit required the
modulo equals if you had a semantic
action attached by attaching a semantic
action to any of the parsers within
would mean that the the total expression
would not actually synthesize what it
was normally going to synthesize because
it would assume that the semantic action
took care of it and if you still wanted
to synthesize it you had to use this
trick little cute little notation you
don't have to do that anymore
okay so the way expression templates
work is you're going to you're going to
expression tables are basically a data
type with an operation between it and
another data type in it and at compile
time you're building up all these data
types and so you need a data type to try
to get things going and so something has
to be something in there has to be
tainted in order to make the operators
combine properly we can't just have you
know pure literals shift it into a
literal that that's not meaningful we
have to somehow taint one of those and
once we take one from that point on we
have a type and so we can just keep
using them however we want great
question okay so let's look at what the
ast looks like so the ast were you going
to use again this variant in order to
describe things that could just be one
of many of these things so at the top
level this this node is either undefined
or it's a comment or a literal text or a
variable or this recursive wrapper to a
section which a section is going to be
full of nodes again or it's a partial
and as we look through this these are
the different descriptions of the ones
we just saw variable is either unex
caped or not and it has an identifier
where an identify err or an identify err
is a string so now these are the types
of things that you will hear people say
never ever ever do ever okay so here's
the deal
I need a unique type that represents
identifiers in my system and guess what
a string is exactly what I want but I
just need the string to have a different
type it needs to just be a different
type so I know that it's an identifier
versus a literal text not I'm not adding
any methods I'm not adding anything at
all right I just need a new type so
that's why we do this okay so basic idea
of an AST right we'll describe a print
usually because we want to print things
out for debug purposes
if not for anything else we're gonna go
through how print works so that we can
understand how busy ssin works and once
we understand that then the rest of it
just kind of is going to be a lot easier
so imagine your head you have now this
abstract syntax where you have a data
structure that is represented as you
know maybe a list of things to things
that could be lists that could be things
to other you know concrete types like
maybe a string or some any of those
things that we just saw and so you've
got this tree and now you would like to
walk this tree and print the values back
out what what do you have how we do this
is we're gonna take a stream in
reference for stream and we're gonna
take the node list was the list of nodes
is the thing that we parsed it's the
very top level we're gonna take that and
pass it in well what are we going to do
first well we're going to just fort um
iterate over the nodes all the nodes and
we're going to apply a visitor where we
pass the node that we currently have and
the visitor we're gonna talk about what
the visitor is now the visitor is in
this case we get printer the visitor is
nothing more than over loads or the
operator for for the function operator
for the callable operator my goodness
for the callable operator for every type
that could be inside of our variant
right so every type that this possibly
could be in our variant we're going to
have an overload undefined mmm okay
we're gonna print out whoa we heard
undefined comment we don't really care
about printout comments so we're not
going to every time we see the literal
text well we're gonna actually just
print out the literal text when we see a
variable will put the squigglies in
front we'll look to see if it's xscape
because if so we can put the ampere sign
that will actually put out the value
that was there for it and ended how
about a section well a section is a
little more complicated we're gonna have
to put squigglies if it's inverted we
get one of these otherwise we don't
we're gonna put the name out in the end
and now we're going to iterate over
every node that's inside of the section
and we're going to reapply the visitor
right because we don't know what the
type is so we're just going to keep
applying the visitor again and let the
visitor
care the problem for us and at the end
we'll stop here now there's a good place
to stop and think about what we're what
we've just done we have a pretty complex
data structure maybe a lot more but it
doesn't matter how complex it is we're
dealing with one small part at a time
conceptually we don't have to think
about the entire world all I have to
think about is what do I do with a
section a section has this introduction
it has an ending and in the middle I
don't know they're just notes like
everything else so what am I going to do
I'm just dispatched to the thing that is
handling the nodes from the top in no
reason to think about it right
okay we're gonna use this concept a lot
so we've now got a front in ast the
partial code that you saw up there
that's it
it creates the parser for us we don't
have to write any more code
can you imagine writing code whatever
was you would have written the code half
an hour ago in order to parse that in
it's not a horrible grammar but I bet
you would have had a lot of code and a
lot of bugs and would have been hard to
think about procedurally we just declare
what we want with spirit
all right so load template or we're
finishing up this and now the result of
this is that ast we're passing it in to
compile so what is compiled well compile
is going to first compile here is taking
the output of this write and that output
was the ast that's associated with the
input grammar so mustache has an ast
something that's gonna describe it so
how do we now take then that stash AST
well we're going to take that there's an
overload for compile that can take that
tight I'm just going to call the compile
on the ast or the stash compiler what
does that look like well you bet
we're gonna do visitation so we're going
to visit the ast so what is the visitor
look like for the ast this time we're
not wanting to print things out we're
wanting to take the ast in and transform
it into a different ast out
that's the compilation alright so coming
in we've got our route and the route the
top is going to basically be a node a
list of nodes we're going to iterate
over each of those just like we were
before and we're going to take the node
list so we have a new node list is our
internal the virtual machines AST we're
going to take and a node list of that
it's nodes and push back the result of
applying the visitor to the node I have
right so I've got a list of nodes I
don't know what the result is don't care
all I just know is that whatever it gets
back out and the transformation is what
I have to push on my new list to make
new new new bits of these and then I'm
going to return the node list at the end
so what's inside of the VM ast what are
we transforming into again undefined
there's a no op literal variable as a
render as a for each and if then else
a select context and a node list these
are the intrinsics of the internal
language basically and everything that
comes in from any other template type
has to be transformed into one of those
intrinsic super-important what each of
these are you probably can guess what
most of them are literal before each
will have a name associated with it and
a node the if in else is going to have a
condition they'll be evaluated and then
a node a node on the bin and on a node
on the else right which are basically
like lists of what to do all right so
how do we transform undefined well an
undefined is just a
if you knowed what is a literal text
literal text we can just return
internally our literal because that's
what it is internally what is a variable
internally that's a render so generator
a render data type and return that
notice each of these a returning node
node was our variant type so that berry
type can hold any comment is a no op for
us we don't care about comments a
partial partials currently no up because
they're not implemented in this version
that's on the slide they're inside of a
a branch at the moment for partials
partials are ways to include other files
think of it that way you're like it's
like an include which is a little more
complicated how we want to reason about
them we want we want to do something a
bit differently in the library a node
list well what is a node list going to
convert to a notice is gonna convert to
just another node list right of the ast
node list but see how I can just reason
about this well was a notice when I
convert a node list from one type to the
other it's just the node list of the
internal data type instead of the one
that I read in so I'm just going to keep
calling apply visitor and let that take
care of it let's get to something a
little more complicated a section so a
section it's going to look at the node
list at the nodes and push those back so
for for this section when it comes in
the section has a bunch of nodes
underneath it and it's going to
transform all of those nodes each each
of those into a list and now it has them
and once it has them it's going to
they're going to be in this VM ast it's
going to get put into the section body
value here we're going to create this
internal for each and it has the name
here so for each this is the value all
the things that we just took care of and
then its name and and mustache is weird
it's sections are both a condition test
and then a loop
so we're gonna have to form inside of
our internals a conditional test
whatever that means and a loop so here
we we produce the loop the for each and
now we're going to produce then an if
block where the condition name is the
name that came in from the section we're
going to select the context so selecting
a context basically means on the data
side we're going to move down in there a
level on our branch give it a name and
then apply to assign the section body to
the body and then we're gonna check is
this thing inverted if it's inverted
then when we do the Select it's going to
go into the l-sit and if it's not
inverted then it's the VIN side or just
can pick one way or the other so this is
the most complicated thing we have and
again I didn't have to think about it
very hard I just had to think about in
terms of a section what are the
mechanics of a section alright so we now
have moved from our front-end ast to our
engine VM ast yes okay so the definition
of select context and what does it
contain
select context has a tag and a body and
we're gonna actually spend some time
with select so we'll see in a little bit
the complexity that exists was selected
all right so if we have multiple front
end we have stache parser we have a
Django parser we've don't have any
others at the moment but adding new
parsers is simply writing that
declarative spirit grammar that reads it
in and then now you have whatever
whatever the natural ast is for reading
that in and then converting it using one
of those compilers and you can see the
compilers aren't that really hard to
write right it's just how to transfer
one ast into the intrinsics of the
internal ast and now we have the engine
ast so this is our how all that we can
support the multiple front-end
we're gonna move on bypassed the Django
example for now because so let's look at
the generation side so we've completed
this we have a compiled template and now
we're going to pass that and along with
the stream that we want to output to and
our data at the top port here so what
does generate look like generate took
the stream it took a template and it
took what we're gonna call a context
we're gonna call the data the data the
input data ast we're gonna call the
context and we're gonna use that to
refer to where we are in the ast
actually at any point in time initially
we're at the top note of the ast at the
very top the detail detail of generate
call looks like this it is going to get
an engine just a constructed engine
based upon the stream in the context
it's passing those in and then it's
gonna call engine passing at the
template notice what is the engine a
visitor I have an ast that perfectly
describes exactly what I want to walk
how do I walk that just with the visitor
right there's nothing complicated about
this well almost the walking parts the
easy part
the data site's gonna cause us some
problem so let's say I have a data
structure that looks like this it has a
conference and conference has an A
Oh yep and as a conference datatype and
within the conference it has inside
there it has a name and the name is Jeff
it it also has this year and it has CP
conference has a name and it has a CP
pecan inside there and it also has a
year object it just like point to an
object it has a year 2015 so try to I'll
try this again I've got like an object
that has a conference thing in it and a
name and name is pointing to Jeff the
conference is pointing to this thing and
what is a conference a conference has a
name and it has a year the name is
pointing to City pecan the year is
pointed to 2015 my ast that I just read
in for then I'm skidding passed into the
engine it looks like this
a literal there's an if condition
there's some things going on here let's
walk through this the if condition is
going to start here and it's if
conditioned and it's going to do
whatever the test tells it to do and if
the test then is true then I I want to
actually descend on the data side so you
remember before with the select bits and
pieces with sections and mustache in
sections once I actually selected that
object it existed it had that type
inside of the map I actually wanted to
send into whatever it was referencing so
a map of string versus like another
object if that is in there then now over
here is where the context is we want to
move over and so if it's true
then I want to select the context which
is selecting on over here and now I can
do my literal render and I'm going to
render whatever it is so the idea of of
what we're about ready to talk about is
as I am moving through and dealing with
my ast on this side the instructions I
actually have to based upon whether I'm
selecting context or what else is going
on I have to be at a different spot
inside of my data
and so we'll select context is going to
basically move me about throughout the
data tree okay so what does an engine
look like so here is the visitor for
engine if I have a node list which is
what I start our start off with I'm just
going to iterate through all the nodes
and I'm going to apply a visitor on the
node right whoo easy all right if I have
a node somehow I actually have a node
itself what am I going to do with the
node I'm just going to apply the visitor
to the node because remember a node was
a variant type it contains one of a
bunch of different types I don't know
what type it is so I've got a strip out
the type inside of it and then revisit
it what are my types undefined I'm gonna
do nothing with no op i'm gonna do
nothing in a literal i'm going to render
i'm gonna call this thing render passing
at the stream and the literal value that
i currently have this using trick here
says basically grab whatever the default
renderer is but if the user overloads
render for their own data types and
value types which they're gonna be able
to do through an extension mechanism
it'll use that through a dl so this is
the trick in order to get us a dl lookup
we'll get the version that comes with
boost - unless the user has provided an
extension for it and they want something
else we use this over and over again so
here's just the render method
if-then-else what do we do with anything
else we're gonna call test passing the
context and the condition name and if
the result of calling tests results in
true we're going to then apply the
visitor to the bin site otherwise we're
going to play the visitor to the else
side
it has to look for yeah so we'll we'll
talk about the extensions in a little
bit so the question basically is how
we're gonna I'll have to agree on a type
how are we going to agree on that type
and we'll see how we're gonna agree on
it in just a little bit we're gonna
agree because I'm gonna tell you what
the type is alright alright so what is a
for each a for each is just calling this
for each which seems pretty innocent at
first and now let's take a look at what
4-h is for each is going to take a
stream and the node that we got in the
context and the first thing it's going
to do is it's going to actually just
dispatch another call for each that
takes four parameters where the fourth
parameter is this thing called the for
each category given the input context so
the input context at this point is a
data type right it's the data type that
the user gave me I don't even know what
it is yet this is what I'm about ready
to try to figure out how do I deal with
the type that I have and what I'm going
to do is I'm going to say what is the
category can I categorize this type that
I have and make any meaning of it at all
and this is going to result then in some
type all right what are the categories
well we just kind of came up with some
categories these aren't well designed
categories that's what happens when you
do a design in a week right so the
categories that we have right now that
seem to make sense initially for for
writing isn't making something work is
we have an unused attribute a plain
attribute a sequence associative tuple
variant and optional the belief is when
we entered into this is that most things
seem to fit into one of these categories
and if they can fit into one of these
categories we understand what to do with
the categories we know what to do with
an associative container when we see it
because we can actually switch contexts
with inside of them we know what to do
with a sequence if what we're supposed
to be doing is a for each loop and it
models the concept of a sequence at that
particular time we know how to test
something for boolean true
given the category type so categories
tell us everything we need to know about
your type and what to do with it without
me knowing what your type is to start
off with so at compile-time as you can
see we're getting ready to do now a
compile-time I'm going to determine what
to do with your entire AST and the types
based upon the category so let's look at
some of these for each you don't care
about any of these really well okay this
is the magic so the for each category
starts off with a plain attribute this
is the default one I put in something I
put in anything for a tea I get a plain
attribute out I'm going to specialize it
I'm gonna treat strings as plain
attributes we'll see why in a moment I'm
going to treat using an enabled if if
the thing I have is a variant because I
can have boost variants I can have
spirit variants I can have all these
different things that look like variants
of treated like variants if it is one of
those variant type things it looks like
one then it's a variant attribute if it
is a sequence that's not a map because I
don't want to treat naps like sequences
I want to treat other things like
sequences sequences for me in the for
each sense of the word because notice I
mean the for each category right now I'm
not in one of the other categories and
the for each category I want to say that
maps don't don't look at all like a
sequence instead maps are going to look
like an associative thing to me that's
what a map is going to look like if I
have an optional it's going to look like
an optional attribute and then I'm going
to use a template alias just to make my
life easier so I don't have to write
stuff over and over again right all
right we made it this far we've got now
the for each that's going to take any
category that comes in and by default
what does it do well if it's not been
specialized what it's going to do is
it's just going to call generate which
is patent it's gonna pass the stream the
current node value that it has and the
context this was the top this is where
we started this whole operation from so
basically I'm going to say
if I get to this point in the for each
I'm just gonna call back into the very
top entry with what I currently have and
now let it work its way down I don't
have anything to iterate over basically
what do I do if it's a variant if
somehow what I have right now is a
variant it is completely useless to me
but what isn't useless to me is the
thing that's inside that's wrapped up
and so what do I do I create a very
special variant visitor which is not so
special which is going to unwrap this
variant for me
so unwrap variant for each which is just
this it is going to simply create this
type giving it the stream in the node so
it's storing the state basically where I
am and calls the variant I calls the
apply visitor which for whatever type it
has now it knows the type it can recall
the for each with the correct type
because it's unwrapped it so it's done
nothing right it's just basically
calling for each again now that it
actually knows the type that's inside
the variant eventually we're gonna get
to do some work here optionals not it
either because I don't know what an
optional is either I have to test if
it's there or not if I have one well now
I can actually call the for each with
the thing that's inside of it so I pass
it a dereference it and at this point
actually what is the for each category
based upon its not based upon the
optional it's based upon the type that's
inside of the optional so I use deckle
type to ask what's inside there
otherwise I just called generate move I
just I just move on okay finally we have
a sequence something that we could get a
rate over I go ahead and call wow what a
surprise
generate over each of the nodes that are
inside of the sequence passing it now
the node value and the item
all right so let's think back up to the
engine visitor so that was the for each
pretty easy right really cuz I'm just
calling back into myself I'm only
handling the special cases and where I
know what to do it yeah the other
takeaway here was the category thing if
you can categorize types of things you
want to deal with and deal with them
generically then you just have to worry
about how to classify them as a separate
exercise all right
select context this is the trick this is
one of the tricky parts so select
contacts the idea is that we have now
this idea that I checked it has a
company and now I actually in I need to
now move over inside of my data
structure to where the company is and
start working with company I've got to
select that within my data set so I
again I call it and hey this looks
familiar right
I want the select category context this
time so the for each context and I'm
going to pass it now so this allows me
to deal with categories based upon the
behavior or how they're going to be used
not just all of them are the same right
it's all these things look like
sequences always well no not necessarily
sometimes these things look like
sequences when they're being used in
this realm but other times these other
things look like sequences to people on
how they're going to be used
alright The Dispatch what a surprise is
gonna just call generate again if it
doesn't know what to do with it
so that's that's always what we do if
you don't know what to do with it we
just call generate here's a version now
where it's an associative attribute so
sheet if attribute means that I now have
tested the thing it's true I've got this
thing I can now call I can now select
the context of whatever it was supposed
to allow me to switch the context for so
how does this work it's assuming that
there's this find or these associative
things if it finds it and we're not at
the end and it must be must be there and
now I can call this select context
passing it now the stream the template
body where we are inside of the the
template itself the context and the
second so the thing that it pointed to
and now notice when I call it I'm
calling it with the tight the select
category is now the type here of of
whatever is pointing to because if you
have an object of objects of objects of
objects you don't really want to be on
the outer shell you need to descend all
the way down until you get something
concrete to work with so a map of maps
of maps and maps you need to be at the
lowest level of that map to do something
with it we found that because it didn't
work the first time but it was an easy
fix all right what does select context
do well it just calls generate unless
it's an associative attribute in which
it calls generate because an associative
attribute means that we need to do this
thing again and when it calls generate
instead of passing in the parent it
passes in the child because now it's
going to basically run the same thing on
the child and descend back down how
about how about if it is a sequence
attribute well we've now we're basically
saying that what we pointed to is an
array or something that we can iterate
over perfect let's stop there and call
generate passing the child in what if
it's a variant you know the answer to
this if it's a variant we don't know
what to do with it so we have to unwrap
it
so we've create a non wrapper which did
nothing if you remember right except for
take the type and recall back in so it's
reduce patching back in all right so
without probably too much imagination
you can see how working with just one
little chunk at a time and by category
and by type we can do just about
anything that we need and what did we
just do we just took any type that you
give me that I might happen to be able
to
distinguish and figure out what the
category is I can use it how does it
figure out what a sequence is and why do
I remove map it figures a sequence out
by determining whether or not it can
call a begin passing at that if it can
call begin passing at the type you give
me it figures out I can iterate over
this thing I don't know what it is but I
can iterate over it and it just uses
that so by by understanding just some
basic things of the types that you give
it it can make decisions and you can
give it any data structure but what if
you give it a data structure that it
doesn't know what to do with it can't
figure it out at all so here we have
some input and template and conference
started is going to be a lambda that
happens always return true the topic is
going to return
Jeff's latest issue at the moment and
now I have this thing this s Model T
data type that is going to take a string
on the left side and oh my goodness a
callable lambda thing on the right hand
side right okay we haven't seen any
category that this is going to be able
to deal with yet right we don't have
this mechanism inside of boost dash to
deal with caller bowles doesn't know
what to do with them and it doesn't know
what to do with them on purpose by the
way because it doesn't want to just go
around calling things you may not
actually admit that but I can tell it
what to do I need to tell it to things
notice this it needs to understand when
it hits this section this is testing its
testing whether or not the thing is true
and it would have done a for each if the
thing was you could be iterated it also
named it needs to be able to help
somehow render the thing so those are
the two things that needs to understand
what we're going to do is inside of the
boost boost dash extension namespace we
say test giving it the things that test
normally gets except for here the
context type is going to be any callable
function here
a no Larry function and a and we say
it's a plane attribute so the plane
attribute then when it is this because
it's gonna be a planar sure because it
doesn't know it doesn't match any of the
categories we have so therefore it's a
plane attribute and we've now overloaded
it for this function type right so the
signature is going to match when you see
this return and we're going to call test
passing it the name and in this sense
we're actually going to call context cuz
we know this thing's are callable that
came in so we're just going to call it
and we're going to pass the result to
test within this context so if if it
returns a map or something it would just
do whatever it was supposed to do with
maps right
in essence what I'm trying to tell it is
this is how you're going to extract the
information that you want to continue
passing on I could have just returned a
boolean at this point we're true this is
how you there's how you deal with
boolean this if I wanted to overload the
render same type of thing here's the
function that the context is being
passed in and I'm gonna call render
executing the context passing that
result into render and so this is how
the extension mechanism works and as you
can imagine without too much thought
just about anything you write then you
can therefore write an extension for it
there's for extension types there is the
the test the render another really ro4
there's a for each and in a context and
a context there we go so if you have
complications with any of those you can
write then the extension for them so
what's the plan for the future yes
yes so the question is can you use
extension functions to actually do
includes there is an individual in Italy
who's been using boost ash quite
extensively and that's what they do in
order to handle weirdness to plug things
in what we're trying to do is actually
to come up with a reasonable extension
mechanism to let you include things into
the is to you when it when it sees
events that makes more sense but yes you
can use extension mechanism for all
kinds of abuse we need to complete the
mustache and jingo support in particular
what's missing our partials which is
that include capability the other
weirdness you you saw how we kept
basically diving down into the data
structure that the user gave gave us the
context what we're going to need to do
is write a context that basically is the
same type of design that we use in
spirit and it's a wrapper that's going
to go around what the user gives us
because not only do I need to go but
dive down but if the user says up here
is the is name and and we've gone down
into the data structure and they
suddenly use name it has to actually
look up until it finds something that
says ooh there's wear name is and use
that we don't have a way at the moment
to go back up it's not trivial to do
elegantly and so we know how to do it
cuz we've done it in spirit so that's
the other thing that's major things
missing we actually need to complete
generalizing the category handling and
actually design it properly instead of
kind of what we did in a week and flush
out the extension mechanism so it's
fully defined and specified and then we
just need Docs lots of Doc's there are a
few people who are are using it we're
getting bug bug reports and feature
requests and pull requests for actually
new features and stuff so it looks like
they're like looks like there's some
people all right you can find it here
cure labs is a is open source effort by
Kira to stuff that we work on and do and
we just throw out those mammal parsers
and json.parse there's another
queer weird stuff out there you can find
the project there it's interesting to
you please get involved hopefully this
was a useful talk for you to kind of see
how you can use these different
techniques internally and and a reason
to think of things in a in a way there
are really smaller chunks try to
contrast that to what you might have
done procedurally in order to write this
whole thing from beginning to end I
think we have like no time for questions
we have 44 seconds for questions how do
we detect maps right now we detect maps
simply through matching on STD some type
some type I'm sorry STD map so we only
detect STD map yep so if you had another
type you'd use the extension mechanism
and you would say let's say it's a type
for an associative so you would say that
on a context switch you would want to
add into the category your type that is
now your type is now an associative type
and that's like you know if anyone how
pretty you want the line to be it's two
lines if you don't like pretty it's one
line of code and then that would mean
your type is now an associative type it
would understand every time I saw that
it was associative in nature and
therefore it could do context switching
on it now what context switch he means
on it is a different question but you
could write the overload for how to get
the data back out yes the tag dispatch
will didn't work for your type right so
it generally will understand because of
the mechanisms there is basically
understand everything that's out of the
stl container types and understands a
lot of other types it understands tuples
which suddenly opens the world for all
kinds of weird things understands all
the fusion types that exist
yeah so the comment is that you could
kind of use just the back end as a poor
man karma yeah you basically could the
back end is in separate directories yeah
it's not tight to the front in any way
yeah so that's a great question so if
you type the wrong name into a template
and it's important to you that it finds
that you should talk to Rolen because
Rolen actually has a template engine
that parses that that utilizes the
template definition bits inside of the
compiler at compile time and so it could
I could do compile time checking type
checking in a sense of you meant or
didn't mean nothing and so you're stuck
to him and mustache what it means is
nothing do nothing so by specification
it means I found you asked for name I
don't have a name I don't want to output
anything that's what you mean and so it
doesn't output anything and most of the
tip engines that's how they behave when
you see something when it can't find
something it just continues on now one
of our users has requested that once it
goes through all this work and it can't
find anything that you can provide a
handler an optional handler that would
tell you that it can find me we've got
thumbs up going on over here - yeah so
that's trivial to do as you possibly
could imagine we're in these trees to
put it it it's like very trivial to put
one in and so that's probably makes a
lot of sense to stick one in anything
else all right so our our time is up
I'll be around if you have further
questions the slides will be uploaded
the bonus slides that follow after this
show how the meta programming works in
order to send it to 'pls if you really
are into that type of pain in your life
you can watch that thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>