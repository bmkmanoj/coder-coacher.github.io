<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2014: Arthur O'Dwyer &quot;C++11 in the Wild: Techniques from a Real Codebase&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2014: Arthur O'Dwyer &quot;C++11 in the Wild: Techniques from a Real Codebase&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2014: Arthur O'Dwyer &quot;C++11 in the Wild: Techniques from a Real Codebase&quot;</b></h2><h5 class="post__date">2014-10-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lKG1m2NkANM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you all for coming out to my first
conference presentation ever just so
where we'd set our expectations really
low so this is my first presentation of
the real conference this is not the
first time I've given this talk it is
the first time is that I've given this
talk as one talk I've given it a bunch
of times as two talks so that this is
C++ 11 in the wild techniques from a
real codebase namely my former employer
it will show very small snippets of the
code in ways that you can use C++ 11 in
real concrete ways but I hope you can't
just take home and remember and
implement write a lot of talks tend to
be about frameworks and and big things
where it's like well that's kind of cool
but either it's closed source or it only
works on Windows or it only works on
Linux or I just don't have the time to
understand that and in this talk I'm I'm
gonna try to show you a couple of things
that I think you will understand and
take home and evangelize and possibly
you'll say oh we already do that already
and then it's not interesting so if you
saw in the conference program that this
is trimmed down from from what I'd said
in the schedule which itself was trimmed
down from what I said in my proposal to
the review committee I just I keep
expanding the sections and and throwing
things off the end so what we're
actually going to cover in this hour is
two things for sure the auto macro and
make it durable and time permitting I'd
like to talk about did spaceship which
is not a real thing for those of you
going to look it up on CDP reference
right now but it should be a real thing
so the audio macro is or we call it auto
you can call it finally you can call it
whatever you like it runs clean up code
at the end of a scope it's basically
you've heard of it it's on scope exed or
at scope exit or scope guard but it's
done in a really really nice way
make it herbal and edible range or
basically I've got to iterators I want
to treat them as a range if only there
were a way to do this there is but you
have to write it yourself and then we're
going to talk about how to basically
write a stir comp for tuples if we have
time if not that will turn into a
lightning talk on Wednesday or Thursday
and you can come to that a few ones so
let's talk about the auto here's the
problem that we're trying to solve we
have some code in our in our normal old
school code base and it wants to mutate
some states somehow and so it's going to
attempt an operation that's gonna
attempt a different operation and then
we realize we're getting a lot of spam
on our trace logs
all right the the disk is filling out
because we're logging too much stuff
because these operations are really
spammy we need to disable logging during
these operations so we throw a disable
logging at the beginning of the function
and n able logging at the end of the
function we're all happy problem is we
forgot all our error handling unless of
course you use exceptions in which case
our error handling looks like this and
everyone is confused but funko basis
will use exception and like I don't
actually want to disk them but we don't
we make everything look like this right
so this looks great but then it's very
obvious that you have a book if you ease
exception handling you already had the
bug in the previous slide the problem is
that these early returns return around
the enable logging and so your logging
is just disabled for the rest of the
program this is a problem we need some
way of running our cleanup code at the
end of the scope without forgetting
about it without having to put a cleanup
block at the end go to it or whatever
what we really want to write looks
basically like this right we want to
disable the logging and then we want to
make a note to ourselves remember
automatically at the end of the scope no
matter what we need to enable logging
again and then we just go when we write
our code normally we write you know the
first operation second operation and we
don't have to worry about that cleanup
code again so this is what we want to
write unfortunately we can't write this
right actually we can we do we we write
this and the way that we get this is
with the following macro
that this is include audio dot H it
looks like this way down at the bottom
here it
there's our auto macro it's a very attic
macro it does some stuff we're gonna
talk about all the stuff that does but
I'll sleep it's up on the screen a
little while so you can sort of see how
it works and walk these all fairway
basically at the very top of it we have
our usual on scope exit sort of class
that you've seen before where it's
destructor does a thing and the thing
that it does is determined by the lambda
that's constructed with then we have a
thing that makes a lambda given whatever
arguments we passed to it we create
enough to go back to it with that thing
we have some magic with under under
counter to actually get a unique name
for one of these things and then we have
the thing that wraps it all up that's
how it looks and there's all sorts of
things that we can talk about this
although I did just talk about pretty
much all of them this uses all sorts of
C++ 11 features and also all sorts of
sequels also three features and also all
sorts of completely non-standard
features that everyone in the universe
supports it uses very attic macros they
uses token-based thing uses templates he
uses Lambos it uses counter it uses
pragma once it uses macros which are
evil and it also uses it one thing it
does not use is a state function it does
not use a state function of void void
instead it captures any kind of lambda
by reference back here so let's see
which one it is the digression that I
decide to cover first oh yes under on
the counter who here has used under
under counter before who here has knows
what it does Wow okay so we have a few
number of relatively few number of hands
here so what this macro does this is not
standard this is not in the C++ standard
but I can't name any compilers that
don't actually support this at practice
what it does is it gives you a new
integer value every time you expand it
so this is sort of like under underline
which is standard underscoring to score
capital why not restoring this word
which gives you the line number that
you're currently on
yes and I forget where if it starts at
zero it starts at one it starts at some
random number I don't know but it's
generally monotonically increasing yes
it's a preprocessor feature in
non-standard preprocessor feature of
every compiler in the world and we we
would avoid it here if there were a
standard approach of course the shared
approach should be standardized counter
right line works people boost
I think uses falls back to line of
counter does not exist problem with that
is then you can't use the same macro on
the same line right yeah whatever use of
the macro on a separate line which is
not a huge restriction admittedly but in
our case you know we're generating code
we're actually generating C++ code we
would like to be able to generate code
that uses Auto so that's the main
purposes it's convenient right it's
convenient for machines as well as
people it doesn't have a lot of
boilerplate and maybe in our machine
generated code we want to reduce the
size of it by removing all the
unnecessary new lines it's really
annoying at some of those new lines
happen to be necessary because you're
using under under other line everywhere
so we use counter mother nun
non-standard feature pragma once who
here has used fragment once
excellent okay you should all use it it
back it is the clearest most efficient
way to make a file I dumped it on who
here knows what I dumped it in means
fewer hands all right ah
Franco means a this file include at once
but it's at the very top of your of your
header file like so it's an include
guard yeah well the question there is
why use an include guard right I mean
what what doesn't include guard consists
of its three lines possibly with some
blank lines before or after and in the
middle of it and we can bike shed about
those and our code reviews you know you
know and then you probably have a
copyright header or something but the
include guard go above that or below
that does actually matter to the
compiler does the compiler want to see
the first line being this when I take
and I cut and paste this file which of
course I'm gonna do right I'm gonna have
a widget that H I want a widget to dot H
I cut and paste it now I need to go
change the the include guards macro in
both places make sure it says widget two
in both places maybe it's three places
because the guy at the end if he put a
comment to say this is the end of
include guard for widget and I have to
go change that from the widget to it's
so much boilerplate and so much
bookkeeping associated with traditional
include guards and I mean these are
things that have uses I mean there there
are real uses for macros defines real
uses for if and effing and if and end if
they have their uses most compilers
these days all all that I know of will
will treat these all identically though
they'll recognize when you write and
include guard they don't have special
logic that says AHA this is an include
guard I will remember that this file is
include guarded and I will not include
the close but of course it's when you
use if and DEF define an end if now
you're tying that file to a particular
macro right it says this one is include
guarded if widget is not defined
anywhere else but if widget is defined
somewhere else I have to remember not
even doing through this file once right
so it's more complicated logic
fragment once is very unambiguous it
says look I just want this to be a
normal item patent header file by the
way this is what I don't but it means I
need to conclude it twice and you've got
the same effect is that you included at
once this is the exact effect we want we
have a feature that does exactly what we
want it's too bad it's not standard yet
but we should just use it right make it
the first line of your file it kind of
already looks sort of like a shebang
it's just the shift rag mine is dead
just make that the first line of every
file you're done the first line is every
dot a trial right all right so talking
about style why didn't we use did
function in this act actually the first
version of
this code did use state function until
we came along and looked at what it was
actually doing under the hood and said
this is terrible that's right the state
function has a cost however I mean you
might say well I mean templates have
costs right I mean like we're making
this lambda I mean a lambda has a cost
Shirley right because we all well a lot
of people know that lambda under the
hood is really just a functor object it
creates an unnamed class that class has
an operator print friend method with
some code in it it has some data members
that are our captures that sounds like a
lot of bookkeeping that sounds like it's
going to generate a lot of code and it
doesn't compilers are actually smart
them we have a question yes oh you know
that that does sound like lambdas are
very expensive and maybe we just want to
use this nice simple standard thing that
just in it looks very simple is that
it's just the CID function looks simple
enough but actually type erasure is
pretty expensive and yes why not state
function right here are some reasons so
actually one of them is kind of kind of
silly which is that in order to use
state function you have to include it
you have to include functional or
something else that gives you function I
think functional is the thing and that
means you pull in all a functional you
pull in your type traits and recursively
just all a whole chunk of the C++ 11
standard library and we don't really
want that because we're we're not only
machine generating code we're also
compiling a whole lot again the
specialized use case but we want things
to be a slight weight as possible if we
can write it in one screen of code is he
to solve with no other includes that's
nice if we write it in one screen of
code plus a million lines have included
stuff from the standard library that's
not so nice when I try to make things as
small as possible so we want to use
language features like lambda rather
than library features like stat function
also it uses type erasure which if you
have not seen that uses heap allocation
and if you have by the way how many
people have seen in Piper a sure
how many people have written like
erasure same hands alright so we'll
cover how to implement that a little bit
more later and the third reason is that
empirically for no other reason and then
we wrote both ways and we looked at the
generated code and the generated code is
better right yeah we are going to see
all of this
I explained some costs of using state
function and type erasure basically type
erasure does imply heap allocation in
the general case there are optimizations
that you can do
GCC doesn't do them I don't know whether
other implementations do do them every
let me say JCCC I guess we made lips did
C++
I don't think let's see what I mostly
use lip C++ and again I don't think it
does any special small optimizations
first did function maybe if you're just
wrapping a function pointer
maybe but okay well let's actually look
at some code so here is some simple code
this I believe it is at the link that I
mentioned at the very beginning or you
can go spoil yourself on all of the
entire presentation this is very simple
code it just says we have a main
function I put some if throughs there
just so we have some scopes that we can
talk about what to do when the scope
ends in the first scope we remember to
put s2 at the end of the scope and then
we put us one and then of course the
scope ends that's where we would
normally put us two in the other block
we remember to put us three at the end
of the scope then we call foo now who
might actually throw an exception so
that's sort of like an early return we
expect to see some sort of overhead
associated with the auto in this case
because there are now two X's from the
function there's one more food throws
and there's one ray
and and at the end of the scope we
expect to see a bonus 3 so we compile
this using the audio dot H that you just
saw that one line question in the back
yes yeah it looks simpler in that
there's no object visible to us right
because we hid it behind a macro well
this is not meant as a replacement for
you know unique pointer right it's not
saying that okay stop using all Aria I
types and now use only disks and and
write your destructor code in an auto
every time right if you have a this is a
replacement for the one-off ad-hoc Rai
types where you're saying I need to
remember to do this particular weird
ad-hoc cleanup let me go write a class
this big to do it once you know when you
could just take that code out of the
destructor and stick it in the auto you
know what usually I don't have well the
constructor is just the thing that I'm
doing I mean that's just code that goes
right here right but I could have a a
logging disabled or object right with
REI so yes I can create a logging
enabler object or logging disabler
objects and that that's the sort of ad
hoc thing I mean if that's a useful case
that I'm going to use a hundred times or
even ten times you know five times in my
program yes absolutely you know right
that logging disabler object definitely
REI is off
but if it's just this one-off thing
where I mean this could be this is just
this is a hack where I'm saying like you
know I need to make a two line change
you know I need the code review I need
to push it today this this is this is
not you know well guys look I think we
need logging disabler let me write this
header file for it and let's figure out
where to put it and what to call it
and then you know this is I need to
automatically do a thing at the end of a
scope done right so I mean that is the
use case this is not a replacement for I
at all right this is not a we use up a
lot in our code base you will see people
making raw pointers and newing you know
new T and then auto-delete auto-delete
pig is all over the codebase but that
that is obviously a code smell that
should not exist nobody should ever do
that they should use unique pointer
right but for the a dog code where it
doesn't really make sense to create a
whole new object that's what we're
looking for here like in this case right
we're just at the end of the scope we're
gonna print - it doesn't really make
sense - to make a object difference at
the end - on the other hand I do like
arguing with the audience that this is
one way that this will stretch into the
full hour but but also yes well baby and
clearly the audience agrees so so here's
the code that's generated for this this
example program using client 3 for the
current clang I think is three five they
might even be up to three six now but
this is three four cuz that's what I
happen to have on my macbook this is
with o2 which is perfectly reasonable
for optimizations it generates perfect
code perfect code right not not like oh
there's a little bit of overhead but
this is literally the code that you
would write in assembly if you needed to
do that thing as efficiently as possible
and what that thing is remember is a
main function that prints one prints two
coal's foo and then prints three whether
it rose or not and that it's exactly
what we do here right the first well we
have a stack frame we can get rid the
stack frame by passing a break after the
stack frame we push the address of one
we call put s we push the address of two
we call put us right Otto had no
overhead there which surprised the heck
out of me the first time that I compiled
this because I was figuring you know
there's gonna be a little bit of
overhead because I'm a breaking these
lambdas there's templates there's all
sorts of things but - smart Netra thin
lines everything I mean it knows the
body of a lambda it knows when you call
it you know it's smart and inlining just
gets rid of everything well you know
that's clang that's that's nice new code
let's look at GCC which is older GCC's
code is shorter it's only shorter
because it omits the stack frame you'll
notice that the the name mangling is
different because this is Linux but
again perfect code load the address of
one call put us load the address of two
called put us call foo in both cases
we're using a table different exception
handling which means that if who doesn't
throw there's no overhead at all we just
go to the next line when we return and
we put us three and then we return if
food did happen to throw there is a
table somewhere else in the data section
or Oh data from some other actual
section but basically our data that says
if inception is going from this line
please jump through this other line in
this case that would have the address of
l3 and so if who throws we actually go
down to l3 and we execute that code
which calls put s3 again the first time
in this code map and then at the end of
it calls on mind resume to continue on
lining the stack so this really is the
perfect code that you would expect to
see oh and by the way it gives perfect
code if you give it a hint GCC is not
smart enough to know that put s doesn't
throw I had the cheat there instead of
including still IO dot H I had to tell
it that it was no except
that may be true all right well this
that this was with the bun - this was a
GCC for eight and lived in C++ that's
all I know
I know that I needed to it's add the
know except to make that work
obviously it should work out the box
clang makes it work out of the box so it
can be done this is the state function
version this is using state function in
the red text that we saw earlier this is
terrible this is just ridiculously bad I
mean it's got stack check cards which
I'm not even sure what those are doing
in there they're probably in line from a
constructor or something
it's got calls all over the place so
it's actually calling out to out of line
code and in fact if this is just an
excerpt from the assembly less thing
there's another seven hundred lines of
assembly just those did functions
constructor and destructor and whatever
else we're doing with it I think we have
to copy one at some point there's all
sorts of stuff it's just terrible so how
so how is it implemented to get such bad
performance so this is where I asked who
has implemented a new his scene type
erasure and got very few hands so I
actually added some slides of this last
night about Piper racer so here's the
idea a stead function is trying to
capture an arbitrary callable object
that means essentially an object of any
type at all and it could be a function
pointer I could be a lamb there could be
some user defined type and of course
user defined type means any type at all
so the first step is we need to make
some sort of container that holds any
type at all
that's easy make a template class write
a container of T now can hold at it and
then our stead function is going to hold
a container of T problem there is now we
have the same problem recursively don't
wait well not really because now the
thing that we're holding is on the
arbitrary type it's actually a type that
we control it's a container of T and we
can do things with those container of
these that we can make a pointer that
points to any container of T just by
making it inherit from a base class so
now we have a class container base we
make container of T inherit from the
inner base and in our actual type of
subject class we have a pointer to
container base and whenever we want to
hold an object of an arbitrary type X we
make a new container of X and we we save
it if we want to do anything with that X
we need to expose those through virtual
methods of the container of to how many
people did that make sense to that's
more hands than the type of raise your
hands so that's what it looks like in
one screen so we see all the same things
like I said earlier I'm not claiming
that this works for every type also
we're completely ignoring the whole
thing that stood function takes a
function signature I'm just assuming
that it's boy to avoid and I sort of
fudged the construction here that a real
state function would be constructed from
all sorts of different things they'd
probably be some r-value references
involved I just pass everything by value
and move it around but that's basically
they the thing here and you can see the
performance issues that we saw in the
assembler code right namely virtual
dispatch calling a virtual method has a
runtime cost memory allocation new and
delete right every time we create a
state function even if it's on the stack
we're doing heap allocation if sigh if
the size of lambda is small we could do
some sort of small string optimization
where we actually put it into the space
on the stack that's the optimization
that would suppose Clause doesn't do and
neither does Liv C++ as far as I know
also at one point we actually were given
this lambda we actually have to move it
onto our new container of T on the stack
or sorry on the heap we have to move it
from wherever it is to on the heap that
means a move construction move
constructing well you know was
introduced in sequel as possible and it
is cheaper than coffee constructing in
general but it's still more expensive
than not doing anything
all right the the cheapest thing that
you can possibly do in C++ is
nothing and what we're doing here is not
nothing therefore it is more expensive
than it needs to be also a last thing
which again surprised me a little bit
when I realized that was that in one
place here maybe two places we mentioned
did move which you think of it I mean
all it's doing is casting to an R value
reference it has no effect on the value
it's purely a type system feature but in
order to get at you you need to include
utility and what it actually does it
doesn't just cast to T ref ref that's
what stood for windows what it does is
it casts to did remove reference of T
RepRap and instead remove reference has
to be instantiated for whatever T it is
that you're moving and so you end up
with a whole bunch of instantiations of
remove reference floating around and so
that contributes to your compile time
and possibly to your length I'm not
saying you shouldn't use tittle courts
you should use did move but it's
interesting that when we're trying to
write the smallest possible thing that
gets the job done we realize wait a
minute every time someone instantiates
this thing
they're also instantiating a whole ton
of pipe traits ok so people were asking
why don't you just do something
different yeah that's always what they
ask when you come up with something
right it's what why don't you just do
something different there are some
different things out there that all
solve the same problem dating all the
way back to Alexander rescue Andre
Alexandre skew and head true margin yah
I have no idea if I'm pronouncing that
correctly December 2000 C++ 98 even
before the O 3 standard they wrote an
article in dr. Dobbs titled changed the
way you write exception faith code
forever where they introduced this idea
of a scope guard object where you give
it something to run in the destructor
and then it does that of course in their
day they did not have lambdas so you
said well it can take a function pointer
or I can take a method and this is the
sort of syntax that they would use for
our example way back at the beginning
Oh at the end of the scope I need to be
in a belonging this is made easy by the
fact that the codes aren't the end the
scope was just you know stay tuned Ava
login if it had been
and more complicated that control flow
it would have had to be encapsulated in
a function before you could use it and
in fact I think yes right can't run
arbitrary code unless it's wrapped in a
function can't write your cleanup code
in line and your cleanup code can't
refer to local variables because you
can't capture anything Auto captures
everything from your local scope by
reference so you can even modify it if
you want because there's nothing wrong
with that except insofar as this is
something wrong with mutable State right
but that was the whole point of the
example wasn't the mutate state here's
boost boost has a thing called scope
exit it suggests that you write that top
thing that's three lines they probably
don't have to be on three lines but if
you read on one line that's even worse
very similar to Auto actually in that
you don't see lambdas anywhere but it's
so much boilerplate at that boost scope
exits and then you have to list out your
captures explicitly in that case and
they give a sequel of an alternative
with a lambda where again you have to
see the lamb that's Blissett Lee and you
have to come up with a unique name which
we use under under counter for but again
coming up with unique names it's it's
not hard but it's harder than it needs
to be because the easiest thing to do is
nothing if you're not doing nothing
you're doing too much
here's Google scope exit this this is an
example taken straight from their
documentation by the way I am amazed
that they would write this in their
documentation and not kill themselves
they have I in parentheses and then they
have scope exit template bar T because
they have to capture that T and somehow
that's different somehow T is a
different sort of entity from I and X I
don't really know why yeah also
capturing that this pointer is some
other weird macro I don't know what
they're doing but it's it's weird and
again you have to explicitly name
everything you capture this is something
on Google code this is called scope exit
I believe it's from Google
if it's not my apologies to Google did I
get a they give a link back here I did
not but I'm hoping that if you google
google scope exed you'll find out where
it comes from it may be someone else
entirely in which case my apologies to
whoever it is and my insults to whoever
actually did because we've seen right
like why would you write this right like
there's there's arguments for okay let's
get rid of all of this let's just use a
the REI we're familiar with of writing
these ad hoc classes okay we all
understand that but why would you choose
to write this and so here it is one more
time that this is the thing that you
should memorize and take home with you
and evangelize oh you know remember how
to write that thing that captures lambda
and calls it an instructor remember how
to paste things together and use counter
to create one of these things and wrap
it all up in a nice short name which I
almost for this presentation called
finally instead of Auto but that's also
slightly misleading and and yes new new
developers come on board and they write
something and we say don't you know Auto
solves that and they say I've read every
C++ book on auto and I don't see how
that solves my problem and we have to
tell them no capital a Auto go look it
up it's at this header file so Auto has
its own problems but whatever you want
to call it I think that concludes that
first oh no it doesn't quite let me
cover this in the milk with you um so
this is one or application of how to use
this sort of thing more macros we happen
to like macros a certain degree
I personally temperamentally put like
macros a certain degree
some people hate macros if you hate
macros don't watch this part we have a
lot of code that looks like this we have
a thing called a code printer it's
basically a string stream you can printf
things to it it has methods scope and on
scope because it's made for printing
code that we're going to then print out
to a file that will print curly braces
and then indent everything afterward
right it keeps track over the invitation
level is
but you could write this right but it's
really unknowing to have to do all this
scope and unscoped it's very confusing
to look at this code and try to figure
out okay I need to add one line to the
generated code where do I add it to this
code and so what we actually write is we
have a single macro macro called
otoscope where what it does is open a
scope and then Auto unscoped it so now
you can actually organize your code so
that the code generator resembles the
code generation in the structure of it
actually matches and that you can see
okay why when I add something in the
body of the if I know exactly where to
put it because I see the body of the if
you know on my screen so I thought that
was pretty cool
you spell the question well we don't use
exceptions at all so yeah the question
was should you put no except on the
destructor or that you should put no
except on the destructor also true and
and I mean maybe you could throw an
exception out of there and it would be
ok in some cases I don't know it it
seems like you know it if you throw
something out of there you probably have
some sort of issue anyway I don't know
yes well then your one thing to do
something no matter how I exit the scope
right at the end of the scope no matter
what where you're no matter what code
throws I contend that that's a bad idea
anyway
all right your clean up code shouldn't
be throw away her clean up code is
throwing that's as bad as a destructor
throwing because in this case it is a
destructor throw it right in the
structure should never
yeah in other words this is a tool that
makes it easy to shoot yourself in the
foot and blow your whole leg off yes if
you're in the habit of aiming at your
feet yes you know we we don't use
exceptions so we don't have that problem
if you do use a lot of exceptions have a
lot of functions that you're newbies are
gonna use and just throw exceptions yeah
you probably shouldn't be using this but
I don't know if that may be a code smell
anyway yeah
yeah definitely nobody should be using
go-to error like ever I even if you
don't like macros or crazy magic or
token paste thing or any of the other
things going on here I think we can all
agree no one should ever use go-to error
and if not hold it till the end so that
was chapter one we do actually have a
whole second chapter we have about 30
minutes left if I read that sign
correctly so this is good because this
one should be fast this is about inside
out containers this is something I'm
sure everyone has seen before but I'm
going to motivate the example anyway we
have we're modeling sequel tables so we
have some metadata about them
represented as C++ objects this is not
about ODB about about representing my
schema this is this is about
representing a table itself so a table
has columns and it has keys right and it
has a bunch of other stuff but for the
sake of fitting on one slide we've got
columns and we've got keys and because
we wrote this code in a hurry
ten years ago it looks like this we have
just a pointer to a bunch of columns on
the heap and column count that says how
many we got and the same thing for keys
and we have some accessors because
everyone knows that in C++ you should
use accessor methods right getters and
setters and so we have some getters for
all of our different members every
single member because who would make
them public and then we well oh yes why
why would we not just use that vector
because I was gonna say we have stood
back here for this if you just want to
allocate things on the heap but maybe we
have some more complicated case where
our keys are really segregated into
common keys and foreign keys and we want
to iterate first the first half of the
array the second half of the array the
whole array what you do is very easily
and maybe we care about size efficiency
where you'll notice that we can put to a
an 8 byte point or an 8 byte point or a
4 by quantity or 4 by quantity instead
of having to organize all sorts of
historical legacy reasons including your
design choices that we might want to
organize it this way and now we have to
deal with it and so we write a whole
bunch of code that looks like
this and this is terrible right this is
basically worse than the sort of default
c++ out three stuff that the VR now was
talking about in his keynote before
lunch where we're not even using
iterators we're using in some we're
iterating over the getting home columns
and pulling the IP element out of get
columns and we don't want to deal with
that we want to write something that
looks like this this is using nice new
for loop syntax which everyone should
use and I hear it's getting better at
some point in the future and that you
won't have to write the type anymore and
so we have this free function columns it
takes an empty table star and gets us an
iterable of the columns it doesn't just
get us the pointer the columns right
because that's not good enough it gets
us pointer and an extent in some form
that can be consumed by a range for loop
what does this look like looks like this
more or less modulo constand and you
know overloads for references in all
sorts of things it looks like this we we
got the columns pointer and we kept
that's a pointer to the beginning of the
array we we get the pointer to the end
of the array and we package those up in
something we call make iterable
analogous to make pair and we do the
same thing for the keys and we return an
iterable of that iterator type how many
people does this already look familiar
too okay good good number of people
right so iterable then naked or boy the
concepts here those are things that we
need to then implement as our take home
things they look basically like this
right an iterable is basically a pair of
iterators it's got two iterators its
constructor takes two iterators it keeps
them for you when you call begin you get
the first one when you call it and you
get the last one and make it verbal is
just the factory that that sort of hides
the fact that you have
the template by conduction idea hides
that from you just likes did make payer
and make shared and make unique make
unique is coming in C++ 14 everyone in
the world has a version of this so
Marshall file has a blog post he calls
it iterator payer house their Meredith
has a paper where he wants to call its
did range Google has a paper but they
want to call its did range boost calls
iterator range and it's with the pair of
iterators in fact you might wonder how
much like a pair of iterators isn't in
the original proposal for c++ 11 it was
actually called stead pair what follows
is a summary of a nice paper by Alastair
Meredith it's not actually in the
audience is he know called pairs do not
make good ranges spoiler alert
pairs don't make good ranges so uh this
is a bad idea to to basically the so
this equals 11 proposal said we need a
way of doing this let's say if you have
a pair of two iterator types or
basically if a pair at all and you call
you know you can say pair dot first to
get the first one pair dot secondly at
the second one let's just call them
begin an end hair it off begin gets you
the first one pair dot and gets you the
second one that sounds great then you
could just use it in a in a for loop and
it just works and they were gonna
standardize this until they decided well
actually this is kind of a bad idea this
is audience participation why is this a
bad idea I meant someone actually answer
that
Nullah infinite rain ball kind of but
you never want to run it for loop over
an infinite range I mean that's the
thing that the working group on now I'll
cover the working group on ranges later
but basically we have some pairs of
iterators in the standard library
already and you can conceive of others
that are not ranges you can have a pair
of iterators that does not represent the
range for example they could just be in
the wrong order right and come up again
is not a range and you think of any
stand
algorithms raise your hand if you can
think of a standard algorithm that deals
in pairs of iterators that are not
ranges i see no hands
here are three these are highly obscure
but they exist mismatched for example
takes basically it takes two containers
and gives you the first position at
which they differ but of course in order
to do that because the standard
algorithms all the old iterators it has
to take the beginning and end of one
container the beginning of another
container iterate over them until it
finds a difference and then it returns
that pair of iterators one into the
first container and one into the second
container so it gives you a pair of
iterators that aren't even into the same
container and they might even be
different types min max element is
better and worse in that it always gives
you a pair of iterators into the same
container the first one points the
minimum element the second one point
maximum elements if you're lucky or
unlucky this is actually arranged but of
course they could be in the other order
or if it's a range of one element I
guess they might be the same and
partition copy does something obscure
which I will skip because it is
irrelevant and so here's the summary the
take-home print sideout containers is
there it is you can make a container
view of any old object right if I have a
pointer and an extent or two pointers I
can just wrap them up in a call to make
it durable and suddenly I have something
like the begin and end I can iterate
over I can pass it if your honor gets
this way as he again talking about
makino to you you know all the standard
algorithms right now use pairs of
iterators as their or iterators as their
core concept he says well really they
should be using containers like
container is kind of a better concept
but we don't have any way at the moment
to get a container out of a pair of
iterators unless you read it yourself
like this you can iterate over it so
frames you can have an object like table
that has columns and keys and we don't
have to decide which of those is table
about begin and table about end and
which of them is some random thing that
can't be iterated just they call them to
the table keys in table ranges are
coming at some point there is a study
group I think it might even be study
group number one that wants to put
ranges into C++ seventeen
they have no proposal I wrote this at
home having no idea I came here I talked
to Alastair Meredith and Marshall Clow
and and said okay tell me what I should
write here instead and they said now you
got it pretty much right yeah
we have no idea because they don't want
to standardize something this simple and
then block something more complicated
such as infinite ranges or being able to
compose ranges you know which are things
that you can't do with this very simple
thing so this very simple thing they
just didn't make it into any standard
ever and then we get the chapter three
stood spaceship which I could cover we
have 15 minutes left apparently we're
there any questions about about iterable
now all right
boost iterate arrange sure a terator
prepare what they call it boost has a
thing called iterator range which i
believe is is what we're talking about
here all right so there are a lot of
slides in this but I think a lot of them
go past also here we're no longer
talking about the same code base we're
gonna talk about LLVM this is something
i saw come by on the LLVM mailing list a
while back where the clang is currently
upgrading basically it's code base he's
filled to C++ 11 and one thing they have
in a lot of places is oh this is messy
code let's simplify this good they have
a thing a convenience method that sorts
an array of plain old data you might say
why do they even have this even C++ 98
had stood sort why don't they just used
it stored and the reason that they don't
use it often is because a lot of the
time something like you sort performs
perfectly well and there's no reason to
go through all again all that template
instantiation bloating your code base
with different template instantiations
or something that can be solved with a
sort so they write Q sort they call Q
sort and they pass it their start and
end iterators and a comparison function
very nice then all you need to do is
write the comparison function that you
would pass to this array pod sort method
so someone recently not that recently
anymore but a while back went through
found all these copywriters and turned
them into lambdas and then realized that
didn't work with em SBC or some little
GCC or something and reverted all but in
the meantime you got to see every copper
ATAR in the system and I looked at some
of them and they they come in all sorts
of flavors for comparing two items this
is a pretty common idiom by the way of
doing this kind of comparison you all
know Q sort takes a copper a tur that
returns negative zero or positive
depending on whether the item is less
than you can do a greater than right and
that's pretty common because in C we
have store comp everyone knows store
comp it behaves that way and then Q sort
and B search expect comp raters that
behave that way unfortunately you can't
Pastor comp to Q sort because when
you're Q sorting arrays which are star
you really need something that takes
charge star star right
but yeah so C has a bunch of these
functions that that return this negative
one zero positive 1 or negative
something zero positive something to
tell you given two things compare them
not is one less than the other not not
any sort of boolean predicate but just
compare them and tell me the answer
you can C++ has some of these stood
string has a compare method which
behaves like stir comm how many people
here know that that method existed the
string compare fair number it is
documented but do people read
documentation no but we have a whole
variety of these cooperators right just
in in LLVM alone not to mention all this
other code you know there's all sorts of
different ways to write this fundamental
operation of I would like to compare two
things please tell me the answer and
it's not really clear which of them to
write and again that this kind of goes
back to the what I talked about with
pragma once where when there's a bunch
of different ways to write things and a
bunch of different ways to get them
wrong that's suboptimal we would we
would like to avoid the the bike
shedding on the style of each of these
and just say like I wish that we should
have a simple way to do this right does
the one nice way to say I have two
objects I would like to compare them
please give me the answer this is a salt
problem right if people who have used
say Perl or any of the other languages
that stole it from Perl know that it's
called the spaceship operator it looks
like that because it looks like a little
spaceship all right looks like Darth
Vader's ship and this is what it means
this is not to talk about operator
overloading I know as soon as you saw
this slide you were like oh my god he's
gonna somehow overload the I don't even
know right and now I don't think that's
actually possible we can just spell it
did spaceship I would be satisfied with
us did spaceship if it actually made it
ever into the standard I assume it'll be
called stick compare you know because
it's boring but if it were called stood
spaceship
you know it's dead dinosaur did robot
those are all good names so this is how
LLVM first decided so this this came in
a discussion on the mailing list that
someone said oh okay well we can
actually just write a generic compr for
any type T if we just write it like this
will pass into void stars that really
point to the T's or we interpret cast
them back to T's and then we'll compare
them if P one is left over to R minus 1
if P two is less well return positive
one otherwise we'll return 0 done and
done and then the bike shedding starts
all right because what's what so what's
the problem with this what's that we're
gonna assume that people use it
correctly we're gonna assume that they
are in fact typed it stood sort because
we're only introducing one template
we're not introducing intro sort and
heap sort and ba ba ba ba ba now the
real problem here is inefficiency says
the guy on the mailing list because what
we're actually doing here is two
comparisons right
all comparisons our chief right after
you can carry in sore whatever the thing
is we're not right we're comparing
arbitrary types so what if T is stood
tupple all right what if it's a couple
of a million items or any domes in
general here's how thoughtful comparison
is implemented this is not actually that
important so I am going to skip it and
move on but basically whenever you
compare a tough ball you have to compare
the lexicographic order that means
compare the first ones if they're
different then you're done otherwise go
on to the second one if they're the same
go on to the third one if they're the
same going to the fourth one and so you
got all the way down at the end you
compared all n items and they're all
equal then you can say for sure it is
not less than okay well is the other one
less than it
all right well go all the way down right
which is the reason that things like did
string which is basically a vector
provide a separate compare method so you
don't have to do this helpful as far as
I am aware and hopefully I'm not wrong
my presentation was based on this does
not have a compare method but really
like so one right we don't actually have
a bunch of tuples and we don't actually
compare them that new compares tuples
unfortunately lots of people at least a
while back I've been saying you know C++
11 makes it really easy to create tuples
and then compare them we want to use
things like this right wait we want to
say I have a class and I know how to
compare it and how I compare it is just
really it's just I Tom wise buy some
ordering of the members right I've got
to compare their A's and then I'm gonna
compare their B's and I'm gonna compare
their season I'm gonna pair their DS it
might not be lexically as they're
written in the class it might be in some
other order but that's that's basically
how we compare a lot of things right
compare it first by last name than by
first names and by middle name then by
date of birth you know in until you
figure out what the answer is and you
normally would have to write out all
that boilerplate right if last name last
them etc etc but C++ 11 makes it nice
and easy
actually this is the applause-plause 14
because the auto there doesn't actually
have an arrow and then telling me what
type
that's the only reason that you couldn't
write this today I mean you could write
this today you just have to go by once
equals 14 mode and so this is really
what we want to write we want to tie
everything up in a couple of references
by the waist stood tie and who seems to
die all right who see this didn't make
couple more hands all right did make
couple makes a couple it makes copies of
all the things you pass to it and it
returns you a topple of them did tie
makes a couple of references
it takes references to things you pass
to it and returns a couple of references
this is for most purposes
indistinguishable from a topple of the
actual things but it's extremely cheap
because you're just taking references to
them and it all gets inlined and there's
actually no overhead at all I have an
actually profile that there might be
overhead to it but I think there's no
overhead at all and so this is the idiom
that we want to write if we just want to
compare two items of type my class where
it's a then B then C then D we just tie
everything up in a couple compare that
this one topple to that guy's all their
topple and then that's the answer the
problem is that then to do the erase pod
sort copper ater that requires comparing
a topple once for less than and then
again for less than s disastrously
inefficient because of those twice as
many comparisons as necessary so yeah oh
yeah how to implement it right by the
way I've got five minutes left this will
go pretty fast I will probably go over
and take questions so this is the easy
part right this is the for any type you
just do the the obvious thing and then
we're going to specialize this template
for couples oh yeah really really if
we're putting this in the library we
have to put all your scores in front of
everything you get the idea
oh and we need one more there's one more
complication of one more little wrinkle
is that stood string also needs its own
little overload where it's going to use
the compare method because they wouldn't
be properly implemented if it didn't use
the most efficient means possible for
that
and yeah again we really mean this but
we'll skip over that here's the hard
part and I could explain this but I'm
wondering if people care if you can read
this you probably already know what it
says if you can't read this you probably
don't care what it says explain it
anyway so we have a a context for
function
it's called spaceship it's it's a oh
load
specialization more like a
specialization for couples I'm sorry
it's actually everyone and we're just
gonna static assert that the two tuples
that you're passing in the spaceship
have the same size they might actually
be different types because I don't know
maybe you want to do something weird
you've got one of Long's and one of the
end so you still want to compare them
anyway we'll let you do that but they
better be the same size right I guess we
could make up some semantics but all say
they have to be the same size move a
static asserted we could use something
like enable if if we hated our users and
we wanted to make the error messages as
in comprehensible as possible but if we
want a nice error message we'll use
static assert and if they misuse it
their programs gonna not work anyway and
then then we call this function couple
spaceship and we pass it the size of the
tuples that we've got as a template
parameter I'm sorry that is not a
function that is a type that is a type
constructor and it has an operator print
friend because I like to make things
unreadable and the operator prime friend
takes the two arguments what it will do
is compare every element of the tupple
all the way up to the IP element and
give us an answer for that how do we do
that well we compare the IP minus one
elements at the front and if that gave
us an answer awesome we're done
otherwise get the IP minus minus one
element and compare that recursively
using spaceship because it might be
stood straight or something
let's say and we have a base case base
cases duffel spaceship of zero element
topple but it work yes however this is
recursion in the type system rather than
at runtime right so it mostly collapses
down and collapses down very expensively
and slowly in the compiler but at
runtime if if we're lucky if we don't
have a debug mode on so yeah there is
actually another way to write this
actually this is an excellent excellent
talk
actually haven't seen the talk so I'll
just say it's excellent excellent slides
that everyone in this room if you care
about this stuff if you're trying to
understand this and you get it you need
to see I forget his first name something
video and has this up on github with
with also very very nice slides of just
really simple ways of doing meta pro
tempore meta programming really
efficiently in sort of ways sort of like
this this is not one of his examples but
this is how I imagine it might uh it
might get written in this case what we
do is we allow the what do I want to say
parameter packs to do our work for us we
use parameter pack expansion so we don't
have recursion with the base case we
have iteration we want to do something
for the zeroth element the first element
the second element the third element all
the way up to the nth element how do we
do this well we just need to get a
parameter pack that consists of 0
through n and then do that thing dot dot
dot for every item in the in the
parameter path from 0 to n how do you do
things in order in C++ 11 you use the
militia wiser list initializer lists are
comma separated things that respect
parameter pack expansion and most
critically happen in order from left to
right off the bottom this is not true of
function argument lists or a lot of
other cases where you might want to use
it but it is true
by the standard for initializer lists
I'm being told the session is over but
this is I think one of the last slides
so I'm gonna take a few questions anyway
if there are I tried benchmarking these
that the code for benchmarking them is
on the sia CMU CPP CPP con you were out
with the the beginning of the talk so if
someone wants the benchmark it for
somewhere other than clanging three four
on Mac OS X over it
and let me know the answers anyway
that's just another way that you can
implement that and I think oh yeah yeah
then you should use did spaceship
everywhere if someone writes it up you
know anybody on the Standards Committee
that's right I believe that that is
unfair and it should be in the in the
standard and possibly in a future
standard but yeah it would be nice
wouldn't it yes that was a somewhat
tongue-in-cheek are there any questions
about any of the parts so the pocket yes
I just had one additional comments about
when you add exceptions and you use auto
in your very first example of using auto
you had an action logging was disabled
and then Auto enabled it if you use
standard function even though you don't
because you don't care about the
performance problems don't because that
construction can fail and you will never
be able logging that's true constructing
a stead function because it uses heap
allocation presumably throw bad a lock
or something yeah
if Malik fails used to just exit your
program in most cases yes yeah I mean
well bad alec is provided for some
reason so someone might think that well
we ought to try to handle it but yeah I
mean I would agree that in general you
can't do anything about it and really I
mean if you're on Linux you know Malick
is never gonna return null it's always
going to give you a chunk of memory even
if memory is full it's gonna say yeah
you know I can get it from somewhere at
some point and if you actually run out
of memory what happens is the OS kills
you you don't get a choice that's
assuming that you are the sysadmin of
the computers on which your program is
running sometimes that's not true though
yes so I actually work on a domain where
we we never want to try and handle out
of memory but I need to stand up for
those people who do handle out of memory
because I have done it in the past and
there are definitely cases let's say
you're working on a graphics editor and
you allocate an enormous image the user
requests a billion by a billion image
you will run out of memory and you
better not crash because they're gonna
lose all their data and they're gonna be
angry with you and and the other point
in that area is that the one time when
Linux or Windows I will definitely say
hey you're out of memory is if you're a
32-bit process 64-bit OS technically
you're out of address space but they
will have no choice but turn 0 because
there are no other pointers that they
can return this is definitely one that
we hit is running out of address space
not really relevant to the talk though</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>