<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Michael Price “Function default arguments: Slingshot or Shotgun?” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Michael Price “Function default arguments: Slingshot or Shotgun?” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Michael Price “Function default arguments: Slingshot or Shotgun?”</b></h2><h5 class="post__date">2017-10-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NeJ85q1qddQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Hi, I'm Michael Price.
The talk here is on
function default arguments,
slingshot or shotgun?
Currently I'm an employee
at Synopses working on a
static analysis engine,
where I do a lot of
compiler front end work.
And some work that we had recently done
sort of required a more stringent
look at default arguments,
and sort of inspired some of this talk.
So hopefully I'll get to mention that
later on in the slides, but we'll see.
Who all here thinks they know
what function default arguments
or default function arguments are?
Just raise your hand.
Everybody thinks they know.
How many people here think that you know
most everything there
is to know about them?
Okay, we have a couple.
Okay, well let's get started.
So, the basics.
A function default
argument are expressions
that are evaluated when there
are fewer provided arguments
to a function call than the
number of parameters specified
in the function definition.
So how that works.
You have a declaration or
definition of a function,
and it's got four parameters.
You have a call site for that function
that only provides three arguments.
Normally this would be
a compilation error,
you didn't provide enough arguments
to satisfy the signature
for this function.
But if the definition or
declaration of the function has
specified default arguments,
then you can leave off arguments
at the end of your call.
And it's pretty common.
Most languages these days
have some form of this,
and it looks like a pretty basic
and simple language feature, right?
What can go wrong?
So some terminology.
Function default argument,
or is it default function argument?
When I first came up with the title,
I thought about this and I settled
on function default argument.
As I was actually writing,
preparing all the material,
I decided, &quot;Yeah,
default function argument
actually makes more sense.
So the term default argument appears in
the working paper for the standard, a lot.
So there's a whole
section sort of dedicated
to default arguments, it's listed there.
And in some places in the standard,
they actually use the term
default template argument.
They don't really use the term
default function argument, though.
So default template arguments
are a lot like default function arguments.
It's just they're provided
for template parameters,
type and non-type parameters.
You can say type name, T equals int.
Say that if you don't provide
this type of parameter,
we're just gonna assume it's an integer.
And so you kind of have to,
when you're looking at the standard,
you kind of have to put it,
when you receive default argument,
you have to put it in the
context of what they're talking
about to kind of understand what it is.
So I'm gonna call them
default function arguments,
or just DFAs from here on out,
throughout the rest of the presentation.
So a simple example,
and I'll let you grok this for a second.
Okay, so it's pretty simple.
We have a function called
fn, that takes a string
and returns the string.
It just returns what you gave.
And we provided a
default function argument
of the string &quot;foo&quot;.
So then in our main function here,
we can assert that if you
pass in a string to fn,
you just get that string back.
If you don't pass any string in,
you should get the default
back, which is &quot;foo&quot;.
Simple, easy, piece of cake.
Now, this is sort of like
the first entry level,
this is obvious, right.
It shouldn't confuse anybody.
Now you can have a default argument
in lots of different cases, though.
You can put them on member functions,
you can put them on
parameters in the lambda,
the signature for a lambda,
you can put them in there.
You can put them in function templates,
so on and so on.
Most of the time, if you're
doing something simple,
the syntax that you think should
work is what's gonna work.
Okay.
But there are some restrictions.
So default function arguments can not,
do all of these things. (laughs)
So you can't put them in functions
like operator functions, like operator+.
You can't put a default
parameter on the type or
default argument on the parameter there.
Unless it's operator call, parens,
because that makes sense.
It's a parens, you're calling it.
You can't collide with things,
they can't appear in friend declarations,
except with some exceptions.
There's an interesting thing that
concepts is being added
in, to the language.
We're trying to get it
added into the language.
And they introduced a thing
called requires expressions,
which can actually sort
of introduce a signature,
just for type checking.
You can't put them there, because
it doesn't make any sense,
because you're never going
to invoke that thing,
it's just for doing the type checking.
It can't show up in
defaulted member functions,
user-defined literals.
There are other things like,
it can't be provided for
the size_t parameter of,
if you have a custom new
function, you can't say,
&quot;No, no, no. If you don't say what size,
I'm going to say, 10.
It won't let you do that.
There are other things that make sense.
It can't be for a parameter pack,
because that's the other feature that
sort of lets you throw
extra things in, right?
And one that kind of gets some people is
that you can't use it to
deduce template type-parameter.
So in function templates, you can say,
template type name t
void f-n-t-i equal one.
Right?
If you call the fn With no parameters,
it won't let you do that,
because it can't figure out what the t is,
even though you have a default argument.
It's just like no I'm not
gonna let you do that.
So, there are even more restrictions.
So that was things that default arguments
can't do themselves.
These are restrictions that you can
put in a default argument.
Because remember default
arguments are expressions,
just about any expression
you can come up with,
in the language with you can form,
can be used as a default
argument, except for these cases.
So, you can have a lambda
as the default argument,
but only if it doesn't capture anything.
You can actually have
the capture specifier,
but as long as it doesn't capture
anything then you're good.
If it captures something,
the compiler will complain.
You can't put this keyword in,
there are various reasons for that.
In that last bullet point,
previously declared parameter names,
unless in a unevaluated context.
So in my signature I said,
int-a, comma, int-b equal a.
Just give me the whatever
the first parameter is,
I want that same thing,
if you didn't give it to me explicitly.
That's not allowed, right?
Even if there's another
a somewhere in scope,
that's visible globally, it
will find the a in the signature
but it will not let you do that.
In order to get the
one that's out of scope
you have to put the scope operator
and give it a more qualified name.
There will be time for questions later,
and if that's a lot of stuff to process,
who here likes lots of pictures
in there presentations?
Okay, sorry. I'm not
gonna have any of those.
Who here likes code examples
in the presentations?
Good, I've got lots of those.
Who here likes live demos
during the presentation?
Okay if we go fast, I
might be able to do that.
Before we get into more examples,
the whole premise of the talk
is, slingshot or shotgun.
Who's familiar with foot-gun?
Like C++ is a foot-gun,
it's like pointing a gun at your foot
and waiting for it to go off.
So that inspired that
subtitle of this, right?
So a shotgun, it spreads,
it could be really
damaging and harmful right?
You don't want to shoot
your foot with a shotgun.
A slingshot, well a slingshot can hurt.
It can be very dangerous,
but usually it's a little
more finer precision.
It's not a shotgun so we
gotta decide, what is it.
I'm gonna say it's mostly a shotgun.
If you use it carefully,
it can be a slingshot.
So guys, don't use them,
unless it's that simple case
that we saw, right there. Just don't.
If you're tempted, don't do it.
There's a caveat.
There's some really cool uses
for default function arguments,
maybe, maybe you could
use those, probably not,
but if we get to it, I'd
like to show some of those,
but again we gotta go fast.
So if I said, don't use these things,
the first thing your gonna say it,
but I want to, what can I do instead?
So there's an alternative.
So in C++, we have function overloading.
An overloaded function can take
multiple sets of parameters
and you can use this delegation method.
So on lines one and two,
we have sort of the
default arguments version.
If you provide no parameters,
no arguments to that,
you're gonna get back the sting &quot;foobar&quot;.
Then we have one that uses
overloading and delegation.
If you don't provide anything,
we're gonna call the one
argument form with &quot;foo&quot;
and then that's gonna insert
the second default &quot;bar&quot;
and then delegate up to the
one that takes both parameters.
That's a lot more typing,
it's a little safer for various reasons
and you can see the insertions
here that I've made.
They're equivalent right there.
Regardless of which technique
you pick, they're the same.
But it turns out, that
that's not exactly true.
They're not perfectly equivalent things.
For one, you've got multiple functions,
which means the symbols
in your symbol table.
Where as with the default argument form,
there's only one symbol.
That could affect things, like
if you're at a extern C block
which says you can't do overloading there,
so if you're in that, you can't do this.
So you have to use the defaults.
So here's a more devious example
of why they're not equivalent though.
So if you look at lines six through 13,
those are basically the
same as the previous slide
that we saw with code,
except that the default
arguments aren't literals now.
It's a function called next.
And if you look up at line
four, the next function
is basically indexing
into some global array
and then it's actually keeping
track of where you're at.
It's like an iterator.
What's so bad about this?
So on line 17, you can see,
we called defaults with not
parameters and we get &quot;barfoo&quot;.
If you remember in the previous example,
we got the first argument
and the second argument
and you would think that we're
gonna index into this array
so why aren't we getting &quot;foobars&quot;?
Does anyone want to offer a suggestion?
These expressions that are
the next function call,
whenever you make that function call,
the order in which those functions
are called are unspecified.
So in this particular case,
the second default argument,
gets called first and
it get the value &quot;foo&quot;
and then the first argument
gets invoked and it gets &quot;bar&quot;.
So you get &quot;barfoo&quot; and its
like, okay that's unfortunate,
but if you see the delegation method,
because we've now are delegating
the evaluations of those
expressions in a more ordered way,
we get kind of what you
would expect, &quot;foobar&quot;
but turns out, you can still call delegate
with those expressions
directly and when you do that,
you still get the old,
unevaluated order problem.
You get &quot;barfoo&quot;.
So this is why when I say
use delegation and overloading instead.
If you try this, if you have
default arguments in your code
and you try to go replace
them, you gotta be careful.
You may have some problems.
This is where testing
will come in very handy.
Everybody has test in your code, right?
Why doesn't have test,
I'm gonna shame you.
Okay good. Nobody gets shames today, then.
Okay there's another problem,
so say you're going to to go do this,
well how would you go about doing it?
You would start replacing these things,
well while you're in
that intermediate state,
where you have some that
are default arguments
and some that are overloads,
you can create situations
where its ambiguous then.
So here we have two
functions, they're overloaded,
the overload set of fn.
One takes a string and an int
and one takes a sting and a &quot;bool&quot;.
The second (mumbles) each
of them has defaults.
So, in our main function, on line 13,
I can call it normally with two arguments,
on 14 I can call it
normally with two arguments
and get what I expect,
but if I try to call it
with one argument now it has to decide,
which one of these is the right one?
Well since both of them could be called
with a single argument now
we have an ambiguity problem.
Luckily this will just
fail to compile instead of
picking one at random or something.
So that may make it harder to transition
if you're trying to get rid of these
and go toward delegation,
its just something
you'd have to deal with.
Okay so that was all the basics.
Everybody feel they have a
good idea, a good understanding
of the basics of how this works?
Great.
So names in a default argument
are bound at declaration,
but evaluated at use, there
should be a code example.
Okay, line one, we have a global b &quot;foo&quot;
we have a namespace N on line three.
We say string function with
a parameter string s equal b
and we're just gonna return s
then the next line
inside the same namespace
we have another sting b equal &quot;bar&quot;
Now, down in our main function
when I call the namespace N
fn with no parameters, it's gonna go,
okay, I need to get the default argument,
I need to fill that in.
It's gonna pick the one on line one,
not the one on line five,
because whenever you scan the line four
and find that default
argument of b, he's gonna go,
okay well let's find a b, do I know a b?
He will not have seen the
b that's on line five yet,
so he's going to bind
that name to the global b,
but he's not going to evaluate yet.
So then whenever you actually
call it and it's required
he goes, ah okay the default
argument, okay I got it.
That's that global b you
told me about earlier
and so he's gonna use
that, so you get &quot;foo&quot;.
Now if you just say b right
there too, you'll get &quot;foo&quot;,
because its gonna find the global one,
but you could provide explicitly
the namespace N and then get &quot;bar&quot;,
so here's a little bit of a
trick though, like you said,
it's bound at time when it
sees it, the declaration,
but its not evaluated until you use it.
So now, one line 13, I changed
the value of the global b
to &quot;foobarbaz&quot;, not when I call
the function with no
parameters, no arguments,
it's gonna get the global b,
which is now the &quot;foobarbaz&quot;.
So, you have to be careful
about what's it's picking,
you could get unexpected results,
or you could get expected results,
if you know what it's doing.
Okay, so that's one step of complication,
it gets more complex.
So default function
arguments can be provided
across multiple declarations
across the same function.
So how do you know if
you have two declarations
of a function, how you tell that
they're declaring the same thing?
There are rules that state
how functions are equivalent
and the default arguments
do not play into the rules
about whether something
is equivalent or not.
It's all about the signature.
Default arguments are not part of
the signature of the function.
So line one, we have a
function that returns auto,
which is gonna be a sting
and takes a sting and takes a &quot;bool&quot;.
We provide default argument
for the second parameter b,
we can have another declaration after that
that now provides a new default argument
for the first parameter,
leaving off the default argument
for the second parameter
this is line six, okay.
A lot of people when they
see line six there gonna go,
that won't compile, no
that can't be right,
because we know that you have to provide
default arguments for
everything to the right of you,
like if you're gonna
say for parameter one,
parameter two has to have a default
and clearly on line six,
there's not default there,
but they're additive. (chuckles)
So the set of default arguments is a union
of the default arguments provided
in all those declarations.
So now on line 10 when I
assert, when I call my function
with no parameters, I'm gonna get &quot;foo&quot;
for the string and true for b,
so I'm gonna get &quot;foo&quot; back out of it
and it's just like if I declared it all
on a single declaration, right?
So, please no one ever do this (laughing)
if someone's looking at
code like doing a review,
or something has gone wrong
and that's the worst case,
something has gone wrong now you have
to figure out what it
was, someone see that,
they're immediately gonna
say, get blame (laughing)
and they're gonna get you on the IM
and complain and yell at you.
A little bit of formul-ish language.
So restrictions of them
across multiple declarations.
So given a function f for each
parameter, in that function F
there may be only a single declaration
that provides a default argument.
So you can't say there's
a default argument
for parameter two here
and no default argument
for parameter two later on.
A parameter P that has a default argument
and a declaration for function F
is allowed only if there are
visible default arguments
for all following parameters following
parameters of function F.
That word visible is
italicized for a reason
that I'll get to in a minute.
For function F, called within a scope s,
the effective DFAs for F, are
the union of all visible DFAs
at the call site.
So whenever you make the call and you say,
oh I need to get the default argument,
he looks at all of the
declarations for that function,
and he makes a union of
all the default arguments
that were visible and that's what he uses.
But there's this big black here,
I wonder what that's about.
So this is weird, the first
declaration in a scope,
hides any of the previously
provided default arguments
for that function.
This is very counter
intuitive, because we think,
we'll you're declaring
this, it should add,
even though you're in a nested scope
doesn't mean, you should throw
away everything you knew.
So now there's an extra
third bullet point.
Within scope S, the first
declaration for function F
hides any previous
visible default arguments
functions within scope S.
It's only active within that scope.
There's an example that will
clarify this in just a second,
probably terrify you too.
I'll let you look at
this for just a second.
Line one, we have a function,
it takes two parameters,
sting and a &quot;bool&quot;,
they both have defaults.
It does the same thing that
the previous slide did.
So in main, we can
assert, we call function
and yup, its &quot;foo&quot;, that's what we expect,
but we're going to into a new scope block
in lines 10 through 14, okay.
So we're not in a nested scope.
We declare that function again,
but this time we don't give
it any default arguments
on the declaration.
Whenever we do that within this scope,
those previous default
arguments that were visible,
they aren't there anymore.
So now if I try to call
function with no parameters
the compiler is gonna go,
I don't know what you're talking about,
I see a function that takes
a string and a &quot;bool&quot;,
you need to give me more stuff.
I can't even just provide one,
it's not like it hides some
of them, it hides all of them.
So then we have another
scope block, 16 through 22.
This one I provide two declarations
and I sort of give it new defaults.
So now I'm gonna say the new
defaults are gonna be &quot;baz&quot;
and faults and I do it in
two different declarations.
Now I can call function
with now parameters,
but now that the second
parameter's faults,
its gonna return an empty sting.
It doesn't care what
the first parameter was.
On line 17, if I said bool equal true,
then it would have returned &quot;baz&quot;.
Just the fact of re-declaring a function,
because I know I'm good, I'm
declaring just the function
I need out of this header file, you know,
I'm being a good citizen.
You could loose the ability to call
without default arguments.
Of course it gets more complicated too.
So using declarations, that's a way
to pull names into a scope,
it can cause more surprises.
They're actually core issues
in the standard committee
for some of these things.
So namespace N has a function that
just concats two strings together.
The second sting is defaulted of &quot;bar&quot;.
So then I say using n colon fn.
So at that point, the
function in colon, colon fn
is available in the global
namespace just by the name fn.
The thing to know there is that,
the using declaration only
pulls into the scope you're in,
the overloads that are
visible at that point.
So if we declare for fns somewhere,
they're not gonna be available
in the global namespace,
but whenever we evaluate
the default arguments,
he still looks at all of the
default arguments for that function.
So namespace N on line nine,
because of the using declaration,
the declaration on line 11
which is equivalent on line two because
same name, same return
type, same parameter types,
sort of adds into the visible DFAs.
So now that function has
two default arguments,
&quot;foo&quot; and &quot;bar&quot;, but then
we declare some overloads,
some actual real, honest to
god overloads of this thing,
including one that take no parameters,
I'm taking no parameters and
I have another version of it
that can also take no parameters
because of the default arguments.
So now, when our main
function, I call in the middle,
just to verify, yeah yeah, yup, if I call,
it normally without, at that
point, then yup, we're good,
but on line 19 when I call
f in with no parameters,
it's not going to see
the fn that's on line 13
that takes no parameters,
which is probably the one
you would expect it to find,
instead its going to find
the other declaration
that's on line two and 11
and it's gonna call that one instead,
because only that
overload was made visible
by the using declaration on line five.
You would not expect this behavior.
Anyone that says, yeah
I intended to do that,
like they're lying, right?
So and another thing to think here is,
okay well say a using declaration is one
of those common things,
oh yeah using declaration
instead of using directive,
which pulls a whole namespace
in, you wanna be good,
you don't want to pull
everything into your scope.
Using directive doesn't have this problem.
So you can end up somewhere
in a header file you include,
doesn't use the declarations
somewhere, all of a sudden,
you've got weird behavior
you weren't expecting.
You know, it just keeps getting worse.
Honestly, that's probably
the worst example.
That's the one that's just like,
what are you talking about?
So let's move on to member
functions of classes.
So default arguments on
base member functions,
are visible in your type.
So base has one of those things,
derived is derived from base,
I make it derive d, when I
call it to member function fn,
he's like okay, I need to find an fn,
he's gonna look in derive and
nope, there's no fn there,
he's gonna look in base and go,
alright, fn is in the base, I can do that.
And he goes, oh you didn't
give me any parameters,
or you didn't give me any arguments.
Okay well that's okay, I can invoke this
with that default argument and
it works as you would expect.
There's this other bit of
peculiarity that I've put here
for the purpose of
illustrations for late slides,
but line 12, who's
familiar with that syntax?
Yeah, its an unusual thing.
As long as the acceptability
of the thing, up in the base
is accessible to you, you can always like,
no give me the thing in the
base, by using that syntax.
So I said they were visible, right?
That is unless you hide them with
your own member function declarations.
So this case is basically the same thing,
now derived has its own fn
that's a different signature,
its a different function.
Now whenever I call DFN, it's
gonna look in derive for an fn
its gonna go, I found one, okay
let's put the parameters in.
You didn't give me any
arguments, but he expects one,
sorry, I give up, you didn't
give me enough arguments,
it won't compile.
You can still use the base trick,
its a call through to the base
and get that base's function
and call that one with no
arguments, that's good.
Line 18, this has nothing to
do with default arguments,
but this is something that is disturbing.
So if I saw this, I called
d's fn with a string.
Well d's fn takes a &quot;bool&quot; not a string,
I would hope maybe it would not compile
and if it did compile, I would think,
okay fine, you compile,
you're gonna call the base one
that has a string, right? Nope.
Instead there's an implicant conversion
from string literal to &quot;bool&quot;. (giggling)
This is what let's you say,
standard sting s equal false
and vice versa.
It's not related but its a terrible thing
and you would get really
confused if you had
this situation going and
you had to debug that.
Okay, that's fine.
You can actually unhide them now,
with using undeclarations in your classes.
So this type we're gonna
have two derived types.
D_one is basically equivalent
to what we had seen
derived in the previous slide.
You've got it at overloads,
so now that hides the one in the base,
but now I really want the
ones that are overloads
that are in the base, I want
those available here to me too,
so you say, using base to fn,
great, now I can use those.
For the second derived
site, I'm gonna say,
using base fn first, that's gonna pull all
the one from base n,
but then I'm gonna say,
auto fn string, s equal &quot;bar&quot;.
Now when I do that, that
declaration now hides
the one that was in the base,
because it's the same signature.
So the user declaration is really saying,
yeah bring all those
things in, unless I say
that I'm gonna have my own version of that
exact function with that exact signature.
Base b, I call the function, I get &quot;foo&quot;,
that's what I would expect.
So I get D_one, I called its function,
I expected to call the base's function,
with its argument so I get &quot;foo&quot;.
D_two, so I call the
function with no arguments,
its picks D-two's copy of fn,
which has a default argument of &quot;bar&quot;
and it adds some bangs to it.
So I get &quot;bar&quot;, bang, bang, bang,
ah but remember that trick,
I can always get back
to the base's function,
by using the little base, the call through
the base trick and I'd get &quot;foo&quot; there.
- [Audience Member] In your two derived,
you changed the ordering of using
that (mumbles) function, does that matter?
- I don't think so, but I
would want to experiment,
the fact that it is in different order,
makes me think that I
probably did it the other way
and there may have been a problem with it
and so it was a while ago when I wrote it.
So default function argument
overridden virtual member function.
They're functions like anybody else.
So why not? We can do that.
Well it turns out there are yet
more problems doing it this way
and this is actually a
more well known problem.
So now my function here is a virtual
and I'm gonna override it.
So string s equal &quot;foo&quot;, but my override
doesn't provide a default argument.
So now when I call the
function for my base,
from a base type, I get what I expect,
&quot;foo&quot; return s, right?
But if I try to call it with
no arguments from my derived,
I get what we had seen before.
Derives fn doesn't have,
you can't call it with not parameters.
So that doesn't compile.
Okay, well how do we make it compile?
Yeah, what can we do about this?
Let me see what time it is.
You can use what's called the non-virtual
interface technique or method,
at some points its been called
the template method pattern,
I think some of herb's early stuff,
we've got w called it that.
But the basic idea is that the interface
that consumers of this are
going to use, is not a virtual,
it's a member of the base, not virtual
and instead it delegates to
a private virtual function
that you can override
at any derived types.
So now when we use this pattern,
we just say, (mumbles)
d fn, which is virtual,
it will do a dynamic dispatch
and then we'll get the right
implementation of the function
and so now when I call d.fn,
it goes d fn, okay is
there a fn inside derive,
nope there's not, okay look
in the base, he finds it
and he says oh there's a
default argument there,
I can actually do this call
and he gives you &quot;foo&quot;,
but with the implementation
of bang, bang, bang, add bang,
bang, bang, to the end of it.
Oh great perfect, that works,
its what we wanted right?
But what happens if we do
want a default argument
for that overriding function.
I mean, its reasonable,
you might want to do this.
So then we do that, so now the derived has
a default argument of &quot;bar&quot;.
So you know, maybe if you're
calling it from derived,
you'd expect &quot;bar&quot; bang, bang, bang,
and that's what you get, base b derived.
You call d.fn and you get
&quot;bar&quot; bang, bang, bang,
but if you invoke this from the base,
so you can get a reference to
the base from that d object.
If you call it from that static type,
you're going to get bases default argument
and derives in the implementation okay?
It may be that you want to do that, maybe.
If I'm looking at any one of these
function definitions just alone,
keep in mind, this is a contrive example,
most times these things are going
to be separated by different files
and hundreds of lines of code.
You're not gonna be able to
see them in the same context.
If I'm looking at either function alone,
how would I get &quot;foo&quot; bang,
bang, bang, I mean it says,
&quot;bar&quot; bang, bang, bang,
as you can catonate those.
So that's problem. So
how might we fix that?
I want &quot;bar&quot; bang, bang,
bang, for that last one.
What can we do?
Well the problem is that
the default arguments
are determined from the stack type,
where as the implementation
that gets picked
is because of dynamic dispatch,
you dynamically figure out
which implementation to use.
So if you want the default argument
to also be dynamically
determined, well guess what?
You have to call a virtual function
for the default argument.
So and in this particular
case, we've just said,
we're gonna make it delegated as well
instead of using default arguments.
In fact you have to do that,
because if you put the...
Is that right?
Yeah, I think you have to do that.
Because if you provided
the default argument,
if you called this virtual method
as part of a default argument,
your type is still your base,
so it's gonna get the wrong one,
so you have to use delegation to fix this.
Now this is a lot more
code to make that work.
And now imagine if you
had multiple parameters
with defaults provided?
This would get out of
hand, very, very quickly.
Okay, I'm doing good on time.
Is that better?
I don't know, probably not.
It's much more complicated.
Take it for what it is.
So far, we've avoided
talking about templates.
So now some about templates.
So default arguments
for function templates,
I add some extra complexity.
There's a section in the
standard about templates,
that talks specifically about this
and there are certain rules
and they give it a name,
default argument instantiation.
So that's the thing that we're
gonna talk about right now.
So this is a summary. You
can find the actual paragraph
in the standard up there.
For a function template,
presumably a member function
of a class templates, default
arguments are not always
completely parsed until the
template has been called
in a way that requires
the default argument.
So it may not parse the
full expression completely,
until you've instantiated the template
and have required the default argument,
you've called that function
template with no arguments,
you have to substitute them in.
So this sounds an awful a lot
like two-face look up problems.
So we've got a template on
lines one, two, and three,
a function template.
Its default argument is a
get function that takes T.
So that's a dependent expression,
it depends on the value
of the template parameter.
So that means, whenever
a compiler parses this,
he can't actually make
the final determination
of whether or not that's valid
without knowing what the type is,
that's what it means to be dependent.
He just returns whatever it was.
So later on we have a class A,
we have a function called get, finally,
(mumbles) return, just returns 42.
So now, on line 11, we
instantiate that function template
with type A, so then we
go, okay we got a type A,
in theory, we can now verify
that that get function is valid
but it doesn't necessarily do it,
until we actually invoke that
parameter and we need it.
So that works.
Now if I call fn of A with an
actual integer, presumably,
it doesn't have to worry about
whether get is valid or not,
it could still be a bad substitution.
That was a dependent type,
dependent expression,
what if it's not dependent?
So this time, I'm gonna do weird stuff.
I'm gonna say, cast integer 42 to &quot;bool&quot;,
something nonsensical and then
assign that to an integer.
Sure why not?
So the key here is that,
that cast to &quot;bool&quot;
is using C++ 11 uniform
initialization syntax.
That prevents narrowing conversions.
So if I just said inside
like main int n equal &quot;bool&quot;
curly 42, the compiler would go, nope.
Not gonna let you do that.
But now remember that's
not a dependent expression.
So the compiler should be
able to fully parse that
and determine that its a bad thing,
when it sees the template declaration.
Well so I did some experiments on this.
MSVC and Clangs they say, yeah, no,
we're not gonna let you do that,
but GCC is like, yeah sure, bring it on.
Chances are, you're using this thing,
you're pretty small, I
guess we'll just keep going.
On line nine, I've
instantiated the template now,
but I've not used the default argument.
Again, GCC has an opportunity to go,
hey there was a default
argument that was not good,
but he does it, he's just like,
yeah, sure, why not, let's do it.
Its only when you actually
instantiate the template
and call it, such it
needs the default argument
that it says, no, no, I'm bool-filled-up,
can't do that, that's not good.
So I ask the core language
group in the committee,
so is this ill formed?
What's the story here,
they have different,
diverging implementations here
and the answer that came back was that,
this is ill formed,
line two is ill formed,
but its no diagnostic required.
(audience laughing)
You can argue that not
diagnostic required,
should it actually build and run
and do normally what you might expect,
if you don't invoke it that way?
I guess it's a theoretical
question, right?
There's one other variant of this.
So what if the default
argument is dependent,
but its actually invalid
once you determine
the dependents, like
you substitute a type in
and now it's invalid.
So this time I'm actually doing this cast
with the type that was
given to me, on line two.
So if I give it an int, it should be like,
sure, peachy, good there.
If I give it a &quot;bool&quot;,
like was in the example,
what's gonna happen, right?
When they declare just the declaration,
all of them are, yeah,
sure, that can work.
Then on line nine, I
instantiate the template,
but I don't use the default argument.
They're all still like yeah
let's do it, it makes sense.
You didn't use this in an invalid way.
Its only when you invoke
it, you instantiate it
and need the default argument,
they're all finally
like, yeah that's right.
And for what's its worth, this is good.
This is the behavior I would expect,
yay, it actually did what
I thought it was gonna do.
So all those examples of
everything that could go wrong,
I'll repeat myself from the beginning,
don't do these things.
Just don't use default arguments.
So then if you take that advice,
what are you gonna do about it?
What do we do?
Okay well, you've got some options.
You can have coding guidelines, like yeah,
don't use these things.
Who here has coding
guidelines in your industry?
Okay you should have them if
you don't. They're important.
You can use code review,
you get a senior engineer
to look at every junior engineer's code,
make sure they're not doing this.
You can do static analysis
tools, for most of these things,
static analysis tools can detect,
or it can certainly
detect, hey you provided
a default argument in this
signature, don't do that.
That might be overkill,
but if you're rules
for your industry, or your professions,
they don't do that, then
they can conceivably do that
and then unit testing.
This way you can avoid
weird, unexpected behavior.
So it's 9:46, we have
about 14 minutes left.
I don't want to go over time because
there's another talk right after this.
I can take questions, the
more questions I take,
the less of the really cool
stuff we'll get to see though.
If you have a question,
just go up to the mic,
or it's a small room, you can yell it
and I'll repeat it what it is.
Everybody wants to see the cool stuff.
Okay.
So yeah I said that this caveat like,
oh well maybe the cool stuff,
maybe we should use it for these things.
I haven't convinced myself
that these are worth it,
but they are pretty neat.
Okay so who knows about the library ts?
Did you have question?
Okay so the library ts.
The library fundamentals ts.
So there's version one,
there's version two,
presumably there'll be version three.
So this is a type that is
added to the version two
of the library fundamentals ts.
Just from the name, does anybody
want to guess what it's suppose to do?
Nobody. Yeah.
File the line number right?
It gives you that information.
But you say, but we already have that
with the file in line macros.
Will this give us an actual full type
with functions and things,
we can pass it around,
as a unit and things like that.
As far as I know, there are no existing
full implementations of this
in any of the shipping
libraries, standard libraries.
So this code of all of the
other code, I should say,
all of the other code is
available at this sort of
relative path to the get hub link
that I posted on the first slide.
If you need that later, you can find me
and I'll give it to you.
This is the one that doesn't
actually compile yet.
So with this you can say something like,
I'm gonna define my own
custom assertion function.
And this used the trick
that the default argument
is evaluated in the context of
where the function is
called and it needs it.
So the usage of it on line 24, you say,
my short faults, I did this on purpose.
Whenever you call that, the
source location argument
that's gonna get passed in is loc current.
That's evaluated in the
context of this file line 24.
So the column number and line
and function name are all going to be,
relative to the main function on line 24.
So you're going to get
that information about,
oh yeah I started in
this file, in this line,
it was this column number.
Anybody worked on unit testing frameworks
or things like that that
have a assertion macros?
Yeah. That's really the big motivation for
this is to eliminate those macros.
You can have real,
honest to god, functions
that do your assertions.
We'll see if people
actually start using this,
once it get implemented
in a shipping library.
So some people earlier said they attended
the constexpr all the
things talk yesterday.
Can I get hands again,
who all attended that.
Okay, a few more people
trickled in after words.
So they talk some about a problem
that was really prevalent
when C++ was 11 first shipped
that if you have a function
that's mark that's constexpr,
there's no guarantee that it will
be actually evaluated at compile-time,
but there are restrictions on the things
that you could put in there
and that led to a lot
of cursive functions.
That's the only to do it, in C++ 11
for constexpr functions.
But if that function
got called at runtime,
it may not be the ideal
implementation for that function,
it maybe costly to have
all that recursion.
C++ 14 made it a little earlier,
you can use more general
programming structures
in a constexpr function, but
there's still this problem of,
I'm in a constexpr function
and I want to write code
that is cognizant of the fact that
it's being called in a constexpr context.
They explicitly called
this out as a problem
in the presentation.
There's some standard
proposals to make that
more a part of a language
that you could tie into that
otherwise you have to do (mumbles) tricks
and other stuff to do.
So here's an implementation that
uses default function arguments.
Its a hack, I'll admit it,
but again it uses the fact that something
is evaluated at the call site,
which is where the context is about,
we're being called in
a constant expression.
So focus real quick on lines 12 though 19.
So I can call function four,
fn with a parameter of four
and I can't put that in a static insert,
because function with four, let's see...
Oh yeah, I'll get that, but
that's a run-time behavior.
So I can do a run-time assert.
That's the right behavior.
The way I structured this,
is you can explicitly say,
no, no, no, give me the
compile-time behavior, please.
So if you want the compile-time behavior
and you're in a constexpr
context, you can just say,
no tag compile-time.
So now let's look at the
implementation of fn.
So its a constexpr function
and it takes a second argument,
which is a tag, the
default argument there is
this function called run-time.
Run-time if you look at that,
is a function that is not constexpr,
so it can only be evaluated at run-time,
which means if I call fn
with only one parameter,
the second parameter can
only be used at run-time.
So that's why line 14 fails to compile.
Its like, no, you called run-time
which can't be used here.
The other thing to note about it,
is in a constexpr function,
you can write code
that is not constexpr,
you can't evaluate it
in a constexpr context,
but you can write it,
as long as it doesn't get evaluated
whenever you're doing the
constexpr stuff, then its fine.
So I have identity, which
is another run-time function
and so I say, if you have been told
that this is run-time behavior,
just call the run-time thing,
otherwise do the compile-time thing.
What we're doing here really is,
instead of magically determining
the context of where
we're being evaluated,
we're explicitly passing that in.
I want the compile-time behavior please.
So it's not quite the
same, but you can emulate
this and you can get different algorithms
based on whether or not your
run-time or compile-time.
You just have to be a
little bit more explicit
about, hey, I'm in compile time.
We've got six minutes. Okay.
So virtual dispatch.
Sometimes you might wanna say,
yeah, yeah, yeah, this
is the right function,
but I really wanna know who it,
what type it was that was
the source of the call
that dispatched to me.
This is terrible, but there are reasons
you could conceivably do this.
It's a little bit small
text 'cause it's more lines.
But the idea is that all of the types
that you know about, you can provide
a static, constexpr value, an ID,
make them unique, right?
And you can provide a name, you know,
depends on what you're trying to,
what you're actually trying to implement,
what you would provide there.
And so what I'm doing here in my,
so the base is pure virtual.
There's no implementation there.
But in my implemented override,
I'm looking up the name
for the ID that I was
originally called with.
And the trick here is that, remember,
the default argument is evaluated
based on what the static
type was that made the call.
So it gets the ID of that type.
And since I've registered these things up
with some map or something,
I can now look up
to see, oh, it was that type.
So yeah, this works.
So if I created derived d,
and I call fn,
it's derived, right?
Yeah, yeah, derived was
the type that called this.
But if I get a reference to the base,
and now I call fn from that
object, from that reference,
I get base because he says, oh yeah,
the default argument was determined
by the static type,
and then I can look that
up in the implementation.
There are all sorts of
terrible, terrible things
you could do with this trick.
This is probably the one that I'm
the least certain if this is a
good or a bad thing. (laughs)
I was thinking last night, there are ways
you could use this to solve
the virtual problem when
you have multiple defaults.
You might be able to actually hook in
and say, no, no, no,
here's all the defaults
for the different types
that might call this thing.
Crazy stuff.
Okay, we got four minutes.
Nominally, that's the
end of the presentation.
Now I did say that, if we went fast,
I could do a demo.
So questions or a real quick demo?
- Demo.
- Demo.
Okay, let's see if it works.
Doing live demos are terrible, but...
Okay, so you remember that compile-time
versus run-time example, right?
So you might think, well okay,
what would I use that for?
Great. Great you can do that.
So I came up with an idea
to use it to provide sort of mock values.
So...
Is mock.
Okay.
So I'm gonna have a class, this is my tag,
class mock, that's my tag,
compile-time, run-time, right?
I've got my run-time function that says,
no, don't do mocking, so returns that.
Now I've got his type file_data.
And he's gonna keep this
mock_state thing as a member.
And he's gonna take that in as an argument
on his constructor.
And the default is gonna be no mock,
give me the real run-time
behavior for this thing normally.
And he stores it away.
So then I've got a constexpr
function that says, hey,
give me some numbers, right?
And just that normally what it would do
is it would go, it goes
and reads from a file,
you know, something run-time,
requires run-time behavior.
Ah, but if I said, no, no, no,
I want mocked values please,
don't do that run-time stuff,
you could implement your
mock behavior right there.
And then else, I'm gonna
go delegate a Read,
and Read is gonna go to a
file, and go do the reading.
So there's delegateRead.
So it just goes and reads in
from this file these numbers
and puts them in the array,
and then there you go.
Okay.
So the first block, 46 through 52,
I instantiate my file
data with no parameters,
so I'm expressly selecting
the run-time real behavior.
I say getNumbers, and I get those numbers.
For 54 through 60,
I say no, no, no, no,
give me the mock behavior.
And then it's the same function call,
but I get different numbers that,
and I can stack insert them,
because my numbers thing is a constexpr.
So who thinks this is just gonna work,
or who thinks, you know,
just not really gonna work?
I wouldn't show it if it
wasn't gonna work, right?
Session is over.
Alright, I'm gonna show that,
I got one minute from my clock.
I have this little script
that compiles and runs things.
What did I do wrong? Oh,
I didn't give it a name.
So it compiles it, it runs it,
and all the assertions pass.
So that's the end of my session.
If you want to ask me
questions about anything,
I would say congregate over there.
We can do it sort of offline,
and thanks for taking my session.
Have fun at the next keynote.
(audience applauding)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>