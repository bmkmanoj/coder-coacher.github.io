<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Odin Holmes “Agent based class design” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Odin Holmes “Agent based class design” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Odin Holmes “Agent based class design”</b></h2><h5 class="post__date">2017-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tNXyNa6kf4k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- So hi everybody, I'm Odin.
I talk too fast and screw things up.
Hi, Odin.
- [Audience] Hi, Odin.
- You're a terrible self help group.
But, I'll tell you all my problems anyway.
This is my first CppCon experience.
So I went to Twitter to figure out
what do people want to see there,
and apparently you people like
practical examples and jokes.
So I hope the fact that mine aren't funny
don't get in the way.
It's your fault, Twitter. (laughs)
My object lifetime began in Oregon.
I was allocated from a pool of hippies.
(laughing)
Yeah, growing up as a hippie
kid is actually pretty cool,
I'd highly suggest it.
It's just you do run into
a lot of the problems
that you also have in software.
Like if you look at, all the hippies
want to save the world, right?
They're very highly motivated,
but they use the wrong tools. (laughs)
And it reminds me of,
there's this Spanish story of Don Quixote,
the knight who went crazy and
started fighting windmills
because he thought they were monsters.
And this is very representative
of how I sort of perceived
all the hippies trying to save the world
around me as a kid because it was like,
yeah, I admire your effort,
but you achieved nothing,
and now my windmill's broken.
And so, my view, and
still to this day was,
for a thought experiment, if
you were to clone the world
and roll back technology 300 years,
because they used Jet then, right?
And then ran it, your
integration test would say
like 95% of the world died.
So if you think about it that way,
being a nerd is probably
the most philanthropic thing
that you can do with your life.
And so obviously, I became a nerd,
because in Oregon, you either
become a nerd or a lumberjack,
and I just don't have the
build to be a lumberjack.
(laughing)
So, I started as an electronic engineer,
and so I did the stuff that
all electronic engineers do,
and that's writing software,
just not for normal
systems, for tiny systems.
And I'm completely self taught,
and I kind of mapped sort of
how you teach yourself things
if Google is your only source.
And so this is the kind
of being innovative
in teaching yourself development cycle.
You think of something,
then you implement it,
and it turns out to be way
harder than you thought,
and you turned out to be
very, very wrong about it,
but still you work on it really hard,
and then you show your friends,
hey, look at this cool thing I built,
and they're like, you didn't
think of that, did you?
And then it's like, shit. (laughs)
And then you try and fix
it, and then while fixing it
you get another idea,
and then you go back and
around another circle.
So, what are we talking about today?
Well, in C++ we have this concept of
you don't pay for what you don't use.
And this is actually
a perfect throwback to
nerds are philanthropic.
This principle that we
have has saved more energy,
more resources than the
entire hippie movement
and probably most governments.
This is awesome.
The problem is we don't always do it.
Who here has shared
pointer in your code base?
Like everybody, okay.
Who here has a shared
pointer in your code base
that is not standard shared pointer?
Yeah, still most people.
That's kind of the problem.
There are very, very many reasons
why you'd have your own shared pointer,
because shared pointer is essentially,
the committee sat around a big can
and started throwing
design decisions in there.
Okay, there are cyclical dependencies.
Well, that's dangerous,
why don't we throw in
something to stop that from happening.
And, oh yeah, they're going
to be used multi-threaded.
Well, you make things atomic,
and so on and so forth
for the common case, for
the use case that everybody,
or at least the theoretical
everybody that nobody is, needs.
So, if we want a shared pointer that's
only going to be used on one thread,
then we don't need this atomic ref count.
It could be non-atomic.
And if we have a shared pointer that
cannot cyclically depend on
things, we don't need weak.
In that case, it's not
a performance overhead,
it's a memory overhead,
because we don't need the
counter of weak pointers.
Maybe I don't need a custom deleter,
or maybe I need a custom deleter
but I don't care if that infects my type.
Maybe this use case of shared pointer
is not a vocabulary type.
It's not being passed
through a million functions,
not even all of which I'm an author.
Maybe it's just in the
private section of my class
because I need to do
copy-on-write optimization or something.
Why can't I make allocator, deleter,
or whatever part of my object?
Or maybe I don't want you
to give me a naked pointer
because make-shared is more efficient.
Maybe I want to force you
to always use make-shared.
Maybe I want the objects that you allocate
to all come from a certain pool.
There are many, many, many
variations of design decisions
which you would want just
a slightly different way.
And the problem is,
if you just take and throw those
design decisions into your own can,
you not only get those
design decisions in that can,
there'll be a huge amount
of bugs in there too.
If you try and implement
yourself, you're gonna screw up.
But what if we were to decompose
a shared pointer into its pieces?
And this is kind of the
pieces I came up with
after thinking about it for 10 minutes.
This is probably not the optimal
set of features that's in shared pointer.
But could I do this?
Could I make this syntax work
so that I could make my own shared pointer
with less of these things?
Throw out all the stuff that I don't need,
and then I could have my can
with just the stuff I
want in it, but no bugs.
So, we find this problem in a lot of code.
In my domain, it's bare metal
drivers on microcontrollers.
But I can't talk about that because
it's one of the examples,
it was the only example,
no one would come, right?
So I tried to find
examples from other domains
so that if you understand
any of these, it will work.
So you don't have to
understand all of them.
But keeping to the standard library,
we have standard function where we also
wanna maybe take things
out of the interface,
or we maybe want small
object optimization,
in standard functions.
Maybe we want to, I mean, we do have
small object optimization.
We just can't rely on
it on being any size,
because it's not specified.
So if I wrote code that's performant
because my objects are small,
maybe some future STL
will make the small size
object optimization a
little bit more small,
and then it all goes to heap.
So
there is a proposal in the SG14 for
in-place functions, which
is basically functions
with a few more efficient design decisions
and a small object optimization.
There's also an in-place
vector, as far as I know.
There is in-place string in flight.
This is a problem of fighting
an exponential, as in
the possible properties
that we can put together into one can
with brute force and that we're trying
to find all of the possible combinations
which are interesting
and making one of each.
I don't know that this is
going in the right direction.
Speaking of not in the right direction,
oh, no, I didn't say that, Qt.
With Qt, we have
actually very high sort
of compositional power,
and we can, in Qt we can
actually quite easily
go in and change things,
take things out, put things in.
The problem is they made it generic
through virtual functions.
So if we look at this dialog,
this could be any widget library dialog.
They all work somewhat the
same if they're widget-based.
We have, in this dialog, a layout.
So we got lower layout
pane, upper layout pane.
And then in the lower layout pane,
we're gonna have a horizontal box layout
with a pane here which is a stretch,
which basically takes
up all the empty space,
and then we have a button
and then another button.
In the upper one, we have some grid layout
with four panes, and in some of the panes
we have more dividers and more dividers,
and this is essentially
probably a composite widget,
which is basically a
wrapper around two widgets.
And all the events get forwarded.
And so how this works from an
event handling standpoint is
a dialog tells the top-most widget
what events came in,
and it propagates them
to all its children, they propagate them
to all their children,
they propagate them to all their children.
And so if some event comes in,
there's gonna be something
like 100 virtual calls
or something just for this dialog.
And propagating from the
root out to the leaves
where the widgets may
want that information.
But depending on what that information is,
maybe all 100 or maybe
98 of them don't care.
But the optimizer can't take it away,
because they're all virtual calls.
That's the reason why in Qt, key presses
don't propagate, like resize events.
You have to go through
a completely different
information channel, which sucks
from a usability standpoint.
But it would just be too inefficient
if your program ran, maybe
not just this dialog,
but maybe 1,000, 10,000 virtual calls
every time you pressed a button.
On the other hand, this is
all known at compile time.
Like what fonts the system supports,
that's runtime, but the whole
layout is just compile time.
So why can't we make this
dialog work at compile time?
There's also another thing going on here.
If you change one of these selections
or if you type text in here,
this has a signal slot
mechanism wired up to that,
and that's got a signal slot
mechanism wired up to that,
so whenever something changes,
it's updated on the other end.
This, again, is going through
many, many virtual calls
to get there, whereas
we knew at compile time
what's connected to what.
So if we wanted to, I mean,
this is just vaporware.
I didn't write a Qt
and invest man decades.
But from a public interface standpoint,
like can we make an interface
that preserves all the
compile time known information
and allows us to, under the hood,
build the thing at compile time
and wire it up the way we
want it to be wired up?
And this is familiar syntax, right?
It doesn't look like we're
feeding a TMP monster.
This is familiar syntax,
familiar semantics.
You shouldn't feel the
knife going in, right?
(laughing)
But this is probably the third time
I've mentioned TMP in this talk.
So what is TMP?
So there are two ways of understanding TMP
for this talk.
I mean, I'm most known for my TMP talks
from other conferences.
Those, you have to understand TMP.
But here, either TMP stands
for template meta-programming,
which a Turing-complete
general-purpose code generator
that runs on the type system,
or TMP is Tabea, Marie, and Paul,
three magical unicorns
that live in the compiler
and do whatever I tell them to do.
(laughing)
That's obviously a lie,
but they're actually
both a lie because Turing-complete,
I mean, with endless resources, right?
But that's kind of how the world works.
You get born, and your parents lie to you.
Well, they call them fairy tales, but,
and then you go to school,
and they tell you better lies.
And then you go further through school
and they tell you even better lies.
And then when you get through academia
and through your career,
and you're the expert
in the world, and nobody
is better than you,
at that point, you can
only lie to yourself.
So it's a metaphor, and
I'll explain things,
and maybe the one or maybe the other,
but both understandings work.
So let's get to embedded drivers.
And like I said, you
don't have to understand
embedded drivers.
Just, this is step seven
of a 17-step tutorial,
how to write hello world on
an STMicroelectronics device.
(laughing)
And it's from STMicroelectronics.
It's not some guy that
made this super bad.
And this is a different design decision.
This is how to design looks like when
you decide that extra byte of RAM
or that extra instruction cycle,
we cannot pay for that.
So it's customizable
because they just spill
all the guts out into
the public interface,
and you have to go picking through these
complexly-dependent guts that are probably
also poorly documented.
And all in the name of efficiency.
But in this hello world tutorial,
everything is essentially default.
This is the inherent complexity.
If you don't know what a uart is,
it's a sub-category of zero ports.
So we're using uart1.
We're using a blocking interface.
I don't know if you notice
that on the previous slide.
Or maybe it was one of the other 17 steps.
But yeah, we're using
a blocking interface.
We're using 9600 baud.
We're using two specific pins.
So this is a factory that
builds me a uart driver,
and I can just say,
blocking-send, blah, blah, blah.
And now I have 16 and a half pages
to deal with the fact that
I'm gonna starve something
cause I'm blocking call to a slow uart.
So I've been trying to make
this kind of interface work
for a long time.
This is a photo that my wife
took of me two years ago.
(laughing)
And she's good with a camera,
captures intent very well.
So I was trying to make
this interface work,
and the tool I was using was
policy-based class design.
Alexandrescu's method
of decomposing classes
into policies and them working together.
And so on the map, we're here.
So I'm working on this, and I'm noticing
this is hard, and you have this glue code
of this policy depends on that policy,
needs to be able to call it.
But maybe that policy
doesn't exist because
these three others could
be there in its place.
And it turned out to be just
this huge template monster.
But I did get some drivers working.
And it turns out C is not that efficient.
Like if you do C++ to the extent
that the syntax allows
you, I had something
like 10X smaller flash footprints
on some of these things, compared
to the STMicroelectronics library,
saved some RAM and faster
and blah, blah, blah,
and syntactically, sorry,
statically checked.
So at the emBO Conference,
I mean, this is also kind
of a recurring theme.
In the middle of
creating my template monster,
I was running into the problem
that template
meta-programming was too slow,
and max recursion depth on the templates
was bad in the algorithms I was using it.
So I kind of fixed that
by writing a new template
meta-programming library
that's way faster.
And I also wanted to go to a conference
about modern C++ on microcontrollers.
That didn't exist, so I founded one.
And so at emBO, I was
showing this to other people,
like some of the top TMP guys,
like Neal Dowes or Joele
Foucault or Jackie.
And it's really a good
thing that Joele Foucault
is just brutally honest
and will tell you things,
because he told me, Odin, you screwed up.
No one understands your code,
and you won't either in the future.
So I was here.
(laughing)
And he was right.
It was kind of a feeling
of gallopy, gallopy,
gallopy, bam, windmill.
And this is an excerpt from my code.
You don't have to understand this
because I don't anymore, either.
Here's an artist's redition.
He got pretty inspired by that.
(laughing)
Good thing it inspired someone.
But here's the problem.
I was making this toy.
This is essentially a
policy-based block device.
And you have some form, some interface
that this thing has to fit in.
And if it fits in there, then it works.
So you can swap these things out.
And it's kind of under the guise
of a generic thing, because on some level,
it's a hexagon, and you need
this glue code around it
to make things work.
But there's still a whole lot of stuff
you can't make work in
policy-based class design.
We basically need legos, right?
Because you can build
anything out of legos,
at least the old legos.
New legos you can just
build like one scene
from Pirates of the Caribbean.
But I'm gonna gripe at
that some other time.
(laughs)
So I need old legos.
I need to be able to do things
that I can't do in
policy-based class design,
like have an optional policy or have
a variatic pack of policies
that are all the same type,
and I still need to call member functions
of each of them in succession,
or things like this.
And I didn't really have names for this.
In the past, I've named
things completely wrong
cause I just suck at that.
And so I decided to steal some names.
And so there's this
discipline in academia,
I don't really get it, but they think like
if all this engineering work was done,
what could we do?
And so this is like a self-assembling
assembly line, where you have a robot arm
that knows it needs a
conveyor belt to move things,
and you have a metal stampy thing
that knows it needs a conveyor
belt to get stuff into it.
And so all of this machinery
knows its capabilities,
knows its requirements on other machinery,
and you give it some
abstract thing to build,
some concept of a thing,
and it will self-assemble
and build it.
Apparently some scientists
have figured out
how to hack this.
So they implement it just to the point
where you don't yet
realize you're an idiot
because it still works.
I think there's a word for
this, PowerPoint, or something.
(laughing)
And then they leave all the
looking like an idiot part
up to us engineers.
And I look like an
idiot anyways, so, yeah.
Anyway, so this is
agent-based class design.
This is Agent Smith,
it's a good agent name.
And it's not a complete set,
because we represent abilities with balls,
and we represent
requirements with sockets.
And so we have three requirements
that are not fulfilled in this set.
For it to be a valid set of agents,
because, you know, you can
build anything with legos.
It doesn't mean that
it's a good thing, right?
You need some way of knowing
whether or not this
shared pointer will work,
this combination of properties will work.
So if we have this combination of agents,
then we can see that
for every socket, there is a ball,
and we got a couple extra balls.
We have extra capabilities.
That doesn't matter.
Just all the requirements
have to be fulfilled
by other agents in the set.
And UML is another
metaphor for PowerPoint,
for everything works in UML.
So let's see if this works in code.
We're composing these three agents,
and then we want to do
what agents do well, right?
So the problem is that
all three of these agents
are capable of ass kicking.
But we wanna have one
public interface function.
And so we also don't want to see a lot
of the internals of these agents.
We don't want that leaked
into the public interface.
This is a classic problem of
policy-based class design,
that in order for them
to talk to each other,
they have to have public interfaces.
But that leaks into the public interface
of the entire object.
And Alexandrescu acknowledged
this in his book,
what, 17 years ago, and
nobody's really fixed it yet.
I mean, there are hacks
to make that kind of work.
But it's still a hard problem.
So the way I try and solve this is
in concept, all of the agents
are in their own arena.
They can talk to each other,
but nobody outside can talk to them.
And then we have public interface classes,
which can be composed, so you
can have multiple of them.
And they can add to the public interface,
and they can also access the agents,
either by type, like
give me agent type this,
or by ability, as in
give me all the agents
that have this ability.
So
this is an agent, right?
Basically, everything's an agent.
An agent has to be, I guess it doesn't
even have to be moveable.
I don't think there's really
any requirement on agent.
This agent, if we put this agent
in our arena, it wouldn't add
to the public interface, obviously.
And nobody could find
it except for by type,
and that's not really
how this paradigm works.
So we need to associate
abilities with this agent.
And we can either do that
by specializing traits,
the specialization of a traits class.
Basically we're telling the unicorns,
Mister Smith, ass
kicking, that's the shell.
So this is one of the ways of associating
abilities with agents.
And we'll see some other ways later.
But if you're a library designer,
this is probably what you're gonna do.
If you're designing
a toolbox for building a shared pointer,
then you would be giving
the custom deleter the
custom deleter ability.
And the user wouldn't even have to know
that that's a thing.
So there's not a lot of TMP here.
Okay, you just have to be
able to specialize traits,
and later, we're gonna find
out a better way to do that.
So what about the public interface?
Public interface does
have one requirement.
You have to take one template parameter
and derive from it.
And besides that, you don't have any other
requirements on public interface.
Probably shouldn't be stateful, but
the world's not gonna
end if you have state.
It's just stupid.
State goes in the arena with the agents.
And you get, for free,
functions like for-each
or optional or whatever, in
order to interface with agents.
So I can say for-each
fulfills ass kicking,
give it a generic lambda,
this lambda will be called
for every agent that fulfills,
that has this ability,
and I will be passed a
reference to that agent.
Every interaction with agents starts
in the public interface.
So public interface gets called.
And then it delegates that to agents.
Can do work, probably doesn't
do a whole lot of work
cause it doesn't have state.
Probably mostly just delegates to agents.
But agents also need to be
able to talk to each other.
So agents don't just kick Neo's ass.
They also talk weird to each other.
That's kind of the other
thing that they do.
So in this case,
we want to
delegate to an agent, and that agent
should then be able to find other agents
with other abilities that it depends on.
And so in this arena, this agent
needs to be able to access other agents.
And we have this for-each
in our public interface.
And to be able to make an agent
be able to use for-each, we
have this factory function,
agents, which gives us
a bowl of unicorn soup,
or however you wanna picture this thing.
It's basically a pointer and
a lot of template information.
And we pass that in.
And it can pass that on to other agents
and find other agents.
That way we can just
keep passing it around
until you reach an agent
that has no requirements
to fulfill that ability.
So we don't just have the for-each case,
we also have (laughs)
we also have the optional
case, i.e. one or zero
of this agent.
So if he wants to complain to his buddy
about life, well, maybe
his buddy's not there.
So maybe we need a fallback.
So you can also pass in two lambdas,
and the first one will be
called if there is an agent.
If there isn't an agent,
then we can fall back
to the second.
And since this is a generic context,
this is not fully evaluated
unless you actually get
stuff passed in there.
So this works.
We could also say we want exactly one.
We could also, rather
than indexing by ability,
we could also index by concrete type,
as I mentioned before.
But you could get cute with syntax
and say, okay, well, if I want only one,
why don't you use square brackets,
put this in the brackets,
and then you're indexing
into the agents.
I don't care at this point.
It's just trying to make
the underlying backend work.
So we still haven't seen a
lot of terrible TMP, right?
This is kind of user interface, and
it's better than most Boost libraries,
as far as angle brackets go.
So this compose function that
was composing the agents,
well, it's also not super complicated.
All that we're doing is
taking a variatic pack
of arguments, putting them in a tuple,
and initializing a composed,
some class named composed,
with all the type parameters
in its type list, and
initializing it with a tuple.
I mean, this could be
a constructor in C++17.
Since the library's 14, I made it
factory function called compose,
and then there's a composed,
which is a concrete type.
So let's look at composed.
Well, this is where some
of the magic happens.
If we see here that we're deriving from,
well, something, right?
And the something, I mean, we're telling
the unicorns what to do.
This is the so-called unicorn call syntax.
You can spot unicorn call syntax
because they don't use
the nice round brackets.
They use the pointy horn brackets.
(laughing)
And what the unicorns are doing for us
is they're making this
class called access.
And this class called
access is templated on
the top-level derived type.
So this is curiously
recurring template pattern,
if you're familiar with that.
If I know my this pointer
and I know the type of which I am a base,
I can cast from base to
derive, as a static cast.
And then I can do stuff with that.
But this is actually a slight variation
because we're taking this access
and we're passing it as the
first template parameter
to the first interface class that we have.
And remember, they're derived
from the template parameters.
So it accesses, then, the
base of that first interface.
And we're taking that type and passing it
to the second interface.
And so that derives from
the second interface,
to third interface, so on and so forth
until we get all the way up
to, the top level is composed.
And so these functions like for-each
or optional or whatever, they're
protected members of access.
So all of the derived
classes can access them.
And it bubbles all the way up to composed,
where we make them
private so that somebody
deriving from composed
can't access them anymore.
So when we want to talk to agents,
we call these functions that are in
the super deep nested base class.
It has the type of the derived class,
can upcast the pointer,
or downcast, I can never
remember which way it is.
Anyway, to the derived class, and then
it's also a friend of the derived class,
so it can access all the agents
which are in this data member variable.
So it's an aggregate rather than deriving
from the actual agents, which means
that we can have multiple
of the same type,
which we couldn't under
policy-based class design.
It also means that a lot
of the other problems
of policy-based class design, like
you can't trivially derive
whether you are copyable or not.
And here, tuple does
all the heavy lifting.
Or moveable, or whatever.
So
if we look at, there's
some stuff left out here.
So let's look at that.
And this is a little bit templates view.
But basically what we're doing is
we also want to support another case
that you can't support in
policy-based class design,
and that is what if I have an agent
which is an arena allocator,
and other agents that want to allocate
into that allocator upon initialization.
So I construct this set of agents,
and I want some of them
in this construction
to go allocate parts in
this arena allocator.
I mean, this could be a small size
object optimization buffer.
And with policy-based class design,
you can't really do that because you can't
traverse this set of agents,
because you do that with the
type of the policy combiner,
the most-derived type.
And it isn't done yet.
It's done at the end of the definition.
And the point of the
instantiation of the constructor
is like, now.
So you can't use that trick, either.
And so if this unicorn
speak is confusing you,
don't worry.
It just works, okay?
In this case, it works because
data is done initializing here.
It's valid.
And so here we can obviously
for-each on this data.
You could go crazy with Hana on this.
It doesn't matter.
It's done.
It means that we're doing
two-phase initialization,
which is suboptimal, cause
really there are three numbers.
There's zero, one, and infinite.
So you don't want two phase
because that turns into N phase.
But it's the best we can do,
and I think it works
with a lot of examples.
So run with it, right?
So let's look at some concrete examples
that are less complex than
shared pointer, because that would be
more than the rest of my talk.
So I had this problem at the office.
We work on microcontrollers,
as I mentioned.
And somebody came to me and said, okay,
I wanna convert a string to upper.
And this is C++ so I googled it,
because it's not like, yeah.
And so the top hit on Google
and the most upvoted StackOverflow answer
was use Boost to-upper.
And but I'm getting this
weird linker problem.
And I've never seen this before.
And I was kind of a new guy, so yeah.
So I go and look at it.
And it turns out the linker problem was
it didn't fit on the chip.
So he was basically doing hello world
with world to-uppered.
And that didn't fit on the chip,
neither in flash nor in RAM.
And the thing is, if you just comment out
the Boost part and leave
the string in there,
that uses maybe five percent
of RAM, or something.
And the rest should use zero RAM, right?
To-uppers shouldn't be
allocating anything.
But this pulls in enough stuff
that has static variables in functions
and just all sorts of crap that then
gets linked into, I mean,
4K RAM is a tiny chip.
So Boost wastes 4K of RAM on
pulling stuff in from libc.
Nobody cares, because it's only done once.
Once you pull in all the crap from libc,
you've got all the crap from
libc in, and that's that.
But again, it's this problem
of customization points, of not paying
for what you don't use
and so on and so forth.
Because really, on a
microcontroller, where
you're not gonna be
formatting an NQTT message
in Turkish, which is where
to-upper kind of gets complicated,
you basically just need ASCII, right?
And okay, maybe you do want to
potentially support Unicode,
because I make an agent
that does to-upper on ASCII,
and then you, Swedish guy, can put
all your funny letters in there,
make a second agent, and we'll just make
a public interface thing
to just run the one
and then the other one.
And yeah,
I guess I'm proud that German is
one of the languages
that is no longer funny
because we have a big
version of our S set letter,
legislated as of six months ago.
So that's gonna break libc.
Why is that in libc anyway?
(laughs)
Yeah, so but we also want to use Unicode.
And with Unicode, you can
have an uppercase letter
that's four bytes that
maps to a lowercase letter
that's one byte.
So it gets a little more complicated.
So why don't we just make
a more generic interface
where you basically have two ranges,
input range, output range.
We eat things out of the input range,
and then convert it and spit things
into the output range.
And then in case you want to have
a prioritized set of them,
and multiple could match,
we also return true or false
whether or not we found something to eat,
whether or not we matched anything,
and make a public interface class
that just does a for-each
until one of them
returns true, and then a for-each again
until one of them returns
true, and does that.
And this is a very
generic, powerful interface
for dealing with text.
If you give this to Ben Dean,
he'll make a toaster
for you at compile time.
(laughing)
I mean, we can do
trivial string formatting
with this kind of thing.
I make an agent which walks a string
and looks for curlies, and then goes
through the agents in the set.
I'd have to write some kind
of filter and then index,
because for-each wouldn't cut it anymore.
But I could write a
string formatting library
where you can control everything
that goes into it.
And that's,
the Linux community likes this saying
that any feature you can't
turn off is a bug, right?
Well, why don't they apply
that to their C library?
So with these tools,
can we express this in drivers?
Can we build this driver and make it work?
Yeah, I mean all we have to do is
make this an agent, and make this
string literal return an agent,
and make this statement return an agent,
and, yeah, we have an arena of agents
that can rely on each other and whatever.
And maybe I want stop bits,
because I'm talking to
some ancient machinery.
Maybe I want two start bits,
or all the other weird things
that are just here by default.
Well, I can drop those in,
and then they're agents,
and are found and are used.
And in whatever function may rely on that,
I would just optional that agent.
And so if the agent is missing,
then I'll just do the default.
And if I have some special
functionality to my uart,
I can also add to this canned set of
agents by making my own agent.
There's this thing called auto baud,
where you can tell some uarts, okay,
just look at the communication,
measure bit widths,
smallest thing you measure,
that will be the baud.
So you can say, okay,
baud may have changed.
Next byte you see, check
out what the baud is.
So we need to add this
to the public interface
so that we can do that.
Then we also need to test if
the baud rate had been set.
And we also need to, in the
interrupt service routine
handler, we may get an interrupt,
hey, I got a new baud.
And this is where we can really beat C,
because we know things
in our code generator
at compile time that the
optimizer doesn't know.
The optimizer doesn't know that
this one bit in this special
function register says,
calculate an auto baud.
And when that one bit has been set,
then this other status bit that happens
in that interrupt service routine
can never be true, right?
If I didn't say set auto baud
because it's not part
of the public interface,
then that branch in the interrupt
service routine handler
can just be removed
because it will never be called.
So we know more than the optimizer
about this particular piece of hardware,
and we can reflect that in our template
meta-programming library,
pretty simply.
User puts in an agent, user
doesn't put in an agent.
And in the handler, just, yeah.
We have to handle everything.
So that's kind of the basic concept
that I've more or less,
this a relatively young,
relatively proof of concepty
kind of a thing now,
but looking a little bit into the future
of where this is going
when you go this generic.
When you start decomposing all of your
objects into discrete design decisions
and then composing them in together again
into some valid set of things
that makes you an object
that you wanna do,
you have the problem with
vocabulary types especially,
but many types, you have
unexpressible types.
Like in the examples
so far, we've used auto
all the time, because that type is
probably, potentially 1,000
characters long or something.
Cause all of the template
information is in there.
That's where the unicorns
store all their stuff.
So one way to combat that,
in the Qt example or in many examples,
there is type erasure on the inside.
And even in shared pointers,
there's type erasure
on the inside, like the
allocator and the deleter
and so on and so forth
is type erased, or in standard
functions type erased.
So we've created this super-efficient
optimized type that the compiler
can see through everything,
where the compiler can
see through everything.
But maybe we do want type erasure,
just Shawn Perrin style,
like from the outside.
So we want a type erase
wrapper around the outside.
And we have an interface.
We have public interface.
We would have to add a few things to that
in order to build a composable
type eraser wrapper in TMP.
And I'm stealing these ideas
from Gasper's liberased,
cause that's basically what he does.
He made a composable type erasure wrapper
generator thing.
So this is possible.
so we could make an erased interface,
and anything that still
calls that interface,
and the other composition
that fulfills that interface
can go in there, and it can
have extra stuff, who cares.
So coming back to the
statically linking widgets,
the Qt dialog, could we model that?
Well, if we say, okay,
anything is a widget if it has
the widget public interface,
and a widget is probably
just a composition
of widget properties, then things
like the H-box layout would be a box
and a bunch of child widgets
and an interface, and maybe
some event delegating,
and so on and so forth.
And so these would then
be factory functions.
So let's look at one of
these factory functions.
So here we have V box layout,
and we're taking all the widgets
that are our children, and we're
associating some abilities
with this composed object.
So rather than specializing traits,
we can also embed a list
of abilities underscore T,
which this variable
template will build for us,
as the first template parameter
of the composed object,
and the traits class looks for that,
is specialized on first parameter,
is a list of abilities T.
And then we'll look in that list.
If the ability in question is in there,
and then resolve the true if.
Yeah, so this is another way
that we can associate
abilities with agents,
because now a composition of agents
can itself be an agent
in an upper nesting level
of a composition.
So we can arbitrarily nest
them as deep as we want.
And so we can make this
widget thingy work.
Now, what about the signal slot mechanism
between the box and the text field?
On change, it wants to
update the other one.
Well, there are two ways to go at that.
And one, I don't have time to explain,
so I'll explain the other one.
So if we assume that
everything that comes in
as stimuli, as in somebody clicked on it
or somebody changed it or whatever,
goes through the event system,
then what we could do is
take, in the top-level widget,
we could take that bowl of unicorn soup
that had all the type information,
that not only has all the type information
for that composition but
because all of the nested
compositions also go into
the type information,
that bowl of unicorn soup
has all the information
for the entire hierarchy,
and it is a pointer to most-derived.
If you have a pointer to most-derived
and all the type information,
you can walk down,
you can say, okay, I am a widget
deeply nested on this branch.
I can say, hey, I'm a publisher.
I will look for people who
subscribe to my messages.
Walk the whole tree, find
everyone who subscribed,
and call them directly, statically linking
without any of the
virtual calls and whatever
that go with the signal slot mechanism.
And when I was working on QuadsMPL,
my template meta-programming library,
people were making fun
of me for benchmarking
up to 8,000 types in the list.
And this is why you may
need that at some point.
We don't have examples now, because
doing that now would take you all day
to compile on BoostNPL,
probably longer than that.
But
if it can compile in seconds,
then it suddenly becomes viable.
So we essentially have
a poor man's reflection
over a hierarchy in C++14.
And so you could, for example,
write a really awesome JSON parser.
Or you could make descriptions
of your objects in the form of agents
and then nest them the way JSON does.
If you, as in the case
with microcontrollers,
have a known set of input/output objects,
then you can serialize
and deserialize them
in far, far less code than
any of the JSON libraries,
and you could even
potentially do it lazily,
so the output string never actually
even has to live in RAM.
You can just dump it into some sink,
like a serial port, and you get rid
of the problem of the unknown buffer size
because usually we don't have
a heap on microcontrollers.
So can we solve shared pointer?
I haven't made a reference
implementation yet.
I probably should.
But I think we can decompose
most of shared pointer
into these agents.
It will compile to
essentially the same binary.
Problem is the public interface.
I am constructing a shared pointer.
How do the unicorns know that this pointer
to something should go into that agent?
The constructor is a problem.
And this is not just
a problem for me here.
There's generally a
problem, in my opinion,
with constructors of, well, anything,
but definitely in the STL
because if you look at different
features in the STL and
how to construct them,
they all have about 12 or 14 arguments.
That seems to be like the pain threshold
of the committee before they start saying,
well, no one's gonna use that
theoretically possible
combination of arguments.
Because again, we're fighting
a quadratically growing
problem with brute force.
We're
making, for every one of
these five different inputs,
we are making a that thing exists
and that thing doesn't exist.
And then taking away the ones
that we think people
might not want to use.
And this will just get worse with ranges,
because we're adding a whole nother
one or two things that could be that way
or another way.
So we don't want the number
of constructors to double.
But if you think about the problem here,
we can kind of cheat.
So we can say,
oops, sorry, I should've, yeah,
so this is the big fucking
hammer solution, BFH.
(laughing)
We compose the exact same thing again
just to initialize it correctly.
Because if we're using
the composition syntax,
we're just passing
objects to a tuple here.
So we can initialize them however we want.
They don't need to be default initialized,
although they were in
all the other examples.
And the type that this is spitting out
is the same that we defined up here
with shared pointer.
And so I think with
guaranteed copy illusion,
you could even use
non-copyable types here.
But that doesn't matter because it's ugly.
So we could also use kind of a clever name
parametery kind of a solution,
make a variable template that spits us out
a type with a copy constructor
that returns whatever we want,
and then within the constructor inside
the composed type, we could then
index into the tuple, what has this type,
and put it in there.
And this is still a little bit problematic
because we support multiple objects
of the same type, but in
this case it would work.
It wouldn't work so
well if we had multiple
parameters, because the equals operator
will only have one thing
on the right-hand side,
and the constructor may
take multiple parameters.
So we could be less clever and then just
make it some tuple thing
that we're initializing
with input, and,
oh, no, wait, those shouldn't be curlies.
This should be a factory function, sorry,
cause otherwise the return
type couldn't depend on,
well, in C++17, these could be curlies.
Sorry.
So we can cheat out way
out of this problem,
and we have cheated our way
out of a lot of problems.
But I think there, we're
fighting with windmills again.
We're fighting the wrong fight.
I think the way we deal with
combinations of arguments,
or combinations of input,
is somewhat wrong.
Because if you think
about what we're doing
when we're making all those constructors,
we're following a very
defined algorithm, right?
Like okay, every one of these things,
there can be one or zero of.
And okay, make permutations.
We could express that programmatically.
We could say, here are the components
that need to go into this thing,
and build them.
And this is actually a talk
that Gasper is going
to hold in the future.
I just decided this for him,
because he has awesome
ideas in this field,
which I think he calls
production guidelines.
So the metaphor is
the extreme metaphor, I have a function
that takes a height and a width,
and a user will often have
height and aspect ratio
or width and aspect ratio.
So I should be able to make
some programmatically
expressed deduction thing
and be able to fall
back to name parameters.
And you can actually do that
to a certain extent in TMP.
We played around at C++ Now.
Or much more, Gasper
played around with Hana
to make that work, to a certain extent.
So he will do a talk
on this in the future.
Sorry, buddy. (laughs)
And this will be solved,
and then we'll be able to solve
shared pointer generically,
and all of the other instances
where people are trying
to add things to them
for one use case, where we really should
be thinking a lot more generically.
So yeah, I wrote a little more
than a PowerPoint presentation.
There's also a buggy GitHub thing, so
I'm gonna drop a paper and
declare victory, like the,
no, sorry. (laughs)
Yeah, so
if you want to work with me on this
or give feedback later or
you're watching the video,
Odin the Nerd at everything.
Or we can open up to questions
from the people that are here.
(applause)
Yes?
I think maybe to the mic, cause then
I don't have to repeat it.
- [Man] So there are clearly combinations
that don't make sense, right?
Like in your shared pointer example,
what happens if you
boot two shared pointer,
but it wasn't the name of the
thing that holds the pointer?
What will it do, right?
It depends, I guess.
(man talking quietly)
(laughing)
Well, it might be that
it will be a bug, right,
because of how the interface delegates
on how the other things.
- Yes, yes,
- [Man] So how do you deal
with these combinations
that don't make sense
or could be problematic?
- Well, one of the other agents
should be accessing
that thing as a execute,
as there is one of those.
And that would be found.
We have these for-each in the case
where there could be multiple or optional
or one single one for a reason.
We're not just accessing them.
We're also, in the same action,
expressing rules about
what a valid set is.
Yeah, this is something that I actually
didn't put into the talk, but it's good
that it's a question.
And it actually wasn't even planted, yay!
So
the main problem with
this method of checking
is that it's hard to prove that
there will not be, I
mean, this is the case,
there will not be a multiple of one agent
in the set, and no one is actually
accessing that agent.
I mean, you could have an agent that just
consumes functionality and is found
from the public interface in some way
where it wouldn't be noticed.
Or if you're expecting
two and you get three,
I mean, that's the harder case
because zero or one are numbers.
Two is not a number, right?
Two is part of infinity.
So yeah, there is some problem there.
And the other thing is
these contracts between the agents
are checked at the point where somebody
makes that call to the public interface,
because as long as
nothing is instantiated,
nothing will fail.
So if I make my shared
pointer in an invalid set
and never call any member function,
I mean, I'm not sure that that's bad
because I never called
any member function.
But it is bad in the case
where I do that and then somebody else,
in 10 years, says, oh, no, he should've
called this member function.
And then that exposes the fact, way later,
that this is an invalid set.
And there is a way to combat that.
You could actually make public interfaces
specify all of their functions
or reflect on them in
some future time in C++.
But at this point, you make a list
of references to all your member functions
and put that in some tag,
and then you could go through
in an unevaluated context, cause you don't
actually want to call them,
and pretend you called them.
And then everything would be, yeah?
(man talking quietly)
Yeah, type erasure will fall there.
But you may also not be type erasing.
But yeah, good point.
Cause it will generate all the calls
to all the public interfaces.
Yeah, good question.
Yeah?
- [Man] On the same note, or similar,
did you look at using Boost DI
to solve the compose problem
of what you pass into the
different constructors
of the different pieces?
- No.
I actually have not looked
into Boost DI at all.
Is it even in Boost yet?
That's Kris Jusiak's lib, right?
Yeah.
- [Man] It's still in experimental.
- Does that not rely on, I think I saw
a lightning talk of his.
Does that not rely on some virtual calls
somewhere anyway?
- [Man] I don't think so.
I think you can turn off virtual calls
completely in there.
- Yeah, okay.
Well if he is doing it
in a way that's viable,
then he must be doing it in TMP,
in which case we could use that.
But that would then be
probably just another flavor
of some production guideline, essentially.
But yes, thank you for the tip.
I will look into that.
Anyone else?
Yay, I have two minutes
left, a victory dance.
(laughing)
(applause)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>