<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Jason Turner “Practical C++17” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Jason Turner “Practical C++17” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Jason Turner “Practical C++17”</b></h2><h5 class="post__date">2017-10-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nnY4e4faNp0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- So if you're looking
for Practical C++17,
you're in the right room.
Hopefully that's why you're here today.
I will, I wanted to preface this
by saying I am giving an,
I am covering the C++17 features
that I found use for
in the work that I was doing.
So if you're expecting,
like a complete overview
of C++17 features,
that is not this talk.
That was Bryce.
He did two full hours on it yesterday,
and you can watch that on YouTube.
Hopefully my clicker works.
So this is me.
If you don't know who I am,
I am co-host of CppCast.
Host of C++ Weekly.
This is my YouTube channel.
Just crossed 10,000 subscribers.
I'm very happy about that.
And co-creator of ChaiScript,
we'll talk about ChaiScript in a minute,
and I'm a Microsoft MVP,
which I always forget to
mention for some reason,
so I had to put it on the slide
so I didn't forget.
So I am an independent contractor,
and I am available for
contracting and training.
Those are some URLs you can look at.
The next training I am
doing is on Saturday, here.
It is not too late to sign up
if you happen to be local to Seattle.
If your flight already has
you going back to Europe
on Friday night,
then you probably can't do that.
So ChaiScript is an
embedded scripting language
co-designed by me,
specifically for embedding in C++.
Supports Visual Studio, clang, and GCC.
Runs on Windows, Linux,
MacOS, and I have ported it
and proved it for FreeBSD and Haiku,
which is a little esoteric,
but I wanted to prove that
it had the portability
that I wanted it to have.
Currently requires C++14,
which is part of what this talk is about.
This is my experience porting it to C++17.
And it is header only with
no external dependencies,
except you have to have the dynamic loader
for your operating system,
so if you're compiling,
you might have to do dash L-D-L.
That's an operating system
thing, not my problem.
And designed for integration with C++,
and this is going to
come up a little bit too.
All of the types that are shared
between ChaiScript and C++
are the exact types.
So if you share a double to ChaiScript,
it's going to be a double
from C++ in ChaiScript
exactly the same.
This, well this will come up in a minute.
So again, this is my proving
ground for these talks.
I've actually got three talks.
This is the first one, or the third one,
depending on which order you look at it.
Anyhow, that is about
proving different concepts
C++ using ChaiScript as my base.
It's about 25,000 lines of code,
and I want to point that out.
It is not a trivially sized project,
but is also not a gigantic project.
I believe it is big enough
to prove what I want to prove
about various techniques in C++.
And as you can see here,
it's had lots of growing pains.
We started at C++03, and using Boost
with Boost shared pointer,
which since there was no
unique pointer in Boost,
has led to its own level of pain
of trying to back track
from having some of the
shared pointer stuff.
Onto C++11, 14, and 17.
The cops are driving past,
coming for one of you.
And I have got lots of
complex template usage
for automatically deducing function types.
So this is a real full
example of using ChaiScript.
You include a header
file, expose a function.
I've got a function on
line two called greet.
It is automatically had its types deduced,
and then the result of this
would be printing hello
world from ChaiScript,
so just so you know.
Okay, yes.
So you're all settled down,
but my talks are much better
if I can interact with you,
so feel free to stand up and
move closer if you want to.
I get one taker. Yes.
You need to interrupt
me and ask questions,
that is how these work.
Otherwise, I will get
bored, and you'll get bored.
Excuse me?
Interrupt, you know if you raise your hand
and I don't see you,
yell something out.
Ideally we use the microphones
so that they get recorded,
but I will repeat the question also,
because I want to keep
the conversation moving
if at all possible.
Hello.
Oh, okay. Sorry.
So I wanted to mention Slack real quick,
since I am heavily involved
in the C++ community.
So if you are not on Slack,
you can get on Slack,
and you can join in the conversation here,
and maybe we'll flip back
and forth a couple of times,
and see what people are saying
about my talk during it.
But this is the live Slack channel
for CPP Con that's going on right now.
Okay.
So I'm going to do an
overview of the C++17 features
that I use,
and we will see where this gets us.
So starting with Structured Bindings,
again, this is going to
be really high level.
We're talking like one slide per feature.
This is basically what a
structured binding looks like.
You have some expression,
you can automatically decompose it
into the components of the
thing that was returned.
Obviously added in C++17.
Has everyone been exposed
to structured bindings yet?
Mostly no. Some people yes.
So, well that's the gist of it.
It works just like auto deduction.
You must use auto.
It must be a comma
separated list of things
inside of brackets,
and, well I mean it can be auto,
const auto, const auto ref.
I think volatile can be used with it,
but I'm not sure if I've
actually tried that.
Does anyone know if volatile can be used
with structured bindings?
No it can't says pr no.
if-init expressions.
They allow us to do things like this.
We can have an expression
at the beginning of our if statement
that we are using here
with a structured binding.
So this lets us set up
something that's going to live
just for the scope of our if statement.
And this is interesting for
limiting the scope of variables,
and it also works for switch conditions,
but I haven't actually
put that to use yet,
in my own code.
So the standard library also
has a handful of changes.
This is one of my favorites,
even though it is like the
tiniest thing in the world.
Emplace back in sequence containers
was changed to return a reference
to the thing that was just added.
So it's exactly like the slide shows
there in the second block.
Emplace back is returning a reference.
I can have an auto ref, whatever it is,
and capture reference
to the thing returned.
So instead of having,
like if you have a reason
to add something to the
back of a container,
and then immediately access it,
this is neat.
And it's tiny, but it's neat.
String view.
We've had some discussion
about string view
I think at the conference so far.
Is everyone familiar with string view?
It's supposed to be a light weight wrapper
around string like things
that is supposed to be the new language
with which we talk about strings,
so yeah.
That's, excuse me, string view.
They're automatically
convertible to, from string,
and const char star.
Nested namespaces.
C++17, we can now do this.
I love this.
So if you have a reason to
have multiple namespaces,
you don't have to have
an opening, open, open, open, whatever.
We'll get to what effect that has.
Yes?
(audience member asking
question without microphone)
You can have an anonymous
namespace that's nested?
How would you do an unnamed nested n --
(audience member asking
question without microphone)
oh, can you?
Oh, yeah, no I don't think you can.
I can't think of any way
that syntax could work.
What?
(audience member asking
question without microphone)
oh, I'm sorry.
Yes, he was asking if it's possible
to do an anonymous nested
namespace like this.
I don't believe so, because
I don't think there's any way
to give a name to a thing
that you can't name,
or not name a thing
that you wanted to name,
or however that would have to work out.
So class template type deduction.
Sorry.
This is the gist of it, now in C++17,
if we want to use a class template,
we don't necessarily have to
specify the template parameter.
So in C++11 and 14 land,
we would need to say
that this is a pair of int and double,
and in C++17 land, this gets
automatically deduced for us.
Based on the types that are
passed to the constructor
that was chosen.
So in this case, it's able to see
that we're taking our first
and second by copying,
and our pairs constructor,
and it's able to deduce
that we want an int and a double pair.
I'm sorry, what was that?
(audience member asking
question without microphone)
Does it apply also for return types?
This is --
(audience member asking
question without microphone)
so the question is,
does it, would it also apply to,
you're saying return type from a function
if you could automatically deduce that.
That wouldn't, the only
way for that to work,
would be for the function
to actually return an auto,
right?
Because otherwise you
would have to specify
what the function is returning,
and if the function is returning an auto,
and you were to try to do this
braced initialized deduction,
it's not going to know what you mean.
So I think the answer is
no for what you're asking.
(audience member asking
question without microphone)
Is the explicit constructor required?
I'm not sure I understand the question.
(audience member asking
question without microphone)
yeah.
Oh, oh, that's an interesting question.
I have not played with whether or not
it would work in uniform initialization,
braced initialization, you're saying
without a constructor at all.
I'm not sure.
It does. Yes.
(audience member asking
question without microphone)
it does work for aggregated
construction, yes.
Okay.
So then, also deduction guides are added.
So they look kind of like this,
and again, supposed to be, you know,
pretty high level thing.
We're just saying, if we're
using forwarding references
in our constructor,
then we can tell the compiler
what we mean by that.
So for a more practical example,
we have updated our pair
so that it takes its two parameters
by forwarding reference,
and then we have our deduction
guide on lines 12 and 13
that tells the compiler
to decay those types
so that it knows what we actually mean.
I don't want to spend
a ton of time on this.
This is, well this
could be an entire hour.
And it's, I think been probably proven
by at least some people
that deduction guides
are true and complete.
If constexpr looks like this.
We have compile time conditionals.
So the things in the if and else
must be syntactically correct,
but you could be invoking methods
that don't actually exist on some type,
if the thing doesn't match the thing.
So if the, if the first block,
if the block is true, then
the first thing is compiled.
If the second block is true,
then the second, or excuse me.
If it's not true, then
the else is compiled.
And so this can have interesting impact
on things like actually
returning two different types
from your function,
depending on the things
that were passed in
and using auto return type deductions
in C++14 and 17 combined.
Fold expressions.
This is what fold expressions look like.
These are for variadic parameter packs.
So we've got unary left
fold, unary right fold,
binary left fold, binary right fold.
I always find these, which
one is left and right,
personally kind of confusing
because I expect the dot to be,
I expect the thing that I'm
naming to be on the left,
but really it's the dots
that are on the left,
but anyhow, it's allowed
in these operations,
which is basically almost every operator
except for, well dot,
but we don't have an overloaded
dot operator yet anyhow.
That'd be neat.
Sorry.
So this is the unary left fold.
Basically it's doing a left wise grouping
of the things that you are folding,
and a unary right is doing
a right sided grouping
of the things that are being folded.
And then our binary left and binary right
gives us an initialized,
an init that we can put up there,
and putting this true in here
is absolutely, completely meaningless,
because true and false is false,
but this is the, for the
sake of this example slide,
and the same for the binary right fold.
We've got our init.
So noexcept is now also
part of the type system,
and I think this is perhaps
one of the more esoteric parts
of C++17, that maybe most
people aren't yet aware of
because they haven't compiled their code
on C++17 compilers yet, but we'll see.
So, is.
This is what it means to me.
So I've got a function
that is expecting a pointer
to a noexcept function.
That's on line one in the top block.
And then I am passing my func to it,
which is not declared noexcept.
In C++14, this can compile
because it isn't making a determination
as to whether or not the
function pointer is noexcept.
Is everyone at least okay with this,
or have any questions?
So in C++17, you have
to add an extra overload
if you're doing things with
function pointers here,
and you want to do it in a generic way.
Things that can take noexcept,
or not noexcept function pointers.
Does it work the other way around?
(audience member speaking
without microphone)
Okay, so the question was, does
it work the other way around
and if I did not, so on line one
if that was not marked noexcept,
and I wanted to pass in a
noexcept function to it,
yes it would work still in C++17 also
because it is a lower requirement.
Noexcept function pointer can be converted
to a not noexcept function pointer.
I really have a really hard
time with the vocabulary there.
With the not noexcept,
I end up cascading all of these negatives,
but yes, it would still
work in C++17 also.
Okay.
Now we're going to talk
about the actual impact,
and how we define our impact.
Well, you know, I meant to ask
you how you would define it,
but then I accidentally went
all the way forward here.
So I'm looking at things
like compile time,
run time, code size, and readability.
And does anyone else
have any other opinions
as to what they would be
looking to keep in mind
for impact on their code.
(audience members speaking
without microphone)
Maintainability, yes. I totally agree.
(audience member speaking
without microphone)
Okay, yeah maintainability.
Code readability, oh that's up there.
I find maintainability and
readability interesting ones
and we'll get into that
when we actually start
talking about the impact.
What is different, you know, between.
Is something that's more readable
necessarily more maintainable,
or is something that's maintainable
more readable necessarily?
What's that?
(audience member speaking
without microphone)
No. Okay.
So, okay I have a poll up
if you have your internet enabled divide.
Strawpoll.com/w767k3kk.
If you can see that,
then you can vote as to what you think
of these options.
Class template type deduction,
if init expressions, fold
expressions, if constexpr,
structured bindings,
string view, enplace back,
nested namespace and noexcept
would have impact on
an existing code base,
and then I am going to go through them
in order of least impact to most impact,
and Wilkins.
- [Wilkins] I think it does
the voting by ip address.
It's telling me I've already voted.
- Oh, no.
I'm hearing that it does
voting by ip address.
Yeah I can change that actually.
Oh, I can't change that
without modifying it now.
Oh, well.
We will see.
We've got some votes.
There's three ip addresses in the,
alright, well.
That is yeah.
I can't get off the wifi and
still be able to look at this,
so, well some people are
maybe not using the wifi.
We'll see if we get anymore.
Anyone else get, hey.
Okay, we're actually
getting some stuff here.
Alright, you can continue to vote,
and we will move forward
so you'll get progressively
more disappointed
or something,
as we reveal what the answers were.
I will leave that up if someone
is still trying to go to it.
Should we check in and
see what Slack is saying
about this talk?
Hey. I didn't even
realize Youngs was here.
Okay, so answers from least to greatest.
Noexcept in the type system.
This actually ended up
causing a two time duplication
of my function type
deduction code in ChaiScript,
which is not unexpected.
But I have to have an overload
for all of my function type deductions
for things that can be noexcept.
And the reason I discounted
it a little bit here
is it required some
conditional compilation
because I have to use a
compiler feature macro
to know if I'm compiling on a compiler
that supports noexcept
to know if I should add the overloads
because otherwise I
get ambiguous overloads
on a C++14 compiler.
But, if you'll notice the last bullet.
Once I added these overloads,
simply enabling the C++17 flag,
it gives me a 1% performance improvement,
and I believe it is because the compiler
is able to do some better
optimization of the code
when it knows that the
function it is going to invoke
can't throw exceptions.
So I give this, I actually
ranked each one of these things,
and then I give a final
score at the bottom.
What the actual values are,
I guess is hidden to me,
but I got a minor performance improvement,
and I considered a
maintainability negative
because you have to now deal
with the fact that these
are extra overloads.
No compile time change,
and no real readability to
the code change in my opinion
because it was already a whole
mess of overloads anyhow.
Next up, if init expressions.
Now considering that it's
very low on this list,
you can already tell that
it's not the top thing.
This is terribly disappointing to me
because I love limiting
the scope of my variables
and making everything as const
as possible and all that,
so I was really hoping for something
that would be a lot of fun here,
but, you know, this is the basic gist.
We get to move the
initialization of the thing
that we're switching on, into the block.
(audience member asking
question without microphone)
Yes. That is, I think
nonobvious to most people.
It does that.
The val in the second block
would carry and is
visible in the else, also.
Yes.
It is as if you created a new scope
that contains your entire if block,
and put this thing at the
beginning of that new scope,
and then you have your if block.
So my code is fairly well modularized
with fairly small
functions most of the time,
so I found that I had changes like this,
and I find myself not as
impressed as I would like to be.
And then I kept finding myself going,
well how do I format this?
I feel like I want to do the top block,
slightly more compact,
but my brain is not used
to reading code that looks like this,
so I scan it and I don't realize
that I'm doing an initialization
at the front of that.
And then the second block
just ends up looking messy.
(audience member asking
question without microphone)
I'm sorry what was that?
(audience member asking
question without microphone)
Why did I expect to be impressed?
Because I just have this thing
with making my variable scopes
as absolutely as small as possible.
It's just what I want to do,
so I was hoping this is a new tool
that would really impress me,
and I guess I just wasn't as impressed
as I wanted to be, perhaps.
My expectations were too high.
Does anyone have any opinions,
as to which one of these
they think is more readable,
by the way?
So I can, like set my coding
standards, or anything?
(audience answering over each other)
First one, first one.
(audience answering over each other)
Wait, wait, wait.
Let's do this differently.
Who says the first block is more readable?
Well that's basically everyone.
Alright.
- [Audience Member] I
guess just do the same
as you do for for loops.
- Do the same that you do for for loops.
That's a good way to put it, I think.
Yeah, that works.
So no performance impact,
although it could potentially
have performance impact.
If you are actually able to
reduce the scope of variables
that then the compiler
could better reason about,
and could better optimize the lifetime of.
Small maintainability thing.
I think readability, it possibly hurt it,
for the reasons I already pointed out.
Yes.
- [Audience Member] Do you
have locks in your code?
- I do have locks in my code,
but they tend to be,
I have intentionally very limited
where I have to have my locks.
(audience member asking
question without microphone)
Yes, and locks I, yes.
And that's actually, locks is one of the
one of the cases that I
like to also like, demo
when I'm talking about this feature,
like look it could clean up your locks,
but I didn't actually find
use for that in my code.
Yes.
(audience member asking
question without microphone)
Okay.
(audience member asking
question without microphone)
Right. If you need it,
in cases where you have the
empty braces for a lock,
or something like that,
this could definitely be helpful.
I think I had one other case, but,
oh, I like it because also,
if you're using regular expressions,
and you need to pass in
the reg x match object,
then you could declare it there,
and then do the thing,
and you could get the
results back from the thing,
all in one thing, but.
I'm not using reg x because
it's not appropriate to my code.
Nested namespaces are next.
Oops. Oh, no preview.
So I have a fair number
of nested namespaces
because ChaiScript, as I mentioned
is a header only library,
so I use namespaces to kind
of obfuscate some things,
so I do things like this.
And I found this, like really,
I was so surprised how satisfying it was
to collapse my namespaces.
Like, yes.
And I know a lot of coding
standards and organizations
don't indent for each level of namespace
simply because it has
too many indentations.
I am not that person.
I do indent for each level namespace,
so it just, you know, I'm happy
to be able to collapse them.
However, when I was actually
doing this in my code base,
I noticed lots of large whitespace diffs
when I would go to make my get commits,
which is, then made me sad,
and then again, flipping back
here in the second block,
if for some reason I had a need
to add something to the
ChaiScript namespace here,
now what do I do?
Do I change everything again?
Do I add a ChaiScript
namespace above this one
that is just for the sake of
having a ChaiScript namespace?
I don't know, I haven't gotten there yet.
Yes?
(audience member asking
question without microphone)
Yes it wouldn't be a problem
if you don't indent namespaces.
I, like I said, I know
that most people don't.
I like indented namespaces.
It's, you know, whatever.
So just as something to be aware,
I felt like, you know, no
performance difference.
Maintainability, possibly
negative if you're like me, yes?
(audience member asking
question without microphone)
I'm sorry, I can barely hear you.
- [Audience Member]
Don't mix the two styles.
- Don't mix the two styles.
I thought about that, and
that's why this line says
might make us rethink
some of our coding and
formatting standards.
Because I was thinking,
I could just have this
ChaiScript dispatch detail,
and then, like the stuff
that doesn't need to be
in all three of them right below it,
just have ChaiScript
dispatch, or whatever.
Yeah, I think we'll be
rethinking some of these things
as we start to use them.
Yes, I was correct to go there.
Class template type deduction is up next.
So C++17 adds a complete
complement of deduction guides
for the standard library types.
So, I'm going to, now,
we're approximately halfway
through the features,
or something,
we're three or four in.
What impact, okay so
who thinks that class,
who thinks that class
template type deduction
with the standard library types
had a good impact on my code?
(audience member asking
question without microphone)
That's a question?
Oh, then it's a question,
you're not raising your hand to answer.
(audience member asking
question without microphone)
Okay, so, like being able
to automatically deduce
a vector of ints by passing
in an init list of ints
for example.
(audience member asking
question without microphone)
Well, okay, we'll get there.
Maybe let's just, alright,
and I just got my time card here
saying I'm slightly running
slower than I wanted to be,
so I will say, basically zero.
And I will say why.
At the class level, or struct level
where I'm declaring something
that's a templated type,
I can't use class template
type deduction here,
there's nothing to deduce on.
So I must specify that
it is a specific thing
like a vector event.
And let's just do,
okay, so who here would argue
that one is better, that A is better?
And who would argue that B is better?
I know I get some half hearted hands
raised on both sides, so,
B, in this example, is
having to instantiate
a standard function,
in this particular case,
it's probably not going to do
any dynamic allocation,
because it's fallen to the
small function optimization,
but there's no guarantee of that.
B is, like, probably calculably,
significantly longer to compile
because of all the templates
that have to be instantiated.
A is not.
So, in my particular code,
I found myself that auto
is way more important
than class template deduction.
So looking at this example,
and this is leading to
what you were saying
about using initialize your list,
who thinks that these are good uses
of class template type deduction?
So I don't have to specify
this is a vector of unique pointers,
or a vector of strings.
Let's, raise your hand, if
you think this is a good idea.
Wow.
Almost no one.
A handful.
Okay. Okay, why do we
think it's not a good idea?
Yes. Go ahead.
(audience member speaking
without microphone)
yes.
(audience member speaking
without microphone)
right.
(audience member speaking
without microphone)
you're correct.
You accidentally constructed
a vector of iterators,
but that would not happen
in this particular case.
Okay, I will put this a different way.
Can both of these samples compile?
No, some nods.
Anyone want to say why they can't compile,
or at least why one of them can't compile?
I have to wait now.
I need someone to give an answer on this.
Yeah, go ahead by the --
(audience member speaking
without microphone)
you can't move from them.
Yes, initializer lists,
is something that cannot be moved from,
so the second set cannot compile
because it is requiring us
to make a copy of a unique pointer,
which is impossible,
and the first thing is just,
really not good performance
because we have to create two copies
of each of those strings.
One that lives in the initializer list,
and one that is actually pushed
into the resulting vector.
And this is where I get the
shameless self promotion plug,
if you want to know more about this,
hire me to train your organization.
This is one of the things
that I love to talk about.
Alright, so I would say
class template type deduction
is possibly negative
if you're not thinking
about what you're asking
the compiler to do.
Maybe some maintainability improvements,
maybe some readability improvements.
(audience member asking
question without microphone)
Does the problem go away if
you don't used braced init?
That's a fascinating question.
If I didn't use a braced init,
how would I take advantage
of the class template type deduction?
(audience member speaking
without microphone)
okay, does, so vector does not have
a variadic pack expansion
that I am aware of.
Initializer list is the
prescribed way to do that.
And you, you might convince it
to grab one of the other overloads
that's like, I want to create
like ten integers kind of thing,
but I'm not sure.
I don't think so.
I think this is all it, yes?
(audience member asking
question without microphone)
Yes.
Yeah, the comment was that for containers
it's less interesting,
but for things like
pair or tuples perhaps,
things that are also related to,
like the pair that lives
inside a map better and faster.
Yes? Go ahead real quick.
(audience member asking
question without microphone)
Okay.
No. Yeah, no it would not
be able to deduce that.
If it was a bunch of,
you're saying related types
that were passed in, no.
You would have the same
problem that you have
with the initializer list.
It wouldn't compile.
So, alright.
So next up, structured bindings.
And I like this, and I
am going to try to move
a little bit faster, like I said.
So I like this because it
helps clean up our code,
if we're doing something like this.
This is real code from ChaiScript.
I have a function that helps me dump
all the types that are currently
registered in the system.
If you have, the first thing
with the ranged for loop,
that's already way better than
what we had with C++ pre 11,
but then with C++17,
we can do the structured binding,
and we can reason about the things
that we're actually, like accessing.
Instead of having first
and second, this is good.
Is there any performance impact,
and let's do this quick.
Who thinks the first one is better?
The first one, I'm getting
like more and more people
raising their hands.
Okay, who thinks the second one is better?
I'm only getting like three hands.
The why is that we are forcing a move
instead of letting the compiler
do a return value optimization here.
So we don't want to return by move.
That's, yes.
So which, who thinks the
first one in this example
is better?
I am not taking questions
at this time, no.
Okay, so a couple of you
think the first one is better.
Who thinks the second one is better?
Okay, we have a lot of
undecided people in the room.
The first one is, I've
highlighted them opposite
in this answer, sorry.
The first one is worst
because our return value optimization
cannot apply to the sub object.
So if we actually need
to return efficiently
a sub object from our pair,
we need to return by move
in this particular case.
So, who thinks the first one is better?
Here now that we're
using structured binding.
So almost, okay,
lots of people think
the first one is better.
Alright, who thinks the
second one is better?
Okay.
We still have exactly the same problem.
Return value optimization
cannot apply to a sub object.
That value is still a sub object
of the thing that was
returned from the function.
In this case, move is better.
Because it is not what
you're expecting, yes?
(audience member asking
question without microphone)
I don't believe the compiler
is allowed to do it in an efficient way,
and I have not seen a compiler that does,
and it is because in the standard,
bindings are specified
as if you had done this.
As if you had created some
mythical object called E.
That is the thing that was
returned from the function.
And then you create references
into the thing that was
returned from the function, yes?
(audience member asking
question without microphone)
I am not qualified to say
if this is a flaw in the language or not.
I honestly don't know how
it could be done better,
so I don't know if there's
a different answer.
Yes?
(audience member asking
question without microphone)
What if E has a non trivial destruct?
Then it's the lifetime of the
things that were the binding
is the lifetime of the
thing that was returned.
It's all, it works exactly
like you would expect it to,
just not in the way
you would expect it to.
So potentially very negative
performance impact here.
Because now you have to consider
the source of your variable
and in my opinion, in no other
part of the C++ language,
do we have to think about where
did this variable come from
when we're determining how
we need to work with it
and how we need to return it.
Minor maintainability help.
Potentially huge readability help,
so it gets points,
and like I said in my scoring system
that I didn't reveal to you,
it now has a score of two.
Fold expressions are next.
Basically, they are
where they are in my list
because virtually
everything that you can do
in a C++17 fold expression
can be done with a C++11
initializer list hack.
It is not pretty, but I have done
a few episodes of this on C++ Weekly.
You can check them out
so that I don't get into
it too much in detail here,
but what in the world?
Got a lag in my clicker.
So let's look at this real quick,
and make sure does everyone agree
that both of these versions
have a well defined order of evaluation?
Does the fold expression
do the void trick?
No it does not.
It is applying the comma operator,
which, spoiler alert,
is why both of these have well
defined order of evaluation
because they are relying
on the comma operator
being, well, by the old
terminology a sequence point,
so that we know that they're
going to be evaluated
left to right in order,
which is definitely distinct
from making a function call.
So, yeah.
So this code, and this is
stripped right out of ChaiScript.
I am actually doing this
exact thing right here.
I'm calling trace on a bunch of things
that were in a parameter
pack for one of my templates.
So I found, so this is what
the resulting code looks like.
I am using the comma operator
expansion fold expression,
and I have to put it in parentheses
to tell the compiler I'm
doing a fold expression,
and I find this, like I look at it,
and even though I'm the one that wrote it,
I find myself going a
little bit, like wait,
why is there a parenthesized thing
in the middle of this function block?
But this is doing exactly
what I need it to do,
and it is correct.
So I said, performance no impact.
Minor maintainability thing.
I ultimately concluded
there was no negatives here,
but I think potentially it could impact
your readability negatively,
depending on, you know,
it's one of those things
we have to get used to.
So now emplace back is the next thing,
it is getting higher on our list here.
And we have this code,
where I am adding an
object into ChaiScript,
and then getting the,
it's exactly what emplace
back was designed for.
You can see on lines 14 and 15,
I'm adding the thing,
and then I'm getting it back out.
I simply made it this,
and that was good.
I actually measured a
tiny performance on this.
Teeny, tiny performance improvement.
Because it was one less function call
that I had to actually do,
and I think it helps
maintainability and readability
a tiny bit,
makes the code more understandable.
What's my time?
Okay.
Alright, string view is up next.
So the main impact for
me on using string view
was looking up identifiers and
avoiding temporary strings,
but it comes with a complexity cost
that I don't think we're all expecting.
So just to be clear,
what does this constructor for string view
need to do, to actually
make a string view object?
It has to call string length, yes.
Now, there is a very good chance
it is done at compile time
if the compiler has direct
access to the const char literal
that you passed into it,
but it might not be.
So now we have this world,
where we already had const char star
could be automatically
implicitly converted to a string,
which has been the source of headaches
for performance in my code.
Now we have an expanding world.
Strings can be automatically
converted to string views,
const char star can be
automatically converted to string,
and const char star
can be automatically
converted to string view.
So we've got this intersecting thing,
and the operator less than,
or all the comparison operators exist
for string and string view, like this,
so if you want to do string
view less than a standard string
that's going to compile and work,
because it's going to
implicitly convert your string
into a string view,
and then call the less than operator
for comparing string views together.
So is this code good?
Let's say yes or no if this code is good.
I'm getting lots of nods,
some shrugged shoulders,
no.
No.
I think I'm going to make
someone cry over here.
This code compiles without
warning on any compiler,
just so you know.
It is creating probably
a pointer to a temporary
that was passed in.
Because the string is going to be
implicitly converted to a string view,
and the string view is a pointer
to the data that's inside the string,
and then that is being
pushed into our map.
Yay.
Dangling pointers with no warnings.
So storing a map of string
view is extremely risky,
and like I said, no compiler warnings.
So, we flip it around.
Now we're using string
view as our language,
we're talking about strings.
We have a map of strings to ints,
and we want to pass a string view into it.
Does this compile?
Raise your hand if it does compile.
Okay, no it doesn't compile.
Because there's no conversion
from string view to string implicitly
and the at method requires a string,
not a string view.
So the answer to this
is to use is transparent
comparitors added in C++14.
And we can do that like this.
On line one we are using
the std less template
that takes the void types,
and that is giving us a transparent,
is transparent comparitor.
I don't have time to go into the details
of what that means exactly,
but it allows the library,
when we call find on the map,
specifically, I believe
find is the only method
that works with transparent comparitors.
It's able to automatically
look up our string here,
and now we compile.
So, the question is,
now what are we doing
when this find is called?
Because we're using this
less than comparison.
Real quick, anyone?
So every comparison, I'm just
going to move forward, sorry.
For every comparison that
happens, we are having to
implicitly convert the
stored string in our map
into a string view
so that it can be less than compared.
So this is going somewhere.
How do we do better?
This is what the standard
library version looks like.
So it takes any two left
hand, right hand sides,
and simply returns less than on it,
and then declares the is transparent,
so that the standard library
implementation of the map
and the find method can know
that it can do this thing.
This is what my version looks like.
That I've added in ChaiScript.
Excuse me?
Oh, sorry, sorry.
I thought I heard someone say,
oh it's a weird echo right there.
There we go.
So this is what my version looks like.
I have a string to string comparison
that returns the less than,
as we would expect it to,
and I have one that does
lexicographical compare,
standard algorithm,
to return the less than
between the iterator pairs
of the things that are stored in there.
This is highly dependent, I am quite sure
on compiler and optimizer settings,
but in GCC 7.2,
adding my version of
this less than comparitor
was a 2% savings in ChaiScript.
And keep in mind,
that this was across all
of my performance tests,
but this only affects the
parsing of ChaiScript.
This doesn't happen at run time
once the script has already been parsed.
So this is significant to me.
Also, don't do this.
This compiles without warning.
It's happy, there's
automatic conversions here.
So we pass in a string
view into our constructor,
and then we are converting
that into a string
and this is perfectly valid;
however, it's, if, well,
it kind of decays into this
by the time you talk about
factory methods, or factory functions,
so we've got this make s that
we're passing a string in,
and moving that into the thing
that's expecting the string view,
and then using that to create
a string from the thing,
so we've gone, well,
it becomes this.
Well we pass in a const char literal,
which is implicitly converted to a string,
which is moved into a string view,
which is moved into a string.
Yeah.
And as I say here, not actually contrived.
I was like 85% of the way of
done converting ChaiScript
to using string view
internally for the parser,
and said, oh no what have I done?
Yes, so if you know
that you're ultimately
going to create a string,
make the whole call chain take strings.
So I gave this possibly huge,
either good or bad on performance
if you're not paying attention.
Minor thing I did not mention here.
The remove prefix and remove
suffix methods on string view
are amazing.
If you're doing parsing things,
and you can just kind of narrow in
on the thing that you want,
that's really great.
Way cheaper than doing it with strings.
I got a mild, minor
compile time improvement,
and I like the readability aspect
of knowing that you're
working with a string view,
not with a string, or something
that you expect to be able to mutate.
So this is basically everything
that we just talked about,
although I would like to point out
that GCC 7.2 still has a bug
with creating a string view
in a constexpr context,
that has been fixed on trunk.
Alright, next up.
If constexpr.
Whoops, keep doing that.
So I have a fair bit of code in ChaiScript
that has to do some
enable if kind of things,
and so this is real world,
exactly pulled from it,
and this is returning
values from functions,
and, well this is actually
returning member variables
that have been exposed to ChaiScript.
So I have to determine
if I've got, let's see what
are the two versions here?
If it's a pointer that was passed,
or if it's a pointer that's being returned
versus not a pointer
that's being returned,
and I have two different ways
that I have to handle it,
and anyhow.
So I was able to merge
them into one version.
I like if constexpr.
It made me happy, and it helped a lot
for some code that's like this
where I have to make
determinations based on type.
It eliminated about
half of my SFINAE usage.
Can anyone guess why it didn't eliminate
all of my SFINAE usage?
Anyone?
Oh, no wait I have
someone raising their hand
so far away I can barely see
there's a person over there.
Yes?
(audience member speaking
without microphone)
Yes to actively deactivate function calls
that should not be called.
And that is basically, yes.
Constructors and other things
where you might have a mix of
templated and other overloads.
So I have this, which
is my version of any.
It's slightly different
than C++17's version of any,
and that's partially because,
well I didn't have C++17 when I wrote it,
and I have my constructor,
which I have dutifully disabled,
it takes a forwarding reference,
but I have disabled it
for taking the type,
and we just heard about that this morning
why this is important.
So it disables itself
if you pass in an any.
And this is, so the
proper copy constructor,
or move constructor can be called.
So if we were to unfold this,
and I think I got all this code right.
Then we can make it say,
well we've just got this
forwarding reference
that we want to take,
and then we're going to
create our helper function
called make data,
and inside make data, we're
gonna do our if constexpr thing
and we're gonna say, well if it's an any,
then we're gonna copy it,
otherwise we will
actually create the thing
from the thing that was passed down.
Which has a problem, does anyone see it?
We don't allow moves.
So we can continue to expand this,
and have another level of if constexpr,
and say, well, if the
thing that was passed in
was in fact an any,
but a non const rvalue reference,
then we can say that we
want to move the data,
otherwise we'll copy the data,
otherwise it'll be an all pointer,
well I don't like SFINAE.
To me it's my least favorite part of C++,
but I'm sticking with just using it
for this particular case.
So on a side note of this,
is I've got a type inside of
ChaiScript called boxed number,
which allows you to do any operation
on any other type of thing,
so whatever arithmetic
operation you want to perform,
it maintains the proper types,
and this results in a huge
explosion of multiplication
of arithmetic types that are generated
at compile time for me.
If constexpr allowed me
to rewrite this code,
massively removing 160
lines of code in there,
and I was really happy.
I think I got a minor
performance improvement.
And a more linear flow of my code.
So, well I say no here.
Minor performance gains,
large maintainability gains.
It did help with my
compile time a little bit,
and readability help.
And now we're all the way up to a five.
If we recall we started at
what, negative 0.5 I think.
So class template deduction guides.
I'm going to mention separately
from class template deduction
because I didn't actually use the types
that were created from
class template deduction.
I didn't use the instantiated classes,
I just let them do the dirty work for me.
So in ChaiScript, I've got,
I did have many overloads
that looked like this.
Where I took a function,
let's see the first one is
a function pointer,
the second one is a member
pointer that is const,
and that's two of the very many that I had
because I needed to have
these for const, non const,
noexcept, not noexcept,
and member functions
versus free functions
versus member variables.
Instead, I was able to break this down
into a set of class
template deduction guides,
which I then used to tell me
what I needed to actually do.
And again covering the scope
of what I actually did here,
is, well we've only got
like three minutes left,
so definitely not going
to happen right now,
but I didn't have slides for it anyhow,
so you're not missing out.
And, so I have all of these
template deduction guides,
plus one simple function
that does the dirty work.
So I ended up with a no
change in lines of code;
however, I was able to
add rvalue reference
and reference specifiers,
and volatile specifiers,
so I ended up with eight
times the coverage.
I now can support
every possible method
signature in ChaiScript,
and had a zero nat on my lines of code,
and that made me, I liked that.
So now I'm up to a score of six.
Possibly some minor performance gains.
My code is significantly simpler.
I think it resulted in smaller binaries.
Large maintainability
gains, some compile time,
and large readability gains for my case.
And, so there are many constexpr things
that we didn't talk about
that are in the standard library,
like constexpr lambda support,
that's not in the standard library,
that's a core language
feature, but that's handy.
And I kept finding that it
was actually the little things
that I felt like had the biggest impact,
so, we're able to do maybe unused
instead of casting the variable to void
to get the compiler to
stop complaining at us
if it's something like
a variadic expansion
that we don't know if a
variable is going to be used.
Being able to do decay T
instead of type name
standard colon, colon type.
This was added in C++17, decay T,
and the underscore T, and
the underscore V helpers.
And, yeah that made my
code way more readable
in my heavily templated stuff.
And so, again, this is me.
And those are those URLs that I had up,
and there are CPP cast stickers up here
if you want any swag,
but I think I have concluded on time,
is there any questions?
(audience applauding)
Anyone?
Great it saves time if I
answer all of your questions
during the middle of the talk.
I'll start over here first.
(audience member asking
question without microphone)
Did I try some new library stuff?
Only, well I have an entire other talk
about optional, and that
didn't come up in here.
I, just emplace back and constexpr array.
Those are the main things
from the standard library
that really impacted my code.
And I think you.
Oh, oo a microphone.
- [Audience Member] Hey.
Thanks for the great talk.
Pretty awesome.
So you mentioned the Slack page,
but you know it's private,
so nobody can actually
join without an invite?
- Well there's a URL
that's on the marker board
for how to join outside.
- [Audience Member] Great. Thank you.
- Sorry.
Oh. Turned on just for you.
- [Audience Member 2] Hello?
Sorry. My question was,
I expected string view to have actually
a large impact on your project.
Was it below your expectation?
- It was --
- [Audience Member 2]
Especially the slicing
that's, processing kind of improvements
I would have expected.
- So internally, we were basically,
I had already wrapped up our stuff
into something that gave me,
like an index and an offset,
but I was able to use string view
in many cases, that just,
it's hard to define,
even if it didn't make the
code better, necessarily
in any, like tangible way,
it did make it feel better.
Like there were a couple of cases
where I would create, like a new offset
based on some new range
that had been shortened,
and now I just get to use remove suffix,
or remove prefix.
And that came up in number parsing,
because if I needed to, like
chop of the negative sign
at the front of it, or whatever, yeah.
I mean, I liked it,
but I just found myself going,
I need to tell people, you should be clear
about what you're using this object for.
Yes.
- [Audience Member 3] Hey.
So I'm not sure if you
paid attention to this,
but while doing the porting to C++17,
did you come up with any specific order
to tackle the features,
when making the changes?
so that you don't have a lot of rework,
or you don't shoot yourself in the foot.
- I, no.
I mean, I intentionally
tried to keep each commit
specific to a specific feature,
so I found myself going, well what feature
do I feel like tackling today.
I will say that,
the reason I said that this is
either the first part or the third part
of a three part series,
depending on how you look at it,
because this is the one I'm giving first,
but it's actually the
material that I created last
because I'd already
gone through the effort
of getting ChaiScript fully
constexpr and noexcept correct,
and then applied C++17 to it,
and then I was already well setup
for doing even more with constexpr
with the functionality that C++17 gave me.
- [Audience Member 3] Alright. Thank you.
- Sure. Thanks everyone.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>