<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Stephen Spann “Cross-Platform Apps with Dropbox’s Djinni...” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Stephen Spann “Cross-Platform Apps with Dropbox’s Djinni...” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Stephen Spann “Cross-Platform Apps with Dropbox’s Djinni...”</b></h2><h5 class="post__date">2017-10-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ssqhz_1pPI4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Just quick overview of
what we're gonna talk about.
Kinda, first give a architecture
overview about all the
living parts involved with
using C++ on iPhone and Android.
Just, all the languages
involved, that kind of thing.
I'm going to introduce you
to the Dropbox tool, Djinni,
and kinda go over what it
does, the workflow involved,
and that kind of thing.
Then we're going to go into the examples.
They're mostly high-level
architecture examples,
there will be some code on the screen,
I'll try to keep that to the minimum.
And I've also tried to
keep the functionality
to an absolute minimum,
which is gonna be strange
cause we're going into a lot
of trouble for minimal functionality, but,
the idea is you can expand
the base level architecture
into a much more complex type,
and combine some of these
methods and that kind of thing.
The first three examples
are all demonstrating
the different ways that
Java, C++, and Objective-C
talk to each other.
The last examples goes
more into data structure
as in passing data objects
around between the languages.
To wrap up, I'm just gonna go through
some random challenges
that I've encountered,
and how I've resolved them,
and point you to some additional
places on the internet
you can go for more information.
Alright, so let's get started.
So,
how we'll go, we want an
iPhone app and an Android app,
they use the C++ lever.
Why do we want to do this to begin with?
My main reason is,
for a dry philosophy,
don't repeat yourself.
There's a lot of code that goes into apps
that doesn't need to be coded
in Objective-C and Java.
We can extract that into C++
and reuse it for both platforms,
and kinda just concentrate on UI for
Java and Objective-C development.
Another reason, during the unit testing,
you can unit test once all your C++ code
before it goes to the different platforms.
So, dealt a little bit into that
and it's worked out pretty well.
Performance, C++ is known for performance,
so, depending on what your app does,
it may benefit from using
some C++ libraries instead of
the Objective-C or Java equivalence.
And just the sheer amount
of open source libraries
available in C++ is
somewhat of a motivation,
like, for example, Boost.
Alright, so what are our goals here?
We already talked about it a little bit.
We want an iPhone app,
and we're gonna code all
our UI in Objective-C,
or Swift.
I'm gonna focus on
Objective-C for this talk,
but it is possible with Swift, as well.
We also want our Android app,
which we're gonna code in Java.
They just announced Kotlin,
which I have zero experience with, but,
in theory, that would work.
If you can have a project
with Java and Kotlin,
you should be able to do this.
But, I can't guarantee that.
And finally, a C++ library
that talks to both.
And kind of, other goals,
move anything we can to C++.
So, we only manage it in one place
and update it in one place.
And utilize that library
on both iPhone and Android.
Alright.
Just a, kind of, a quick
little few bullet points
about what should and
should not go into C++.
So, if you have
your Cloud API request and responses,
it's a good opportunity
for C++ to do that once
and then send data to
Objective-C and Java.
Any sort of SQLite Database Logic,
iPhone and Android both
have access to SQLite,
so, we can handle all
that in C++ if we want to.
If you have really complicated
calculations or algorithms
or anything like that,
that isn't, you know,
it happens behind the
scenes, behind the UI,
C++ may be a good opportunity for that.
And pretty much anything we
can do with a C++ library,
OpenCV is a good example,
that kind of thing.
So now, what doesn't belong in C++?
This is, sort of, my opinion.
I know that some of these
things could go there, but.
Okay, so user interface and animations.
I actually like to
use the native
you know, iPhone tables
and my Android tables,
the platforms spend a
lot of time making those
really smooth and animated,
and I just assume, keep that.
There are some platforms
that you render a whole app
in JavaScript, and then your animations,
and that kind of thing
gets a little wonky.
So, this technique we get
to use Apple's table views
and that kind of thing, so, I like that.
App Store Logic is obviously gonna
be different for Android and iPhone.
You can do a little bit in C++ like,
unlocking content, that kind of thing.
But for the most part,
we have to go back to
iPhone and Android to
handle that kind of thing.
Sensor/Camera input,
some of that you can get through C++,
but it's a lot smoother to just use
the input from Objective-C
and Java and then
process the data, or whatever
you need to do, in C++.
Okay.
So let's go through an overview
of all the languages involved.
Or, we've talked about three.
C++,
iPhone coded in Objective-C,
Android coded in Java.
So, those things don't talk
to each other by themselves.
You can't instantiate
just, out of the blue, a C++ object
and start calling methods,
in either Java or Objective-C.
But there are, what we
call, bridge languages,
which is what we're gonna use.
So, on the iPhone side of things, we have
an Objective-C bridge built
with a language called
Objective C++.
On Java side,
a Java bridge built with JNI.
So, this is, kind of, one
of my favorite questions.
Show of hands, has anyone
had to ever deal with
Objective C++ or JNI?
A lot of people, okay.
So...
How many of you had an
awesome time with that?
And that was your favorite thing you've
ever done with a computer?
Kay, maybe?
- [Audience Member] Just C++ or JNI?
Either one (laughs).
- [Audience Member] C++ is mine.
Okay, alright.
So, JNI, not so good? (chuckles)
I can only speak for Objective C++
and I was trying to use the
open CD library on iPhone
and it was before I, kind of, discovered
Dropbox's tool and all, and it was a mess.
I had code in all kinds of weird places,
I couldn't tell where Objective-C ended
and C++ began, so.
I was renaming files to make it work,
so it was pretty gross, I didn't like it.
So...
That's pretty much a common theme,
is people don't like these languages.
So, they stop.
They are very error-prone.
They're difficult to troubleshoot
if you get this crazy stack trace,
and somewhere in the middle,
you have this nonsense Java function name
that has a package in it.
There's a lot of weird
stuff that can happen
trying to troubleshoot this.
There's little to no documentation.
I feel like, the Objective-C
documentation was removed,
or something,
cause I don't really find
much about it online,
other than stack overflow and what not.
And it just, it looks gross.
We're nice, tiny programmers,
we don't wanna deal with gross code, so.
So, we don't wanna lose heart yet, though.
So, we have this architecture
with these bridge languages,
and what we're gonna do is we're going to
remove them from the situation.
They'll still be there,
but we're gonna generate
them automatically
using a cool tool called Djinni.
So, just from a
developer team standpoint,
this is a lot more appealing
cause all the languages
we're gonna use are
languages that people actually
wanna put on their resume.
I don't know about you,
but I wouldn't put the
other two on my resume.
Okay, so let's go over Djinni.
Well, first of all, any
questions before I move on?
Good so far? Okay.
So, let's go over Djinni and what it does
and how it can help us.
What does it do?
It takes in, basically
a configuration file,
called an IDL, Interface
Definition Language.
We can define interfaces in
our enums, that kind of thing.
The main reason we want it is,
it generates interfaces for us
for each of the languages
that we care about,
Objective-C, Java, C++.
It gives us an interface for that,
that we just fill in the methods
and that's all we need to worry about,
as far as our language
bridge is concerned.
And it automatically
generates all the stuff
that happens between those,
so, we don't ever have to see it.
So, Djinni deals with three types,
kind of, the higher level...
Like, the top level types of
things that we'll generate.
So, enumerations,
records,
and records can have named properties,
everything you would expect, like,
bools, ints, strings, lists,
maps, and other records as well.
So, you can get a pretty complicated
data structure with Djinni.
It generates interfaces which is
mostly what we're interested in.
So, this is gonna allow us to
send methods back and forth
between these three languages.
You can add constants, as well.
The main thing missing here is properties.
We're not gonna really be able to
build an interface with properties
unless we build our own
methods to get and set them.
You can get around that
by using private members
in your various implementations
of the interface.
And, so, your methods can have
arguments and return values
of all the same types as the records can,
the record properties.
Quick little clarification.
So, there's another tool
that deals with IDL files
and generating code for all
these languages called Protobuf.
So, I wanted to, kind of,
compare these two things real quick.
So, they have different purposes, overall.
Djinni's really focused on
iPhone and Android development.
Just the languages of all, there.
Protobuff, has sorta,
what's a whole ton other
languages, PHP, Ruby,
and it's more focused on the
data structures themselves.
So, they're both two data structures.
Protobuf actually generates the
getters and setters for you,
so you kinda get that member feel,
but it's not an interface though.
So, you can't make methods with Protobuf.
Djinni, that's primarily
what we're gonna be doing,
is calling methods back and forth.
Okay, still no questions? Any questions?
Good.
So, first example.
Again, I'm trying to
make the functionality
as minimal as possible,
just to keep things simple.
There's no reason you
would need to do all this,
to say &quot;Hello World&quot; on an app,
but, we're gonna do it.
But you can kinda
extrapolate this architecture
into a more complicated app.
So, what are our goals here?
We're gonna build the
&quot;Hello World&quot; logic in C++.
We're gonna init the
class from Objective-C
and call the method.
We're gonna init the class from Java
and call the same method.
So, reuse the library,
get a &quot;Hello World&quot;, and we're good.
Architecture.
Start with iPhone,
we got the iPhone UI.
After that, we're going to
automatically generate the C++ bridge.
We're gonna pass through the
bridge and call the function
on a C++ library.
Android, same thing.
To a JNI bridge,
C++ library.
So, the important thing here
is the arrow is one way.
Right now, all we're doing is
from Objective-C and up,
Java calling a C++ method,
C++ is not calling
Java or Objective-C yet.
I wanted to clarify,
cause I'm gonna use the
word interface a lot,
and that's not, that's more of a
high level architecture,
kind of, perspective,
it's not what they actually are.
So, when I say C++ interface,
I'm talking about an abstract
class with virtual methods.
You can see on the right,
they've got the virtual
keyword equal zero.
Kind of, the typical interface, sort of,
situation that a C++
developer would expect.
Objective-C is a delegate,
much like a ELI table view,
delegate,
and ELI table view data source.
Again, something that
an Objective-C developer
is really used to seeing.
Finally, Java is another abstract class.
So...
When we extend that class,
Android studio's gonna
complain and want us
to implement all the abstract methods.
So, for now, I'm just gonna
call those things interfaces.
So, let's get into our first IDL file.
Pretty simple syntax,
looks fairly like JSON, or something.
Couple of notes here, so,
we're...
oh no!
Sorry about that.
Make it less easy. (chuckles)
So, we're creating an interface
that +c indicates what language
we want the interface to exist in.
So, right now,
we're just telling it to
build a C++ interface.
This create method,
it's getting around lack
of constructors, kind of,
so, it's a static method
that returns itself,
that we're gonna call
from Objective-C and Java.
Finally, our method that we're going to
call from both Objective-C and Java,
returns a string.
Pretty straightforward.
Now, the fun part, we're gonna run Djinni.
Djinni is a command line tool,
you just open up Console,
type in a command,
I usually make a shell
script cause there's actually
a lot more arguments involved.
You can specify all kinds of things like,
what directories you want the
different languages to go in,
if you want camel case, or
snake case, that kind of thing.
And more importantly,
you can specify name spaces,
you can specify the Java package name,
you can specify the
Objective-C, kind of, prefix
that's common with Objective-C.
Okay, so we run a script,
and what do we get?
We get our bridge code.
It goes in our directory,
we're never gonna look at it,
it can just stay there.
And the one thing they do care about
is it's gonna generate a C++ interface
that we have to implement.
Quick coding slide, okay.
So, on the left is the
auto-generated interface.
So, you can see the virtual methods
that we have to implement,
that kind of thing.
So, our implementation files,
the header imports that interface,
implements it,
and declares that we're
actually gonna implement
the, get &quot;Hello World&quot;.
The cpp file
has a couple things going on.
So, it implements the
method, hello from C++,
we're cool there.
It also has that create method,
which is a little strange
cause it adds it to the
interface.
But, I can't really
explain how that works,
but it does work,
and that's the thing that
will call from Java and Objective-C.
Okay?
So, now we're in iPhone world,
and this is our view controller.
Your controller is kind of,
the thing that represents each view,
and where a larger line exists
for all kinds of things.
The viewDidLoad, that's
kind of, the init method.
So, the H-W-C-P-P-A-P-I.H
is also a class generated by Djinni.
It is a full-blown Objective-C class
that we can do, it behaves
exactly like you'd expect.
So, we have a
private property for it,
and the viewDidLoad, we create it,
and then we call it, get &quot;Hello World&quot;,
and send it to the console.
Java...
Similar situation.
We don't have to import
anything cause it's in our
&quot;Hello World&quot; packaged name,
which we've configured
in our Djinni commands,
I didn't show that,
but that's what we're gonna end up doing.
Private variable for the API,
and then our own create method
which is similar to the
Objective-C.
We create the API and then
call it, get &quot;Hello World&quot;,
and should go out to the console.
How's everyone feeling about that?
So far so good?
Okay?
Okay.
So, these examples are
gonna build on each other,
and I'm going to avoid
repeating any of that.
So, I'll only show you the
new things from now on.
K, so example two.
Our goal here is going to be
to do, to access this bridge
and logic in Java and
Objective-C from C++.
This comes up a lot and...
The example we're gonna
use here is Android and iOS
both have a separate API for setting
a quick and dirty user preference.
Just a key-value pair,
different data types, that kind of thing.
We're gonna store a string, or no,
we're gonna retrieve a string
from Objective-C and Java.
So...
Recap. (chuckles)
Call a Java function from C++,
call an Objective-C function from C++.
So, what's that gonna look like?
It starts out pretty similar
to our &quot;Hello World&quot;.
The UI passes through the bridge,
and it calls off,
or it instantiates the C++
class, that kind of thing.
So, when our library wants
to go back over the bridge,
it's gonna go through
the Objective-C interface,
or the delegate.
And also, Java interface.
So, these are things
that Djinni is going to
render for us,
and we just implement it in our apps,
or wherever we see fit.
So, how do we actually do that?
So, previously,
in Objective-C and Java,
we instantiate, basically
instantiated a C++ class,
that's not really a
great way to say it, but,
from our perception, that's what we did.
We can't do that, backwards, right?
So if, we're in C++,
we can't create a Java object because
we don't know if we're gonna
be in Android or iPhone, so.
We do something with the,
I'm gonna call, a listener.
So, this is from Java's perspective,
we create a listener object first,
we pass it to our C++
object with a create method.
So, a listener is now,
there's an argument listener
that we instantiated in Java.
And finally, in C++, on our create method,
we would save that listener
as a private variable
and throughout our whole API class,
we can call our get preferences function.
And C++ doesn't care if
it's Java or Objective-C,
it works out really well.
So, let's write our IDL file this time.
So, a few different
things to look at here.
We have two interfaces, first of all,
so we've added an argument to our create,
that actually, the value
of which, is our listener.
And our listener now has different,
we're telling Djinni to make
it in different languages.
So, we're telling it to make an interface
in both Objective-C and Java.
So, now we run our Djinni
command again, the fun part,
and what do we get?
We get our bridge code, goes in a folder,
never look at it.
We get our API interface again for C++.
And now, we get Java interface
and Objective-C interface
from the preferences listener.
Okay, so now we're going to
implement this in Objective-C.
So, we import
the listener interface.
We create a NSObject that
conforms to that delegate,
and down below, in implementation,
we implement the get preferences function.
So, below that,
the NSUserDefaults, that's the IOS way to
get that quick and dirty key-value pair.
So, then we just,
we get that, we get the
value and return it.
So, Java, pretty similar.
We don't have to important anything,
cause it's in the package.
So, we're...
Extending that PrefsListener,
which is a Java interface,
and our implementation implements getpref.
So, the shared preferences,
or get shared preferences,
is Java's way, or sorry, Android's way
of getting a quick and
dirty key-value pair.
So, we get that, return it, we're done.
There's the, app context is another thing
that you have to deal with for Android,
since we're not extending an activity,
but you can just pass in a context
and call all the methods you need.
Okay, so that was...
The user preferences example.
Questions, anyone?
Alright.
Okay, sorry, there was one more slide.
Okay, so.
C++ interface now has an argument.
So our create method takes a,
the interface argument,
so, it could be Objective-C or Java.
It passes onto its' constructor,
we save it, and then later we can
call or get preferences.
We can do that pretty much
anywhere in this class.
So, this is just showing,
creating what the object will look like.
So, very similar before,
except with the
C++ create method.
But now, we instantiate
either an Objective-C or Java object
to send to C++.
So, worth noting that we're
using alloc, init, and new,
cause we're initializing
Objective-C from Objective-C
and Java from Java,
so we can just do it the
normal way we always do it.
Okay, next example.
Now, we're gonna get
more into something that
you might actually want to build.
We want to implement Google Analytics
on all of our platforms.
So, we're gonna add TVs here.
So, we're gonna do iPad, iPhone,
Android, and then
Android TV, and Apple TV.
So...
We're gonna kind of pretend that
we have a really complicated app API,
and at some point, we do something like,
we call our web API,
it returns some user data
and we set some values like,
are they a subscriber?
What tier of subscription
are they, that kind of thing.
Are they paid? Are they free?
What are kinda, something
we would wanna tell
Google Analytics, as a dimension?
So, to separate users.
And, this logic is,
so it happens somewhere in C++.
So, we need C++ to tell Google Analytics
a custom dimension or something like that.
We're gonna use Google's
libraries if we can,
so, there's already an Android
library for Google Analytics,
and a Objective-C library
for Google Analytics.
And finally, the reason for this example
is so I can demonstrate
a use case for generating
all three interfaces.
So, let's take a first
stab at this architecture.
Android, we're gonna separate
the TV UI from the Android UI,
cross the bridge,
and talk to our app library.
This app library is not gonna change,
it's gonna be the same
for all of these things.
It's our C++ library.
And go back across the
bridge to our Java interface,
which is going to talk to
Google's official library.
Alright, pretty cool so far.
So, let's try to do the same thing with
the Apple TV and the iPhone and iPad.
So, separate tablet and the phone UI
from the TV UI, cross our bridge,
talk to C++,
come back across the bridge
to our Objective-C interface.
Also, the Java interface and
the Objective-C interface,
when we implement those,
those can be the same on both the TVs
and the iPad and iPhone.
And now we're gonna talk to
Google Analytics for iOS,
but, there's a problem.
If you try to import
Google Analytics for iOS
into Apple TV, you will get an error,
it can't publish because
it doesn't support UI.WebView.
So, now I have to kind of
think of something else to do.
First thing we're gonna try is
just keep everything in C++.
So, got all our UIs crossing the bridge,
talking to our C++ library,
our C++ library can just talk to Google.
There's a reporting API,
you just send a request to
and it'll log everything.
You can set it at all kinds of perimeters,
like your app name,
your Java, or that version,
you can set custom dimensions,
you can do pretty much,
not quite everything, but
a lot of what you wanna do.
I think it was originally
intended for things like
Raspberry Pis and stuff, that
don't have a web browser.
So, this makes programmer
Stephen pretty happy.
You're reusing everything,
everything's talking the same way,
but it doesn't make
businessman Stephen happy.
So, when you go into Google Analytics
and start poking around
at device information,
that kind of stuff,
some stuff's missing.
So, I wanna go back and try to
use the Google libraries wherever we can.
So, we're gonna combine the two things.
Android, Android was always fine,
so keep it exactly like it was.
Apple side of things,
so iPhone and iPads separated from TV,
they're both crossing the roads,
it's the same library but
I had to separate them for
just aesthetics.
So, iPhone and iPad
back across the bridge,
interface, Google
Analytics for iOS library.
And now, Apple TV, what do we do there?
We eventually get to the reporting API,
we were just talking about
with the C++ solution,
but now, we've included another interface.
So, in-between our library and the API,
we're gonna build our
interface that matches
all the other interfaces.
And as you can guess,
Djinni's gonna do this for us.
They'll have all the same methods,
and as far as C++ is concerned,
they're all gonna be
the same type of object.
So, what does the IDL
file look like for this?
So, down below we have the
API that we've been creating.
There's one difference
here, wait, let's see, okay.
So, the top part.
So, our listener now
has all three objects.
So, it's gonna create a C++ interface,
Objective-C interface,
and a Java interface.
They're all gonna
conform to this interface
which has the overly
simplified track screen,
tags a screen name.
And our interface,
now has,
wait, okay, sorry,
oh! Yeah.
So, the listener,
we don't actually need that
create method weirdness,
because what's going to happen is
we're gonna instantiate
the C++ object in C++.
So, we can just do it the normal
way we would always do it.
Finally,
you notice our API has two
different create methods now.
We can't really do overloading,
so we kinda have to rename things.
So, one takes an argument, one does not.
So, the top one would be for
iPhone, Android, and what not,
the bottom one would be Apple TV
which is gonna default to C++.
Run our command,
similar to last time.
So, bridge code,
never look at it again,
C++ interface that we implement,
and then finally, for our listeners,
we have three different listeners.
All which have the track screen method
that we have to implement
on each platform.
So, now let's look at the
C++ API implementation
and how we handle the listener.
So, now we have two of the create methods
that return the API itself.
The top one is for Apple TV,
so we instantiate our listener as a
shared pointer, pass that to our
second create function,
create with listener.
And our,
our constructor saves the
listener like we did before.
And now that listener track screen
can happen anywhere in that API.
Any questions about Google Analytics?
Okay.
So, this is gonna be the last example.
So, right now, so far we've only talked
about interfaces and methods,
talking to each other with methods.
Map Pins is gonna talk
more about data structures
which we can also do with Djinni.
Thankfully, it's a lot more simple.
So, our goals here are...
We're gonna architect the
data structure with Djinni
in our IDL file,
we're gonna pass data objects
between C++ and Objective-C,
and pass data objects
between C++ and Java.
So, our architecture is pretty
similar to the &quot;Hello World&quot;.
We don't need to go back to
Android or iPhone at this point.
IDL file.
So, we have our API,
much like we did before, create.
Then we have two methods,
get pins and add pin.
Get pins returns a list of pins
and add pin takes an argument of a pin.
So,
down below, we haven't seen this yet,
this is Djinni's other, one
of Djinni's other types,
which is a record.
It's basically just a list of values,
or sorry, names, and their types.
So, for a map pin we have a label,
longitude and latitude.
Oh, right,
so, record, we didn't have
to specify what language
because, no matter which
method we call above,
get pins or add pin,
we're gonna need the
record in all languages,
Objective-C, Java, and C++.
Run our command,
bridge code, tuck it
away, never look at it.
Our C++ API which we have to implement,
and then our different data objects.
So...
C++ is gonna be a structure, or struct.
And Java and Objective-C are
both gonna give us objects,
which again, handle just
like any other data object
on those platforms.
I'm gonna spare you a bunch of code here
and just show you...
What it kinda looks like creating
objects in each platform.
So, there's our struct,
there's our Objective-C init,
a data object with the arguments
and Java initiating on object.
And, back to, kind of,
one of the good things
I like about Djinni is,
all three of these things
are very familiar to these
different, like if you had
three different developers,
all those things would
be very familiar to them.
What's crazy is Objective-C looks
like that's how you initialize things.
Okay, so now on
those other examples.
Any questions? No questions, alright.
So, we're gonna kinda talk over some
challenges I've encountered doing this,
and my solutions to them,
and possibly maybe get
feedback from you guys,
maybe there's better ways
or maybe there's something
I'm not thinking of.
I got really tired of
bullet points at this point
so it's just gonna be titles,
me talking, and some monsters from D&amp;amp;D.
So.
Alright, so, Namespaces.
I ran into this problem,
so Djinni allows importing
other Djinni files.
I ran into this problem when I,
say that the analytics library,
I wanted to have that separate
and use it in two different halves.
You would think you would want
a namespace for your library,
a C++ namespace for your library,
a C++ namespace for your Java,
oh sorry, your first app
and a different namespace
for your second app.
That didn't work out so well
because when you wanna start
doing the listener type stuff,
and reuse some things,
the different namespaces
can get all messed up.
So, my solution was to just
stick with app one namespace
and app two namespace,
and a library just gets
either namespace in these.
It's all generated automatically,
so it doesn't really matter.
There might be a better way to do that.
So, that was one of my issues.
So, architecture woes.
It gets complicated when
you try to separate things
much like the libraries,
or just functionality in one app.
How do all these things
talk to each other?
So you can have a gigantic
app API with all these methods
and you can instantiate other
C++ things inside of that,
but again, you have that gigantic API
to deal with.
You can also have multiple APIs,
so in Java, instead of just
instantiating that one API,
you can have two or three different ones
if you can separate your
app logic like that.
But then when it comes time for them
to all talk to each other,
where does that responsibility go?
I would prefer it to be in C++ but,
I usually end up with some in C++,
some in, on my native slide, but.
It's just one challenge that you
kinda have to think through.
And at first, I'm kinda
like, Djinni's awesome,
like, it kinda architects for me, but.
There are more problems.
Database IDs, I never, like,
this was kind of frustrating to me when
I was using the data objects
like the map pin example.
So...
If you, make your crud interface,
like create a record,
all that kind of stuff,
with the new record, you don't have an ID.
So, I ended up having to kinda
do two different structures,
which I wasn't totally happy with,
one with an ID and one without an ID.
Some possibilities
there, like null or zero,
or something, I don't know.
So, multiple implementations.
This isn't really a problem,
but it is something that kinda helps.
So...
Back to the google analytics example,
say you wanted different things to happen
on different platforms.
Say like, say you needed to
go back to Android and iPhone
to get user agent string of the browser.
Well, Apple TV can't do that,
so, you can create a separate,
and you can even,
like, the way to get the
user agent string is to
on Objective-C, is to
instantiate a web browser
and kind of get that property out of it.
So, you can't do that on Apple TV.
So, the solution there is
to have just a separate implementation,
that can actually extend
another implementation,
and yeah, you can have
several layers there.
And for Apple TV, the
solution there was just
return a string that
isn't a user agent string.
So, Boost filesize.
So, this might even be
our motivation to use
Djinni in a C++, in our app is,
there's so much functionality
with these third-party libraries,
particularly Boost.
Boost is huge.
And I ran into this when
I was trying to convert
one of my apps into
an Android instant app.
So Android instant apps,
you break apart your Android
app into little pieces,
components, and then, in theory,
the user doesn't have to go through
the app store to get your app.
They can just click a web link,
they download a little piece of the app,
they're in the app with functionality,
and then later they're prompted
to download the whole app.
So, one of the requirements to do this
is each piece of the app has
to be under five megabytes.
So, when you get in the
C++ world with that,
you already have it,
some file size just from
going to the native language.
And then Boost on top of
that was like a megabyte,
or two, I wanted to say,
so there just wasn't space for it.
But if you're doing like a larger app
then you don't need to
worry about instant apps,
then you're probably okay.
So, main thread.
I ran into this just,
kind of, calling the C++,
actually a timer is a good example.
So, calling a timer for C++ and then
the timer ends in C++,
goes back to iPhone and
changes something on the UI.
You have to be careful to
call things asynchronously
and not on the main thread.
- [Audience Member] Question.
- Yeah.
- [Audience Member] In all the C++ world,
this is this thread, this is that thread,
do you do those things on thread A,
do those things on thread B?
- I don't know that I can
answer that question perfectly,
but, so, Boost.AISO has several different
threading libraries, and on that kind of,
the iPhone side of things I can speak to,
you can specify when you call C++,
what thread it's on.
So, you wouldn't do that in C++,
you would do it before you called C++,
does that make sense?
- Yes.
- And you can also do that
around the responses from C++.
So, actually a better thing to do is,
when you get the response from C++
and you're gonna change the UI,
then put that on a different thread.
Okay.
So, some additional resources.
In case you're interested
and wanna get into this.
So, getting Boost into all this stuff
can be a little bit of a challenge.
For OS X and iOS, there's
a pretty good dull script
that just builds libraries
and you drop them into
your projects.
TvOS, at the time,
so this was a year and a half ago
when I was trying to do all this,
on tvOs, there wasn't,
kind of a funny story.
I spent like a couple days,
like Thursday and Friday one week,
working my tail off trying
to get Boost into tvOS,
closed the laptop on Friday,
had my weekend, came back Monday,
did another Google search,
and this thing appeared, so.
This was right after Apple
TV was released, too,
which is kind of one of
the things I didn't go to
about why I do this,
is I can be on a platform
as fast as I can.
If you were doing something like Xamarin,
you might have to wait
for Xamarin to update.
So, that last link is
actually an alternate
NDK for Android.
It has several useful
things going on with it,
has just basically better
C++ support in general,
although now, Android has come a long way
as far as their support.
And I think it even comes with Boost.
There's a little bit of more
configuration you have to do,
but it's kind of all
packaged up in the NDK.
So, other links.
There are two good help
repositories up there,
there's the official Djinni one,
and there's also this project called MX3.
It's a little out of date at this point
but it does have some pretty good examples
of that listener architecture
I was talking about,
and just kind of,
good practices, in general.
A lot of what you saw today
was based on that repository.
Mobile C++ tutorials,
that's my website, it has tutorials on it,
if you wanna check them out.
There's also a really good slide channel,
mobile C++ slide channel.
A lot of the Drop Back
Up guys hang out there
and answer questions
and all kinds of stuff.
So, that is about all I have.
Does anyone...
Have questions, or comments?
Yep.
- [Audience Member] So...
If I want to return an entire class set
into a callback,
so a simple example of
CS, I got information,
here's the string that you
applied during call back
but if I wanted to
return that data object,
does that data object recycle data
or does that have to
be from share pointer?
I saw a share pointer being used--
- Right, so.
That is a result of the actual interface
that Djinni generates for us,
it already has that create
method with share pointer.
So, it's kind of enforced by Djinni.
Around SU, passing around other objects,
you could do it exactly
like we did our listener.
- [Audience Member] When
I go back into Djinni,
instead of returning a string,
I'm returning my formula object--
- Right, oh, a C++ object.
- [Audience Member] Correct.
Do I have to make sure that
and then return it?
- Yeah, so I've never needed to do that
but I think if you just,
do the same thing we did with
the Google analytics example,
and make the interface
in all three languages,
you can pass it the other way as well.
That's a good point though,
I've never tried that.
Yeah?
- [Audience Member] How
come it, or how gnarly
could the records be?
I saw there was like lists of structure--
(audience member drowned
out by background noise)
- I've never tested the limits,
but it can kinda get
as narrow as you want,
again, you have all kinds of
data types, you have lists,
you have maps.
And the one weird thing is
they're only one level deep,
so if you had a property
that's another record
like, say you had,
say you had an enumeration
that was a job title,
and you had a record that was an employee,
like you couldn't declare those
things inside of each other.
That was a bad example.
If you have another record,
they're just one level deep, so.
If you had a really complicated record,
it would actually be a long
file with separate records.
(audience member drowned out by echo)
Right, I think so?
That's something I'd have
to try, I don't know.
Okay, well I guess, if
there are no more questions,
we can wrap up early.
(audience clapping)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>