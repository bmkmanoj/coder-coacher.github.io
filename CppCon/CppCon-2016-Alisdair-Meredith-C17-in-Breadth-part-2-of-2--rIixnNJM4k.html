<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Alisdair Meredith “C++17 in Breadth (part 2 of 2)&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Alisdair Meredith “C++17 in Breadth (part 2 of 2)&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Alisdair Meredith “C++17 in Breadth (part 2 of 2)&quot;</b></h2><h5 class="post__date">2016-09-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-rIixnNJM4k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm already 90 seconds late so I'm
going to have to really get going so we
finished with the template instantiation
guides nice example of how we might use
them with vector interesting point that
we didn't actually get this early enough
so the standard library added this to
vector so this is what we're saying
we're out in the ballot comment period
time I filed ballot comments suggesting
hey this thing saying this is the
motivation for doing this let's do this
stricted bindings is a another light
breaking feature that I expected to be
really popular the idea is so I've got a
function that returns multiple values
and I want to declare a bunch of
variables that are the result of
breaking down those multiple values into
separate variables so the syntax is
we're using all of our wonderful tokens
Auto square bracket X comma Y introduces
two new variables x and y that will bind
to the result of dereferencing in this
case map fine so it's first and second
of that pair what does the stricter
binding syntax work with functions can
return any aggregate so I've got a C
style struct I don't need to anything
extra that will already just bind
correctly as long as I provide the right
number of identifiers for the new
variables I'm declaring and I can return
an array by reference and it will wear
for initialize the same number of
variables of that type or something that
supports the tuple protocol where the
tuple protocol has not yet been nailed
down properly in the library but the
intent is this will all be smoothed over
and cleaned up by the time 17 goes to
print so the idea is you're providing
specializations for tuple size and tuple
element and the get function in order to
retrieve the element out of the tuple
using those values but it does mean that
array parent topple out the box already
support those types we've just not given
you the user the rules for how you can
customize your own types to specialize
those traits and it also works anywhere
initialization may be performed so this
was a fun one that had figuring out to
draw the slides you can you know got a
map using a for loop and can
Auto reference give me first and second
from the map I've got first and second
variables directly usable within the map
you'll notice I've used an auto
reference to make sure I get references
out and it means that I've got a Const
reference to first and a regular
reference to second as include is a
little tool putting into the
preprocessor that it's an extension in
several popular can powers today and
people wanted it in the standard for a
while so here's my husky example of them
trying to use the file system header
I'll see if I can include the file
system header and if so great namespace
FS is standard file system otherwise
I'll see if I can find the experimental
file system header and if so great
namespace FS is the experimental file
system header otherwise last-gasp I'll
see if I can find the boost file system
library and I'm missing the HPP on boost
file system so that's a bug on the slide
if I can include that great I've now got
the boost file system is my namespace FS
otherwise yeah I'll give the user an
error I couldn't find the file system
library this codes probably not going to
work
language tweaks going on one that was
requested going back at least as far as
C++ C 11 we finally get is the ability
to open an STD namespace so a namespace
STD colon colon file system I don't need
to know independently open both
namespaces really is nice because it
means I can close it with a single curly
which is fairly handy when you're trying
to write these things in macros not that
we like writing mini macros and you can
wise reckon if clauses I thought this
was a particularly dubious feature until
someone gave me the classic motivating
example and now I love it too bit
basically the idea is it's avoiding a
pair of curly brackets you're not
writing anything you that you couldn't
write before but it is just so much
neater on the page similar to the idiom
of where you would initialize a point
with a dynamic cast inside the earth in
this case I'm going to take a lock over
the Konkan call so if lock garden mutex
elk it okay I get my lock but the test
that I'm going to do once I've acquired
the lock is V door empty and if the
things empty I'm going to do my push
back
so I acquire the lock before doing the
test but I've got a scope of mine if if
block and the else for that for that
lock
another simple small cleanup for static
assert often if we're using good class
names with good identifiers the thing
that we're testing is clear enough that
coming up with a separate string literal
to describe the error it's frustrating
it's annoying especially if you're
writing a lot of these especially
writing test drivers so just having the
static assert string guys that text like
it would with a regular assert is a
popular little feature so we can now
omit the string literal nor just string
eyes the text of the code and obscure
little corner at the end that this is
significant if you've been following
what's happening with the ranges TS and
if you've not you'll find out again
another three to five years but the idea
is a range doesn't need to have now the
begin in the end iterator be the same
type I can have some kind of query that
when I'm querying it against the end as
long as I ever I'm testing with tests
with the first iterator type I can have
it a simplest sentinel type at the end
that is very useful in some kinds of
ranges especially input ranges so this
is an idiom that were propagating all
the way through the ranges TS which is
coming for the library in the medium
future in the meanwhile we put that
support straight into the new range base
for loop so if people have loops a
returnee functions at returning ranges
they can drop them into the loop a
obscure corn they were clarifying
explicit default constructors as I said
I'm going to show you everything we've
done in a standard look the final
bracket Zed C is equal to empty braces
is this supposed to work is it not a
standard was ambiguous on this and it
turned there having gone round the
various alternatives that making that
ill-formed is the one that seems most
consistent with the way explicit
constructors work elsewhere in the
language these days so that was cleaned
up and that
actually simplifies an awful lot of
library issues that were hanging on this
specific core feature one of the more
contentious things we were dealing with
at the end was nailing down an order of
evaluation of expressions this has long
been a corner case for bugs in C++ you
know I plus plus plus i plus plus is not
well-defined optimizer folks love to
claim this is a really important corner
where they can get the most out of
language and folks learning language
especially coming from other languages
have undefined behavior in the programs
that they're not seeing and this is we
don't like that confusion so we came to
some kind of a middle ground where the
operators of the web the standard
operators are plus minus and so forth
are all going to have a clear well
specified order of evaluation now
function call operators so the order and
evaluate the expressions within a
function call so a B you know I'm
calling F with ABCDE evaluation of ABCDE
are now all indeterminately sequenced
that is progress since C++ 14 where they
were actually uncie quince and therefore
I could have date arbitrary data races
or interleaving of instructions between
any of those evaluations now there is
going to be a sequencing but whether
it's left-to-right right-to-left or any
random permutation you don't know that's
known only to the compiler vendor there
was a desire to make that left-to-right
you might read about people saying it
should be left to right we had some
feedback from some optimizer folks who
implemented that and said yeah we were
doing right-to-left before and when we
switch to left-to-right we're getting
this much of a performance penalty and
we don't want to pay it so certainly as
far as 17 is concerned we're not nailing
down the order any more than
indeterminate with sequence but there is
now at least a sequencing there to
eliminate further kinds of awkward
corner case bugs it also means that when
you overload an operator the overloaded
operator when it's called
will have a sequencing between the
evaluation of the two arguments that
would be quick consistent with the
underlying operator which finally means
you can overload operator comma to do
what the built-in operator comma does so
quick example X equals y plus plus plus
y plus plus is now well-defined it means
I'm going to increment Y and then add
that to incrementing Y in exactly the
order you see whereas if I call a
function f with y plus plus comma y plus
plus it's no longer undefined behavior
it's going to do something and that
something will be well defined at the
language level but you don't know which
values of the third those two arguments
will be because the order of evaluation
the 2y plus plus is you don't know
ongoing language tweaks I think this is
the end of the language now we've got
this funky function coming into the
standard library which is effectively a
function that does nothing so it should
be an operation but it gives information
to the compiler regarding a lifetime of
object the in particular obscure corner
cases when you're building some of our
more advanced data structures you get
into corner cases about type safety of
the language that's okay I'm going to
destroy this thing in place and recreate
another thing on top of it and how that
interacts with a lifetime rules of the
language you just need to give the
compiler a hint so it doesn't say how
you've got into undefined behavior the
way you're abusing the type system here
standard launder says we're about to do
something funny mister compiler you're
not allowed to optimize on the
assumption that we weren't allowed to do
that if you never hit one of those
corner cases are thank you you're in the
99.5% of C++ developers you never need
to know about this but when you're
trying to build some debt some data
structures classic example be a flat map
where I'm trying to resource ort my
elements in my vector but I've got a
comp a pair with a Const key so I need
to somehow swap things with consti I
need to play funny games with the type
system and those games will probably
involve calling standard launder to keep
it all well-defined Const cast isn't
enough final corner the memory
allocation of over aligned data so when
we call operating you
do new with it yes what this is the
arguments for the new operator prior to
passing the arguments of constructor so
it's like to be an in place new I can do
a new with a size and an alignment using
the new align val t enum class and those
the full set of the core language
changes so just in time to start on the
library gsa is significantly larger in
terms of page count hopefully will go
fairly quickly because libraries are
much easier to summarize because as soon
as you go into depth you've suddenly got
this much to talk about so i kept trying
to talk about this match starting with
the multi core support we've got these
two terms we've been throwing around or
just make sure that you're on the same
page that the standard committee up and
we talked about these terms parallelism
is the idea of using multiple executing
unit to perform the same computation as
quickly a single computation as quickly
as possible
farming out lots of tiny parts or the
same computation and collecting them all
again at the end okay yep I've got my
result concurrency is multiple threads
of execution doing different things at
the same time so that you know we get to
the end when the last of those results
is already oh it's a good way of
reducing latency it's very useful when
you're doing lots of them asynchronous
processing but it's you know different
kind of set of idioms and be usually
different goals than parallelism just
trying to accelerate some one specific
thing as much as possible so we now have
context per is always lock tree for your
atomic types in the standard library you
can query if they're lock free or not
but prior to see per for seventeen that
function itself wasn't Const expert so
it was a runtime dispatch of your code
now with it with context per the
compiler could optimize that away and
with if Const X but you can actually go
down different branches of logic
entirely so making that context was
actually fairly handy we also have two
new values that are context burb
integers or size t types that aren't
terribly meaningful to me cuz I do not
work at this very low level but this is
coming straight out of the folks who are
working directly with
hardware so your writing came for the
PlayStation you've got a very good idea
of your target the idea is these are
describing the cache lines of your CPU
so the compiler itself at compile time
needs to know the cache lines of the
target that you're optimizing for but if
you can do that you're going to get
values here that are going to be very
useful otherwise it's going to give you
its best guess values and your logical
using those will be as good as the
guesses but the really high throughput
applications that are really sensitive
to cache lines and specific hardware
that can know the hardware they're going
to be running on these can actually be
incredibly useful so also on the
concurrency side of the library C++ 14
we added shared locks C++ 17 we're
adding here mutex and they're very
aliquot guard so the idea in the very
early what guard is I'll say here's
three four five different mutex is I
want you to walk make sure that you
acquire them in the same sequence every
time which should resolve a potential
risk of deadlock sit with some kinds of
code on the big change it big progresses
is we're adopting the parallelism TS
which is adding parallel overloads for
many but not quite all of the standard
algorithms so what happens is all of the
algorithms in basically the numeric and
the algorithm header where we can we're
adding an additional overload where the
first temp first parameter to be used
will be an execution policy that
describes or give permission to the
algorithm to make further assumptions
that allow it to optimize its algorithm
and dispatch using multiple threads or
vectorization instructions other
executing units we're not providing
parallel support
oddly enough algorithms involving random
numbers because parallel random numbers
are still a very interesting research
area I mean I can provide parallel
guarantees on a single thread but as
soon as I go across multiple threads
does each of those threads see the same
quality of random numbers is your broad
distribution across the threads also
going to be good and random
it's a tough topic to go into so we're
just not going there
keep operations other than querying it
is heap or is heap until I'm not going
to have the parallel overloads anything
involving permutations as going from
permutation to permutation tends to be a
fairly serial algorithm and again these
other algorithms I've got in Orange do
not get parallel support we do add to
the numeric header for new algorithms
exclusive scan inclusive scan transform
reduce and reduce that some of these I
feel a bit if you're familiar with the
term MapReduce will be making sense
inclusive scan and exclusive scan I'm
not particularly clear what they do but
these terms are the terms of art used by
the high-performance computing parallel
community so if those terms resonate
with you that probably what you think
they mean when I look at the word scan
this wasn't doing what I was expecting
so read the spec if you want to know
what they do changes since the TS was
first published which is basically the
last year now we have forward progress
guarantees that I spoke about in the
memory model back at the start of this
talk we're applying those to describe
the progress guarantees on the parallel
algorithms themselves the execution
policies were renamed to be something a
little bit simpler is going to be using
these frequently enough the behavior
when an operation that the user supplies
throws an exception has been changed to
trap in the TS we tried to have a note
in it when exception list we could
accumulate a variety of exceptions and
then throw an exception list object you
could somehow retrieve the acceptance
from without ever documenting how you
would populate that exception list
yourself now as we're promoting these up
to the main standard it becomes
important that the users writing their
own parallel algorithms can interoperate
with the standard algorithms in the same
way people know the framework and if we
can't populate around accepting lists
that's going to be a problem but further
even as we try to nail down what this
meant we were seeing lots of problems
with the formulation the next
expectation of an accepting list in the
standard so the policy has changed this
if anything
user-supplied operation so anything from
one of your factors or the increment
operator on your onion iterators or
trying to dereference in the iterator if
any of these operations throws the whole
parallel algorithm would just call
terminate and bring the process down and
that includes when you're calling with
the sequential execution policy so an
algorithm with the sequential execution
policy is not the same as calling the
equivalent algorithm without a policy
and this is not an accidental oversight
it's deliberately by design because the
idea is trying to debug parallel code is
difficult enough switching to a
sequential execution model of the same
code having you sent with the same idiom
in semantics is very helpful in tracking
down the debugging if this is suddenly
propagating exceptions rather than
terminating it's not having the same
behavior so the main reason that the
sequential policy here is debugging aid
to serve its purpose it has to terminate
in the same way on the math side we
incorporating the separate is that we
created roundabout 2012 based upon the
vibraphone the original library
technical report we had 20 or so
mathematical special functions in there
so Bessel functions beta functions the
Reimann zeta function if these terms
resonate with you you know all the
goodies you're getting if they don't
resonate with you going to research
these things it's probably not going to
help you this is fairly obscure
mathematics unless you're up at graduate
level math there was a desire to
incorporate those in C++ 14 that or even
C++ 11 but there were concerns about the
cost of implementing these and bigger
concerns about the cost of supporting
these you don't want to have somebody on
the hotline who's got to answer I've got
a bug report on your Bessel function is
your gamma technical support phone
capable of dealing with that but there's
been sufficient demand for these now
coming from certain scientific
communities that the idea of maintaining
two standards and the free availability
of reason could weasel to good-quality
implementations of these functions we've
finally folded them into the main
standard itself
we're also grabbing on the smaller scale
of things a three argument version of
the hypotenuse function yay so we can do
three-dimensional as well as
two-dimensional triangles greatest
common divisor and lowest coming at
least common multiplier and we're adding
a sample function so we will go over the
rank begin end we will write through the
output iterator a a number of samples
using a specific random sequence and
ingenuity in the realm of vocabulary
types vocabulary types are the kind of
thing that you want to use in your
interfaces so vocabulary types work
really well when there's very few of
them if you've got seven ways to
describe the same thing you're going to
need an exponential combination of api's
when things start interoperating with
these ideas so the more we can get
common vocabulary into the standard the
more interoperable libraries will be
that use the standard vocabulary so
we've had pair for a while this is
really you know a simplified version of
tuples so we've already got a bit
occasion about vocabulary there and
we've got standard array so we've got a
pairs you know contained with two types
tuple is a heterogenous campaign
container event values and array is a
homogeneous container event values we
now have the idea of optional which is
i've got a value or it--don't which is
clear you know it it's the type it's
been wanted quite a while with people in
getting around this by perhaps using
pointers but then who owns a thing that
the point is pointing to and you end up
with lots of awkward code trying to
manage the lifetime of these things so
standard optional is the primal
vocabulary for expressing a result that
either produces something or doesn't
standard any is the vocabulary type it's
a container for one of anything as long
as that thing is copy constructible and
you can hold it you'll notice it's not a
template it's just a regular type that
holds anything let's copy constructible
the fun comes when you want to take the
value back out but we'll get to that
later variant is kind of like optional
it's a container of one thing but in
this case it's one of us
sequence of types so I've got a bunch of
types it can hold one of them and you
can tell me which one it's holding
unlike any which can hold anything which
is a much larger set of types but I
don't know which one it's holding and
the other vocabulary type that's been
coming through is string view which is a
reference into a string that doesn't
actually own the string is much more
like to wait for passing around as a
vocabulary type in a lot of interfaces
so pet and tuple every standards we have
a new way to clean up and break pair
interval so C++ 14 we added the ability
to retrieve an item out of your parrot
apple with a get of the type rather than
get of the index so we've got a couple
of in this case an int a standard string
and a double if I call get the int it
knows I wanted to get the one out of
there if on the other hand I had to intz
it would be ambiguous and the call would
fail to compile in C++ 17 all the
Constructors for parent supple and now
we're going conditionally explicit now
explicit constructors were an
interesting thing in C++ 98 but only
meant something useful when you had a
single argument when we expanded the
rules for brace initialization for C++
11 explicit constructors with multiple
arguments suddenly acquired a meaning
and that was unfortunate for tip all
that had made its multiple argument form
explicit on the grounds that that might
be a single argument and we didn't want
the implicit conversions they're trying
to resolve that issue ran through a
variety of design choices but the one
we've come down to is if my
initialization of that tuple with that
set of arguments with hit an explicit
constructor then that same constructor
of tuple should be explicit
so we inherit the explicitness kind of
in it inherits up from the elements of
the tuple itself but it's specific to
that form of initialization so we've got
a converting constructor with many
parameters it checks each of those
individual constructions and says if
fat's annexed was a constructor then
that constructor will be marked explicit
otherwise there's no explicit there this
is a joy to implement as you can only
imagine no we have no language support
and no the core folks have no interest
whatsoever in jumping down this rathole
to give us language support but once you
can it got the tricks it's it's fun a
fun problem to solve and a painful want
to keep implementing one of the other
things we can do now is we can for a
long time be able to pack function
arguments for example with make to put
into a tuple we've not been able to go
the other way and unpack the arguments
into a function call or a functor call
so now we have the apply function to say
here's a function here's some arguments
practing the tupple unpack them and call
the function with the unpacked arguments
for me i believe it was actually sitting
around as an example in the c++ 14
standard and that exact example is now
just the definition of the library and
finally similar to the apply function
going the other way we can construct an
object by unpacking a tuple so this is
equivalent of apply for a constructor so
kind of like make pyramid but make sure
that make unique you you specify the
type of thing you want to construct so
I've got a tuple using me then you funny
constructed deduced type syntax auto
tuple one one two three
I can then why I can make from tuple and
say I'm going to make a my type I've got
to specify the type in the angle
brackets but it will then unpack the
trouble to the appropriate constructor
of my type OP film so this is the idea
of a type that's going to substitute for
T and behave exactly like a T if T has a
value the default constructor is going
to go into the empty state though so I
don't have a value the reason say
behaves exactly like T is when you get
to the overloaded relational operators
classic example I've got an optional
double and the double holds an an the
standard way that the library has so far
approach is defining the six where
operators is you define equal equals and
then not equals is the negation of equal
equals so if I do equal equal on an
optional double holding an am it will
say yes false then and doesn't equal
itself okay does it not equal itself
under the old rules it would not equal
itself because it's the negation of
equal equals but if I'm holding an am
and passed directly down to the nan
operator not equals also returns no I
don't equal myself and now the equal
myself nor do not equal myself I'm a
bizarre thing Emma nan so optional t4
words or six relational operators down
to the underlying T rather than
synthesizing them the way we've always
done in the library in the past this is
a really contentious design call but the
fundamental idea is no optional T is
really intended to stand in for the
original T so it's important to have
these semantics rather than we invented
something else to go along with them
from that we need to say well where does
the empty state order and yeah it's less
than all the others
and yeah you access the element by
dereferencing it as if it or a smart
pointer that makes it relatively easy to
do in existing code that has been using
pointers to represent this kind of idiom
in the past especially going through our
functional interfaces next one about
vocabulary types we have variant this is
an interesting type in that this didn't
go through any of the TS processes it
came in it was just missed getting into
the fundamentals to TS it was a
slam-dunk my fundamentals three but
given by having all about other
vocabulary types shipping in this
standard and the huge amount of time was
burnt getting this design right there
was a real desire to ship this in the
same vehicle so bearing has come all the
way up the process and the shipping in
C++ 17 in particular there was a strong
concern that shipping any without
variant would lead to people over using
any interfaces where variant was the
right answer so the idea of variant is
it always holds a value this was one of
those again an important awkward design
question that can variant have an empty
state
code is a lot simpler if I never need to
worry about the variant being any I can
just you know visit it query it and it
will always have a good answer but
there's a cost having a never empty
guarantee and that cost typically
consists of double buffering cos if I'm
reassigning a new value to the variant
and the reassignment fails by throwing
an exception how do I get the original
about the original value back typically
I would have that in a second but for
now I would just translate between the
two but that so that I've always got a
good state and can just transition one
way or the other but that now means I'm
paying twice the space overhead to my
variant than I would want or I could
allow for the fact variance can be empty
and therefore always have to query the
empty state worrying about my that in
addition to all the other states in the
variant so people banged on this really
hard in terms of design and it was seen
that the majority of types that users
want to store in these as long as
they've got a well-defined no throw move
constructor
you can always temporarily move away the
object and you've got a guaranteed
ability to move it back so it's common
for implementations to be able to
eliminate the empty state the need for
the empty state and not consume extra
storage
but in those rare cases where users do
give us these awkward things that throw
we've now introducing this valueless by
exception state which isn't a state you
can construct directly this is why it's
different when actually having an empty
state in the vector it's not something
in the variance or you can't request it
but you need to be aware that yes
variants can enter this strange
valueless state if an exception is
thrown it's a particularly awkward time
if you want the program against the
never empty guarantee and assume it
doesn't happen most of the time you'll
be correct and I liken this to
programming with doubles and ignoring
the idea that Nan's might be in my data
set the majority of the time I control
things well enough that this isn't going
to occur especially from writing
non-generic code so I know all the types
that are in my variant but in generic
code every so often I might have to
worry about this and then I've got the
empty state and those
algorithms will just be a little bit
more complicated to implement and I
might have intended so other obvious
things so I can access by type because
variant holds things by type but we're
also allowed duplicate types in that set
of types and therefore I can access by
index so and whatever the third type was
and we have a variant size and variant
element I think they're the reforms of
tuple size and tuple elements so I can
introspectively query what types of
variant can hold similar to a C++ Union
the default constructor is going to
value initialize the first of the
alternatives in that type list as if
that were the first element of a union
and again in a manner similar to the
optional library it's overloading all
six operators as if trying to forward
them to the underlying operation between
the two the elements held in the two
variants but first of all we check if
they've got the same index and we'll
order by index before we order by okay I
mean I've got two things I know that the
same type so I can now just do the query
on the operation for those same types on
the assumption that operator exists if
the operator doesn't exist the whole
comparison for that variants going to
fail regardless of what type it's
holding because that's a compile time
constraint standard any as I said before
can hold any copy constructible thing
because it's going to dynamically
allocate a copy of that thing
essentially on the heap we might have
some small object optimizations if you
strike start passing integers and so
forth but mostly if you're storing
something in any object you've got a
dynamic allocation and it's copied onto
the heap if I make a copy of the any
object it makes a copy of that thing on
the heap so both any objects have their
own copy if I want to get something out
of the any object I've got to know what
type that is and then we go we query it
with the anycast
function which is kind of the funny
dynamic cast we have on smart pointers
we've now got any cast is a way to try
to retrieve the item out of in any I can
retrieve it by reference any caster to
an end
and if my any holds an int I have an
improv if it doesn't it's going to throw
a bad any exit bad any cast except and I
think it throws an exception and
conversely I could try and retrieve it
by pointer and that case I'll have a no
accept guarantee but it will just give
me a null pointer if the cast fails I
can also query the type ID of the object
that's held but there's not a whole lot
you can do with a C++ type ID that might
give you a clue as to how the API is
implemented though in particular it will
not do based derived conversions for
compatibility and pointers for you it's
got to be an exact match in the world of
text handling we've now got basic string
view which is the analog of basic string
it's kind of like an AK on string
reference given that everyone seems to
agree that it's a real shame that basic
string has way too many functions we
want to use this as a drop-in
replacement for basic stringing menu
function so it has the same way to many
member functions it's basically got
every Const qualified member function of
basic string and it's got a couple more
that allow you to shrink and grow the
range that you're viewing over on the
underlying string being idea being it's
your job to make sure you don't go over
the band so shrinking is easy but if
you're trying to grow the range of your
viewing it's your job to make sure you
don't go out of bounds we also have a
faster string searching network
framework in the book using the by or
more algorithms the idea here is I'm
going to have a large I'm trying to
search for a common string across lots
of different bodies of texts so I can
effectively construct a small finite
state machine to describe how I would
search for that string to say ok once
I've searched I'm actually first seven
characters but not the last the eighth
one failed I know I can usually jump
seven characters in the underlying
sequence unless there's some common
subsequences which might mean I jumper a
smaller amount so it's a handy way of
people researching for the same string
in many different bodies of text
minor fix for basic string we've got a
data member function that only had a
Const are valid so we now allow the non
constable owed so I can pass the content
of a string to a an underlying C API on
the group with the understanding that
I'm not going to try and change the
length of that string in particular I'm
not allowed to overwrite the null
terminating now I can introduce other
null bytes because strings are allowed
to have null values but the terminating
though should not be over in and final
thing in the purple we've got a high
performance number string passing
library coming in this is in pink
because when we came to apply those
edits to the final standard it didn't
apply clean there were a couple of minor
issues that were picked up in the
interface there so we're sending it back
well well my file encompasses say it was
meant to land but the editors weren't in
a position they could merge it cleanly
we expect that to be cleaned up and that
is still expected to be a part of C++ 17
when the actual standard is published
next year far system library is our last
large TS that's being landed into C++ 17
so basically were adopting the TS as was
published around about the same time as
C++ 14 and resolving a bunch of defect
reports are coming in over the
intervening three years the
specification is based on the POSIX
standard to define the noting of a file
system what it means to navigate a file
system and all the operations on the
file system it doesn't mean you have to
have a POSIX file system underneath but
it does mean that you've got your the
fastest um that you're using should
hopefully have a fairly clean mapping to
the POSIX semantics so that this library
can be layered on top one of the big
concerns that was reported against this
and did give us some pause about whether
we were correct to adopt this at this
point is that we have no protection
against data races at the file system
level so make a file that you know make
a temporary file name now open the file
name somebody can afford things in the
middle is an opportunity for an attacker
to do a man-in-the-middle kind of attack
on your code so this is not in
tended for that kind of application
we're securities our real concern if I'm
writing small applications to know to
mind my own opera own machine or many
common uses where security is I'm within
a constraint where I don't have to worry
about that
it's more than good enough but please be
aware do not use this up this library
thinking you're going to not be
introducing any see using this fiber is
going to injuries potential security
holes in your code be aware of that
concern it uses the system error
reporting the system error exception
handling exception categorization that
we introduced in C++ 11 and all the new
facilities that come from the file
system TS are added in the STD file
system namespace
I'm not going to exhaustively enumerate
them all because as I said this is a
quick catch-up and of things we have so
a quick categorization and a few things
that changed into the ETS the basic
class is file path that you will notice
is a regular class it's not a class
template like basic string it's a class
that can traffic is constructors will
take a regular string and a wide string
and now that we have them but also a
string view in a wide string view on top
of that we've added a lexical API for
decoding relative paths so I say it's a
lexical API because we're doing
operations purely on the string names
themselves and we're not querying the
operating system to say how do i best
map from this path to this other path
which might have to deal with things
like symlinks and so forth resolving
through those paths might be able to
find shorter resolutions will not find
the canonical resolutions so the key
things that we get from the filesystem
API are functions and iterators that
allow us to navigate a filesystem and
then the corresponding operations that
is create delete files and directories
and symlinks and so forth
tap traits library type traits is a
popular library if ever you're doing
anything with templates because the idea
to introspect and guide your template
algorithms accordingly is a you too too
much to pass so in sequence or 17 or C++
14 we added a bunch of alias templates
for all the type traits that computed in
return two types with an underscore T
suffix that were often substantially
easier to use because you didn't need to
have the type name when you used them
and it was just a nicer interface so for
C++ 17 we're adding something similar
for type traits that return the value
where we're using a variable template
with corresponding underscore V name
it's not clear that these are is useful
but when I implemented my own version
but tab traits library I found that code
working with the V's especially as I
made the visa actually my primary
definition and the separate an alias to
almost to the trait just turned out to
be much cleaner in use because I'm not
jumping between type based
representations of values and actual
values in the language so code just
somehow read more cleanly but it's not
so clear it's as big again but it is a
nice consistency to have throughout the
system alright wise bull constant is our
new alias for integer constant of bull
again I was not very excited when this
came in I started writing code using it
and it just looked so much neater and
cleaner and this is a lot of what we're
getting from 17 code written
idiomatically I just feel simpler and
cleaner when I was talking about the
fold expressions earlier remember I said
that even though we got short-circuit
evaluation on the expressions you've got
to instantiate the whole fold before you
can do that evaluation and that might
fail to compile we've got the
conjunction disjunction and negation
type traits that are effectively doing a
similar kind of thing of you know
conjunctions and disjunctions or wars
and the gating is just probably negation
as a very attic pack expansion but these
are written in such a way that we have a
lazy evaluation of the template
expansion so if if I can compute the
result and determine this what we know
within the and or an or after expanding
the first two or three
that I've got the result I no longer
need to expand the whole parameter pack
in case any of those expressions might
in turn fail to instantiate so this is a
safer way in generic code potentially of
working with the same kind of ideas but
it's also going down your template
recursion depth and the way a fold
expression might not so different
trade-offs one of the embarrassing
things in the C++ 14 library is we've
got all these type traits that all these
sorry functions in the standard library
that have no except operators that would
be importantly querying is your swap
operations no except this was not at all
a problem for the standard library to
implement any men that we wanted your
swap Robbery you and your swap functions
to be able to decorate your swap
functions and accordingly
but the kids were relying on your doing
in the ADL look upon your swap you can't
do any IDL look up in a no accept
operation because there's no name
looking there's no way to get the using
STD namespace STD in there in the first
place now the standard libraries written
in namespace STD it never saw the
problem so it turns out it's actually
really important to be able to have a
query not so much Lee is swappable trait
which is handy but it is no throw
swappable is something that users could
not write to put in there except there
no except specifications on their
functions so we finally added those to
the standard library and it's callable
is our missing invoke related trait
invoke is this funky language we have in
the standard when we're trying to invoke
or call an arbitrary function like thing
so it could be a function it could be a
functor it could be appointed to member
function it could be a reference to one
of these things there's a whole variety
of these things but if I can pass a
comma-separated list of things between
the pair of parens and it's going to go
off and invoke and call some code this
is the set of rules to follow
so we're exposing that says a function
that follows that set of rules that they
say it's more general than just calling
the function operator because it handles
pointer to member functions and so forth
for you as he is callable function it
has unique
yet representations I missed the s for a
long time simply says that all the bits
used in this object representation are
part of the value there's no padding bit
which means if I have something that has
this trait I can therefore use things
like mem camp in order to test if two
things have the same value so when
dealing with a large range of these
things I can transform to usually much
more optimized low level algorithms and
finally we've got a new transformation
trait alias called void T this is a very
handy trick built around this for doing
compile time introspection to say you
know do you have this particular member
and therefore create this thing I
constraint around that so if what I'm
saying there make sense to you go off
and look this up it's fantastic and if
what I'm saying makes no sense then you
do not need this it's a good corner that
solves a really awkward syntax problem
in the library or in libraries in
general I'm assuming everyone in the
room knows what I mean when I say spin I
if you don't I'm sorry these like last
few slides probably not going to make a
lot of sense but we had a problem in C++
14 that's vinay or people use the result
of type trait it would drag them
dropping into a context where we would
really need it to say well if I don't
have that overloaded I want to go and
pick another one it had to drop out of
resolution correspondingly but there was
no primary definition of the result of
type trades so code would fail to
compile as a heart failure in the wrong
places
so we require the result of trait to be
an empty class if it's a if it's not
going to be defined appropriately a
primary we basically give a primary
definition to the primary template and
we've done the same thing now for
iterative traits in common type so these
can also be used safely in code that
would be wanting to query these things
in swing I like context smart pointers
because we all love to keep working on
our smart pointers there were some holes
found in the kind of conversions that
you would do with a unique pointer to an
array
that might end up being you know losing
the fact it was a unique pointer to an
array and calling the wrong the weeks
and so forth
you had to jump through some hoops to
get into those holes but we found those
holes and we closed them shared pointer
of array of unknown band was supposed to
be added to the CD along with which is a
shared pointer analog of the unique
pointer functionality this was imported
from the library fundamentals TS and by
the time we were doing that it turns out
we'd also rate already made quite a
bunch of changes to shared pointer so
the project editor didn't have an easy
way to do the merge and then we've
accidentally forgot about that
so that is intended to be landed in the
c++ 17 that we publish next year but
it's not in the current document that
went out of a ballot standard own or
less with a funky diamond c++ 14 we have
all these diamonds functors that's a
cute way of having the function call
operator of that class template be a
deducing thing more like a polymorphic
lambda where all the DC arguments of
both types and then apply the operator
accordingly so we found another standard
library functor that didn't have this
particular tweak will be added in c++ 14
we've done it there
Rhian abling heared from this is
something i would really not like to
talk about because this is just evil and
should never happen anyway but if you're
in that crazy round where you want to
have multiple shared pointer owner
groups so I've got a shared pointer over
here that thinks it owns pointer X and a
shared pointer Y over here that thinks
it owns pointer X but they have
different control blocks because they've
got different de litres that are going
to do different things typically one of
them is going to delete and destroy X
whereas one might just be calling a
function with it that's going to assume
it lives beyond that so a don't be doing
this but if you did that and the x you
were using use the shared from this
mechanism you quickly fell into
undefined behavior so we've defined how
these shared from this is rebind when
you construct these objects and found
the corners of undefined behavior and
ruled it out so this crazy thing you
shouldn't be doing
is mildly less scary because we've
defined what it does and I'm not sure
that was a good thing but yeah it when
you start going in poking in dark
corners of the standard library is
surprising somebody's already been there
and cleaned them out for you in advance
and finally shared point a weak type
just so we can get the the weak pointer
analog of the current shared pointer I'm
looking at if I don't actually have
immediate access to the the type
parameters allocators in C++ seventeen
that's subject near and dear to my heart
we've got a new trait to simplify our
use of we can specify a lot of the
accepted specifications dealing with
alligators so standard alligator it's a
stateless alligator so any two
alligators of this type are always going
to compare equal they can always enter
interchange memory but there's a lot of
code that is required to query that at
runtime in order to figure out if I can
swap or so forth which meant that lots
of code that should have good clear
exception specifications that say I know
this thing can't throw couldn't do so
because it couldn't heck which is a
compile-time property so we now have the
is always equal trait that defaults to
I've got an empty type it's a state a
stateless alligator probably is always
going to compare equal to it to other
alkyds of that same type and that lets
us give much better exception safety
guarantees and especially exception
specifications throughout the standard
library the other thing we've done is
we've incorporated the polymorphic
memory resources from the library
fundamentals TS room which i've got even
more detail on the next slide so I'm
probably just going to jump straight
through behind there is standard PMR
memory resource is an abstract class
it's not fast template it's a straight
class that won't get when you implement
the derived classes they just give you
memory of appropriate sizes so we're
taking the type out of the allocation
framework and by making it a base class
that does the allocation through virtual
functions you can now pick your
allocation strategy essentially at
runtime so we provide a few standard
resources so there's a diff
memory resource because the memory
resource you will use unless you request
a specific ones through this API the new
delete resource which just delegates
everything down to operate a new
operator delete which is the default
behavior for the default resource and
the handy the ever handy null memory
resource that always throws whenever you
try to allocate it could never allocate
which is a hand you want to have the end
of a chain of our resource adapters
adapting different strategies and again
we put three actual useful strategies in
there the monotonic mapper resource is a
resource that basically you give it a
buffer and it will just allocate memory
from it as it goes it never reclaims the
memory the the delete function just says
yeah thanks thanks for sharing and then
if you exhaust that buffer it will
dynamically allocate through an app as
additional allocating allocate resource
you supply when you construct it or the
default if you don't a buffer twice the
length and then continue allocating
through there simple strategy very handy
for try to say I want a small buffer on
the stack so I'll create a small stack
object there allocate out of that and
hopefully never need to go out to the
heap for memory the synchronizing
unsynchronized pool resources are more
familiar strategy where we're going to
bucket things based upon the size of the
allocation when I have the allocation
back I'm going to keep that in my bucket
and therefore I've got a free list of
allocations of the appropriate size but
this does mean because I've got separate
pools now with different resources I can
have more localized pools for different
memory subsystems within my overall
system and that has a surprisingly good
effect on cache locality of these days
then we have the resource of web memory
resource working aware of those
containers so p.m. are polymorphic
allocator of T is the allocator that
works with allocated traits that wraps
all those memory resources then within
each container header we have a new
container alias that it simply now is
for the existing container using the
polymorphic allocator rather than
standard allocator so SDM our containers
allows the versions that can use these
type of racing alligators quite quite
efficiently
throughout the system other changes for
containers
we've got non data member sorry non
never functions versions of data empty
and size that they're coming across a
few of the containers where are my on
slides I have five minutes to do seven
slides I'm going to have to really
accelerate that so game
we have minimal incomplete type support
for for word list list and vector which
basically means up with a recursive data
structure like a struct X it's got a
data member that's a list of X while I'm
passing X X is an incomplete type so if
I've got a list of X I've got a list of
an incomplete type but as long as those
operations when I call them or
instantiate them see a complete type
we're going to be good and it turns out
all the existing implementations of
standard libraries could support this
guarantee for those three containers
when you start getting into the more
node based containers not all of them
could give that guarantee today so we
didn't want to go further than we knew
we could guarantee another minor change
the sequence containers have in place
front init and place back containers
functions they're great I've just
constructed something where'd it go so
they return rather than void like they
used to return in C++ 14 and C++ 17 they
will directly return a reference to the
thing they've just constructed because
they have that reference handing out
standing around anyway
for associative containers ah ignore the
last bullet because it's on the next
slide so we've now got the default order
quite lookup type trait the epitome says
this is the way I want you to order my
type by default and we can drop that in
where the default is call standard less
which we'll call the operator less than
so by dropping this in we've got a
customization point so that if I want to
customize my type say I've got a complex
number type I do not want to define the
less than operator for this type nor do
I want to abuse the standard less
functor that is supposed to be the
function like an analogue of calling
operator less but I do want to be able
to store my type in sets and skeezer
maps because I can define an arbitrary
ordering that's good for my type it's
not the mathematical ordering
default order gives us a customisation
that will do that while being 100% a bi
compatible with existing code because
it's a lookup through a typed rate for a
default template parameter it produces
exactly the same tack for all the
existing code when it comes to trying to
insert things into unique key maps or
unordered Maps we've got the problem
that if the things already there the
inserts going to fail and how do we deal
with that there's different
optimizations you can do container side
to make these current you know try and
try them place this or insert or if it's
already there assigned to it much more
efficient than trying to live in purely
outside the container so we've added
those methods funky thing about splicing
is extracting a node from a container so
the other is I'm going to I've got a
node that's been allocated by my
container that holds whatever element I
can extract that node out of the
container then either splice it into a
different container because it will just
sort correctly without having to do
another allocation or I can perhaps
fiddle with the key which is where I was
talking about standard launder earlier
you occasionally hit these strange
corners where you want to do funky
things just outside the strict rules of
the type system case your family on the
key and then try and insert it back into
the same container okay I don't want to
allocating it will now go just to the
right place one of the problems it does
solve is that with a set of unique
pointers in C++ 11 and onwards we've
never been able to actually take
elements back out of the set I mean I
can erase the element that's in the set
but I've not be able to move the unique
pointer out because I only ever had
access to a constitute or effectively or
alliterated with constant access so
that's another thing that this extract
interface will letters do finally we've
got these funky a bit too small to read
on the slide hopefully you'll be able to
see them more clearly when the slides
are published a bunch of algorithms for
working over an initialized memory to do
a construct in place or destroy in place
or a move in place when we have a small
subset of uninitialized algorithms that
have been sitting there since C++ 98
there was a real desire from the
on the gaming community and other high
performance low-level winery managers
that want them really to enrich its
facility to encompass all the behavior
so we that has finally been broadened in
C++ 17 small library editions invoke a
callable thing with a bunch of argument
as const is just a simple it'll give me
a const reference to the thing
so all those widely functions like c
begin CN that we've done all these
different overloads i could just call as
const and then begin it's just a more
general thing rather than having to
create lots of separate named functions
all over the place one that just gets us
to the right place
clamp is the classic i've got a minimum
in the maximum and I want my value to be
bound within that range the generalize
negator not fun I mentioned earlier I'm
already 15 seconds over con sexpert is
more broadly spread throughout the whole
standard library in the list of places
there and final library cleanups
reference wrapper is now guaranteed to
have a trivial copy constructor and copy
assignment it doesn't have an assignment
operator for the chrono types we now
support abs sealed floor and round and
finally we're reserving for the future
all namespaces that start STD followed
by a sequence of digits we are looking
probably not for C++ 20 but hopefully
not much beyond that to have a new
standard library namespace that we're
going to want to start populating with a
more consistent standard library built
up from the kind of features we've been
talking about today so you're on notice
we're reserving those all of those
namespaces for future use thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>