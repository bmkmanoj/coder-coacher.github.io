<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Zach Laine &quot;Writing Great Libraries: 89 Easy Steps&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Zach Laine &quot;Writing Great Libraries: 89 Easy Steps&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Zach Laine &quot;Writing Great Libraries: 89 Easy Steps&quot;</b></h2><h5 class="post__date">2015-10-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hcHUZE6buzE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this talk has the slightly snarky
subtitle 89 easy steps and I've had some
people actually ask me how many real
steps there are there's not a particular
number of steps the point is that
writing libraries is hard and there's a
lot to cover these are at least talks
with one hour so I Jam kinda lot of
stuff into this one hour so if you have
a question that you think really clarify
something feel free to jump in at any
time but if you can't kind of minimize
your questions because there's there's a
lot to go through especially in the
second office okay so things are going
to cover first of all why we write
libraries at all what's what's the point
efficiency concerns usability concerns
and then last I've got sort of a grab
bag of useful implementation tips for
writing libraries so first motivation
what is the principle that governs what
we need to think about know relating
writing library the reason we write
libraries is at coast court Toby
October use write so there is no other
reason right you've got Cody right every
day some of it is meant to be reused and
hopefully that's library code and some
of it is one-time use or very custom and
it's not suitable for use and that's
your application to so this is gonna
underpin everything that I tell you in
this talk we're trying to achieve this
good reuse okay so what is the main
difference between the two we've got a
library code and application code and we
don't know the requirements for our
library code rewrite it we don't know
what the user is going to be needing
this library for because we haven't met
them yet okay and sometimes you don't
have a very good grasp on what you need
for your application requirements here
but to the extent that you know them you
know them less for library well usually
a lot less so as an example let's say
I've done my application I've got this
button type and for the button I have a
click handler okay so whenever you click
the button right I get this function as
a callback and how much time do I have
to do something in this function does
anybody have a guest and you shout out a
hundred milliseconds good answer 100
milliseconds what I said too because
usually like if you have around 100
millisecond response time for that No
you notice right the user cannot detect
that lag in feedback what if I have an
arbitrary function called foo in my
library how much time do I there I don't
know right and nobody knows so the point
is that I don't know if someone who
calls this is going to call it inside of
a hot loop where they have like you know
a few nanoseconds is the overhead that
they're allowed I don't know if they've
got a hundred milliseconds or somewhere
in between or something else no idea so
we need to make our library as usable as
possible for anyone that might want to
use it and the end no more part is
important okay it's easy to get carried
away with this I'll get into that a
little bit but this implies that we need
to care about efficiency because this is
C++ people care about efficiency but
moreover we need to make it maximally
efficient because we don't know the use
case we don't know when that person's
can be calling that function how it's
gonna be used what the time budget is
and for the same reason we needed to be
maximally reusable we need to be
composable with other things we're doing
and reusable just in a functional sense
okay any time you write code there's two
audiences you have to care about there's
the compiler so the compiler can reason
about and compile your code is correct
and you also care about the the reader
of that code so when you're writing an
application especially that's playing
demo where some kind of throw where you
think you just write at once and you
throw the way you don't care about the
user being able reason about the code
when you write library code you really
care a lot about that end user right and
it might be you in six months or someone
on your team or it might be a complete
stranger okay so as far as motivation
does one of we wouldn't be covered here
we care about libraries for cookies and
these are two corollaries we care about
maximum efficiency and maximum
disability because of the primary
principle principle zero okay so
efficiency everybody in this room is a
C++ programmer or something like that
and we all know lots of guidelines we
can see possible sufficient right so you
make it moves know except you minimize
copies you minimize resource allocations
there's lots of things like this but
these are all implementation guidelines
and what we need to do is lift those
implementation guidelines into guide
for how to make interfaces I wish I had
some really concrete silver bullet type
guidelines for this part I don't so
we're gonna look at an example since we
don't know the usage context this is
gonna be very ad hoc process right it
depends on the specifics of your library
and its interfaces okay so a way to get
a sequence of things to have an API this
is a bad implementation or bad interface
rather I've got a struck Dex I've got a
function dum X's that tells me how many
I have available from that interface and
then I have a function that gets one X
at a time by the index okay and if you
give me an out of bounds index I'm going
to give you a null for that pointer tax
so this is how I use it I just get the
number of X's on the stack I loop over
them because I've chosen to write this
into this loop where I'm consuming only
the number of X's that I know I already
have then I don't have to check that
it's an all when I get it back and I
just use each one as I can okay so the
implications of this are that inside the
library code you have to check that the
I that you're given to get X is in
balance right you might have to check on
both sides or just one side of the range
depending on how you write it but you're
gonna have order in branches they're not
strictly necessary in the receiving code
and the client code you have to check
that the X you get back is not null if
you don't use it as something like that
loop in the general case if we're given
it in index I you don't know if it's
gonna return at all or not at one place
in the code or it's very hard to reason
about that so you have to do the checks
there too
you've also got order n function calls
which is a lot more than I would like
so we want to take the same thing we
want to minimize the number branches and
minimizes BER function calls
so a/c way of doing this would be that
you get the number of X's and then you
give it an array that has that many roof
that many pointers in it and then it
fills in the array with pointers to all
the XS that it has here's how you use it
you just take the number of X's and then
because of C++ you type with that the
vector and you resize the vector B that
size then you call get X as one time and
then you loop over all the X's and use
each one so this is better because we
only need to call to function to API
functions right so that's a lot less and
lower inflation
before and there's no more per element
branches inside the implementation so
that's definitely an improvement but we
still need to allocate memory to use
this and if we just wanted to look at
the elements that's really not
appropriate right we don't force someone
to do memory allocations just to get a
look at what's in the what's behind the
API okay and in this case we happen to
have a function that tells us the number
of exits but what if the way we're
getting these X's is that they're coming
over a wire or they're coming from a
terminal we don't know the exact number
of them so again it's it's a limited by
that so a better way to do this would be
to construct a lazy range
okay I've called this one X range as you
can see it's just got a type def for the
iterator of the underlying storage that
it that it's you know that it delimits a
range of and then it's got a first and
last member and that's it I just defined
a public member of sorry public function
free function rather begin and end for
getting the first and last numbers and
then get X just returns from these X
rapist and then here's how I use it I
just say give me the range and now I'm
going to loop over the range and the
range miss Portland right very simple if
I decide that I do want to copy the
elements out I can still do that too
just by copying the sequence like you
see down here at the bottom okay so
that's a very straightforward way to do
it and has the nice property that it
handles on bounded sequence as long as
you change that interrater category
right where that was a random access
iterator but if I change those two input
iterators then I could have some
something coming into a file or
something coming in started a stream or
something coming in from wire okay so
you need your guide to be efficient
they're all reasonably foreseeable usage
scenarios and I mean reasonable okay
don't don't go crazy this is something
you're gonna hear me say over and over
again you want your interfaces to be
maximally reusable and maximally
efficient as I keep saying but there is
an easy way to go off the rails with
this stuff so you have to use some
judicious you know amount of inclusion
exclusion of what goes in your guys so
to get to that point as far as
efficiency goes keep saying like what if
I call the API like this what
call it like that okay and there's gonna
be some point at which you say well what
if someone you know someone could do it
this way but think about like in terms
of use cases like realistically someone
gonna want to use it that way and if not
then that's not a real use case and
don't worry about it don't don't say
that like I need the day to be
accessible in every possible permutation
of access because it's just not
realistic come up with a concrete use
cases for what works and then make sure
every one of those is max lifted
maximally envisioned okay so in other
words don't get crazy with that okay so
usability I'm not going to dwell too
much on efficiency because I feel like
as a community we have a really good
handle on efficiency and I feel like we
don't have a very good handle on
usability so that's what most of the
talk is going to be span now so this is
a hopefully a non-controversial thing to
say that names are important but I want
people to think that you know what
usually hears don't don't use
unintuitive names but I want to take it
a step further and say I want your names
to be obvious so getting things from the
sequence or selecting things from a-z
because you've gotten in this case I've
got a struct X with a value member if
I've got a bunch of X's on the stack and
I've got another vector of X's I'm gonna
select from the other range of X's
called this filter function okay filter
is not do anything crazy it does kind of
what you expect you take a beginning in
iterator and it just stuff stuff into
the selected X's via the back of the
server and has a predicate to tell you
when you do something but my question
for you is what is this something does
it filter and reduce and filter out if
you come through the functional world
you expect this to you're looking at me
I see because you expect it to filter in
and everybody that comes to the
functional world expects that filter in
the problem is that I've worked at a
place where we had multiple filter
functions some of which filtered and
some of which filter that you said to
know which ones which and if someone
doesn't come with a functional world
they might think well a filter like
filters out grip out of your water line
so this is probably filtering out right
so the impedance mismatch you get from
people with different backgrounds means
that this is not an obvious enough name
instead what if I call the copy of which
is what the standard algorithm is called
that does this now it copies if the
predicate is true there's no way for me
to misunderstand this right
besides being tragically under you know
behind on my sleep right screen like
unless you have a complete brain fart
you know you're gonna understand what
this does everyone here is comfortable
this name okay so again don't just try
to go for intuitive names whatever that
means I want the names to be obvious I
want to be like there's no way I can
misunderstand what this thing does the
name describes what it does completely
and when I make a guess of what I think
the implementation is my guess is gonna
be right because the mean goes well
shows up okay the principle Lee surprise
is another ones question later people so
don't make your interfaces do crazy
things that no one's gonna guess so for
example if I've got this register
function right it takes a pointer to X
if I knew an X on the stack and then I
call register X I feel like I'm using
the API right maybe it doesn't have API
document me to see the name of this
function and I see that I need to
register stuff and would proceed to use
X after this but then when I get a crash
I look at the implementation of that
register and I realized that this is
actually you should have been called
consume or something but someone named
it register instead right how was I
supposed to know that like I'm not
psychic right and the name is very
misleading names are important and
really I think that in many cases the
principally surprise is just a
permutation of names are important so
make your interfaces impossible to use
incorrectly whenever that's possible and
if you can't make them impossible use
correctly make them very difficult to
use it correctly impossible to use
incorrectly shows that okay so what
happens when we try to restrict the
number of X's in that example before
like the bad interface for getting
access right we get the number of X's we
have some code that new tastes that
number and then we loop over
the exes that we want to look at well if
I write that code that mutates the num
variable such that num exceeds the
number of X's then I get undefined
behavior hopefully I get a crash but
maybe I just get an undetected bug from
ones that have to do with down the road
okay so if we use that range based
approach this talking about before not
only is it I'm arguably more efficient
but also is is disallowing direct
indexing into that range in most cases
so in the example I showed you those
were public data members you'd make them
private data members that you don't have
people indexing into that okay
alternatively if those were input
iterators it wouldn't matter that they
were public because again you can index
with an imitator either so you give up
some you give them some flexibility
because you can't do something like give
me from the third to the eighth element
of this range right that flexibility has
gone if he can index into it but many of
the sequence operations that you're
going to do are going to operate on the
whole sequence that's just the nature of
many use cases for sequences if that is
the case make it impossible to index
into the sequence because you obviate a
whole class of errors that you can
otherwise be horrible to all right said
that okay another one is avoid aliasing
so that means don't use pointers and
references in your API is because that
allows you to alias values and those
interfaces so that confuses you when
you're implementing the confusion of
users who are using the API and it
confuses the compiler to the compiler
generates worse code when you do that so
here's an example is a pretty classic
example of a wrong implementation of an
XOR swap does anyone know why this is
wrong anyone if a and B are the same the
first statement zeros a map okay pour it
out it's the same thing so if I pass in
a and B but they're the same object
instead of swapping with itself and
becoming a no objects a zero is that
thing out so as I told someone before if
you really don't care about precision
zero is pretty close to everything at
the Max and range right so that's that's
the only condition under which this is
correct so this is a possible
implementation
fix right so if I know that these are
different objects then I can just only
do the operations when I know that
they're different objects so this is bad
because we've got an extra branch and
what should be a very simple
straight-line highly efficient a little
bit of code and I don't want to have to
think about identity this is it's almost
more important to me right I don't care
that these guys point to the same place
in memory I care that they're the same
value that's that's the thing I want to
reason about in the code having to
reason about lifetime and who's who is
taking away from what the program
actually does is make you think about
stuff you don't need to think about
complicating your life so how about this
implication now we copy out the
references we're given onto the stack we
do our operations and then we copy them
back out okay so this is better it is
correct but this is also good too and if
I just copy them in by value in the copy
amount by value it's a pure function
it's still simple straight-line code and
it turns out well believe it or not I
used clang three something to generate
code for all these and this actually
generates the tightest code don't use
tener for this if you want to generate a
code that's not gonna happen
the step air version of it generate
almost twice as much code as any other
implementation so you know the bottom
line here is that you should avoid
references and pointers in your
interfaces because they make it harder
for you to write a correct
implementation and they makes it harder
for your users to understand the right
way to use your interface sometimes
references around Loyola I'm not saying
anybody should ask them a large object
by value and not ask you to make ostrov
that's that's not on the table but if
you're doing small values like I just
showed you the convenience of right of a
swap where it does references might
actually be a customization and you need
to look at the code that your compiler
generates to determine if the references
are a win or a loss like when I first
did this I did it with in terms of
two pair and I thought okay well that's
easy right and then I looked at the code
that it generated I was like this is
terrible so you got to look okay
another example if you have a base class
and has struck test drive from base
let's say you have some index a notion
of index for base and not every base has
an index so the the API author decided
that they were going to return this
index unsigned debt as a pointer because
it's knowable you could say like well if
there's no such index that I returned
off and then there's a convenience
function new S with index that
dynamically allocates an S calls get
index and returns both of those things
to you okay if I'm gonna use new s with
index and this is all I know I just see
this stuff then I immediately have some
questions about what it's doing and when
it's safe to use and how best to use it
so if I just think of a simplest
implementation this is what comes to
mind right I just knew an S and then I
called get index with that within us
okay doesn't get indexed throw I mean it
returns a pointer and so it's gonna
return a null in cases where there's no
such index but in the general case I
can't just say like well I can't depend
on the fact that doesn't throw the C++
does any line of code you have to
suspect him I throw it some way okay so
given that if the answer to that is yes
then does that mean that the whole thing
throws does numb s with index throw okay
if it does it's gonna leak that s right
there's no there's no cleanup for that s
it just gets leaked so if it doesn't do
that if it swallows or capture some
exceptions is a swallowing mixed up just
the past throw through I need to know
these kinds of things right so here's an
alternative limitation I didn't change
the pointer from get index but I did
change the new s with index to return an
S by value it could also return one by
unique right those are kind of
equivalent as far as I'm concerned in
this case because what I get is
something that I no longer after we have
to think about and understand how it
works I know the semantics of it by
looking at the interface so the question
of the first one is I don't care because
if get index throws everything gets
cleaned up and then whatever get index
throw
you as s with index can pasture the same
thing like someone could have made it
swallow exceptions or do something crazy
but it's unreasonable to expect that
right the way I'm expecting the code to
work is the most natural way for that
author to have written it it's very
obvious from the implementation so you
know I don't care about these three
questions anymore and as for the pointer
forget index don't use pointers to
express null ability youth there's boost
optional you could pick a sentinel value
if it's something like it you entered it
you could have changed that you went to
an int and a negative value is you know
the range of central values something
like that because when I have the
pointer and I have you know I get the
pointer which tells me the index and
then I have a bunch of operations and I
want to I want to use that index again
if I didn't do reference that pointer up
here before I've made those to be
function calls now I have to think like
did that change out from under me
because of one of those function calls
or did it not I'm thinking about life
time and think about identity and
thinking about address is a memory when
I should be thinking about what the
program does which is always in terms of
value not in terms of pointers and
pointer tasty okay okay so as another
guideline just keep raw and cherry
pointers out of your interfaces whenever
you can help it they make your code
harder to reason about when you have Ron
shared pointers they are a form of
shared state this is the world
equivalent of using global data in your
program okay so if I have a global data
member or sort of global variable if
I've got three or four references to it
you know you've got the problem that
references to it grow over time and that
becomes a problem and it's just harder
the reason about even in among those
three or four references right so I've
got the the the consideration that one
of those other three or four references
might have changed the value out from
under me at some point during my one of
those one of those scopes okay so again
don't we don't want to think about
lifetimes of objects we want to think
about what they do because that's what
the program does okay so we covered
these four things that names are
important that there's this principal
least surprise we don't want to violate
though we should make our interfaces
impossible or if necessary
difficult to use and avoid alias but
there's a common element of always and
in fact I would say that they're all
saying the same thing which is that your
code must be easy to reason about I
don't actually consider these four
different pieces of advice it's sort of
different ways of saying a small part of
the major piece of advice just one piece
of advice your code needs to be easy to
reason about these are four different
ways in which you can make your code
easier or harder to reason about but
it's the same piece of advice all right
so composability I put in its own
section because I think it's very
important but it's just an aspect of
usability okay so this is this is kind
of more of the same issues so I'm gonna
put some blanket assertions up here and
hopefully I will justify some or all of
them and hopefully some of them will
just be obvious once you have stayed in
the way I'm going to so first I think
type should be regular regular means
that something is default constructible
it's copyable it's assignable it's
movable it's destructible and it's
equality comparable if I don't have a
quality comparable this is something
called semi-regular which you'll see in
a second it's also very useful copy an
assignment though must not create
aliases so shared footer has all of this
it is not regular because when you copy
a schertler you now have two references
to the same data they do not have
independent state even across copies
okay like I said some here we go is
often very useful too if you have all
the rest of these you can't compare them
for equality that gets me most of what
makes regular useful okay and here is
what makes regular useful think of
regular is like a number right numbers
are easier to reason about the C++ API
is okay they just are or you want to
think about the world in terms of
mathematical formulae when you can and
when you can't deal with deal with
classes and so forth okay moreover think
about regular is like a banana okay with
the exception of copy it's you can all
these properties apply to bananas okay
so I heard someone say something very
insightful during a talk one time he
said you know people people worry about
the move from state of an object this is
this is a big topic and C++ in Lebanon
later if I move this remote over here
what happens to that well there is
this is the remote like I'm not looking
for the banana or if this is the same
banana the banana it's just a banana
there's not more than one reference to
it it's a banana ok so if you can think
about the world in this very simple way
of like actual objects that live in your
code I'm not talking about object
orientation talking about the entities
in your code are real things in the real
world if you can get the lifetime
semantics out of your thinking you will
make more code that is more extensible
more maintainable faster ok and of
course bananas are these are is about
even the numbers ok
so functions should be pure that means
that they depend only on their inputs
they do not mutate their inputs and they
have no other side effects
ok retain their butts obviously a kind
of side effect so remember XOR swap
right we have a lot of trouble getting
to a good implementation of it when we
started from the point of view that we
were gonna make a function of mutate
since it's our chance so when you see
this function call what is an issue that
comes up you get shattered out anybody
order an evaluation right so we've got
two function calls in the same
expression which one happens first is an
issue unless they're pure then I don't
care
again we're not thinking about addresses
anymore we're thinking about what the
program does when we write it like this
we don't have to think about like maybe
who does some crazy increment and then a
test and so I don't know if the two
increments happen in which order they
happen in especially in case of inlining
and stuff so just get rid of all these
things just make these functions pure ok
type should define a basis so a basis is
a set of member functions which is the
minimal set of member functions that you
need to maintain the invariance of your
type ok so that means you don't include
anything else that is a function of the
basis or that it's outside of the basis
ok as an example this why don't we have
vector sort why isn't anything right
it's Dom is walking right we wait
hopefully we don't do a lot of dumb
things as a standard library convention
so we have stood sort which
in terms of vector or spit array and it
makes no difference which one you use
right that's because we have standard
algorithms here at da in terms of the
five iterative categories you have at
most five implementations of any
standard algorithm and you can have an
infinite number or simply unbounded
number of container types and they all
have some iterative categories to
develop in the standard algorithms okay
so we don't want to have a different
sort for each container and so that
indicates to us that we shouldn't be
adding things like sort that are
extraneous to the basis of the type
itself okay we define stood sort in
terms of subsets of the basis which is
just begin and end on the containers we
want to sort so again you should not add
things that are there extraneous to the
basis and when you when you employ that
discipline you're able to pull things
out and generalize in a way that you
wouldn't that wouldn't occur to you
before so if instead of having stood
sort I had stood array sort and state
vector sort I would implement each one
in terms of the guts of that type and
then that code would not be reusable
across those two if I say I'm only going
to do stood sort in terms of those other
two API sometimes the beginning end of
those things now I have to suddenly
write code that is truly general-purpose
it could be used for both cases and that
doesn't apply this just containers and
sorting this compliant this applies to
any two types that you've got that you
want to do a common operation on right
you will find a ways of generalizing and
writing generic code and being more
productive if you if you enforce this
discipline okay so if you want to see a
counter example that you can look at
stood a string which doesn't famously
fat interface which does the you know
the kitchen sink is in this thing right
recently stood array view was proposed I
think it's in the library fundamentals
TS and you know what the idea is you can
pass in a constant R star to this or a
stood string and then it has the
interface of strings so you don't have
to actually copy anything or have double
overloads for you know efficiency and
using a constant R star
those cases where you've got one the
problem with it is that it has to
reproduce the entire API it's to string
this giant fatty API right if we have
algorithms on to the string or a
constructs star that operated on strings
of characters we wouldn't need to
reproduce all this API and anyone that
wanted to work a live stream wouldn't
have to do it okay this is an important
one
all right so also container types need
to be operable interoperable with STL
algorithms so that means they need a
beginning and they needed their own the
iterator types so if you need to make a
custom iterator to make this happen for
your type get to know the loose ten
Reiter library because it makes what is
for any proposition making an iterator
type but custom entertain for your
container nearly trivial so here's an
example of the amount of code you need
then this is more or less kind of pasted
over their documentation here's the
amount of code you need to make a fort
traversal iterator okay
so the top part where we're inheriting
from a type that type is just you know
CR TP based iterator facade is what they
call it so you give it the the type of
the the classroom making here you give
it the the type of the underlying node
that you've got and then you tell it
with this for traversal tak tak that
it's a forward iterator and then the
rest of it is kind of boilerplate if you
look near the body we've got increment
equal and dereference those three
functions where all the magic happens
right that's where your actual until
matei she goes so once you know that
this is all the boilerplate you need
then you just do those three implement
those three everyone those three
functions that do what you actually care
about and all the boilerplate goes away
a lot of the boilerplate you have to do
for a standard iterator is hard to get
right there's some subtleties that you
take it takes some experience to do this
this takes all that idea
pants okay so you also need to make your
types usable range based for loops okay
this is really important okay so let me
back up so the reason I'm saying this is
that I recently had a container that one
of my co-workers wrote that did not do
this and we had to iterate across the
elements based on index
I caught an error in his code that he'd
already written where he was hit a fence
post issue with the iteration that was
causing a bug and then I wrote another
loop that had a similar problem on the
other end the other fence post okay so
making forward arrangements for loops
usable by your code and gets rid of
those kinds of fence post issues again
it's obviating a whole class of errors
that are possible okay okay
and this takes very little effort so
let's say I've got this customer a type
and it's got some story say array or
ever a vector or something so all I have
to do is make these two free functions
that take you know a cost ref to this
array and then return the begin and end
of its storage and that's it now I can
use it down the bottom this real code
that compiles and this custom array I'm
just iterating over it I can teach each
other one at a time
I wrote the arrow deckle type that just
so I didn't even have to know that the
name of the pointed to value underneath
there is our upside that the name of the
the iterator is iterator versus
concentrator I don't care I just want to
write whatever it produces that's what
goes there and the nice thing is see
bustles 14 everything past the arrows
can go away you just remove the arrow
whatever and you just use automatic
return type deduction so this is getting
easier and easier and it's already easy
right now you should do this
alright so library types also need to be
using a container subject if I've got my
type and I want to use your type in it I
better be able to have it as a member
that better be easy to do if I have to
make your thing hanging off the end of a
pointer inside my class even if it's a
unique footer that makes it harder for
me to get my work done if I can't use
your type in a stood vector we got
problems right that's a fundamental data
structure that we use every day all the
time
and so the most controversial part of
the regular concept that I talked about
before is that regular has default
constructible a lot of people grouse
about this being a weakening of
invariance for your types if you've got
a type it can only construct certain
ways and you don't want it to be
billable you don't want to have an empty
state you don't want the default page
character I argue that I care for myself
more about being able to put one in the
stood vector and being able to call
resize with only one element which
requires a default a default constructor
so that's just the way I work and I
really care about that some people
really care about strengthening the
invariance that either one of these is
fine but think about this and consider
that this is an important case for you
know making your types of reusable even
if it weakens be variants okay so
regular a general helps with
composability
a whole lot right if you're able to
treat something as a banana you throw
the banana in the basket you lined up
bananas on the table whatever they just
go over everything you know to go okay
so library types need to be
constructible anywhere that someone
wants to construct on whenever possible
everybody knows about constructs and
stuff on the heap and the stack a lot
people don't really think about making
something with a context or constructor
and they also don't really think about
making something Rama Bowl by making it
you know like brace initializer belen
static static scope right so if it's
static in it but it calls new then
you're not going to be able to stick
that and wrong but if it's something
that just has like you know literal data
types and sits in there that can be
caustics or just wobble and non-cost
you don't one of those things is is very
nice okay if you've got to type the
download stuff from the internet and
it's constructor then this doesn't work
but wherever it's possible to get those
other two use cases you should strive
for that because
again you don't know who's using this
type and what their conditions for users
are going
so error messages are important but one
thing that a lot of people miss when
they're doing anything or involves any
kind of template metaprogramming is that
they're like well you know the compiler
produces the spew of template errors and
what am I going to do right well if that
is the case in your library is going to
be unusable to a certain class of
programmer if you look at boost graph or
lose spirit in both our great libraries
that do what they do very well and if
you make the slightest mistake they
punish and viciously flutter with error
messages okay and so there's lots of
people that I know that are you know
hardcore spirit developers that are like
I make one line change my compiler make
a one line change and I could probably
go on line change my third line because
there's no way I can getting work done
so if something like this is the library
you're gonna be writing you need to come
up with some kind of you know a
convention that communicates errors to
the user in a reasonable way so I wrote
a linear algebra library that had
matrices with static sizes and a bunch
of different types in there and they're
inside the matrices and I couldn't
really find a way to stop you know let's
say you're doing a matrix multiply like
somewhere down in this you know three
deep nested for loop you're going to
have two types and we try to use them
together if that blows up there's no way
for me to sort of catch that from the
outside that that's gonna happen so I
just have to live with this template
ever spewed but what I also did was I
said that I'm going to use a
substitution failure it's not an error
in let's say operator x so that if these
two matrices don't have the same
dimensions that I'm going to say like
that function gets removed from the
overload set and so if you say a times B
and the compiler says there is no any
times B then you know oh well that means
that they're the wrong dimensions of
matrix right if you get this huge mess
then you know oh I made a mistake in the
dimensions of the the units I put inside
okay
that's the next thing I was gonna say so
I also made static concerns at certain
places to catch certain conditions that
I knew were common and then when you go
to that static assert a big fat note
saying like this is why you hit the
static assert right and I feel like
that's a pretty good convention and if
you do any kind of better program you
need to come up with something like this
to communicate problems back to the
users okay I've been saying a lot
so what I want you to take away from all
these shoulds is that you should strive
for it is impossible to use wrong it is
maximally efficient is maximally
composable with other code and then only
compromise on that when you have to and
sometimes you simply have to write so
I'm not saying you should get carried
away and make something like for
instance the example I gave before about
making input iterators rearranges like
if you decide that actually do care
about the indexing into that range don't
make this type with input iterators and
say no one can index into it because I
don't want that kind of error when it
just gets rid of a whole bit of
functional you actually need your live
way for some reason okay so that's it's
another case so don't get carried away
it's not wrong to use non regular types
and if your functions and stuff
sometimes you need to for performance
reasons as I said before they've got a
large object you want to pass it by cost
graph that's not you know there's some
cases at which that means the function
is not pure and and that's probably okay
but again get as close to that as you
can have that ideal thing in your mind
and keep trying to hit back to that and
then only only compromise me you have to
okay so here's the grab bag of library
of annotation tips so one another claim
I'm gonna make is that implementation
design these are synonymous for for
writing programs right you have some way
you think you're going to implement code
and you go to actually implement the
code and it turns out that you've got
this complete impedance mismatch between
unit a unit B they just don't cooperate
with without this other bit of
functionality you didn't didn't realize
you needed until you started
implementing this means that as you go
you need to be using your own code and
refining where there are problems like
this needs to be a constant thing
especially the early stages of
this is iterative you're not gonna get
right in the first pass you're probably
right on the third pass either okay and
writing test as you go really really
helps with this hopefully we're all
testing our code but realistically it
doesn't happen sometimes in some places
the more tests you write the better your
interfaces will get not just the more
correct okay and start with just writing
you know fairly extensive snippets of
what you want the client code to look
like before anything compiles before
you've written a single line of your own
library code and keep referring back to
that and if you can't get the
implementation to match the ease-of-use
that you wrote when you said if I had my
druthers this is what I would write then
again go back and sand off those rough
corners so and you know this is a
process of discovering the right
solution you know I mean you're not
inventing anything new right get very
familiar with lots of other libraries
there are any number of library
development problems and they've all
been solved by somebody somewhere so so
read a lot of the code and if you try
something and it doesn't work if you
refer back to that that example code
you're writing as you go and you find
that something doesn't work the way you
want it to then you need to keep looking
right the reason I say these things this
way is that I find that a lot of people
I work with are like well this works
pretty well and I'm like we need to find
a way to make it perfect and only when
we prove for ourselves that's not
perfect do we settle and if you don't
keep that mindset it's easy to to slip
into something that's that's highly
imperfect so an important metric to this
process is something hopefully everyone
else has heard too that you make simple
things simple and not simple things
straightforward to do okay so the common
case of use you need to be able to write
very succinctly and easily in your
sample that you're there working
that is the target code you want clients
to write and if you find you're drifting
away from that you may be a redesign
okay so it has an example oh there
should be daxpy okay well that says a
lot about bad names so Saxby is actually
a float for the a and not a double but
these are actual functions from like a
blast implementation so light from the
Fortran days there's a standard Blas API
for doing linear algebra and in this
case Saxby means single precision x same
precision a times X plus y that's what
this thing returns okay now Dax B means
double precision a times X plus y okay
so there's a lot of them they're insane
names right so if instead I did operator
star and operator plus and I was able to
write a times X plus y everyone's gonna
know what I'm doing right this is
obvious code everyone gets it you don't
think know what sacs mean Dax baby okay
in order to get back to actually calling
code that looks like sacs beard ax B you
need to use something called expression
templates if you don't know what that is
don't write a linear algebra library but
it's
that's a very that's a very heavy topic
and there was a three-hour talk on it
yesterday the case in my David's ago so
in order to transform this into Saxby
and the reason you want to do that is
because Saxby exists because that is way
more efficient than doing the a times X
by itself and then adding the why doing
it all in one step is way more efficient
so again you want people to write code
like a times x plus y but at the same
time you don't want to give up the
efficiency so there's an important point
here which is that again you want to
refer back to like what do I want my
user code to look like and if I have to
jump through some insane hoops and do a
bunch of gymnastics to make that
efficient then that's just what I have
to buy it off as a library writer right
and compromising and saying no
everything's gonna be called sacks being
back speed is not sufficient okay so
documentation is important to users some
very large libraries have great
documentation and without it they would
be largely useless though if anybody
here is whose spirit but it's this huge
parsing library that does all kinds of
stuff and it's got very extensive
documentation without that documentation
you have no clue what this library does
right there's lots of stuff in there
but aside from that Doc's are very very
important to the implementation and
design process I have found myself so
many times writing documentation that
says the library does this and then
realizing the library doesn't do that
right I have thought that this is what I
want the library to do and when I
actually implement it didn't do that and
then writing the documentation let me
step outside myself and kind of realize
that it's the same phenomenon as Adam if
like people heard of you know explaining
a bug to a teddy bear or whatever you
know it's like you don't need another
person to help you debug it sometimes
you just need to step outside your
normal frame of reference and then you
see things from a different angle
writing documentation does the same
effect it's very very handy okay so you
need to really anticipate future needs
at the beginning of your library design
process when it's things like thread
safety that's very hard to bolt on later
things like versioning are also very
hard to believe there's there's a small
set of things that are in this category
of if we didn't think of it at the
beginning we're kind of stuck but
there's another important aspect is Amit
teachers right so I used to work in a
place where we we did visualization of
sonar data and there was this one little
widget that had like a bunch of bars of
data and then went down the screen it
was like an ear range too far age and
then like direction around the circle
and from you know right to left so in
this view you know we're only rendering
data in that way I describe this is near
that's far it goes right to left the guy
that rode it was like why there's no
reason why it has to be right to left
there's no reason why it has to be near
and far on the bottom of top so he just
rode all four ways and there were like
six levels of inheritance and you know
it was just a big mess and it got to be
such complicated code that is something
relatively simple that he himself could
not fix bugs in it that we found and we
couldn't extend and we end up throwing
it away and we're doing it right and so
there is such a thing as too much
generality there is such a thing as too
much generosity if the direct share
going in is making it generic in a way
that says I want more more features
you're probably on the wrong track if
it's generic in a way that says like
this is the fundamental thing that it
does and I want to make sure that
everyone that does it was slightly
different variation of that can do it
then you're probably on the right track
okay so header only verses compiled this
comes up with some especially open
source projects a lot of people say like
it was not header only I'm never going
to use it because there's too much
trouble to figure out your weird build
system and link to your library and what
life's too short okay and then some
people say I'm never gonna use your
library if it's header only because I'm
not gonna like we compile that every
time because I've got this very tight
loop I compile and debug and I and I in
a code right so you can have both worlds
if you use this this pattern that you'll
just see this a lot of routes libraries
if you want another example but
essentially you've got your header it's
got your interfaces in it and at the end
of your header you say like if I've got
this macro to find this as its header
only then I'm going to include this IPP
file okay that basically has all your
implementation set and then you've got
your food on CPP file which
unfortunately I should have written like
include food on H at the top of this
that makes this make more sense but if
it's not header only if you don't have
that macro defined then you include the
IPP file here and then you add
the CPP file to your build okay and then
the IPP file has the stuff you normally
have a listing can be file except maybe
the pound include of the food on th now
you can do this with food CPP by itself
you don't need the IPP file necessarily
so you can include that at the bottom of
your header file if you want but
something like this is very easy to
accomplish if you just start with it
from the beginning it's no extra work we
tried it later it can be difficult
online things understand how inline
namespaces work so inline namespaces
there's lots of great tutorials online
and I didn't really have the time to go
over this in this talk but suffice it to
say that in my name is basically to take
like I can see that namespace foo and
you've got v1 v2 v3 all these different
versions of your of your library and so
you just say like this one is the latest
one and then everyone just says using
you know everyone says food colon colon
whatever and they get the latest version
of that API entry point but then you can
also have the older versions side by
side with the newer versions in a very
nice way they don't conflict because
they're in different namespaces but as
you migrate different versions you
always have one version that is
considered to be the latest one that
just uses food : all right so like I
said I'm not gonna get into too much
there's lots of great stuff online how
to use it it makes it very easy to
version your library and migrate once
you change versions or for client click
my grades version
ok so generic code all templates have an
implicit concept requirement even if
it's implicit so let's take a look at
this let's say you look in the
documentation you just see like the name
of this function and it doesn't have any
comments it's just this function and
some oxygen comments or something so it
takes an A and a B by value that bolides
the fact that a + b is used inside of it
ok and so I can't pass just any little
thing in there I need two things that I
can add ok so there is a requirement on
virtually any template you write but the
template argument T or whatever argument
has requirements on it for what types or
will fit in that and that that template
parameter if you don't document them
then you're making your code like
impossible to use in some cases and very
hard to unwind these kinds of things
sometimes if you have the concepts
feature to use it all over the place
right in this case this is probably
going to be a concept that comes with a
standard library a library arithmetic
and if you just put arithmetic T on your
sum function then you know all as well
people are gonna know what that is in a
few years but this is a common feature
until then document these things right
if you have a public function in your
library API that people were expecting
to use they need to know what the
requirements are for T of U and all the
other types of grammars you alright so
to boil this down we're writing
libraries for code reuse that's it
that's the beginning in the end of why
we do this ok and because of that we
need them to be maximally efficient and
we need to be maximally reusable in
practice what this means these are the
guidelines that went over the second
half of the talk that means you need to
make your library if you got a easy to
reason about to get the usability part
and that means that you need to name
things in a way that is obvious what the
names do you need to make sure that the
the the functions don't do anything
extremely surprising in addition to
doing what the names say they do they
don't have any crazy side effects you
need to make the interfaces impossible
to use incorrectly wherever that's
possible it's not always possible but at
least make the part using correctly
avoid aliasing type should be regular
function should be pure and type should
define a basis and nothing else all
other things should be free functions
all right also container types should be
interoperable in this dialog rhythms and
use one for range for loops and types we
should be usable and a container of sub
object that someone else writes your
type should be constructible anywhere
don't forget about making things Rama
beware possible or concepts for possible
and error messages can't impede the
easier library you've got a library
nobody can use and finally don't stick
to everyone
these guidelines all the time right like
so the thing I keep saying is that you
want to strive for every one of these
bullet points every time you're making a
decision you're like am i compromising
on any one of these and if the answer is
yes why am i doing that if that's not a
compelling reason don't do it okay
that doesn't mean there aren't
compelling reasons do it in those cases
all right questions so do you have any
suggestion on how to design the folder
structure for an optional a header only
library because when I actually
implement this on libraries that were
optionally eternally it was pretty
annoying to have the global including
source folders as you had to use
absolute include paths to include the
CBP file in the header file whatever
know she had the header only macro and
the something I used was actually at
having like a folder for every module of
the library and that local includin
source folder inside the module folder
if that makes sense so we have any
recommendation how now to design a nice
folder structure I really don't I mean a
lot of people really swear by having a
source breakdown where the occlude has
like the whole tree a lot of people
swear by like you said a module
breakdown we've got a clinton source to
me is six of one half a dozen of another
as long as it builds i really do care
about the layout that lunch whatever the
whatever the layout is all get used to
it i think most people are like that too
so yeah I mean concrete so the question
was how do you migrate to new standards
in C++ essentially when you've got how
long how long do you wait that's that's
a big question I mean essentially you
know where most places work you've got
GCC playing and and Visual Studio if you
do really lots of clock crossbow flower
stuff and you need to make sure they're
all three using whatever future
you want to pick and of course
downstream clients have to be able do
that too so I don't think there's ever a
particularly good or bad time to migrate
as long you're dashing clients or able
to comply all use that code then that's
the time to do it as for using specific
language features I think that you know
the nice thing about simplest is eleven
is the vast majority of language
features that are new are also things
that are you know they're just pure
extensions so if you want to start using
them in some places to model others
that's totally fine then you can just
you know stuff as you go right so the
question was instead of documenting
requirements for template parameters
that constraints on them instead user
named Olaf and so that this sorta
schools have thought of this like one is
using able live and that's great because
it pulls things out of the overload said
and that's one way the muse you can
detect it they've chosen the wrong
instantiation of this template the
downside of that is it's completely
removed that something else might get
picked up if you've got a static assert
that's the other way of doing it which
is that we're gonna let them try to use
that well we could tell you why it's
wrong with a static assert it completely
depends on like like I said you know I
had this convention before where I had
certain things that would catch with a
static assert certain things I would
catch with scene a certain things I
wouldn't and it just depends on on how
you're breaking things down the
important part is you come up with a
good convention that is consistent and
it generates this kind of error for this
kind of thing and that kind of error for
that kind of thing and when a user sees
an error they know immediately where to
start looking for what kind of error it
is so that is a great thing to do but
it's not it's not necessarily the the
only right answer
do you have competitive reasons why I
should
but struck many I agree to behead oh no
no I don't but there are I've seen
people over and over and over
say on line when talking about a
particular boost library or another
library that they're going to use and
I'm going to use I'm never going to use
that cuz its header only I will only use
that up this header only it's just user
taste so if you have lots of users that
care about this make it possible for
those users that care about that care
about header all need to get header only
those you should care about compile only
to get compile that's my site I don't
have a particularly compelling reason
for either one I I personally don't care
but lots of pillars are very strong
about what me to do taking the library
then maybe is not in a good state
currently and getting it into a good
state if you have a lot of colors a lot
of or consuming it beretti
oh no you're kind of stuck that's that's
that's the that's sort of a big problem
so another one of the things when I said
before you note that thing about thread
safe do you think about versioning the
big part about versioning is thinking
about like okay we've got this API entry
point once we publish this and
downstream users are using it we are
very much locked into that we can give
them an alternate API but a lot of it we
can say like we're not going to rewrite
our all our code for this like an
incremental gain that's rather small so
my advice for you is make make api's
that were ever possible or completely
extensible so if that means you do
something that's pessimal like you pass
and destruct that you can add numbers to
or you pass on a handle to something
that has the configuration if there's
some fundamental entry point in your in
your api that that cannot change once
you publish it and then anyone and any
further features that need to happen
need to go fit within that you might
have to do something like that like i
said passing in a handle to a
configuration object to passing this
drug these are pessimists like there's a
well-known things not to do to make
optimal code but for purposes of making
things general purpose and making them
extents
yes to the question of why header only
at least in our case our build
environment is such a the way we use
link time optimization and whole program
optimizations relies on us being
completely header only now there's other
ways of setting up the builds and so
forth to get different optimizations but
that's our reason where some good
libraries to look at um so one of my
favorite libraries in terms of linear
algebra is eigen because it does lots of
very nice stuff so it essentially takes
stuff like how I'm showing you before
like you know the x times a times X plus
y it takes something like that
transforms into something like Saxby and
then it also takes the extra step of
saying if I know that I can that I can
generate vector code for this something
to that instead so it takes stuff from a
very simple to use interface that looks
very easy and doesn't much of insane
gymnastics and produces the right stuff
right and other libraries like if you
look at most of the boost libraries or
very very high quality
some of them do really interesting
things with meta program and they're
just fun to look at but like I don't
know that you're necessarily going to
try to do the same thing in your own
code especially if you're using symbols
or 11 or 14 you don't have to do a lot
of those things anymore especially a 14
you basically don't have to do meta
programming and I understand the case
we're used to but yeah looking at the
boost libraries I mean the first time I
read Boustany I was like why it doesn't
everybody do this why didn't I think of
this myself it seems like impossible
that any should exist and then the
implementation is very simple that's
that's a great sort of aha moment so
anyone else all right I think it's it
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>