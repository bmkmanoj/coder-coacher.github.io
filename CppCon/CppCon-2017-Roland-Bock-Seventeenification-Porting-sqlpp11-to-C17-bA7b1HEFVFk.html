<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Roland Bock “Seventeenification: Porting sqlpp11 to C++17” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Roland Bock “Seventeenification: Porting sqlpp11 to C++17” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Roland Bock “Seventeenification: Porting sqlpp11 to C++17”</b></h2><h5 class="post__date">2017-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bA7b1HEFVFk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Alright, good morning.
- [Audience] Good morning.
- So, nine a.m., and a lot of
people are all already awake.
That's good.
Cool, so just a show of
hands, who is not using C++11,
or at least knows about C++11 already?
Okay.
(laughs)
You know about C++11, alright.
Cool, so pretty much everybody
knows at least C++11.
That's good, because otherwise
you would have a hard time, I guess.
Cool, so, my name is Roland Bock.
I'm a Principal Software
Engineer at PPRO Financial Ltd.
I'm also the author of
this library here, sqlpp11.
And this library is gonna
be the vehicle of this talk.
The use case examples of C++17
are based on this library.
In order to get you
acquainted with the library,
I'll give you a short bit of history.
So when I started to write
C++, it was about 2008.
The first thing that I
had to do, basically,
was interacting with databases.
And at that time, that
meant writing strings
and sending those strings to the database.
It could look like this, maybe,
hopefully not exactly like this.
When I prepared the slides, I deliberately
added three errors in here.
Okay, anybody see more than three?
Just out of curiosity.
Yes.
(mumbled words from audience)
Yes.
(mumbled words from audience)
More than three, alright.
Okay, I think there are
five in there, I'm not sure.
When I gave a test
presentation of this talk,
it was pointed out to me.
When I went through the
slides yesterday evening,
I saw another one, I think.
Just about the point why this is bad,
to have such a string based library.
There's a space missing after the name.
There should be quotes,
you shouldn't use ==,
because that's C++ syntax, that's not sql.
You should probably escape the
whole thing, the name thingy.
Probably, because otherwise
you might have sql injection.
And there is a typo, priority
is not spelled that way.
It's just a stupid collection of stuff,
that happens when you write sql and C++
on a string-based library.
At least it happens to
me all the time, because
I really cannot concentrate
on this kind of nonsense.
Right, I want a compiler
to take care of this.
Then in 2010, I had a first
RFC for the boost mailing list.
That was still C++98, and I
said, &quot;Well, I have this idea
&quot;of an sql library. What
do you think of that?&quot;.
And the boost community,
well, they replied with
yes, there is interest, but also with...
Well, you shouldn't use
vector, you should use rangers.
You should use proto for your DSL,
because proto, that was the
thing at the time technically.
Dave Apraho said,&quot;I don't like
sql, I cannot program sql.
&quot;Write an algebra library,
and then make it such
&quot;that you can transform it to sql.&quot;
And others said, &quot;Well,
no, no, no, no, no.
&quot;That's not the way to do it.
&quot;I don't want to learn a new language,
&quot;I'm pretty confident with
sql, so keep it this way&quot;.
So something was wrong, obviously.
And it took me a bit of time,
and when C++11 came out,
I work on a new thing,
and then three years later presented
what I cal sqlpp11.
And this has now, a
nice interface, I'd say.
You can write code in C++,
that pretty much looks like sql,
so anybody that knows sql can read this.
So here we select two
columns from table foo,
with some condition.
And then the result rows have members
that have appropriate names,
and appropriate titles.
Everything is cool, right?
And this time, the discussion
was completely different.
This time it was, alright,
well you could still use Meta-Pause,
because Meta-Pause was
then the thing of the day,
and you should be pausing strings,
and turn those into your expressions.
Alright, not in my life, but okay.
Otherwise it was, well,
what do you do with prepared statements.
How do you handle a binary transfer,
and multi-row inserts?
And other people asking, &quot;How can I write
&quot;and connect it to my database?&quot;.
So, somebody wanted to use PostCSS,
and I only had connectors
to other libraries,
other databases.
So the discussion was
completely different,
and it seems like I hit a nerve there.
In the following years
I gave a bunch of talks,
about the library.
And, for instance, I
talked about how to reduce
the amount of error messages that you get
from such a library, because
it's heavily templated,
and as a user,
if you're a user of heavy
templated libraries,
then in many cases,
you've got these horrible error messages.
And, I tried to cut those down.
So, that was one talk.
And then, last year I gave a talk,
pretty good talk, about
variants of variadic AND.
The task is, if you have a
bunch of pools at compile time,
and you wanna figure out
if all of them are true,
how do you do that?
And, there are two answers
to that one, is for C++11.
Because you're either a small helper,
that takes a bunch of bools.
And then, you instantiate this helper,
and the first time with bool,
and all these arguments.
And the second time,
with all the arguments
and bool at the end.
And if, and only if, all
the arguments are true,
then these two helpers are the same, okay?
And still the same, you
transfer the result.
That is, as far as I know,
still the fastest way to do it.
But there is an much more
elagent way to do it, right?
And that is with C++17.
There you have fold expressions,
and many can just say, well
I use true as an initial value
and then combine it with end,
with every single of the arguments.
And, if the expression is still true,
then every argument is true, okay?
If you compare that, well, I'm
always going for readability,
even if it's slower to compile.
This talk basically spawned the idea,
I wanna migrate sqlpp11 to C++17.
A bunch of the things
that a learned about,
along the way, are
presented now in this talk.
So, first topic, we'll start off
with a bunch of language
topics, and then afterwards
with a few library topics.
First, is inline variables
and auto non-type template parameters.
In sqlpp11, we have to
deal with names, somehow.
I showed you the example,
also for the generated code for the sql.
You have to deal with names a bit.
There is a necessity to have to
sql a name of a column somewhere,
for instance, or of a table.
These are apparently incoded in these
static constexpr char _literal[].
And there's a problem with those,
because you cannot use them at runtime.
That is very annoying.
They don't count as...
as initialized for the linker.
You can use them at compile time,
for crazy stuff, but you
cannot use them at runtime.
So I had to work around that.
Also, I wanted to have
something that I can use
to make sure that all
these links are unique.
We're coming to that.
The idea was to wrap these into,
into something like this.
A character sequence, just
takes a bunch of characters
as template arguments.
Well, if you want to have
the string representation,
well you can just act
for a character point
that contains these characters.
It seems stupid, but in C++11
you had to do it this way.
Now, how do you construct that?
As I said, you can use
the character sequence
at compile time.
So what you can do, is you can
pass this character sequence
as a reference to a template,
but you also have to pass the length,
because otherwise the template
wouldn't know what to do with it.
And then you can, from there,
build a character sequence.
Using the index sequence on there,
you can specialize them and that,
and just iterate through all of those
and put that into the
character sequence type.
Okay?
By the way, if you have
questions, feel free to ask them,
or otherwise, just wait and
go to the microphone later.
Yes.
- [Man In Audience] You
swap out the entire rate
to a function, a separate function,
and (microphone issues/garbled words)
(microphone issues/garbled words)
- The comment is, I could have made the...
Instead of using a member directly,
I could have a static
function off this type
that returns this.
Then again, I still don't
need to create this type
for other purposes, okay?
It's more code, and these
things are exposed to the user.
So I don't want to have an
additional function in there.
I want to have it as short as possible.
So, in the end, I had something like this.
So, there's char _literal and
then, using for this type.
Now in C++17, the situation has changed,
because well, at least this compiles, so
if you want to do just that
you have a string that you
can define at compile time
and use it at runtime.
That's cool.
This works now, because
we have inline variables
and these are defined in
place, just like that.
So it does what you expect it to do,
there's no surprise at link time.
And static constexpr
variables are, by definition,
always inline.
So, that is neat.
It reduces the boilerplate for this
character sequence class a bit.
And what we also can
do, is we can now pass
variables, or references, or whatever
any long type template
parameters to the template,
without specifying the type.
This is neat, in the sense
that I don't have to
pass the length anymore,
to this template.
So this make character
sequence now just gets
the character array, and
will do something with it.
Behind the scenes, is just
still the same things.
You have a character sequence inpull,
and it's specialized then for
a character array of a
good different length.
You don't get around
that, but then after that,
the same machinery continues to work.
But if you compare this code.
In the first case, you
had to pass the length,
so this duplication feels stupid,
that you have to pass
the size of the literal
and the literal itself.
In C++17, you get rid of that.
That's gone, it's easier to read.
Good.
Another interesting side effect
of C++17 being simpler,
is if you don't have to fight
to get this to work at all,
you can concentrate more on
the beauty of the thing, right?
I had more time on my
hands, to think about it.
Things that should have
been obvious, probably,
in the first place, but I
just didn't have the time
to think about them was:
I can make this character
sequence generation,
an external function, basically.
So in template metaprogramming
terms, an external function.
It's a free function of the struct.
I don't have to have that
inside of the struct.
There's no value of having
the character sequence type
inside of the struct, okay?
So in the end, I just have that.
I find this way more beautiful,
than what I had before.
And that's thanks to C++17.
So we have a nicer code
I think, it's less code.
It's improved compile times,
because I have, in the end, less types,
because before those, they
were imbedded types sometimes,
or tab alleles, at least
Moving on, to the next thing.
Any questions, by the way, for this here?
Okay, cool.
The next part is about nodiscard,
if constexpre and class
template deduction.
Let's start with a
motivating example for this.
In sqlpp11, most of the
things that you can do wrong
are known to the compiler,
and the compiler will tell you about it.
So whenever you forget some column, sorry,
a table in the front, where you have a,
we have columns selected,
the compiler will tell you.
If you're comparing apples and oranges,
the compiler will tell you.
If you have columns with identical names,
the compiler will tell you.
But still, you can do a
few things incorrectly.
Like here, you select
all the columns from t,
with some condition.
And then store that into some variable,
and then later on, after
some other code maybe,
you say, alright, I want to order them.
Then you say s.order_by something.
Now this looks reasonable,
but it does basically nothing.
The thing is, that when you call order_by,
that is a constant member
function, of the select.
It just returns a new statement.
A new statement, that then
contains the order_buy.
So calling this, well,
while it does something
and return something, but in the end
it will, everything will be
erased and result in nothing.
And, especially, s will not be changed.
So you're sql results, will
probably be unexpected.
Right.
So, yes Jason.
- [Jason] Well I may be jumping ahead,
but I'm curious if you
just found in general.
Well, okay, you know, go to the next slide
then answer the question?
I am jumping ahead.
The last question is.
- Alright, alright, cool.
I think you will have to wait,
for a couple of more slides.
Alright.
Cool, so, um.
Before we look at
everything that has changed,
let's first see how it's
currently implemented in C++11.
So you have this order_by function,
and it's a member function of a class,
which is the base class of a statement.
The member function takes
a bunch of expressions.
It has a return type, that depends on
this check_order_by thingy, that basically
returns whether the
expressions are resonable
for order_by, or not.
And this new_statement
thing is a local type alias,
and it will do some stuff,
depending on this condition
and will use this order_by
too, with the expressions
to construct the new_statement, basically.
The details of that are not
really important right now.
And then it will do tag
dispatch, inside of this function
to the implementation of order_by.
Yes?
- [Man In Audience] Just
to check out the syntax,
Is the idea here that if the order_by
is not valid, will it spheney away.
- No, will not spheney away,
you'll see just in a
second, in the overloads,
that something else is happening.
The order_by_impl will then
be called with tag dispatch,
so depending on what check_order_by,
what kind of type that is.
There is a good case, that
case of check_order_by
will be of consistent type,
that will just create a new statement
with the new order_by,
and everything is fine.
And then, in the bad
case, so everything else,
everything that is not consistent,
will return a special
error, indicating type.
If you've seen one of my previous talks,
this thing will internally
contain the static_assert,
which will fire under
normal circumstances.
But if you want to test it, you can test
whether the user will actually
get the static_assert,
that the user should get.
Is that nice, is that easy to read?
I don't know, I really
don't like it, to be honest.
It works just fine, but
there should be better ways.
And if we go to C++17,
well, we can get rid of all the,
of all the horrible tag dispatch.
So in C++17 we have, of
course, all the features
of C++14 as well.
In particular, we have
return type deduction.
We will also have this new feature,
that called if constexpr.
Basically, the same check as before,
which you can evaluate to True or False.
The put that into the if constexpr.
And then, in the good case,
we basically do the same as before,
we return a new statement.
In the bad case, we return
something else, right?
That looks funny, but it works.
Why does it work?
Well, because, if constexpr means
that one of the blocks
in the if statement,
so either the good case or the bad case,
will be actually compiled.
And the other one is pretty much ignored.
It has to be syntactically correct,
the compiler will check that for you,
so you cannot write
complete garbage in there.
But, otherwise, the
compiler will ignore it.
So for return type deduction,
either of the branches is gone away.
Which is why we can, seemingly,
return two different return
types, from this function.
So, that I think is pretty neat.
So we get rid of the complete
nonsense of tag dispatch.
It's much more readable,
and if you compare it
to the previous slide, by the way,
this does not contain the
implementations of the functions,
this is just the boilerplate, right?
And it has much more characters.
If you go here, way more white space.
And it includes, actually,
the implementation of
the functions, right?
I mean, they're not very
long, admittedly, but still.
So this is wonderful,
this is life-changing
for anyone who's using
tag dispatch these days.
You.
- [Man In Audience] Why do
you decay the check type?
- Because it's const, and
I have the specialization
for those which are
specialized along const.
I'm sorry, the question was,
why do I decay the check type?
Yes.
- [Man In Audience] (garbled,
unclear questioning)
- Yes. (laughs)
(audience laughing)
Yes, you can.
So, with C++17, you can move
the initialization of the check
into the if, if you want that.
- [Man In Audience] I like that.
- (laughs) Yeah, yeah,
so it's even shorter now.
It doesn't pollute the outer scope, right?
That is also cool.
Alright, moving on.
Then, we have these things here,
these proxy functions make_tuple.
Now, make_tuple does some additional magic
that you may want to rely on.
So, what I'm saying now
is not for every use case,
or, for instance, make_tuple also, I think
resolves in standard reference.
But, what you also can do
is, instead of writing this,
what we would have done in C++11,
you can now use the constructor guides
for class template deduction
And just write this,
because what did work in the
past, with normal functions,
with a compiler, can deduce
the argument types that you pass it.
That didn't work in the
past, so up until 2014,
or C++14, sorry, this didn't work.
But with C++17, this works just fine.
So the compiler can
for many of the standard
types, can argue deduce that,
and figure out the template
parameters for tuple itself.
We can do the same for our own things.
The whole questions of whether
I want to decay this or not,
will go away,
because I can use template,
sorry, class template deduction
for this as well.
In some cases, I have
to help the compiler.
In most of it, or in many cases,
the compiler will just
be able to deduce it
by the constructors that some class has.
In the case of the bad
statement, the last one.
I mentioned before, I have
some specialization for those
and the primary template
is not even defined,
or was not even defined until C++17.
If the primary template
doesn't have any constructor,
then the compiler won't be
able to deduce anything,
regardless of what kind
of specialization you have
and what kind of constructors those have.
That doesn't matter.
You have to have compiler
guides in the primary template,
or associated with the primary template.
In this case, well bad_statement
as the primary template,
is something that contains
the static_assert,
that will, this wrong thing
will evaluate to wrong,
as to fault, sorry.
So, whenever you try to
specialize this, or to use this,
this will fire a
static_assert, and tell you
to use some other specialization.
But there is a constructor
added to this, nonetheless.
And this helps with the
compiler, to figure out
which bad_statement to use.
Okay, because it takes an argument
off the template parameter type.
Cool, so, now we have this.
I hope that we're now
coming to Jason's question,
or Jason's remark.
What to do with the return types.
We haven't done anything yet.
So far, we have just cleaned
it up, made it easier to read.
While all that is cool, we
still have the same problem,
that we could return this
and the user would not be any wiser.
But, there is a new key
word, or new, sorry,
attribute for functions.
We can say nodiscard.
That's an indicator that
you don't want anybody
to accidentally discard the
return value, of this function.
Then, if you call this, the
same way as we did before,
then it's almost certainly
a compiler warning.
Almost certainly, because the
standard doesn't mandate that.
I don't know why.
It highly recommends it.
I don't know the exact wording for that,
but basically says,
implementers are recommended
to issue a warning here,
but it's not mandatory.
Yes, Jason.
- [Jason] I don't believe
there are any mandated warnings
in the standards, that
might be why they decided
to not add it there.
But, I was wondering if
you found in general,
that adding nodiscard on all return values
of const number functions,
was like a best friend?
- Okay, so the question is,
whether adding nodiscard
to all const member functions
that return something
is a good idea?
- Yes, I think so.
- [Jason] Okay.
It sounds like a good
idea, I haven't pursued it
because you just put this up.
- Okay, well.
Cool, yeah, I'm using
it all over the place.
So, wherever I return
something for const function,
I do that, because everything else
would probably be bad usage.
(laughs)
(warped/unclear words from audience)
(warped/unclear words from audience)
Anway, so.
(warped/unclear words from audience)
Alright, okay, I think we should,
should stop the tool discussion
here, before it derails.
Alright, thanks.
As, I think everybody's seen,
this results in a much
nicer code, much less code,
cleaner code, because,
well, you don't have
all this additional rubbage,
that you have to care about,
with template parameters,
and decay, and what not.
There is improved compile time,
because, well, you don't have all these
additional template associations,
and less bugs.
Users have less bugs with these.
Cool, so, moving on.
Fold expressions, I've shown
this example in the beginning.
This thing for figuring Arga
with, all the goals are true.
That is so simple to write now,
that it doesn't even make sense
to have an alias for that.
You can just use it wherever you want.
That is, that's just really nice.
Good, one use of fold expressions
that I have in the library,
is print tuple members
as comma separated list.
For this, I have a small
helper, that basically
does nothing but add a comma to a stream
and then return the value.
You insert it with a stream, a separator
and then it will figure out
whether its the first
time that it's called.
Then it will set it's first false.
Otherwise, it will just print
the separator to the stream
and return the expression
that you had it in.
And that can be used like
this, in this code here.
So, I inserted a separator
with ostream in this case,
and a comma as a separator.
And, then I can use that in
a fold expression, right?
On the left end, I start with ostream,
and then just left shift, or stream
every of these expressions,
into the stream.
And before you get too
wrinkled up, (laughs)
this only works in my code,
because I know for sure that
when this function is called,
with this tuple, with these columns here,
I know for sure that
they're all different types.
Otherwise, you will be in
deep trouble with this code.
Otherwise, you would have to go by index.
But that would add another
level of indirection, and
for the index list, this is nice.
Everything good?
You have a question?
Okay, cool.
Another thing that I already mentioned,
that I have, is type sets.
So, I want to compare types
and figure out whether,
for instance, all of them are unique.
So, type sets are a neat way to do it.
And type sets become
much more easy in C++17.
So, in order to write a type set,
we start with something that
can be used as a base class.
And then, we create some type set struct,
that takes a bunch of types,
which are hopefully unique.
And internally, it has this struct _impl,
that's inheriting from all
these different base classes.
This will crush the compiler,
if you pass in anything
that is not unique, by the way.
Well, crush something,
that's what I'll say.
And then, before we go
into how to construct this,
we'll start with checks, right?
How to check whether there's
an element in this set.
Well you can just check whether,
base T is a base class of this impl class.
And the compiler will just tell you, yeah,
yes it is, or it isn't, depending on
whether T is one of these elements.
So, that's fine.
Then you can start with fold
expressions, for instance,
to figure out if something is
a superset of something else.
In this case, if it's a superset, then
for the right-hand side,
all these T's have to be
elements of ourselves,
which is what we test here.
So, we start with true, and
then combine it with and,
count, for first T, second T, and so on.
That's what fold expression
does, goes through all the,
all the arguments, one by one,
and applies this operator to the left.
There are different versions
of how fold expressions can work,
whether with a left or
right, or you can have
different ways to initialize them.
But, I like this best, for most cases.
So, that is neat.
We're coming closer now to
actually constructing something.
So, if we want to insert and
you type into this type set,
and along we have a function,
nodiscard, because it's a const function.
It takes a template parameter
T, and then we can just
check one, if the count is false.
Then we already have it, I'm sorry,
if the count is true,
then we already have it,
then we just return
instance of this type set.
And otherwise, we add
the T to the other list
of elements that we already have,
and return that, okay?
So, we're done.
And then, to make this
useful, for fold expressions,
we just add an operator
that does exactly the same.
So, this one has to take a value,
and since we don't know in all cases
how to construct a value,
this uses the base class,
or this base helper type.
Then it just calls insert,
and returns that, okay?
And now, if we want to
construct a type set,
we just take any number of T's,
they don't have to be unique.
Just take any number of
T's, and then initialize
the fold expression
with an empty type set,
and just shift every
of our types in there.
It will make sure that
everything is unique.
And then we have a type set.
We can use it like this.
That's for the columns.
So when you select columns,
like we then used in this print example,
this will check whether the
character sequence types,
of all these columns.
So it's extracting the
names from these columns,
which represents them as types.
Whether all of these, puts
all of these in a type set,
then compares the size of this type set
with the number of columns.
If that happens to be the same,
then everything is unique.
So, that's the good case.
So, fold expressions lead
to more expressive code,
lead to less code, lead
to improved compile times.
I'm sorry, I haven't done
extensive tests with this.
But, for instance, I created
I used this create type set function
with what I have in
sqlpp11, and what I now have
in the 17 version, with
just a thousand ends.
Well, it's the simplest test that
I could have come up
with, in a short time.
The speed improvement is factor 4.
That is not just a few percent.
Also, since this is so
much easier to implement,
so much less trouble to do,
you don't feel like you
have to use it all the time
because it was so hard to produce.
That's why I say, reduced
golden hammer syndrom.
You don't use this thing all the time
just because you have it.
That also leads to better compile times,
because tests are still expansive.
Cool, so, that's what I wanted to present
about core features.
Now we'll use some library features.
Okay, enough time.
So, string view, just a few
words about string view.
Currently, when we have a
text result field in sqlpp11,
you typically have some character pointer,
that you are provided,
or the content of it,
which is provided by the
back-end of the database,
and a length.
And then, when you get the results,
or get a new result
rule, you bind this thing
to some kind of target.
Then we'll reassign the text pointer,
and the length, and then
you assign these values
to the string.
Because, well, in earlier versions
we didn't have a string, a string view.
If the length is always the
same, that's not that bad,
because, well, you basically have to do
bit amend copy with the assign.
But if the size increases,
for instance, from row to row,
then you will have
reallocations in addition.
I don't know, that's annoying.
With C++17, we now have string view.
String view is a non-owning view
on a character pointer, for instance.
And it doesn't allocate anything,
it just happens to take a
character pointer and a length.
That's exactly what we have.
We can put this in the string view,
and then we'll then have a representation
that almost looks like
a string, but isn't.
It has pretty much the
same interface as a string,
can be converted to a string.
So, if the user wants to do something,
like storing in into
a string, that's fine.
There is no difference in usage.
But internally, at least, the
memory usage and everything
is much nicer for this.
So, cool feature.
Basically, improved runtime performance.
The next two things are
std::variant and std::optional.
In order to see what I want to do,
let's go with this.
All the examples that I've shown before,
were examples where the
structure of the query
is completely known at compile time.
So, every column is known, every
table is known, everything.
But there are situations
where, I don't know,
you select some data from a database,
and sometimes you want
to add a new column,
or a different column, because
this column is expansive,
you don't want to extract it every time.
But, based on some condition,
you want to extract it.
That's where this
dynamic_select comes from,
comes into play.
You can say, okay, dynamic_select,
and you have dynamic_columns,
and dynamic_from.
You start with whatever is the default,
and then there is someCondition.
Then you'll say, alright,
I'll add another column.
Then, under someOtherCondition, I'll add
another column from even a different table
than I used before.
In that case, I also add a dynamic_join.
That's just wording in the library,
basically you added join
to the from, this way.
And then, the library will
take care of that, for you.
But since this is done at runtime,
you cannot have the same core return rows,
or result rows that we had before.
The ID, which is statically
added to the query,
that is still accessible
as a member of the struct.
The others, well they have to be taken now
in a map like fashion, in this case.
So, we'll add a string
here, into this operator
and then hopefully get something out.
The type is also not clear.
The library currently
only returns strings,
and then you have to do,
whatever you want to do with it.
I really don't like that.
Then I thought about,
well, first what variant,
what to do with it.
And I found, well, variant
could improve the situation
quite a bit.
Because instead of returning
strings all the time,
I could return a variant.
There are not too many types,
that this library would return, normally.
I don't know, there's BOOL, and
there's some integral types,
there's a text type, there's a block,
date, datetime, that's I don't know.
Half a dozen, or so.
And we could return a
variant on all of those,
and then the user could
figure out at runtime
with some checks, what
kind of type this is.
Whether this actually
matches the expectations.
So, that would be an option.
But we would still do
name lookup like this.
I'm not a big fan of those.
And also this checking it at runtime,
whether the type is really what I expect.
Not so good.
And then I thought, well,
if I look at use cases,
and not the general one,
where somebody wants to add
a thousand additional columns
under certain circumstances.
The usual use case, is
that we have some columns
that are expansive.
I don't know, maybe one, maybe three.
But a very limited number.
So, what I could do, is I could say, well,
I indicate these columns
as optional, right?
Which is really what I want to express.
The user can say, well,
this column is optional,
and only if this optional has a value,
then that should tell us the library
that it should actually
retrieve this value.
And then, it would look like this.
Same code as before, under some condition.
We say, alright, we pass
an optional of foo.name.
So, this column into the library,
that's so we can do,
into this select call.
And otherwise, if the condition is false,
then we just passed our std::nullopt,
which happens to be an argument
for the std::optional
constructor of any type,
and will just construct an empty optional.
So, this way the user can indicate
whether or not they want to
have this column selected
and returned, right?
In the second case, where we actually have
a different table in addition,
then what we can also join and say,
well, this table a join
in here, that's optional.
And the whole join expression will only be
created for the sql, if
this optional is not empty.
So this is, I think, a
reasonable use of optional,
much better than the variant version
that I had thought of before.
And, as you can see, the good news now is
I now have members in my result struct.
I have the appropriate names.
The only thing I have
to do, in the result,
is check the condition,
and then I'm pretty sure
that this will have the
well, I'm not pretty sure,
there is pretty much a guarantee
that this thing will have some value.
Unless the column itself is null,
then this might still
be an empty optional.
But, all this crazy lookup
by string, that's gone.
All the, and security what the
type might be, that's gone.
So we're back in type safety land.
Even though I didn't
use variant in the end,
it gave me new ideas of how to do it.
Basically, it led me to
the idea of using optional.
So, yeah, thinking about
C++17 features may be helpful,
even if you end up not using them.
That's a nice thing about this.
That brings me to the summary
of what we've seen here.
So, a bunch of core
features of the language.
They're, at least from my use,
they're just wonderful, awesome,
whatever you want to call it.
It's super.
And, if somebody says that
C++17 was a minor release,
well, I don't know, not for me.
For me it's a great release.
C++17 is just great for these uses.
Even though on variant,
I don't use it yet,
but other people will
certainly have uses for it.
Cool, and as mentioned,
thinking about these things
and experimenting with them,
also improves my sqlpp11 code.
Just by not having to think
about stuff that hard anymore,
and coming to more elegant solutions.
Some of them, suddenly, you realize
can be translated back to sqlpp11.
And then, code is easier.
So, for instance, my type set
and I haven't replaced it yet,
but the type set that I showed in C++17,
it's not that hard to
come up with something
that is pretty close in sqlpp11.
It's not that bad, right.
But, I never had the ideas to do it,
until I experimented with C++17.
So, even if you cannot use
it in your professional life,
or in your library
currently, just play with it.
It's cool, right, and it helps you.
Alright.
That's it, thank you!
(applause)
(applause)
(applause)
We have a couple of minutes for questions.
Yeah, go ahead.
- [Man In Audience] So
you showed iterations
over the terms of your
select with a range for.
Did you structure bind
this, and want back,
the struct that you brought back?
- So the question is, can
I use structured bindings
to deconstruct the result row?
I guess so, yes.
If not, then I'll try to
make it happen, for sure.
Yeah.
- [Man In Audience] I think
the practical problem,
with the knowing what order
there's in the resulted
struct, so you could
actually decompose them
when you go back.
I'm guessing you don't have any guarantee
as to what order the elements
are, in terms of structure.
- Okay, so the remark is that
I might not have a guarantee
of the order of the elements.
Actually, I do.
So the columns are ordered in the way,
inside of the struct, they
are ordered in the same way
as you selected them in the function.
- [Man In Audience] Oh, okay.
- So, there is a guarantee for the order,
but then again,
if you have several
columns of the same type
structured filing might not
exactly be what you want,
because then you don't have
the name safety anymore.
I really like the name
safety, of the data on this.
- [Man In Audience] Where
can we find the slides.
- The slides will be on
GetUp!, sometime soon.
So, I guess all of the people's slides
will be uploaded to GetUp!,
and will be announced.
More questions?
Alright, then, thanks again.
(applause)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>