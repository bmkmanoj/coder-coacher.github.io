<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Howard Hinnant “A ＜chrono＞ Tutorial&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Howard Hinnant “A ＜chrono＞ Tutorial&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Howard Hinnant “A ＜chrono＞ Tutorial&quot;</b></h2><h5 class="post__date">2016-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/P32hvk8b13M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right this talk is going to start on
time for two reasons one I've got a lot
of material to cover
and two it's a talk about time so let's
be ironic
and also because I've got a lot of
material to cover I'm going to ask you
to keep your questions to the very end
because with questions this is about an
hour and a half talk and only got an
hour so questions at the end and also if
if you don't get your question in at the
end I love to talk about this stuff I'll
be here all week just catch me in the
hall and ask your questions in if you
get crowded out at the end of this talk
so this library everything you need to
know about this library is it's in the
standard header Crono and everything
that I discussed today will be a
namespace standard Crono I won't always
have that explicitly on the slide
because it's a mouthful and it's a lot
to write and it means it wouldn't fit on
the slide so I'm going to start with
talking about the motivation about why
you'd want to use Crono in the first
place and then I'm going to talk about
time durations and points in time clocks
and wrap up with some examples so the
first thing that some people ask when
they first start looking at a time
library is you know why do we need
something fancy like chrono can't you
just use an INT for the number of
seconds since 1970 or what have you
worked for ever and see and you see
something like this well actually you
see you see sleep 10 in your code and
the 10 is ambiguous does that sleeping
for 10 seconds 2 nanoseconds 2
microseconds nobody knows but if you've
got a time library you can write
something like 10 m/s which means 10
milliseconds it's much more readable you
can tell exactly what this is supposed
to do now admittedly for m/s you need
c++ 14 not C++ 11 I'll be mainly talking
about C++ 14 here and the parts that do
have a limitation to C++ 11 I'll try to
to Lucido to elucidate those
so your code comes much becomes much
more readable when you've got a typed
system a strong type safety system for
your units and in general using an
arithmetic type to represent a duration
or a time point is just intrinsically
ambiguous so chrono is all about helping
the compiler help you find your logic
errors at compile time and it does this
by making distinct types distinct
concepts so I'm going to start out with
time durations and time duration is just
a period of time it could be three
seconds three minutes three hours
what-have-you and I'd like to start out
with our very first duration unit
seconds now seconds is a very trivial
type all its special members are trivial
it's basically all it has is it's a long
long inside of it it's just a wrapper
around a long long or assigned 64 bit
type it's very simple here is how you
can visualize it it's just a class it's
got a long long in it it's default
constructible trivial special members
it's very very simple to construct a
seconds you can construct it like this
if you don't have initializer on it it's
just like long long you get an
uninitialized duration if you want to
zero initialize your duration you can
add the curly braces or the parens and
that will zero and initialize your
duration so not only is it just like a
long long you don't have to worry about
if you've got to say a vector of seconds
you know and your vector is a million
long you don't have to worry about that
vector going through and zero
initializing every single one of those
zero elements every single one of those
elements unless you ask it to so the one
thing that you can't do with seconds is
implicitly initialize it front from an
int for example if you say seconds s
equals three this will not compile now
it turns out that in chrono it's almost
as important what it won't do is what it
will do
and this is all about catching your
errors at compile time and that'll
become clearer at least I hope it'll
become clear as I talk more about it
through this talk but of course
sometimes you need to save three seconds
and this is how you do it you just say
seconds and seconds is in namespace
standard chronal that's not shown here
and you can use the curly braces or
parens and you give it some integer so
here is how you'd say three seconds very
simple unfortunately printing the mount
is not as easy it should be there's no
good reason why it's not but I'm
presenting the library tomorrow that
will fix this problem you should
consider this part a bug to print out a
duration you actually need to use this
member function called dot count and all
dot count is is it returns that three
that's stored in the long long inside so
durations are very simple and they're
very observable if you want to get that
long long out it's easy as dot count and
so here I've also added yes so that you
can see that yes I'm printing out three
seconds so so far very easy very simple
now here I'm writing a example function
called F and all this function is going
to do is print out the print out the
value in general you might have a
function that does arbitrarily complex
things with your durations but just for
the purpose of this talk our example
function is going to do nothing but
print it out now if you call this
function with an int you get an error F
of 3 and this is a very important error
again I hope this simply I'll be coming
back to this again and again over the
talk just to emphasize it if you call F
of 3 since 3 won't implicitly convert
two seconds to get this compile time
error now if you think about this if you
didn't see the function f above all you
said all you were looking at in your
code was f of 3 you might look at that
and say well I know it's a duration is
it 3 seconds is it 3 milliseconds at 3
nanoseconds you wouldn't know so that's
one of the reasons that it's very
important for this to not compile if
you want this to compile and mean three
seconds then you would do it such as
this you'd form seconds three explicitly
and that's perfectly fine and this will
run in printout three yes in c++ 14 you
can actually say three SS as a
user-defined literal and you can form
three seconds that way it's the exact
same efficiency it means the exact same
thing it's just a little bit more
readable and concise you can form an L
value of seconds type and pass that same
thing same efficiency you're literally
just passing long long surround but it's
just wrapped up so additionally you can
do subtraction and addition with with
your durations there's the plus equals
the minus equals you can say seconds
minus second seconds plus seconds and it
all just works except this very bottom
line if you say something like X plus 1
again you get a compile time error why
because the one is ambiguous you don't
know whether that's a minute or an hour
or a second or whatever so it things
just the library will refuse to compile
that additionally you've got all six of
your relational operators equal equal
not equal less than greater than etc etc
so here i'm ridin' a function and i'm
I've got my argument D and I'm comparing
it to some global or whatever some
faraway code called time limit and you
see my my time limit also has type
seconds because of the S on the end here
so very easy comparisons things just
work and if we call this like so then in
this example it would print out out of
time 3 s now if we accidentally forgot
the to make our time limit of type
seconds say we accidentally made it in
an integral type this would again not
compile because 3 seconds is less than
or equal to 2
- what it's ambiguous again so you can't
compare seconds and hence you can only
compare seconds and seconds or more
generally seconds and durations and I'll
get into that so as long as you have
your your units correct things just work
so one of the things that people worry
about with will how much am I paying for
for all this so what I'm going to do
here is create a function that does
nothing but add two seconds and I'm
going to do it two ways one using the
chrono library and the second way using
basically C I'm going to take a couple
of long Long's
add them together and I'm instead of
timing this the operations are so quick
that's tough to get accurate timing on
them so instead to look at the
performance I'm going to compile these
using clang optimized - oh three and I'm
going to show you the assembly listing
of both of these functions now don't
worry you don't have to be an expert at
reading assembly to get the point that
I'm about to make
so compile both of these look at the
assembly and here's literally what each
one of them generates this is the entire
operation and the assembly code for both
of those functions is exactly the same
object code except for the name mangling
at the top and this is again for a
release configuration for debug you
would get a wooden inline and stuff like
that so you would get different object
code generation for the two functions
for debug mode but for release mode
there's absolutely zero overhead here
the exact same object code so what's the
range of seconds well it's unspecified
it's different for each platform but you
can query it seconds has static min
function and Static Max function you can
get those and it's Chronos has three
currently three separate implementations
two of the authors are actually here in
the room I did one of them Stefan did
that a second one and on all three
implementations the range on seconds is
plus or minus 200
two billion years that's a little bit
older native universe so if you overflow
you you've got problems beyond just
overflowing seconds you've got some
serious something wrong going in your
application the the intent here with
having the range so large is so that you
don't really have to worry about range
checking that much with a chronal
library it intentionally has very large
ranges so that if you overflow it's
going to be something obvious and very
bad going on you don't have to check
every single little operation to make
sure you're not overflowing plus or
minus two hundred ninety two billion
years so seconds is just a wrapper
around the integral type long long it is
this a big deal and I claim yes this is
a very big deal and the rest of the talk
will hopefully convince you of why it's
a big deal so one of the one of the
things you might imagine is let's say
you're in charge of a large program you
know maybe a million line program maybe
a hundred million lines of code and
you've got all this timing timing code
through it and it's all based on seconds
and somebody comes through and says you
know we need to start trafficking in
milliseconds can you make that happen in
a small program it'd be easy you just
substitute in seconds for milliseconds
double-check everything run a thirty
degree a test and you'd be done when
you've got millions of lines of code if
any of body event of you of handled code
that big you know that can be
problematic
so croto also has this type called
milliseconds and milliseconds works just
like seconds it's just a wrapper along a
long long a around a long long it's got
all the trivial special members about
the only difference is its range is only
292 million years instead of two hundred
ninety two billion still have plenty of
range so we just search and replace our
code and replace seconds for
milliseconds no that would be a
dangerous way to do things
chrono allows you to do something that
is much much safer than that you modify
a small piece of your code
time just porting that one piece of code
from seconds to milliseconds and then
you recompile and retest don't modify
your entire million line program at once
that would be a disaster so to show you
what that would look like let's look at
our tiny little function that does
nothing but print out its duration let's
pretend like this is some small piece of
code in your very large program let's
port this and then we'll see how the
rest of the program reacts to our
reporting so we go through and we change
seconds to milliseconds and because
we're printing out we change this to m/s
so that we get a nice printout what does
the rest of the code do the rest of our
large function
I think I'm blocking my my signal here
so before if we called F of 3
it didn't compile now when we call F of
3 it still doesn't compile now let's
just think a minute let's say it let's
pretend it did compile when we used to
have F taking seconds then this would
have been it would have meant you know
call F with 3 seconds if it compiled
again now the meaning of this function
would have changed and now we'd be
calling F of 3 milliseconds silently
that would be a runtime error it'd be a
change in behavior that would be silent
so this is why it's so important that
it's not implicitly convert to 2
durations now if we call it with if we
look at our calls with F of 3 seconds in
each case no change is needed the call
with 3 seconds will implicitly convert
to 3 milliseconds and print out exactly
what it should 3,000 milliseconds in
every case so the rest of the program
continues to work now there are cases
where it won't work but those cases will
refuse to compile instead of compiling
and creating runtime errors so in
general port your small piece of code
and the rest of your program will leave
their compile and do the right thing
won't compile and you'll get error
message that will help you lead to lead
you to how to make things compile and
make them compile correctly so let's
look at our second example are a little
bit more complicated example function
where we can compare it with a time
limit let's port this we change seconds
to milliseconds we change our our output
from s to m/s what happens with this
well one of the one of the really
interesting things with this is this
function is referencing this far away
global this time limit think did we have
to change that and the answer is no not
at all
that can stay seconds milliseconds will
compare to seconds and it will always
get the right answer and it won't even
cost you anything at runtime the
compiler says oh I see I've got seconds
here I see I need to compare it to
milliseconds here this is a compile time
constant I know that at compile time I
will convert that to seconds to 2,000
milliseconds and then do the comparison
zero abstraction overhead so things just
continue to work properly and at our
call site we we call this with F of
three seconds we don't need to change
that and we get the exact same behavior
except now it's printing out 3,000
milliseconds instead of three seconds so
things just continue to work so chronal
the chronal library knows about the
relationship between milliseconds and
sex it knows it has to multiply seconds
by a thousand to get milliseconds or
divide if you're going the other way one
of the one of the poor practices I often
see when people start using Crono is
they they get the number out with the
dot count function and they start doing
their conversions manually they'll
multiply by a thousand or divided by a
thousand or what have you don't do that
chrono can handle all the conversions
for you don't code your conversions
manually if you're doing that in a
hundred places over years
was in line or million line program odds
are you're going to get one of those
places wrong you're going to multiply by
a thousand when you should have divided
or vice versa
if you always let crow know do your
duration your conversions Crona will
never make that mistake and the code
that chrono generates will be just as
efficient as if you'd hand coded that
times a thousand or divided by a
thousand and to demonstrate that let's
do our compile time test again I've got
my function and I'm going to convert
seconds to milliseconds then I'm going
to do it two ways once with the chronal
library and we have an implicit
conversion here from seconds to
milliseconds and then in the caveman the
and Earth all sorta way where we
multiply by a thousand compile both of
these optimizations on the exact same
object code gets generated except for
the name mangling so there is really no
cost at all no runtime cost to using the
chrono library so chrono allows you to
migrate from seconds to milliseconds a
small piece of code at a time and code
across such a transition that hasn't
been ported yet will either be correct
or it won't compile and even if you have
a context where you need to do mixed
mode arithmetic you need to start adding
milliseconds to two seconds or
subtracting them things will just work
if you hear I'm adding seconds in
milliseconds and we get two thousand and
three milliseconds we pass that to our
function f and it'll print out two
thousand and three MS so mixed mode
arithmetic works just fine so if it
compiles it's working don't worry now if
it if it does it compile I think I
skipped a slide there I'm sorry let me
backtrack a little bit
this is important
if it doesn't compile don't escape the
type system with the dot count member
function and do it yourself instead try
to understand why it didn't compile it
didn't compile because chrono is trying
to tell you something that you tell you
that you did something that's not right
and it shouldn't compile so that's
another mistake that I see all the time
is people using chrono and you know
they're so happy that they poured it to
chrono and then they need to do
something and they can't get it to
compile they get frustrated and they say
oh I know I can just get the number out
with dot count and multiply by a
thousand or what have you please don't
do that if you have to just email me and
I will help you fix your code and we'll
both learn so that the one exception to
that is if you're interfacing with
legacy code and unfortunately see out or
streaming out is legacy code at this
point if you're interfacing with legacy
code that doesn't know anything about
chrono you might have to use dot count
for that
so in general so far we've only talked
about what I call lossless conversions
conversions from seconds to milliseconds
if you have a different number of
seconds you can always represent that in
milliseconds assuming you don't go over
the 292 million year boundary so the the
milliseconds can always exactly
represent the number of seconds you had
and so all lossless conversions are
implicitly allowed to happen as we've
seen however when you go the other way
try to convert milliseconds to seconds
that's a lossy conversion if you have
for example 3400 milliseconds you can't
exactly represent that in seconds so
that conversion the chronal library
doesn't allow you to do at least not it
doesn't allow you to do it implicitly it
says wait are you sure you want to do
this because you're going to lose
information now sometimes that's exactly
what you need to do you know you need a
bigger hammer sometimes so there's a
function in the library called duration
cast you supply it as a template
parameter whatever destination type that
you need and then it will do the
truncation for you it'll do the
I'd buy a thousand essentially so if you
duration cast two seconds thirty four
hundred milliseconds you get three
seconds out of that so do it it's also
important to understand that duration
cast means truncate towards zero now if
you're if we're looking at positive
durations that's always truncate down
but if you're looking at negative
durations like negative thirty four
hundred seconds that's truncate up
towards zero to be negative three
seconds in C++ seventeen you will get
new rounding modes
there'll be floor for always truncating
towards negative infinity ceiling for
always truncating towards positive
infinity and round for truncating toward
zero width towards even on a time and if
you absolutely need those before C++
seventeen my website has them and you
know it's this much code you can just
copy-paste if there's no copyright
issues or anything like that
so in summary only it's only use an
explicit cast only use the duration
caster the ceiling or the floor when the
implicit conversion won't work if the
implicit conversion compiles it will be
exact and that's what you want to do and
then if it doesn't compile you can make
the decision okay I see that I'm doing
truncation error here and you can decide
you know this is your chance to think
about should I truncate towards zero
should I round should I truncate towards
negative infinity what have you now so
far we've only talked about seconds in
milliseconds we can handle more units
than that we have a few more units in
that in the chronal library we've got
everything from nanoseconds to hours now
everything that I've told you about
seconds in in milliseconds is exactly
true for all these other units as well
so there's there's not that much more to
learn they all interoperate with each
other exactly as I've described with the
seconds in milliseconds
they'll implicitly convert from coarse
to fine and if you need to go from fine
to coarse you need to use duration cast
and they all work together seamlessly so
let's take a look at a few examples
let's say we rewrite our trusty F
function here within nanoseconds back
and do mixed mode arithmetic I can add
hours in microseconds pass that to our F
that will implicitly convert it'll add
the hours in microseconds together and
that creates some of microseconds and
then that temporary sum gets implicitly
converted into nanoseconds as it's being
passed to F and it prints out this
outrageously large number of nanoseconds
so we're looking at relatively complex
code here I mean it's not rocket science
but it would be easy to get wrong if you
were doing all these conversions by hand
and the code is very clean-looking and
it's guaranteed to work it will always
get the right answer so a lot of people
start thinking well gee long long using
long longs for for all my time durations
that's kind of expensive this is
overkill for my application I say you're
building a trs-80 emulator or whatever I
only need 32 bits seconds for whatever
reason well of course that's going to
overflow a lot easier but if that's what
you need to do if that's what you want
to do
Cronos got you covered there there's
this template in Chrono called duration
standard chrono duration and as its
first template parameter it takes what I
call the representation and you can pass
into that representation a 32 bit int
and this is just the same thing as a
type death for those who aren't used to
the using syntax of C++ 11 and 14 so
this creates a type def called seconds
32 that is a 32 bit seconds
representation and this seconds 32 will
be a first-class member of the chrono
library it'll in or interoperate with
milliseconds and seconds and hours and
nanoseconds in the exact same way I've
already described so you can create your
your own seconds using int 32 and
hopefully that will talk you into using
it even if
you're building a trs-80 emulator some
people still complain they say well I
really meant unsigned okay you can stick
an unsigned in in 32 in there as well
some people still complain well since
it's only 30 32 bits actually need
overflow protection fine there's plenty
of safe int libraries out there where
you can find one or build your own you
can wrap your in 32 up into whatever
safe int library you want and pass that
in as the representation in Chrono will
still deal with it all the arithmetic
it'll do it'll do on this safe in 32
type so you can you can there's a lot of
flexibility here you can pass almost
anything you want into Chrono is a
representation as long as it's emulating
an arithmetic type it'll just work now I
used arithmetic type there on purpose
you can plug in any arithmetic type in
for this representation or an emulation
of an arithmetic type and yes that means
even floating-point types so if you want
to have a seconds that can represent
fractions of a tick using a float or a
double if that's what you want to do
knock yourself out and there's some
interesting interesting facts about
using floating-point types for your
representation recall that if I said
that if your conversion is lossless ie
if there is no truncation error it
should be allowed to happen implicitly
well if your destination is a floating
point type there's never going to be
truncation error there might be roundoff
error depending on you know the
precision of your floating point type
but there's never truncation error so if
the destination is a floating point type
the conversions are always implicit so
here I'm adding 45 milliseconds in 63
microseconds and then implicitly
converting that to a floating point
second and it just works it compiles in
it prints out point O for 506 3 just
like you think it should
at this point you might be wondering
well what I really want is generalized
representation on something that's not
second say for example milliseconds can
I do that of course you can this is this
is chrono you can do anything so here's
how you might do this here's a template
type def there's a second template
parameter to this template duration that
takes what's called a ratio and a few
slides I'll go into a little bit more
detail about what a ratio is but there's
a ratio called
milli it's in the standard namespace and
so here is how we can make a type of any
representation we want that's always
going to be milliseconds and just to
demonstrate it
here's a millisecond based on float and
if I put in the same expression we had
on the previous slide now it continues
to work but instead of 0.045 blah blah
blah prints out 40 5.0 6 3 milliseconds
which is of course exactly right so
you've got a lot of power and a lot of
flexibility here to do really almost
anything you want so we're going to dive
a little bit deeper here and I'm going
to explain some of these things that
have been showing you a standard
actually specifies seconds milliseconds
microseconds in nanoseconds exactly like
this
these are specializations of this
template called duration and they are
they have a representation of signed
integral types that have at least this
many bits in them now you don't have to
memorize those number of bits what this
means in practice is that if the number
of bits required is over 32 the
implementations are going to be using a
64 bit signed int in here so all of
these would be using long long or in 60
40 or what-have-you and the second
template parameter there are predefined
or standard defined ratios called nano
micro milli and and several others and
so those are defined for nanoseconds
microseconds milliseconds
and the duration template itself
defaults the second second template
parameter to a ratio of 1 over 1 so
let's look a little bit more about what
ratio is so that's not such a big
mystery ratio is a compile-time fraction
that's all it is it's a template it
takes two integrals two signed integrals
representing the numerator denominator
and it has contexts per members
numerator and denominator abbreviated
Naumann and down again and all ratio
does is it takes its template parameters
reduces them down so that there's a most
compact you know reduces it down to
lowest terms and then you can you can
use this to represent your compile time
fraction in addition this standard
specifies that we have these predefined
ratios this is one over a billion one
over a million one over a thousand so
these are just really the SI units milli
micro and nano so the duration template
uses these ratio classes to do these
conversions that I've been telling you
about so here's our complete definition
of all six Crono durations and it uses
these predefined ratios for the first
three periods here I've explicitly put
in ratio of 1 this is just means 1
second it's the fraction 1 over 1 and
then for minutes ratio of 60 60 seconds
per minute for hours ratio of 3,600
3,600 seconds per hour and it's these
ratios that make all the conversions
work the compiler will say oh I see
hours has this ratio in nanoseconds has
that ratio so I divide these two ratios
at compile time and that's how I figure
out how to convert hours to nanoseconds
so I got to admit I lied to you a little
bit earlier in the talk when I said
seconds was this class called seconds
that's got an int long
in it seconds is actually a
specialization of this class duration
that is templated on rep and period and
it stores only the rep the period is not
stored it's simply part of the time so
rep is the only theta member so I didn't
line much it really does look like a
class called seconds with a long long in
it except it's a specialization of a
template called duration now one of the
nice things about about duration it has
these nested types called rep and period
so that if you get a duration say that's
generic and you don't know what it is
and you want to inspect it you can say
you know if it was milliseconds for
example you can say milliseconds period
that's the ratio get the numerator out
of it and that's going to be one and you
get the denominator out of it that's
going to be a thousand if you want to
see what the representation type is for
the milliseconds it's not specified to
be in 6040 but in practice that's
exactly what it is so you can these are
all very observable all of the compile
time characteristics of all of your
durations are very observable so now
that we know that this is how durations
are made you can build your own custom
durations let's say you've got a game
application that you're working on and
you want to measure frame rates at one
sixtieth of a second here is how you
build something that means one sixtieth
of a second stored in a 32 bit int and
let's say for example we still have our
function f that just prints out its
duration and let's say we're taking a
version it uses floating-point
milliseconds we can use our our custom
duration called frames send in one
frames to this and it will automatically
convert to these floating-point
milliseconds and print out 16 and 2/3
milliseconds because that's what the
conversion happens to be you don't have
to do any of this math itself the only
math you had to do is specify this one
sixtieth right up here which means one
sixtieth of a second giving it you can
even do mixed mode arithmetic between
your custom duration and the standard
supplied duration
it turns out that 45 milliseconds and
five frames or 128 and 1/3 milliseconds
who knew so this this last one is a
little bit interesting that I'm going to
do a deep dive on this to show you all
the gory details about what's going on
under the hood to make this happen and
I'm going to use the sudo syntax here
everything inside square brackets is
always compile-time information which
means it's never manipulated at runtime
all the computations involving inside
square brackets always happen at compile
time so here I'm just using this syntax
to represent milliseconds this syntax to
represent our custom jury frame duration
one sixtieth of a second notice that the
representations are different the first
thing that happens is the compiler says
oh I need to add these two that means I
need to bring them to a common type a
type that I can convert both of them to
losslessly
so the compiler figures out that it
needs to make both representations
signed 64-bit int and it needs to change
the
period to 1 over 3000 which is the least
common multiple it's C using essentially
the same stuff you learned in third
grade fourth grade whatever it was this
is how you add fractions your compiler
the chrono library knows how to do this
at compile time
and this is what it does once you've
done that you just do the problem in the
common type multiply 45 times 3 and 5
times 50 you get 385 in 64 T's of Units
1 over 3,000 and then the last step of
this was to convert it to floating-point
milliseconds and so you simply divide
everything by a floating point 3 and you
come up with 128 and third so it all
just works and it all works implicitly
and most of it is working at compile
time and to demonstrate that if we had
some function called tests up here that
took runtime arguments x and y four
milliseconds and frames this is the
assembly generated and the thing to
really notice here is what's not there
you don't find any calls to greatest
common denominator in this call because
they happened at compile time they don't
exist at runtime all you've got at
runtime is multiplied by 3 multiplied by
50 yaddam together and you divide by the
floating point 3 that's the only stuff
that happens at runtime so this this is
very efficient if we had to do all that
finding the common type finding the
greatest common denominator those
fractions at runtime this would turn
into a fairly expensive library but it's
not an expensive library so I know
especially with that deep dive I've been
hitting you with a lot of information
you may feel like you've been drinking
from a firehose
but there's more I'm not finished yet
however before we go on I want you to
know that remember back in the beginning
of the talk when I said there was just
seconds and maybe just milliseconds and
they were nothing but long Long's
wrapped up in a class all of this fancy
stuff that I've been talking about the
frames the floating-point milliseconds
and all this stuff it's all there only
in case you need it and if you don't use
it you don't pay for it you can pretend
it doesn't exist at no cost to you so it
may seem like a contradiction but this
is a simple library it's only as
complicated as you need it to be seconds
is to this duration template type just
the same as string is to basic string
char char traits char alligator char a
lot of times you just use string and you
don't think about the fact that it's a
specialization of this very powerful
very flexible template think of seconds
the same way don't worry about the fact
that it's a specialization that is
powerful complicated template called
duration it's just a long long wrapped
up in a class
so this library lives and dies by
converting one type to another if the
conversion is lossless that conversion
can be made implicitly if it's lossy you
need a conversion function such as
duration caste and if the conversion is
dangerous such as converting them into a
duration or duration to an end there's
very explicit syntax for doing that so
if you make a change in your million
line code and it's a reasonable change
that doesn't involve a explicit can
explicit conversion or XR dot count and
if you were only using implicit
conversions you can have some confidence
that you haven't introduced a bug in
your code because chronal will catch
silly bugs that you might have made
otherwise so in all of your conversions
use the weakest type conversion that you
can use implicit conversion if at all
possible this is another mistake that I
see beginners make they say oh duration
casts that's how I make I should make
all my conversions no use duration cast
only in those places where it won't
compile only in those places where you
need to specify truncation the reason
for that is making a lossy conversion is
a source for errors maybe you round it
down when you should have round it up or
whatever if every single one of your
conversions is hiding behind a duration
cast you'll have a lot more conversions
that you need to debug through but if
only the lossy ones are decorated with
duration cast then you've got a lot
easier debug job to do so use implicit
conversions everywhere you can if it
compiles with implicit use it that way
use duration cast if you need to specify
a truncation try not to use count at all
last resort use use the dot count and
you know for example if you need to
stream the the duration out to a file or
what-have-you you'll need to use count
so that's that's durations now we talked
about points in time
now don't worry everything you've
learned about durations will help you in
learning about time points a lot of that
knowledge will carry through there's
not that much more to learn so a
duration such as 10,000 seconds means
any 10,000 seconds or if you prefer 2
hours 46 minutes and 40 seconds but
there's this thing called time point and
just as an example I'm going to throw
system clock at you the time point based
on system clock with 10,000 seconds in
it doesn't mean 10,000 seconds it means
the state here 1970 new years 246 some
some odd in the morning so they both
have 10,000 seconds they both have the
same representation if you were to look
at the binary representation of a time
point and a duration they would look at
dinickel in the debugger but they mean
very different things one means any
10,000 seconds the other means this
point in time so there's a time point
templated class this is exactly what it
looks like I'm not lying to you this
time the first template parameter is
going to be a clock and I'll explain
more of what clocks are in a minute
they're not complicated at all and the
second template parameter is a duration
that defaults to the clocks duration
nested type and the only thing that gets
stored in a time point is the duration
itself the clock is not stored and a
clock has these nested types clock in
duration so that if you get one
generically you can inspect it at
compile time
find out what clock it's based on what
duration it's based on and from the
duration then you can get the
representation in the period
numerator/denominator all very
inspectable
and as I said before time points and
durations can have the exact same
representation they just mean different
things so when it comes to arithmetic
time points are very similar to pointers
they can be subtracted and the result is
a duration but time points can't be
added tomorrow and today are valid time
points course ones but their time points
and today plus tomorrow makes no sense
whatsoever but tomorrow - today is the
duration of today so it makes perfect
sense and you can also add a duration to
a time point or you can say a time point
- a duration
and this is all a 100% self-consistent
algebra that's checked at compile time
again Kronos trying to find all of your
errors at compile time if you accidently
add two time points you'll get an error
message might not be a pretty error
message I'll warn you but it'll be an
error message it will not compile so
time points can since they have a
duration you know you have time points
of different coarseness Azur different
durations and so they convert just like
durations to if you've got a time point
based on seconds and say it's got five
seconds in there just as example and
another time point based on milliseconds
they'll implicitly convert in that
duration inside the time points will
implicitly convert from five seconds to
five thousand milliseconds now if you
need to go the other way like generation
cast there's a function for that it's
called time point cast and that will
allow you to convert from a fine
precision time point to a coarser
precision time point and the c++ 17
rounding functions that I mentioned
earlier floor round and ceiling are also
all available for time point with the
exact same spelling floor ceiling in and
around so so use use time point cast
when you want to force a truncation
error use implicit cast as often as you
can with the time points and you can
explicitly force a more dangerous
conversion from duration to time point
with an explicit conversion syntax or if
you want to go from time point to
duration there's a member function
called dot time since epoch which just
gets the duration back out of the time
point you should view that with the same
skepticism that I've talked about with
dot count
it's a dangerous conversion you don't
usually want to do it but sometimes it's
necessary and this is how you do it just
be careful that's the dangerous part of
the line
so clocks
what is a clock a clock is a bundle of a
duration a time point and a static
function to get the current time so this
is what a some generic clock would look
like it would have all these nested
types in it so you can get the duration
out the time point out if you want the
rapid period
there's convenience type tips for that
there's a context per Bowl in it called
is steady if is steady is true that
means the clock can't be adjusted it
just runs if as steady as false this is
a clock that can be adjusted say for
example by a network time protocol
server to correct for leap second now
advanced or something like that so every
clock has a time point associated with
it and time points from different clocks
are not interoperable with each other so
for example just trust me that there's a
two different clocks here named system
clock and steady clock and if we
accidentally try to convert time points
a system clock time point to a steady
clock time point you'll get a compile
time error these two time points are not
interoperable at all now what this means
is that it's safe to use different
clocks and their time points in the same
program because if you accidentally mix
them you'll get a compile time error so
hmm
hope I haven't run out of batteries on
my clicker here it's interesting so
every time points associated with a
clock time points with different clocks
don't convert to one another and the
library supplies here I'm listing really
only to the library supplies three
clocks for you two of which are actually
useful it supplies system clock and
steady clock and then high resolution
clock is a third clock that it specifies
but the the standard allows that to be a
type def for one of the other two and in
all three implementation
it is a type tip for one of the other
two but the different implementations
type def it two different things
so my advice is don't bother with high
resolution clock just choose system
clock or steady clock and that way you
know exactly what you're getting now you
might now be asking well which how do I
choose between these two so if you if
you need a time point that relates to a
calendar or a time of day time that the
clock on the wall says you have to use
system clock only system clock has a
relationship to any calendar at all
steady clock on the other hand is just
like a stopwatch it's great for timing
things but there's no way you can get
the time of day from a stopwatch so
steady clock for timing and system clock
for getting time points that you need to
store somewhere and read back in and
still know what they mean because
they're convertible to a calendar so
whatever clock you choose you can get
it's nested time point like this and you
can get its current the current time
just like this so very simple syntax and
chronal works really well with auto
people get very tired of saying clock
color : time point and that sort of
thing so this also works and this is
usually the way I write it myself don't
have to repeat anything and it's very
simple so let's look at some more
examples here's how you might time a
function you just call steady clock on
either side of the function subtract
them now you don't always know what that
nested duration is for those time points
you could find out if you wanted to at
compile time but here I've said I don't
care what the the nested duration type
of that clock is I want my answer in
nanoseconds so I just convert it to
nanoseconds use the dreaded dot count to
print it out and there I have it if I
wanted to do something else say print it
out in floating-point seconds that's
just as easy or I could use duration
cast and convert it to milliseconds a
lot of flexibility here you can print it
out in whatever unit
to want the main point is is that you
should choose your units and explicitly
convert to them so that you know what
units you're you're getting printed out
the mutex functions have a tri lock a
time to try lock if you will you can
wait for a duration here in this example
I'm waiting for you know half a second
500 milliseconds you can also wait for
weight and toll a specified time so for
example here I'm saying okay now plus
500 milliseconds which is the exact same
thing but you might have a function
where you call now at the beginning of
the function and you want to wait at the
end of the function for now you know the
now plus 500 milliseconds and it's
difficult to know how long the function
took between the time that you started
the function and the time you start at
the weight you don't have to take care
of that and that's why it's very handy
to wait on a time point sometimes
instead of on a duration when you need
to take some other execution time into
account you can write your your custom
durations ratio also has a facility to
multiply two ratios together so in this
example I'm saying I want a duration
called days and that days is exactly 24
hours and and that's how you say 24
hours and this just creates a new
duration type named days you could also
spell it this way and it means exactly
the same thing it's actually the exact
same type just ratio 86,400 now there's
really no huge advantage when way or the
other it's more of a stylistic choice
and this custom duration of yours is the
first-class citizen in the library you
can use it with the standard threading
API to say sleep for a day or if if
you're really tired you can sleep for a
couple of weeks whatever you need to do
and for time points the de-facto for
system clock is that it's counting time
since 1970 New Year's in in UTC that's
not specified but all three
implementations do this and here's how
you might say okay I've got my system
I truncate that down to seconds and I
want to find out how many seconds it's
been since since the epoch and this is
how you would get that information out
if you want to find out how many days
you could truncate it down to days and
sure enough this is actually today it
has been 17 thousand and seven days
since since the epoch so you can use
chrono to find out these wonderful
fun-filled facts
so in summary chrono is based of three
modules say duration time point and
clock compile time errors are stressed
over runtime errors the generated code
is as efficient as you could have
handwritten and possibly even better and
the library is very feature-rich but you
don't pay for features you don't use
finally this library was designed a
decade ago was voted into C++ 11 in 2008
it's been standard C++ for half a decade
now so this is not bleeding edge code
this is best practice if you want to see
time computations based on bleeding edge
code please come to my talk tomorrow at
4:45 p.m. and we'll talk about a library
that does not obsolete chrono it builds
on top of it and makes it even more
powerful and easy to use I think we've
got maybe five minutes for questions uh
yes no kidding yeah that's alright it's
a true thank you for the information
I can you know whatever you do the code
I write can adjust um oh that it was it
wasn't really a question is more of a
remark that visual is going to change
their epoch from 1970 to 1600
January 1st 1600 right 1601 yes yes
that's true I did have a slide on that
it's in there it's always it turns out
that in practice it's always a typed ft
their steady clock or system clock yes
no come to my talk tomorrow
yes and and that's about an open-source
project that you can download MIT
license you know free to free to use no
cost you know very easy yes yes they'll
be talked about tomorrow in detail pain
pains painful detail Oh am I'm sorry
that they were asking about does chrono
handle leap seconds time zones no it
does not but I'll be handling that in my
talk tomorrow yes it's kind of a queue
of I thing the question is what are the
exact requirements on steady clock you
know for cases when the computer goes
into hibernate mode or something like
that
the intent is that steady clock is as
steady as possible to a second per
second so that when the computer woke up
it would you know it would take into
account the second set it's been
sleeping I don't think the standard
actually requires that it's kind of a
gray area the hardened fastening is is
it can never
come back and it can never decrease in
time yes what by that the question is
will your code still be portable when
when there's all these details differing
from library library which code are you
talking about the code you write code I
write okay so any any code that is
written that depends on the epoch of
system clock will become non portable
when visual changes are epoch my my date
time a timezone library is dependent
upon such things and it will be portable
when they when they create that you know
just if defin and as needed to - time -
yeah but Stefan was saying if you use -
time T that will always be 1970 that
will also always truncate you two
seconds precision the the change that
visual is going to make in there epic
will be happening within the next
release and I don't know when that is
and I doubt Stefan will tell us right so
that the the epoch of of both system
clock and steady clock are unspecified
by the standard I would call them part
of an implementations ABI but they're
allowed to make it anything they want
yes
so the question is are there I'll
summarize a little bit music correct me
if I summarized wrong the question is
are there field types like hour minute
second year month day in the chrono
library the answer is no but come to my
talk tomorrow I'm not selling that art
art I yes the question is the library I
talked about tomorrow will it go into
the standard and the answer is nobody
knows it will be proposed and that's the
that's all my time and thank you very
much and if you have any more questions
find me in the hole they either after
this talk or throughout the rest of week
glad dance room</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>