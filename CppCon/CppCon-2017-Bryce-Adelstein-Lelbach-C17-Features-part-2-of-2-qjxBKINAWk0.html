<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Bryce Adelstein Lelbach “C++17 Features (part 2 of 2)” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Bryce Adelstein Lelbach “C++17 Features (part 2 of 2)” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Bryce Adelstein Lelbach “C++17 Features (part 2 of 2)”</b></h2><h5 class="post__date">2017-11-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qjxBKINAWk0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Okay.
All right, so who was not
here for the first half?
Yeah, okay.
All right, so I'm Bryce.
(laughing)
I'm Bryce, I work at Nvidia
and this is a talk about C++ 17 features
for those of you have just joined us.
The first part of the talk,
we covered language changes
in C++ 17, and the second half
is gonna talk about new
library features in C++ 17.
And for those of you who were
in the first half of the talk,
somebody helped me out during
break to adjust the font color
so hopefully the operators are
a little bit more readable now.
My apologies for
the AV and color contrast issues.
But, again, this is the
link where you can go
to view the slides right now
if you wanna follow along
on your laptop, and I know
somebody from the back there
requested making the
font a little bit larger.
Unfortunately, there's not
much I can do about that
so sorry about that, guys.
So, let's get right into it.
So this is the 13
different library features
we're gonna talk about and the ones
that I have underlined
here are sort of the ones
that I think are the
biggest and most impactful.
So the first of them, so
the string_view, optional,
variant and any are three new
sort of vocabulary types
in the standard library,
so let's dive into those.
So,
before C++ 17, we would often,
when working with strings,
write functions that would
take a string and
manipulate it in some way,
and then return a new string,
but we're not actually really modifying
the underlying string,
just sort of change the way
that we're viewing that string.
And unfortunately, with
something like std::string,
which has ownership semantics,
writing these sorts of functions like this
first_3 function here which takes a string
and returns the first
three elements of it,
this can be expensive because
it requires you to make
a copy, because here,
I'm using the .substr method
to get the first three elements,
if it has more than three elements,
and that might allocate, and
it might create a new string.
And even if we were to
take this by value and,
this might still end up
with unnecessary copies.
And so then this operation
which isn't really
a muting operation might
introduce additional copies,
that we didn't really need strings.
So in C++ 17, we have a new
string-like type called string_view.
string_view has the same
interface as std::string,
more or less, so it has
all of the million of
member functions that std::string has,
but it does not have ownership semantics.
What string_view is is a lightweight
non-owning view of the string.
Sorry, I'm gonna have to refresh this page
because my slide notes are not coming up.
There we go, all right.
So, a std::string_view, as I said,
it's a non-owning copy and
it can't actually mutate
the elements of the
string that it points to,
but it can be quite useful
to work with because
when you're taking a
string_view like here,
and when I take a substring
of this string_view,
I'm not actually modifying anything,
and then this string_view
that I can return,
it's pretty cheap to copy,
because it's just like a pointer in size.
And so then this becomes
a fairly cheap operation.
So it's in a header &amp;lt;string_view&amp;gt;,
it's a non-owning view of a string,
the interface is mostly
the same as std::string,
it's often a dropped-in replacement.
std::string might allocate,
a string_view's never going to allocate.
A std::string owns its contents,
string_views don't own their content,
and it's the equivalent of
sort of a pointer and a length.
And copying a string_view should be cheap,
whereas copying std::string
might be expensive.
You should pass them by
value, not by reference,
but you can't mutate the
elements of a string_view.
And this is to avoid you overriding
the null terminating
character, is my understanding.
So in this example here,
I've got two different implementations
of a splitting function,
which takes a std::string
and then a regex to look
for as a deliminator
inside of the string, and then returns
a new vector of strings that are
the deliminated elements
of the original string.
So the std::string version here
will create a whole pile of new strings
and return them to the vector,
whereas the string_view
version will just create views
into the original string,
and won't actually create any new strings
and return them in the vector.
Yeah?
- [Audience Member] When the
owner string goes out of scope,
then what happens to the string_view?
- Ah, the question was what
happens to the string_view
when the owner string goes out of scope?
The answer is it's just
like a pointer and a length.
So it's like you've got a pointer
to something that's been freed.
So if you continue using that string_view,
you're going to have problems.
So string_view does not hold
any, it doesn't have any
ownership of the thing itself
and it will do nothing to protect you
from shooting yourself in the foot
if the thing that it's
pointing to goes out of scope.
- [Audience Member] So my question is,
if the original string
is changing its contents,
the string_view will
see the later updates?
- Yes, so if the original
string's contents have changed,
string_view will see the updates,
because it's just pointing
to the same memory.
(audience member speaking quietly)
So the question is,
if the length of the
original string changes,
will the length of the string_view change?
The answer is no, because the length
is a part of the string_view itself.
(audience member speaking quietly)
Right, so if the original string,
if you add a bunch of new
elements to it and it gets,
it gets moved to a new location in memory,
then the string_view is
gonna become invalid,
and it's not gonna, it would
not be updated by the string
being moved to new memory
to accommodate the new size of the string.
So there are,
it does not have any
smarts that protects you
from any of these things,
it really is semantically
sort of just like a,
a pointer plus a length.
Yep?
(audience member speaking quietly)
- Right, so the question was,
does the string_view have a length or
does it check for a null terminating--
- [Audience Member] Right,
does it keep its position
or its length or--
- So the string_view keeps a length
and does not look for a
null terminating character.
Any other questions on string_view?
- [Audience Member] What if
the original string was const?
- What if the original string was const?
I'm not certain what you mean.
- [Audience Member] I mean,
can you get a string_view
from a const string?
- Ah, can you get a string_view
from a const string?
Yes, you can get a string_view
from a const string.
Because keep in mind, the string_view,
you can't modify the elements
of the underlying string.
So it's not an issue at all there.
Something like span from the
guidelines support library,
you can modify the underlying
elements of the thing,
and so there, you can't take a span to a
const string, for example.
Any other questions on string_view?
Yep?
- [Audience Member] What happens
if you do not c_str on it?
- What happens if you do not c_str on it?
You'll get back the pointer.
(audience member speaking quietly)
Yeah.
Is there a dot?
Ah, okay, yes, yeah sorry,
so when I say mostly the same,
.c_str is not there, yeah.
But data is there, okay.
Okay so .data is there,
.c_str is not there,
but .data may return a null pointer.
Okay.
- [Audience Member] Can you
cast a string_view to a string?
- Can you cast a string_view to a string?
What's, the answer's probably gonna be no,
but what sort of casting
do you have in mind?
You can't, there are
different representations,
so definitely don't try casting
a string_view to a string.
You can't construct a
string from a string_view.
Okay, so, talked about this.
Okay.
So one of the other nice
things about string_view
is that you can use it to
simplify your interfaces.
So in C++ 11, let's say
that I had this two int API
that takes string representations
and attempts to convert
the string to an integer.
So I wanted my API to
work with std::string,
for const of std::string
with C-style strings,
and with my own string classes.
The nice thing about string_view is it,
because it's this non-owning view,
it's sort of agnostic to whatever
the implementation detail
is of the string.
You can just write, you can
just have this one interface
make everybody provide some
mapping to string_view,
and such as like this for your
own internal string class,
and then this will work for std::strings,
for C-style strings, and for whatever
your own string classes,
you make convertible or
constructible in some way
of string_view.
(audience member speaking quietly)
You can construct a
string_view from a std::string.
(audience member speaking quietly)
So the question is if you try
to construct a string_view
from your string representation
that doesn't have a null
terminated character,
will that work?
I believe, yes, I believe it will, yeah.
std::string_view won't
check that the string,
that it's been constructed from
has a null terminating character,
or do anything in that nature.
So it's not, is that incorrect?
(audience member speaking quietly)
But if you were to construct
it from a pair of iterators,
it's not going to, yeah, yeah.
so I should clarify,
if you just give it a single
pointer to a single char star,
it will read until the end
and look for a null terminating character.
But there are other
constructors you could use,
like there's a constructor that just takes
a pair of iterators that if you had a,
if you had an internal
string representation,
that was not null terminating,
but there is the, the
constructor that takes a single
char star will look for,
will assume that it's a
null terminating string
and look for the null
terminating character.
Thank you, Nico.
All right.
I think we're gonna move on,
if there's more questions on this,
let's save them 'til the end.
All right, so next, I want
to talk about std::optional,
so again, with this like to_int API,
so what do we do if the
conversion from this
string_view to an int fails?
Well, there's a couple options.
We could return a default
constructor end on parse error,
we could throw in a parse error,
we could return false on a parse error,
or return zero on a false error,
we could return null on the parse,
like return a null, a unique
pointer on a parse error.
None of these options I think
are particularly attractive.
In particular, this last one here,
where we're trying to use
pointer semantics to add
sort of like a state of hey,
this thing is not really valid.
So in C++ 17, we have this new
thing called std::optional,
which is a nullable object wrapper.
And so it's in this header,
#include &amp;lt;optional&amp;gt;,
and what it does is it adds a null state
to the value that it wraps.
And it provides smart
pointer-esque interfaces
for accessing the underlying entity.
So this is a little unintuitive at first,
because it sort of looks
and acts like a pointer,
but it doesn't actually
ever do any allocation.
So it doesn't heap allocate,
it owns its contents.
If you give it an optional T,
it's just, T is just gonna be
a data member of the thing.
And copying it's gonna
be, if T is cheap to copy,
then copying an optional will be cheap.
And passing style, if
you pass Ts by reference,
you might want to pass
optional Ts by reference
in you pass Ts by value,
then you should pass optional Ts by value.
Optional isn't just
useful for error handling.
There's a wide ranges of use cases.
I keep discovering or being shown
new ways that you can use optional,
so let's talk about a few of those.
So first, this is what the,
using an optional and that two
int example would look like.
So first, I got my std::optional here,
we're gonna try to,
I think I'm going to return
this one if I have no int,
and then I go and try to
use stringstream to try to
extract out of that string
and int, and if I do,
I go ahead and assign it to this optional,
and if I don't, I just return
the default construction optional,
which is in the null state.
So if you just default
construction optional,
it will be in the null state.
So it's useful when you're
working with types like int
which you can default construct,
but they'll be in sort
of this invalid state
where who knows what the
value that int could be?
It's also useful when you're
working with types that might
not even be default constructible.
So, I have this one example
from a project I've been working on,
we have this function depend
that retrieves a value
from a future using .then,
and the idea here is that
the lambda passed to .then
stores the value of the future,
which is passed as the
argument to this lambda
into some variable r
here in the outside scope
that's captured by reference,
so this lambda captures r by reference
and then it assigns it the
value from the future here.
And when I originally wrote this code,
this wasn't an optional, and we,
at some points, this was used with a T
that was not default constructible,
and then the code broke because
I was trying a default constructor T here,
and it was really just because,
I was gonna assign to this object r here,
but I needed to have like a null state,
because I needed to have a state,
I needed it to be, to exist
before I was gonna assign to it
'cause I was gonna pass
it into this lambda here.
So I don't know if Mehow is still here,
but one of my colleagues was like,
&quot;Oh, just make it an optional.&quot;
And then when it's an optional here,
it's added this null state
so I can default construct it
and then pass it in, and
then at the end here,
I just dereference it,
dereference the optional
and move the value out.
And then this will work for my types
that are not default constructible.
Yep?
(audience member speaking quietly)
Sorry?
(audience member speaking quietly)
That's possible, I'm
gonna take a step back.
Which one, this one?
Yep.
Yeah, you're right this one should be,
take two int and then have
an int reference parameter
and return a bool.
(audience member speaking quietly)
Yeah, that is, that's just
because I'm reading it
into the stringstream here,
but I'm checking whether that's,
I'm checking whether
whether that's valid here.
I see what you're saying,
but the idea here is not
that I'm not default constructing an int.
(audience member speaking quietly)
Oh yeah, I could have, yes,
I could have used selection statements,
the if init condition here, yeah.
I think that's right.
Yes.
(audience member speaking quietly)
Oh, okay.
The question is, can I
define two variables in,
I don't believe, of different
types, I don't think so.
I don't believe so, I
don't think you could have,
I don't think you could both have an int
and a std::stringstream in
the init section here, no.
I have the,
I think it's the same problem where
you can't have more than
two in an, sorry, what?
(audience member speaking quietly)
To have just the option?
(audience member speaking quietly)
Yes, then you can take
this stringstream out.
You can have one of them in
the init statement there.
You can't have multiple,
ones of different types
and their size there.
Okay, any--
- [Audience Member] If
you constructed by ints,
could you then get multiple variables?
- The answer is yes, if you use,
if you wrapped up all the things
that you wanted to
initialize into a tuple,
yeah, that would work.
- [Audience Member] I
think you could do it.
- Yeah, if you used a temporary tuple,
yeah, that would work.
Okay, there, we've found a way.
(laughing)
Okay, all right, any other
questions on how we can use
if init conditions?
Same text here?
- [Audience Member] What's the
space overhead of optional?
- What's the space overhead of optional?
That's a good question, it's gonna be,
depend on your implementation.
It's not gonna be nothing,
but it's gonna depend
on your implementation
and alignment requirements,
I would assume.
(audience member speaking quietly)
Right, right, but then
you have to think about
alignment requirements too.
So yes, it is at minimum one bit,
but it's gonna be more than that
because of alignment requirements.
And it's never going to be nothing.
Your implementation is not
allowed to specialize it
for types where maybe it
thinks there's a way to
represent that state and some unused bits
of the actual underlying type,
so it doesn't have any hacks for pointers
or anything like that.
Yep?
- [Audience Member] Can you
use an optional as an optional?
- You can and we've had,
so the question was can you
do optional of optional?
And I've had conversations
with people about whether
optional of optional is useful.
I think if you're making
optionals of optionals,
then it means that like you've got,
you want to have more
than just one extra state
that you add and there are
better ways to do that.
But yeah, you can do that, it works,
you can have optionals of optionals.
All right, other questions on this?
Okay.
I'm gonna skip past this one because
that's got a lot of things
that we just talked about.
So one of the other use cases
that I like for optional is
using optional to express
optional parameters to functions,
instead of having default parameters.
So like here, this slice function,
and I have use examples of it,
maybe I don't, where I want to
have with a start and an end,
both of which could be sort of unprovided,
so like you could just
brace either one of those
and that would be fine,
but I don't want to have
them be default parameters
because I'd like you to,
there isn't one of those that seems like
a natural fit for me to
be the default parameter,
so I'll always make you
specify all of them,
but you can just brace init
one if you just want it to be,
to just default to the start
or the end of the string.
And so that's where you might
you want to use optional
as sort of a way of having named,
but defaulted parameters.
All right, next up,
let's talk about variant.
So, yep?
(audience member speaking quietly)
So the question was, if you
default construction optional,
it is the value std::nullopt?
(audience member speaking quietly)
I'm not sure.
(audience member speaking quietly)
Yeah, I'm not sure,
I think we'd have to
talk about that offline.
Yep?
(audience member speaking quietly)
Sorry, can you repeat that one more time?
(audience member speaking quietly)
So the question is do you need to provide
the optional arguments here?
Yeah, you do, because they're
just regular arguments.
So you do need to provide
the start and the end arguments here.
You need to call this
function with three arguments,
it's just that what I,
instead of just having these be ints,
where like there's a special
value like if it's zero,
I'm just having, I want
an int with an extra state
where the state can be that it's not zero
but it's this nullable state.
Yes?
(audience member speaking quietly)
The comment was that
you should use std::none
to indicate the default
state for std::optional.
And I'll take that on
faith, I'm not sure myself,
but I think that's correct, yeah.
Any other questions?
All right, let's keep going.
All right, so variants.
So before C++ 17,
working with discriminated
unions was not easy.
We had this thing, union, from C,
but it's kind of a pain to build anything
that's type safe with it.
So like for example here,
I'm trying to create a,
basically the equivalent of like a variant
with three different states,
where I have this type where
I want it to either be an int
or a double or a string and
be able to switch between
being one of these three things.
There's a lot of places
for possible bugs here,
and then for a lot of
maintenance overhead,
like let's say that I add
a bool type here later,
but I forget to add a
bool to this state type.
And I've actually written
one of these things
many years ago for a large
software project, and we started off with
three different states,
and by the time I left,
there was 20, and the enum was quite long
and it was just a giant source of bugs.
And also there's questions
about when you're using unions,
do these constructors and destructors
get run when you when you
switch between states?
And no, they're not going to,
so union's not really,
not really something that
you should be using in C++,
it doesn't really respect
the rules of types in C++.
But it would be useful
for us to have a facility
for representing variants,
and now we have one in C++ 17,
and it's called std::variant.
So if I want to have this
convert function here
that converted a string from
some representation to either
a bool, int, or a double,
assuming that it fits one of those.
You can just write
std:variant, bool, int, double,
std::string, and std::variant
will be an object
of one of these types.
So it's a discriminated union.
So it's in the header &amp;lt;variant&amp;gt;.
Its interface is similar to Boost.Variant.
Some of the semantics are a bit different,
and its access uses the visitor pattern,
and I have some examples of that,
so it's not, it doesn't
use a heap allocation,
and it owns its own content.
And it's like, if you would want to copy,
if copying is cheap
for all of these types,
then copying will be
cheap for the variant.
And if you pass, if you
would pass all the types
in a variant on a reference,
then you might want to
be passing those variants
by reference instead of by value.
And it's just a variadic
parameter pack here,
so you can have as many
things in there as you like.
So here's an example of visitation.
So what I've got is this
multiplier visitor here,
so it'll take, it's got
three different overloads
for its call operators, each
of which takes some thing
and turns it into something of that type
that's been multiplied by one,
so like here, for the string, it'll take,
if you give it a string and
it will duplicate that string.
And then for an integer,
it'll just multiply it by n
where n is whatever this
template parameter is.
And for the array, it'll
just multiply each element
of the array by n.
And then the way that you use visitors
is with this std::visit function
where you provide it with a
callable that is overloaded
for all of the types
in your variant, or
whether that can be called
with all the types of your variant,
it doesn't need to be overloaded,
it could be a call
operator that's a template,
and then visit will call
the call operator with the type
that the variant is currently in.
So here, I've got a
variant where it's an int,
so it will call this call operator here.
And then if I assign a string here,
it will call this first
call operator right here.
Now all of it needs to be,
it will instantiate calls for
all of the different options
of course, because it needs
to dispatch at runtime
to the correct one.
You can write visitors a
little bit easier in C++ 17
with if constexpr.
So here I am, instead of
writing a separate struct,
I'm writing the same thing as a lambda
and just using if constexpr
to pick the right operation,
and then a static assert
here if it's some other type.
And there's also a nifty
little trick you can do
with variadic using declarations,
which is a language
feature I didn't talk about
in the first part here,
but I've got this this
struct overloaded here which
inherits from all of
the template parameters
that it's passed to,
and then it does this
variadic using declaration
of the call operators of all
the things that inherits from.
And then there's this
deduction guide here,
so that it's basically just
a quicker way of writing this
without writing a constructor.
And then what you can do with this
is you can brace initialize
this from a set of lambdas,
and then this overloaded object will
have a call operator which
is like an overload set
of all three of these.
Yeah?
- [Audience Member] Why we
don't pass an argument here?
- Why we don't--
(audience member speaking quietly)
Well, for right here, where it's called?
- [Audience Member] Yes.
- Well, the string, oh yeah, you're right,
there should be an n there, yeah.
That's a bug in the slides.
So yeah, there should,
I should have angle brackets
n right there, yeah.
So this is sort of my preferred
way of writing visitors
because it's nice and fairly clean,
and I don't like, if
constexpr is nice and all,
but I think this is a little
bit nicer to work with.
And there is gonna hopefully at some point
be a function called std::overload,
which would sort of work like this,
but be a little bit cleaner.
And this only really actually,
only works for things with call operators,
not for any callable.
All right, so another place
where variants can be useful is
if you're writing
recursive data structures,
for example, like a binary tree,
so here, I've got, this is
my binary tree structure
and then I've got this
branch node type here
where a branch is gonna have
a shared pointer to a left,
a shared pointer to a binary tree
for representing the left branch
and then another one for the right branch,
and then the tree itself is a variant
which is either the leaf type,
so the actual data type
that we're storing,
or one of these binary
trees, branch elements.
All right, any questions on variant?
Yep?
- [Audience Member] So let's say,
you have a variant int long, or short.
- Yep.
- [Audience Member] So my
variant doesn't necessarily
have to have all three at once?
- Right, so the question was,
let's say that I have a variant
of int, short and double.
And does my variant visitor,
doesn't necessarily need to
have an overload for each.
And that's correct, all
that what needs to be true
is that you need to be
able to instantiate a call
for each one of those types,
that the callable that you
give to visit needs to,
you need to be able to actually
make that call to each one.
So it could be that it's
a template function,
it could be that there's
set of implicit conversions,
that will work, but even if the variant
is not in one of the states,
the variant's gonna be in
the nth state, let's say.
When you call visit on it,
the call for the short
state and the double state
still need to work because it's,
the compiler is not gonna
know at compile time
which one it's gonna actually be made.
Does that make sense?
Okay, any other questions?
(audience member speaking quietly)
Right, it also needs to
be non-ambiguous, yes.
Other questions on variant visitation?
Okay, great.
All right, the next
category type to talk about
is std::any.
So what std::any is is it's a
generalized type erasure facility.
So what if you want to have
like a heterogeneous vector?
Well, you can use std::any to build that.
So right here, the std::vector of std::any
can store any object.
So I can put a string in
there, I could put a tuple,
I can put ends, I could put
std::vectors of std::any.
And then that.
So it's in this header &amp;lt;any&amp;gt;.
It's type erasure for copyable objects.
There are four main operations
you can do with any.
You can copy them, you can
assign them some value,
a value of some type T,
you can ask whether an any contains
a value of a particular
type, so you can say hey,
do you have an int right now?
And you can then retrieve a
value of some type T using
this any_cast function.
So any's will store the memory heap,
they own their contents,
and you should probably pass
them by reference because
they're being stored on the heap.
All right.
Okay, oh, any questions on this?
- [Audience Member] Can
you store a non-copyable?
- Can you store a
non-copyable type in any?
I'm not sure.
Yeah, I'm not sure.
I would have to check.
If you come up and ask me
later, I will go check for you.
Okay, next up, I'm gonna talk
about my favorite feature
in C++ 17, the parallel algorithms.
So pre, or prior to C++ 17, we had
concurrency primitives
and sort of low-level
parallel primitives in C++,
but we didn't really have
any high-level interfaces
for expressing parallelism.
So something like this, like
an OpenMP parallel for loop,
we didn't really have any
standard way of doing this.
Now in C++ 17, we do.
So the model is parallel
versions of all of the existing
standard library algorithms.
So something like for each,
the parallel version of that will have,
it'll have the same interface,
except that the first
argument will be this thing
called an execution policy.
So this is one of the three that are in,
the three execution
policies that are in C++ 17,
and it indicates what type of
parallelism is allowable for
the operations and the datatypes
that you're passing in.
So this would be roughly the equivalent
of what we've written here on the left,
with OpenMP parameters.
So this is a serial sort,
and then this is what
a parallel sort would look like in C++ 17.
So for all the algorithms,
it's these new parallel
algorithms, the same API,
except the first parameters,
this execution policy thing.
These algorithms live in the
same places that their current
route algorithms live,
so algorithm and numeric,
and the execution policies
are in the &amp;lt;execution&amp;gt; header.
The input iterator
requirements for any algorithm
that currently has an
input iterator requirement,
the parallel version
bumps that requirement up
to forward iterator, because
that alleviates a lot of
implementation concerns.
We're not really sure how to parallelize
a number of the algorithms
for input iterators,
so we decided to bump up
the requirements for 17,
and leave that design
space open for the future.
And the complexity guarantees are relaxed
for some of the parallel
versions of algorithms where we
don't believe that there
is a way to implement
the algorithm in parallel
with the same complexity guarantees
that are given in serial.
And there are some new algorithms
that are designed for
parallel programming,
so there's reduce, inclusive_scan
and exclusive_scan,
and then there is these
three fused algorithms,
transform_reduce, transform_inclusive_scan
and transform_exclusive_scan.
So the execution policy parameter,
it sort of describes the how of execution,
so, it answers the question
is parallelism allowed,
what restrictions must be
respected by the algorithm?
And at some point in the future,
this facility will be
integrated with executors,
which is a richer way of describing
where work should be created
on what resources should,
executors be created that
is hopefully being planned
for C++ 20 and there's ongoing work
on a technical specification for that.
And right now though there's
three execution policies
in C++ 17.
There's std::seq, which indicates that
you don't want any parallelism,
you just want sequential execution.
There's std::par for parallelism,
without any of the ordering,
so SIMT systems, like GPUs.
And then std::par_unseq,
which is for parallel
and unordered execution,
so something like a SIMD
system where you would want
thread parallelism and
also vector parallelism.
So the difference between
std:par and std::par_unseq
is that with std::par,
operations are indeterminately sequenced
with respect to each other
within the same thread.
With std::par_unseq, the
operations are unsequenced
with respect to each other
and they may be interleaved.
The interleaving is the key thing here
that basically std::par_unseq says that
you're giving permission for
your process function here
to be interleaved, because normally,
the library would not have
capabilities to go and say,
hey, I'm just gonna leave this function,
to interleave this function
that that this user gave.
So let's see, we've got
a few examples here.
So these are some examples
with some of the new parallel algorithms,
so this is how you'd write
a serial dot_product in C++.
Just, I got two vectors, I
want to do x[0] times y[0],
yada yada yada,
and with the new algorithms,
transform_reduce,
you just write this.
And so transform_reduce
does a transformation,
to apply some unary operator,
or some binary operator in this case,
and the default is to do multiplication,
and then it reduces the
sort of pseudo sequence
that's formed from the transformation.
So that would be the the plus operator,
which is the default there.
So this is a parallel
dot_product in C++ 17.
And let's see, do another one.
And then this is a version with,
so this is the full version
without any of the operators
defaulted of transform_reduce,
and this is the unary version
so the execution parameter,
and then this is the input
sequence, initial value,
and then this is our reduction operator,
which is addition here, and then here,
we're doing a vector norm,
so the transform
operation is just squaring
whatever the input is here.
So this is just examples from the new
transform_reduce algorithm.
Any questions on this feature?
Okay.
So next feature, the file system library.
So prior to C++ 11, there
was no standard support
for file system access or querying in C++,
and depending on the system you're on,
these APIs can differ greatly,
and I think they tend to be quite ugly.
This is what copying a file
in a directory looks like
with the windows APIs.
And I've always hated these,
especially given that they're
quite different APIs for what,
for operations that seem like
they should be quite similar.
In C++ 17, you can do
this in a portable way
using the new file system library.
I should note, this FS here,
I'm just using as an alias
for the full name of this namespace,
which is std::filesystem, which
does not fit well in slides
and it's a little bit unfortunate.
But so this is not only I think portable,
but it's more user-friendly.
So it's contained in
the &amp;lt;filesystem&amp;gt; header,
and as I mentioned, that's the convention
I'm using in these slides,
and a lot of people have been using.
It's based on Boost.Filesystem.
The interface is primarily
non-member functions
operating on path objects.
So the sort of the main primitives of this
is the path class.
And then there's directory_entries
and directory_iterator
for moving through directories.
And then file_status is
the platform agnostic
representation of metadata.
So there's four major sort
of classes of operations
that you can do with
the file system library.
There's path creation, manipulation,
directory iteration and recursion.
And then file and
directory metadata query,
creation, removal and modification.
So this is an example
of what it looks like
displaying the contents
of a path in C++ 17,
and this is not recursive
because it doesn't fit onto a slide,
but basically we take the
path and print off the path
and then if it's a directory,
if it's not a directory, then we're done.
If it is a directory,
we go and create a
directory_iterator from the path,
and then we iterate through
each thing in the directory
and we'll go and print off the size
using one of the metadata query functions.
So there's a fairly large and rich API,
not something I can cover
in sort of an overview talk,
but it's worth going and taking a look at.
The interface is sort of,
it's not that it's based on POSIX,
but the Boost.Filesystem API
draws a lot of inspiration
from the POSIX API, and then
maps other file system APIs
on to those interfaces.
Yep?
- [Audience Member] Are there
important differences between
the standard file system
and the Boost.Filesystem
that some of us are familiar with?
- The question is are
there differences between
the standard file system library
and the Boost.Filesystem library?
The answer is I'm not 100% sure,
but I'm almost positive
there are differences,
and I believe some of them are notable.
If you want, we can talk
a little bit afterwards,
but I'm not certain on
all the details of that,
but it's worth looking at,
you shouldn't assume that's the case.
Yes?
(audience member speaking quietly)
So what Nico pointed out
is that even if your code
still compiles after just
changing Boost.Filesystem
and std::filesystem, the behavior
might be different because
while we've kept APIs in some places,
the semantics have not
necessarily been kept,
even if it's the same APIs.
So don't assume that
it's the same library.
Yes, question there?
- [Audience Member] What
kind of strings are used
as the basis for file
strings or wide strings?
- The question is what
type of strings are used
as the basis for files
strings or wide strings?
(audience member speaking quietly)
I'm not certain.
I believe it's platform-dependent.
I'd have to check though.
I'm not certain.
Other questions?
Okay.
How much, how we doing on time?
Okay.
All right, so next I'm gonna talk about,
the polymorphic allocators in C++ 17,
and I'm not gonna talk a lot about this,
but fortunately, there are
five talks about allocators
this week at the conference.
So if you want to learn
more about allocators,
there's plenty of content.
So before C++ 17,
the old allocator model we had
caused an explosion of instantiations
of all of our allocator-aware constructs.
So if you have a whole bunch
of different allocator types
using your program, you would
need to have a whole bunch of
different instantiations of std::vector.
And this can be a problem
once you have a fairly large code base.
So in C++ 17, we have a
polymorphic allocator type
that type erases a
abstraction of a memory allocator.
And the abstraction, it's this
thing called memory resource
and I have another slide on that,
and you can implement your own,
there's also some that are
provided by the standard.
So there's a, I think I
actually have a list here.
Yep.
So there's a new delete_resource,
which just uses the global new and delete.
There is a unsynchronized_pool_resource,
which is the thread-unsafe memory pool,
and there's a thread-safe memory pool,
and there's a monotonic_buffer
memory allocator.
And so all, all of these
live in the pmr namespace,
and also in the pmr namespace,
there are aliases for all of
the standard library constructs
that are polymorphic-aware.
So std::vector, int,
std::pmr::allocator&amp;lt;int&amp;gt;
is std::pmr::vector.
And so that what this,
this gives you the
capability of having just one
vector type that you're
using in your code base
that has different types
of allocators backing.
Okay.
We're gonna skip through that one
because we're a little short on time.
Okay, so improved insertion
and splicing for associative containers.
So map,
multimap, unordered_map
and unordered_multimap
now have try_emplace and
insert_or_assign functions.
So these interfaces are
designed to make it easier
to deal with operations on
maps that access existing keys.
So emplace, which is a pre-C++ 17
map API, if it takes the key, the value,
if the insertion failed,
was this p moved here?
And would you still be able to,
would you be able to go
and move from this p here?
try_emplace guarantees that
if the insertion fails,
p wasn't moved, and insert_or_assign
returns the info as to
whether the insertion failed
as a pair of iterator and bool here.
So that you don't have to wonder,
did this operation here actually
insert or assign this key?
And what iterator is the key at?
It gives it back to you.
And we also now have a way to merge maps.
So if you have a map, if you have two maps
and you want to merge them,
you can just do m0.merge(m1).
And the merge doesn't
overwrite existing keys.
And I have the complexity guarantees
and notes in the slides if you want them.
I'm not gonna read them out though 'cause
it's kind of difficult to read them out.
And this is for all the
associative containers.
And, yep?
(audience member speaking quietly)
Sorry, not that this move doesn't happen,
but whether the thing is
actually moved out of,
by the operation whether, if the,
if it can't insert it, does it
actually consume the objects?
(audience member speaking quietly)
Sorry.
I think you're right.
Yeah, that should not be moved,
that should just be a
p there, yeah, sorry.
My apologies, you're right,
that should just be a p there.
Yes.
Okay.
Merge, let's see.
Ah, this last one, so
there's also now interfaces
for the associative
containers to do node-based
insertion and extraction.
So you can take a node out
of one associative container
and insert it into another one.
So the APIs, you can do
like this .extract function.
And there are type defs in
the associative containers
to an implementation to find
type that is the node type.
And that node type,
you can do a few things
where you can get the key,
it doesn't expose too many
implementation details.
And then you can move nodes,
you can move from one map
into another map, for example.
You can't move nodes between
containers of different types,
of course.
I'll see, we got a
couple other quick ones.
So the special math functions,
which were on a separate
international standard
that's been around for a few years
are now part of the main C++ standard.
So they're in the &amp;lt;cmath&amp;gt; header.
And it's this list of math functions here.
And, all right,
variable there now, these
_v variable templates
for metafunctions.
These are defined for all the type traits.
So right here, instead of writing
std::is_integral&amp;lt;T&amp;gt;::value
you can just write std::is_integral_v.
That's nice, just a small
convenience feature.
And in C++ 11, let's say
that we wanted to write
an all integral type trait,
which is true if all the
elements in a parameter pack
are integral and it's false otherwise,
I commonly run into this pattern
when seeing on parameter packs.
And we now have this
bool constant in C++ 17,
and this is pretty convenient.
You can use this and fold expressions
to express this same pattern right here,
although this bool const,
this won't short-circuit properly.
And,
oh, what's going on here?
Yes, so there's these boolean
logic metafunctions as well,
so because this one will
not short-circuit properly,
there is a std::conjunction
metafunction that will.
And we also have a std::disjunction
and a std::negation.
And they're the moral equivalence
of these operations here.
And, all right, that brings us to the end
and I think we're pretty much out of time.
So if you have some questions,
come up to me afterwards.
(audience applauding)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>