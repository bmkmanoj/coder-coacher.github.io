<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Alan Bucior “Building Better Worlds: Developing a Procedural City Tool for Alien...” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Alan Bucior “Building Better Worlds: Developing a Procedural City Tool for Alien...” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Alan Bucior “Building Better Worlds: Developing a Procedural City Tool for Alien...”</b></h2><h5 class="post__date">2017-10-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/F9tGa-hbmTU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Hi everyone, I'm Alan Bucior.
I am a lead software developer at
the CG software department
at Moving Picture Company
or MPC in Vancouver, Canada.
I've been at MPC for about,
little over two years now
and before that I spent about 18 years
in video game development.
This talk is gonna be
a little bit different
from most of the other
talks here at CPP Con.
I'm not going to be talking C++ 17
and I'm not gonna be talking about
new tech plate
meta-programming techniques.
It's not even gonna show
you any code, unfortunately.
What I really want to talk about is just
how C++ is used in visual effects.
You don't really hear much C++ in film.
It was mostly discussed
in other industries
but C++ does really play a key,
an important role in the creation
of most of the big features that are
in films that are in theaters today.
Structure of the talk: who we are,
a little bit how we use C++,
then we'll get into the bulk of the talk
which is about our project called Machi,
what it is, how it's sort of structured,
and I'll dig into a few of
the interesting technical
and artistic problems
we met along the way.
Then we'll talk about what we're gonna
be doing with it in the future.
By the way, I stole some
slides from the marketing guy,
so if you want to play like which of
the marketing guys slides,
I'm cool with that.
(laughter)
This is a marketing guy slide.
When you think about
visual effects companies,
there's probably a few that come to mind.
Unfortunately, outside of
the visual effects industry,
most people, a lot of
them haven't heard of MPC.
We're actually one of the
largest VFX companies out there.
We work on many of the
biggest films each year.
We've got nine locations in the world,
five of which are focused on film.
I say one of the largest,
it's possible depending on
when you ask and what metric
you use, we may be the largest.
But I'm not gonna claim that today,
I'm just gonna say, we're
pretty big by VFX standards.
We work on a lot of films,
sometimes only a few shots
and at the other end of the spectrum,
we'll do almost the entire film.
We've done a couple of,
we've won a couple of Oscars
for the best visual effects.
The first was in 2013 for Life of Pi
and just this year we won for Jungle Book.
We did about 90 percent of that film.
On top actually, up there,
that's my favorite scene
and before we talk about Alien,
I want to talk about this scene.
I mean, how much of this is CG?
(crowd murmuring)
Almost all of it.
I mean, the only thing that's
not CG here, is the kid.
(laughter)
That's it.
I mean, it's kind of crazy.
Think about what went into this scene,
like the background there with all
that foliage in the jungle.
All of that was placed by an artist
but it was placed using
procedural techniques.
The water, there's fluid
simulation going on.
Every strand of hair in the fur,
that was generated procedurally
using artists creative guide curves.
And of course, one of the
things to note is that
the water actually floats
correctly under the water
and it mattes down
correctly above the water
and it's all sort of rendered
using shaders and so forth
that make it look really realistic.
There is a huge amount
of code going on here
and a lot of it is C++.
And by the way, not
all of the kid is real.
Look at the legs.
CG legs.
I don't know why.
(laugher)
I have no idea.
(laughter)
Yeah, so first, I want to
talk a little bit about
what languages we use
here at, or use at MPC
and how C++ is really
at the core of it all.
We use C++, Python, those
are sort of our big two,
Lua and Fabric Engine
are in there as well.
You probably haven't heard of
it, much about Fabric Engine,
so I'll just give you
a quick introduction.
It's an application programming framework.
It includes a textural scripting language
that's fairly high level.
It's got some, it has an LOV on backend
which allows it to run, generated fast
or native code and run fast,
and it also has some really
convenient semantics built
into the language for parallelism
and general purpose GPU acceleration.
It's kind of meant to
bridge the gap between
a scripting language
in terms of simplicity
and a compiled language in terms of speed.
I should also mention, well
actually, I won't mention it.
I'll talk about it later.
So, underpinning everything at MPC,
we have a library in C++
called Muggins, it's a,
and we also have a bunch
of simulation codes.
That really is where the
bulk of our C++ code ends up.
The simulation code is things
like Alice, our crowd engine,
Kali our destruction engine
and Furtility, our hair system.
Muggins on the other hand
is just a generic library
that we use throughout
most of our code at MPC.
It's been a core
component of our stack for
about ten years now and it's
been used on hundreds of films.
It provides a bunch of
useful functionality
and abstractions like various data types,
all the way from vec3 up
to (mumbles) geometry,
geometry manipulation
routines, math libraries,
custom data serialization
formats and importantly,
it includes something, a
rendering abstraction layer.
That allows us to render to a
variety of different targets
such as OpenGL or Pixar's RenderMan,
using the same higher level code.
I can't show you Muggins.
If you're really interested
in this sort of thing
there is actually a open
source library called Cortex
which is very similar.
One of the original
Muggins developers went to
a company called Image Engine and he made
an open source version of, well,
an open source visual
library called Cortex
and it's, it shares a lot
of the same design choices.
So if you're interested
in this sort of thing,
check that out 'cause it's open source.
So, we have a lot of languages.
We also have a lot of bindings
between those languages.
That also means actually,
we have a lot of code
to help automate the
creation of those bindings.
In the middle, we have Lua.
That is really the
business logic around most
of our complex data types and
how we get that data onto the screen.
It binds mostly down into
C++ through Muggins and uses
that rendering abstraction
layer quite substantially.
It's high level enough
that a technical artist
can contribute to it
and it gets from behind
the scenes in a lot of different places.
It really only binds down to C++ though.
We also have Python.
Now, a common pattern at
MPC is we write the stuff
that needs to be fast in C++
and then we wrap Python bindings around it
with Boost.Python and then we control
the higher level code in Python.
We also use it for a lot of
stuff like UI and pipeline code.
And of course, we have
Fabric Engine over here,
which I talked about earlier.
It mostly just binds down to C++.
We also have some
bindings back into Python
for our asset management system.
I should actually also mention you know,
I'm using a Mac here, we use almost
strictly Linux in our development.
I don't know if that's
interesting to you or not.
So, we talked a lot about languages.
Let's talk about aliens for a little bit.
We began work on Alien Covenant.
We knew there was gonna be a big city
in the film, the Engineer's city.
We even had a concept
image roughly showing us
what it was gonna look like.
We've done a fair bit of work in the past
with cities on a number of different films
but this was looking like
it was gonna be bigger
and with a lot more detail
and a lot more shots,
so it was kind of scaring us a little bit.
We knew the rough parameters.
We knew it was gonna be from
a few thousand buildings
to maybe tens of thousands of
buildings, circular in shape,
but maybe with some
organic bits at the edges.
There was gonna be districts so that,
that meant more residential here,
maybe more temple oriented
here, something like that,
and we wanted to basically
have a few key hero buildings
that we wanted to place in the world,
for example, a giant cathedral
or something like that
and we had to build our
city around that regardless
of what we chose for the
shape of the city otherwise.
The concept art was only
gonna be a rough guide.
We wanted a way to experiment
with various city looks
and layouts without
requiring an army of artists
to manually place buildings
every time we iterated on them.
We needed a very quick
iteration cycle, you know,
build the city, get some
feedback, do it again really fast.
So, programmer slide, by the way,
not marketing slide (laughs).
Next we had to choose, do
we use an off the shelf tool
for this or do we write our own?
There were plenty of like,
toy programming examples
out there and some really
interesting plugins
and then there was CityEngine
which really, you know,
it's a tool designed specifically
from the ground up for generating cities.
Unfortunately, our artists evaluated it.
There was a couple of reasons
we didn't end up using it.
One was that it was
really, kind of centered
a little more around urban planning
and less around creating alien cities.
(laughter)
And the other one was,
one of my favorite aspects
of CityEngine which is CGA shape grammar.
For those that don't
know anything about it,
it's an amazing language that
the CityEngine team developed.
It's a way to define
parametric architecture
through shape transformations,
but to an artist
it's all textual and to an
artist, that's really daunting.
That's just not how they want to work.
So, they asked us to deliver something
that was really artist focused
and had really creative inputs.
You know, buy or build is the,
sort of the question that you pace a lot.
We definitely have sort of a proudly
not-invented here attitude at MPC.
We try to use third party
software where we can
but there are times when it makes sense
for us to write something new.
We wouldn't write Maya again, for example.
Kali, our destruction toolkit
is a really good example
of that and we won a (mumbles)
Academy Award for that.
But in this case, some of
the advantages included
the flexibility for us to
be able to make the tool
that exactly what the artist wanted,
the opportunity for it
to, for us to integrate it
with other aspects of our
MPC pipeline and tool set,
and in general we
consider ourselves to be,
one of our core strengths
is to be proceduralism.
And looking further ahead we said,
we keep on getting more and
more requests for CG cities,
we would like to perhaps
spend the time, you know,
these cities keep getting
more complex and complex.
Maybe now is the time to
spend, investing a little bit
in just starting the
road towards developing
our own toolkit for creating cities.
I was brought onto the project.
Shamus Young has an excellent series
of blog posts describing how to create
a city completely procedurally without
any artist input at all and
I was just so taken by that,
that I decided to create
my own version of it,
but then I decided, I don't know,
just go a little bit different
and I started researching
road layout, algorithms,
and I came across Yoav Parish
and Pascal Muller's
papers on city generation.
For what it's worth,
Pascal Muller was the guy
who went on to create CityEngine.
I felt confident that I could at least
come up with something that would work.
So, what we came up with
was a tool called Machi,
that's our logo up there,
and Machi is a Japanese word.
It means town or street so
it was, seemed appropriate
and suitably confusing and non-descriptive
as is the fashion in application naming.
This is a very early iteration of Machi.
This is, what I want to show
you here, the bottom here,
this is running inside
of Fabric Engine's canvas
node graph visual scripting tool.
Each of those blocks on the bottom here
essentially corresponds to a C++ chunk
of code like procedure.
And so, by putting these bits together,
the artist can build a city.
We ended up not exposing that
to the artists in the end.
What they wanted was something
a little bit more dynamic,
so we got rid of the node
graph and we created this,
I like to call it a task
focused UI basically.
It's a traditional UI really.
We're gonna get back to this question
of whether that was a
good decision or not,
but the main point to understand is at
this point we're still using
Fabric Engine actually here.
We've just hidden the node UI
and we've added our own UI into it
and we're using Fabric
for the actual rendering
but all the core stuff underneath is C++.
So, there's quite a few layers here.
(coughs) Excuse me.
So, I should,
we basically have a Python
layer at the very top.
This is really a different way of doing,
by wrapping everything in Fabric Engine,
we're doing this a little bit differently
than how we typically do things at MPC.
Typically, we take C++
and we wrap it in Python.
Here, we're wrapping things in KL,
wrapping our C++ in KL
and then we're wrapping
that inside of Canvas and
then having Python control it.
This was a bit of an experiment at MPC.
We haven't done this before.
This was just sort of a, you know,
we're trying to figure out if
this is a good way to make applications.
Anyway, yeah, we have a Python
layer which controls the UI.
We have that it layer in red there,
it's Fabric Engine Canvas script,
it's just a very small node based layer
which hides and glues a
lot of the bits together.
We have two layers that
were written in KL.
One is just really to
communicate with the view port
and do things like selection
and manipulation and rendering.
And then we have MpcMachi
which was a thin wrapper
in KL around the C++ code
and all the really good stuff
was in C++ where we
have things road layout,
trying to figure out where blocks are
for each of those roads and
then breaking those blocks
into lots and then putting
the buildings onto the lots.
Of course, all this
required a lot of bindings
between languages and this was at times
a point of frustration for us,
but the rationalization was
that if we could figure out a way to get
these Machi libraries wrapped in KL,
any application that
supported Fabric Engine,
we could then drop it into
it and have the functionality
to create cities regardless
of the application.
Now to begin with, we just
used the Native Canvas editor
as our sort of hosting
application but intention was
that we would use it in other applications
like Maya and Houdini later on.
Back to the original problem.
How do you layout a city procedurally
but still keep it artist friendly?
I think the first thing to keep in mind
is automation is not necessarily
an either or proposition.
It can be a continuum.
So, artists would love to
be able to press a button
and it's done, there's
my city but you know,
typically their gonna want to edit things
and the director is gonna
want to make changes,
so we had to be in the mindset
of allowing changes at any point really.
To this end, we wanted
to keep our automation
in small controllable chunks
and allowing the artist
to take control at any
point and make edits
to the data as they needed it.
Problem is this becomes a
little bit of a liability.
What would typically happen in a show
is you would layout
you're high level streets
and then you'd create your buildings
and then the artist would
say, okay that building
wants to be, maybe I'll change the number
of floors on it, for example.
Now the director comes
along and says, okay,
the city is not gonna be
circular, it's gonna be square.
So, go back to the beginning,
layout the streets again,
create the buildings again.
What happens to that one
building that you just edited?
Now in many cases, it's fine.
You can just throw it
away and start again.
But in certain cases, it isn't,
you actually want to keep that building.
So, in our case, we tried
a few different things.
I think the simplest and
most helpful approach for us
was just to let artists
lock down data at any point.
You could say, I don't want
to change this building
or this road and then what we
would do is we would clear out
everything else, regenerate
the city and use that data
that was locked down as
seed data to build off of.
We'd actually, you know,
these roads are locked down,
build roads off of them
and we would go from there.
I want to talk a little bit about
the 15 second demo that we came up with.
At a big studio, artists can be skeptical
about embracing new technology.
They love their tools.
So, even if they asked for
you to develop a new tool,
you still have to convince them to use it.
So, our goal was to try and
make it as simple as possible,
something like five clicks
to actually create a city
and instead of a 15 minute tutorial,
something like a 15 second tutorial.
We wanted to show them the
power as quickly as possible
and let them explore it later.
So, we set up a bunch of
defaults and just kept in mind
as we were designing
the UI, keep it simple.
This was a huge success to getting
people excited about the project.
I'm gonna talk about an
interesting artistic problem
we faced along the way.
One of the first problems
we ran into was a mismatch
between lot and building sizes.
When we originally wrote Machi,
we used a very simple algorithm
for creating lots from blocks.
This is a, these are four roads basically.
The standard algorithm
is take the longest edge,
divide the thing in
half and keep doing that
with a little bit of random variation
until the lots are the size that you want.
The end result is very evenly sized lots.
This actually is kind of how
it works typically in a Western city.
North America, you'd often divide against
the shortest edge first so
you can get like a back alley.
But a European city you'll see
that play out all the time.
Problem is, that would
be fine for many cities,
really wasn't gonna work for Alien.
Their buildings, well,
this works great when your
buildings are all the same size
but they wanted to author
their own buildings
and they did not want them scale,
so we had a wide variety of things
that we had to place into the city
and an early test with sort
of, even just a simple,
slight changes in size
was showing us we needed
to do something about
making the city more dense.
They really wanted it to be
a tight, tight feeling city.
Our first iteration on
that was to basically try
and get a little bit smarter and to try
and think about using more of
a texture atlasing algorithm.
We wanted to decide,
here are the buildings
that we're gonna put on
the lot, on the block first
and then figure out, divide it
up so that those things fit.
And this worked kind of.
It wasn't perfect.
There was still a lot of feedback
that it was still too open.
They wanted a cramped, tight feeling city.
They didn't want the center empty areas
in the middle of blocks, that was fine
but they wanted it really, really dense.
So we went back to the drawing board
and we came up with this idea for,
we just threw out all
of the work we'd done
and said, let's just do this
dart throwing algorithm.
Let's just try and find a
random place on the block,
put a building down, if it fits great.
Move it out closer to the
road and just keep doing this
over and over until you
can't fit any more buildings.
It was embarrassingly stupid but it
was exactly what they
wanted, so that was great.
There are some downsides
to it, I won't go into it.
We don't have too much time to go into,
it ends up favoring
smaller buildings is really
the problem but we had other code
that we could use to compensate for that.
Here's an early untextured
test render showing
this sort of nice level of
density that we achieved.
Another feature we kind of
added towards the end was,
we have a scatter system that we use,
you've seen it for, in
Jungle Book basically,
it's just a system of
putting tens of thousands
or hundreds of thousands of things down
in a world really quickly,
but when they tried
to use it on the city, they realized they
were getting trees in the middle
of buildings and so forth.
So, we built this sort of
city aware scatter system
where you could drop
down trees for example
and it wouldn't be in
the middle of a building,
it wouldn't be in the middle of a road
or eventually the city had
to be a little bit decayed,
so they wanted to be able to
drop down chunks of concrete
that were within two to
three meters of a building
or pieces of shrubs that were
only on the tops of buildings
and we could support all
of that sort of stuff.
And you can see some of the
interesting variation on roads
that I've got here, this
is just some test data
that wasn't really final data at all
but I've got straight
roads, circular roads.
Up on the left there's some organic roads.
So, couple of final shots in the film.
The city was used in sort of
close to 400 shots in the film.
There was only 800
shots that we worked on,
so it was used in almost
half of shots that we did.
Most of those are more background shots.
This was one of the few
shots where it was actually
sort of showing it in all it's glory.
Think the only thing, there
is some real stuff here.
I believe those mountains, at least some
of them might be from New Zealand,
but otherwise that's all, of course, CG.
Here's the same shot you saw earlier
but the final version of it.
Lot of clouds here, obscuring the city.
Artists hate that, well,
some artists hate it.
The comp artists love putting clouds in
but the guys who get their stuff
covered up, they hate that.
(laughter)
We had a lot of back
and forth discussions.
We basically met with the
artists and the CG supervisor
twice a week at the early
start of the project,
try to prioritizing very quickly
about what their needs were.
It was kind of like Agile
on steroids but it worked.
The only problem with
that is that we ended up,
we brought on some design debt really.
A lot of our focus was very
much towards Alien Covenant
and when we go back and revisit
this for the next series
of films, we're gonna
want to sort of take out
some of the alienisms in the software
to make it a bit more generic.
So, I mentioned it's in the
background of a lot of shots,
this is a great example of
it being in the background.
There's a really beautiful city shot here.
Look at that thing, it's great.
But then they went and just messed it up
by putting a big alien and
a spaceship in front of it.
(laughter)
I paid good money to see that city.
It's a bit annoying but anyway.
It's nice.
Yeah, moving forward,
this was the first film
we used Machi on but
there's quite a few films
coming down the pipeline
and as I mentioned,
we have some design
debt we have to address.
A few key areas we want to focus on.
The first is getting back to
what I talked about earlier,
this question of node
based vs task focused UI.
I am a big fan of node based programming
and we do that a lot at MPC.
We have there Katana, we
have Houdini and Nuke,
all of which are node
based packages that we use.
And it's great because you
can put things together
in ways that you may not
have envisioned originally
and you can come up with
interesting and unique results.
But ultimately, node based UI's are a way
of asking your artists
to become programmers.
And that works for many artists,
doesn't necessarily work for all artists.
So, I'm still a little
bit on the fence about
how to approach this, but I'm
definitely leaning towards
revisiting the node interface
and maybe trying to blend
the two approaches a bit
and by authoring custom UI's
that control nodes and
exposing those nodes.
Procedural buildings is something
that we really didn't do too much with.
Most of the buildings we
had on Alien were actually
just authored directly by the artists.
They didn't want to do
anything procedural with them,
they just wanted to give them to us,
but we did have this
system built into Machi
where you could specify
the base, the roof,
and a bunch of floors in between
and have random variations
for them and then we would
build up buildings out of that.
We'd like to go further with this.
I think it ads, it's a great way
to add random variation to a city.
CGA shape grammar from
CityEngine is the perfect example
of how this sort of thing works,
where you can parameterize
an entire city really nicely.
But it's definitely
still too complicated for
the average artist, so
we're looking at ways
that we can, you know, have
the artist generate chunks
of geometry and then define
using C++ code wrapped
with KL in interesting ways
to maybe make it simple enough
for the artist to define
rules for how to put
those pieces together
and expose parameters
that then we can procedurally modify
throughout the city to add variation.
Finally, integration with other apps.
As I mentioned, we used Fabric Canvas
as our hosting application for this,
but we really want to
expand out to hosting
it inside of other applications like Maya,
Houdini, and maybe even some
game engines like Unreal.
Maybe we could do something
like layout the streets
and buildings with Machi
and then inside of Houdini,
we could take the geometry, or
the roads that were generated
and create actual street
geometry, and then we can maybe
take it into Unreal and
preview it in real time
so that we could figure
out the right shots
that we wanted to use in the final film,
with high quality lighting and texturing.
That's mostly it for me.
I hope I gave you some insight
into software development
for visual effects.
I think we have some
time for some questions.
(crowd clapping)
Yeah.
- [Audience Member] Um.
- [Male] Can you use the microphone?
- [Audience Member] Oh
yeah, sorry (mumbles).
How did the concept
artists feel about the tool
and how was the process
that worked with that?
Because when I've worked
with games and such like.
- Yeah.
- [Audience Member] The shots in the games
look very similar to what
the concept artists produce.
- Yeah, you know, in this case,
the concept art came at us really early
and we didn't create it in house.
It was actually created by the studio
so I guess Ridley Scott
had signed off on it
at an early stage but then he still knew
that he wanted reiterate on
it quite a bit after that.
So, we didn't get to talk
to the concept artists.
I don't really know what
their response was to it
but ultimately, we still did fulfill
the general vision there,
it's just that our final city
ended up being quite a bit more dense than
what the original concept art showed.
Yeah.
- [Audience Member] Hi, how
much time do you guys have
from the moments you were
tasked with creating the tool
to handing it over to the artists?
- Well, that's a good question.
We spent, a lot of the work that I'd done,
I guess I should say it was
about two or three months
of messing about and trying
to figure things around
and then we started to work
with the production team,
like in lock step with
them, so that they would,
this is when this sort
of twice a week cycle
of meeting with them and tuning.
So, kind of like, basically maybe three,
actually maybe four months
first and then after that
it was maybe another six
months of development
in conjunction with the
actual direction team.
- [Audience Member] Cool, thanks.
- [Audience Member] So, if
you're building an internal tool,
one of the things that
I've struggled with is,
we get a lot of feedback
and it's a struggle
to sort of incorporate the feedback
versus prioritizing what we're working on.
I'm assuming that a lot of the times
when you guys gave this to the artists,
the artists come back and they want this
and nit pick on this.
- Yeah.
- [Audience Member] And this and this.
How did you guys prioritize
what was most important
to focus on in your
development and versus fixing
the things that the artists wanted which
would give them that immediate feedback?
- Yeah, absolutely.
That's what I talked a
little bit about with,
when I comment on Agile on steroids,
that was our twice a week meetings.
They would come at us twice a week,
tell us what they didn't
like and then we would work
with them in those meetings,
directly with our
stakeholders to prioritize
what was gonna happen next.
And generally, we found
them to be quite receptive
to the idea of, this
is gonna take a month.
We're gonna work on this next month,
right now we're gonna focus on this.
As long as you have, you know,
key ideas for well, on this
sprint we're gonna focus
on this, on the next sprint
we're gonna focus on that
and you can make steady progress.
Generally your stakeholders
are gonna be fairly okay
with that I find, unless
somethings really critical.
Obviously if there's a bug
and they need it tomorrow
and it's stopping their work,
then you fix it right away.
- [Audience Member] I was
curious when you were talking
about the artist wanting
to lock a building down
and then you were going to
regenerate using that as a seed.
- Yeah.
- [Audience Member] I was
wondering if you could give us
some more details on that, like,
would that be the seed
generation for your roads
or were they?
- Yeah, it is.
- [Audience Member] I
would imagine at some point
they want to lock down
a whole bunch of things
and then you've got all these constraints
and how do you deal with that?
- Yeah, I mean mostly it's road generation
that's the interesting aspect of it.
I mean, a building itself isn't really,
well, roads, let's talk about roads first.
The roads use some sort of, it's kind
of a modified L system to layout the roads
and basically if somebody
locked down a road,
we would just use that as a starting point
and we would just generate new roads
starting with the endpoints of those roads
that they'd locked down.
If a building was locked down, typically,
hopefully in the end it
was still in the middle.
If you'd locked down the roads around it,
and it's still gonna be in
the middle of the block,
so that's gonna be okay.
If you haven't locked down the roads,
then it could end up in the middle
of a street later on which would be bad,
but for the most part is wasn't a problem.
And generally, we basically said with our,
it was really easy to lock
down a building in a block
because you just say,
well, this block is gonna
have these buildings
that are locked and then
that feeds into your
dart throwing algorithm
and you just keep on
pumping more buildings
in there until it fits really.
- [Audience Member] Okay.
- Ultimately, yeah, it was
the cool part was that,
with the city layout, the
road layout bit of it,
where we actually just used it
as a seed point for the
new stuff. (clears throat)
- [Audience Member] I was just curious
what Python Gooey library you guys
were using for that tool.
- Uh, the UI's all QT.
- [Audience Member] Got it.
- It's actually mostly, it's Python QC.
- [Audience Member] Yep.
- Yeah.
- [Audience Member] Gotcha.
- Cool, well if that's it,
thank you all for coming.
(audience clapping)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>