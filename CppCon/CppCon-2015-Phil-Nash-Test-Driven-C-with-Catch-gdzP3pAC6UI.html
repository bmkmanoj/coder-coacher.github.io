<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Phil Nash “Test Driven C++ with Catch” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Phil Nash “Test Driven C++ with Catch” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Phil Nash “Test Driven C++ with Catch”</b></h2><h5 class="post__date">2015-10-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gdzP3pAC6UI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everyone thanks for coming
along good to see quite a few people
interested in just driven C++ especially
with STL giving her another talk in
another room so thanks for coming so
quick show of hands before we get
started
who's done some form of TDD before in
any language not just C++ so a fair few
but quite a few haven't who's sort of
reasonably familiar with what TDD is at
least so quite a few people only knew
two TDD it's not going to be a deep dive
on CDD I will explain a bit about it so
to recap what it means and we'll sort of
bare some other out in the demos so
hopefully you'll still get plenty out of
that but also the other part of this is
it's we have catch so catch is a test
framework originally written by me many
contributions now over the years rubbers
so it's more of a community thing and
they're going to look at some of the
ways that catch I feel at least is
particularly good for doing TDD but what
we get onto that I want to concentrate
more on that first part the test-driven
C++ so so I'll have my um click in some
somehow I managed to leave it at home I
completely failed to connect my Apple
watch to use it as a remote so I'll have
to have to do it from here so
test-driven C++ what's he talking about
TDD she usually expand to test-driven
development but some people like to
expand it to test-driven design and
that's quite nice because it puts the
emphasis on on their word design and I
think that's really the sort of one of
the most valuable parts that comes out
of TDD a portion utley that's not the
word that most people focus on most
people just seem to get stuck on that
first word test and that's a bit
unfortunate because there has a lot of
connotations a lot of baggage
comes along with that word and people to
get a reaction when they talk about
tests that's not really what TDD is all
about some people will say that the
tests are not even the most important
part of TDD you may argue with them but
I think the most important word here is
actually the middle one driven
test-driven development or test-driven
design what it actually mean to drive
your design from tests to answer that
question and we also need to look at
what we actually mean by tests let's say
a lot of people have a reaction where
they hear that word I think it's worth
clarifying that and to answer that we
need to ask another question very broad
question why do we actually write code
in the first place why do we do it
there's always a reason here's a few
possibilities maybe we want to deliver
stakeholder value because that guess is
our bed in the morning practice to to
meet a business need yeah sounds sounds
important maybe because it's we were
just told to do it so job we write code
someone told us to write this code we
write it I don't really care why all of
these things may be true but as I said
they're not particularly motivating it's
not really what we connect to as
programmers how about this one we write
code to solve a particular problem
now that's something we can connect to
we're problem solvers that's what we do
we solve problems now that problem may
deliver stakeholders early it may meet a
business need it maybe what we're asked
to do but we can connect to the problem
solving pal so we're getting somewhere a
couple more questions we need to ask how
to solve a particular problem we need to
ask what the problem is that we're
trying to solve another question is how
do we know when we've solved it
seem like simple fundamental questions
so trivial will we miss them we won't
ask the questions and that's a shame
because we end up not actually answering
them either we end up solving the wrong
problem and that's an incredible waste
or maybe we start off on the right
problem but we don't actually solve it
we think we had how do we know that's
the question so how do we know when we
solved the problem let's look at really
simple requirement so I had two numbers
together see very vague just run with it
we might jump straight into some code
not doing TDD here which write this code
now we'll set aside for the moment other
questions we can ask and it did we mean
integers there's all sorts of other
questions we can ask about requirements
but to set that aside integers are fine
here well writing code like this and now
we need to know does this actually
address the mither requirement that we
were trying to solve what we were trying
to solve how can we verify that we might
say the case like this it's so simple we
could just look at the code we can see
it's going to do it and that may be true
we might go out to simplify our code to
the point can verify just by inspection
and their whole disciplines that have
been built up around code inspection and
they're quite successful that it happens
generally we want to actually run some
code through this and see what the
output is just to make sure this does
actually do what we want and we'll see
more complex cases all the more so so
I'm gonna make a call to our add
function give it some sample values we
might do a few of these but let's go
with one and two at the moment and that
will exercise the code but still we
don't know that it's returned the right
value we need some means to to verify it
it's a simplest way the Wiccans verify
but that return the value we expected
how about just a simple C assert
so we've got our expression add 1 &amp;amp; 2
we're saying that's equal to 3 that's
gonna evaluates a boolean true or false
and if it's false assert or terminate at
least in the debug build so simple
straightforward what happens when it
does fail Oh before I go on there's a
bit more to actually we do need to
include the header for assert and we
need to put it in some sort of function
it could be mine but still that's just a
few plus plus for you so if we introduce
a deliberate error into this say we
multiply instead of add what are we
gonna get out of this something like
this so I captured this on my Mac
running Xcode with clang the app I got
told me what the expression was that I
wrote it's up with the function that it
was in when it failed main in this case
and that's nice you write a number of
different test functions you want to
capture that name and of course it tells
you the file and 9 number but the
assertion photon they can go straight to
the cause of the problem that's actually
really nice I haven't really invested in
anything else other than just the
standard library here and yet I'm
getting some quite good feedback for a
very simple test
but there are some shortcomings one is
that this output is implementation
dependent so I ran this on Visual Studio
and windows and I've got quite similar
output didn't give me the function name
to the shame
and gave me most of the rest but none of
that's actually guaranteed or what's
guaranteed is that it might actually
terminate so that's not cigarette
doesn't scale too well either
if you've got hundreds or thousands of
these asserts probably want to group
them you put them in functions then you
want to have something that controls
which ones get called and you get more
and more of these requirements and
you're not building your own test
framework so
that's when we turn the test frameworks
and we concede that we might need some
extra dependency so it talks about catch
which is a test framework what does this
look like we write it in catch very
similar actually we still include a
header file
this time it's catch that HPP we still
have to have some sort of function to
put it in this case that's provided by
this test case macro you notice we
haven't given our test name we don't
have to we usually would can be useful
for demos and for exploration just did
not have to worry about that yeah so or
name things later and instead of assert
we said require but the basic flow is is
still there so we haven't lost too much
I wouldn't take it on that additional
dependency so that's quite nice there is
one other thing we have to do that
because catch will write its own version
and main for us if we ask it to just in
exactly one source file we need to put
this hash define before we include catch
catch config main there's another one if
we want to provide our own main but
apart from that that's the only
additional thing over the OBD assert
example so what sort of feedback does
this give us now let's see that I think
we should do a quick demo so I'm going
to come out here start Xcode so I'm
running on my Mac so I'm using Xcode
there's nothing particularly Xcode
specific about any of this so other than
just setting up a project if I've got
enough screen space to do this actually
see if I can get rid of that dock
yeah okay we got there in the end sorry
about that everyone read that okay okay
so like any good IDE Xcode is written a
load of code that we don't actually need
so we want to do is include catch now
this is the spirit of TDD we're actually
including a file we don't have yet
seeing that file so now we need to get
catch
to go to my previous version of this
tool so get that file there I would
normally download it at the same time
but already having too many problems
here then we'll go back to our project
so I'm just going to drop the single
header file into that folder
so hopefully have it interrupted the
flow of this too much of it so normally
I would get that file from github
download it straight there and we're
done then I go back to Xcode don't our
compile but doesn't link the reason
doesn't link is because we don't have
mine so we need to put that how to
define in that I mentioned catch Quantic
main let now compiles in links and we
have a complete working application
know what's going on there okay gonna
abandon this session for now we're going
to come back in a moment to do another
demo anyway but first go back to slides
so wanted to talk a little bit oh there
we go okay something's working we're
gonna talk a little about why I wrote
cash in the first place so let's go back
to the in with the technical issues in a
moment because after all there are one
or two other test frameworks for C++
already out there this is a page on the
Wikipedia
dedicated to just listing or the test
frameworks for C++ you're taking notes
you might wanna write quickly there's 56
of them there at least there was when I
captured that list about a year or so
ago and of course that's not exhaustive
so why do they need to write another one
that's a good question so I'll see them
try every single one of those I tried to
the popular ones and there always seemed
to be sort of one or two things missing
probably the main one is just simplicity
we saw right at the start that you can
actually get quite far just within a
search statement and we don't really
want to give up that simplicity in terms
of how you write the tests but
directness using natural expressions and
so on since with a lot of boilerplate
and ceremony involved in so many of
these test frameworks I just didn't get
the like getting involved in that number
one is expressiveness so just with a
small amount of code being out to get
rich feedback we did quite well with
assert I've got for my last demo you'll
is seen that catch gives you a little
bit more and low overhead
so you did say it's just a single header
file you can grab from github you clue
that and you get started no messing with
you know static libraries and getting
other things up and running worrying
about the different build settings you
just include and go oh yeah so they're
the values that I was looking for and I
didn't really find elsewhere
at least at the time and I try to build
these things into catch so hopefully
your grief you you try it out so go back
to that example we looked at earlier
with the add function we saw how that
works in you catch that we could add a
name in now this might be surprising if
you've used other test frameworks both
test frameworks will force you to write
your testings as function names usually
you have to find out a way to couch
these names and you want to try and be
descriptive because what we're told
try and couch them in legal safe house
plus identifier well attach you think
you see as a free-form string spaces
punctuation whatever you like be
descriptive as you like and more than
that there's an optional extra argument
where you can put in square brackets tax
where as many of these as you like and
these let you run groups of tests or
exclude groups of tests and you can
actually build up some fairly complex
expressions to be able to sort of cut
across your test suite and we'll see
that a little bit more in action later
so that's quite useful so at the point
where what should have come to my second
demo so I'm going to do because I've
tried to keep a locked-down user for my
presentation that doesn't seem to be
working out so I'm going to log in as me
Choki will give us less problems okay so
starting Xcode again resolution is maybe
a bit too high now let's see how it goes
when we spikes code so for this demo I
wanted to pick an example I could sort
of work through and show you a fair bit
of catch but also demonstrates EDD so a
bit of a meteor demo so I'm going to do
a ring buffer you know how those fonts
looking is that readable for the back
okay okay so again we get rid of that
let's try coding catch again we know we
want to do catch conflict moon now we
know we're going to need that header
file it from somewhere different this
time
would it be create that
okay so and Rappard in there I should
now compile and build this is where we
got to earlier and we couldn't run it
okay that's a bit weird I need to do
well that's never not worked before it's
definitely bad demo day today should I
run it from the terminal okay that's
better
let's try and bring the fonts up a bit
on there I prefer running this from the
terminal anyway so it's no big loss
okay that terminal readable so no test
run ran that's what we expect so that's
fine so let's start our demo
so we said we're going to do a ring
buffer I'll call it that for now now
we're going to want some sort of ring
buffer class
so let's declare an instance of that so
this is the start of TDD we haven't
created a ring buffer class yet but in
our test we're asking for one this the
way TDD works we write the test code
first and then even when that doesn't
compile we can that's telling us
something it's telling us we need to
create a class called ring buffer so
let's do that don't have to implement it
what we're doing is the minimum that we
need to get this test to pass and even
though there's no assertions yet just
compiling is the first stage commonly
there but we can see that it still runs
but it's not particularly interesting so
let's start adding some requirements
what can we say about an empty ring
buffer well we could say that its size
is zero we haven't written a size method
yet so let's do that
it's size T and what are we going to
return well now we just want to make the
test pass so we're going to hard code a
zero in there if you've not done CDD
before this might seem a bit stupid you
know we know that's not German enough
but this is the point
we're not going to write the
general-purpose code until we have tests
that cover it so we only ever write what
we need to make the test pass and then
we think about what tests we need to
write so make that file so for now that
should make the test pass and everything
is green so that's good now on the side
it may have noticed that the compilation
is getting a bit slow here we have very
much code so what's going on the reason
is this catch convict name so I said
that that causes catch to generate a
version and main for us and it does but
there have been more to it than that
though we've packaged catch as a single
header file but it has a whole framework
in there and normally you would write
several header files and implementation
files and in cash both of those are
present it's compiling the whole thing
every time we don't want to pay the cost
of that so what we'll do let it another
test file let's call it test dot CPP for
now let's forget to give another header
we're copy everything from our main file
into there except we removed that hash
define we only need it in one file and
in our main file that's all we're gonna
do so
did something going up asked them quite
a lot you know why does catch compile so
slowly that's usually their reason
you're putting all your tests in the
same file as the catch config main it's
great for demos and to get started but
once you're actually building up a test
suite it's best to keep this off in its
own file that's now only going to have
that long compile once get that out the
way and now introduce a deliberate
mistake there compile again you can see
it's pretty much instant that's what we
would expect
could run that we can see the test file
so we didn't see the test file before
they didn't do my previous demo now you
can see what the output looks like we've
got so plenty of red there to show us
that everything has gone wrong see that
the test is filed you can see what we've
got the the test name up here
the final a known number of the test
case file an EIN number the failing
assertion the assertion as we wrote it
so so far we're sort of on par with the
assert statement but now we've also got
the expansion of the expression the
left-hand side and right-hand side
separated out and that's interesting
because in most test frameworks to get
that you need to rewrite your expression
using a macro like a 30 equals in this
case it's quite common it seemed like a
minor thing but if these little speed
ballasts that you have to have a
slightly different mindset and the way
you write your test code it's to
slightly less natural than the code you
would have written otherwise adds up so
here we're just using a natural
expression and it's broken it down for
us now forget time it's all wasted a bit
of time and the technical issues we were
going to how I do that
a bit later let's go back to our ring
buffer
so let me come down because I was a bit
blocked so I still didn't quite catch
that
let's write about this in the other
source file you mean when I spit from
Maine and test at CPP so I think the
question was I moved the test into
another source file so how did catch
pick pick them up so the the test case
macro this one here defines a function
behind the scenes but also defines a
little class that has a constructor that
just registers the test case and another
like the global instance of that fairly
common technique for self registering
test cases because we have we have
included a catch here we just didn't use
the define to instantiate a main so it's
got all of the catch machinery so it
works exactly the same way there as it
would have done in the main test file
sound to your question great okay so we
said that the size is zero we've
hard-coded that let's fix that again now
and now we can see the test passes again
it's great so what else can we do with a
ring buffer we probably want to be able
to add elements so let's use pushback
and we use push back and pop front
because we're gonna have a front of the
buffer in the back of the buffer which
move independently
now what are we going to put in it we
haven't said what types the ring Pathak
anode so let's go back and make that a
template to probably what we want and
well let's den see eight this for in
spinel we put a one in there and now we
need to write pushback because it's
asking us to we don't have to implement
it because we're not testing anything
any consequences of that just yet
we just need that to be able to compile
okay what can we now say about the ring
buffer well got our size method we would
expect that to now return one I'll say
expect we'd expect this to this test to
fail because we haven't written any code
to cope with it yet and of course it
does size is still zero now is the time
we can go back and make the size method
more general so we're going to want
something to keep a track of the size so
let's just introduce a variable size
going to want to initialize that in our
constructor now we can return it here
and we could implement it yeah
see if that works
and it does so this again it might seem
a bit of an odd way to to build our ring
buffer we sort of probably have an idea
in our head how we wanted to implement
it but the tests are leading us in a
slightly different direction but we will
get there let's carry on with this now
we've got an item on the ring buffer or
at least we we seem to have pushed one
well we want to be able to get a value
back of course whoever written pop front
yet so let's do that now and it's a
minimum we can do to make this pass was
just to return the default 40 that
compiles so now what can we say about
the ring buffer again we can look at the
size I should now have gone down because
we've removed an item and do we expect
that to pass or fail hopefully file C
and it does again this is safe like a
stupid step you know we know that's
going to fail why do we run it of
sometimes it doesn't and then that tells
you that you've missed something should
always know exactly what your code is
doing so we challenge our assumptions
all the time even the simplest cases so
now we can the equipment the size here
we pop back notice we haven't got any
storage yet but I'm actually storing any
of these values that now passes okay but
now now we're going to want to test the
value and we want to expect that to be
the value that we pushed in which is a 1
I would hope that's going to fail
it does so now this is a point where
we're going to want to do some real work
we won't actually hold on to to the
values we put on and it forces us to
take on another question is how big is a
ring buffer going to be we haven't said
that anywhere
so first of all we want the constructor
to take a capacity there's a few ways we
could do this we might want to make it a
fixed size at compile time a template
argument we're going to do it like this
for now and with uh some underlying
storage we use a standard vector gonna
have lots of choices we could do here
this keeps it simple so how are we going
to relate the capacity in the vector
well vector has a capacity that's not
quite what we want here where she want
the buffer to be a fixed size and just
have her pointers into it so we actually
going to create a vector already sized
to capacity initialize it to zeros it
gives us somewhere to put our values now
so we couldn't we could push back but
that would push after our buffer but
it's not what we want we want actually
set in to do size we can move that back
there it's not going to be that helpful
let's let's go with this and see what
happens to retrieve the item off well we
need to go back from the front we don't
have anything that's telling us what the
front of the buffer is so uh actually
we're gonna need some more indices we
have front and back
those zeros now we can say push back
go to the back index which were then
want to increment obviously there's
something else we need to do there but
we can not get into that just yet
and now I'll pop front similarly take it
from the front index and now the front
is going to move on because it's a ring
buffer so we'll increment that as well
that should be enough if I've not missed
anything which I have of course the
capacity here let's make it four that
should be enough to pass our tests it
does it's definitely not finished but it
passed their test so far so I chose a
buffer size of four here just to keep it
maintainable for our tests another thing
to notice here is we've got our the code
under tests and the tests in the same
farm don't have to do that of course I
usually prefer to do it that way when
I'm just writing some new class or
structure or function this in isolation
health-food to keep it in isolation and
not worry about the rest of the system
you can do it in place in another target
source file if you want I'd sort of move
it there when it's ready make sure all
the tests all pass matter of choice but
something else we're doing wrong here if
you done any unit testing before you've
probably heard of this guideline that
you should only have one assertion per
test that actually means one logical
assertion so down here at the bottom
where we're testing the size and the
value we got back that's two aspects or
test of the result of popped rent so
that's one logical assert that's fine
problem is we have these ones here as
well
with testing some state we take in the
state testing again mutating testing
again and that's considered bad form in
unit testing because you can't isolate
those different parts usually we would
have to nail separate this out into
separate test cases with a lot of
duplication some of which we could
factor out into a setup method the catch
has a a different way we can now create
different sections that will be executed
separately so here we're going to add a
value adding a value increases the size
give it nice descriptive names again and
that's that part there this is going to
continue on so we want that in here as
well so that's our second legible is
that off in a section and then the next
section starts here talking about it
decreases the size and returns the first
ready these names aren't brilliant we'll
come back to that in a while but now
we've got h logical asserting its own
section but notice we've been out to
nest sections here in here because this
section is still dependent on the first
section our first logical test is to set
up for the next illogical test so we
captured that in other cases we can
include additional sections here which
we will do in a moment but are not
dependent we'll see how that works let's
just make sure that still runs it does
now when I seen the output here because
we haven't seen any failures for a while
we can see the output even if it
succeeds with - yes and now we can say
as well as all no results up here
got our test case name and the names of
all the sections that have been executed
up to that point like a stack if acted
is a stack these little stack based so
it's a really natural fit for C++ I hope
you scroll back a bit we can see it's
also executed just the first section in
isolation and that was the really the
first illogical section so we've got
quite a lot of bang for the buck there
and having done that we can carry on so
we've added one value to our buffer and
popped it back again but it's gonna get
more interesting if we add more values
than there there should be room for so
let's start a new section for that so
adding more values and capacity wraps
the buffer will get a better name for
that in a while so we're going to want
to add at least five values now we can
do five pushbacks in a row but that's
going to get a bit tedious if we have to
do that a lot so happen to write this
test it's putting us in the driving seat
where this is part of the driving part
of test-driven development we're seeing
what it's like as a client of our code
rather than does the implementer and it
can often change to you know the way
that we want to express our API it's
quite convenient to be able to push many
items at once and we've so plus plus 11
we have a nice way to do that we've and
initialize a list so I'm going to do an
overload of pushback takes an
initializer list
we can quickly look through there and
for the values onto our single value
overload that's a few ways we could do
that we could use a an algorithm notice
also that that method is implemented
entirely in terms of the public
interface our ring buffer we could
choose to move that out into non-member
non-friend
and a certain advantages to that as a
design choice which we had to make
separately if you feel that this is
genuine generally useful
he might be clearer to leave it there if
you thought it is just for your tests to
start with maybe better to leave it as a
non-member non-friend okay so now we got
that we can have a bit more fun and add
multiple values so that should now
overflow our buffer and wrap around of
course we know it doesn't yet but what
can we say about that now again we can
look at the size that should now be
stuck at four even though we are did
five items because that's the point of a
ring back so expect that to fail and it
does mmm that looks a bit suspicious
okay I have to look at that we'll move
on for now point is it did fail oh
that's because that's the wrong that was
the funny one good that's a relief it's
one less bug report today so we expected
the five because we're not wrapping
around so coming up here we can see
we're unconditionally incrementing sighs
what we wanted to do is say if size is
less than the capacity what's the
capacity it's the size of the vector so
that's going to stop at four now which
means our test should pass and it does
we're far from done now let's pop front
again see what value we got back so we
know we should be expecting because we
only got four items should be expecting
a - what do we get
at 1:00 so again that's because
here we're unconditionally incrementing
our back index okay so that's sober
flowing off the end I've been told that
running a bit shorter time so I'm not
going to finish this demo as it is most
of its carrying on much the same I
wanted to just pivot into different
aspects of of catch so we've used these
test cases and sections here you can see
how that's allowing us to group related
parts of the test together to keep
single logical assertions and nicely
described the flow through but if you've
done any BDD behavior-driven development
you might be familiar with another way
of talking about these tests with the
given when then approach and catch the
forces as well we're just a set of
alternate macros starting with scenario
it's a corresponds to the test case and
then we can say given an empty ring
buffer does involve a bit more nesting
costume you pay so given an in tearing
buffer throw that should have included
that this case has no when we can see
then signs will be 0
I don't we can say we'll give it an
empty ring buffer when
the value is pushed then the science
becomes one now we get the nesting and
when the value is popped then size
decreases the value is returned I would
just do this one as well so going back
to give it an interviewing buffer when
more believes in the capacity or I did
then buffer wraps around size stays at
capacity
okay so let's look at what we've done
here it's a same test but we've changed
the naming a bit sorry had a question so
they're they're following on so are you
saying that we could put the end when
directly under the web yes you could if
I probably should have done that rushing
a little bit too much you're quite right
it will work either way but yes you've
got seven additional logical assert in
that chain that you'd probably don't
need so you're quite right
so yeah the point was here this bar is
not really dependent on that then we can
move it out
it's okay so we've introduced this
structure and quite a nice property of
the naming has emerged as a result of
this I think it's much clearer than what
we had a moment ago and we haven't
really had to think too much about it
which has been guided by the given when
they're in structure so best
demonstrated if we actually run that run
over - yes and we still got that failing
test but you look now the test name
we've got a whole scenario description
scenario ring buffer given an in tearing
buffer when more values in the capacity
I did then the buffer wraps around in
this capacity side stays at capacity and
we ever hear these all here all of these
routes through that scenario they're
covered and this is human readable we
can talk to someone maybe not technical
maybe they'd have to be in this case but
maybe I don't know C++ they don't have
to look at the code to see the flow so I
mean that's a really nice property of
this but they're gonna have to get back
to the slides to try wrap up back in a
different username now okay skip over
some things
let's go through this part fairly
quickly when the test files catch we'll
try and convert all the types evolved
into strings and a bit that I just
skipped over which explained how the
expression template works you would see
where it calls catched your string in
there to do that if it doesn't
understand a custom type do you may see
this in your output so it's worth seeing
how we get around that
so by default if your type supports the
insertion operator overload for a string
it will just work catch we'll find that
and use it if it doesn't you can write
an overload for catch to string in the
catch namespace which just takes your
type and returns a standard string and
the new to work there are some
cases where that's not quite enough
usually involving specializations
writing test code if you've got a no
stream operator overloading in your
production code we'll pick that up or
you can write it just for tests yeah so
some real cases usually involving a
partial specialization you may have to
drop to this string maker template class
it's a bit more complex but works the
same sit away you've got to convert
static method there takes your type
returns assign a string for all the
primitive types and even standard
library types like standard vector
static map you can stand a tuple there's
already overloads with cachtice string
in catch you're gonna to worry about
those
so mostly just works it's worth keeping
that in mind and then just to address a
couple of the elephants in the room most
common questions I get when I've given
this talk before firstly what about
threading cash doesn't have any
awareness of frets
the main problem is that it's targeted
at C++ so free compilers and has no
external dependencies it's the way I
want to keep it so it's quite hard but a
portable threading support in there the
plan is to conditionally include support
for C++ 11 compilers using the C++ 11
reading primitives that's just not being
done yet
but that is coming and you ever elephant
is what about mocks so cash doesn't have
any built-in support for mocks mostly
because I tend not to be a ma kissed
if you don't mock objects are you know
what a mock it is it's a different
approach to testing but a lot of people
find invaluable I get this a hath this a
lot there's a couple of mocking
frameworks that do work quite well we
catch that I'm aware of one of them is
hippo box there's a link to both of
these at the end I think you have to do
a little bit of integration code to get
that to work the other one a fairly new
framework called Trump Lee and the
author of that was already aware of
catch when he wrote it so you made sure
it works well with it there was a little
bit of integration code but he includes
out on his github page and there's a
link to that at the end other mocking
frameworks may or may not work I don't
know about those sorry so it works for
C++ 11 and C++ 14 and there's a number
of things in there already conditionally
that I've had to do to to make it work
say for example we've had a null pointer
has to understand outer as a particular
type and a certain things like you know
the deprecation of auto pointer as I've
had to use unique pointer in some things
like that I've already had to do just to
make you work but it turns I've actually
using C++ 11 features relying on them
there's nothing in there currently that
relies in C++ 11 but I think that's
worth changing for the writing support
because that's quite a big thing if
you're using it for pure unit tests that
shouldn't matter because you shouldn't
be doing threading in a unit test but
I've deliberately tried not to call
catch a unit test framework because you
can use it for non unit tests particular
integration tests what you do want to
work in a multi-threaded environment
what I currently do when I'm in my day
job I use catch is I have to sort of
store up all of my failures maybe in a
TLS structure and then once I've joined
my afraid so and then I assert on Ian's
catch it's a bit of a clutch but it does
work so I would like to get for support
into catch if I've got time just to run
through a couple of the other things
that are hopefully coming and catch
generators it's quite a big area it's
been on my queue for a few years now but
basically will give you a way of doing
property based testing testing large
ranges of values at once
matches is in our area quite a big part
I want to try and keep sort of off to
the side more what do that thing but
matches are basically a way of composing
assertions writing customer surgeons for
particular needs and composing them
together so you can have the knot of an
assertion and break them together
weave ands and ORS it's quite powerful
quite a powerful technique that needs
some supporting catch and it's a
prototypical version already in there
you're finally possibility of changing
the name reoccurring complaints over the
years has been that catch is not a very
searchable name in the context of
particularly C++ search Stack Overflow
per catch you'll see what I mean so I've
been ignoring this for a few years but
I've finally thought maybe it's a it's a
real problem be looking at possibility
of a new name my current favorite
proposal is catfish
so keeps a similar sort of acronym in
there but let me know what you think
about that afterwards
so I think we can finish their top link
is just redirects to the github page for
catch my blog level of indirection calm
you can also get there from extra lever
don't indirection calm it just redirects
I often talk about catch there and other
things and those two mocking frameworks
that I mentioned just a little while ago
so sort of that will be the demo issues
but they got there in the end
well thanks for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>