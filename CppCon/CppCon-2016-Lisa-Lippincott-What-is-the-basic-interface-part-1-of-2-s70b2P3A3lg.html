<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Lisa Lippincott “What is the basic interface? (part 1 of 2)&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Lisa Lippincott “What is the basic interface? (part 1 of 2)&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Lisa Lippincott “What is the basic interface? (part 1 of 2)&quot;</b></h2><h5 class="post__date">2016-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/s70b2P3A3lg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay let's begin I'm Lisa Lippincott I
am here to try and answer this question
what is the basic interface and I won't
pretend that I have a complete answer
for you today what I have is actually
three answers all of which are
incomplete even taken together but I
think they point in the right direction
and I think this is a question that we
need to get answered so first this is a
sequel of sorts to a talk I gave a year
and a half ago at CPP now called
how we reason about procedural programs
that talk is on YouTube you can watch it
later if you like
but the important takeaway is this we
routinely prove that our programs work
if we didn't prove our programs work
they would hardly ever work you can't
explain the success of our computer
programs by chance alone second point
and feel free to interrupt me with
questions if you have questions but
second point proof behind a well-written
program is mostly evident in its text we
expect that if a program is well written
you can pick it up and read the code and
figure out why it works and if it's well
written but buggy you ought to be able
to pick it up and read the code and
figure out why it doesn't work
but sometimes the proof we intended is
wrong either our logic is faulty we've
missed a case or something that we
didn't that we thought was true wasn't
true or maybe our logic in our head
didn't match our code because there was
a typo or something sometimes our
intended proof doesn't quite work and of
course that leads to bugs not all bugs
some programs are defective by design
but it leads to a lot
books and we will see some of those
later but this leads to an interesting
question why aren't we having computers
check our proofs and I think a big part
of the answer having thought about this
question for a while
is this we generally aren't clear about
what we're trying to prove in particular
in function interfaces we don't write
down formal requirements and
expectations of the function and there's
to some extent a reason for that our
best formal notation for doing proofs is
mathematical notation that's like 200
years old it goes back to a crisis in
mathematics that happened in the 1800s
and a new mathematics or arose out of
that crisis based on an idea called
platonism Platonism is the idea that
mathematical concepts like v exist in a
timeless unchanging parallel universe
that we reason about treat you we access
through the eye of our imagination or if
you go back to the original Plato
thought that we accessed it by
remembering it from before we were born
it's actually a little crazy when you
think about it closely but it's given us
mathematics that has worked pretty well
for 200 years except because these
things are off in their timeless
universe it is hard to talk about change
about them changing we have mathematics
that is hostile to change and this isn't
a problem
with reasoning we are good at reasoning
about change and we do manage to work
mathematics about change but the problem
is it has poor
user interface for discussing change and
it has therefore has poor user interface
for discussing procedural programs now
one approach would be to write a
different sort of program in which
nothing ever changes and that approach
has been tried for about 50 years with
limited success I'm going to go the
other way I'm going to say our reasoning
should embrace change I'm going to write
mathematics procedurally and integrate
it into programs so moving on to the
next thing
we don't write down all the details of
function interfaces and that's maybe not
obvious but I think it will be by the
end of the talk that there's a lot of
niggling details that we expect of
pretty much every function that we let
go unsaid because pretty much every
function is like that but we should at
least agree on what the things that can
go unsaid are and that leads us to this
talk the basic interface is the set of
expectations we have about a function
before we write down the documentation
and if we want a function that does more
than the basic interface says we will
add to that and if we want to weaken it
some way we will remove things from the
from the basic interface but the blank
sheet of paper that we start with is the
basic interface it's the standard
expectations of function doing the usual
things but before we go further I have
to talk a little about interfaces and
how we write down interfaces and now I'm
going to play fantasy C++ I'm going to
invent new bits of the lang
which to cover the things I want to say
and here is the first one this is a
function interface it looks a lot like
an inline function and in fact it has
two salient parts always in line and it
may have this statement implementation
somewhere in its outermost block the
implementation statement separates the
interface into a prologue and an
epilogue sorry I thought I saw a hand
and what is the implementation statement
to the implementation statement invokes
the function implementation it's very
like a function call our execution path
runs through the prologue through the
implementation body back for the
epilogue it's unlike a function call in
three ways one it doesn't choose what to
call when a complete function is always
composed of an interface and
implementation put together and the
implementation statement is just the
jump across to the other part so when a
caller calls a function they're calling
an interface and an implementation
together and this just connects the two
second thing if there were parameters to
the function I know there aren't for
this one but if there are parameters the
parameters in the function interface are
the same objects as the parameters in
the function implementation there are
not copies and that's going to be
important because we are going to want
to make assertions about L values as we
get further third thing the
implementation produces the result of
the function unless it's void of course
and the implementation returns something
the epilogue can examine the returned
value using the identify
result and but the epilogue does not
return its own value it just when the
epilogue completes the results of the
implementation is the result of the
whole function I know that's a lot to
grab right now but we will see some
examples in a bit so if we had a
function that calls this say bar here we
have an execution path that runs through
the pre call region through the prologue
through the implementation body through
the epilogue and through the post call
region as you might expect function call
on the Left implementation connection
whatever we'll call that on the right
but I draw this not because I think that
was unexpected
but because I'm going to be talking
about local reasoning today I'm going to
be talking about covering our programs
in a collection of neighborhoods that
overlap and cover the execution path and
we're going to reason about the behavior
of each neighborhood independently and
then use the fact that they have to
agree in the overlapping regions in
order to make global conclusions about
the correctness of our program so we
divide this part of the execution path
into two parts a calling neighborhood
which includes the pre call region the
prologue a mysterious gap where the
implementation happens the epilogue and
the post call region and the other
neighborhood is the implementation
neighborhood which has the prologue the
implementation body and the epilogue but
knows nothing about the caller we're
going to talk about them independently
but notes that the neighborhood's
overlap in the interface that's what an
interface is it's the overlapping poor
Asians of the neighborhoods where the
neighborhoods overlap we're going to put
one of them in charge one neighborhood
is always responsible for any anything
that goes wrong any undefined behavior
so in the prologue the calling
neighborhood is responsible for any
undefined behavior and I know you might
be thinking because people asked this
last time I gave this talk but whoever
wrote the implementation might have
written the interface that's not your
but that's not the calling neighborhoods
problem the calling neighborhood just
has to look at the interface and say if
I can't make the Prolog work I can't
call the function likewise the
implementation is the implementation
neighborhood is responsible for the
epilogue if the implementation can't
make the epilogue work it must not
return and that's how we're going to
piece things together knowing the
implementation gets to see what happens
in the prologue and the caller gets to
see what happens in the epilogue but
they're not responsible for that they
know somebody else took care of that
it's also worth noting that each
neighborhood fits in a single
translation unit local reasoning like
this gives us it gives us reasoning that
can be checked on the translation unit
level so separately compiled the proofs
of correctness the interface is of
course in both translation units that's
why it's inline inline functions are
functions that can be in more than one
translation unit so the translation
units overlap usually in a header file
that's where you put generally put
interfaces so now we know about
interfaces we can return to the question
of what's the basic interface and I gave
you one answer already which is that the
basic interface is what you have before
you write anything down
here's answer number two this is the
basic interface it's what you have
before you write anything down I'm not
going to end the talk here the rest of
the talk is going to be about what
things are implicitly part of the basic
interface what things do not have to
write down and first thing no not the
first thing thing zero of the basic
interface rule zero is this at the
points where responsibility passes from
one neighborhood to another there must
be no undefined behavior so far if and
that is really the basis of all the
reasoning we're going to see if you
can't get into the function without
under undefined behavior then there's no
way for the implementation to prove
anything so the caller is responsible
for making sure there's been no
undefined behavior so far at the point
the implementation is entered and the
implementation is responsible for there
being no undefined behavior so far at
the point control returns to the caller
and another bit of notation I'm going to
put the big blue dot next to things that
can go unsaid so blue dot means that's
part of the basic interface you don't
have to write it down
but I'm writing it down and writing it
down anyway are we okay I'm writing it
down anyway
because that's what this talk is about
writing down the things that you don't
have to write down
ah one more case where there has to be
no undefined behavior is a little
trickier to write down more notation
this is the fancy version of the
implementation statement that gives us
both an ordinary epilogue to execute
when the implementation returns and an
exceptional epilogue to execute when the
implementation throws an exception or
when the regular epilogue throws an
exception I'm going to say there has to
be no undefined behavior so far when we
exit by exception as well as when we
return because again you can't get
anything without that guarantee worth
noting the return at the end of the
regular epilogue and the throw at the
end of the exceptional epilogue are
implicit I won't be writing them down
for the rest of the talk
they've got the big blue dot next to
them so that's rule 0 but let's try
something a little more practical here's
a little function I've given it the
basic interface it takes an integer
reference in it sets that integer to 5
and the question we're going to ask is
what could possibly go wrong and here
are three things that can go wrong first
thing we write off the end of it a
second thing we write to D allocated
memory third thing we write to a
constant all of these things cause
undefined behavior in the implementation
function or in the implementation of the
function foo they're dangerous in the
callers but the undefined behavior is in
a different neighborhood and that's
something we have to find a way to avoid
if we're going to do local reasoning
we have to make sure the danger and the
fire are in the same neighborhood so
what can we do to get the danger in the
fire into the same neighborhood we can
write this claim writable in the
prologue and again I've just invented a
couple of things but the point of claim
writable is to move the fire earlier in
the program so that the undefined
behavior happens in the same
neighborhood as the danger once we do
that we can reason locally from the
danger point to the undefined behavior
point and see that there's really a
problem a little deeper I claim is a
kind of assertion
it's the mathematically provable
assertion mathematically it acts as an
existential modifier over execution
paths any mathematicians in the room ok
claim is an existential quantifier over
execution paths and writeable is an
expression i've written not a slide for
this one writable has no effect when
assignment of an R value of type T to
the to the the L value has defined
behavior otherwise the behavior is
undefined so writable is a strange sort
of function it exists only to provide
undefined behavior sometimes it either
does nothing or it has undefined
behavior depending on the conditions but
it's exactly what we need inside of this
claim because undefined behavior means
you can't show there's an execution path
through it so the claim
fales there is no execution path if you
can't write to the variable if you can
write the L value then there's an
execution path the claim succeeds so I'm
gonna put the blue dot next to claim
writable in this interface I'm gonna say
generally when we pass in an integer
reference we mean for it to be writable
you don't even have to write that down
integer reference means that it means
that the implementation gets to write to
it and similarly we can have this sort
of problem here I've changed the
implementation of the function the
implementation here reads from the
variable that's been passed in this
variable is uninitialized again danger
in the caller fire in the implementation
we need to get the danger and the fire
into the same neighborhood we do it the
same way we write claim readable in
Prolog of the function and readable very
much like writable readable has no
effect when L value to our value
conversion of the l value has defined
behavior otherwise the behavior of
readable is undefined so readable and
writable these are what I call
capabilities they named things that we
aren't doing yet but that we need to do
later and particularly they named
operations that are going to cause
change or are going to be affected by
changes so readable and writable part of
the basic interface here I pass in an
integer reference I expect it to be
readable and writeable yes
see interface is knowledgeable about the
implementation
why do we have to claim for this
implementation perhaps we wouldn't but
I'm saying writable Oh the question the
question is why do we have to claim
rightful for this particular
implementation and the answer is we
could have written a different interface
here I'm saying this interface the basic
interface the implicit thing is going to
be writable if you pass in an integer
reference and we will see you later
ways to avoid saying quite so much but
the thing you get for free for in 2m
purse and is readable and writable
likewise we have think we can reverse
the situation we can have danger in we
can have danger in the implementation
leading to undefined behavior in the
caller as in this case where I have
actually taken a variable that the
caller passed in destroyed it
constructed and an uninitialized
variable in that spot so that the caller
shouldn't be able to it won't be able to
read from it and that's kind of crazy
you should be thinking that code is kind
of crazy you shouldn't do that but if
you're thinking you shouldn't do that
then don't do that is probably part of
the basic interface so we will be seeing
a lot of stupid code today showing
reasons why don't do the stupid thing is
part of the basic interface but once
again oh I'm going to just whoops I just
do
is that not the same slide as before oh
I put in a different bug here right no
ah I read the wrong one ah right this
one's writing to a constant but we need
that thing to be writable and this one
is what I described before sorry I can't
really even for squeezing you over here
I can't really see this screen very well
I'm used to looking at that so this one
was the one I described before you can't
read from that because we've managed to
put an uninitialized variable where the
initialized variable used to be so we
can solve both of these once again we're
going to claim readable and claim
rightful in the epilogue so that if you
pass in an integer reference we're going
to say we expect the basic interface
expects that it's readable and writeable
on the way in readable and writable on
the way out and I'll go further if
there's an exception the general
expectation is that even if there's an
exception that variable is still
readable and writeable on the way out so
there we have some code that destroys
the thing only but only on the exception
path don't do that don't do that as part
of the basic interface now if I keep
this up the interface is going to get
very complicated indeed I told you they
were going to be complicated I'm going
to shorten it a little by inventing this
function proper a proper integer L value
is one that is both readable and
writable
and we're going to claim that the L
value is proper in the prologue in the
regular epilogue and in the exceptional
epilogue here of course if we pass in a
constant ature reference we don't expect
writable if it's Const just readable so
proper is different for constant ature
references and integer references more
generally proper is an assertion we can
apply to an L value it's specific to the
CV qualified type it's implicitly
claimed at those three places entry to
the function exit from the function exit
from the function with the exception for
parameters function results and thrown
exceptions there's some weasel words
there about star this because star this
doesn't have to be proper before a
constructor when a constructor fails or
after destruction but implicitly these
things are implicitly claimed proper
immediately before responsibility is
passed between neighborhoods so proper
for us is going to occupy the space of
class invariant it is the thing in the
type system is the way for the type
system to affect the basic interface but
it's not quite the same as a class
invariant first it's not invariant it's
just frequently asserted we will be
asserting that things are proper pretty
often but that doesn't mean they're
proper all the time just pretty often
also worth noting that proper depends on
the CV qualifiers and that's something
that class invariants don't get you
because class invariants were invented
for functional programming and there was
no change and so there was no CV
qualifiers in functional programming so
that's proper back to our examples here
we have another example where we have
said we've implicitly claimed proper
here this variable is uninitialized
turns out this function would have been
fine with an uninitialized variable it's
just going to assign to it so for this
function
proper on entry is a little much so I'm
going to throw in a syntax that I'm not
going to talk about much today but I'm
going to say you need a syntax say this
one for saying proper doesn't apply to
this particular interface so this is an
example of subtracting from the basic
interface we're going to say this
integer isn't proper gives us in a bit
of a hole as to the right ability of X
though now in this example knowing
everything we know that X will be
writable but locally in the phone in the
implementation neighborhood there is no
clue that X is writable a different
caller might have passed in a non
writable X so we have this situation
where in this caller X is writable in a
sort of global distant sense
but it's not writable in the
neighborhood it's not locally writable
because we haven't been told and we can
have the reverse situation can also come
up here I put claim writable into the
interface now locally writable in the
implementation but the caller doesn't
know that X is going to be readable on
the way out
so X or I guess yes X is not locally
readable after the function for the
caller and so we're going to have to put
in a claim of propriety explicitly in
the epilogue here and we're gonna have
to stick in a claim of right ability in
the in the exceptional epilogue you
might notice you start using improper
things get a little out of hand you have
to start writing a lot more stuff down I
think therefore this syntax is not quite
right I've got some better ideas but so
if you're a language designer don't use
that it's not quite baked yet but the
point is we need some relief from proper
sometimes on the other hand that
business of being locally writable is
really neat because usually when we're
asking is that can we write to this
variable we don't mean is it allocated
to some part of our program we mean is
it okay for this particular function
we're writing to write to it and you
know that's the situation we run into
the devastating situation with buffer
overflows for example it's not that you
are writing to something that'll cause a
core dump because you wrote to it
that's bad but worse is you wrote over
some other data that was important to
some other part of your program that you
weren't supposed to be writing so
locally writable is a much more
interesting condition than globally
writable so I'm going to change the
definition of writable to match it yes
the question is in the exceptional
epilogue here why did I write to say
claim writable instead of claim proper
that is why am I not asserting that it's
going to be readable if an exception is
thrown and the answer is it's dangerous
to claim more on an exception than you
got on the way in from the prologue
because if something goes wrong before
you fix the variable you're left with
whatever you had when you in whatever
properties you had when you came in in
this case I know assignment to an inch
isn't actually going to throw an
exception so we would have been fine we
would have been fine if there weren't an
exception of what belong at all maybe
but more generally claiming more in the
exceptional epilogue than you get from
the prologue is dangerous anything else
okay locally writable I am changing the
definition of writable to the local
version this one has no effect when
writable has been previously asserted in
the responsible neighborhood more
recently than the L value has been
destroyed and I know that more recently
than the yel value has been destroyed as
kind of weasel words we'll get to that
later but otherwise the behavior is
undefined
this is a weird definition here I'm
saying you get writable from having
previously asserted writable but this is
exactly what we want in our
implementation we might want to assert
writable and the way we might get it
from our implement in our implementation
is by having asserted it in the prologue
but we're not responsible for the
assertion in the prologue the caller is
responsible for the assertion in the
prologue and maybe it can make that
assertion work because there's an
assertion of writeable in the caller's
prologue or maybe it got it from the
epilogue of a function it called and
each step of this the chain is in a
single neighborhood the logic the
logical step is we've seen the right
ability asserted and so we can assert it
again in the same neighborhood when we
are responsible each step is in one
neighborhood but the path crosses many
neighborhoods because the assertions can
appear in the interfaces where
neighborhoods overlap so right ability
traces a path from the construction of
the object where it originates into
interfaces into more interfaces out of
epilogues and to the place where we call
it so the global proof that the object
is writable is this long path that it's
taken to get to our claim but the local
proof is just it was claimed up there in
our prologue
okay yes so the question is it seems
like the very first right of all
assertion will be undefined it will it
will will be undefined it will fail by
this except there's this tiny
parenthetical that I didn't actually
speak including as a consequence of
construction
if you imagine constructing an integer
to have an interface around it the
epilogue of that construction will give
you write ability that is constructing
an integer gives you write ability so
the and yes some magic must have
happened that the compiler provided in
the when you declared a new integer or
that the library provided when you need
a new integer but wherever it came from
it wasn't your neighborhood it came from
something below your neighborhood so yes
it seems like it's Turtles all the way
down and it kind of is there are these
tiny things that we rely on compiler
magic for or if you would like open up
the compiler and see what's actually
going on it's not really magic it's just
that right ability came from a byte on
the stack that it knew was writable
already you know it just handed us that
right ability but from the point of view
of a C++ programmer there are turtles
below that a level that we can't see
um anything else yes in the same
neighborhood in the responsible
neighborhood so you can you know the
first writeable in your neighborhood not
your problem you're probably not
responsible for it because it's probably
in your prologue or the Apple oh the
question is whether the I mean
previously asserted in the same
neighborhood and I mean previously
asserted in the responsible neighborhood
writeable can be asserted in interfaces
and be in more than one neighborhood at
once but the responsible neighborhood is
the one that we care about and so yes
the first assertion of right ability for
an object in your neighborhood ought to
be one that you're not responsible for
and then after that you can go to town
readable by the way works the same way
no effect when readable has been
previously asserted for that object the
little parenthetical is different here
it says including as a consequence of
initialization or assignment so
readability tracks a path much like
rideability
readability comes from a previous
readability maybe in a prologue in
different neighborhood it comes from
maybe an epilogue of some other function
and it keeps going back to the point
where there was an assignment or a an
initialization of the object and again
we get the global proof by piecing
together these local steps and each step
is in just one neighborhood and again we
have these weasel words more recently
than the elf value appears to have been
destroyed here's the first
art fixing the weasel words we're going
to invent a new capability destructible
it works exactly the same way
destructible has no effect when
destructible has been previously
asserted for that L value including as a
consequence of construction you would
get destructible for free by
constructing an object and again we care
about it only in the irresponsible
neighborhood and more recently than the
L value appears to be destroyed the
weasel words are still there and again
otherwise the behavior is undefined so
like the others this can still be male
AZ implementation or in an
implementation that just wants your code
to go fast it can be implemented as an
empty function nothing has to be done in
an undefined behavior case and nothing
at all is done in the define behavior
case so the function could be
implemented as an empty function or it
could be implemented as something that
actually keeps track and the keeping
track version will be much nicer for
debugging but the empty function version
much nicer for making your code go fast
so with that in hand let's look back at
the mysterious gap I told you about in
the calling neighborhood the calling
neighborhood has this gap where the
implementation appears we know something
happens there but we can't see it we
need to put some limits on what can
happen there so that we can reason about
what happens afterwards and here are
some things that we can say anything
that's locally readable to the
implementation might be read from
anything that's locally writable
might be written to anything that's
locally destructible might be destroyed
so in the prologue we saw what
capabilities were asserted and we expect
the implementation might use those
capabilities but more importantly we
expect the implementation won't use the
capabilities that we have that we didn't
pass to the implementation that is if we
have a variable that's readable to us
and we don't and it's not mentioned in
the prologue then we assume that the
implementation doesn't look at our
variable and that should be kind of
obvious we declare a variable we don't
pass as a parameter we expect the
implementation doesn't use that variable
similarly we have a variable that we
didn't give the implementation
permission to write to by saying it was
writable in the prologue the
implementation doesn't get to write to
our variable and finally if the prologue
doesn't say that the variable is
destructible the implementation won't
destroy our variable so we expect that
the capabilities we reserved from the
implementation the ones that we don't
that aren't mentioned in the prologue
won't get used by the implementation and
that gives us a way to talk about what
functions destroy objects if the
function doesn't claim destructibility
in its prologue we can say it's not
going to destroy the object and that
gets rid of a whole host of those
earlier problems because destroying
objects willy-nilly can cause an awful
lot of undefined behavior and that
leaves us to another question should we
make destructible part of the basic
interface like we made readable
writeable part of the basic interface
that is should destructible be part of
proper is that a usual expectation when
we pass a reference to an object into a
function and you could say you know some
functions do need that expectation but
really those are dangerous functions I'm
gonna say the basic interface doesn't
pass destructibility if you want
destructibility to go from one function
to another you have to say so
when you write down the functions
interface but there are a couple of
cases where destructibility is needed in
the basic interface and that's these if
we return a value of an object type that
is not a reference then we had better
return a destructible object of that
value type because otherwise the caller
isn't going to be able to ever destroy
it likewise if we throw an exception we
had better throw a destructible
exception because at some point that
exceptions have to has to go away I'm
not actually showing you the crazy code
that you can write to violate these
expectations but if you want a little
puzzle you can go home and try to figure
out how to throw is an exception that is
not destructible
there are a couple of other places in a
constructor we have a claim of
destructibility automatically when or
sorry in a constructor it's not a claim
it's a posit it's actually I'm fudging
just a little bit here but posit is the
is the other assertion posit is the
universal quantifier over execution
pants this is some this is how you
introduce a thing that never was known
before you say I'm just going to assume
this is true so posit is the dangerous
assertion we won't be seeing very much
of it but at the end of a constructor we
can posit that the object is
destructible because that's where it
happens likewise we in the constructor
we have if the constructor fails the
exception has to be destructible in a
destructor the other side of the slide
we claimed destructibility at the top of
the destructor for the last time this is
where destructibility goes away and you
shouldn't destroy an object if it's not
destructible and that's where it gets
enforced same thing if the destructor
fails the exception still has to be
destructible there's a little bit more
to say about constructors and
destructors there's a couple of
assertions I'm not going to go into the
details of just what these mean but I
think that we can agree that there are
places you are allowed to construct an
object and there are places where you're
not allowed to construct an object and
I'm going say unoccupied space means
it's okay to construct an object here so
a constructor takes unoccupied space and
turns it into
destructible object and a destructor
takes a destructible object and turns it
into unoccupied space and again we see
the bit in the exceptional epilogue we
don't claim more than the exceptional
epilogue than we had coming in if the
constructor fails we're back to
unoccupied space if the destructor if
the if the destructor throws an
exception it turns out the sub object
destructors still run we still get back
to unoccupied space so constructors and
destructors get goofin unoccupied space
to destructible object and back and this
shouldn't be too surprising I think I
know I'm saying tons of obvious things
the basic interface is about saying the
obvious things but you're trying to
write them all down see ok let's try out
destructibility and how much time do I
have ten minutes okay I'll see we might
have to break in the middle of this
section and I'll back up but here we go
here is a this is this is the falls
assignment operation instead of doing an
assignment we're going to destroy the
object and construct a new one in its
place and because we're doing it that
way we're going to claim destructible in
our prologue and then we can as usual
wonder what could possibly go wrong here
is something that could possibly go
wrong we claimed destructible in our
prologue
but after we destroyed the object we
created a new one and we didn't tell the
caller that that was destructible and so
when the caller implicitly tries to
destroy the object we created it can't
because that object appears to have been
destroyed already that's us keeping
track of appears to have been destroyed
this interface appears to destroy the
object that's passed in and of course
that's a problem that causes code that
we thought should work to not compile
worse would be this code here we've
construct we have created the object on
the heap
there is no implicit destructor here the
destructibility of this object that was
created by the implementation has been
lost he can't ever be destroyed but we
didn't notice we've just leaked that
object we don't like leaking our objects
so I'm going to say at the end of a
function here and at the end of the
epilogue at the point where
responsibility is transferred there has
to be no leaked destructibility that is
all the destructibility that was known
to the implementation at that point has
to have been mentioned in the epilogue
so I can't just let the destructibility
fall flat on the floor in the epilogue
it has to get passed back and that gets
rid of our memory leak or get in this
case it doesn't actually get rid of the
problem there but we can add in a claim
of destructible to get around that now
we had destructibility at the end of the
epilogue but we mentioned it so we're ok
it's not leaked
and similarly if there's an exception no
elite destructibility we want all the
destructibility
to stay in play until the object is
destroyed we can ask one more question
what about readability and readability
do we want the readability and write
ability to necessarily stay in play till
the object is destroyed there is a weak
argument against apart from destruction
there aren't any operations that get rid
of readability or write ability I mean
somebody at the last talk brought up
some eunuchs this call that actually
does but for the most part no but here's
the important point if we keep the
readability and write ability in play we
can say you have to have them in hand at
the point where the destructor where the
destruction happens that is if
destruction requires the readability and
right ability we can know that the
readability and write ability are gone
after destruction because the interface
for destruction is going to take those
capabilities in and not give you them on
the way out and I think that's a pretty
good place to break for the to have our
break are there any questions before we
go excellent excellent question the
question is how does this generalize to
all other operations for a value more
generally we're going to have to be able
to invent
new sorts of capabilities mostly by
combining existing readability and
rideability
in interesting ways and these
capabilities can be associated with
proper for a particular type so that a
so that we know a proper vector for
example will have the ability to read
and write its elements or a proper
constant actor would have the ability to
read its elements so invents the
appropriate capability name the most
usual set of capabilities for the object
proper and that brings them into the
basic interface anything else uh why do
I think the the fact that very few
operations forget readability and right
ability is a con for making not leaking
readability and rideability part of the
basic interface I suppose you might
think that it's needlessly complicating
the basic interface to say something so
obvious now that I think about it the
basic interface is all about
complicatedly saying things that should
be obvious so maybe that's not much of a
con at all I agree it's a very weak
argument but I'm against it any I am pro
on this issue I just tried to make the
best other side I could anything else I
guess it's time to take a break</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>