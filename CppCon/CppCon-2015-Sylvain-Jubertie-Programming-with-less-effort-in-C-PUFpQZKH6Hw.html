<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Sylvain Jubertie “Programming with less effort in C++...&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Sylvain Jubertie “Programming with less effort in C++...&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Sylvain Jubertie “Programming with less effort in C++...&quot;</b></h2><h5 class="post__date">2015-10-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PUFpQZKH6Hw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is josh BTW i'm from the
university in all of allianz friends and
i'm going to present this talk stator is
programming with less effort in C++ so
it's not a technical talk so you can
just relax I will not talk about meta
programming expression templates
concurrency so you can just relax so am
i some I am an assistant professor at
the University of corneal i'm also a
researcher at the computer science lab
laboratory in the pile computing team so
no singulated to to software matrix but
you you will see later why i will talk
about this subject today i'm also a
teacher of c++ at the Technical
Institute and the computer science
department in the same University so
everything started when one day I
decided to to take some distance with my
pile algorithm so when you write a
parallel optimized code you need to deal
with the architecture you need to deal
with cash optimization organize the data
as a structure of array a rough
structure oh you feature blocks of
memory into Keshi Keshi is how do you
vectorize your code you create some
threads by using OpenMP silk and lots of
other libraries so I took some distance
and I said I started to wonder how much
effort does it need is it required to
just write parallel codes so if my pal
Cod's is two times faster and I spend
maybe 10 most 10 more times to write it
is it really a good deal so I started to
use software matrix just to know if I
can evaluate the programming effort from
my code so it's a work which was
replicated in 2012 with my colleagues
drove her ego and ferric Yaga and today
I'm going to present an extension of
this work to commence improves programs
so I will start by presenting software
matrix and what is a programming effort
then I will present you some code
samples then ow you can automatically
compute matrix from your code using the
clone lip tooling and some reserves in
some conclusion on the current say
please piston down and what it brings in
terms of programming effort so let's
start with software matrix so suffer
matrix are measurements on the code just
to determine simple thing like code
coverage command and CG and in our case
we are more interested in the
programming effort so to measure the
programming effort of your code you can
just count the number of lines in your
code but it's not a really good metric
since for example you can have a
statement with just a type a variable
name ok or you can have a line maybe
with a hundred of characters and lots of
types lots of templates and sensation or
so OC so the source line of code is not
a good metric except if you consider
programming in assembly program with an
assembly language because you saw
statement in this case is fixed nearly
fixed then you can determine the effort
required from the length of your code so
instead please please it's a bit more
complex so we decided to use the alstead
matrix which were designed by Morris
I'll stayed in 1977 and which are
commonly used in some some software ok
so of course this is this matrix are
just empirical ok you make some
assumptions on your code you can say
that treating a type are declaring
available as a certain costs and you
just have to count tokens in your code
you also have the problem with language
dependency because you can compare the
same code in Java in C++ it's nearly the
same but if you use something like
prologue or something like camera or so
long a programming language it's
difficult to compare two identical
programs into the foreign language
oh the state matrix r are based on
measurement theory and alstead I see the
design this matrix to be independent of
the underlying language so II stated
that the code can be viewed as a
composition of operators and operands
from the number of operands and
operators in your code you can count
them you can deter mined the number of
dt distinct operators the number of
ding-dings distinct appearance and you
can obtain some mirrors so on the bottom
of this slide you have the alstead
matrix so you have a subprogram lens you
can eat our mind from the sum of the
number of operators and upper ones seem
straightforward you have the program for
like vocabulary which depends on the
number of distinct operators and
operands you have the volume of your
code which depends on the program lens
but also on the program vocabulary so
here you have a lug which is quite
difficult to explain in fact you can
view the card as a music part so you can
just increase the length of the path by
using the same symbols but you cannot
increase you have a fixed size thousand
number of symbols of Abel's so the
volume of God just increase more in
length than in vocabulary
you also have the difficulty of your
code so it depends on the number of
total the total number of appearance and
the number of distinct operators and of
these things Oberon's so if you want
more details on these measures so you
just have to google it I think you
search for our state matrix explanation
because Marissa stead died in the
nineteen seventy-nine just two years
after it published this matrix so we
have a few explanation on why he chose
to determine to to compute these metrics
as described here the most important
metric here is the effort you can
compute the effort from the difficulty
ends of your volume of akkad this is a
measure we wish seems to be the most
important and which is related to the
time you will spend to write your
algorithm okay so as the matrix are
independent of the consonant language so
you doing you know we need to define
what has your petals n overruns in C++
just to compute this matrix so operators
are our classical C++ operators but not
limited to you can also add return and
other control statements as operators
zero parents are variables constants
types
types are considered LeBron since you
you can pass them to templates as
arguments so we consider them as
appearance so it seems yes it is
empirical I've said matrix our empirical
measures so it seems a little bit it's
difficult to to understand why it works
so i will show some cause i will show
you some results we have measured the
time span by are afraid ago during this
PhD to write some peril codes so these
measures are similar to those obtained
with arson matrix why okay just it works
so you can define your whole matric if
you want but we prefer we preferred when
we started this work we prefer the
implemented an existing matrix just to
avoid comments on you are not
specialists in this domain and okay just
just try some something yeah yes so
first code samples so I talk to you
about a paper we write we have returned
in 2012 so I will start with some of the
code we used for this article so the
goal was to just try to write some
algorithm perform a trick multiplication
and to try to optimize it and to try to
use a parent p on it and see how many
time how much time you can spend on it
just to
obtains the desired speed so we started
with the sea like algorithm to multiply
two matrices so here's a card nothing
special just three four loops to perform
the scalar products of each element in
the destination matrix so this is the
knife version of the code every student
should write sinking in his life you can
just by swapping the two last group
obtained a slightly different version of
the code we share which is also correct
which consists in just performing a
multiplication of the scalar product for
each element of the first row then
starting over the first row and adding
the second element of the scalar product
and so on so this version is similar so
you will have the same effort it
requires the same if our true to to
write this code but it's faster so with
the matrix you obtain the same effort ok
everyone agree your turn same effort but
you have maybe saatchi you have a
speed-up of you may obtain such a such a
percent of performance with this code so
why
because if you know how the cash work
sees the shine of the code just use
middle education between two contiguous
element so in this case you have less
cash misses your card is faster so the
matrix gives you the same effort when
you test the program it's faster so you
can determine from this code if the
developer who produced this code has
more knowledge if it's better so if you
want to I off someone you may give give
her a piece of code and just ask her to
write a code with a rich require semi
fault but is faster why not so now
another version of this code using SIMD
units so it's little bit more complex
you need to to deal with interest sinks
we were just to load a contiguous block
of memory from memory into simg
registers and perform operations okay if
you prefer to use the / MP you just have
to take the second card here and just
have the pragma on it so you have
different possibilities so now to
summarize for each version we compute
the effort of the code and we measure
the speed up so if you take the second
ilysm okay you have any thought of 9,000
if you optimize likely the code just by
adding this version is not shown here
just by adding some temporaries just to
accumulate scalar products into a
register instead of placing the value in
memory each time you have any fat out of
12,000 or if you use the SIMD code ight
requires an effort of 700 more than
700,000 so you notice here that it's
nearly on droid x as the time required
to write the second shell program but
you can expect on your speed up of four
so is it was it just to spam the this
time writing this algorithm just to
improve the speed of the the code by by
four so to summarize this result if you
want to back to us your code you can
expect the speed up of two to 10
depending on on your processor you use
SS e AVX nail on ARM processors but if
you rely on interest six to write your
code then the requiring effort is really
really important so maybe the best thing
to do is just try the second shell
program optimize the access to the cash
and let the compiler just vectorize this
code
Oh openmp okay you can add a small extra
effort to your code just we are just to
write a pragma but you can expect a huge
speed up if you have a lots of calls on
your processor it also depends on the
you all go ism if you have something
real regular like the matrix
multiplication you can expect the
speed-up of nearly 40 on 48 processor 48
car Numa computer you can also use my
advanced technique more complex
techniques like blocking tiling okay in
this case you need to rewrite your code
just to weigh all those memory access
just to hear all loops everything so the
speed up depends on the complexity of
the algorithm and it requires lots of
evil so as this result we can extend
them to a general programming so we only
consider a pearl programs now we ask
ourselves can we apply these metrics to
simple codes like return in C++ and test
if if you just modernize your code and
use new standards maybe it requires it
will look a lessee fault so if you take
this simple program okay nothing special
here you can consider a bracket parents
currents return statements as operators
and Japan's are int main st d
if you modify this code just by adding
you're using a statement on your code no
code then you obtain a similar
difficulty less volume because you
remove all the occurrences of STD you
remove all the occurrences of Collins so
you obtain so it requires less effort of
course it's a simple small program but
if you just you see out or some other
members of the STD namespace then the
effort will will be reduced more if you
use a new super spruce 11th features
like auto you can see immediately that
the effort required to program this the
second version is less than the first
one so it's abused but you have a way to
measure it so all these tools without
these two so you can convince people
just to try simple spruce with a new
standard because now it's easier you
have zero keywords you have the dick
type you have lots of things I will show
some other examples and you can measure
it so if your clients come to you and
just ask yourself to use old C++ you can
tell em that ok I can it can be faster
to to use new standards just to produce
your code so it will cost less me if you
consider lambdas okays old way was to to
use functor just too
to use functors into stl algorithms for
example so now you just have to put a
lambda inside your algorithm and that's
it so let's difficulty less volume so I
let you compute this from this this
formulas here to have the exact effort
required so let's see fun so c plus plus
11 brings fun things okay my students
sell the light coat oh okay they put
Otto everywhere but it's not only fun
it's also a feature which allow you to
reduce the programming a fault and to
produce more code in less time instead
of pushing back elements into vector the
old way you can just use initializer
list so yeah it's true it's trivial to
to say that it's it requires I see fault
of course you have exceptions if you
consider move semantics it's something
really difficult for example for
students just to to integrate into the
code why because it adds code to your
existing code it cannot remove some
codes you need to add some code just to
integrate the move semantics inside your
code so it means it requires more
thought but maybe more performance so
it's a it's a feature which which which
which is very specific and we wish does
not allow to reduce the programming
effort of course most of peoples of the
people and the students and Mike some of
my colleagues just do not want to hear
about move semantics because it's too
complex for them just to understand and
to modify the existing codes so in C++
on 11 you have lots of new features
which helps you producing codes faster
so you have wednesdays loop you are
varying link templates I think you can
consider as a boost NP a library just
look into sort of the sources just see
the number of macros you need just to
have a fixed number of possibilities now
with vitac templates you can rewrite
this code just with some vitac templates
so it removes a lot of lots of
complexity into your card you also have
strayed into the new star house so you
do not have to use these Reds anymore so
you remove a pointer void void pointers
and and so on also have shooters and
lots of new future so now i will present
you how to compute this matrix on your
code using the Klunk light lead to link
library
so the lip chillin library allows you to
generate the ast of your program Travis
it and then transform it so you have for
example three clong tools which are
based on this library so you have trunk
check which just display for example ght
of your program I have an example just
next slide you have come format which
allows you to reorganize your code not
transform the code exactly but just
organize your code to remove spaces and
to ensure that after each function the
the curly brackets are on the next line
and and everything is aligned correctly
according to to a default format we also
have come with a nice which detects for
example for loops and try to replace
them with range based follows it also
removes types by Auto when when possible
so we clung light filling library you
can also write your own tools to perform
some static analysis to remove for
example automatically you news variables
are true in to add comments to generate
comments inside your code example you
you produce your card you want comment
before each function you create the
program which the text which detects
each function in your program and just
add determines before another ID I add
on monday during the talk of BL it's to
implement the say please please
car guidelines using these tools since
you can transform the code you can
detect patterns you can detect patterns
remove them and replace them with
something else so you can check if your
program complies to some guidelines so I
have a demonstration of the clown check
okay so it's really simple to use ok so
you tap kong check ok you just need to
install clunk tools I I think the name
of the package on debian ubuntu systems
ok you want to damn tht so you have this
parameter then you provide your file and
after stashes at the end of the line you
can for example add some flags if your
program is a citrus press 11 complaint
so on this example so it's a simple
example you can see maybe when I seat ok
it's ok
okay so you have three kinds of nodes in
your ast you have declaration in green
you have statements in purple and you
have expressions so not in this example
but maybe you know someone okay so I I
made a mistake I've included the
iostream file so it also passes see the
complete iostream library so three
complex okay so ght give you access to
these three kinds of notes so for each
node for example declaration node you
have named declaration if you have a
name if you have a name associated to
your declaration if you have a value it
sees a value declaration which inherits
from name declaration and so on so if
you have a function parameter it's
called here palm valdek it generates
from verdict and so on so you have a
Yaqui of types which is complex and I
will show you that sometimes you have
problems using all this type just to to
cast seen swords so the limb tooling
libraries is
is a bit complex to to just manipulate
so when you want to to use the leg
feeling library the only thing the main
thing you have to do is to write an ast
Jeter missionaries from reclusive iced
tea visitor so you can recognize the
other curls curiosity I going Tom played
Patel and you have to declare for each
declaration statement expression you
want to visit or if you want to perform
some transformation on it you just have
to declare the visit function associated
with the type so if i want to just
display every declaration in my code I
just have to override the visit deck
function okay it takes to declaration as
parameter and then I call the dump
method of the Declaration just to print
the information about the name to type
and so on of the regulation then I
return true just to continue to travel
the tree if I return false then it stops
traversing dissidence and you cannot
have more information on this type so
I've developed with Adnan Federer the
matrix calculator tool which is based on
the library and this library so the
first version was developed by Adam but
few weeks ago I will add that we did
that news the little in library as it is
intended to be so i am writing the
second version which is
still highly experimental of the library
and this this tool is available on
github so i can show you some issues i
add writing this this tool
okay so as I said earlier if you include
an HT h PP file inside you your current
CPP file then the preprocessor just
include it in it so if you don't want to
consider this this file just the CPP
file you need to detect if the current
declaration is in the main file on so
it's not really well documented so I
found the solution and on some websites
here so it was the first issue you also
have several issues because of the Yaqui
of types so for example when I started
to to create the calculator of simply
spruce Rick up deck Sibley's reciprocal
deck our class okay our c++ class tricks
Union and in EM so each time you have
this kind of a statement in your code it
is traversed using this function but if
you consider lambdas lambdas linear it's
from this object so if you take this
code and if you do not test if the
record is actually a lambda then we
asked for the name of the class for
example and in the case of a lambda you
will have a segfault so
it's sometimes difficult just to know
exactly how you travel so tree okay
something you something difficult also
is that in fact the compiler transform
your code so a lambda is no more lambda
when you you compile it it's replaced by
a hunter an anonymous functor with an
operator parents and so so you don't
have you have to detect this just not to
count for this operator and everything
in your inner analyzes okay so as you
can see you have visit C++ meter deck 4
meters c++ constrictor deck for concert
halls and so on so for example if I want
to detect and to add the explicit
keyword to my analysis as an apparent I
just use a method is explicit just with
the mine if the constructor is actually
expressed so this work is actually based
on empirical statements so it's verified
in practice so if the if you compute the
effort of two different pile codes for
example and you have a ratio of 10
between the two codes and in practice
it's verified light it's around 10 times
faster to write one code than the other
so measuring efforts ratio between code
seems relevant but it does not take into
account the the experience of the user
so if you need to learn the library
before using it this time I is not taken
into account most of the C++ 11
functionalities help reducing the
programming effort ok so it's a good
news and I hope it will continue to
progress in this direction with a new
new standards but if you consider adding
new keywords new annotation in the code
like a soul in talks is this which you
automatically increase the complexity of
your language not only the complexity is
not only the programming effort but also
the comp the learning a thought of your
language so maybe sometimes we need to
remove something or to simplify things
maybe with the new use of using maybe
typedef is will will be deprecated soon
but you have the compatibility with C so
I don't know so from my experience with
students as a super spruce teacher use
it
using auto requires a few key knowledge
so students tend to use zero to a
keyword everywhere so it's fast because
it's fun for them so replacing the STD
vector consider later and so on by just
by auto it's it's really fun so so it
was fast to to adopt it decorah type its
bit more difficult because if you have
templates and you want the type of it's
more complex lambdas also considers fun
by my students so especially when
writing when using the sterile
algorithms using this prefer to me
typedef but if you consider the syntax
you have one more perator we are using
type equals zero type instead of type
def do two types so it costs more but
maybe it's like the sea ella le s
command in UNIX you type alias is the
same syntax so maybe it's faster to it's
more intuitive maybe so range based loop
also valid chill because shorter and
because you don't have to do care on the
beginning hand of the sequence for
example but mixing all these key box is
still difficult you have contacts also
you have Auto ticket tag you are you can
mix it with template parent in
parameters you can okay becomes complex
just too
to combine this give us so maybe if I
have to design another matrix maybe I i
will consider multiplying the cost when
when such keyboards are combined okay
move semantics is especially difficult
just to teach so difficult to understand
for students so and it costs a little
bit more than the other keyboards okay
some feedback on unclog it to on the lip
tool in the library so it's powerful
tool you're already have those some
examples on an Internet just to
transform the code remove seeing
transform things and so on it's
sometimes complex to use so it requires
also learning a thought which is really
important you have to to understand the
type Sharky ow ght is traversed out to
exclude sings and the tutorials are not
always really detailed another thing is
that when you obtain the st the compiler
just already has done some job on it so
for example if you write clays be in a
bit from a so you do not write pride 8a
but in the AST you will find private
because it's implicit when you write it
but it's explicit in the ice tea so
maybe you need sometimes to combine the
lexer just
to verify the presence of the token in
the code and NZ iced tea and compounding
if it's in GST and not in the code then
it simply sit so nope no more effort you
will not add something to you you need
not add a nap around on operator to your
metrics you can also use a con man
denies just to reduce the complexity of
your code because it will try to convert
your types into auto white possible and
to replace for loops traditional for
loops with range based loops so feature
sure work I use a lot of expression
templates in my code just to transform
the code for adding parallel pragmas
openmp pragma to my code automatically
so the user just right map function on
my vector and it will automatically
turns on the coda to openmp an Olympic
code so what I would like to measure is
the ratio between the code the user
right and the code produced by the
compiler it's kind of it's just too much
awesome the power I don't know exactly
the temptu to describe it so the power
of you template of your expression
template ng also in the st you have can
go far to you different ice tea you have
suspended iced tea and you can also
travel inside such a template
installation so this
you can verify with this mechanism with
St that you can count the number of
times your template is instantiated and
so measures the program the Ray Ray
usability of your template another thing
another simple thing to do is to take
into account the balance of variables
because if you write int a gate shot but
if you write int something very long it
costs something just to maintain your
code it's more complex it's longer to
read so it was my fault another ID is to
evaluate my students accordingly to
these metrics so I asked them to give me
a code and then I can compare the code
and see which one requires less effort
and produce for example examples of the
best performance just to to to take into
account the adult say that the quality
of the quad produced by the student okay
and of course we can implement also
there a checker for for guidelines you
can also add lots of seeing ascetic
analysis and so and so I will certainly
a lot have the time to to to do all
these things but if you want to help
okay do you have some questions yes
according to a matrix if a student Oh
meet the const they win yes i mean if if
you if a student is able to produce and
also a mattock cast out that we do a
sweet figured what do you mean by static
instead of static left they do regular
crust okay in fact regular casts cost
less in turmoil fault because you have
just parents and the type instead of a
template with your wizard the type you
want to use so we think that you promote
bad code I have to change some some
sinks in the matrix okay our maybe we
have to change something in C++ just to
to provide a simple cast another
notation or something simple but in few
cases of course you you will not be able
to to have something shot with a new
standards for example using using it
adds z equal power so okay you have one
operator so it increases your big n
so increase your fault so if you of
course if you use static cast on each
line of your code okay it's it will I
will promote a bad code but if you only
have a few static cast in you in the
code it's it's not too it does not add a
huge effort to do yoga thank you okay I
also never said that the Upstate metrics
are perfect so it's some matrix top
drawer back so I feel that the metrics
here optimizing for effort of writing is
that I feel like they're getting you
could produce more right quickly to
write code that's less comprehensible
let's confront ago yeah so to pick an
example from your slides putting using
namespace STD at the start of the file
reduce the number of times you've
referenced that piece of vocabulary and
the namespace operator but it means that
you have to comprehend the whole file to
understand any the piece you're looking
at so if if you have for example for
whatever reason multiple string
implementations you don't know which
string you've got at the place you're
reading it when you're writing it you
know if so I feel this is the criticism
of pearl is it as a right only language
and I think this will give you the same
emphasis of okay like if you're playing
the numbers you get right only code I
think you can solve this just by adding
a switch in your developer environment
so imagine you'll want to you write
everything explicitly STD currents and
answer on and then you can imagine in
your environment just to press somewhere
and just it removes
our ad everything but the matter kid why
not I was I think there might be at
that's an IDE solution to what might be
a readable problem i can't do that are
in a printout i was thinking more maybe
perhaps waiting keywords or the
operating the operators yes waiting
waiting of operators might help this
because there are some operators which
are more expensive mentally even though
they are quicker to use using is
probably what I would highlight as being
aliasing aliasing pointers is bad
actually aliasing things in co can also
be bad as it can be make it harder to
follow if you're not careful with it
that was some thoughts I'm interests
have a look at this because it could be
quite interesting to evaluate cost of
adding new features to an existing code
bases where I'm interesting it so thank
you very interesting presentation q
sorry if I missed this i came in that
slide 8 we mentioned that you use these
metrics to evaluate evaluate your
students but what exactly do you do with
these metrics in regards to your
students over the years and in fact so
the common way to evaluate students is
to just verify that so card wells okay
but you do not verify the quality of the
code so maybe some this matrix of sock
am some kind of matrix is useful just to
verify the quality of this code maybe
also the cut you produce to your clients
are because you you don't want for
example too long statements too long
variable names to some maybe it's useful
to evaluate not only the result of your
code but also the way you write it it's
kind of quality I don't know
so did the students skip this feedback
after you've produced these man I did
not try yet in fact the code was
produced with my students know so I add
on during is internal ship and township
in my lab so it was in June July so i
will try this next year or in fact also
we we are moving from c++ to java in
mind okay but you can also apply this
matrix tools on languages so it's
obvious that if you want to solve a
Sudoku you will use prologue loss a
language like that because its domain
specific and in a few lines you can have
yawns well in c++ if you want to write
this all there it's a little bit more
complex</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>