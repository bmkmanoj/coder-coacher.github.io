<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Peter Sommerlad “Templator: Demo of a nice tool...&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Peter Sommerlad “Templator: Demo of a nice tool...&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Peter Sommerlad “Templator: Demo of a nice tool...&quot;</b></h2><h5 class="post__date">2015-10-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gek32PjjN6o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">who of you is writing templates
regularly okay who are you gets
templates right the first time always
sometimes often okay the thing with
templates is that the compiler creates
code for us in the background that we
cannot see we only see it when we get an
error message and these error messages
can be quite tedious to understand and
read and so we and especially in C++
some of the language rules are quite
complicated there's a lot of reasons for
them to be complicated and especially
surrounding templates and fact
especially function templates there are
some interesting rules that are correct
but not always as the programmer would
expect them to be and since the compiler
hides from us what it's actually doing
my idea was to have a ide support to
showing us what the compiler would do or
intends to do so it's easier to actually
be back template code not only when it
fails to compile but when it compiles
and doesn't do the right thing that we
expected just one thing who knows what
happens with this variable we what is
vector bool is that like a vector of
char or a vector Rindt there's a
language expert please
okay the premature optimization that
happened in the 90s was that vector bool
was implemented by using bits for
boolean values and not if you define a
variable that is a bool it usually get
gets the size of one element that is not
just a bit and vector bool try to
optimize a memory consumption by using
bits for boolean values that it has a
lot of implication that this nice
gentleman try to explain and I don't
want to go into details it's just vector
bool is a specialization of the suit
vector T template and if you use vectors
in generic code you always always have
to consider that there is this strange
thing vector bool that has a different
API than vector that has different side
of or it's a effects underneath you
still in most cases you get around fine
but you might have corner cases for a
vector bool just behaves differently
than a regular vector and you might get
surprised for example you can't get the
address or a pointer to the elements in
the vector that you can get with all
other vectors another problem is
overload resolution and that's the
problem especially in IDEs let's say we
recall we have two overloads of the
function inner 14 inch 14 doubles the
template function outer that takes any
kind of time value and calling inner and
a non templated overload of outer for
ins and if you call outer with an int
the compiler will select this overload
calling inner for ins if you call outer
with the double okay the int might be a
match if there wouldn't be a template
around this function would still be
called in the second case but we now
actually or maybe I should use now we're
actually calling the template function
which also calls inner and because T is
deduced as a double
calls in ER with a double value so it
calls the other inner the IDE we are
working of it with is based on eclipse
CDT and if you go for CDT it actually
once you're it you can follow the the
coal chain and the instantiation chain
but once you end up with in the template
context it will not know which overload
is actually selected and that's okay
because within the template you don't
know which overload is actually selected
because you don't know which template
parameter which template argument he
actually got so it can obscenity in its
plane forum will ask which which
overload I are you using that's one of
the deficiencies where you cannot easily
see what's actually happening so the
compiler will actually follow the chain
up to the overload of inner with the
double but the IDE cannot that's one of
the second of the things that overload
resolutions are I asked yesterday who
has been to a pop quiz on C++ yet none
all virgins in that so I borrowed this
that example from all models he's
running pop quizzes at conferences i
think in DC and AC see you in europe are
things that he has run that so we have
two two functions called why with the
reference overload and an r-value lvalue
reference overloading our value
reference overall and we have a main
function calling why with a variable and
the constant so which why would be
called in the first case the first case
because I is an lvalue it calls the L
value reference
and the second case with just a value so
that's an r-value the overload of Y with
the r-value references is called so we
get if we look at the output we would
get one and two but we can actually tell
you what happens when we call F G and H
with that who is able to know that ok
the experts doing everything but a
normal programmer has a very hard time
to understand that the problems with the
forwarding references with what happens
what X would actually be what happens if
we move it what happens if we move
forward it it's just tricky I couldn't
figure it out on my own correctly I
might come up with a solution that might
be guessed correctly but it's not
there's one change to the original pop
quiz and that's something hours develop
IDE provides you if you want to step up
to c letter c c++ 11 or 14 the let's say
the good way to initialize things is
using curly braces and I don't go into
don't want to go into details what to do
with the curly by kerli braces are the
right way to do things but if you don't
use curly braces yet we have a plugin
that suggests you to change your code
and it will do the change for you on
your behalf it's not completely
automatic so you don't get messy fast
with your code by a tool it's just it
tells you okay why don't you use a
initialization like it's supposed to be
and if you want to do it it will do it
for you questions
yeah we will see so we will see in the
demo I just have to I just reformatted
the code a little bit too and you will
see in a second why and I need my
glasses if you run that code this is the
output as you expected good and this is
actually the view that my students
implemented and if we select main here
in the editor and say synchronize we get
exactly what we have here and it shows
us names and these are clickable things
so if we click on why calling within an
lvalue we actually end up with the
correct overload that is called in that
situation if you do it for the y with an
a value we also get the r-value overload
that was the easy thing we could we all
could figure out that on our own but now
we call F and what you actually see here
it shows us the deduced template
argument compare that to the f here it
will only show us okay this is a
template function so here we actually
have the views already the correct
template argument and that's the nice
thing about function templates we get
this template argument deduction and I
just produce a little bit more space
just a mouse curves is a little bit too
we see now we get F as it is defined but
it tells us unfortunate the fond of I
couldn't figure out how to enlarge that
font we see that the t is actually in
and it lost the reference but we see the
correct one here and if we now click on
why it will actually give us Y as it is
called in this context so we not only
see the template definition we actually
see the incense EA shin with the t is
int rev now go for the next we see okay
in this case t is deduced as int and if
you call why it gives us us the L value
why is that well let's make it a little
bit more space in this case X is a
parameter to a function and if you use
that parameter within the function body
it's like a local variable so it's an
lvalue so we get the L value overload or
why so we had 12 11 now let's go for G
here we move so we give up x and since
we move we create an hour value so the
r-value reference overload of Y is
called and if we continue that with the
other g it's the same situation the RL
you overload
is called just make things a little bit
smaller so you don't lose track and now
we go for age and here we forward it to
the underlying type so we again get from
the L value reference we get perfect
forwarding we call the L value reference
version of it and over the last case
sorry my screen space is limited we get
did I click the last one no this is last
case where we get perfect forwarding of
the r value it is an hour value
reference so this means is actually we
can click through the template in
sensations and see what what's
underneath for those of you who have
been so yeah we to reset our temp later
view to what's now in here that's a
simple case where we have template type
argument deduction we can click through
you have seen that and see the different
overloads and here for example we have
print value with Nova load for boo like
vector rules so we if we call print with
a pool we get the other implementation
of print value here which is not that
obvious from the code if you just look
at the templates so let's see what else
i canna show if you go
come on where is my that's the example
of the verdict template function I
showed yesterday a print lined and if we
look how very big templates actually
look like in temp later we see that the
list of our deduced arguments is
actually shown so we can actually see
which version of print line is or how
print line is actually instantiate it so
we have a character array which is our
one string we have an int which is our
two and a double which is 3.0 and if we
go deeper into that we see that in the
first case our head is character ray of
four and there's a tail and if we go and
we see the tail is actually int and
double and we go a deeper we stick with
double in the end and if we go even
deeper we get to a case that is actually
never called the tail is empty but the
compiler will actually instantiate the
template with the call even though it's
never called we're so we have to provide
the base case for the recursion of the
very template implementation
now we have more examples no questions
everybody is baffled by thing let's see
here we have a class template that uses
vector sorry and we have a
specialization for doubles and we have a
factory function creating that stack
from an initializer list to be using the
element type of our template so we could
have written our auto here but let's see
what actually happens make stack
interested use because we call it with
an initializer list of ins and it will
create actually a stack of ins and we
can even dig down into vector and now it
takes a little bit of time because
vector is is a bit bigger template and
we now can even drill down and look for
interesting things within vector how it
is in sin she ate it with these template
arguments the end and the allocator I
just want to go back and see what
happens if we have a stick with pools if
we then go into the vector it will show
us ok we have a vector where the
allocator is a bool and we see it's a
specialization because it has pool here
without coming from a template parameter
and to see that vector bool is actually
different we can search for a thing
called i believe it's flip come on leave
my focus and that is something that the
regular vector sorry it's a navigation
problem
has no idea that it exists I hope so
come on non-existing questions yes it's
actually implemented based on the ast of
the underlying platform CDT with
extensions that we created to actually
provide the template in sensations
that's also why it's not perfect yet
part of it is already part of eclipse
CDT so it actually can show you some of
the argument detection and the
instantiation but only one level so the
question is how is it implemented sorry
fer fer not saying that and so it's
underneath the platform has some
implementation infrastructure for
templating sensations but not the
nesting that's what my students
implemented to get the nesting down the
point is it's not perfect yet it's not a
compiler yet so we are working on
getting sveen I see plus 14 support
where we can do very interesting things
that's also one of the reason I showed
it in a vm on my mega halves GCC 522 and
this the center library of GCC 522 uses
computed no accepts depending on the
template parameter and that's a call on
a case that's not handled yet by the
parser the future the soon immediate
future for the the plan is for the next
release of savella that happens within a
couple of weeks it will be part of it
and the further futures actually
complete the implementation of the in
sensation engine so we have seen i
support and we actually have a debugger
for template metaprogramming but
I cannot promise when you get that maybe
next year around this time but I'm not
sure it's just a hard task I don't think
so because it heavily depends or so the
question is is it available in other
IDEs i'm not sure if there's a JetBrains
person in here you can ask them if they
will steal our idea and implement that
they are clay when my students release
the video they were claiming that they
are plant have plans to do something
similar but i think they also have a
long way to go to implement a very good
C++ puzzle it's just hard but you still
have to but it gives you out rest text
I've seen but it's not you don't get the
visualization and the interaction the
point is you get all the insane see
asian information from the clang tooling
and you don't get the nice visualization
where you can actually click through so
it's it's like if you put it an arrow in
the Internet's a template a compiler you
get the same information from from any
compiler as a template in satiation
sequence but it's not not the same first
think Lange is not we don't want to
couple us to clank because especially
when we started out clang balls and
available on windows so that's why it's
not playing and also i want to have the
children pastor and the AST very very
good so that all our refactorings which
go far beyond what you can do with clang
ast s actually work with it so there's
that's motivation to get it get a better
idea so it makes develop better and now
we have a competition so we have even
more things the only problem is we have
to do it all with student work or money
that I get from other projects to do to
invest in that so it's not we don't have
the financial resources of a company
like JetBrains any more questions I
think we are soon to stop yeah go ahead
yeah you can do that with any function
where it could what you cannot do it you
cannot do it with the template function
because then you don't you so the
question was kinda can I do another
function i just used main as for
convenience you can do it wherever you
have an insane see asian context of a
template you cannot do it from a
template function because then you don't
know which arguments are actually there
so that's that's the only limitation
it's not so if you directly go into
vector t then you cannot use it
reasonably because you don't know which
value of t you get another question
sorry so the question is how do you
manage pre-processing the good thing is
we implemented all the hand or a lot of
the handling of pre-processing and the
AST so we actually use the unprepared
but we know what the preprocessor would
output and that's a problem we have
already with our refactorings for
example if you extract a function you
want to keep the original macros and not
the expanded version in the exact
function and that's a problem we solved
what's not perfect it is if you have if
deaths or conditional compilation
someone is playing with the lights a
conditional compilation then we only see
one brand
of it because you get combinatorial
explosion of all the branches that you
get if you have too many so get rid of
if there's as far as you can and then
then it's your good and i think i have
to finish because there's another talk
supposed to have known i stay here until
thursday noon if you have more questions
take the sill develop token with you and
otherwise feel free to contact me with
further questions if you want to try
today I can even point you too well I
shouldn't say that but I can point you
to a nap dates I to install it in
develop of today but you might get some
problems that unexpected so a final
question or otherwise I think thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>