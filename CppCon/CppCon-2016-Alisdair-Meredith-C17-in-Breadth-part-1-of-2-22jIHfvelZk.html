<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Alisdair Meredith “C++17 in Breadth (part 1 of 2)&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Alisdair Meredith “C++17 in Breadth (part 1 of 2)&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Alisdair Meredith “C++17 in Breadth (part 1 of 2)&quot;</b></h2><h5 class="post__date">2016-09-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/22jIHfvelZk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so we're just gone two o'clock I've
got the what to try to cover in the next
two hours so I'm going to get going any
wait stragglers there's plenty of room
for people to come in and sit down
anyway so just to make you what everyone
thinks are in the right session the
session is c++ 17 the next c++ standard
in breadth and not depth so the idea by
the end of this session is you will know
absolutely everything that has gone in
or change with c++ 17 and maybe not a
whole lot about any of it but you've got
a good idea about what you want to go
and see during the rest of the week if
anyone's talking about any of these
topics and hopefully you have a fair
idea of what to do with these things but
certainly not an in-depth on any
particular topic those of you who don't
know me my name is Alistair Meredith I
currently work for Bloomberg as one of
their senior developers on their own
internal standard library and we publish
that now through the open source bde
project during the evolution of c++ 14
hours a library working group share so I
know a little bit about what went into
all that we're about to see so I'm going
to have a quick slide Christopher who's
aware of how the C++ standards process
but works in practice so just a
professional hands quickly to background
the one slides worth no more why do we
have a C++ standard in the first place
this predates me going back to about
1990 there was a wide variety of
dialects of C++ emerging is everyone
like following up on be Ana's work and
adding their own different extensions so
it would be really good to have a
talking shop where people could come
together and produce a consistent
dialect in version of that language but
that hits anti cartel we're disliking in
the States that lots of companies
colluding actually you're a seen as a
bad thing as if you convene under an ISO
standards process it's an open process
everyone can come and participate so
that was the way to go ahead and we
actually set about creating a C++
standard that eventually fooled the
committee that they actually had to
publish something that's it has been
quite quite a good thing for us if you
want to follow what the standards group
are working on if you google WD 21
that's
name of our standards group under the
ISO process or the last part of our name
it's quite a long acronym and the other
place we can go and follow standards
work now is the ISO CPP org website
which is intended to be a new community
knew it was new a while back hopefully
everyone here will know about it because
this is one of the outreaches as a
consequence of creating this website in
this organization this is intended to be
the online home and community for C++ at
large
so quick history of the C++ standards
1998 we had the first standard and that
will took roughly seven years and
twenty-one meetings then we have the
2003 standard which was 5 years later
your spot we significantly slowed down
the amount of work we were doing at that
period and that might have set some
false expectations about how the
standards process is supposed to work
this was because we had a false
understanding of how the standards
process is supposed to work we thought
that once you publish a standard you
weren't allowed to touch it for 5 years
so we did five years of defect reports
fixing things and then found out that no
after five years you have to say we're
retaining a standard or do or it retires
and we should have been doing new work
all that time so 2003 is roughly also
when I joined the process and for the
next eight years we started working on
C++ oh seven eight nine set it's escaped
in 2011 roughly as you can see similar
amount of time that went into the
original standard and I hope you will
agree that it was a big step forward in
what you could do with C++ the idioms
you could use and have a language would
interact with the broader software
community
falling 2 to 2011 standards we wanted to
start what clearly on the next standard
and we did not want to have another big
bang release taking another 10 years so
the idea was we're going to have a new
standard round about 2017 and started
work on that and round about 2014 we
already had a lot of bug reports and
defects we wanted to fix so rather than
say going through the standards process
you can't add
new features in something like a bug fix
technical core agenda which was a 2003
standard so just to avoid asking that
questions we said 2014 will continue
standard it will simplify our paperwork
and that last meeting everyone dropped
in any new feature that happened to be
ready so 2014 was actually a better
iteration than we were expecting
2017 another three years later similar
amount of time should be where we be
landing hopefully substantially more
features so if you're looking at the
evolution from 2011 to 2014 to set your
expectation for how much of an increment
we have now hopefully you're going to be
pleasantly surprised so where are we in
the C++ seventeen process final slide on
process sorry either but it's wanted
together at the last minute we're
currently in C++ 17 ballot review that
means that the start of at the end of
June started July we sent out what we
would hope to be the C++ 17 candidate
document for the new standard that's
going to ice off a ballot we have
roughly up until sometime in the middle
of October to send ballot comments back
to ISO to address any issues and defects
we think we spot in that standard but no
new features should be added at this
point we expect with our experience of
previous standards that will be have
another two standards meetings that will
process and deal with those defect
reports which means roughly the end of
first week of March is our second
meeting we should be sending that back
to ISO hopefully as our final approved
standard they will bow at that for a few
months say in the middle of summer if
that all goes going according to plan we
should have a new standard published
sometime by the end of the year so
that's where we are in the process it
does mean everything I'm about to show
you is subject to change
we've got this ballot resolution but
he's substantially factory correct while
we've been working on sleepers for 17
just a quick slug we've been working on
a whole bunch of other things the ones
in green we worked on well enough and
early enough that we've actually landed
those in the new standard those will be
part of C++ 17 the yellow TS is our
additional project we've worked on
we've published them as
very mental material and hopefully those
will all be parts of C++ 20 and the ones
in white are our ongoing projects that
we're still working on publishing so
even though we're publishing C++ 17
there's still a lot of existing ongoing
work happening in parallel the committee
is very busy these days again just
trying to set expectations as to the
growth of the standard I just page
counts not necessarily a good guide but
it gives you again an indication that if
you look around about 2011 we had a big
dump of new things coming into the
standard a new hundred pages in the
court and the huge growth in the library
so C++ 11 people like to talk about the
changes in the language but you can see
in terms of the standard it was a huge
addition to the library and it's a
similar kind of thing happening again in
2017 you can see we're adding a number
of pages to the core languages we clean
up and have lots of features smaller
features the libraries taken another
reasonable size change but also it's not
on the same scale as C++ 11 and if
you're wondering well there's a small
page count reduction in the 2014 cool
language we didn't take things out we
just use a slightly smaller font in the
standard so those 2017 pages are far
more valuable and again just showing
again the evolution of the standard
roundabout to the first standard it was
a fairly even balance between core and
library in terms of volume of what went
into the standard but it's been a real
desire to expand within the library and
just provide the core language features
that will allow us to write richer
libraries so you can see that for 2017
this will be the first standard where
the library is actually more than twice
the size of the core language so what
we've done with C++ 1717 at the glance
it builds on C++ 14 which we published
two years ago as I say it's a
significant library update you saw from
the previous page can we're adding
almost 200 pages to the library and most
of that's coming through libraries that
we've already trialed in existing
technical specifications so they're
coming already in good shape well tested
on the language side it's a modest
change but in total you can see
roughly we've got we've accepted close
to 120 proposals so I've got a lot to
talk about in 120 minutes some of those
proposals are reasonably large in scope
some of them are very small just maybe
changing a word or two but it all adds
up to the feature set we're going to
look at as I said most people landing a
lot of the existing technical
specification work an ongoing thing that
happens every release of the standards
we get a lot of Queen of clean up of the
existing wording and presentation so the
standards a lot more precise about
issues coming in people start playing
with corner cases we find where the big
things are standards of specification
not a library or compiler specifically
so fixing the specification is a
slightly more interesting in their
attorney involved process but we concede
to clean up and give a much better
contract between the customer and the
developer and on the language side as I
said I don't think I'm seeing any
significant new idioms if you look back
at C++ 11 the big things where we had
move semantics we had a well-defined
memory model we have lambdas coming in
there's quite a series of things that
would fundamentally change the way you
might program in C++ 17 we have a lot of
things that make a lot of those idioms
that we've been introducing over the
years much easier to use but don't go
looking for the big new idiom that more
like we C++ 20 for those of you who have
been following the process I'm wondering
where are these things these some of the
big-ticket items people were hoping to
land concepts we've got it at at
publishes at es but it was just a little
too late in terms of getting experience
to be landing it directly into C++ 17 if
this doesn't land in C++ 20 there's a
lot of people going to be very
disappointed if you don't know what
concepts are come back in three years
you'll be hearing an awful lot about
them if you haven't heard already
Cortines was another one that came in a
very well defined shape because
Microsoft had been shipping their
implementation of this language feature
and they've given us a specification
that looked pretty much good enough to
accept the main reason it didn't land is
there's another idea of co-routines
happening out the networking development
side so we've got competing ideas in the
space so Microsoft you know happily
gaber's this this work and said okay
well public is a technical specification
so we can carry on honing the standards
process and this will be again ready to
land very quickly in C++ 20 depending
upon how the competing proposal goes so
active work on co-routines but nothing
landing in 17 so with that let's get
talking about what actually is going in
17 quick color code for trying to decode
my sliders like go through fairly
quickly something in green is something
that why didn't C++ 14 or earlier quick
show of hands who followed what happened
we see is aware of the differences
between super plus 14 and C++ 11 just
got a sense of the audience okay I've
got two well informed audience that's
good most of the green stuff is I was
adding the super plus 14 as them as a
gradual migration but you're already
ahead of me on that anything in yellow
is part of the C++ 17 candidate CD
things in this funny purpley color they
were supposed to have landed in the CD
but due to a couple of last-minute
editorial problems didn't actually land
in so we still expect those to be part
of the public standard but if you look
at the one we sent out for ballot you'll
not see those yet and then I'm using
this funny orange color to say here's
something that was deprecated
discouraged removed so can this is the
bad thing color so first things we did
starting with the simplest and working
our way up the scale towards some the
more interesting features are binding to
other standards the C++ standard has to
refer to other standards for some parts
of its specification so we have the C Y
C standard specifically the C standard
library that we have not updated for a
while so I think C++ 11 finally bound to
the c99 standard just as C was
publishing the C 11 standard so having a
good update to our library to get back
in sync again with the C standard
library we're adding a new binding to
the ISO 80,000 specification which this
used to be ISO 31 which is about the
oldest standard we could find to bind
against this
certify some mathematical special
functions so anyone who was following
the tr1 process back in the day
that's your heads up for what might be
coming in though I'd be this afternoon
we also have a binding to POSIX and to
the Unicode standard and to the ECMO
script standard because that's where we
specify our regular expressions
libraries and those are in orange
because I noticed by me now we're
following our ballot comments all of
those are currently binding to older at
a date standards so hopefully those will
all be updated in the next two months
next term to meetings so we're rebasing
on the c11 library what does that mean
well we're going to update the reference
of which why we were bringing in by
specification and part of the
presentation as I said we've improved
the quality of the specification itself
one of the awkward things with the C
standard library functions and
structures was we just said look at that
other document we didn't show you what
the headers looked like so it's kind of
tricky piecing together what was what
what the C parts are the CEO C++
standard library look like so we've
actually expanded all those headers in
line to say this is how you apply the
mapping but what the C standard library
headers looked like in C++ we actually
make it easy to find in the index as
well as been a fair bit of work on the
index if you are a standards geek you
actually like to read the standard
itself and that's really fixing up all
the cross references so you don't have
out-of-date reference this pointing to
the wrong words in the other document
one of the questions we had when looking
at the c standard library is in c 11
they introduced the notion of optional
components of a standard which c++
doesn't really have and one of the
larger optional components is an XK
which is the safe or the checked
standard library api which was some work
that said all those places where you
provide a pointer and then there's no
real way to check whether or not the
library was given the right range or not
so you can have buffer overflows running
off the end too easily there's now an
underscore s parallel but a surrogate
version of that library that will give
you the ability to check the YB the
ability to check the parameters as they
come in
and that's an optional part of the C
standard library
we're not importing that into the sea
stood version that same lab eNOS in the
standard namespace it's there for
implementation defined so if your vendor
ships that in the global namespace as
part of C they can do so but they just
tell you whether or not they've done
that with deprecating some C++ 14
headers so those that map to the funny C
language features of how they deal with
complex numbers some of their generic
math functions or macros these don't
really do anything useful in C++ so
effectively vacuous headers so we're
just deprecating them they can't just
follow the pattern of why we introduced
them and likewise when it came to
dealing with the memory model stuff the
way C hasn't supercilious of slightly
diverged C is doing this directly in
terms of some key words we didn't import
those headers when we imported the rest
of C 11 so that it's probably some
fairly useful information to be aware of
moving on vocabulary is an important
thing when you're talking about
standards and things coming out of the
standard and we're getting a wide some
computing out of some of these terms and
lots of competing terms for the same
thing that people would talk about the
same thing not realizing they were
talking about the same thing so we've
got a few new standard terms in the
standards itself the first one is
forwarding references years we had this
wonderful chap called Scott Myers trying
to make sense of the r-value reference
in text in C++ 11 finally did kill you
of the rules that he decided meant
universal references and then we have
the rules for almost universal
references and why universal references
aren't quite universal and the main
issue comes down to when you're in a
template deduction context if I've got
the double ampersand I'm going to do
with the duckling as to what that type T
is and it's typically alternative use to
an L value or an R value reference as
opposed to distinct we type T / 3 B did
you see see I have an hour value
reference but if I've got if I'm dead
using off an L value it wouldn't use T
is an L value reference so rather than
getting confused with the talk of our
values and L values in this syntax
doing something following those rules
but with a different effect when you
step back and think about how you're
using it we're now consistently calling
those forwarding references and suggest
that's the vocabulary that the community
should use now as well so that's what
the how the standards going to refer to
this idiom in the future
another thing that was running around
with far too many different names with
now we can initialize data members in
directly in a class and therefore if you
don't initialize it in the constructor
that's of that's the initialization it's
going to perform and there are a variety
of names for this running around
including the the one for NS DMI acronym
which I think there's non static data
member initialization so the name we've
chosen for this just to simplify how
everyone talking about the same thing in
the same way our default member
initializes and family these funny
things that show up in templates that
aren't quite templates but follow a lot
of the rules of templates but dependent
values and types and so forth we've got
a template a member of a class template
a template member of a non class non
template class and these things that
kind of look like template should follow
the template rules we just call them all
templated entities rather than spit out
this big long list of special case rules
all over the place so hopefully that
will allow us to talk more precisely and
more simply about some corners of the
use of templates in the future on the
library side we're introducing the term
of contiguous iterators which are almost
a new iterator category that a
refinement of the idea of a random
access iterator that goes one step
further and says if I take the address
of the element I'm referring to and take
the address of something that's further
on down the same sequence I can do
simple pointer arithmetic and it's going
to work because you could easily have
some kind of clever iterator that's
doing some bookkeeping between each
element so although I can do all the
random access behavior I still can't do
the pointer arithmetic and we want to
guarantee in certain circumstances
classically array basic string and
vector that those iterators really do
have the contiguity
guarantee so it's not quite a new
iterator category because it doesn't
have a
Tagg yet and we're still looking at that
in the evolution group to say is this
distinct enough it should have an extra
tag you can dispatch in your algorithms
but for now having the term contiguous
iterator helps you talk about this idea
much more cleanly and we use it to
define contiguous containers to clean up
the guarantee that these three
containers really do have a contiguous
range of elements regardless of the
allocator that you're using another fun
piece of vocabulary my way was we have
these universal generators for sequences
of bits in the standard that the
mathematical community that gave them to
us we will call them Universal random
number generators no saying no no what
really matters is that from bits a bit
to bit you get a random sequence of bits
the fact they happen to group up in
packages of bits that are going to be
used as a number it's misleading if you
call them that because you're talking
about the groupings being random rather
than the sequence of bits so hopefully
using the right name here will lead to
less confusion as people start trying to
talk about these universal random bit
generators because random sequences are
confusing enough for me to begin with on
the memory model side this is what a lot
of concurrency guarantees there was a
concern that when I'm trying to describe
the behavior of an algorithm or some
other parts of the standard although we
can have the idea of a lock-free
algorithm we want to guarantee you the
algorithm continues to make progress and
it doesn't you know live lock or
deadlock and having the ability to talk
about this the concurrency working group
study sitting down to nail down their
vocabulary that I'm not the ideal person
to talk to about this but as I said I'm
going to do everything that happened in
the standard we don't have terms that
can better describe how you would
document a parallel algorithm to give
the guarantees as it continues to make
forward progress to eventually complete
the operation so we now have a we define
the term of an execution step that can
make progress a thread may provide the
kink so or you can see the words on the
screen I'm going to run pass because
this is not my area of expertise but the
interesting thing to note is that atomic
operations are not guaranteed to be
lock-free
and therefore if you've got an on lock
free implementation of the atomic
trapped in the standard library be aware
that your algorithms even using the lock
free types sort of the atomic types can
still block hopefully all the
implementations I'm aware of provide the
lock free guarantee on their atomic but
if your plot if your hardware doesn't
provide the necessary primitives you
might have to implement those using a
mutex and therefore the ability to book
a chance at that hardware might block is
still there moving on what time to
describe is garbage collecting the
standard deprecating and deleting things
first of all we remove these things in
c++ 11 so if you're using any of these
things in your code today well as soon
as you upgrade your compiler to
something that's more modern and
conforming it got be aware that you
might hit problems hopefully none of
these things room widespread use at the
time we removed them so auto in the
non-deduction context just to say this
is a local variable was removed exported
templates because there were very very
few shipping implementations and those
that shipped didn't get widespread use
and the use we had didn't show it to be
use useful of features we had hoped for
access declarations I can't even
remember what they were but there were a
syntax that you could use to I think
mark things public and private in a
slightly different way than we did back
in 98 so that was a pre 98 syntax that
hopefully nobody remembered and we
quietly removed well one of the ones
that did catch people out was you could
have a non-constant binding to a string
literal which was really kind of
dangerous so we that was deprecated in
98 we finally dropped that in 11 and
when we add you the new braceland
civilization narrowing conversions were
banned and therefore some of these
arranged realizations might have caught
people at those caught by the picking
our test drives but we're really trying
to test the merit of bound stuff
we've been going to C++ 14 we removed
one function so not a whole lot of
cleanup happened in C++ 14 and this
wasn't even deprecated in C++ C 11 but
by the time we got round to it C had not
only deprecated they removed it so we
went the whole hog and said this
this function was just too dangerous it
went straight away so I'm moving on to
C++ 17 we finally get to remove
trigraphs which yes you can applaud I'm
so happy to see that go the register
keyword or at least the meaning of the
register keyword was deprecated in C++
11 because compilers are doing their own
judgment about how to do register
allocation so even if you gave the hint
with the keyword the compilers were
largely ignoring it and this is really
nice keyword to have in our back pocket
to use felt future language extensions
so we're deprecating are we removing the
existing use of the register keyword as
I said that was deprecated in 11 anyway
but we're keeping the keyword that's
still reserved for the language to use
at some point in the future
and likewise back in 98 operator plus
plus on bull types was deprecated and
it's 2sat round there we've got some
compilers are finally giving deprecation
warnings having setting deprecated
status since 98 it was finally time to
remove that as well because if we don't
clean things out the standards just
going to accumulate corner cases of
interactions indefinitely
you'll notice that Bulls never had
operator - - unless you were using C
where it does something even more
interesting so additional things that
we've cleaned up and tidied that might
break you in the similar manner to a
removal one of the ones that caught
people out by surprise was if I'm using
the new bracelet realization it works
very well in a lot of places but when I
try to use it to make a copy so Auto XY
make me a copy of why actually the views
to the initialize of list and surprised
a lot of people it was very confusing so
we're fixing the rules those rules are
saying no that's what you expect that
gives you a copy but that does mean if
you were genuinely trying to use the
auto initialization - hey I want to
initialize the list event that code will
now be all formed and in the really
unlucky case where you were trying to
deduce an initializer with of a single
argument yeah where some we're changing
the type on you hopefully your code will
catch that comparing somewhere else but
this is a distinct change that be aware
of we
think this is mostly going to be fixing
rather than breaking code another part
that I'm not sure with this was as much
that ease the specification but still
can give a clearer model of how the
language worked with accepting
specifications on functions exception
specifications are now part of the
function type as opposed to some
peculiar annotation that sat outside the
type system but lived in the grammar and
they interact the you know they decay
appropriately the way you would hope so
that you can call the one the which way
around as it go I always get this wrong
when I try and talk about it quickly on
the stage you can call a function that
has a wide throwing it says it can throw
you can pass a function I've got a
function pointer for a function that
says it can throw anything naturally I
can pass a function pointer today that's
got a no except on it whereas I can't go
the other way around and pass a function
that can throw through a function
pointer that says it can't that's caught
it as a syntax error now so that's
helping find errors in your code but the
compatibility goes the right way so
mostly nothing could break we've got
this wonderful little example that's
actually in it in the compatibility
annex of the standard that says if I'm
doing a deduction so I've got a temple
it's going to try to use T to be the
same thing in this case where I've got
the functions have slightly different
accepted specifications it would work in
14 and will fail to compile in 17 so
accepted specifications are in the type
system the old deprecated dynamic
exception specifications do not enter
the type system but we didn't manage
quite yet to take them out the standard
ISO I hand going up at the front here ok
so the question is do you have to does
the signature include the whole
expression of the no accept but no
there's no accept expression has to
evaluate a compile time to true or false
and it's simply the true false nature is
what enters the type system additional
and breakage inheriting constructors
were feature we introduced in C++ 11 and
they continue to turn during a small
variety of corner cases and bug reports
one of the classic ones was we couldn't
actually have a inheriting constructor
for a constructively user C style
ellipses that just didn't work in the
grammar nicely so with changing the
rules to say this should work widely the
way it worked before but it will clean
up some some cons just work better for
you you use the same syntax as you say
using a colon colon a here but now what
happens is if I call a constructor
that's not found in the derived class it
now says well I've got also got
constructors in the base class so I
could just directly call that base class
constructor and then any members in the
further derived class just get whatever
rules that have had if I called say a
default constructor and haven't provided
members so things want default
initialize value initialize use the
default member initializer however they
should initialize which is essentially
with the same behavior you had before
written in subtly different terms it
means we're not declaring you
constructor functions so that
initialization has to happen somewhere
other than in calling the constructor so
it's a slightly different arrangement of
the code but it should be a cleaner
model that will be easier to understand
and it's generally what people wanted
when they spoke about inheriting
constructors also on the move removal
side moving over to the library now Auto
pointer has finally gone deprecated in
C++ 11 now we have unique pointer we
don't need it by first binding second
member and unary function all these the
old adaptable function API that relies
on having special type deaths in your
classes we've generally got better ways
of doing these things now with lambda
expressions and bind so this limited
functionality was deprecated in C++ 11
if you're using those functions and
types they are gone from C++ 17 random
shuffle was a shuffling function that
basically used the rand function from
the c standard library that was not
particularly well specified to be a good
random number generator so that was
deprecated in c++ 14
and we're removing it from 17 also on
the whole garbage collection and
cleanups I'd back in C++ 98 when we
standardized i/o streams we put in the
deprecated annex oh and here's some
other names people have used in some of
their implementations to describe the
same things but use the ones we've put
in the standard instead so we're finally
just cleaning up these type def so that
nobody I I've spoken to knows about
these things apart from people who read
the obscure deprecated annex of the
standard and also going is the support
for type erased allocator in standard
function and call this one out because
it wasn't even deprecated in 14 that we
had many reports that this was a very
hard if not impossible function to
implement the this use of allocators we
don't have any shipping implementation
that has successfully figured out how to
implement it so removing it isn't going
to break any code because anyone relying
on it was relying on the broken
implementation anyway this just could
not work as written so by removing the
support now we're hoping that we'll make
it easy to provide a correct
implementation the need for this kind of
support for allocators in function and
similar types at some point in the
future further clean-up in the library
we're tightening down our specification
for the kind of things you can add pass
the predicate in the standard library
the general rule was you could pass any
functor which meant you didn't have to
console if I the function call operator
even though everyone knew that was best
practice the standard library in theory
we should have gone out of its way to
support this turns out not quite all
standard libraries were doing that we
think the reason this was never there in
the first place was back in 98 when this
idiom was first defined people were
still not as familiar with the idea of
overloading a function call operator
never mind Const qualifying it this
would just looked a bit strange whereas
now it's a very familiar idiom so we're
not requiring libraries to do strange
things and jump through lots of Hoops to
support unusual code and my favorite new
clause in the standard library zombie
names
the idea here is but I've just told you
about all those names that we've taken
out of the library
zombie names is a cause it says all
those names remain reserved by this to
the standard library for previous
standardization so standard library
vendors can still provide those things
as extensions if they want those names
are reserved to the standard library
you're not allowed to define macros with
these names now we've taken these things
out so this is our standard clause that
says yeah we have those names once
they're still ours and yes we can still
ship these things and support customers
who don't want to break straight away so
features deprecated by C++ 14 the
previous and the random shuffle that not
only deprecated it we removed it in 17
so that's going on on the language side
of deprecations in 17 static cons data
member definitions are being deprecated
because we've now added the notion of
inline variables so in a non variable
follows the similar kind of rules as an
inline function so typically if a
typical use case is a standard sorry the
static member a data member of a class
where if we don't it has to be defined
and it has to be defined at the moment
in exactly one translation unit that is
messy when you're dealing with templates
and we've already gone through these set
of rules about how inline functions can
appear in multiple translation units
multiple headers you can see the thing
many times as long as they all have an
identical definition and the preceding
inline keyword so without doing the same
thing with inline variables that just
solves this whole corner of strangeness
when people are trying to get their
static data members initialized
correctly and therefore we deprecated
the old way that for the Const data
members where they could be defined in
the class still legal but deprecated
because we've hopefully got a superior
alternative to move to on the library
side now that we removed all that old
adaptable function API we've bound first
bind second and so forth because that we
deprecated the type def that we had
there purely to support that the main
reason that these things weren't
deprecated before
have not one not two unary and by
knowing the gate functions that we
didn't have an alternative to so that
was the tail wagging the dog saying
these keep all those type deaf surround
forevermore so we've introduced a new
library function called not fun but
similar to mmm fun in naming idiom but
it solves it generalizes the problem of
the negate errs and letters remove these
things so they're deprecated for 17 we
expect to remove them as soon as C++ 20
opens uncaught exception is a
particularly poorly specified library
function that was trying to let you
detect if you're in the middle of stack
unwinding given exceptions already in
flight we're replacing with a better
function called uncaught exceptions
plural that will give you a count of how
many exceptions are in flight and if you
thought that answer couldn't be more
than one I've got news for you and I'm
not going to tell you how because it's
so much nice and not to have to deal
with that but yes you can do strange
things it can have multiple exceptions
in flight multiple versions of the same
except in in-flight uncaught exceptions
will give you an accurate version of
that count we also have the is literal
type trait that was not very useful
because knowing that a type is literal
doesn't give you any useful information
a literal type is a type that it's got a
few rules about trivial constructors and
has at least one context per constructor
but is literal doesn't tell you which
constructor that is so yes I know that
mytab can perform Const expert
initialization but unless I know which
constructor it is that's not useful
information so it's debatable whether
the whole term of a literal type is
useful as currently formulated and
certainly the type trait wasn't serving
much of a useful purpose so that's now
moving to annex D with the other
deprecated components what also
duplicating standard iterator this was
the template class that just has a bunch
of type def that with the theory make it
easier for you to define your own
iterator types all it provides with five
type depths that now rather than being
named you need to know the order you put
them into the template instantiation to
know what they map to so if anything it
felt like a step backwards but the whole
idea of using base classes to forward
deft doesn't seem to work as well in C++
11 we've just got cleaning idioms for
solving a lot of these problems so a
deprecating standard iterator the
library traps that were defined in terms
of that already were cleaned up their
specification in C++ 14 and the
recommendation is just put the top gets
into your type directly raw storage
iterator with an iterator for iterating
over raw memory so the I do is I could
initialize oh you know through this
storage iterator construct my elements
into raw memory as I'm going along the
iterator was didn't work very well once
we've got a much better defined
allocator model there's a whole bunch of
problems with it we're deprecating and
we have to talk faster cuz i'm running
out of time and I'm not going to get to
the library at this rate get temporary
buffer and returns empty buffer those
were a optimization point that we put
into the standard library to say
sometimes if I can spot that I can do in
the efficient allocation off the top of
the stack with information known to the
implementation I can maybe do a really
efficient allocation without even having
to lock memory and go out to the heap
and so forth and if I can't a can fail
and you can go up and do a slightly more
expensive thing but your library candy
you take this and say if I can get some
keep memory sometimes I can do something
better
these api's didn't get those optimizer
implementations we didn't have the RAI
wrappers that you would need to use them
safely idiomatically so rather than
clean them up try and fix them and make
them an optimization opportunity they've
not been optimized in 25 years so the
just sitting here will just deprecated
them and if we really need an
optimization there will have a cleaner
better version at some point in the
future and finally when we had allocated
rates as the way you perform allocations
in all your containers and data
structures as a whole bunch of things in
standard allocate that would be deduced
according to the formula of allocated
trades and indeed you should always
access alligator's now through the
allocated tracks interface so having the
useful parts of standard allocator
actually part of the allocator that just
do the default thing left the temptation
to go and call them directly now clearly
if you've got c++ l-3 code that's
exactly what you're doing it was the
only way to do that
so we can't remove these features yet
but we can deprecated them and say yeah
the intention is we really want to send
the message allocator trait so the way
to access your allocators we also got a
new term going deprecating white when
you start doing atomic operations we've
got this memory order consumed but I'm
not sure if it's not clearly specified
it's not clearly doing what people want
it to do today but there's a real intent
that we should be able to fix this and
make it work so we're deprecation
writing it or putting a note in the
standard rather than officially
deprecating it's saying please don't use
this yet but we will make it more usable
in the future
so heads up be very cautious using
memory order consume until we fix it
hopefully in C++ 20 so new features we
introduced a bunch of stuff to do with
literals in C++ 11 I have a good
audience so I'm not going to dwell on
that slide in C++ 14 we introduced digit
separators binary literals and though I
provided the user-defined literals that
would therefore actually use the feature
so for C++ 17 in the world of literals
we added utf-8 character literals I'll
admit I'm not sold on the utility of
this feature but it really cleans up how
we specify things in the standard as far
as I can tell a utf-8 literal must be
ASCII because anything that's above 127
doesn't fit within a single char and we
can't have multi character utf-8
literals whereas we could with a regular
key R type that promotes it in because
it's actually an error in the language
well diagnose it as an error so as far
as I can tell the only thing you can
store in the utf-8 character literal is
an ASCII character but it really cleans
up the specification for how you have
prefixes and so forth with characters
and strings and it's just nice to have
the syntax mirror each other so Roland
in your weird exception it's just not a
very useful feature we also have from c
99 hexadecimal floating literals for
folks who it's a bit of a not obscure
corner but i write test drivers that
deal with floating-point numbers an
awful lot and being able to really
specify that bit pattern rather than
rely that the parser is going to move
the decimal text in my
code transfer it to the binary of the
hex values I'm expecting having a way to
prespecified that precisely is really
handy the thing to note we have an OE X
in front of the floating-point number
let me have the mantissa and then when
you get to the exponent it's followed by
a P not an E and that number is decimal
not hex thank you see but that's the
that's the form of a hexadecimal
floating point and as far as I'm aware
most compilers are already shipping this
because they got this from their C
implementation after butte c++ 14 added
the deprecated attribute c++ 17
therefore as full true which we got from
the clang folks as a way of saying
here's a case statement okay that we
really do want to deliberately fall
through to the next one please don't
give me a warning about it and it's
certainly a very good clear
documentation to the readers of the code
that you didn't accidentally miss the
break and they don't go and fix your
code by adding it
no discard is to say this function is
going to return your result and you
really should not just drop it on the
floor and ignore it so it's an
opportunity for the compiler to give you
a warning when you don't actually
consume the result of calling that
function good example that we've not
done in the library but we may who knows
if we'll have ballot comment suggesting
this the empty function of any container
somebody who's coming from another
language we'll look at this this thinks
this sounds like a command empty the
container I'll just call empty we move
on no empty tells you whether or not
it's empty so why would I there's no
need to call it unless I'm going to
examine that result so that's a good way
to catch errors in code so hopefully
that will become a common idiom within
standard containers that people will
whether the set of mandates or not put
no discard on the empty function and I'm
sure you'll find lots of examples of
your own may be unused is the attribute
we're going to use for something that
potentially is not going to be used in
the following code compilers love to
give you warnings about this especially
on function parameters the usual idiom
is that you cast that to void so unused
was a popular name for this attribute
because it's shorter but we like nice
long names in the standard especially
when you've got conditional compilation
that means if this thing goes through an
assert it
might or might not be used if you said
unused you would therefore expect the
compiler to diagnose if it actually gets
used because that would be separate so
maybe on used was a simple general
all-purpose attribute that describes all
these situations with the least
confusion and most characters also I'm
moving on to attributes we can now put
attributes on namespaces because that's
one of the few things that we couldn't
actually annotate so yeh after use on
namespaces I'm showing an example of a
dick namespace lots of people would love
to deprecate but we haven't deprecated
yet sorry another place we can now put
attributes that we couldn't before was
in enumerators with enumeration so if
I've got a series of values maybe I've
got an old enumeration that represents
flags I don't want to support anymore
I've come up with a cleaner name for
something I'm transitioning you can
actually actively deprecated a specific
enumeration or any other attribute that
you wish to use but deprecation is
always an easy example to provide the
normative encouragement to compilers to
say if I see an attribute in using the
attribute namespace feature that isn't
mine at my attribute namespace don't
give a warning about it we've put this
feature in so that the feature is
extensible to other libraries yeah
there's a feature I don't recognize I'm
not using it but if I nag you about that
the feature then turns into lots of
conditional compilation and defeats the
whole purpose of introducing the idea of
attribute namespaces in the first place
and similarly there was an idea that if
I'm using a lot of attributes from the
same attribute namespace it would be
nice be able to have it using and saying
using this attribute namespace I'm using
all these attributes so I don't think
they'll be widely used features but when
you deal with some heavily annotated
code that could actually be very useful
aggregates get a little tweaked up in
the new standard aggregates can now have
empty base classes which means you've
got a class that was not an aggregate in
C++ 14 because it had an empty base
class that class 1 now for the aggregate
initialization rules rather than calling
the default constructor in the copy
constructor accordingly that does show
up in a few corner cases but the
difference typically
I can actually initialize all those
members but when I'm going through
containers some of the ways I can
initialize things get a little bit more
confusing aggregates now they can have
base classes are not allowed to have
inherited there are doing Herot
constructors or have explicit
constructors how would I have an
explicit constructor I would inherit oh
I guess I actually couldn't have an
explicit constructor while that's in the
word some folks in the core wording
found it cool in the case of how they
could actually get explicit on the
constructor into an aggregate I'm not
sure how that could have happened but if
you miraculously construct it it's still
not allowed from a really handy problem
they finally solved aggregates now to
put copied list initialization so if
you're using brace initialization and
trying to copy your aggregate well the
rules are bracelet wise actually say I
initialize the first element with the
first thing in that list in V I don't
have my first element is not of my own
type I'm not a recursive data structure
so that's not valid so actually that
will now be a copy constructor call
rather than trying to initialize the
first element with a copy of yourself
I've got way too many slides on lambdas
because lambdas are always fun to talk
about but this was C++ 14 and you've
already all told me you're familiar with
C++ 14 so I'm not dwell on this classic
example of it I'm trying to do a reverse
sort algorithm in this case so I'm just
going to turn round the two elements of
the container that I'm calling I've got
to use this funky horrible type def name
so it's much easier or a I'm suggesting
that bind would be the answer for this
even though people love to use lambdas
because the bounce in fact is really
short and it's fairly clear as to what
it's doing I don't have too much other
text to read but C++ 14 we can do this
directly using the polymorphic lambda
feature where we just drop auto in as a
type and we now have a function template
that's abusing both arguments for the
the implicit functor that's in there and
then we just call the arguments in the
reverse order the other thing we
from C++ 14 is lambda capped yeah so
where I can use an initialization
expression to initialize the CAPTCHAs
classic example usually given here is
I'm calling a sort algorithm I want to
have the lock over that whole algorithm
while I'm calling my function so we're
going to have a lambda I'm going to move
the unique walk into the lambda to the
lambda narrow interlock and when the
algorithm is done it destroys a lambda
and the lock goes away the main problem
with that of course is that standard
library algorithms can arbitrarily copy
their functors I noticed this just as I
was preparing these slides and I've just
started a discussion on the standard
reflected today that this is a feature
sounds great but it's not going to work
with a standard library because most I
was given was user reference wrapper
instead so I'll call stud ref but
holding a reference to something that's
supposed to be unique walk sounds
particularly worrying to me if it is
going to be copied many times everyone
thinking they on the lock and it adds
nothing because all right I've got to
move the lock outside which I already
have covering the context anyway so the
classic example of the movie
neutralization of lambdas I'm not sure
how useful a move on the lambda is yet
but hope they will pick this up in the
library working group and see if there's
anything more useful we should be doing
there and that's a whole other from C++
14 that's not new stuff what am I doing
here
this is just the this is pretty much how
you would write it today is you actually
you could lock fine-grained on each
operation or you could just let us say
on the previous slide lock oh the
original slide look over the whole
algorithm outside it and just to kill
how do these things get we have an
example in the standard of just
combining lots of things together and
saying here's a really awkward set of
corner cases to think about please don't
do this
so see parcels 14 we have the
polymorphic lambda expressions I just
showed and the capture initialization
show of hands Delia said you already
know all about these for C+ or 17 lambda
expressions can now be constants per
which means that there will be literal
objects you can con state for a little
while
to them the language expression itself
can be executed as a Kong sex poor
evaluation given the generalized rules
for context but when things and C++ 14
that's really handy and one of the other
things that was problematic in C++ 17
was capturing a cut if you capture this
you capture a pointer value and if I
wanted to actually make a copy of an
object or specifically this Copic with
the star this it the syntax around that
was possible but very convoluted so
we've actually got a very simple way of
just putting a star this and to capture
a copy of the object rather than a
reference through the list pointer and
okay I'm I'll be ahead of where I was
going to be I've spoken myself too fast
this was roughly about my breakpoint so
I'll be a little bit I can slow down a
little bit for the next second template
features C++ 14 we added variable
templates so the idea here is I've got
PI and if I want to have this is a
classic example pie I'll have it at
various accuracies different frequency
of representation for float double long
double and use specializations to have
my preferred representation of Pi in
that resolution rather than just relying
on part in the long number and rounding
accordingly one of the awkward cases for
seventeen that we finally got round to
just an irregularity in the C++ grammar
whereas most places in templates we've
got the option of using class or type
name and the seams to your feeling that
type name is more of a C++ ething line
class so there's been a general idiom at
people have moved towards using type
name but when they have a template
template parameter so I've got trying to
have a class template of type X called X
the ground I didn't support using type
name there it had to be class so we're
changing the one part of the grammar
that required class rather than type
game yes yeah and going up okay
another again man your future just doing
what's a queen up Napa seventeen we've
got the feature of I'm trying to have a
template that's going to integral
constants is the classic example where
I'm going to have a constant but I've
also got to name the type of a constant
I can't I want to give you one thing
the constant value but end up having a
template parameter with two because
they've got to say what the type is as
well as the value of the constant as I
can see what type what what the type is
it's in the constant so we've got this
new template Auto n syntax that as you
can see what the use n is both of type
end and an int with that value so if we
were to go back in time we might have
implemented integral constant this way
neat new feature that's why I have on
this slide I put it in purple because
when I went to trying give an example of
this I went let's go back and look at
the the paper that was adopted for this
now actually although I have this down
on the list of things we've done I
couldn't find a paper trace that said
what the feature is is possible it's
come in through a library defect report
it's possible that I've just fooled
myself and this one didn't happen so
take this one with a big grain of salt
but there's the idea of it when I've got
literal types we can expanded the idea
of what nan type template parameters to
be to allow beyond just integers and
pointers here I particularly wanted to
look at that to see what you know if I'm
using a floating point there what are
the rules for matching Nan's and so
forth but because I couldn't find the
actual paper trail I'm no longer as
convinced as I was when they put the
slides together that made the final cut
and you'd have to go back and be
research my notes I'm afraid so one of
the big features coming to the template
feature facilities of C++ 17 is if Const
expert the idea here is the condition I
passed if Const X but is going to be
some code that you value eights at
compile time is a constant expression
and then which of the two branches of
code you have got the if-else is
actually compiled is chosen so if I've
got an expression that isn't going to
compile on the elf on the under the if
branch normally what you'd have to do is
you have to have partial specializations
or class templates or overloads of
function templates you go to a very
indirect idiom just to jump around the
fact that I've done the test I know
whether or not this grammar is good too
because under here is going to match the
name will look up rules and be a valid
expression and I've got something else I
want to do if it isn't
I want to write that cleanly in one
place like the example here rather than
have an indirection from in directing
function that goes into an overload set
that dispatch is accordingly perhaps
with some enable ifs it was really messy
so this is going to clean up an awful
lot of obscure template code that could
be written much more directly all the
expressions were popular request for
very attic templates where I've got its
parameter pack of things and the
examples I'm using here I've got the
street counter folding the standard the
left fold the right fold and the the
binary fold these terms are great if
you're familiar with functional
programming everything I know about
functional programming I learned by
reverse engineering from C++ templates
so I don't know the vocabulary but if
you know the vocabulary these are the
terms you're looking for otherwise read
the syntax and hopefully become fairly
clear what's happening we've got a left
hold on double ampersand I'm going to do
a conjunction of every expression in the
pack expand engine and get true or false
at the end it does follow the
traditional short-circuiting rules when
it evaluates all those expressions but
it also has to instantiate all those
expressions in the parameter pack before
it starts evaluating them so if you're
looking for a short-circuit evaluation
that says because I know that the third
one was true I don't need to worry about
whether or not the fifth or sixth thing
in the pack is going to compile
correctly or not because lookup fails no
you still have to instantiate the whole
pack but it will combine accordingly
another popular feature is requesting
for a long time and we just didn't quite
know how to specify in standardise we
think we've got it right now and this
came in right on the deadline of c++ 17
is deducing templates from their
constructors so I've got a class
template and it's got a template
constructor in there depending on how I
call that constructor I could be able to
do use the actual parameters for the
class itself so we've got an example I'm
trying to say I'm going to have a pair
this would be an alternative actually
coin a mate pair function I'm going to
initialize it with 42 you
you in hello world is a string there for
just having standard pair and then these
things in the curly brackets it now
knows I'm trying to D dousset I prepare
I find the only constructor that can
match and from that I can did use that
for pair T and u T was an unsigned int
and you had to be a string and for those
cases where it's not immediately obvious
from the template itself we can we have
outside the class a deduction guide that
can give the direction so in this case
I'm going to call the container
constructor that takes a pair of
iterators but the iterators are not the
type of a container element they refer
to the container element so when I call
that and then I'm doing a deduction I'm
did using the iterator type and the
different guide says well I'm a
container whose element type is the
value type of the iterator that I can
find in directed rates and that Paul
lets me did use that for the container
I've got container event because I have
a sequence of n that I'm passing through
iterators and I think this is probably
the place I should be calling a pause
till the second session</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>