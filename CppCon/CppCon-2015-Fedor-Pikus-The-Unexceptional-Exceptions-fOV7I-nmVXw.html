<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Fedor Pikus “The Unexceptional Exceptions&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Fedor Pikus “The Unexceptional Exceptions&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Fedor Pikus “The Unexceptional Exceptions&quot;</b></h2><h5 class="post__date">2015-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fOV7I-nmVXw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning and thank you all for
coming
the let's open the morning with the talk
on exceptions which is somehow
undeserved Lee considered to be an
exciting or a controversial subject in
truth exceptions are one of the most
boring parts of C++ and my goal is
actually to convince you that this is
one of the most boring part of syphilis
plus and the reason is because you know
there is no real controversy about using
if-then-else and what's so special about
if-then-else now you just use it there
is no you know code stuff and guys will
avoid it then else now use goto but
there are plenty of organizations who
outright forbid exceptions because
mystery happens who works in our
organization that does not allow use
excel use of exceptions by by feet of
law there are some like if you are an
embedded systems maybe but for the most
part it's a result of kind of
mystification of exceptions more than
clear-thinking furthermore even if you
don't use exceptions that exceptions
themselves are very boring even if you
know just like if you don't use for loop
you still have some form of iteration it
just looks differently and understanding
how for loops work would help you write
iteration in any other way
whatever that may be there is very
little in exceptions that is exception
specific so understanding how exceptions
work would help you write better
programs even if you actually end up
never using exceptions okay was that I
think it's time for us to start on the
subject
sit down okay let's begin
so I already started talking about the
motivation now I will show the basic
exception machinery just so we're all on
the same page and we know basically what
the vocabulary is and then will
fundamentally switch to error handling
and then we'll talk about some the
practical guidelines for using
exceptions in existing code base as I
said it's not actually very hard to use
exceptions it's harder to use them well
but even that is not particularly hard I
want to show that basically they are not
special in any way if your program is
written correctly and you want your
program to be written correctly just on
that subject just checking anybody works
for organizations whose style guide says
do not write correct code okay what is
an exception in C++ exceptions are
language facility for handling basically
abnormal situation usually there are
some sort of errors the non-trivial
thing about exceptions they interrupt
the normal control flow we'll see how
that happens and there is a reason for
that they are used when the normal
control flow becomes impossible or at
least undesirable that's why they
interrupt the normal control flow and
they create alternative control flow
which is executed only when exceptions
happen I'm not going to give you like
all details about exceptions you can
read that you can read the standard you
can read the exceptional books you can
read cpp reference but I'll give you the
enough basics for us to to get through
so this is basically you know all the
exception language it's almost all the
exception language on one slide there is
a throw there is trying a catch so we'll
go through the explanation so exception
is generated using a sir
here I throw an integer can throw
anything you want the standard provides
the base class STD exception you don't
actually have to use it you can you can
throw built-in types you can throw your
own types you can derive from STD
exception you don't have to there are
some advantages to that but you can
throw anything you want exception is
arbitrary data type it may contain data
you can throw a string that's DD string
you can throw a temporary it just gets
copied so what happens when the
exception is thrown well let's go back
here it interrupts the normal control
flows and you immediately jump to the
closing curly bracket any distractors
that were object local in the current
scope fire the objects get deleted and
then if the exception is not caught by a
cache block this process continues to
jump to the next closing curly brace and
so on if doing so you reach all the way
to then to the main an exception is
still not caught the program terminates
there is an interesting detail here
which is that if the compiler knows and
usually does that you would reach main
although from your from the point point
where you throw the compiler is actually
not required to go through this routine
it can terminate your program right
there which means the distractors do not
fire when the program terminates right
there but the cleanup does not happen
well the operating system presumably
does the cleanup so let's let's look at
this example we have some while loop we
create an object and we're going to
transmogrify it except before that we're
going to throw the of course this and
you never write this you don't throw
unconditionally but let's say we throw
what happens well first of all the rest
of the code within that scope is not
executed so transmogrify is not cold now
G is destroyed a local object and the
exception is not caught the works effect
okay so a local variable is destroyed
there is no catch here so we keep
unwinding the stack another local
variable is destroyed here may be Y may
be exactly as I said not caught anywhere
on this slide now in this case you
actually know that it's not caught which
means the compiler knows till the
compiler can call terminate right from
here okay let's change it so we catch so
now this has to be destroyed so now in
in this scope and we sell we know that
there is a catch compiler actually
tracks that whether there is at least
one catch in the stack above you or not
so now there is a catch local variables
are destroyed okay this I'm sorry this
would actually be called this isn't
correct this is called because we caught
it so it's a exception interrupts do
stuff gets handled here and then this is
called this isn't correct cold okay how
do you so we know how how to throw
exceptions how to handle you can catch
and inside the catch block you can run
basically arbitrary code you can catch
exceptions by reference that's the
normal way of doing it
you can catch by value as normal values
is passed by value semantics a copy is
made you can catch by pointer pointer is
just a built-in type which means you can
catch pointers by
there is a tricky question as who is
going to delete whatever the pointer
points to difficult to arrange Enel in a
large system that deletion happens and
happens only once so usually not this
usually not recommended now here I said
catch int by reference what if it's a
double or if it's some exception you
don't catch this catch block does not
catch it well if you want to catch
anything you can use catch dot and it
catches any type of course you don't
know what type you call you can catch
multiple types so we're going to catch
an end
this is catching STD exception by
reference now you don't normally throw s
DD exception you throw anything derived
from STD exception your normal
polymorphism rules work if you catch by
reference to base class you get all
derived classes and if you if it wasn't
any one of these here is code okay so
since we spoke about derived classes can
you throw a derived class
sure why not so let's look at this this
is I specifically focused on this
because this get zero sometimes here is
a derived class base class throw a
reference to a base throw base base
class here we have derived class and
we're trying to catch derived class
because that's what we actually passed
in this is a base reference but it
points to a derived class surprisingly
enough this one fires not this one and
that's big
exceptions rowing is static it's the
type of exception you're serving
determines at compile time not at run
time zero is not a virtual function so
whatever the type of whatever this type
is that's what is thrown you can think
of it as a copy is being made which it
actually can be but doesn't have to
there are no virtual copy constructors
if you're copying a type a base type out
of the derived type you get a slice you
ripped out the base type out of the
derived can you throw polymorphically if
you want to yes using virtual functions
you basically make the throw itself into
a virtual function like here is a
function raised in the base class it
throws the base class exception in the
derived classes rows derived exception
and now if this is really a reference to
D the D will actually be Cerrone because
the polymorphism occurs not at the point
of zero but at the at the point where we
decide which of these functions to call
here it'll call derived derived okay can
you throw in inside the exception
handler inside the catch yes just throw
anything you want but there is one extra
option open to you you can sir you can
this one sir always note that throw
nothing this throws the current
exception whatever you were handling
gets rezone and continues to propagate
this is actually sometimes useful
sometimes people modify exceptions if
you catch by reference you can do
something to that exception and reserve
it and here is an interesting idiom that
allows you to have some code reuse in
your exception handling so let's say you
have many places which can throw and you
but you have some unified code code with
that you don't want to copy that you
want to use for handling those
exceptions this is called exception
dispatcher so here is your place that
can throw in catch you call the dispatch
the dispatcher gets cold inside the
catch block the only thing it actually
does is it restores it restores the
current exception and it handles it here
okay so this is just so when we see
exception syntax in the slides we know
what we're talking about since the main
goal is to convince you to not be afraid
to use exceptions well why would you be
afraid to use exceptions what's wrong
with exceptions the main problem that
people bring up is exceptions around in
a separate control flow now exception
handling code is what what you have
inside the catch blocks so the normal
execution is suspended and you have the
control jumps out of the middle of your
normal code into the cache blocks the
cache blocks are difficult to write
because the why did you jump out of your
normal control flow the normal state of
the program has been disrupted the
current state is all nobody knows what
exactly it is something went wrong so
the program is probably already in a bad
state now the goal of exception handling
is to actually undo this situation and
restore the well-defined state in order
for us to do that we have to have some
level of guarantees about what can we do
safely if once the program is in a bad
state you cannot do anything for sure
you there is no guaranteed way to
recover so you have to have some
guarantees okay so going going back to
our alternatives exception safe how this
code is card to write that is actually
correct it's not however a good reason
to write to not to avoid exceptions
because any code that maintains a
well-defined state is hard to write in
about equally hard to write well let's
look at this okay if you don't use
exceptions what do you use you use
return codes
well here is your error codes so we
create widget if something failed during
creation and we got now you returned an
error code the main difference is error
codes use the same control flow so you
would have returned to return the value
anyway even if it succeeded so you use
the same control flow the second main
difference is return codes can be
ignored everybody knows that printf
actually return something who always
checks with the return value of printf
exceptions cannot be ignored
they will terminate if you if you try to
ignore them all the way up return codes
are constrained by the return value
which means you have to have a return
value that is otherwise impossible of
course the other option is you add an
extra parameter for your return code
exceptions can be of any type or of
multiple types there is a price for that
and the price is exceptions are not
easily visible in an interface whereas
return codes are so if you this is the
Declaration of a function well what does
it return a pointer what can it throw
anything it wants that's the
manifestation of the separate execution
channel okay
C++ 98 had throw declarations C++ 11
added know except yeah they don't quite
help all the way first of all it's not a
compile time check even know except
which can be evaluated at compile time
whether to check whether you have a
guarantee for now except doesn't
actually guarantee that at once so the
only thing that guarantees that the
program will die if it tries to throw
furthermore the functions that are no
accept or no throw cancer all inside
they just have to catch it this actually
guarantee is that except
don't escape well it guarantees that
exceptions don't escape at the cost that
you may terminate okay there is one
place where you cannot use return codes
constructors have no return values
constructors can fail just like any
other functions oh there is another
place destructor have no return values
well it would be kind of hard to deal
with destructor failing because the
object is going away one way or the
other a destructor soldiers also should
not throw the reason for that is in C++
you can have one exception propagating
at any given time destructor can be
fired as a part of stack unwinding when
an exception is propagating if
destructor itself throws you now have
two exceptions in flight the runtime
system calls terminate immediately so
technically you can throw it will
compile and if it actually throws during
stack unwinding the program terminates
so summary of the differences exceptions
cannot be ignored return codes can
exceptions have their own execution flow
that never gets exercised unless you
throw return codes have the same
execution flow return codes you have to
propagate on every stage if you are not
ready to handle it you have to return
again exceptions will do it for by
themselves implicit interface versus
explicit interface more constraint on
the types and the exceptions can be used
in constructors ok
exception safety is really hard that's
why some people avoid it here is a very
simple function open the log create a
widget log the creation of the widget
close the log return the new widget what
could possibly go wrong here everything
yes ok open control what happens if open
throws nothing really
the new expression including the
constructor can throw what happens if
new expression throws log file remains
open presumably the recording control
what happens if that's rows well
we throw we don't return the pointer but
we did allocate it so now there is no
way to get to that widget anymore so the
widget has leaked that wouldn't be half
as bad if it was just the memory what if
construction of the widget takes a lock
that you must unlock later wouldn't be a
very good design but what if it happened
now you leaked off an open lock well
okay let's let's see that's why you
shouldn't be using exceptions see how
many problems on one slide return codes
are much better let's say that
everything here uses return codes they
all returns the return code just like a
printf never happens ignored a new
expression can return now now probably
wouldn't happen nevermind a record can
fail return an error code probably won't
okay now let's actually use error codes
I said use error code let me hon just
let me highlight use error codes if it
opens if often failed return now if
widget creation failed return now if
record fails return now well all of the
same problems that we had with
exceptions actually can happen here only
the code looks uglier the fundamental
problem that we're facing is not
handling exceptions for writing
exception safe code the problem is
handling errors and writing error safe
code the fundamental requirement is
after an error happens the problem
somehow must remain in a well-defined
state and what's a well-defined State
well there are several levels of
well-defined State at the bare minimum
no resources must be leaked
that's called basic error safety
guarantee it's if you are using
exception it's called basic exception
safety guarantee but in a more general
situation we can call error safety
guarantee
ideally whatever operation failed is
cleanly and done as if it was never
attempted that is called strong
guarantee it's hard to do because the
only reason you're even there is because
something is already wrong okay in
practice people who are at exceptions
you know that's kind of your your first
line of defense you know people who
usually don't think about this guarantee
is the most common guarantee you have is
we don't use exceptions here that's a
kind of notes or guarantee assuming your
libraries don't throw assuming your
runtime system doesn't throw anybody you
two separate or knew well that control
then I'm a cast control okay
you still need to handle error somehow
so there are alternatives the the
probably most common alternative is this
one no guarantees at all so if exception
is thrown or if error happens the state
of the program is undefined and
continues to be that way now if you
actually try to do it right then you
have to consider these at least these
two fundamental guarantees the basic
guarantee and here talk about exception
safety but if you use something else for
handling errors it will be your basic
error safety guarantee the the program
must always remain in a well-defined
state in a well-defined state some
actions are possible with well-known
results some other actions may be
impossible or lead to undefined results
but at least some set of actions that is
known is still possible and is well
defined so for example if an object
throws you can still call some member
functions may be only destructor but you
at least we can destroy the object now
well-defined state is not necessarily a
very useful state : terminate or abort
is a well-defined state remember eyes
mentioned not very useful the opposite
extreme is a strong guarantee and the
strong guarantee is what's sometimes
called commit or rollback semantics any
action that you take will either succeed
or be undone as if it never happened
this is very hard to do it may be very
expensive it may be impossible
now it's sometimes used in a more narrow
context for example on some library but
even on libraries it's very expensive
STL which could never be accused of
avoiding writing complex code does not
provide such a guarantee across the
board so in in practice you have some
kind of medium for example STL provides
strong guarantee on certain functions
and it's documented which ones for
example STL push back either succeeds or
throws and makes no changes to the
container now it doesn't actually make
no changes it makes changes it just
throws them back or it is it may make
changes because you made you may throw
some time halfway through push back in
which case some of the changes were
already made it just guarantees to undo
them other operations provide basic
guarantee which is it means that certain
invariants are maintained at least
destructors at the very minimum STL
gives you the guarantee that if it's
arose destructors may be called no
resources such as memory locks threads
and so on are permanently leaked what do
I mean by permanently at the point of
zero not all resources may be cleaned up
but you do have objects that own them so
if you start destroying stuff eventually
you will release those resources so
in addition STL gives you additional
guarantee that is very important
certain operations such as swap and all
destructors provide the no sir or no
accept guarantee it's actually very
important that swap provides no Cyril
guarantee okay exceptions safety is just
a particular case of error safety if you
happen to convert your if you'd have an
exception program and you convert it all
to error codes well I don't know why you
would do that but if you imagine an
exception safe program and then write it
in terms of error codes it's actually
just if you do it correctly it's just
the different syntax your error handling
will be basically the same so let's
think in general ignoring exceptions
versus error codes what do you do if
your program encounters an error the
first option is you ignore it and hope
it doesn't happen the second option you
ignore it and you don't have any hopes
and then the more practical one is you
maintain certain level of invariants
that's a basic guarantee or every
operation follows commit or rollback
that's a strong guarantee in a program
that remains in a well-defined state in
the face of errors some level of
guarantee must be given whether use
exceptions or not so so throughout this
lecture we'll have several kind of
take-home points accumulated and the
first one is know your error handling or
not exception handling error handling
guarantees what do you do and what do
you promise when the program enters an
undefined state and something abnormal
happens okay exceptions are just the
syntax is a syntactic tool here is a
program that uses exceptions try
creating widget catch it close the logon
rizzo try recording it catch if
something fails delete widget that we
created close the login reserve this
looks very much like error codes
can rewrite it we was error codes and
it'll look almost the same well let me
do that just to prove here it is these
things look very much like catch blogs
there is very little difference if you
actually bother to handle errors either
way so it's useful to think in terms of
handling errors not the details of
whether they expressed by exceptions or
not so let's look at this kind of
pseudocode from this point forward so
here here if an error if an error
happens here we just return when we may
return through the normal channel or
through an exception channel but we
basically just we don't do any of this
if an error happened on this line we
must close the log and then return if an
error happens on this line we must
delete the widget close and then return
and so on another way of thinking about
it is from this point forward if
anything happens we have to close the
log from this point forward if anything
bad happened we also have to delete the
widget we still have to close the log
but we also have to delete the widget
again this is this is not C++ this is
annotations for for us to pay attention
to so we need some kind of action that
will happen automatically from certain
point on until the end of the scope and
then from this point on and another
action will happen like delete W and the
first action will still happen you know
any feature in C++ that automatically
runs code at the end of the scope
destructors and local objects there is a
wrinkle however this there is slight
subtle difference between closing the
log and deleting the widget closing the
log must always happen even in the
normal flow even if there is no error at
the end of the scope you need to close
the log
you better not delete the widget if
you're going to return the pointer so
there is a subtle difference between
these two actions one happens in normal
and error handling channels and one only
happens in an error handling channel the
guideline here is the normal cleanup
should be done in the normal channel
well let's look at some code that would
do this now this is basically a unique
booter of C++ 11 the only reason I wrote
my own is I want to show you exactly
what's going on on the inside I didn't
want to lie to you about implementation
of unique pooter it has a little more
code than I'm going to show so I created
a kind of simplified unique footer and
you would you would use unique footer in
reality so first of all we have this log
guard that in the constructor it opens
the log in the destructor closes the log
and then we have basically a unique
footer which I call scope scope Twitter
here constructor just grabs the value of
the pointer and the destructor deletes
it ok now here is our log guard of log
the constructor opens the log the
destructor will close the destructor
will close it no matter how we exit this
scope if we return right here log is
closed if we return all the way on the
bottom log gets closed if something
throws in the middle here log gets
closed thank you ok this is great
here is our unit scope pointer which as
I said is just a unique footer captures
the widget if anything sorrows in here
let's say this record sorrows then the
destructor of the unique footer will a
fire and delete the widget this is great
if but at the end of the scope the
destructor of the unique footer will
fire and delete the widget that we just
returned
that's not so great okay so we have
converted an error handling problem to a
resource management problem
we just haven't managed the resources
quite right so resources that are
acquired within the scope must be
released within that scope that's the uh
normal local classes unless you want to
hand off the ownership and that's the
classic resource management problem so
for load we're good we don't handle
ownership anywhere for the for the
widget we need to hand off the ownership
to the caller okay let's go let's add
some more stuff to our scope footer
again this is verbatim how it is an
unique footer only there is more stuff
to it
but it behaves basically as if it had
this and that's why I didn't call it
unique footer because I don't want to
write more stuff and I don't want to
pretend that it's as simple as this
there is a release function what the
release function does is it returns the
pointer that was captured inside the
unique footer and it resets the pointer
to now without calling the destructor
that's important you can always reset
unique pointer tour now by just
assigning now to it but it will call the
destructor well this one you can't reset
to now because it doesn't have a sign
interpreter okay
so at the point where we have to release
ownership where we don't we got we
survived up to here errors did not
happen if we didn't survive the
distractors of both of these would do
the cleanup we survived up to here now
it's time to relinquish our ownership on
the widget so we can
turn the release the important part is
basically there shouldn't be any errors
after this at least not the ones that
would force you to delete the widget
because at this point we gave up the
ownership well okay so the guideline use
resource acquisition is initialization
paradigm to automate resource cleanup in
both normal and exceptional channels and
actually this is a standard factory
function so this is this is actually a
simpler way to write it with a unique
pooter
because unique pooter will move the
object from in C++ 11 it will move the
pointer from here from this one to the
return value and when you move the
destructor on the temporary will not a
destructor on the unique pointer will
fire but it will not destroy the widget
because you moved it out to be now
inside before c++ 11 in the you could
replace unique pointer without a pole i
was out to put her and this is actually
one of the few places where it actually
worked and did exactly what you wanted
now this is all about exception handling
so where are my try-catch blocks how do
you handle exceptions without try-catch
blocks there aren't any and this is a
very important point this is actually
this is this program handles errors
correctly it handles errors regardless
of how you what mechanism you actually
use for handling it if you put returns
here it will still handle the cleanup
correctly if you throw so if any of
these can throw errors are handled by
the destructors if let's say instead
let's say instead of throwing you check
a return code of record and return
return now because you return now from
here you did not move the widget from
the unique pointer so the destructor
will fire so this is essentially
mechanism agnostic and that's the whole
point
correct error handling knows very little
about the syntactic tools you use to
handle errors so we think of always
think about handling errors don't think
about don't think what happens if this
rose
think what happens if this function
encounters an error and has whatever
abnormal return it can put it can have
according to its syntax how are you
going to recover mostly error handling
is about not leaking resources and
maintaining invariants now your normal
programming is also to a large degree
about not leaking resources and
maintaining invariants while we're
focused on not leaking anything if error
happens we also don't want to leak
anything if errors do not happen that
would be bad so most of the cleanup
actions actually have to be done in both
normal and error control flows so do
them in this and do them without copying
the handling code do them in a way that
works for both normal flow and the error
flow at some point you have to actually
handle errors explicitly so if you're
using exceptions you have to catch them
if you're using a return codes well
first of all you always have to check
and return so you have to handle them
explicitly for that that's why you know
the well written exception code has very
little exception syntax because you only
catch stuff when you need it for the
most part it the automatic return
happens and visibly to you a well
written error safe code based on return
codes has explicit code to check return
codes every time other than that it
doesn't it still doesn't have any other
special handling code it just check
return check return the cleanup happens
automatically so why would you catch
well
you have to stop exceptions at some
point from propagating if nowhere else
you have to do it in Maine otherwise its
determinate now the another reason is if
you want to change how you report errors
you can catch exceptions and then
propagate the error in some other form
you can use return codes you can throw a
different exception rarely used you can
modify the exception and reserve it
which is just a particular case of the
previous case here is what so these are
were all reasons to catch this one is
not a reason to catch do the clean up
after the error don't do it don't cache
to do the clean up well let me show you
a more more complete example so the
guideline is only use cache blocks when
you actually have to catch exceptions
not when you have to do the cleanup okay
let let's talk about what not to do
let's talk about unnecessary error
handling manual error handling deleting
your pointers closing files reclaiming
resources this is this is what not to do
so don't be confused right things to do
and there are things to not do don't mix
the two this is not exactly as the D
vector resized which so I put a capital
v here but it's close enough so what
does the resize do well it allocates new
memories so vector is basically a
wrapper around the big array has a
contiguous buffer and so if we want to
resize let's say this this resize it
always doubles kind of doubles the
memory the real resize takes the
parameter but that's not important here
now allocate okay if that fails you just
throw in a nothing changed all right
then
because we just allocated new memory we
have to copy
the existing data from our current
buffer we have so this is a new buffer
so we have a current buffer we have to
copy the existing data from the current
buffer into the new buffer and that can
throw because it's a copy constructor it
can throw so if it's rose we have to
clean up the memory we have to
deallocate the new buffer and we throw
the exception okay this actually has a
oh and we also have to destroy or
whatever we already copied so this would
follow commit aerobic semantics if
uninitialized array copy was done right
so let's look at initialized array copy
here is initialize direct copy this is
actually an STD algorithm it's slightly
more complex than that but that's the
basic idea again we're going to try to
copy from begin to end just increment
increment the from four this is the the
front pointer this is the source this is
the destination and we're just going to
placement new this calls the copy
constructor this constructs a new
element in this location that's a
placement Neil if something goes wrong
we have to call distractors because this
is a placement you we didn't allocate
any memory so we can't call delete but
we still have to call destructors yeah
you can call disruptors explicitly so if
some if something went wrong we have to
call the destructors on anything that
succeeded so maybe ten objects got
copied eleven thrown well you have to
delete the ten okay so if copying fails
all the copies that you already made are
destroyed whatever question okay well
this
this is correct but badly written this
wasn't the previous example was correct
but badly written here is how you do it
without an explicit catch here is our
buffer has constructor and it has
destructor and it has an arrow swap or
in C++ 11 it would be a no accept swap
very important that this does not throw
CY okay we create a buffer we do
uninitialized array copy we copy the
elements I mean and we swap the buffer
this is why it's important that this
doesn't zero because at this point you
would not be able to recover from there
or anymore
oh you destroy it yeah you just and you
destroy the old you call destructors on
the old stuff distractors don't zero
because again at this point you know you
would not be able to recover from
there's destructor important the
destructors notes are all very important
the swap doesn't throw
if however uninitialized are a copy
throws it does whatever at once inside
it then reese rose and the destructor of
the buffer cleans up the memory without
the explicit cache block
okay what about an initialized array
copy well here is our little handy copy
guard and very strange calling signature
destination destination there is a
subtle difference one captures the
pointer by value and one captures the
pointer by reference which means what
one of them tracks this is the begin it
tracks what the destination was when you
called it this is the end it tracks what
the destination is currently and we're
advancing destination as we as we
copying values from begin so this
destructor will destroy from the old
original value of destination to the
current one without any cache blocks
compare that compare with this cache
block this is basically the same code
only now there is no cache blocks now
there is there is one trick of course we
don't want that destructor to destroy
everything if this copy succeeded so we
have to do the equivalent of the release
on success we have to release thinking
okay so don't do manual error cleanup do
automatic error cleanup if you're
already got so far you have very little
try cache in your program so now do take
advantage of the language features of it
basically at this point exceptions is
just the return code that you don't have
to explicitly tell you explicitly
checking you don't have to say if error
return that's basically what exception
does for you everything else is exactly
the same here is your error safe code
using return codes here is your error
safe code using exceptions badly don't
do this here is your error safe code
using exceptions correctly the scope
guard will do it will do whatever
actions you need to do on it on on that
on
it assuming you have some clean up on
exit so this is just a placeholder for a
resource acquisition is initialization
object so do prefer exceptions to error
codes for the simple reason that they
actually remove few lines of code if
error return okay we're now going into
kind of a system design area so okay now
we have our we know how to write our
safe code we know how to use exceptions
so at the kind of microscopic level at
the level of one function we're good
what about the entire system well that's
where you have to think usually happens
when two different groups write two
different subsystems one of them has
their own exceptions list and the other
one has its exception list now that's
why exceptions are bad that's why you
use error codes no same one of them has
its own enum for error codes the other
one has its in them for error codes
exact same problem this could actually
be a good thing if you need to cross a
system boundary and change how you
handle errors if if this wasn't by
accident if you actually have different
subsystems with different error
conventions not just different kinds of
exceptions you could be changing from
exceptions to return codes are back so
in general consider your error handling
which could be exception handling or not
as a part of your overall system design
even though it doesn't show in the
declare in the function declarations
when you design system think of it as a
part of a part of your design how are
you going to capture and Express errors
well this is an example of converting so
I this is an old legacy system well who
uses ooh boxes now this is a brand new
shining database it uses exceptions of
course it's C++ 11 so this is the
conversion from one to another fine if
the if that's if you have to bring those
two systems together and change the way
you handle errors that's what
you do you can repackage errors that
system boundaries no problem so in fact
system boundaries are a good place to
handle errors in general within one
system you have your automatic cleanup
going when you leave that system you
have the kind of broader concept of a
well-defined state nothing really don't
leave don't abandon your system in a
poorly defined state that's where you
should do their or cleanup so exceptions
do make it easier but most of the time
we work on legacy code and a lot of
legacy code doesn't use exceptions it's
difficult to rewrite your entire code
base to use exceptions so how to start
using exceptions and small doses the
answer is don't worry so much about it
the goal is how to stand start handling
errors correctly if you don't now here
is a little program which doesn't handle
errors close has an error code by the
way can fail who checks our error codes
on file close ok don't neglect
the advantages of exceptions but think
first of making your program
error-handling correct if you do then
there is very you will discover that
actually to switch the exceptions is a
very little burden for the most part and
if you have to to explicitly handle
errors can each including converting the
different types of error handling do it
at the system boundaries okay
legacy code and third-party code so as I
said convert error codes at system
boundaries you the hardest part is this
last one you have to know what a
well-defined state is whether you use
exceptions or not and there is no
shortcut so that you have to know your
system you have to know what resources
could be in use and what resources could
be leaked that's actually the hard part
of being exceptions safe but it has
nothing to do with exception safety it
has to do with error safety and yeah
error handling is usually not visible in
the interface which means you rely only
on the documentation unfortunately error
handling is usually the worst documented
part of your interface if your here is a
kind of a flipside just to show you if
you are integrating third-party code but
kind of backward if you are writing a
live in not you're using a third-party
library but you are writing a
third-party library well there is this
trick where so the the file system the
file system proposal now uses before the
standard uses this trick so it's not all
bad basically provide function overloads
for all your functions one option is
with exception handling and the other
isn't no except with error codes this is
the syntax that the file system ts uses
you can also do it like this here the
choice is a compile time here the
choices at runtime the advantage of this
is that they can actually put no except
on the overload that has error codes
converted gradually focus on
error-handling
first okay and we have some time for
questions right okay I have some
additional reading on the slides and I
believe CP Khan will publish the slides
at their github okay
I do have a bonus guideline who wants to
see bonus guideline eat now warning if
you were asleep during this talk now is
the time to wake up
aureus dreams will turn to nightmares
because this is a bonus nightmare
material c++ now supports threads well
big deal and practice c++ supported
threads for a very long time supported
POSIX threads on UNIX systems
what's POSIX present I will know what
that is pthread create B thread join or
multi thread lock/unlock who cares have
seen this one B thread canceled in the
POSIX tender if you cancel a thread by
pthread cancel do the destructors fire
good things they do
I think they don't gilepsy implements b3
canceled as an exception destructors do
fire stocks are stock is unwound yeah
that's great
a is it you just caught the thread
council and didn't whistle well in
practice it doesn't do quite it doesn't
quite do what you think it will do it
doesn't completely silence be thread
council pthread canceled is a special
exception you get a board instead of P
thread Council well it gets actually
worse than you can solve this problem
you can solve this problem in the when
you're dealing for booze dilip see
because you live see specifically
implements B thread cancels an exception
so any catch dot dot
can trap with read cancel well you can
specifically catch for this is what this
is what you should be catching if you
want to specifically grab the pthread
cancelling you probably should reserve
you'll probably want to have deaf it if
you in your compilation because this is
a type that is only present on July
pc-based Linux systems energy database
systems it's not the worst part
this the this was just you know
disturbing dreams
the nightmares part time right now
pthread cancel can interrupt your thread
in any consolation point which means any
cancellation point can now roll
including those inside your no accept
functions including those inside your
distractors how often do you have
destructors that close files who has
destructors of close files close as a
consolation point which means close can
throw if a cancel is pending avoid key
thread cancel okay question as I said
it's a special exception it's
effectively caught at the big you know
at the outer level of the thread where
thread exit would where pthread exit
would be called so the compiler knows
that this is you know just like it knows
to abort if you decide to ignore it it
also knows that this exception is always
caught and the implied handler is B
thread exit any more questions or go and
use exceptions then</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>