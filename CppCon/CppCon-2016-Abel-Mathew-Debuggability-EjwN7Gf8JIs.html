<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Abel Mathew “Debuggability&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Abel Mathew “Debuggability&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Abel Mathew “Debuggability&quot;</b></h2><h5 class="post__date">2016-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EjwN7Gf8JIs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so a common discussion I have with
people is GCC versus Sealink but the way
they kind of compare compilers typically
ends up being with a couple of criteria
performance warning or error messages
and that's kind of where the
conversation stops but what I do in my
day job is actually look at debuggers
and I look at them a lot and look at
their output but whether it's on Linux
systems and dwarf information and the
debug ability of binaries that produce
and so about a year ago I asked myself I
wonder what the debug ability difference
is between binaries produced by GCC
versus C lank and it's actually it was
pretty interesting a year ago but before
we go into that you know what are some
other ways we can actually compare
compilers you know there's correctness
which is obviously very very important
but not a lot of us do we kind of just
trust our compilers whether they're
compliant and whether or not they give
us good compilation time so what is
debug ability I don't really have a good
definition so I pulled this off of
Wikipedia the extent to which something
can be debugged not sure so the way I
think of it is if I've got this thing
running in production and I have a core
dump or something of that nature if I
pull it up into gdb how well can ID bug
it and the problem is is that compilers
especially with heavy optimization can
really screw us over if we're trying to
actually view this information so a
symbolic debugger which gdb is will map
the state of registers in memory back to
a back trace of variables and type
information it does that with a very
convoluted process if anyone's ever
looked at the door specification it's
like 200 pages long and there's that I
know there's tons of information as to
why that is but it's turing-complete
it's really complicated it can really
really be a pain in the ass if you're
especially if you work with debuggers so
this is what I settled on it's not
really good it's not really scientific
but basically I said any debugger if I
swap the back trace how many local
variables can actually resolve based on
the compiler that I used so did this oh
nice
okay so I'm gonna go over five minutes
so basically si Lang sucked it so this
is about a year ago I looked at the
dwarf information
it was either outputting trash or wasn't
outputting anything at all and this is
for different optimization levels Oh -
Oh zero so even non optimized builds
looked at this with a toy C++
application today comparing a more
recent version so si Lang 3.9 The
Situation's a little bit better but
still not up to par with GCC so for all
you guys that really love si Lang and
love to use it it's great I think it
gives me great information and great
warning messages when I'm actually doing
development but make sure you consider
the kind of debug information you get
before you push it out into prod</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>