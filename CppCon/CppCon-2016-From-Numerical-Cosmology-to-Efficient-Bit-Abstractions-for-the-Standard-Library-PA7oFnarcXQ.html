<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: “From Numerical Cosmology to Efficient Bit Abstractions for the Standard Library&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: “From Numerical Cosmology to Efficient Bit Abstractions for the Standard Library&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: “From Numerical Cosmology to Efficient Bit Abstractions for the Standard Library&quot;</b></h2><h5 class="post__date">2016-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PA7oFnarcXQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hello everyone I'm sorry buddy I'm
postdoc researcher at the University of
yerba champagne and I am working in
between numerical cosmology and comm
plus ions and today I will present how
we came from a very thirty calicoes
medical background and how we started to
investigate bit abstraction for c++ so
too I will try to summarize the talk in
three slide first what is this talk
about
so as Bryce explained on Monday I think
there are several level of parallelism
me I will I will focus on bit level
parallelism which is the most from the
motorman which means that basically we
want to process bits in parallel this
talk will will be also focused on what's
wrong with vegetable and STD beat set go
there are a lot of problem with them in
supply space and I will show how we can
count bits 100 times faster than with
STD Victor so this this work littered
through library it led to a library
which is called the brief library and
it's it's very easy to use so if you
want to use it in less than two minutes
so you just download it on github then
you can start implementing your very
simple example to run a minimal test
case 5 ampere here we declare unsigned
int we set it to 42 and then we will try
to observe the bits of that unsigned
integer so we create a bt title the
address of the unsigned integer we at
the beginning of it and we call it first
and we create another one
next unsigned integer and then we
iterate through the sequence a bt later
in one line we managed to plot to
display the bits of the 42 between the
listing if you can beat starting at the
least significant bit and finishing at
the most significant bit and that's it
so the the thing the library is still
evolving so there will be breaking
change but our goal is to try to
standardize it and to give people tools
to manipulate bits both in a generic and
in a very efficient way so there is a
description in the for the proposal the
there is a proposal for the description
of the project and also a wording in
progress the end of in the coming month
there will be breaking changes but well
benchmark are very welcome on that level
so now I will explain where we started
in cosmology and why we ended up playing
with bits and to tell that I would tell
story so once upon a time in a galaxy
far far away and a small piece of rock
wandering aimlessly in the vast universe
a team of astrophysicist was wondering
about the nature of life the universe
and everything we got a new from math
some physics some computer science and
some programming that decided to design
a code that could answer their
methodical question about the errors
they said let's take an enormous box
with periodic boundary condition which
means that the right and left are
connected together the top and bottom
same thing and same thing for the front
and back let's fill that in no booze box
with particles when in the mass of
millions or billions son that's a lot
now divide this box in cells and in that
grid we will apply the following recipe
so for each cell
greed we will first in waiting for each
cell that contains a particle at
position X and velocity V we first start
by interpreting the density calculating
the density in each cell depending on
sounding particles from this density
hole we can compute the gravitational
potential because the more mass you have
the more the greater you will the
potential will be then from Phi we can
interpolate back the acceleration add
the position of particles and from this
acceleration we can compute the new
velocity of the particles and from the
new velocity we can compute the new
position and doing this step after step
we can see the particles moving and
you're using this very simple recipe we
can form galaxies in simulations so
simulating galaxies is nice but it was
not answering the question so they
decided to do better let's try to
investigate larger scales with galaxy
size particles first they took a
supercomputer and they made the Box
expanding at the universal at the
universe does and then they filled the
box with the distribution of particle
that is based on the statistics of what
we observe in the column in the
cosmological macro background forth to
improve the the first simulation they
they made an algorithm a mesh refinement
algorithm so that they have more
resolution where they have more
particles so with this kind of scheme
they divide they have a regular grid and
when the accumulated particles they are
threshold and when one of these
threshold is is passed we divide the
boxes into small cubes and finally after
all this work they ran the simulation
using millions of computing hours over
thousand of course and then the
with this thing so in that kind of
simulation every dots every will amuse
dots in that box is of the size of
galaxy and what we see is that there are
structures and if we compare that
large-scale structures and if we compare
that what we observe we see the same
kind of elements
it was nice and exciting but John's
other metaphysical question the need far
more computing power thanksfully new
architecture and nuke supercomputers
were coming but they realized that there
was a metro problem because they
occurred would not scale up to millions
of core my major part of the problem is
due to data structure so this slide is
stolen from a talk from Chandler two
years ago one or two years ago I think
and I think it summarized very precisely
the problem we have now for high
performance computing and this problem
is that you have a lot of computing
power but every time you try to access
the memory you can lose cycles so
hundreds maybe even thousands of cycles
if you try to access like a hard disk
drive this is a problem because now we
need to optimize the codes for cache and
memory access and then in this
simulation the adaptive mesh refinement
is implemented in terms of explicit
trees which means that every cell is
another tree the nodes are linked
together by pointers the problem with
that is every time we want to
exceptional you go elsewhere in the
memory and it's not at all cash
efficient so they started to think about
what they could they could improve about
these these trees so they started with
numerical cosmology and numerical
cosmology is based as I said most for
large pot and oak trees and the trees
just adapt to mesh refinement
dimensions but if you if you improve up
trees this can have consequences for all
kind of physics simulation and them so
for visualization the trees are a kind
of special trees and special trees are
used for geo matting and special search
trees special treats are type of trees
and trees are used everyone come to a
science including machine learning and
language processing and even compilers
are Brazilian trees and now in your
ballad champagne we have a whole team I
need a whole team about making trees far
more efficient it's the tree building
rock research project there are types of
trees that are implicit trees and where
you can create them as associative maps
it's very efficient but there is a
problem of then that the key so you have
a pair of key and values but the key is
to be efficient have to be sometimes
more than 64 bits and the problem is
that we don't have anything to deal with
more than 64 bits in either static or in
a dynamic way in C++ and this kind of
integral bits that can be used in a lot
of areas like arbitrary-precision
arithmetic from parent then we need bit
manipulation and for that we need to
from to start from scratch about bits
and this thing can configure a lot of
areas in confidence in computer science
particularly if you want to have very
good performance so they soon realize
that to make the most efficient trees
ever they will need very efficient waste
through many play bits and this is how
the whole story started thanksfully
either-or magician of surplus passed and
came to them and helped them to stop a
quest
he gave them a very precious map and
disappeared and that map where the
follow it contains it's a map of the C++
language and you have everything is
there so they started to search well
what do we have in this online library
to deal with bit and they started to
search on here because it's about the
bitwise
Canyon
so you have bitwise operations then they
looked more closely and they saw it
thanks Mike job or and bit set the
problem they it doesn't look very
appealing but this is the only thing
they found in that map chewed a little
bit so they decided to go there with the
hope of to leverage some bleep
manipulation to speed up their trees and
oscillation and this is where the bit
manipulation library started how its dot
so now I will speak about I will
describe the current state use a bit
manipulation in the in the suppress
Istanbul so first let's start with bit
set so I guess all of you know the bit
set class so if we look at see people
reference it tell it tells us that it's
a class template to represent a fixed
sequence of n bits and that sequence
there are some operations we can do so
this is the example given from people so
first you declare get set with eight
bits in it you print the first value
then you try to find with a while loop
the first unset bit so the first bit at
0 and for that you use the bracket upper
you can use the bracket operator and
then what this program do is you will it
will set bits until half of the bit set
is filled and to do that it use some
function like its account and bit set
size you end up with the bit set that is
written here second so it's very simple
and easy to use and there are lot there
are some optimized mum function members
like test or an enum count set reset and
flip the problem is that you only have
that so it's very limited in terms of
function and functionality for example
you don't have any
begin or end eaters which means that
this container is not really a container
because it's not compatible with
standard algorithm and you have no
control and the underlying
representation bit set is generally
implemented at an array of unsigned
integers in which you store your bits
but the problem yet you don't have
control through it on paper amateurs so
if you want to do your own bit
manipulation you can't really do it
thou something there are so something
about the operator bracket and bead set
that that's a little weird
so in that small program we create a bit
set of eight bits and then we set it to
42 then we create a boolean value a bull
from the first element of a bit set and
also something that is with the keyboard
auto which means that we have a
reference to this first element and then
on boolean we can do plus equal one and
something we cannot do so it's what's
happened in that operator bracket
returns a proxy of type
it's a nested class which is called bid
set reference it's almost like Abel but
just almost there are different
promotion rules different arithmetic a
member flip and different behavior of
Oberto between odd and this is extremely
confusing and error-prone for example so
here we we declare bit set of a bits and
we set it to zero then we do the same as
in the previous slide we declare a
boolean value and we declare something
that is a reference to the first element
both of them are set to the same value
and then we do 2 bitwise nuts these
things and we print first the boolean
value and then that's something so which
means that we start from zero we apply
bitwise not it should set it to 1 and
we'll play it again it will check it
should set it to zero pretty simple so
but is that this simple so whether that
print who thinks it print zero and zero
who thinks it prints one one who thinks
it prints 1 and 0 and 0 1 1 some of you
think the wrong man and it when it's 1
in zero the following happens so you
start and the first thing you start from
a boolean or pull value this will value
is 0 so you the first person you do is
not get wise not and force there are
promotion rules in C++ and when for when
you execute twice not a boolean it
converts it to an integer which means
that not false gives you minus 1 then
what you do is you be twice not this
minus 1 and bit wide enough of minus 1
in integer for an integer gives you 0
and then you store this 0 in boolean and
you end up with 0 now with the reference
so you start from 0 you be twice not it
it gives you a boolean which is true and
then you'll be twice not it again the
primates at that step it's converted to
an integer and true is 1 so you do
bitwise not on 1 and bitwise not on 1 is
minus 2 and you when you come back back
- true to a bore
it's considered as true that's why you
end up with 0 1 so this kind of behavior
is room asleep then we have another
thing too many played bits in C++ which
is variable so my opinion vector ball
it's that it's one of the biggest
mistake in this table if you if we look
at what CP / reference says about vector
born
it says the following vector goo is a
space efficient specialization of STD
Victor for the tide pool the manner in
which vector buoys made specifications
as well as whether it's optimized or not
is implementation defined one potential
optimization evolves quality vector
elements such as such that each element
occupies a single bit instead of sizable
bytes vector will behave similarly to
state victor but in order to be space
efficient it for thing now it does not
store its element you know contributes
array which is completely different than
Rachel than the Sun object ah then we
have vegetable reference which acts in
the same way as bit set reference it
does not use the Arabic eight or trace
contrib constructs to construe bit
values and finally you have no guarantee
that different elements in the same
container can be modified concurrently
by different threads it's because I
still Victor can be implemented as an
array at the dynamic array of unsigned
integer and the problem let's say you
want to write at the same time by two
different thread the first date and the
fifth bit the first and the fifth are
likely to be contained in the first de
jure of the sequence of your dynamic
unsigned integer array so when you will
try you will try to modify them at the
same time you will access the same
underlying integer at the same time and
it will fail so October is not a
container it's not confirming the
standard even though it's in this order
and there have been in the past year
since 99 there have been a lot of papers
trying to correct what's wrong about
electro ball and the problem that's
still in 2016 Victor Bowie still alive
so we need something to replace it the
good thing about victor ball that it's a
compact storage in memory and you have
begin an entity at all so it's
compatible with all algorithm there are
a tough problem
you have poor performance no access
again to the underlying representation
no thread safety it breaks the normal
behavior of containers and you have the
same problems as with bid set for France
it's not a problem of the functionality
of vegetable because the functionality
is okay but the mistake that was made in
that it should not be a specialization
of victor it should be an independent
dynamic bit set as we have in boost so
we have these two tools but the problem
is that in both bit manipulation can be
useful to fall out of things and
particularly new procedure generation of
processors you have entry sinks a zombie
functions that can be used to speed up
some applications and these interest 6
can be used here you have a plot of
where it can be used so for example in
cryptography bio informatics in error
correction from memory and it kind of
things
another important so right as I said
there are new instruction sets that
leverage beat manipulation to do things
very quickly in the shorter of time it
replace may sometimes tens of bitwise
operation by a single as an instruction
which means that it can it can really
optimize the code that that's used is
this kind of of instructions here I
listed some of this instruction for
example pop count and I went Popkin does
it count the beats in an unsigned
integer at all and all at once so people
started to some people wonder how can we
improve bit manipulation in C++ and
there was a proposal in 2014 that was
called a context per bit wiser person
library for C++
and the goal was to give Stoddard eyes
function like that too many plate bits
the problem that there was more than 60
bit specialized function that were
operating at a very low level and they
were limited to a small type as small
range of arguments mostly unsigned
Hinton and sine long long int and he
didn't provide any tools to manipulate
arbitrary long sequence of bits so the
beat library started with bathing and we
wonder how can we make things far more
general to operate and be sequence so
the beat library so bit dynamic beat set
also provides a structure that
generalize the static one the static
version of it and it has the same kind
of problems about the reference there's
no like a coherent set of tools too many
play bits so yeah btro you have bit
reference but it's hidden from the user
and if you want to implement your own
bit manipulation algorithm in a very
efficient way you need access to the
underlying representation what we didn't
only interface with what dynamic it said
actually do
it's like generalizing what's already
done in this structure but sometimes
it's hidden from from the user yeah oh
okay
but some so the idea behind that is true
this library will act as an underlying
layer a common layer that can be used to
reinterpret sequence of unsigned integer
a sequence of bits and on top of that I
as I will explain we can implement bit
view bit ranch beat a container adapter
to adapt whatever container you want to
a big container so as I said the goal is
to make the motifs bit manipulation
instruction sets and sequence of
unsigned integer to be able to build to
give people the tools to implement their
own bit manipulation algorithm and be
based data structures as I already said
there are a lot of application areas and
here I listed some concrete example of
use for example user-defined sets and be
to raise each with what we provide here
it should be very simple to implement
them an access to the underlying bits of
bounded and unbounded integers and
allowing people to implement their own
algorithm for example here a
specification of count that called the
pop count instruction when executed in
bits it resonates also with something
that piane said about the fact that
unsigned integer are types that are
ideal for use that Street storage as be
terrain the problem is that there is no
some other way to access and MIDI plate
bit arrays in C++ and to treat and sign
integer as bit rate what we want to do
is to give user to something simple
generic and efficient so the solution
the key ID is that thing that is
variants at the centre of this library
is a bit theater all of what I spoke
about can be
Shh if through a carefully designed eto
acting as an idiot or laptop at at Otto
adapter like STD reverse is the same
kind of things so a BT Tara takes
another turtle as a template and it
provides people with an API that is both
high level and whole and low level from
the eye high level it's easy to use from
the general user point of view from the
low level it gives access to the
underlying representation for the
musician purpose so from the high level
what you can do for example is you
create a list of unsigned integer with 0
1 2 3 4 in it and then you create a btro
that is for example starting at the
first bit of the first element the fifth
bit of the first element of the
container and you want to end your
sequence on the last element of the
container and then if you you can
execute the star Gautam on this seconds
in between first and last for example to
count the beats that are set to 1 and it
will return the number of bits that are
set when in a very original file
regarding to design they are true
question that we needed to solve
apparently every the first one is unwed
prison about what word presentation we
are talking about supply so they are
true representation the object
representation which deals with memory
how bits how bytes are stored in memory
and the value representation for example
if you said unsigned into this value the
objects representation is different from
the binary value of the value
presentation of that unsigned integer
because of little Antanas
it would be different on a big endian
machine but if you if we design
something that is dependent of the
underlying memory
datian then the results will be
different on different architecture so
we decided to that the beat at when we
say we want to be that position zero it
refers to the binary to the value
representation in binary which mean that
we are only able to operate an unsigned
int because for example on Integra there
is no specification in the study where
the minus sign is where the sign is same
thing for floating-point 40 in front of
values so our library's folk used an
unsigned integer when we're adding to
the move we can do with be teachers it
is done that way so finally we create a
list for integer that I stood here in
binary starting from the LSD you're
right and the MSD element 31 on the left
and let's say we start we settle it out
or to the thing that is in red so if you
decrease the 88 or you will go that way
and then go continue to reiterate the
first integer the sequence so if you do
your bit to total minus 23 you will have
the the green and each other for the
green element reversing for the if you
do the thing in the opposite way if you
do your charger plus 50 55 you will end
up with an iterator to the yellow so now
from the low-level pointer there are
three key functions that you need to
know to be able to implement be targeted
so first enter has a member base it's
the same kind of base as we were she
taught obeys and it returns the
underlying material because as I said
visitor is another each other adapter
then
btro also gives you a member position
which gives you the current position of
the bit within the value which refers to
you have the same member function a bit
reference and I will explain this later
and then bit reference you have also a
member a dress that gives you a pointer
to the underlying value so for example
if you want to implement count a
specific position of the counter go Adam
forbids so let's do those the
implementation for a BTR tour first
digital last and a bit value so you
stopped it so here we just declare some
types we control it the sequence of good
is good and then we have two cases the
first one is when your bids are
indifferent and sign integer second case
is when your bits are in the same
underlying integer so in the first case
what you do is you check whether you
start at the LSB of your integer this is
what does B position different than
their if it's different than zero which
means that you're not aligned and what
you do is you shift your first integer
and you count the remaining bits then
the unsigned integer that are between
first and last you do you simply iterate
on the sequence executive Pupkin
function on them
and then if you have remaining bits and
the last interview you do the same as
before you shift your integer and you
count the remaining bits where your two
bits first you're too busy at all on the
same underlying integer then you do
something a little more tricky you
extract the middle part of your unsigned
integer the part in which you are
interested
I mean you count the beats in that
sequence and then depending whether you
want the number of ones or the number of
zero
you you if you want the number of zero
you simply compute the difference
between the number of bits you have in
the sequence and the number ones and you
give back the result it's so with beauty
theater it's easy to manipulate from the
user point of view because you simply
declare your bitter turtles as adapter
but he tells so gives an stolid eyes
interface to access the underlying
sequence but there are key design
question because it's in eater at all we
need to answer all these foreign
question what is difference type eternal
category value type reference 1.0
relevance iterator BTW total offense
type can be implementation defined but
should be at least as large as PTR gt40
auto category in the same category as
the category of the turtle you pass to
and the difficult ones are what are the
value type the reference and the pointer
type here to answer this question i this
figure summarize the main tools we have
in the booth library so we have a bt
turtle as i said that can with an
operator like telephones and bracket and
this super toe will give you a bit
reference that's the reference type of
same thing for bit pointer same thing
for bit pointer and if you execute the
bracket operator on beat poetry gives
you a bit reference but sometimes we
also need to deal with bit value that
are not reference in the unsigned
integer but which are independent this
is why we have also a bit value and then
we have three help helper thing
0 bit and 1 bit which are just a bit
value that are constructs per and the
financier on one
and binary digits that in most cases
return the miracle numeric limits of
unsigned integer number bit but if user
want to to to provide a template
specialization for that then the they
can only specialize a specification
provide a specialization for by your
ears and not affect the numeric limits
digits there are good value they are
declared as bit value so now I will I
will go to some tricky details so when
we started this to think about this we
wondered what is a bit this is an
innocent question that it's actually
very complex to answer related question
are what functionality is a bit should
provide and what should there what
should be the arithmetic behavior a bit
for example we see as I already said in
bit set and vector boom a bit is defined
almost as a boolean value but it leads
as it's only almost it leads to some
problems but number with the bitwise not
and operators with assignment operators
with also plus a quality and
completeness in the subtle you it's
actually a mess because if we compare
the results the behavior of a boolean
a bit set reference and a bit field it
leads to different results for some
operations some of them don't even
compile where it's the line where I put
X but and some for some operation the
results is not the same so already in
the sold out we don't have a clear
agreement and what
according to the system down a bit is a
unit of data storage in the execution
environment largely not large enough to
hold an object that may have one of two
values a correct to the surplus press
turned out a bit is an element of a
contiguous segments from forming a byte
by being the fundamental storage unit in
the C++ memory model and being at least
a bit low which means that you have you
can have more than eight bits in a byte
and some weird architecture if we look
to Wikipedia for a total give a
mathematical definition the bit stands
for binary digits a digits being a
numeric symbol used in combination to
open numbers in a positional numeral
number if we look through a boolean data
type a boolean data type is a data type
having two values usually denoted as
true and false Ethernet to represent the
truth values of logic and boolean
algebra so there are bits
rule doesn't seem exactly the same I
think one of the key ID to to try to
implement something that is working and
not misleading with a clear behavior be
that it is binary digit a boolean is a
logical data type but to be a bit is not
a ball they are often either identified
because they just both happened to have
two values but the logic behind it is
different and if bit if you are not
convinced is bitten bull were the same
we would not have the problem we have
with Victor bull and an array of bull
and M should be the same as a bit set
solve the case so now I will solve the
question about what the types nested in
which theater should be so the value
type of btro is a bit value it
represents an individual bit and we know
value because it mimics the behavior of
a bit but it's not actually a bit in
memory since bit cannot be represented
in the world so it's stored in another
way if I don't purchase it just a
wrapper around the Guru the make
function it is that you can take an
unsigned integer on a bit position you
can construct from that value there is
no arithmetic behavior to avoid any kind
of collusion of of confusion this is the
same approach that is currently studied
for a CD byte you have bitwise operators
you have a flip set and recent members
and if you want you have an ex PC
conversion to pool and here are
illustrated some of these functions so
here we take the first the bit at
position one in three we flip this bit
just reduced rate that we can use the
flip function and then we set the bit
value to the their worth bits of one we
set it to one and if we print this value
so we we came to the committee with two
different proposition one with with an
arithmetic behavior and the other one
without and we ask the committee what we
liked more the thing in the mathematical
definition it's a numeric symbol it's
not an actual number
it's an American symbol and to avoid any
any kind of forum we already have with
poor with arithmetic a ball they decided
we prefer to restrict the I admit
behavior so we don't have a new kind of
weird conversion happening because and
in most cases in most cases except if
you implement sure
your own bit manipulation algorithm you
won't have to read it value we need it
because you need it for to make a btro
that is what design but in most cases
you won't do weird things with values
then for bit preference we have for the
type reference in Wichita we have a bit
reference which acts the same way except
this time it takes a reference to an
unsigned integer and opposite position
we already the operator and to return a
bit pointer and it has an address and a
position that gives you that can tell
you what it gives you an access to the
underlying representation so in that
program we declare an unsigned int at
four we creates a reference to the third
bit of this and sign integer we flip it
and then we we prints the result so the
result of so now the the reference bit
is set to one if we print the position
of the beat it will print three and if
we print the if we access the underlying
integer because we set the bit to the
third bit it's now 12 and finally a bit
pointer which is compliment from play
material bit reference it we mix a
pointer to this this time it takes a
pointer to an unsigned integer and a bit
position for construction and we
override the opener to star to return a
bit reference so they are very
complementary so for example if we
declare an array of two and sign integer
and we declare two pointers one the
first one I made a mistake the first one
is on the birth bit number three of the
first element the second one is unbeaten
umber eight of the of the element 1 of
the array then we flip the first one the
first bit
and if we print it it leads to the same
result as in the slide before as with
get your fans
same thing for position and rest if you
compute the distance in bits because you
have to to your two unsigned integer are
in the same array it gives you the
distance in bits between the two the two
bit pointer which is in that case and
finally we have the binary digit
structure helper which is just it
inherit from integral constant it tells
you how many bits you have unscented row
or in a user defined type if the user
defined it and as I said the bt turtle
combines all of that to bring
capabilities bit manipulation leave user
with the opportunity to any play bits
either from a high-level point of view
or from a low level as I showed in the
general design the operator operator
star of a bit chatter word sounds a bit
reference and you have the base and
position numbers that gives you an
access to the underlying sequence so
this is the example I showed I think I'm
the first in the first of second side so
when you declare here you declare a list
of unsigned integer you create first and
last data and then you can count the
bits in between the adventage of the
flume it's easy to use generic and
efficient it's very generic because it
allows you to reinterpret any kind of
sequence of unsigned integer as a
sequence of bits they are they were
overhead with menus out o - and - all
three most compilers compilers are about
the abstraction away and it has very
good integration with the existing last
on the library it's like it's an ETL
adapter as velocity so the interface
allows you to interact in the same way
with as you do with stand out the eto
with Sandow algorithm so now I will see
I will speak about some benchmarks we
need first I would like to say that over
Finland made a great article about this
kind of bit manipulation to the 12 it
was already mentioning something we a
lot of think that we are scrubbing here
at the big library the web page be
tweeting hugs is really really useful
when you want to item when you want to
optimize a bit manipulation and the
implementation of rivers I will so was
done with a student Miguel Kumar at the
University of so if we compare for
several algorithms that we optimize with
our interface compared to what GCC can
do in Victorville we have the form in
comparison so the x-axis you have
different algorithm and on the y axis
you have the average computing time per
bit in seconds and the scale is
logarithmic on the top you have the
speed ups and we do that we do average
for several computation of 100 million
bits and it was an i7 to 630 it was so
the kind of performance we can obtain
are very very good in most cases we have
several orders of magnitude of
improvements for example with pop guns
with count as you can't we have almost
100
with cookie we have 522 with salt we
have more than 3000 go searching when we
when you know that you have only two
values you can just count the values and
we place than the lying values of in
unsigned integer by the number of zero
and when you up the tricky behind all of
that is instead of approaching a beat
and each time a penny and a single bit
is that you can operate on 64 bits at a
time because most of the time you have
compiled entries in precincts and
assembly in functioned as some neat
function to do that and if we plot it in
an unmarked scale you end up with
something like this we don't even see
the widget or performance in that plot
so these criminal benchmarks we are done
with align bits and we are now working
implementing the algorithm for
non-aligned bits so when your bit
position when you're busy Turturro does
not start at at the first at the LSB and
neither your first and last at or
archive spiritually significant bit and
here an example of the implementation of
STD worse it's it's kind of tricky so I
will just describe it in a general
manner and if you want to look at it
it's in the just download the library or
look at the slides and they will be
available and you will see how it's done
so basically we are we want to reverse a
sequence of of bits so when bt titles
corresponds to less be both first and
last then it's easy because the thing
you can do is you can just reverse the
interior of the underlying unsigned
integer first and then you reverse
the bits within each integer so what we
do is we call the reverse algorithm the
standard one on the underlying sequence
of an integer and then we call bit swap
each element the implementation of bit
swap is tricky but if you want to look
at it it's in the inter library then
when we have true when the Twitter toes
are referring to different integer under
an integer at least one of them is not
corresponding to our least significant
bit so I won't go into detail but what
we do is we start by reversing the whole
sequence and then first we save the
values of the first and last material
then we reverse the whole underlying
sequence we shift it then by a given
number of of bits if necessary so either
to the left or to the right then we beat
swap every element in the other line in
sequence and then we replace the first
and the last element by the bits by the
value we saved so we mixed the bits of
the value we saved and the bits that we
inherit from reversing the sequence and
then the last case is where is when the
B teacher shows belong to the same
underlying value in that case we this
function does a mix of bits according to
a mask and it's actually very efficient
so if we study the performance of this
new version of reverse so it works on
all kind of seconds not only LSB which
were still working on adapting the other
algorithm at the survivor
and in that new version the row level
function like big swap have been
improved thanks to the beat tweeting
hacks using compiler entry 6
and using template metaprogramming so in
the first version we had 31 performance
improvement and with this version with
this new version we have 86 reference
improvement compared to the Cobo so in
summary the interface of vector bool is
broken and the one of bit set is
regulated bTW territory is a good way to
combine the ease of use generosity and
performance and in terms of performance
as we have seen if you implement the
algorithm to you the compiler on 3:6 you
can have several orders of magnitude we
have seen also that abstracting bits is
not an easy task and we asked several
time the committee there are advise some
question for example where should the
i50 behavior it should be the big
library is a still work-in-progress so
we are now working on either side and
specialization of most algorithm and
there are still some work that is
ongoing and pin value and dereference
because there are some open questions
for Standardization the library is
available online if I want to test
benchmark share and not so you are
welcome to test it rather to
standardization the proposal and wording
the number of the proposal and warning
is p0 237 it has been submitted several
times the feedback is pretty good there
are still some issues that will need to
be solved but we hope that this digital
adapter will end up in the summer
library for c++ next at least that's
what we hope regarding to open question
two of them are particularly tricky I
would say what first one is someone in
the last coverage meeting someone asked
whether bit value
to be a template class so that we can
implicitly convert reference to bit
value to beat references the situation
about that is stealing that very clear
but we are we are trying to see whether
it's it will be a good decision on that
second question is far more tricky I
spend however thinking of that and I
don't have the solution so top plate and
CV qualifiers do not combine very well
for proxy classes such as bit
abstraction so if you declare a bit
reference on the cost T there is no
problem it's a conference and behaves as
stalled-out constant reference but when
you have both down plate and CV
qualifiers we can declare something like
a cost bit value of a volatility or a
Const bit reference and immutable G what
should happen with these kind of things
particularly regarding to the corner
from between these types because now can
we convert like what happened if we if
we take a reference to a bit value that
is constant volatile it does what types
of reference as it did so if you have
any clear view on that problem please
come to me and contact me because now
the situation is not it's not very clear
in terms of future directions as I said
we will work on the stand algorithm we
are also working on
beetron proposals with that with the new
branch proposal so that our interface
with the new run follow after that we
will implement continued adapters to
interpret containers as static or
dynamic bit set so finally would be to
declare you would be able to declare a
vector of unsigned int and then treat
that as dynamic bit containers and after
that we may work on multi precision
integrated finally here are some people
we would like to
thank so those the drawings were stolen
from xkcd by randall munroe we are
thanking the CSS community for the back
we had for standardization and this work
was done in the tree library in the tree
building blocks library team which is in
the data science group of the Department
of astronomy of University of litter
robot shopping and our goal is to end up
with trees to optimize both a high
performance computing solution and big
data science and machine learning
algorithm that are based on three
countries thank you for your attention
so it will say it's a long term project
and what we want to do we are starting
to use that to implement as a class that
because that is called integral beat set
it's like a bit set but it also provides
arithmetic we behave I've made some kind
of arithmetic behavior multi precision
arithmetic and then with that we will be
able to build implicit trees that are
associative arrays of keys and values
and top of that then we will be able to
implement additive added chief-mate
refinement and we expect other
magnitudes of improvements in terms of
performance compared to the current
explicit trees I hope not I will
awkwardly want to stop using vector ball
and replace it by something different if
their code yeah yeah this dynamic bit
set is is perfect to replace vector wall
so the question is how will we address
the how will we address the the
conversion between reference to beat
value and Beach reference and for what
it on things like for it at all
specification so the answer to that is
the wrong proposal and particularly
there is something called there is a
proxy ETR tour proposal that wants to
give genic tools to deal with proxy ETR
tools and make people able to deal with
this kind of problems it's it gives so I
don't know this proposal by how but you
can specify what how does the value with
the value that the reference and value
and reference type are linked or
together
the question is whether we are targeting
the same are we targeting the ranch
proposal the answer to that is for now
it's an independent proposal but we
definitely want we have discussed things
so that we are sure that our interface
is compatible with the ranch proposals
so that as soon as we have ranchers we
will define beach ranchers and the
question is what what we will do about
concurrency concerning these these bit
utilities and how we will specify them
for now we are focusing and the single
faded version but we will start we are
working on providing specialist the
algorithm that are not which is further
but then we will work and the algorithm
that are multi-threaded and while we are
doing that we will realize what we need
so your question is about how to either
some direction with that library to deal
with interacting with two different
types of unsigned integer and to string
the beads so how do we deal with
segments of you haven't so are you
speaking of architecture that has
integer of 11 bits or are you storing
the 11 bits integer for example as an
array of unsigned char so to deal with
for example an 11 bit integer that is
stored at the 32 bit integer is it what
you would do is you would create you
would create an unsigned integer you
would create a class that is defined to
be an integer of 11 bits and in that you
will store your 32 bits long integer and
you and you will interpret thanks to be
T Delta your unsigned integer as an 11
bits integer yeah question
unmanned for now we so most of algorithm
are for each surface so the question is
can we treat can we deal right now with
architectures like arm the goal is to be
able to do it for now we'll focus on x86
and 64 architectures the thing that most
of the very efficient function like bits
like bit swap things things like that
like that we have a version that works
everywhere
on any architecture on some architecture
we have version of that function that
use intrinsics to make thing working an
arm we can take and using the increasing
set of arm we would just need to to I
guess to make these very fundamental
functions according to in 6's and arm
and that's it thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>