<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Jackie Kay &amp; Louise Poubel “C++ in Open Source Robotics&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Jackie Kay &amp; Louise Poubel “C++ in Open Source Robotics&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Jackie Kay &amp; Louise Poubel “C++ in Open Source Robotics&quot;</b></h2><h5 class="post__date">2015-10-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PXdQwFSJwQ8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for coming I'm Jackie this is
Louise we're from the open-source
robotics foundation we're going to
introduce organization and tell you all
about what we do and hopefully there'll
be some interesting sequel C++ tidbits
here but most we're going to talk about
how cool robotics is and how cool
robotic simulation is as you probably
already know sling work there we go so
OS RF or the OpenSocial products
foundation is a small nonprofit
dedicated to making the robot revolution
also open source we're 17 people who are
all pictured on this slide based in the
San Francisco Bay Area and we're mostly
software engineers and we work primarily
in C++ our two main projects are Ross or
robot operating system and gazebo which
is a physics emulator for robotics
research so I'm going to spend the first
half the talk introducing Ross and
Louise will talk about gazebo and we'll
take all of your questions at the end
although there's something unclear on a
slide you need clarification just raise
your hand so this is all you know
talking is boring so we'll watch some
cool robot videos for a while cool so
this video says five years of Ross but
actually Ross is an eight year old
project so it's three years old but
hopefully it'll give you some idea of
the kinds of robots that run our
software so Ross is a framework it's a
collection of a unified communication
protocol with a simple message interface
for passing messages between processes
but also between devices over ethernet
or Wi-Fi it's also a set of tools for
introspection orchestration for it's a
sea make based build tool chain for
coordinating many packages because
there's a lot of software that goes into
making a robot do a really cool stuff
it's also an ecosystem of high-level
packages thanks John it's an ecosystem
of high-level packages for motion
planning navigation computer vision
really complex research tasks that
roboticists need to solve and it's a
really awesome community of researchers
and
industry professionals who are trying to
do things with autonomous systems so
Thank You Tube is taking over this in
summary Ross is network plumbing tools
capabilities and an ecosystem I'm mostly
going to talk about the first two
aspects let's let's talk today but to
make that broad overview more concrete
here are some statistics it's you might
not most people at this conference might
not know about in a general software
engineering context but most people in
robotics have heard of it or using it
particularly in academia where open
source tools are really valuable my
favorite statistic on this slide is this
is Robonaut which is a robot made by
NASA that's currently running Ross on
the International Space Station it's the
farthest away from Earth that we've
gotten and this hopefully is you it's
kind of hard to see the text but this
green section is the percentage of C++
lines of code comments are ignored in
our code base so this is the desktop
full Debian package and it has basically
every all of the core things you need to
make a robot go and some stuff on top of
that so Python comes in a close second
and there's a lot of there's XML a mole
also see make and see so that's all you
know of in the same family that's why
we're here so I'm going to tell you all
the story of how a Ross message goes
from point to point so let's say you
have your laptop and you have a turtle
bot which is a one of the first robots
that was running our software and it
basically all it does is move with two
wheels and collect data and it's cool
Xbox Kinect so that you want to send
your on a write a program that makes the
robot move so you're writing in C++
because your C++ developer you make a
twist shared pointer to a shared pointer
to a twist message a twist is linear and
angular
velocity so this is a boost shared
pointer because we're in Ross one and
you do some other stuff to initialize
the this publisher and the Ross context
and you just call publish on your
message object it's very simple so
because you're publishing from your
laptop we're going to call it the
publisher node the message is going to
get serialized and published over this
topic which this D specify when you
construct the publisher object and it's
going to be sent over the internet into
the cloud for those of you who want more
details it's the TCP based transport
tcp/ip there's a layer called we called
TCP Ross that converts your C++ struct
into a message packet and goes down the
pipeline back over to this topic which
your turtlebot the subscriber is
listening on via TCP sockets oops
spoilers so message gets deserialized
you enter the subscriber call back and
then the turtle bot is running software
that was written by someone else
somewhere far away but it's available on
the Internet open source it enters the
callback and then it probably calls
really low-level motor drivers that were
written in C to interface with the
motors and make the thing move so yay
we've accomplished everything we need to
write really simple um so I've given you
a really high level overview of what
ross's and but in this talk I'm actually
going to focus on Ross to which is the
project that i work on primarily and
ross to is basically it's it's kind of
like the Python 2 to python 3 migration
effort it is a an API change and a a
major overhaul of the codebase to kind
of modernize this eight-year-old project
for a new era and for many different
areas and robotics that have developed
since the Ross project was initially
developed for academia so there's a
couple of capabilities we're focusing on
three major ones we want to be able to
run Ross natively on embedded systems
with minimal OS or no OS in a bare metal
situation we want to make Ross
configurable to run in real time I'm
going to focus a lot on that aspect of
Ross to today and we also want Ross to
be able to be performing in high traffic
situations with many robots and Kirk is
currently you know with a data protocol
built on TCP it's it tends to degrade in
a really low high traffic situation and
it's kind of hard to picture this but we
want to modernize the API to c++ 11
originally we relied a lot on boost for
things like shared pointers which is
exactly what the people at this
conference want us all to do this is
great so again going into a little more
detail instead of using TCP for
transport we're switching over to dds
which is kind of was originally designed
for Miss clicking the Internet of Things
and robotics and autonomous systems
there was actually another dds talk on
Monday which is really good we're also
planning to target with three major
operating systems pictured here rosslyn
really reliably only works on linux
there's pretty good support for OSX but
maybe not all features are there in
Windows it's like almost unheard of to
have Ross running on running on windows
again so we won't c plus plus 11 and
Python 3 but that's irrelevant to this
conference and we haven't done a lot of
work yet in roscoe and python currently
ross 2 is an alpha projector ok so frost
to is an alpha we made our first alpha
release last month so this is all kind
of presenting to you from a working
prototype that still has a long way to
go to give you an idea of the API
changes between Rosslyn and Ross to Ross
one is going to be on the left Russ two
is on the right and this is
a simple subscriber so you might not see
a lot of differences and that's actually
sort of intentional to ease the
migration effort but for our users but
they're also again major changes in what
we're exposing the first is a really
small thing but this bothered me there's
a typedef in Ross one for a boost shared
pointer here it's a shared pointer of a
const message and this was typed up to
just a plate a pointer so a shared
pointer was just a pointer and in Ross
to it's actually called a shared pointer
that really bothered me because it's
conflating coronation assured borders
which could lead to really mistakes so
in this line Ross on it argh cr-v
listener we're initializing the Ross
context and we're passing the name of
the node remember our node in the
example was our laptop really it's a
process running on your laptop running
this code so you pass the name of the
node and you create a node handle which
is how you access the Ross context
basically in Ross to you callin it but
you don't pass the name of the node and
you create a node object with the name
so this basically you can have multiple
nodes in russ too and you couldn't in
ross 1 nodes mapped directly to
processes which is a big limitation if
you say make so you compile several
shared libraries with different nodes
and you want them to run in the same
process in one situation or maybe you
want to run them in different processes
this architecture gives you more freedom
the subscriber initialization is
conceptually really similar there's some
slight different contexts in tax but you
know we're using auto and we have to
specify the template here if we didn't
specify auto it you could you know it
needs to infer the type from this
template but mostly symp the same then
you call spin in this in Ross one spin
is essentially a blocking call where you
enter the event loop where you can
well once you're blocking and spin you
can receive the call back from the
subscriber which here is called chatter
call back in Ross too there's a similar
call that's just a spin without any
object pass to it or but there's an
alternative which is you can instantiate
an executor and so we're exposing the
executor to the user the executor is
just something that listens for all the
dds communication and gets the work
that's going to come in on the network
or via IPC execute it in a fashion
that's specified by the user so you can
specify a threading model which is also
different from Ross one and you can add
nodes arbitrarily add and remove nodes
to the executor and that the executor is
going to listen for work to be done by
that node or done for that node and then
it you call spin as a class function of
the executor so a more high-level
overview of the Ross to architecture
we're placing on time puts on this
hourglass pattern here we want users to
be able to write code in many different
languages and so we have different
client libraries which they're going to
access having the kind of API that you
saw on that last slide but these client
libraries the implementation in some
form and other I'll calls the unified
Ross middleware API which is this
abstract wrapper over the many dds
implementations so is anyone in this
room really familiar with dds cool so
there there are many different
implementations of BDS and none or maybe
one of them is actually open source um
there's an upcoming one that we're
actually supporting in this effort so
for someone who already has a dds
license they can use open splice maybe
new open source implementation of dds or
our TPS is here but those details are
all hidden to the user and actually to
the client library so I'm going to now
shift gears a little bit and talk about
aspects of rosty development that I find
really interesting and I hope you do too
so one thing I've worked
Don is real time support and Ross to
prototyping what that's going to look
like so who in this room knows exactly
what i mean when i see a real time
system raise your hand ok so that's like
most people but actually the the real
time low latency sg14 is happening like
right now so all the experts are
probably in that meeting up so including
like I mean not an expert but familiar
right so real-time computing essentially
you have deadlines you have to stick to
your deadlines if you don't stick to
your deadlines that's really bad that's
an error so you have some update right
here it's you know that line and you
have some acceptable error which is
often called your jitter so you can't
block for longer than the deadline plus
your error and if you go over it it's
often called overrun so let's say in
this loop you're getting data and you
block so long that the call where you
get the data is past your deadline then
that could be bad so in some cases you
throw an exception and you exit in other
cases maybe you just throw out that data
and ignore it even fancier you mighta
just like quality of service settings so
you get more data in the future but
that's that's essentially the definition
and you might ask why we care in
robotics but I think the question is
actually why don't we care real-time
reaction is really important when you're
reacting with the real world on a real
timeline so if you don't have real time
performance then your humanoid robot is
going to fall down on the steps and
break itself your autonomous satellite
is going to react poorly to some old
sensor data and it's going to maybe go
out of orbit and your autonomous car is
going to think the pedestrian that it
saw is no longer there or maybe not see
a pedestrian and then kill it so
roboticists really want real-time
computing and many of them don't have it
because many roboticists the researchers
who don't know how to write real time
safe code so in order to deliver Ross
to a framework all roboticists can use
that's real time safe all layers of this
stack must be configurable to be real
time safe maybe not Python maybe we can
just ignore that but the user code they
provide the client libraries we provide
the Ross mental wear API we provide the
DDS implementation someone else is
providing and the operating system
they're running their code on none of
those places can have a thread that
blocks past the deadline so how do we
achieve this well commonly people who
are familiar with real-time computing
probably know that when you that the
default heap allocator for basically any
platform is not real time safe you could
end up walking on deterministically
while you're waiting for our you're
looking for a free block of memory or
maybe let's say you're looking for a
free block of memory because you're
allocating on the heap and you have to
go to main memory because you're
swapping out memory that's in RAM and
that could take a really long time and
that means you could miss a deadline if
you call new or again if you're
returning memory then that's also
incurring the same costs so I looked a
little bit at how we're going to make
memory allocation real-time safe in Ross
to a lot of people in real-time
computing say you can have kind of this
stage where you pre that's that's not
real time safe and then you have your
critical section where you're you know
running that update loop that's on a
regular deadline and that has to be
real-time safe then there once you exit
that loop UD allocate the memory like a
responsible person and you have your you
know non real-time safe clean up section
down here so I map that to executor spin
as the real-time safe section you enter
this update loop you're just going and
going getting jobs you need to do and at
the end you clean up all the memory that
you allocated at the start analogous to
our example where we created the
subscriber and the note handle and all
that so this is kind of going into a
little more d
tale of what spin is going to look like
it spritz really straightforward we have
this arm w-wait call an armed w
middleware interface we're to
dds dds is actually going to take care
of walking for us because dds claims to
be real-time safe the specification so
we'll just rely on that we're going to
create a dds weight set we're going to
you know make that block until work
comes in on the network if there's work
available will wake up even if work is
not available will wake up when there's
a timeout so we can you know get our
deadlines and tell the user no data came
in so one thing here is when we tried to
pre-allocate all the memory there are
you need to allocate for the
representation of work that's going to
come in after you wait you don't know
what work is going to come in so you
need to dynamically allocate that and in
the initial implementation of this yeah
we dynamically allocated Oh a
subscription comes in we have the
representation of that with the metadata
the job that needs to be done Oh a
client came in client call back we've
similar thing for that but we we can't
we can't we just can't call new in this
context so I prototyped this
architecture basically where we have
different kinds of memory strategies and
you pass that to the constructor of the
executor so by default when we need to
create a handle to this representation
of the object in our CL CPP after we
wait we held you just call new malloc
and free here new and delete not the
same thing but heap allocation if we're
in a real-time safe situation you can
pass a different memory strategy which
inherits from the same base classes this
which refers to pre allocated memory
pools so the executor code is all the
same general dependency injection it's
great but you might ask why don't we
just use this because it's more
real-time safe why do we have to worry
about this whole scheme flowchart crazy
well
draw back here is that you need to know
in advance the maximum number of those
executables that I said before you
allocate this memory in the constructor
so it's nice about this because it's
dynamic you know you just say knew like
five subscribers knew whatever
subscribers it's great but here if you
go over you know five subscribers
whatever your maximum number is you
throw an exception because you don't
have enough memory to store those
subscribers so you know there's benefits
and drawbacks of both and one of the
challenges making this framework is
meeting the needs of users who want more
simplicity users you want more
configurability but I think this works
pretty well so but doesn't really work
pretty well i don't know let's do some
benchmarking so i set up an example
where so it's very simple inverted
pendulum simulator an inverted pendulum
is just a mass on a stick that has a
motor at the bottom and the motor is
trying to balance the mass that's
swinging on a stick so it's all in
simulation though and this is kind of
the software topology of the nodes that
are involved in this simulation we
actually have one process that is a
simulator creating the physics data and
then commit it's also simulating a
sensor on the motor and its publishing
to a controller so in a real situation
the controller might be a computer
actually that's running controller code
like a microprocessor the simulator node
this might actually just be a sensor
node and these might be connected via
ethernet on your board on like a you
know a robot that's running here so it
publishes sensor data and it also sends
a command and here it just sends it to
the simulator so the simulator can move
the pendulum and then we have non
real-time processes that are doing non
to real-time safe actions like logging
data that's being published out of the
controller in a file and printing it to
the screen and we also have in a non
real-time process that publishes to the
simulator by basically taking key input
saying you know
what is the theta I want to command on
this pendulum so some other really
technical details the default Linux
schedulers not real time safe so I used
RT preamps because a allows for full
preemption of the scheduler I used P
threads because the C++ 11 thread
interface doesn't expose thread priority
with Ron robin scheduler but FIFO i
think is also a valid option this is
actually deprecated now Malik hook but
basically it's it's a way to write your
own custom Malik right so I wrote a
custom Malik that just said hey your
mouth looking and if it was after
calling spin then my test failed luckily
that didn't happen and also get our
usage counts page faults which are page
faults are bad for real time I'm not
going to go into too much detail again
here if endings that wants to know more
about page faults just ask me and so the
goal this is kind of a gold standard in
robotics is a 1 kilohertz update loop
and that's basically if your computer is
updating every millisecond you're
basically running faster than your
motors can react so that's really good
because your motors can't react faster
than you are and do something unexpected
that you don't know about and we want a
pretty small margin of error 3% again is
you know I don't know who comes up with
these numbers but it's it's a it's a
gold standard that roboticists use so
the results look pretty good I run the
example for a little over two hours and
the average is very far below what we
wanted so that this percentage column is
probably more useful to you the average
is very far below are like this this by
the way is is jitter not like the amount
of time it took in the update loop so
this is like the error here very low
error but our maximum jitter is actually
a little bit over three percent but you
know five point five percent and our
minimum is again very low but our
histogram here shows the
it's kind of a bimodal distribution like
the the error that usually the data that
usually came in and it's very very low
but we also have you can't see in this
plot but you know we go over it around
35,000 nanoseconds or thirty five
microseconds and this is marking our
maximum allowable computer if we want to
stick by real-time requirements so yeah
in conclusion I think this is a really
good start I learned a lot by setting up
this prototype but we've got a really
long way to go especially because
there's features like client-server
communication which I didn't really talk
about that are not real time safe right
now and you just block they use standard
features it's like great there's i'm not
using standard allocator anywhere which
i think is the next step for creating
real time safe memory allocation for
standard library structures by providing
a pre-allocated pool to vector and map
instead of just like calling you and
they resize which is what they do by
default and also I you know lock free
programming I went to some cool talks
about this at this conference maybe I'll
prototype them I don't know uh yeah so a
real-time performance is actually really
important on microcontrollers which are
cool I'm not going to talk much about
microcontrollers sorry but maybe in a
year I'll know a lot more about them so
but they're also all these desktop
platforms we're trying to support and
I'm really happy to report that we have
stable CI jobs for all three of these we
and you know we could always improve our
test coverage but it's cool we can prove
that Ross to does actually work on
windows unlike Ross one but there are a
couple of caveats to that actually the
Ross team @ OS RF is a very Linux
focused group we're all linux developers
by training and so when we you know
venturing into Windows development was
really an adventure for us because there
are some things that visual Studios
doesn't like visual Studios 2015 doesn't
like that clang and VCC you really don't
have a problem with and don't even warn
you about so I don't know what's up with
that so I'm going to just give an
example of that
so we wanted to do this and this is
essentially we're creating a service
that's another communication primitive
and Ross and it has it it has a function
callback a function point of that you
pass to it and a name that's less
important and the function has type
request and response those are messages
well there's another option though you
can have a name and a call back that
takes a request ID that's kind of its
metadata you don't need to worry about
too much what it is but it's it's a
struct and then their request message
and the response message so we had these
two template types and we say no
instantiate we implemented them but
calling the function compiled on these
two platforms but not windows that seems
weird I basically said this call is
ambiguous so we would think the compiler
would be able to resolve the template
overload because the it's given a
request message and a response message
it's clear that it's this implementation
of the template or this declaration of
the template not this one it turns out
the standard function implementation on
windows 25 visual studios it's greedy
and it basically just goes with the
first template declaration rather than
over like over letting these two which
it's an incomplete implementation of the
spec so we we had a workaround with more
insane template stuff I know this stuff
is crazy and this is this is actually
just a small very small excerpt of it so
we basically have standard enable if
that says only compile this function or
only make this overload this template if
the arguments have the right type so the
the you know we have functioned traits
and the argument is going to be response
and we had one for you no argument 0
should be the header argument one should
be the request or coming to should be
the response let me add another one that
was just like this with the other
function signature this is kind of crazy
yeah
this also didn't compile on Windows it
compiled on OSX and Linux but not
windows so you know our work around
totally didn't work I throw up our hands
turns out we did some research actually
luckily I was the one who is working on
this with someone else on my team who I
feel really bad for it and you know this
is the link to the blog post explaining
yes expression substitution failure is
not an error which is what I've been
demonstrating here not overloading
template types is not fully implemented
in windows so we ended up doing this
static assert still you know pretty good
you can catch this a compile-time which
is good but it's it's less efficient
because rather we we get to the static
sir and we're we're not skipping over
the function at compile time okay so
that was kind of crazy but that that was
the the the deep dive into ross to
technical details so you know this wraps
up the ross portion of the talk you now
know everything you need to write robot
software right you can just go online
and download our software for free it's
really great uh but you need this you
need a robot and robots that are
interesting with arms and sensors are
really really expensive and so unless
you're at a company that can just afford
to buy you one or you're at a research
lab that does robotics then you probably
need an alternative and so why not try a
free simulation cool so I'm going to
talk about a robotic simulator where you
can do this kind of stuff called gazebo
it's also maintained by the open-source
robotics foundation let's show you some
videos about what gazebo can do so you
can simulate a wide variety of robots as
you're gonna see here in this video and
the question is well why would you need
a robotic simulator besides the fact
that you might not have the robot well
even if you have the robot you might
want to just try things in simulator
because in simulation because it's
faster you can iterate faster you can
try to
different algorithms that if you put in
the real robot it might break it or it
might be too troublesome to go and turn
on the robot and if it falls you have to
put it back up so you can do go through
these things and simulation and do
research on your new algorithms very
much faster if you're simulating it
another reason to use simulation is for
prototyping you don't have a robot yet
and you're thinking about it you do any
simulation to get a little bit and then
you go for the physical prototypes after
doing simulator prototypes and
simulators are also widely using
competition so it's good to have a
controlled environment for all the
competitors and some of the things here
are from actually the DARPA Robotics
Challenge which was a big robotics
competition that happened along three
years and just ended this year and the
first stage of the competition was to
compete inside simulation and gazebo was
the official simulator for that so all
the teams had to compete against each
other just with their algorithms they
didn't need to have the robot everybody
was using the same robot inside
simulation and the best teams were
actually paid they received a robot in
the end to compete in the real world
like physical reality competition I you
can see that gazebo has a lot of
features you can interact with hardware
and things like this so that's a little
intro to gazebo let's check out some
stats so right now we're on version 6
but actually gazebo is like quite old
it's being around since 2002 so it's
like 13 14 years old right now and we
have right now about one thousand
dollars a month the lot of lines of code
over 250k a lot of comments to function
coverage is not as good as we would want
and this is something we're working on
improving right now to make it more
robust and we have about sixty plus
contributors from all around the world
contributing back to cos e book just for
you to ahhhh what's spoilers no so what
what's involved in a robotic simulator
you can see that there is a lot going on
they're most people look at simulators
and they think it's just a video game
with crappy graphics very good physics
and it's basically that but but so here
is like some of the dependencies we have
so these four here open dynamics engine
bullet dart and sim body are the four
physics engines that we support in
gazebo so you can change that in runtime
you can choose if your simulation is
more about soft bodies you might want to
use one of them if it's if you need some
features from different physics engines
you can change that in runtime so it all
comes where you have to compile gazebo
with with them and then you can just use
them for a rendering we use ogre and the
rendering is not only used for you to
see your robot doing things but also to
generate sensor data so the robot has
cameras in it and you have to generate
the Kent division for that camera we use
ogre for that too we use cute for the
graphical interface we're still using
cute for we have in transition 25 yet we
use protobuf for the message passing
between processes for the message
description we use boost for a bunch of
things so as you can see gazebos a quite
old project and we're adapting to new
technologies slowly we are since gazebo
5 you can use C++ 11 but we haven't
we're not making this up all the
features of C++ 11 yet so both shared
pointers is something for example that
we still use but we are adapting little
by little as the format is the XML
format that we use to describe the world
so everything that the user wants to
have in their Road in simulator in the
simulation is described in XML so you
have like a road tag you have text for
robot models for all the physical
properties for the visual description of
the robot so everything is described in
the SD format and ignition is a project
that we're starting to break gazebo
apart so gazebo has a lot of libraries
inside itself and it's becoming a very
big project so we are trying to take
things out for example our math library
we're separating it out of gazebo murmur
making it into a ignition library and
just to make gazebo itself a little bit
lighter so
I thought I would talk about plugins
today because you can see some of the
C++ code that users can have to write to
interact with the simulation that's the
way that you control your robots you
control your worlds inside the
simulation it's all writing C++ code and
I thought it would be fun to make a
plug-in to explain the plugins so let's
go into gazebo and hope everything goes
okay it's sort of a demo / presentation
see okay we're inside gazebo this is our
simulated world here usually it would be
much more interesting if you're doing
some robotics stuff like you will have
some fancy robots in there but right now
I just like put some lights there first
to look at them so let's start with the
plugins plugins are the way that users
interact with the simulated mission they
have to write C++ code and another way
that users can interact with the
simulation is through Ross actually you
can but that is done by plugins in the
back end but for many users who are
using a Z but they are just writing Ross
code and that's the same code that runs
in there be a robot and in the simulator
robot and many times they might be
writing that in MATLAB or Python or
whatever they want but the bridge is
done in C++ so let's take a look at our
plug-in structure in the architecture in
a Zeebo so we offer a C++ API for users
and which is basically our whole code
base so it's very flexible you can do
pretty much anything inside the
simulation but it's also very dangerous
because you can break a zebra and it's
it's being done like this historically
because originally gazebo was widely
used by research researchers who were
very tech savvy they knew what they were
doing and they wanted to have full
control they would even write their own
simulator if they had the time but they
were using gazebo for convenience so
they wanted the freedom and they have
the freedom to do whatever they want
with the simulation but more and more
gazebos being used by people who don't
know
to write C++ code so well like
mechanical engineers like myself or like
high school students so we are trying to
make the API easier and the entry points
into gazebo simpler and more straight to
the point for people who don't want to
deal with all the details of the
simulation so we're offering the C++ API
which I'm going to talk about it's also
worth pointing out that since it's the
whole code base user code is very
similar to developer code so in a way
it's very easy for you to go from a user
to a gazebo developer because you kind
of know the API and you're like oh I
want to fix this in gazebo and you're
just like okay let's make a pull request
to the original application so the way
that users have to compile their code
into a shared library and there are a
few ways that they can refer they can
refer to that library inside gazebo
Fergus able to find it so you can either
use the SDF the xml formats that i
talked about earlier there is a plug-in
tag you just put the name of your shared
library there the iso file and because
he was going to find it for you you can
also just do it by it by the command
line there's an argument and for glee
plugins for example you can put it in a
GUI dot ini file which is going to be
loaded every time you open gazebo so if
you want to add your own buttons and
stuff i'm going to talk about each
specific plug-in in more detail later so
you just forget about to find the
plug-in that you referenced by the file
name you just have to set this
environment variable called gazebo
plugin path and that's pretty much it it
might be simple for it is or for this
audience but for people coming from
mechanics and all it's like what's an
environment variable why do I have to do
this so it's it's as simple as we have
made it so far and we're trying to make
it even simpler for people so the we
offer a wide variety of plug-in types
that you can write and I'm going to talk
about them later but they all have a
very similar structure which is there is
a load method that you have
to override and that's your entry point
and from there you can add your
callbacks you can do whatever else you
want but they have this thing in common
which is the load method there's also
like a couple of other methods like in
it and reset that you can also overload
if you want some different behavior but
load is the bare minimum that you need
any way that plugins communicate with
the main application and with each other
is by shared pointers so they can have
access to shared pointers by via the
load method they receive some shared
pointers and there are some also some
global functions that you can access
some of these pointers you can use
events for communication inside the same
process and messages for inter process
communication between plugins and the
simulation so this is an example of a
base class this is the model plug-in
base class and but all of the plug-in
base classes have very similar structure
so you can see it's very simple just the
model plug in here there's a constructor
destructor and the load method which is
pure virtual and you receive a model
pointer which is a shared pointer both
shared pointer and you receive an SDF
pointer the model pointer gives you
access to the mall when we say modeling
angle Zeebo we're referring to the robot
the robot is a model which is a
collection of links and joints all in
one so that unity that makes up a like
something like a robot or a table they
are both robot models and SDF is how
you're going to pass in parameters to
this plug-in so remember I said the
plug-in there is a tag in X in XML that
you can specify the plug-in you can also
specify tags inside that tag and you
receive all that structure here so you
can deal with it in your load method in
any way you want so you don't need to
compile to change the input and there is
this a very helpful macro to just
register the plug-in with the simulator
so this in the back end calls dl load
and dynamically links that the library
with the simulator but the user only
sees this and just cause this changing
here the type of plug in this case is
also a model plugin
so these are the plug-in types will
offer right now I'm going to go over
this list very quickly and why you would
want to use each one of them a road
plug-in is sort of a God's view so you
have access to all the model pointers in
the world all the lights you have access
to the physics engine so you would if
you want to change the physics engine
dynamically you would want a model
whirlpool again if you want to measure
how two robots are close to each other
you would want to roll plug-in because
we have access to both of them so that's
a roll again a model plug-in is more
something inside the robot or any other
model so you can use it for example for
a joint controller so you have access to
the pointers of all the links in the
robot and all the joints are also for
physical phenomena for example we gazebo
comes with a lot of plugins that you can
use like pre-made plugins and one of the
model plugins we offer is a lift drag
plugin in the videos you saw a airplane
flying and that's running a model plugin
that is applying forces to the plane
according to its velocity and all so
that's all done with a plug-in it's not
even in the physics engine like the
physics engine is running it back end
but you call the physics engine like
apply force to this and then it takes
care of the rest sensor plugins are for
example you have a camera sensor and you
want to filter that data or modify it
somehow so you would have a sensor plug
in visual plugins are for like the
rendering part so you can have dynamic
textures and interact with everything
that you're seeing system plugins are
the ones they're the most powerful they
are loaded even before gazebos loaded
they have access to the command line
arguments so they can modify anything
that is going to come afterwards so this
is like for the experts for people who
really know what they're doing and they
really want to have full control they
would use this and GUI is I'm running a
great plugin right now right now I'm
running to plugins in this in the
simulation one is the great plug-in that
I'm using to get key events and pass the
slides and the other one I don't know if
you saw a drone flying around that's a
model plug-in and I'm going to explain
these two plugins for you now so first
one let's look at their mother plug-in
that is running in the draw
I try to keep the physics to a minimum I
think people in this conference are not
very interested in the physical details
of what's going on so I just kind of
cheated the physics and I made an
animation with the drone that is flying
around so I it's just very simple i'm
setting keyframes i have a list of both
positions in the world that the drone
has to go to i passed that as an in the
xml and the plug-in just loads that xml
creates animation and runs in the inner
loop so i try to keep the example in one
slide i think i was able to fit it so if
we start with registering the model
plugin up there then we supplies the
model plug in class we're calling this
day animate model and then this is the
load method we're receiving the model
pointer which is a pointer to the the
other i did dr. and we receive it SDF
which which is loading that world file
with the older post poses that we want
for the drone so here we start going
through that file and generating a
keyframe here for each one of those
poses and in the end we just set the
animation for the model since I said
this here to true it's going to loop
forever so that's it this is a very
simple you probably wouldn't want to use
too much animation in your real
simulations because that's cheating the
drone is like not gonna respect physics
at all if wind comes it's not going to
affect it so this is just an example of
how simple the code can be for the users
and this is the great plugin that is
running it's a little bit more involved
they couldn't fit everything in one
slide they commented something some
stuff out but it's basically the plug-in
that I'm running to control the keys and
move the camera phones light to the
other so in the same way we registered
but this time it's AG we plug in and I
in the constructor initializes some cute
element which is just this tiny box here
with the number of slides where we are
you can usually in the normal
application you would like put buttons
to control your robot to tell your
parade you would do yeah you can plot
you can do whatever you want then we
override the load method
and here we just received the SDF
pointer there is no other point too
involved anyway you can get everything
from like the main window for example
you can get it with a global function if
you want then we go through i commented
out some code just left here that you're
taking again the poses from the SDF so
you're making a list of all the key
points for the camera that you want and
I just said that that all in the xml
file we also keep a pointer to the
camera so you can see here that i use
the global function to just get that so
that's the user camera and then here i
just create a callback on keypress so
every time you press a key the camera
it's going to call this and then we
check which key was and then we're also
keeping track of an index of which slide
we're at and just move the camera to
that position so it's quite simple and
just to finalize I want to show you the
load for the system plugin which is a
really powerful one and you can see that
you can have access directly to the
command line arguments before gazebo and
yeah that's pretty much it thank you for
your attention if you want to get
involved there's a bunch of links there
mmm we're open to questions the question
was what is our source of funding uh
thanks for asking we're mostly funded by
grants and contracts so we get a lot of
funding from darpa NSF nasa government
organizations we also have some
contracts with larger companies like
Google Bosch Qualcomm yeah and we do
take donations but that's not a large
source over funding
haha I wish well you could totally do it
and wait some time to make some demos
like we a few months ago for the DARPA
Robotics Challenge finals we've made a
demo where you can use the oculus rift
and some like control is kind of like
the wiimote reason so yeah they called
the razer hydra to play football inside
gazebo so you had two people playing
against each other so you could
definitely do something like this like I
said the graphics or you know not really
competitive and in video games you
usually don't want really real physics
but you can do it no other questions
great question uh yeah the Ross is not
very well secured I'll be honest with
you it is it is another goal for us to
to like add an encryption layer for
messages like a user interface for
encryption but it's it's very easy if
you're on a network to search for you
know the IP address of the robot like
sniffing packets the the standard port
for Ross communications is like everyone
uses the same port so it's all it's all
very open yeah and we like to you know
emphasize to people that open source
doesn't necessarily mean insecure in
fact many high security like many many
of the great security libraries like SSL
are open source and I think that's an
advantage to these projects but Ross is
not an example of like a super high
security project
yeah I think I think it's not a built-in
part of a spec but there are some
vendors who build it like secure dds and
you know that it's so usually a layer
right on top yeah I'm just playing sorry
any other questions yeah I believe so
there's actually a funny problem we ran
into with RTI connect where their old
version didn't support messages with
arrays larger than 255 which was a
really big limitation when I was trying
to destress testing but that their
they've improved that now as well
actually but yeah that's about a
completely different vendors yes
standard functional helped us a lot we
do a lot with passing callback pointers
and creating lambdas is really nice for
user code although one of my co worker
says like lambdas are horrible for
testing if you want a unit test
something that you make in a lambda like
you can't sew or it's not a great
interface but I'm a big fan of that one
one feature that I would really like to
see is more support for real time now
that I have had some experience with
that a lot of structure is in the
standard library are not great for real
time low latency lock free performance
but luckily there's an S key for that
nice in gazebo um yes yes actually
there's a so real time factor in gazebo
means something different this is real
time factor for those of you can't see
and if you have a real time factor of
one it means the physics clock is synced
up with like the real world clock like
your physics is running as fast as real
life is and right now the real time
factor is like point nine ish so Michael
good is not good yeah if you're running
this on a beefy desktop this world would
probably be a one well simulation like
as long as you don't want it to run in
real time for you but you can run the
simulation like leave it there for these
12 hours and then come back and see the
results so usually you don't it's not oh
I know I actually haven't you can email
me later with more information about saw
them okay any other questions cool thank
you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>