<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Jens Weller “An Overview on Encryption in C++&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Jens Weller “An Overview on Encryption in C++&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Jens Weller “An Overview on Encryption in C++&quot;</b></h2><h5 class="post__date">2015-10-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OBpX6R_lEnY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to my talk on encryption
that's why you're running a little bit
later I'll just come quickly like it
yeah I'm running Metis the best person
to talk here so I would like to start
this talk with a short disclaimer I'm
not an expert on the description and
this talk is meant to be an overview and
so I'm gonna try to cover with the PP
botan and the sodium in this talk he'll
give you an overview how to use
encryption in your application that's
the whole goal of the talk and yeah what
did motivate me to do this talk I was
looking for a solution last fall and was
seeing that basically it was very hard
to find really good the trigger on it
there's a lot of libraries there
somebody's on encryption which are
having their own documentation is but
using a s or other encryption algorithm
turns out to be more difficult than it
should be and I was working through
getting myself into this field and then
I thought why not do a talk on it and
have other people to also have things
like an encryption easier to understand
and also what I found out last fall and
as I have been by some people told this
that basically there has never been any
overview on encryption on any conference
so I try to take this with this talk so
again I want to stress our that this is
an overview and so talking about using
encryption you're not about implementing
it so that's a hold of a different topic
and I think that most the the most
people which are good and implementing
are not good people which are good at
C++ so there is a very small share
between people which actually invent and
make encryption algorithms and people
which are writing batteries so most of
the libraries which I will show you or
actually all the other libraries I saw
are very
to see and the coated surface mature so
some of the libraries are now moving to
C++ 11 in the next version but in the
current version they're mostly based on
zebras also 3 and also there's an
ongoing discussion in the last half year
about encryption and the government's
want you to put across in the
application on to eatin encryption
algorithms and so yeah that's that's
non-going discussion on it could be that
you know some part of this talk are in a
few years may not really not so legal at
there today there's already legal
situations in the US or the FBI wants to
to have your keys and they also have the
legal situation that they have the
ability to get those but the problem was
back toss is currently visible and the
whole T as a keys affair that the it is
a key sneaked and basically all our
luggage is now opening by being open to
everybody as those keys are now
basically printable by everybody who has
a 3d printer and the TSA is not reacting
like oh we don't care that's not really
an affecting our sense it's not gonna
have an effect on a particular T we'll
see that later and on that point I also
want to point out that if you have if
you're working on a start-up and you
know you want to be trusted by the
security community you might sort of
think about having a cannery on your
website which you know it's updated once
a week and once your security model is
broken you keep you stop updating the
canary but that's actually again the
different topic as a field of security
and encryption is very broad I want to
point out that you as a developer our
target for governments services botnets
et cetera also because over you know
we're writing the software and software
it's a word so you have software
development software developers are
becoming an increasing important target
by not only services but also by
criminal
organizations so interesting data which
are no machines and also shared like in
the Internet of Things
I like things like passwords email
logins and also the hardware resources
once the machine is hacked you can mine
crypto coins on it or you can use it if
it's not strong enough to mine crypto
resources then it's good for doing an
dass attack so there has been a very
good talk on that topic on the -
deafness which are linked in the slides
but before I get them to the external
purpose of encryption I wanna also point
out that the attacker which were you
know try to crack your encryption or try
to crack your software lists in the
future but you write your code today and
even if you like have today better tools
like sanitizers and intelligent fathers
you always should have and when you're
writing security critical code in your
mind that your attacker probably has and
much more resources than you do and if
psycho lives in the future in a few
years they automatically gain more
resources as our technology advances and
no technology it matters even faster
than they did in the past so most noise
etc you know the the the the raw power
we have and machines where double each
like three years for the current time
probably like for ten years which brings
me to a very short update on encryption
topics which will play a key role in
this talk there is a symmetric
encryption where you have one key which
is used for encryption and decryption
and that is then for example a s the
symmetric encryption standard there's a
very very known algorithm for that then
there's an asymmetric method to encrypt
things where you have two keys a public
key and a private key and you shouldn't
share your private key and the public
key is basically available for everyone
and if somebody wants to send you a
message they can encrypt it was a public
key and was a private
it's only decrypted so for example RSA
is a very very known algorithm that
feared the algorithms themselves are
mostly in two big classes there is a
block cipher which always runs on a
block of memory like 512 bytes and then
there's a stream cipher which in advance
generates a key stream and operates on
this key stream and both both categories
have their own advantages and
disadvantages
spirit cipher can be computed in advance
the rocks are usually not and there's a
stream cipher you have the problem that
if method to generate your key is weak
your attackable from that and also I
want to I want to stress that HTTP
that's not really encryption HTTP is
only transport encryption it doesn't
work for example for UDP and the data
inside this encrypted pipe is not
encrypted so I have seen if you project
that managers thought if they apply
HTTPS it automatically every single
secure and they have encryption on their
pro-leg that is not that case which
brings me shortly to connect it filled
by passwords and how to store passwords
when when you have authentication of
course if you don't stored as plain text
that's a bad example and you should have
it correctly which is a whole different
topic so I'm not going to really go in
depth with that but one from I want to
also point out is that you have low
comes back to your data bases and two
other two is which you actually need to
store in some form that you can decrypt
them and have the password as the
plaintext to actually be able to lock on
to your database or something and so
there's a key question for mister how to
throw that in a correct manner if you
you know encrypt your key in a symmetric
way you have another key which you need
to store somewhere in a secure way the
same thing applies was a private key if
you do it a symmetric key and private
keys are often when they're saved on on
the
drive they're often encrypted with a
password so again have a password and
yeah plain text as an option if you
consider your machine secure you can
choose to mutate this plaintext to your
real passive original a little bit more
secure few operating systems offer AP is
and I know for example that pootie has a
daemon which allows you to store keys so
maybe on your platform X is something
like that so you shouldn't get up and
I'm still thinking on that from looking
forward as this feedback on the topic
I'm really interested in there which
brings me to the to the main topic of
this talk like how to do encryption and
C++ and the first the first news I have
for you is like unsigned char that's
that's that the great the great and only
language basically encryption speaks
every algorithm I have seen so far
mostly operates on unsigned char and we
do have those interfaces of passing an a
pointer to an array and length and
there's a seed like interfaces like
everywhere but most interfaces which
which we have in our own code like STD
string are either sign char or something
else so that interface actually makes
sense to to use as the as we usually
cast the data which we want to encrypt
to unsigned char and then have some part
in the memory which was educated before
it's actually being something else being
encrypted or decrypted and a short word
on the standard the standard has a
random header which some people think
it's safe to use for encryption and
that's actually not the case you can't
really trust random device which is
actually only thing which is on some
platform secure as with lips C++ and C++
and the problem here is for example if
you use the link W random device will
give you always the same numbers on the
on the windows so even even VCC doesn't
get that correct and so you if you need
random numbers like for keys or
initialization vectors like we will see
soon use the facilities of the library
which you're using and not the standard
or some other random source and the same
basically address with this random and
there are a few encryption libraries out
there and our just stretching
cryptography Bhutan and episode iam are
the three libraries which I have picked
two to cover everybody who has done any
work with SSL crypto the you know when
you work with it once you probably want
to avoid it afterwards so I have I have
implemented in ours a class was open SSL
crypto past a while ago but I did not
consider that fun and but I don't think
that it's a secure way to implement
crypto for a modern world and then there
is a cute architecture so if you use
cute there's an alternative they also
now running on cute for and if you'd
five but yeah I think if you really need
encryption you should use one of the
library's above so quick overview on
those crypto PP in its current version
uses C++ both three they're currently
working on in next version five six
three which will be based on C++ 11 and
licensed was cryptic he has a boost
class and so it's very much usable and
also Bolton has a BSD tube license which
is quite easy also the next version of
Bolton will feature C++ 11 and they're
already saying if you start to write new
code or a new project using photon you
should not use this table on C possible
so three track but you should use the
dev environment which they're offering
also
so which brings me to lip solium which
is actually a fork of a different
library the lip NaCl or lip salt the
only thing which is really worth
mentioning is that the light this
library has been built with this is
going to make encryption easy and
unfortunately they picked an open-source
license which is not as easy as T
licenses when you look at up a normally
open source license it should be not a
problem but in some organizations you
might run into trouble because the
license is not known so if you want to
use lip story emit is a very nice
library and I really think that if you
just need encryption don't need the
algorithms behind it
lip story was a very good alternative
you shouldn't my knee may be prepared to
you know explain what sayest you license
in your organization if you have some
strict rules of lying to you there you
know I like to cover shortly the three
libraries with example so I've chosen
for a s crypto PP for s for our essay
botan and crypto box this is basically
the approach which with sodium
implements and the Advanced Encryption
standard is the block cipher it's a
metric as I already have mentioned it's
widely used in the industry it operates
on different modes and it needs to be
initialized there's some random data
this is short overview of the modes and
there are five Euler modes and a few
other modes which exist but there are
actually two oilin newer modes which are
AR x and GCM which you should use if you
can choose your mode and when we write
code you not always can choose them out
because we get just to encrypt or
decrypt something from a different
client and then have to use the mode
which the client you'll assess those
modes are not competitive to each other
so if you if you encrypt in one mode you
also have to decrypt in the same mode
yeah ECB is electronic codebook it's not
really used for encryption and you
shouldn't really use it as you see the
picture is actually encrypted and
encrypted data set you shouldn't see any
patterns and you create I think you
create your clearly can see the image so
ECB is actually the only mode you really
should avoid then there's cipher block
chaining and like the most modes it's
secure when used properly and like most
modes which we is gonna see it allows
parallel decryption and yeah
disadvantages is no per encryption and
there are known text like availability
and somet ability means that if I know
the position of the bytes in your
encrypted data I can flip a bit in there
and treat your data and if I do it
correctly of not able to notice it
because one of those most don't
implement authentication so you
basically not knowing what there's no
hash very clear authenticating the data
which you have been sent over the wire
or which has been saved on some Drive
then there's the earth fee mode which is
a stream cipher mode for a s it has
advantages the key stream can be as I
told you earlier advanced and it can be
computed in advanced and they are fast
Hardware presentations for it available
some people think that the security
model for this question either and if
you have a Miss configuration then you
might have to the short the key cycles
might be too short that actually the
encryption of you water then cipher
feedback is basically the CBC backwards
it's not very common it's just for
example the example is in the Vicki
there's I also picked for this talk so
it's probably used out there small the
footprint it has
it allows for a decryption counter
motifs what the newer modes are based on
because it lost Perla and in decryption
therefore has the best performance there
used for encryption and I couldn't find
any negative points on that and yeah as
I mentioned there are two newer modes
and those new newer modes both at
authentication to your encryption and
they are basically based on the counter
mode which we saw earlier and you know
which one to choose depends really on
what what your application is and what
happened why I meant your running and
what's the goals of your encryption are
if you can use X or GCM you should
definitely use those modes as that
certainly our security above the
encryption this authentication and
counter mode is good and the other modes
also used in the wild so sometimes you
just have to use what your server sends
you new capture so one more important
thing to mention is that a s needs to
have an initialization vector which is
16 bytes long and must be randomly
showed up beeps auto random it can be
public it's a bit like a public key but
it doesn't it's basically for innocent
for initialization of the algorithm and
yeah you shouldn't Ryu that so each time
you need that you should recalculate it
and usually libraries provide facility
for generating random bytes which you
should apply here and a short code
example so I ask you sir either 16 or 32
bytes by standard and so we get these
seeded parts from crypto PP from a class
called auto CD Brennan Poole and then we
simply generate a block of for the key
and then we generate a block for the
initialization vector then the
encryption
we just have some text and the examples
just taken from the Viki it's very C
like and the text is then encrypted into
you see that the modes and cryptic VP
are actually template and take the
algorithm which they should and
implement and then by a process data we
do the encryption and the decryption is
very similar just that we use now the
encryption option in the type def here
so AAS in cryptography you should use a
random initialization vector and the key
is not a password that's also something
important to know that passwords like
you know they are not good for
encryption so if you want to use a
password for encrypting something you
have to turn the password into something
which is good for encryption which is
random and yet the modes you should do a
little bit of research but what mode you
should use and if you can use and know
the newer modes you should do that and
also what I didn't mention there's
little she was pairing off set before
the encryption is that yes can happen
some implementations the weakness that
you basically can guess if you have
enough data you can guess a key and
there's some method against that and
that was pairing good actually a random
order of bytes as applied to your
encrypted data but decrypted VP examples
do not use padding but that's another
method which is known to strengthen your
encryption which brings me to our essay
as I previously mentioned at some
a symmetric cipher you have two keys a
public and a private one the public key
is used for encryption and can and
should be shared otherwise it doesn't
work and the private key must not be
shared should be protected usually it's
stored and in some encryption manner
which are also standards next listing
for to be stored and some safe storage
back the drive
I do use botan in this example botan
needs to be initialized there is a
method called booting library no sugar
either or not exactly lawful and you
need to create an instance on this deck
and yeah this instance can flow so you
might want to guard it or maybe also a
vacation just should abort if you can
even create you create this instance and
yeah Bhutan is just like crypto Pippi a
collection of encryption algorithms and
of course one of the questions when I
was starting with ours I was like where
do I get such a private key from and
Bhutan has basically a class and which
has the role of being a private key and
the constructor takes around a number on
the run and the random number generator
from Bhutan and the size of the bits
which the key should have and the
example so as we see in the example
Bhutan already used with FPD string and
they also have some auto seat at oranjee
which just securely generate random
numbers and seeded automatically then as
a private key is generated first
thousand and 24 bits the question how
bigger and our sake he should be is that
depends on how much of an performance in
fact you can take think of in the
current stage of key this 4,000
- what house 96 bits should be enough my
my opinion on 2048 is also okay my
opinion but it's that's again something
that you have to decide how long should
your encryption be strong then the key
gets encoded and again and start and -
every string variables one is a public
key and one is a private key and both of
those are derived from the private key
which we just have generated then those
start off actually gets thought and in a
class which will take care of the key
memory so that it's cleaned up
efficiently and zeroed out deletions of
it deep enough cannot see a key in
memory then to actually have the setup
to enter and decrypt is a bit more
complicated was RSA in Bhutan so you
have to load that he private key and the
public key corresponding classes you
then dynamic cast those instances to an
encryption key and decryption key which
then are actually handed over to a
method where we then actually hand over
which actual implementation we want to
use of RSA and then the N and decrypting
is simply having a secure vector byte
ciphertext and and recording encrypt or
decrypt on the encryption and decryption
objects
so as we see the set up for RS a and a s
can be quite tricky and there's a lot of
things which can go wrong and there's a
lot of things which often have gone
wrong and the security community has
responded with that and said why we
might need a different approach we need
something which is secure and a lot of
people including me it's I'm not looking
like or for complicated setup all I want
is encryption
I want safe encryption so they have come
up with a method called crypto box which
basically does all the setup internally
and it gives you some box where you can
enter up your decrypt and yeah then
installer code you you have a method
encrypt and decrypt and give it a key a
buffer in an algorithm and it has what
what what it should and in practice it's
not that easy but almost so the script
of box approach is covered by boat on
and by lips thorium little thorium
basically is based on the idea of
offering crypto boxes to use to the
end-user so lips so diem offers
symmetric and an asymmetric crypto box
which she also for the asymmetric crypto
box you also can generate the keys and
center the public key tool to your
counter and both sides can actually use
the crypto box with other sides public
key the boat on implementation is the
first is based on serpent and I have
chosen the example it to be from the
disodium so lips Orion is a fork of any
sort and its goal is to make encryption
at very excessive the it's a seed
library C++ wrappers exist but none of
them really satisfy me and other people
so you might directly want to use the C
library if you use the sodium and you
have to call sodium in it when you want
to use any of its method that's like the
first method you have to
in each threat as calling 30 minute to
set up the environment for solid sodium
and in the code example which of course
is CSS e-library we see that they choose
to define several macros to actually
cover their needs so we have a message
in the message length and then they need
to calculate the extra cypher text
length so the crypto box has of course
and overheads though that they need to
calculate the message length Plus this
overhead is the actual length of the
cipher text them and then several areas
for the nonce which basically is kind of
like a installation vector and the key
and the ciphertext are located on the
stack and then yeah the nonce and the
key are filled with random bytes and
then the actual call to the crypto box
heads and crypto box easy with just
handing over the corresponding
parameters and then the decryption is
again very easy you need to know the
method length in advance
this probably is the only thing that you
really need to transfer unencrypted the
crypto box then itself present yourself
to yourself as a method called a
function called crypto secret box open
easy and in this case if this function
does not return null that means that the
message has been force that there's
something happened something it just
flipped or something has gone wrong and
you should entrust that message and
lipst odium uses for their crypto boxes
exit our stream cipher in the standard
version
you also can
specify different ciphers but there's a
different topic and the essa metric
implementation they use a certain curve
to do the key exchange and the
encryption is the same again a 20 stream
cipher and the success of cipher is
specifically designed to resist known
attacks on encryption and is actually
comparable comparable to AES and the
both crypto boxes of course also having
an algorithm for authentication and yeah
I know thoughts on the topic you should
today in your applications encrypt your
critical data that's I think something
you really need to do Booton and crypto
plus plus both offer the right set of
algorithms which are not always easy to
set up or if you need to use those
algorithms those libraries are basically
you go to implementation and Supercross
which one you prefer it depends a little
bit which style you like more botanas a
bit more black orientated but both
libraries a bit like not very modern in
design and and some operations are very
C like and can in some instances be
difficult to set up if you just need
encryption and a crypto box would do you
should use a crypto box in my opinion
the sodium has an symmetric and an
asymmetric way to do that and Bolton
also has a crypto box whether this is a
symmetric cipher so which brings me to
the last part there are neck question
yes
I can restart my question so you gave
one example for both on one example or
lib crypto today only for example on the
crypto example is AES but is that the
only does it not does it not have RSA or
do they they I have to choose a library
to present for in second example
so both libraries have basically all
modern encryption algorithms okay so I
wouldn't pick RSA and a s both supported
by by both libraries but vote on and
back up to PP the sodium in my memory
does not support those episode iam
brings its own set of algorithms which
are specifically designed by people
which are designers of such algorithms
and follows largely the crypto box
approach ok so your recommendation
crypto box is just because it's probably
easier yes it depends on what you need
if you just need encryption then use a
crypto box that's just it's easier to
set up you will not make arrows and
that's in my opinion the most important
thing in encryption that setting up our
essay or a SS can be quite complicated
and quite error prone so in my opinion
the crypto box is the way to go because
otherwise you will need to write
something similar anyways to to read the
safe creation and destruction of keys so
they use the end user interfaces of both
libraries botan and crypto PP I do not
think that they're very user-friendly so
you will have to wrap that and your
production code anyways yes
I have heard of certain keys are derived
from passwords encryption keys that you
can get so there are algorithms that you
can get a key that are derived from a
password other than the obvious security
flaws on using passwords where people
can choose objects passwords and all
that have you researched those and given
any thought on those methods I have not
really done deep research on authority
passwords it's not storing passwords is
deriving an encryption key from a
password and then using that yes I have
not covered that and leeteuk so I did
not research that entire either I know
that other isms exist there but I cannot
do and I will not do fundamental I
cannot really tell you what I written to
use there you presented an example with
a lip sodium you said that this is a
fork why is it better than lip and nasal
lip NaCl is also very good on you also
could use it but the sodium actually has
been forked for the reason to be more
user-friendly to be easier to be used to
be less error-prone so there's nothing
wrong with lip saw it and you can use it
if you use it in your production code
that's fine basically the work which has
been done by Delia burns 9 which is also
post libraries it's just let it go it to
make encryption more accessible and make
it easier to use and lip saw it could
not really follow up on that so they
made a second library which forked that
sort and it's up on top of the work on a
flip sword he
you mentioned we're reading code now our
attackers in the future so computers
keep being faster is there researchers
there talk about how long you can expect
your encryption to still be safe so if I
encrypt something today in 20 years is
that trivial is 2 years is that trivial
yeah there's research done on that
there's even research done on methods
like quantum computers I mean nobody
really knows do quantum computers
already exist and if they're if they
exist are they already used to attack
our encryption switch
most of our encryption or a lot of our
encryption is based on other isms which
are weakly against quantum computers so
there's currently a lot of work done on
the fear to explore ways to have
algorithms which can resist that and
there's other the current encryption
this basically you're safe for 10 to 20
years if you use strong enough keys
that's that's what what we think from
our position today but there's I mean
the the current leak of the of the
dating platform is a good example where
they at least thought that they had
encrypted their passwords in a safe way
but made an error and implementation
which then was actually leading to to a
weakness so that they can actually
decrypt those hospitals password hashes
quite easily now so there's a lot of
research being done and cracking
encryption and there is it almost
depends on who your attacker is I mean
if it's like in five years it's clear
that the hardware has advanced
dramatically but also today I mean the
Chinese or the the u.s. decided to crack
your code because it's important enough
to do so they have a calculation power
which is like the whole cloud in part so
we all have seen what what data center
has been built for the NSA in Utah they
intend to use it for purposes and it's
no reason to believe that the Chinese
the Russians and other services have not
similar capabilities so the encryption
is a good method to to keep your data
safe but of course there will always be
an attacker which could probably already
cracker today hi I have a couple of
questions actually first you didn't
mention elliptic curve I was wondering
if lifted curve is among the algorithm
is provided by the three libraries that
you that you discussed and second once
you have these keys have you encountered
any solutions for restoring them on the
device yeah that's that's basically what
I talked and the password part that you
know that's the same thing applies to
keys and there there are standard
algorithms to store your key encrypted
on the drive there's a password and then
again you you end up with a problem that
you have to store that password and some
manner if you actually want to on
uncooked your private key in an
automatic manner that's not somebody
typing in the key as I mentioned there
is demon by pootie which can serve as a
password store and secure source for
that and there might be different other
demons and different other operating
systems out there I'm very keen to to
know more about that how this actually
solve in a secure manner in the
beginning you said that HTTP HTTPS is
not enough usually so can you tell what
HTTPS is encrypting your transport and
within that transport your data is
secure but there's a bunch of a text
known against it HTTPS which starts from
having
buddy in the middle like a
man-in-the-middle attack where you're
not really gonna notice that you're
being hacked so that when you send
critical data over the network HTTP is
not enough you should always include
also your data which is sending over the
encrypted link that's one of the points
because I have been in projects where
the product manager is basically wanted
to send particular data over the
Internet via HTTPS and they thought it
was a cure and I as a software file as a
contractor would not implement something
like that I also would make sure that
the data you are sending over an HTTP
fingers encoder itself
any more question
oh yeah right right right yeah there's
work done on an elliptic curse and
actually the the key exchange here in
this algorithm and the in the isometric
part as far as I know that Kerr facility
Kerr
but I have not done extensive research
on the curse as there is currently also
a lot of dispute which curves are still
safe which serve which curse are might
be getting with record or should not be
used as an assay I might have that's a
problem with curse that it's hard to
prove that the curve is secure and the
the organization which is kind of trying
to standardize a certain curve for
encryption that needs to be a very
trustful organization so this curve is a
curve which is designed by Daniel Burge
done which is the known encryption
researcher himself so that's in the
community thought to be a trusted curve
and yeah all right when when I did the
talk I mean I was going to design the
talkin spring I decided not to hand it
and couldn't add a big curse to as it's
just then again another topic which is
very important but also they're
complicated to understand</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>