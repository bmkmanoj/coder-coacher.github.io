<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Jon Cohen “A Type, by Any Other Name” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Jon Cohen “A Type, by Any Other Name” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Jon Cohen “A Type, by Any Other Name”</b></h2><h5 class="post__date">2017-10-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ely_hVVZjEU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Alright, so, thank you
everybody for coming to this
talk 'A Type, by any other name.'
I know there's lot of other
really fantastic presentations
going on right now so I
really appreciate all of you
coming here and taking a
listen to what I have to say.
So with that in mind, hi there, I'm Jon.
I'm a software engineer
on Google's abseil team.
If you saw Titus'
keynote speech yesterday,
you'll know abseil is an
open source collection
of all of Google's common
C plus plus library code
and we've been working
on that for a long time.
This talk is more or less
a lot of battle stories
around making that happen,
we had to do a lot of
code reorganization and code
moving around to do that.
So, with that underway,
we're gonna be talking
about refactoring.
Hooray, hooray.
Seriously, though, here's
what we're gonna do.
I'm gonna talk about what
I mean by renaming types
and talk about why you would
even care about such a thing.
Why is renaming types something
that is like cool enough
and worth enough of mention
to have an hour long
talk at CppCon.
A lot of examples.
These examples are gonna
start to build up a list
of things that user code can
do, which can break other
users as a distance, library
maintainers or people who
depend on them when people
want to reorganize code
and do these kinds of refactoring.
And then we'll wrap it up, great.
So, renaming types.
What do I mean by renaming types?
It looks like this.
We've got a class, it's called old,
a function that takes it,
and we have some other code
that's using this type.
And we want everywhere that is says old
to now say new.
If you have a very small,
like just a little app,
a couple thousand lines
of code, if everything
is self contained, if
you have control over
everything in your code
base, this is not hard,
this is a very easy problem.
You can probably just do a SED
replace or something similar
and you're fine.
The key that we're going
to talk about in this talk
is that there's a sort of
invisible line in the sand
where at the top we have
some common library code
and at the bottom we have
some user code in a lithe
part of the application and
you can't expect in general
that the people who are
writing this business logic
lithe application have
knowledge or ability
to make changes to the library code.
Furthermore, you can't
expect the library code
to know who's using it
and this creates more of a
challenge when you're talking
about a refactoring task,
when you're talking about
making substantive changes.
This now becomes something
that you have to deal with,
you can't just go and
do everybody at once.
So, why would we even
want to rename a type?
Like if we're just changing
a name, is that a big deal?
I think it is, you might
want to do a lot of things.
All of these up here are kind
of dancing around the idea
that a name has meaning, a
name refers to a bunch of data
and a bunch of behaviors.
So when you refer to a name,
you're implicitly referring
to everything that type could possible do
or you could do with that type
and by changing a name,
you can gradually change
the meaning of your code in a better way.
So you might wanna upgrade,
maybe you have some old version
of like an upcoming standard
type, maybe you have an
optional type in your code.
I'm sure a lot of people here
have some kind of optional
in their code base and
they might want to move to
std optional or abseil optional.
(laughing)
So you may wanna upgrade,
you may want to gradually
rename everything that says
my optional to std optional.
You might want to move
it, you might have some,
maybe someone in your company
wrote some really great
networking code over here
and a lot of other people
want to use it but we don't
want a bunch of people
depending on lithe application code.
That's not a good overall
system architecture
system design.
So we wanna take this
and put it in a central
common location where
everybody can get to it
a little bit more easily.
You might also want to
fix dependency issues,
this was actually a
problem we solved in abseil
where we had a problem
dependency where a lot of our
foundational code that you'll see in base
couldn't use our good string
manipulation libraries
because it depended on
base so we used these sorts
of migration tactics that
I'll talk about in this talk
to invert that dependency and
mean that our foundational
stuff can rely on more
sane string manipulation
instead of going down to
like C standard library
string stuff or rolling
their own string algorithms.
That's not fun, no one wants to do it.
But, this bottom one is what
I really want to talk about.
To allow non-atomic codebase refactoring.
And what I mean by non-atomic
is the typical model
we'll often talk about with
refactors is maybe you have
an IDE, you click the rename
button, you click some button
and it generates some big
change that does the refactor
you wanna do and then you check it in.
And if you're able to do that
then great, you don't need
to do non-atomic refactoring.
If that works for you,
perfect, it's a lot easier.
But, often, non-atomic refactoring,
taking this large change
and structuring it in a way
that you can make the change
piece by piece by piece in
smaller, more self-contained
chunks is a much more sane way
of actually executing these
kinds of large reorganizations
and refactorings
of codebases.
Why do it?
Why?
What are the reasons that
we would actually do a
non-atomic codebase refactor?
Your change may be too large to merge,
this is a common problem
that we have in abseil.
At Google, we have 250
million lines and growing
everyday of C plus plus code.
There's double digit
thousands of developers adding
code to this codebase everyday
and we like to do things
like rename a type that's
used a hundred thousand times
all over that codebase.
And so if we tried to check
in this change all at once,
the time that it takes our
version control system to
actually turn all the bits
and do all the change,
there will be merge conflicts.
It's literally impossible.
Even if you aren't that
large, it still might be
an annoying game of whack-a-mole
of, &quot;Well, I gotta fix
&quot;this merge conflict over
here. Oh wait, but then that
&quot;code over there and then
that file got deleted,&quot;
so now you have to figure
that one out and you just keep
constantly having to put out
fires and find the right time
where you can just slip
in that change in between
your other developers
who are trying to work.
You don't really wanna revoke
everyone's access to the
sourcetree to do this, that's not cool.
Let's not keep other people from working.
They may also involve
excessive coordination, right?
If you wanna make a change
that goes maybe over a
frontend server boundary
or some kind of boundary
in your code such that it's
really hard to do it all
at once, you might need to
have a couple people have
two changes or three changes
and they all go at the
same time.
This is something we have to do common
or make something happen
one right after the other
after the other just because of some code
organization issue.
They also introduce extra complexity.
You take all of the risk
of every single change
when you make a large change,
and this is more of the
just general engineering thing.
Maybe a lot of your refractorings
or a lot of the parts
of this refactor is easy,
all this stuff is easy,
but there's some hairy stuff over here
and if you bundle them
into one large change
these little changes
over here that are easy
inherit the risk of this
squirrelly, difficult change
over here.
So you're just making
it harder for yourself.
Also, like say you're an open
source library repository,
I don't know why anybody would do that.
You don't know who's
depending on you, necessarily,
and even if you did, if you
wanted to refactor something
you literally just can't
make a change to all of them
at once because they're
all different repositories
so you have to structure
your refactoring in a way
that allows these things to
be changed one at a time.
Great, so the analogy
that I like to use is
to fix a bridge, just build
a second bridge and then
divert all the traffic to
that bridge and then get
rid of the first one.
There's some constant factor
that building new bridges
is cheaper in software
than it is in hardware.
(laughing)
Great.
There's a really easy
question to come out of this,
why not just make a new thing?
Why not make a v2 of our type?
This is totally fine and
it's kind of orthogonal
to the point that we're talking about.
A lot of what we're gonna
do is make a new type,
we're gonna see a couple
instances of these rehappenings
where we do make a new
thing and migrate people
but the point is, there's no
coupling between old and new.
We want to try and create
some migration path
between old and new and we
don't want to have to do it
in massive chunks, we
wanna be able to do it
a little bit at a time.
So, a lot of times, maybe you
just throw a v2 over the wall
if you don't have a lot
of users, that's easy,
but we're talking about larger situations,
more core like common code
that might typically be
thought of as almost unchangeable
and we want to provide
a migration path for it.
Here's one way to do it.
You can have the two types
convert back and forth
to each other.
Here we have an implicit
constructor on new.
It can implicitly convert
from old and it converts
to new by operator old.
We actually do do this
sometimes in abseil,
we have an int128 type that
converts to all the other
ints because that's what ints
do, they copy and convert,
whatever.
But, if this is a more
expensive type, say you need to
allocate in this constructor
or new and old are just big,
they have a lot, this gets
really expensive really fast
when you're passing things back and forth.
And it's not exact
equivalence, this isn't,
we aren't just doing a rename,
we're making a new thing
and kind of making them play together
and here's what I mean.
This code is problematic.
You can't just migrate g to use vector new
because even though old and
new convert to each other,
we don't have that kind of
code variance relationship
where vector old and vector new convert
so you'd have to copy all the news to old,
pass them in, do all your
stuff, and then copy them
back to news when you're
returning them or if you're
doing something else with
them and you just have
all of these spurious copies everywhere
and it's just a big pain.
it's a giant pain,
it's not what you want.
But we do have a tool to do what we do,
to do what we want to do
and this is what I'm going
to be talking about a lot
for the rest of this
talk which is aliases.
People use aliases a lot,
they're typically used to just
give things new, shiny names.
I'm gonna try and convince
you that aliases are
a lot more powerful for
software engineering over time
than that.
They're literally the same type.
In this instance, old
actually just doesn't exist
in the type system.
And I think everybody
there has experienced this
when you have some kind of
compile breakage that has to do
with std string and the compiler
doesn't give you a nice,
&quot;This isn't a std string,&quot;
it says, &quot;This isn't a std
&quot;basic string of char and
std char traits of char
&quot;and std allocator of char,
what are you talking about?&quot;
And of course if you have
a template that's got a lot
of strings and all of a
sudden you've got 50 million
lines of code that's all
complete and you don't know what
it is cause all those aliases,
all the sugars been removed.
They're literally the same.
So now, this example's totally fine.
We've decoupled f and g,
we can change one without
the other, without changing the other
because vector of old
and vector of new are now
exactly the same thing,
one's just a different name
for the other one.
Great.
So the analogy I like to use is this,
with variables, when you
make a reference to another
variable, the reference
and the original name
refer to the same data.
They're fundamentally the
same in an interesting way
whereas if you make a
copy, as on the right,
you have two things that
are equal but not the same,
they don't have the same identity.
And similarly, when you alias
types, they're the same type,
the two names are the same thing,
not two types that convert to each other.
If there are any math
minded people in the room,
this is also kind of like
conversion, two types that
convert to each other is
kind of like two groups
that are isomorphic, you still
need to a little bit of work
to go from one to the other
as opposed to two groups
or two sets or whatever
that are fundamentally
the same thing.
There's a little bit of a
difference between isomorphis
and inequality so it's kind of like that.
Great, so, let's find some code,
let's do some real stuff, right?
Just kidding, we're not
at examples just yet,
there's a little bit more
we have to do (laughs)
and I'm gonna talk about a little hairy,
what some would call &quot;expert
only&quot; feature of the language.
So, take a deep breath,
we're gonna breathe in (inhaling loudly)
and breathe out (exhaling loudly)
and we're all relaxed.
Good, are you relaxed?
Awesome, great.
We're gonna talk about ADL.
(audience laughing)
So here's the situation,
we have a type called class
and we have a function
which takes a class,
named very creatively.
Every type, when you're looking at class,
has associated name spaces
to it in C plus plus.
What are the associate
name spaces for class?
Someone shout it out.
And the global name space,
the global name space
is also an associated type for this,
which is gonna be important later,
it's gonna be important later.
But the point is that
TakesClass is in an associated
name space to Class, namely N.
So when we have user code
like this, they can just
call TakesClass without
actually qualifying it.
ADL only works on unqualified
calls and what'll happen
is when the compiler searches
for the function, it will
look in all of the name
spaces surrounding f for
TakesClass.
It will also look at all of
the associated name space
of every type which is past
to f and search in there.
So it finds, in classes
associated name space,
it finds TakesClass and calls it.
Great.
There are interfaces that
are designed to be used
with ADL, swap is a canonical example.
Here's how you call swap generically.
You bring swap into look
up by using std swap
and then call it undefined to trigger ADL
and this gives you a
sort of extension point.
You can write swap for
your own types when just
doing the three move thing
that the compiler does
isn't what you want.
So swap, big swap with
int would call std swap,
there are no other overloads.
Swap with n::Class calls
the r overload n::swap.
That might be something interesting.
I think probably a lot of
you in here have seen this
but it's good to go over
because it's gonna be important.
So the takeaway from
this is that ADL couples
types and functions.
It creates a fundamental
coupling in the language
such that when you're talking about types,
talking about refactoring types,
and specifically talking
about the names of types,
you can't ignore functions.
They are tied together
inextricably so you have to
talk about them together.
That's one of the reasons
that I'm looking at
functions that take these
types of refactoring,
we're gonna see that come back a lot
Alright, breathe out.
(exhaling loudly)
We've got a nice, cute
kitten, we're done with ADLs
so here we are.
Meow.
Now we have examples, I'm not
kidding with you this time,
we actually have some examples.
This is what we're doing.
So here's a basic example.
We've seen this before,
this is what I had up.
And what our basic strategy
is is we take the class new,
we will change everything
in that class definition
to say new where it says
old, all of your constructor
names and all of that stuff.
And then the old name turns
in to an alias into the class.
This case, I will give,
is not at all interesting.
This is kind of silly, if
they're just in a global
namespace or whatever, this
isn't that big of a deal.
But this is more interesting
and a lot more realistic.
You have something in an old namespace,
this is the situation I
maybe was talking about
where there's some lithe
code over here that wrote
some great utility and
you wanna bring it into
a common area.
You also wanna bring it
into some kind of common
namespace because that's a
good way to organize your code.
And we have some user code
and remember, we can't change
these at the same time.
This is a fundamental
restriction of our problem sed,
this is our constraint
we're trying to work around.
Afterwards, we just put
the class and the function
in namespace abseil, alias
into it, and this situation
works totally fine, this is great.
Does anybody know what happens
if that was the user code?
Does this compile?
Don't all answer at once.
You have a 50% chance.
(laughing)
You don't count.
This does compile.
This is totally fine.
Aliases, if you remember,
they're not in the type system.
An alias is not a type, it's
another name for a type.
So the associated name
space of class and f
is still abseil even
though it's declared as an
old::class in our function.
And we've also moved f
into namespace abseil,
so in this instance, both
the type and the function,
the function is in the
types associated namespace,
the compiler finds the
function via ADL, it calls it,
everything's fantastic.
However, we have a
different situation now.
Often, one of the things you
wanna do when you're doing
a large codebase change or
you're doing a refactor,
is you have some really old,
crufty stuff you don't wanna
maintain anymore.
Who here has things they
don't want to have to
maintain anymore in their codebase?
Yeah, that's what I thought.
So, for the record, on YouTube,
everybody raised their hand.
(laughing)
So we have this old, crufty
thing f, that we don't wanna
have to deal with anymore.
And so, we don't want to
bless it by moving it into the
new namespace, we want
to leave it over there,
it's a signal for people that
A. This is probably not
what you want to be using,
it's not in our core util
namespace or whatever you want to
call it, use this thing over here.
We don't want to migrate it,
we don't wanna deal with it,
we wanna get people off of it.
Now what happens with this user code,
does anybody want to tell
me if this compiles or not?
Does this user, does g compile?
There are couple people
shaking their head.
It does not compile.
This is the error message from Clang five.
No matching function call for f.
We can see f, it's right
there, there's the matching
function call but it's not
in an associated namespace
anymore, even though class foo
is declared as an old::class
it's associated namespace
is abseil, not old,
so this breaks.
And this is an important
moment because the user has
created a spooky action at
a distance for the library
maintainer they're depending on.
Their life has gotten worse
because they made their
library maintainers worse.
The whole point of having
this library is that most
of the lithe application code,
they don't wanna write that
library code.
They don't wanna have to deal
with it, it does a thing,
it has a contract, it
does something I wanna do,
I don't wanna have to deal with
writing it a bunch of times.
I don't wanna have to deal
with figuring that out,
we want it just in one
place, here's where our logic
is bundled.
By using ADL, they've
created a coupling between
the name that they're
supposed to use for the type,
and where the type actually lives.
It's completely reasonable,
for example, for class
to be an alias into an
internal implementation type.
That's completely
reasonable if you look at,
I believe StrSplit does this in abseil
where it does this magic splitting.
It'll split string into
any container you want
and it returns an internal
type that you're not
supposed to name that does all of these
magic conversions for you.
But the library author,
people who are working on
common.h, they have no
way of knowing that you're
calling them by ADL.
So they've been broken by a
spooky action at a distance
that they weren't aware of
and this is gonna slow down
the refactoring, this is gonna
slow down the maintenance
of the core parts of the
codebase because the interface,
this function f was called
in a way that was not,
my words are failing
me, it wasn't expected.
So we're gonna bring up this list now,
this is a list we're gonna
build of ways that user code
can make the lives of library
maintainers challenging.
Or as I like to call it,
how to make a puppy sad.
(audience laughing)
How can you make this
poor little pupper sad?
Call code you don't own by a ADL.
And there's three parts to
this and two of them are
interesting.
It's the fact that you don't
own the code and you called
it by a ADL and this idea
of code ownership is really
important here.
The lithe user code, these
are not the experts in
maintaining the library
code nor is their time
prioritized to work on the user code.
They're off making some cool application,
they're off making something happen.
They don't wanna be
prioritizing time to maintaining
their building blocks
if they don't have to.
So unless this library is
designed like swap to be called
via ADL, there's not a
particularly good reason to call
it via ADL except saving
a couple keystrokes,
as far as I'm aware.
So this is an example of what
we at Google like to call
Hiram's Law.
It's an observable behavior of the type,
people depended on it.
As a number of users n grows to infinity,
the odds that somebody is
depending on every observable
behavior of a type or
function, even if it's not part
of the explicit interface
of it, goes to one,
it's going to happen.
Also, if you use the global
namespace, you're gonna
make the puppy sad.
You're basically forcing
every call to maybe use ADL
cause who here likes to write ::sizet?
Does anybody actually fully
qualify anything in the
global namespace?
Yeah, who goes ::StrComp?
No one writes that, even
if you're writing StrComp.
So, you have the opportunity
to unwittingly trigger ADL
if that type moves underneath your feet.
The whole idea, again, is
separating the concerns
of user code and library maintainer code.
So here's another example.
Now we're changing a name and a namespace
and this is subtly different
and introduces some other
problems and I wanna
look at the two different
using statements in namespace old.
One is an alias, using
old equals abseil new,
we're actually making a new type.
This other thing is not actually an alias,
it's more of like
directions to the compiler,
it's a using declaration,
I think is the name of it.
It's a little bit different
although it's similar
enough for our purposes,
that's why I've just been
calling them aliases.
But this is a completely separate thing
and it'll get worse later.
This code compiles, this is totally fine.
But what if a user did
something clever like this?
People forward declare types all the time.
It's something a lot of people want to do,
maybe they don't want
to increase code load by
including a header because
you're only referring to this
thing as a via a reference or a pointer.
Maybe you want to
decrease your binary size,
maybe this is gonna help
your linker some way.
This is something that
people do all the time.
But we're confusing the compiler here.
The user over here is
saying old is a class,
or struct, actually I think
if old is declared as a struct
this still works, old
is a class type compiler
but the library maintainer
who's actually in charge of it
says, &quot;No, no, no, no, no,
old is a type alias. Old isn't
&quot;a type at all, it's not
a class, it's not a type,
&quot;it's just another name for abseil new.&quot;
And indeed we get this compiler error
definition of type old
conflicts with type alias
of the same name.
So this is another instance
of an implicit interface
that wasn't meant to be
exposed but is exposed
just by the mechanics of the language.
The language lets you do this
and if you control everything
or this is a short-lived
project, go ahead and forward
declaring doesn't hurt anybody.
If this is your own class that
you control, it doesn't hurt
anybody, it's only when we're
passing over a barrier of
who owns what that now you're
creating additional burdens
on other people who are the
actual owners of the code
and not you.
So, as it turns out,
pandas are made sad by everything
that you can make sad with a
puppy but you can make pandas
even more sad than puppies.
You can make pandas even
more sad than puppies.
Forward declaring a type you
don't own will make pandas sad.
I just talked about why
this might be a bad idea.
Also, opening a namespace
you don't own makes pandas
really, really sad.
This is basically the same
rule as don't open namespace
std, there's a reason
it's in the language.
It's in the language spec.
If you open namespace that you don't own
and put any name in it,
then you basically void
every possible guarantee
that your library maintainer
could make about the code
because they don't know what
might be a name collision and
this is even more sinister
because maybe you're a
code that's in the middle,
maybe you're not lithe code.
You have some people
depending on you over here
and you're also depending
on this library over here,
maybe you're depending on
one half of this library
and you add a name to it, you
open namespace abseil or std
or whatever and write
your own symbol into it,
which happens to be present
or made present in another
part of the library you're not
including so it just happens
to work, there's no ODR violation.
Until someone includes
you and also that thing,
and now you have two
definitions for the same symbol,
the library maintainer has no
way of knowing that you stole
a name from their namespace
and now there's an ODR
violation for these guys down
here for nothing that they
did wrong, they just wanted
to include two things
but you've introduced
an artificial coupling
in the dependency graph of the program.
And again we're talking,
this is all based on the idea
of code ownership and not crossing that
code ownership boundary.
When you cross the ownership
boundary, being a little
bit more principled about how
you're using code that you
don't own.
Oh god.
What about templates?
Yeah, whatever.
You can alias with templates
exactly the same way,
exactly with the natural
syntax that you would think.
This does exactly what you think it does.
But I do wanna make one point,
you can also, you can do a
using declaration and then
you don't need to do
the template introducer.
This is a much simpler
case and what I mean is
these are often called
metafunctions and what I mean
by metafunction is if you
squint really closely at old,
you can look at it as a
function from a type to
another type, new of T.
It doesn't return a new of T,
it returns the type new of T.
And as we're all aware, you
can do arbitrary calculations
in the type system of C plus plus.
So template aliases are an
extraordinarily powerful tool,
and just like any other
extraordinarily powerful tool
in C plus plus, with great
power comes great responsibility
and great ability to
shoot off your own foot.
So here's a renaming of a template.
I'm cheating, this is actually a function,
you can imagine this
happening with a type too
but this is something
that happened at abseil,
if you replace f with make
unique, this was a situation
where a user had a
struct or class and their
constructors were private
but they wanted to use
make unique so they friended it.
And make unique, if you
look at abseil right now,
it's under abseil memory,
it returns an internal type.
It returns a type in absl::internal.
But to make this friend
declaration they had to name
that type, they had to name
the signature of the function.
So this worked for them,
it compiled, it ran,
it did what they thought it would do
until we moved it into namespace abseil
and now old::internal
doesn't exist anymore.
It's gone and that name
internal should have been
maybe a warning sign that perhaps
this is subject to change.
No member named internal in namespace old.
So you can make owls really sad.
(audience laughing)
Look at him.
If you name an internal type you don't own
you will make this owl very, very sad.
It says internal for a reason.
The whole point of depending
on a library is so that
you get to ignore these internal things,
this is the stuff that you
don't have to worry about.
You don't care, it's not your problem,
that's why it's in a little
library code and it only needs
to be touched when that
thing needs to be maintained
instead of every time
somebody wants this kind
of functionality.
As a related thing, specifying
deducible type parameters
is also often problem.
This is our issue with make unique.
If you have a function with
the type of parameter that
can be deduced, there's
nothing saying that unless it
is specifically specified
like by template functions in
the standard, what deduce
specify the meaning of the
template parameters, there's
nothing saying that the
template parameters of a
function couldn't change
the meaning to make an
easier implementation,
maybe it makes the metaprogramming easier,
maybe they upgraded to 17
and now they can do something
cool with fold expressions
and type packs they couldn't
do or something like that.
This couples to the implementation.
Owls are very, very wise
animals, supposedly.
So this sad owl is able to
sum these up in a really nice
phrase that is pretty
common engineering knowledge
and which I've said a lot
but bears repeating with
the additional knives
that C plus plus gives us,
with the additional everything
that C plus plus allows
you to theoretically do in code.
Don't rely on implementation
details of code you don't own.
This bears extra repeating in C plus plus
because the details that you
could rely on in C plus plus
are there and they're easily accessible.
It's very, very, very easy to just say,
&quot;Blah, blah, blah, colon,
colon, internal,&quot; we don't have
types that are private to a
module like other programming
languages do.
We don't have the ability
to hide things as well as
other programming languages do.
Sometimes build systems
can get around this.
Bazel, abseil's build
system, has visibility rules
that can kind of help
us out a little bit here
but if these are named in a
header because you're doing
template code, all bets are off.
So just because it's
possible to rely on implicit
interfaces of a type,
doesn't mean that it's a good
idea over time or in a
situation where you're affecting
that guy down the hall's code
and making life difficult
for him when all he
wants to do is help you.
He's trying to be your friend,
just trying to be your friend.
One more example, oh yeah,
now we have a happy owl,
look at him.
You didn't rely on
internal implementation.
Look at him, he's so happy.
Dependent types, one
more thing to talk about.
I've got a little story to tell.
We've gotta talk about dependent types,
there's no scream this time,
although maybe there should be.
A dependent type is a template type
and it is dependent in
the sense that the actual
concrete instantiated type depends on the
template parameter.
What this means is that,
for example, this is remove
const, this is a pretty
simple one from the standard
library, it does exactly what
it says, it removes const.
But you can imagine that this
is a more complicated type
where maybe remove const of
int, type is actually a static
int, type is just an idiom,
it doesn't actually have to
be a type.
There's no way for the compiler
to actually know necessarily
what this is statically.
You also can't get away
from it, you can't hide.
Remove const underscore
t is just an alias for
remove const of t::type but
dependent-ness of a type
is viral, you can't
hide it, it's dependent
all the way down.
And here's the point I'm making,
template parameters of dependent
types can't be deduced.
If you have a function,
or I guess now a class in
C plus plus 17, although I
have to admit, I'm not that
particularly familiar with
constructor template parameter
deductions in C plus plus 17.
If you have a dependent
type in the argument list,
the template parameter of
that type can't be deduced,
that template type has to
appear again somewhere that
the compiler can figure out
what it is and then insert
it back to the template parameter and say,
&quot;Oh, t and t here must be
the same,&quot; and maybe I have a
remove const t and then an
int or and then a t and then t
is passed as int and then
this must also be int
or something.
But you can't ask the compiler
to actually deduce these
and if you squint really,
really closely and think about
how the type system is turning complete,
asking the compiler to
deduce template parameters of
dependent types starts to
look a little bit like a
halting problem.
So now here's a little story
and this is gonna be a
last little story about
a battle story I have in abseil.
Merging types, why do this?
Why would you take two
types and make them one,
or three types, or n
types and make them one?
It turns out, there's a
lot of interesting things
you can do with this.
It's very often that
disparate parts of a codebase
will write kind of the
same thing in a lot of
different places with
kind of the same semantics
but just different ways of
spelling the same thing.
You can write one central
type in your central location,
create the thing that's
going to be exist after you
clean them up, and then
internally shovel off to
different implementations
and then just fix
these guys over here
and these guys over here
and these guys over here
instead of having to do
a bunch of wholesale migration.
The first two bullet points
are kinda the same thing.
You can also abstract
away semantic differences.
There's another talk
going on right now about
how, at Google, we're
replacing approximately every
occurrence of unordered map
with our own hand rolled map
and saving just gobs of
memory and space and when it's
on YouTube you should all watch
it, it's a fantastic talk.
We didn't do it this way
but it was discussed having
the new map type initially
be an alias that shovels out
to unordered map and hash map
and a couple of other maps
we have, unify all of those
interfaces, and then flip
a switch and change
everyone over but it was too
dangerous, we have too many hash maps.
So here's a little story.
I'm gonna tell a little story.
Once upon a time there
was type called ArraySlice
at Google.
It's a non-owning view
of contiguous memory
and it is read only.
It has a constructor that
takes an anything as long
as it's a contiguous
in memory, implicitly,
and it has an operator
bracket so that returns
a read only reference.
Around the same time,
there was also another type
called MutableArraySlice.
MutableArraySlice is a
view over contiguous memory
but it's writeable and it
has a constructor that takes
a pointer to anything, at
Google we have an idiom
that mutable parameters
are taken by pointer,
and it has operator
brackets that gives a read
or write reference.
And it's not too hard to
convince yourself that these are
just two spellings of
basically the same thing.
These are the same type but an
ArraySlice is basically just
a MutableArraySlice of const t.
These types are used depending
on how our tooling feels
this day is it kinda chokes
on it anywhere between
50 to 100,000 times in
Google's codebase almost always
as function arguments.
This is basically designed
to be a function argument,
you can pass a vector to it,
you can pass an array to it,
you can pass a whole
bunch of stuff to a span.
There's a proposal for
something similar to our span,
although there are a decent
amount of differences.
We wanted to ship this, right?
We wanted to take our internal
idioms and export them
when we need to but we
don't want to ship two types
that are basically the
same thing except one says
mutable in the name,
that's not good design.
So it fell upon me to figure
out how to merge these
into one type.
And this is made much harder
by the fact that they're
taken as function arguments.
So you can't rely on implicit
conversion because you only
get one of those at any one time.
Span has to be an ArraySlice exactly,
but span also has to be a
MutableArraySlice, exactly.
It needs to be able to
wear both masks while we're
making this migration.
So there's kind of a tool
for this that I tried.
You could try doing this alias.
For those who don't know conditional,
std conditional is like a
ternary operator for types,
it takes a compile time
bowl and two types,
if the bowl is true, it's the first type,
if the bowl is false,
it's the second type.
So this kind of accomplishes
what we're looking for.
It's nice that we don't have
to rewrite any implementation,
as it turns out, the
implementation of span is a lot
more complicated than it would seem.
All of the implicit conversions
make for a lot of very,
very hairy and subtle SfENay
so we don't wanna rewrite
implementation as much as possible
when we're doing this.
What happens here?
Anybody wanna guess if this compiled?
It's not a courageous crowd
for answering yes or no
questions.
This does not compile,
which is a little bit weird
because looking at this,
it's really intuitive to say,
&quot;Well, we're taking a span of
int and we're passing it to
&quot;a thing that takes a span
of t, so obviously t must be
&quot;int, right?&quot;
This is a very intuitive
thing for us to say.
But span is a dependent type,
it's type depends on it's
template parameter.
So we see no matching
function call to TakesSpan
and the first time I
saw this error message,
I was absolutely floored.
I did not know about
dependent types and I sat back
and just like (breathing
deeply) I have no idea,
it's right there, it's
right there, it matches up,
I don't get it.
It's literally like it was this close,
the function it was calling
was literally right above it.
Like compiler, just do the thing, come on.
(audience laughing)
It couldn't infer template
argument t and this is what
I was talking about with dependent types.
Span looks like a template
class but it's not,
it's a template alias,
so we need another way
to do this thing.
So we are going to need to
do a little bit of rewriting
but what we ended up with,
is something that's morally
very similar to all of the
other strategies I talked about
in this talk.
It turns out that, for
historical reasons and because
they're also very similar,
MutableArraySlice and ArraySlice
had two implementation classes
which dealt with the SfENay
of those constructors
that take everything,
and then forward it back
to a central implementation
class that held a pointer and
the size and did all of the
actual logic of the class.
So we can hide the
dependent type inside here
and you can do this generally
as long as you have some way
to discriminate a compile time,
what implementation you want
dependent on your t.
I could have switched
between a million different
ArraySlices, if we had a bunch
all sitting around Google
for whatever reason.
Thankfully, we didn't, we only had two.
But this works, this is totally fine
and this is exactly what
we were doing before.
ArraySlice and MutableArraySlice,
they become aliases,
the span is now our class
and we did it exactly that.
I spent a couple months
just cleaning up the entire
implementation, I think I
ended up removing like over
a hundred lines of metaprogramming
from the implementation,
something crazy like
that, it felt really good.
(laughing)
And with all the caveats
of our list of how to
make owl sad before, this works.
This is a way to migrate
non-atomically, all of our
hundred thousand ArraySlices
everywhere with the correct
coupling between the old
name and the new name,
even though they will
eventually change to be
different things, bit by bit.
So, this is my claim.
Aliases, while nice to give
meaning, you know, maybe you
don't want vector of character,
maybe you want player
list or something, I don't
know, in your game engine.
I claim that really aliases
are a tool for gradual,
non-atomic refactoring.
They create the correct
coupling between two names
such that you can move piece by piece,
change your dependencies,
do very, very large, large
scale reorganizations of
heavily depended on code,
in a pretty reliable way and
the only things that break it
are pretty reasonable to
not ask user code to do.
And also, fairly easy to
fix when you see that break
after you've seen it before.
They are, in fact, such a
powerful tool for gradual,
non-atomic refactoring
that just three months ago,
this is September 2017 for the video,
about three months ago, the
Go team, another language
at Google who are very famously
do not like to add features
to their language, it's
a very minimal language.
They added type aliases,
type aliases only,
to their language.
And if you read their blog post about it,
the expressly stated
reason was we needed a way
to do large scale code based refactorings
and reorganizations.
We have fundamental dependency
problems that we can't solve
without these at the size of
codebase that the Go compiler
now is.
So this is really the
hidden power of aliases.
And that's how you can rename a type.
Thank you very much.
(audience applause)
If anybody has any questions,
I'd love to hear them.
Hi there.
- [Audience Member] Hi, I'd like to know,
there was a part where you
showed the LES saying that
quote unquote and you
said that okay over here
(speaking faintly)
Yeah, so, I don't.
Google produces statically linked binaries
and if you actually look
at our project guidelines
for abseil, we talk about,
we don't particularly give
any guarantees for
dynamically loaded libraries
for precisely this reason,
you can't do it statically.
- [Audience Member] Okay, thank you.
Thank you for the question.
Okay, if there are no other
questions, before people leave,
this is my first talk at a
major conference so I really
wanna take a selfie with the audience.
(audience cheering)
Oh wait, do we have another question?
- [Audience Member] Yes.
Oh, perfect, no selfie yet.
- [Audience Member] I'm
wondering if you've also had
in refactoring cases where
in order to make a very,
very large scale refactoring
you would actually start
and deconstruct the old type?
So like, say you make lots
of various constructors
which would appear at some
point so that you can slowly
get rid of a very large
amount of (speaking faintly)
Yeah, yeah, we do that all the time.
Getting rid of a
constructor, changing a name.
I think a really impressive
one that we just finished
recently was our internal
version of string view
which we called string piece.
Was it we had to switch from
signed integers to unsigned
integers and I think size and
.size and which if anybody
can think about the semantics
of signed and unsigned
integers it's a big,
that's a scary thing to do.
That's a very scary thing
to do, you could introduce
all kinds of undefined
behavior and we did.
How long did we spend making that change?
We spent nine months making that change,
little bit by little
bit, just literally tons,
we have other talks about it,
tons of tiny changes
that are run more or less
automatically with some human change
using a lot of clang
tooling to actually generate
that change and it works really nicely.
It makes these sorts of things
like changing an integer
from signed to unsigned on
a heavily used library type
like very doable and more
or less straightforward.
- [Audience Member] So
at some point, you do get
a situation where there's
old type that's actually just
a partial representation of
your new type because you're--
So it depends what you're doing.
So for span I actually
changed the name first because
that's like whether or not
it compiles is kinda the
important thing for span,
it's really that constructor
that I showed you that is
like, if I did SfENay wrong
in the constructor, I didn't
even have test failures.
We couldn't build the test
system because it used
span so much so that was my test failures.
So it really depends on just
the particular engineering
task at hand, do you wanna
clean up the type first
and then move it?
Do you want to create your bridge
and then clean it up later?
Often you can do that at the same time.
That's a nice thing about renaming first
is then while you're actually
going through the code
and renaming things, you can
also start cleaning up the
type at the same time.
You can kinda parallelize the task.
- [Audience Member] Thank you.
Thank you.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>