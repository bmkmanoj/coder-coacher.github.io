<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: John R. Bandela &quot;Simple, Extensible Pattern Matching in C++14&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: John R. Bandela &quot;Simple, Extensible Pattern Matching in C++14&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: John R. Bandela &quot;Simple, Extensible Pattern Matching in C++14&quot;</b></h2><h5 class="post__date">2015-10-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9IVCVSwn-fI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon everybody my name is John
vandella and I'm going to be talking
about simple extensible pattern matching
in C++ 14 thank you all for coming out
just a little bit about me I first
started programming in C++ after I
convinced my parents to buy me visual
c++ 1 point 0 for my 14th birthday after
that I went to undergrad at University
of Florida and then I went to medical
school and that did nurse surgery
residency this is this is me right there
this is actually from one of the
surgeries the patient right here had I
guess an epilepsy which is seizures from
a part of the brain that that couldn't
be treated with drugs unfortunately the
bad part of the brain was right near the
speech area so we don't want to take it
out and make him not able to speak so
basically put him to sleep open up the
skull expose the brain then woke him up
and then had all these electrodes
monitoring everything and and basically
the neuropsychology people asked him a
bunch of questions like can you identify
stuff and while we were like probing
different parts of the brain to identify
what he actually didn't need that we
could take out yeah all very cool stuff
after this I decided to do something
with a little bit less scary undefined
behavior so back to C++ all right so our
goals for this talk we're going to have
a very brief introduction to pattern
matching we're going to look at some
existing solutions and then we're going
to design implement the library and then
we'll have some question answer time
basically the goal at the end of this
talk is for you to understand how the
library is implemented and have a
feeling that hey I could do this myself
all right so what is pattern matching
this I guess you can have several for
more or less formal definitions a good
enough working definition is instead of
explicitly extracting and testing values
you basically you specify what you want
the value to look like and then you
specify an action to happen when that
occurs it's kind of like you can think
of it as a kind of level abstraction of
using regular expressions with strings
versus using like stud find and you know
matching and trying to match that way
how well does C++ 14 support pattern
matching C++ 14 supports it very well it
is probably in the top tier of support
among widely used languages
unfortunately it's all at compile time
so at compile time we've got function
overloading we got partial overloading
of template functions we've got template
specialization we've got partial
template specialization it's on the
family of pattern matching and it's
actually quite good at runtime this is
what we have right so on not too hot the
good old switch statement which you know
which yoyo you'll find somebody on Stack
Overflow asking why can't I use a string
there and complaining about what
happened other languages for example
Haskell which is a functional
programming language they have pattern
matching which support several ways you
can do it so this is basically the
equivalent of like a function
declaration and then you can actually
pattern match in the function
declaration so ABC is actually a couple
that's built into the language and so
you're basically to get the first part
of a you extract out the first plane and
you ignore the rest here and the other
way you can do it they have a case
statement here and these square brackets
are a list so an empty list a list of
one or else a list of many this is how r
us does it so they have this match
statement so you have your your pattern
here and then what to do afterward this
means basically is the otherwise and
that always matches you can also do
stuff with tuples you can break them
into parts and extract and tests on
those parts and you can have algebraic
data types so you have like email
message so this is kind of like a
variant and you can have different parts
quit change color move right your match
can extract and pull those out without
having to do a bunch of it found
statements there
just a plug for URI here in the audience
so there's actually a right there
there's actually a very nice pattern
library already available it's called
Mach 7 there were some very nice
presentations about it last year at CP
pecan and also in the c++ now that you
can watch online it does a bunch of a
bunch of stuff for example here is an
example from it dealing with boolean
expressions so if you have a boolean
expression basically to kind of evaluate
that type of thing here's how you would
set it up and here's how the pattern
matching would look like in this library
so my library is called simple match as
opposed to that this is just made by
yours truly Mach 7 works with older
compilers I think as far back as visual
c++ 2010 this one is c plus plus 14 only
so basically you're looking at I think I
G clanging 3.6 GCC 5 series and visual
c++ 2015 a simple match has no macros
it's basically a library no plans for
any like future language features and
the focus for this thing is not at the
moment on performance but rather on
clarity and simplicity as buren a said
C++ 11 actually feels like a new
language and the implementation of it so
this is just you know WC minus L and all
the implementation files was actually it
was actually a lot less complicated and
less code and actually I thought it
would take so which is a testament to
c++ 14 so just an example just the
previous example of doing like the
expression matching don't worry like for
this example just you know this is here
just for kind of reference we'll go
through it and by the end of this talk
you'll understand every line what he
does and how its implemented so
basically
you you basically declare your strokes
we're using boosts parent with recursive
wrapper so recursive rapper basically
keeps you keeps your space from blowing
up infinitely so you can reference stuff
like have recursive structures using
boost variant I instead of like a valve
type we just put in a bool and then we
basically inherit from STD tupple and
then we basically are using the temple
constructors any questions about this or
this is this should all be basically C++
11 boost and then this is what our eval
function is there's a couple of changes
i'm using the variant boolean expression
and i'm also this is constant so
basically you do a match and then you
say what you want to match and then you
provide a lambda that that tells you
what to do like i said at the end of
this talk will will will basically
understand and be able to implement
every line yes they are they are yes
simple match placeholders already and
this is an added bonus if you forget
something some not expression especially
for this just for this case mainly you
get this error message saying this type
is not in the match not expression all
right so let's talk about how we go
about designing and building this so
building blocks there's some nice c plus
plus 14 language and library features
function return type deduction generic
lambdas and index sequence okay so
function return type deduction basically
the compiler knows what the return type
of a function should be and instead of
having to write it out yourself
especially with generic code
it can become a lot easier and simpler
just to put in Auto and let the compiler
do it generic lambdas instead of having
to specify what the exact types of the
lambda parameters are you can put auto
there or Auto ampersand and the compiler
will deduce it for you and you know and
you can use it as as a generic index
sequence index sequences unless you're
familiar with it it seemed kind of like
a little magical class for me but
basically you can call make index
sequence say like a five and get back
this index sequence of zero one two
three four we'll see where that is
useful in just a little a little bit so
the star of our show is STD tuple we
will use that a lot and it will provide
a lot of help for us all right so this
is what top o everybody anybody here not
familiar with STD tupple alright so
basically you can make a couple gets
extract stuff out of it all right
anybody know what this is all right
temple cat basically this is a really
cool function that you give it two
tuples and it returns you back at uppal
with everything put together in one
giant couple anyone know what this is
stud tie all right this is the last one
for a while anyway so stud tie basically
creates a couple of L value references
by the way this is a really easy way if
you want to implement lexicographical
comparison for multiple types you put an
STD tie and then do a less than and
it'll work out real nice all right apply
apply is not yet in the c++ standard I
think its proposed for like the one of
the tss standard yet sterile experiment
okay so it's in there this is what it
looks like you're basically you give it
a function and a couple and it calls the
function with all the with all the
arguments from the couple okay all right
thank you very much so I did I pull this
from like the N 3915 paper and basically
this is what I'm using for the
implementation here so it's just
straight up still a c++ 14 so as you can
see the trick is basically the index
sequence with the integers basically we
can expand the parameter pack here to
actually make the function call alright
so let's go on let's talk about the core
of the library so the court of the
library is a function called match and
match is a is a is a very attic function
so basically the first part is basically
the the base case so we take the the t
is that is basically the value that you
want to match so T is the value writer
match a is basically your pattern f is
what you want to do afterward so you
call match check passing in the value on
a match and the pattern and if that
returns true you call apply and with the
result from match get which has which
you pass in the the value and the
pattern and match get returns couple so
down here a base basically this is the
very attic form of it it's a little bit
different than a lot of times you may
see because there's no empty case there
has to be at least one match
for it so basically the same as before
except if we can't find it we pass it on
to the next thing so this is basically
what's called a first fit match we match
the first thing that fits so the order
is important yes actually I think I now
made a subclass for but this is just
yeah laziness initially yes correct
there's a sub if you on the repo there's
a subclass now but just for illustration
all right match so match check basically
basically look basically looks up
matcher with the type of the type of the
variable and the type of the pattern and
based on that it calls a static function
check and gap so basically this just
passes it on and this is what it looks
like as we go forward we will specialize
this class and we'll get more stuff any
questions about the core at this time in
terms of correct the reason is I was
going like one after the other there may
be a whole bunch of checks without gets
and it's like an if so here it's so you
could combine into one but you'd have to
keep like some other parameter or
whatever with it and then for the other
parts you may not be able to return a
nice valid couple for it where's this
thing you know that you can return
something match check returns true that
you're good match check returns hey this
map we can go forward with Colin a match
get this is a valid match this matches
this pattern that's true correct so here
match check same as up here and then if
it doesn't match instead we pass it on
to the next thing all right any other
questions all right so so basically
we'll start extending the score so right
now it's pretty useless so we're going
to make it useful by specializing
silicon match match your lives and
customization and that's also the
customization hook for user-defined
types all right so first of all we're
going to start matching the same time so
Matt say X is just some get in get you
an integer one two three if it's we were
answers one answers to interest rate and
this is what we do we specialize matcher
check is just if they're equal to each
other and basically return empty tuple
all right so that will work now if you
have a string and constant char you know
the types won't match so let's let's
make this work as well so yes probably
do you're correct yeah so basically just
same thing at the 40 right right correct
right so yeah we could probably do an
enable if on it with with equals
operator correct alright so let's do
otherwise so this is basically
equivalent of a default in a switch in
the switch so basically so the
underscore it lives in simple match
placeholders so in place holders we have
destruct otherwise t we create otherwise
and underscore
and this is the match type we just
returned true and returned empty temple
everybody good so far all right some
more interesting stuff let's match and
be able to actually get what value that
we matched right so placeholders
underscore X and basically it'll come
out so we can come we can grab the X
here and we can output or do whatever
you want with it alright so we have
match your predicate we just holds up
basically a function object and then we
have this helper thing make match a
predicate that just you know type
deduces it and creates the right type
and then we specialize match the
predicate basically we check returns
true if if the if the predicate returns
true and then then if it then forget we
just return we tied there and so return
like a couple of one whatever that
matched so then placeholders we can have
XY and z they're basically you know
simple and you can add however many
things now there is no difference
between x y&amp;amp;z in terms of how they're
handled so that just you put XX or XY XZ
there's no significance to that alright
so let's do relational operators now so
one two we want to do X is less than ten
or say X is in between 10 and 20 and
otherwise and like I said we can do
different stuff so we can do if we
wanted to we can do the half open range
or the other range so this is just
example for operate or less basically
all the other operators follow the same
pattern we compare a match your
predicate and a value and then
we recurring we call the f Fung the
predicate function on the metra
predicate and the comparison operator
and this is just with those reversed any
questions about this and the reason it's
that way is is basically no I thought
this was a pretty nice range syntax that
was compact and easy to see at a glance
what's going on alright any questions
here so these are the simple types here
then we'll extend on to compound types
alright so here's the example Mike
remember what rested basically you are
able to split up the couple and extract
stuff so that's known as d structuring
basically it's taken a larger structure
breaking into its components and then
you can pattern match further on the
components for our case we're going to
use tuples as the underlying case all
right anybody everybody know fizzbuzz so
yes so fizzbuzz actually by reginald
Brathwaite and i think Jeff Atwood of a
coding for is the one that popularized
at least for me so basically it's based
on I believe a children's game is that
correct from from the UK i believe so
basically have the numbers from 1 to 100
if it's a multiple of 3 you print phys
so the number multiple of five fit buzz
multiples are both upenn fizzbuzz
otherwise you print what the number is
so i guess it's a children's game you go
around the circle and whoever messes up
gets kicked out of the circle all right
so here is there's a million ways to
implement in this here's a simple way to
implement this with match so basically
make a couple I modulo 3 I modulo 5 if
both are 0 fizzbuzz 0 or anything phys
anything or 0 buzz and otherwise we
captured the I output it any questions
about this example
alright so now comes the fun part of
implementing this so this is just like
some adapters this will help us in the
future when we want to try to adapt the
class to topple so basically have this
simple match get to poll which is
basically the identity function for
topple if there's a constant overload
non-constant overload and then you have
couple adapter which has a static get
function that takes the index and then
returns simple maps get top ones cause
STD get on it any questions about that
everybody yes it's going to be this guy
right here this is the easiest
customization point though this is also
a customization point if this doesn't
quite work for you you're welcome all
right so this is what our matter is
going to look like so we find the couple
adapter now from right here and then
topple len sizeof args minus one will
get back to why we do minus one in a
little bit and then we have our helper
function so basically let's see it takes
the first position and then the last one
basically let's go on to the base case
so we're the first of the last so this
is the last one at the end so basically
it calls match check and it pulls out
the the element of the top position and
and passes that to mass check as the
variable being matched and it pulls out
from here it pulls out the pattern here
and passes out to matts check and then
get does the same thing here so
basically with this we can we can like
compose stuff so everything that we have
access to with the simple types we have
access to in the temple as well
alright and then this is this is the
general case it does the same thing
except it passes on to the phosphorus 12
the to the helper any questions if
there's any questions interrupt me stop
me raise your hand we can like I said
let's stop and talking and learn all
right so check so Matt so matcher so
these are the check and get things
basically calls helper check forward it
to that and help her get all right and
then when we want to so we're going to
create like a little helper function
called be structure and then basically
takes all these arguments make them at
uppal now the reason we have this and
the reason we did the length minus
basically the size of minus one when i
try to do this initially it got it at an
ambiguity between TT and this thing so
we add this extra type at the end that
we just ignore and that keeps that keeps
this from happening alright so let's see
so how do we adapt a class so we got
basically a point class x and y and you
know we want to use it with this so
basically let's create a match sure if
it's 12 we output this otherwise we
output output this alright so basically
we can create a couple pass to it and
create a point pass to it it all works
so basically this is how you'd customize
the type that you that yeah that you
were creating that you want to work with
this so you can do a constant overload
if you want but basically this is all
there is to it yes
maybe I just did another thing well so
you have to provide this yes you had to
provide this for your types that you
want to use with it correct correct yes
yeah this is the this is the
customization point so to be able to go
in there yes if you overload by if you
yeah if we if we didn't over them for
that when we would be able to do it
alright any questions about tuples all
right so let's go on to pointers so
basically in everybody familiar with
like the maybe type or optional and
functional programming basically if you
have an error in turn throwing an
exception you you can return a maybe and
then you can pattern match determine
what you want his little high school
example basically dip safe keep from
dividing by 0 if it's just something we
say it otherwise provide that so it's
justin nothing so we can kind of treat
pointers as an optional so no partner
means nothing valid point we can extract
the value and then we can do further
matching on the extracted value alright
so here's what we can do so let's say
we've got some unique pointers nothing 5
10 12 right we match on it if it's a
five so some will act 5 basically we
print out five we can extract the value
from it print it out some by itself will
give you basically this will be int int
ampersand and actually that's yes and
then it'll be a copy of it anyway I'll
put it none means nothing and the order
is important here if we have this at the
first the other two whenever we never
get through any questions about this
example
alright so we will go on so for now
ignore this type right here class we
will get back with that so basically we
specialize matcher for some tea and then
Bay so we basically defer to that match
your class to to do the check in the get
and the same thing for now we have a nun
t-type will defer to that this is what
it looks like I said ignore class we'll
get back to that so check so basically
for void void so that means we'll see
what this means basically this means you
do not pass any further patterns to it
so it calls a pointer getter get pointer
no cast forwarding this if that's a no
point it returns false otherwise returns
true for here we call the same thing get
point of no cast and we return basically
at uppal with that pointer s2d tie if we
have a matcher or a pattern with it we
do the same thing except for the check
we pass this on to the match check with
that with the pointer as the value that
we're testing and the match same thing
with match get any questions about this
yes correct exactly and like I said you
know we're we're doing work twice but I
said anyway so none the recall this is
null for check and get just returns
nothing all right so this is what it
looks like for a pointer turn T naught T
and then for use with it this is how we
define none some with no parameters and
some will you pass the matcher we pass a
pattern
any questions about any of this all
right I'll go ahead have a question yeah
that's a good good question the question
was why we had an empty summon says some
with the placeholder I guess I felt like
it that day and just just just short of
thing you know that so yeah I guess this
was you know just the some non common
case that may be useful but like i said
it's it was basically more or less
arbitrary any other questions all right
so let's say instead Pat you want to
actually do unique pointer instead of
just you know then nothing got get same
example as before so we just specialized
unique pointer and there's a
specialization 4shared pointer to so
this the same code right here will work
whether you pass it a unique pointer a
shared pointer a raw pointer same
pattern all right okay let's have some
pump some with fun all right so let's
say we have a base class called holder
and then we have a template whole dirty
that takes the type stores it and then
the Rye is derived from holder okay we
specialize the simple match gift I have
a temple match get tuple just a little
helper function alright so let's say you
make holder 5 10 and 3.4 and then
nothing so then we can basically say
extract out of here only if this type is
holder int extractive holder int some
extract if it's anything so this will be
a constant holder and it's consider
holder and X and then if it's nothing
and then we can do further pattern
matching we can match you this in 25 or
if if you want to extract an X and you
go ahead Kurt correct yeah correct the
with the summon the not correct yes
alright this is how we do it so this is
the class that we had before so
basically our check and get exactly the
same except instead of calling get
pointer no cast we call get pointer
class right here and here same same for
the type without the matter the
controversial type here alright and this
is the full specialization for a pointer
so we're using dynamic cast I think
there's probably performance issues with
this one but like i said the focus was
on simplicity and clarity at this point
instead of performance optimization and
then is no all right and this is the
whole class of functions that you can
use with it so you can specify what
class you want to do to extract out
alright any questions about any of this
alright next we're going to talk about
integrating with the boost libraries so
here's that safety of function using
boost optional and this is actually in
the standard now is STD optional correct
leave at least in like a TS experimental
expl not 14 right but potential
potential 17 experimental so example has
a match to if we're dividing by 0 return
nothing here otherwise return x divided
by y
some nut to the optional thing and we
can do safety for two I said you could
do underscore X here this is how this
and this is the specialization for boost
what's so the pointer no cast so this
notice this does not have the the get
pointer that takes a class because
there's no way like you know generic way
like extract it out of out of optional
so that will fail only if you have like
uh some with a template parameter all
right remember whole dirty whole dirty
is a poor man's version of what yes
boost any any is able to hold any type
allows you to create an extract the type
which is previously stored so we can
then specialized specify this for any so
any 510 basically if it's an integer
extracted out same thing here with the
cement none we can do we can do even
more stuff but if we wanted to further
and this is our specialization so get
pointer so boost anycast if you pass it
like any star it'll return a null
pointer on failure instead of throwing
an exception and then we just is no
checks if it's empty alright this is the
last one I promise anyway no that is yes
so I was pretty bad that's the last one
no more all right everybody familiar
with boost variant so it's a type-safe
Union it allows you to store one of a
set of types one of the setup types and
get back what you stored it can be
recursive and common example for example
is JSON where you can have no numbers
string object or any so just a little
bit of diversion into algebraic data
types if you really wanted to learn
about them David's talk yesterday was a
great thing he went through the whole a
whole thing from 0 to 12 product to some
and with a bunch of math symbols in
there too I don't have any math symbols
just real small just real simple so
basically a some type is either a union
or variant and a product type is a
structure tuple and then we can use
pattern matching to break down the
abstract break it down further this is
the rust example so we have basically
this is the some type and these are
product type so it's the sum of products
and you can break it and pull it out
what you want so this is going to be our
boost variant example so just a very
very simple integer expression thing
with add sub neg and mall so we create
all right anyway so to create this
variant I think I change the slide so
expression same thing basically variant
recursive wrapper and then we add and
then we define the actual class of the
structs themselves same is what we did
at the beginning and then here's our
match so we can match on the expression
to make this actually should be math
variant t and then we can extract some
sub mole or an integer and extract the
variables
out of there this is our specialization
for variant just get pointer we just
call boost get and we pass it the if we
pass it a variant star then we get back
a note point of that fails sure right
here all right and then X multi methods
so simple example paper rock scissors
right all derived from a base this candy
apple full bunch of stuff say like
collisions or different I guess
collisions is also like another example
for it so basically paper rock scissors
you can tie that's couple and then you
can do some paper some paper rock and so
on for the next seven more any other
questions about everything that we've
done so far yes I did not do I I'd no I
did not all right exhaustive pattern so
what happens if we forget multiplication
so pattern exhaustive pneus you make
sure that the pattern match covers all
possibilities hask I believe throws a
runtime error Russ does exhaustive
patterns at compile time so this is a
non-exhaustive pattern so this is the
error message we get with visual c++
2015 when when we mess that up and GCC
5.1 so how do we do that
it's not really magic basically so
here's how we do it will go over kind of
quickly so we take this match so
basically the previous match that we had
before we'll move it to detail and
rename it match helper so this right
here is the previous match helper so we
extract all the argument types we look
up a customization exhaustion checker
see what the type is and then we pass
the argument types to the checker and
then we assert on checker value so
extracting out all the argument ice
basically return a couple with you know
with just the pattern types ignoring all
the f's and then here come down to here
so and then we have this fast for some
exhaustive pneus so in the type we check
if it has otherwise if it's otherwise
basically we're done we basically
specialized for something says return
true cuz if it otherwise there's always
an exhaustive match and then we have a
sum exhaustion as helper here which is
specialized for false where there is no
otherwise we extract all the some
classes we get that as a couple and then
we call there's a helper function which
which it's not in the slides but
basically it checks that all the
required types or in all the some
classes it's just matter of some
template metaprogramming have a value
there and have a value here then for
variant we have this helper fun helper
function here we extract all the variant
types and then depending on which
compiler you have and what the things
are I know with you had like it's either
the very addicts or else you might have
some I think they there's a boost no
type or something that's appended to the
end for those ones so we just discard
those for these ones get that as a
couple and then basically map some
exhaustive pneus to the type that we're
using
so this is all available at j bank
github gee abanilla simple match and as
my daughter says most of the fun
building stuff is actually being able to
talk about it with other people so thank
you all very much for attending this and
giving me the privilege of talking about
it and i'll be happy to take any other
questions thank you sure yes go ahead
correct no it does not support that yeah
I actually I actually thought about that
so is having pair pair we're both of the
same type instead of having to do the
placeholder X what I thought about doing
was basically at the function level you
declare like a variable called
unification variable and you give it a
type and then that type you'd pass you
know say X and then you pass that X is
the pear pear and the first time it did
it it would it would basically be like
have a boolean say hey whether I've been
it's basically like an optional in there
right whether it's been said or not if
it's not been set you set it to whatever
value you have if it has been set you
compare it and then you returned to her
false so I think that's the way you
could go about doing that that makes
sense to any other go ahead
what about like usually you have like
bases there are classes yes you would
expect ability where you match when it
arrives gloss and you have a case okay
um correct okay so pointer holder say or
you're talking okay that was that it yes
I need to go up already so this will
right here let's see you're talking
about right okay and then add arrive
they'll be derived from here correct I
believe you could because this takes it
by reference there and that's the drip
and I believe that when match here but
you'd only get the first two out unless
you specialize it for the other one
right but I think this may catch it here
and then you could go from there but
yeah they'll be definitely something i
can check
right I guess the only thing I was doing
is I kind of like this this format in
terms of you know with the comma
separated you in terms of in terms
instead of that then I guess without the
stylistic choice that that was the main
reason ok ok I guess the only advantage
this can be more complicated than just
you know straight up arguments like it
could be X is less than one and then
so you're talking
so this one right here yeah you could so
x and y or actually so they'll give you
this expression e so then you could
actually put like a des in here and then
so you could do d s XY so W X Y Z you
could do that if you want to do would be
X Y W X Y Z linear lies yeah everything
I linear lives no matter how deep this
is over here basically you just a matter
of specializing simple mats customizer
matcher define the type and then for
example you have to find a match to type
and whatever type you want and then you
can do whatever processing you want as
long as you can do a check and again
sure and then the
thing like I said like you know for what
I thought about those like like the end
k plus 1 patterns things like that i can
do that as an example any other
questions comments all right thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>