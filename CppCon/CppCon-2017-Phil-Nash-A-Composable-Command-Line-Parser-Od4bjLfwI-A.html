<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Phil Nash “A Composable Command Line Parser” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Phil Nash “A Composable Command Line Parser” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Phil Nash “A Composable Command Line Parser”</b></h2><h5 class="post__date">2017-10-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Od4bjLfwI-A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">So what does composability have to do with
command line parsing?
Well, we'll answer that
question in a moment,
but first we'll have a question.
Who here has actually used Catch?
So, handful, that's good.
The rest of you should be ashamed.
If you have used it,
you'll know that it has
a fairly rich command line interface.
You can see there, it's
got lots of options,
nicely formatted in the usage strings,
with some nice column wrapping
on the right hand side.
But it wasn't always that way.
Fact, if we look at a
brief timeline of Catch,
right at the start,
just had the very basic,
ad-hoc command line parser,
just referenced Argc, Argb directly
with some string matching.
It was simple, but it worked.
Of course, over time we've
added more and more things.
More options, string
conversions, error handling,
from those usage strings.
It became more and more
general, to the point that
I actually found that I had
a library within a library.
So even the libraries were composable.
So, what I did was, I
split that library out,
called it Clara, for command
line argument arranger,
and put that up on GitHub
as a separate library.
But that had a couple of problems,
one of which was that it was like
Catch itself constrained to C++98,
or had a few limitations.
And a couple of sort of slightly
dead end design decisions
that I meant to go back and revisit.
So eventually, with Catch 2,
now, evidently out, re-based on C++11,
I took the opportunity to
rewrite Clara from the ground up,
with C++11, but also revolving around
this idea of composabiity.
So what does that really mean in practice?
Let's take a look.
An example.
So this is a single option parser.
So, it just binds a variable
name there to that variable
combined to a variable or a lambda.
You've got the usage string
documentation in there,
the options themselves.
So it's sort of like a little mini DSL.
But this is a complete,
stand-alone parser.
You can use this to parse
straight from Args in RV.
You're parsing in at the top
by running them through a very simple X
So that easily tokenizes the arguments.
And then, what that returns is
a series of remaining tokens
and a status, say, where
there was an error,
and if there was, what the errors were.
And of course, you can
create additional parsers
for additional options.
So here's another one.
Once you've got more than one,
this is where it gets interesting,
you can then compose them
by using, in this case,
the pipe operator.
This is where the magic happens.
Because, remember I said
the first option will
return the remaining tokens.
So within the operator,
if there are no errors,
it will pass those tokens
on to the next parser.
So, it's a bit of a monadic bind there.
So you're now left with a combined parser.
And of course we can do away
with intermediate variables
to sort of a nice declarative
setup of your parsers,
and we can easily add more.
This is an Argument rather than an Option,
but it's basically the same sort of thing.
In fact, this is exactly
what Catch now does.
This is the complete command
line specification for Catch.
This is all very regular
and neat and easy to follow.
As you can see at the end there,
it does return that combined parser.
Which is all well and good,
but what's the actual
benefit to doing it this way?
What do we get out of it?
Well, if you're a user of Catch,
you can declare your own name, and
the bit of the highlighted code there,
is where you might add to compose
better command line parser
that Catch has in session.cli,
with your own one.
Very, very simple
thread, your own binding,
to your own variables.
And then you just pass that back to Catch,
and it will use it to
produce usage strings,
to pass the command
line into your variable
where you can immediately use it.
And if you look at the
beauteous string produced,
you can see the additional one
I had to drop in the end there.
And if you have your own applications,
with various different components
that don't necessarily need
to know about each other,
they can all expose their
own command line parsers,
or partial parsers,
and they can then be
composed at the top level
and that they will benefit from that.
So that's the end of
Composable Command Line Parser.
I'm Phil Nash.
You can reach me in these places,
or in the JetBrains booth tomorrow.
And also during a talk on
Friday on system hash trees.
So be there.
Thank you.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>