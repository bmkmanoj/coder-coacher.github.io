<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Ingve Vormestrand “Tools and Techniques To Stay Up-to-date With Modern C++” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Ingve Vormestrand “Tools and Techniques To Stay Up-to-date With Modern C++” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Ingve Vormestrand “Tools and Techniques To Stay Up-to-date With Modern C++”</b></h2><h5 class="post__date">2017-10-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xDEGpKJ62lI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I've been told that if
there's a lot of people,
you should make room to get them
into the center of the room,
but I don't think that'll be a problem.
So we'll just start normally,
and my name is Ingve.
I'm a developer in IncludeOS
open source project.
I'm also on Twitter.
That's my handle and when
I checked in to my hotel,
the receptionist told me that
last name was way too hard,
so I'm sorry about that.
I blame my parents,
but Google will probably help you find me.
I work from IncludeOS and
hopefully you have seen
some of the other talks.
There have been at least three talks
and if you have missed some of them,
they will be on video soon.
This talk although I work for IncludeOS,
this talk is not about
operating system development,
not about systems
programming or any low level
difficult stuff.
There will not be any
inline assembly here,
so I'm sorry to disappoint
those who like that,
but I think there's talking
for assembly on Friday.
If everybody can check
they're in the right room.
This is the theater and the
time seems to be correct.
You probably can't read that
so I'll enlarge the portion there.
You see down there where
it says level beginner?
I've seen many of you around
and I doubt that there
are many beginners here.
Hopefully some of this content
will be useful to you anyway.
There are probably
beginners in your companies
or in your user groups or something.
Teaching and learning
has kind of become the
unofficial theme of CppCon this year.
There have been many
sessions about those topics
starting with Bjarne's keynote on Monday.
There was also a trainer panel
and an academia panel and so on,
and I just want to tip you about this.
It's later today, teaching related
and looks very interesting.
This talk is about tools
and techniques for staying
up-to-date for Modern
C++ and C++ we have lots
of everything.
It's a big language.
It's a big ecosystem.
We have lots of tools.
We have lots of techniques.
Clang-tidy, valgrind, client
format, core guideline check
over in Visual Studio, all good stuff.
Also techniques.
I don't know who comes
up with these names but
the substitution failure
is not an error and the
curiously recurring template pattern,
if you know what these
are, you're not beginners.
As programmers we tend
to prefer hard topics
about the technology
and how machines worked.
This talk is unfortunately not about that.
It's more about soft topics
like people and how we work.
This is a really hard word.
What it means is self-education.
Education without guidance
of institutions or teachers
or masters or professors.
I want to talk to self learners,
people who have some C++
or programming experience
and want to learn how to stay
up-to-date with Modern C++.
Bjarne said this on Monday.
&quot;Teaching is easy.
&quot;Getting people to learn is hard.&quot;
And that's true, but people
really, really want to learn.
The most popular online course
for several years running
has been a course about
teaching yourself how to learn.
Bjarne also said you should,
&quot;Know your students -
most are not like you,&quot;
and that's probably true if
you're a college professor,
but if you're self learning
obviously your student is you.
It's kind of important to
make your learning process
as effective as possible,
to know yourself.
Bjarne also said that
the previous occupation
of most professors was student
and that was maybe not optimal,
but imagine how confusing it
is when you try to be both
at the same time.
You are your own student
and your own professor.
I'm going to share a bit about myself.
Like probably most geeks,
I'm not really comfortable
talking about myself, but for this work
you have to know something about me.
I never intended to go into programming.
I, like many people when I grew up,
I had no idea what I wanted to do
so I did the obvious thing,
I studied business administration.
(audience laughs)
So this was in the 90s and even then
you still had to have some
technology courses in your curriculum.
We had to take two IT related
courses and I took one
called Structured
Programming and one called
Object Oriented Programming.
This was the textbook we
used, C: How to Program.
Great title and this
is the second edition.
This book is still in use.
They're now up to the
10th edition I think.
It starts with C and then the second part
or roughly the second
part is C++ as better C.
So it starts with the low level C stuff,
manual memory management
and then when you get a bit further,
when you get to the C++
part, you learn about
object oriented programming.
One of the classic example,
you implement your own
string class and so on,
and like I mentioned
this was in the mid 90s
and C++ was quite different then.
They also had this classic
book as suggested reading
and this was in a simpler
time before internet
and when our buffer overflows
was not a huge problem.
So we had static sized buffers
and we never cared about overflows.
I must've become somewhat
interested in programming
because I actually ended
up buying this book
and from this angle it
doesn't look so intimidating,
but if you flip it around, you
know it's a pretty heavy book
and I have to be honest,
I never got past the iterator chapter.
That was too hard.
I think I must've understood
a couple of things because
on Bjarne's homepage he
publishes Errata for printings
and I'm actually listed there.
I cannot remember what I told,
what kind of error I found,
but it probably was some minor thing.
I see there also some other celebrities.
(audience laughs)
Keyser Soze, I don't
know if anybody remembers
The Usual Suspects, but
I think it makes sense,
if you are a super villain, you use C++.
Anyway like I said I had no
intention of going into programming
so I started working in media production.
First I did print work.
Then I did corporate videos.
Then I ended up doing
multimedia, web, and apps.
So obviously, the future got
more and more technological
and I figured it was time
to go back to school to get
a proper CS education,
and I ended studying under this guy.
I don't know if you ever heard about him,
but I've seen him around
and I think he knows
what he is talking about.
I ended up having to get a
newer edition of Bjarne's book.
This time I actually got
through the iterator chapter.
That was pretty good
and the funny thing is
this is still recommended reading.
So my 20 year old copy served me well.
One of the things about C++ in college
it's not taught in isolation.
Technically it was a C++
class, but there were
a lot of different topics
that were put into this class.
You have the basic language.
You have the standard library.
You have low level bit access stuff.
You have high performance stuff,
object oriented programming
templates and all these other
things, plus you have all
those workflow things about
linking and make files
and things you don't need to
worry about in other chapters.
It's kind of weird that
so much C++ still deals
with these low level things,
but again it makes sense.
I'm sure if you ask some
database professors,
they will complain that
you don't SQL properly,
but there they also have to put
in a lot of real world topics
like data modeling and
transactions and normalization
and all these other things.
So there are usually not
college classes for want to be
language lawyers where you go
perfect detail into a language.
You use language.
Okay, now you know far more about me
than I'm comfortable about.
The reason for that is
if you are interested
in self learning, you need to
do a self-assessment first.
You have to know how you
learn, what kind of material
that works for you, what kind of material
you don't find interesting
et cetera, et cetera.
Here's a slide and don't
worry if you can't read it
because that's not the point.
This is very, it's internet
famous stack overflow question
and it's a bmi calculator
and the first question there
is I would call it old school C++.
You have explicit control structures,
you have the switch and
all that stuff, lots of ifs
and else ifs and that's
the way I was taught C++,
and that's the way my brain,
if I get an assignment
to make a bmi calculator,
that was what I would
do, but it's not what
you're supposed to do.
This is a good answer.
It been discussed quite
frequently and as you see there
you use upper bound from stood algorithm
and this is a lot more elegant.
If we go back you see here.
It's probably, it's a lot longer.
It's easier to make mistakes
and it has far too much details
about unimportant stuff.
It tells you how to do it,
not what you want done.
And to give you another
example, this is a snippet
from the aforementioned code.
This is from the explicit
control structure version
and I find that very readable.
Variables are named, they are explicit.
You probably understand what's going on.
If this had been some to
code with variables named
foo and bar and baz and all those things,
then I tune out immediately.
If a textbook has functions
and they're called f and g,
I'll lose interest immediately.
If they're called the catholic sales tax,
then hey I can understand this.
Okay, the point of this is
this is the kind of thing
you need to self-assess.
I am clearly more familiar with
explicit control structures.
I am bad at recognizing opportunities
to use standard algorithms.
I have a low tolerance for abstract
code examples, et cetera, et cetera.
This is important because
we need to maximize
the return on investment
when we are studying.
There are many different ways we can study
and again this is not for school study.
This is things you do on
your own, self-directed.
So here we have a lot
of different activities
and we have effort and if you
start at the left side there,
you can start a project in
GitHub or read a blog post.
That's pretty low effort,
but also pretty low reward.
Then you can exert some more effort.
You can go to CppCon.
You can hear lots of, hopefully
some of them useful talks
or you can try some
coding in online compiler,
but that takes more effort.
Then you can do even more effort.
You can write the blog
post or explain something
or you can present at CppCon.
I really don't recommend that but,
or you can write the standards
for both or write a book,
and if you are in the trainers panel,
to write a book is not
considered worth it either.
The thing we, most humans, at
least the realistic humans,
we try to follow the
principle of least effort.
Here I have a pen.
If I walk around on stage
and I accidentally drop it.
I could go back like this, charge for it,
somersault over there, slide
down there in the crowd,
jump up, but I'm not gonna bother.
It's a pen.
It's just gonna stay
there until I pick it up.
(audience laughs)
So I want that pen when I go
home, but it's gonna be here
and nobody of you are going
to come up here and take it
from me, so you have to use
the least effort that will
accomplish your goal and that
goes for training as well.
We're gonna do a slight detour.
I don't know who Eduardo Madrid is.
It's a really cool name
and he seems to be here.
So if anybody run into him
or know him, say hi to him.
He is really, really
enjoying CppCon and from his
description here it's like
drinking from a firehouse.
Each presentation takes days
to digest and there's a bit of
(mumbling) missing out because
probably when you're in here,
there could be at least
two talks at the same time
that are even better,
five in this case but,
(audience laughs)
I don't want to be a Debby Downer,
but anybody here familiar
with imposter syndrome?
(man mumbling)
I'm asking for a friend of
course, but good to know.
This is pretty much how I felt when
I got back from CppCon last year
and it's important to have some balance.
So what is imposter syndrome?
Basically this is oversimplified.
Two things, inability to
internalize accomplishments
and a persistent fear of
being exposed as a fraud.
This is incredibly common.
Here are just very, very few people.
They have written very well about this
and these are celebrities
in the programming sphere anyway.
I mean Jon Skeet is like
the super, super, superstar
of stack overflow and he has
written about this problem
and the thing is with
these guys obviously,
they have to be imagining
it because you know,
they are really excellent programmers,
but me on the other hand, hmm.
So just to cheer you up, some
reassuring words from Simon.
&quot;Don't be discouraged when
you find things difficult.
&quot;C++ is hard, and even the
experts get things wrong.&quot;
So having said that, we need
some information sources
that we can use when we
need to follow Modern C++.
Are you familiar with Sturgeon's Law?
It's...
(audience laughs)
Yeah, not all information
out there is equally useful,
plus there is really a lot
of it and it would take
even if you found only the perfect
really good flawless information,
it would take a long time to process it.
There are some potential
sources if you want
to know what's going on with Modern C++
and we are going to put them
into categories good and bad,
and that don't mean on an absolute scale.
That means good or bad
for the specific purpose
of paying attention to what
is going on with Modern C++.
We have the C++ Slack.
It's great when you're at CppCon.
It's very nice to ask
questions there if you were
stuck on a thing, but it's really noisy
and people there tend to
be fans of doing things
harder than you have to just for sport.
Another really useful source
is the committee mailings.
Available online, papers,
proposals that the committee
will discuss and consider
for standardization.
Actual, this is one,
probably the most recent one,
but it has way too much detail.
Again, on the return on investment thing,
if your goal is to be a language warrior,
if your goal is to have one million points
on stack overflow, then
you should read this,
but if your goal is to stay up-to-date
and be reasonably
confident, this is overkill.
Now how about Reddit?
Reddit has kind of an iffy reputation,
but the C++ Reddit is surprisingly good.
The moderators are doing an excellent job.
Generally quality content flows to the top
and they are very pragmatic.
It's useful or most of
the content is useful
and not language lawyerly.
So I recommend that.
Twitter, that's of course
a perfect place when you're
looking for a snark and
political fights and lots of time
wasting, but if you have
been at CppCon this year
or last year, you will know
that a surprisingly high
percentage of C++ developers
or at least the kind of developers
who go to CppCon, they
are very active on Twitter
and they post so many good links.
So I would recommend
following quite a few of them.
There is this guy, some
strange Norwegian guy.
He has created a Twitter list
where he has hundreds of C++,
of the best of the best C++ followers.
So I recommend subscribing to that list.
Of course we have Meeting
C++ that every week I think
they publish a Blogroll which
are a collection of blog
posts that they have tweeted on
their Twitter channel or something.
It's really good.
Anyway this is one of the latest ones.
They change every week.
Very nice curated list.
Of course you have CppCast.
It goes without saying.
It's the best podcast ever,
and then you have a very useful concept.
I don't know if these
are collected anywhere.
Back on step two where we
had the committee mailings,
these are the raw papers
from the committees.
Then we have people who go to
the committee meetings who write.
It's a C++ specific genre.
They write reports from
the committee meetings.
They digest the papers.
They give highlights.
They explain things.
It's tremendously useful.
I don't know if there's a
collection of the Trip reports,
but if you follow the Reddit CPP,
most of them are posted there.
They are really, really good.
They are much more approachable than
the raw committee mailings.
I highly recommend it.
(audience laughs)
I think Andy is right.
&quot;C++ was invented primarily
to teach humility to humans.&quot;
So it seems like he and
Simon are in agreement
and if you are discouraged
because every now and
then you will be, you can just
remember what the legendary
Japanese director Akira Kurowsawa said.
&quot;I've been able to work for so long
&quot;because I think next time,
&quot;I'll make something good.&quot;
(audience laughs)
Okay, we should get back to Modern C++
and how to learn that,
and here's someone named Perry.
He tweeted a couple of weeks ago,
&quot;C++ 17 approved by the
standards committee.
&quot;C++ 20 work already started.
&quot;Once the language gets more features
&quot;it will finally be perfect.&quot;
(audience laughs)
And I thought that this reply summed
up my feelings pretty well.
(audience laughs)
Okay, but what is Modern C++?
Can anybody define that?
This is frequently debated and nobody has
a textbook definition I
think, but what is Modern C++?
Meeting C++ is again, they
have tremendous resources.
For example, the Twitter
feed, there are usually
very insightful quotes
and they found out that
a majority seems to be using Modern C++,
but this is of course the
majority of C++ users on Twitter.
That is not representative of all
the C++ users in the world I think,
but there was a follow up.
The link up top there.
And Modern C++ seems to
be a name for C++ written
to C++ 11 and later standards.
I don't know if you agree with that,
but it is a useful definition.
Another definition that's
sometimes uses as Modern C++.
It's called the fellows,
the C++ Core Guidelines.
I actually printed the C++ Core Guidelines
before I came here and in
Europe we use paper called A4.
It's slightly different from
your letter sized paper,
but the Core Guidelines
when printed are 340 pages.
- [Man] Did you print it on both sides?
No, I printed single sided.
(man laughs)
And if you have to read 340 printed pages,
and that's just the Core Guidelines,
(audience snickering)
then it's tough to know
what Modern C++ is.
So Modern C++ we get,
it's kind of the thing
where you know it when
you see it but you cannot
really say what it is,
but we have a great example
of what Modern C++ is not.
Patricia Ores had a great
presentation about two weeks ago.
C++ for Java developers or
Android developers, I'm not sure.
And this is not Modern C++.
Raw pointers, manual memory
management using operator new,
I think most people would
agree that even though
we don't know what's Modern
C++, this is old C++.
Okay, now we're gonna have to talk
about something a bit scary.
What is the scariest thing you ever read?
For me, personally, it was a email subject
I received in July.
(audience laughs)
But that was hopefully
just a one time thing.
So what the scariest
thing I read regularly?
It's this three line simple recipe.
To install library,
configure, make, make install.
To make it even scarier, when
they have pseudo make install.
(audience laughs)
There are basically, C++
since it has a history,
it's used for systems programming
and it has roots in C,
we often talk about the system compiler.
We have system libraries.
We have system include paths.
We have, there's one.
It belongs to the system.
Newer languages have package
managers and virtual environment.
So you can have one set up
per project which makes sense,
but in C++ it's common to have one
set up for your whole system.
We should have a way to work around that,
and I don't know if this is the best way,
but it works.
We use Docker.
You want to have your dependencies
and you want to perform your build
inside a controlled environment.
Everything happens inside a container.
Nothing gets installed
on your actual system.
Nothing gets left behind.
There's no pollution and everything
is kept nicely separated.
So for example in IncludeOS,
if you want to build
IncludeOS services without
installing anything,
not development tools, no
environment, then you can go here
and we have Docker containers to build
and to test IncludeOS services.
Or if you just want to,
let's say you are using
a version of Ubuntu where GCC
version is 12.9 something.
That was the most common
version in a recent poll.
Let's say you want, you
read a great article about
something new in GCC seven
and you want to try it,
then this is a very useful thing to do.
Here we have to commands.
The first one Docker pull.
That will fetch pre-made image
which has the latest version
of GCC and the second on that
runs that whole environment
like a normal executable
and the command line
looks a bit confusing because there you're
usually not adding all
that stuff when you,
usually you just use the last
three or two words there,
GCC source Cpp, but everything here
happens inside a container.
So there's no pollution
and someone named Jan
has written a really helpful and nice
introduction about this.
You can just copy and paste his examples
and you can test code in GCC latest seven
without installing GCC, it's great.
There are also many other
pre-made Docker environments.
Here is one where you can
select between client, GCC
and some other compilers
and the workflow is
pretty the same.
You pull an image that has
the environment that you want
and then you use it using a slightly
convoluted command line,
but nothing gets left behind.
The LLVM project actually has great
documentation for building.
Let's say you want to build a
more recent version of client,
then what your distribution is delivering,
then you should go and
check out this link here.
This gets even more exciting if you start
building your own Docker containers.
Unfortunately, that needs
to be a separate talk,
so you could look at the
Docker images from IncludeOS.
They are on GitHub open source.
You can use them for
inspiration and if you want to
chat with us we have a gitter chat room.
It's like slack only gitter.
Okay, so now we have
covered two objections
or two things that make it
difficult to learn Modern C++.
First of all, information
overload, but now we know
how to select useful sources
and the second problem
was the thing about dependencies
or compilers versions.
We just move that into Docker.
It's like our own sandbox,
but that's just things we
need to start learning.
We haven't learned anything yet.
Kevlin Henney, he is probably
one of the 10 smartest
people in the universe
and he has said that
&quot;the act of describing a
program in unambiguous detail
&quot;and the act of programming
are one and the same.&quot;
We can exploit that by doing
something most of you think
is really boring, but
it's tremendously useful.
If you want unit tests.
Unit testing is perfect for learning.
You have to state what
you think should happen.
This improves our intuition
about how to code the work
and it teaches us about
potential problems.
It's bite sized.
You can test one minor thing at a time.
You can be a granular as you like
and you get to test edge cases.
How many of you can say
unambiguously what will happen
if I have vector, it's
empty and prop from it?
(man mumbling)
It's easy to find out if you run the test.
This is a presentation.
It's about 10 years now
since it was recorded,
so the video quality
is somewhat depressing,
but I highly recommend watching it.
Kevlin goes through unit testing in C++
and you probably know that when,
obviously people have
always done unit testing,
but for a while it didn't exist
as a name or as a concept,
but then first the small
talk people started doing it
and then the Java people
picked it up with j unit,
and then people obviously
imported the j unit.
We had n unit in dot
net and we have x until
or whatever in C++, and
the problem with that was
your code looked like and felt like Java.
You had to write a lot.
You have to make classes for everything.
You have to write
convoluted search syntax.
It was boring, but with Modern
C++ and this is what Kevlin
talks about in this talk specifically
is when you got to C++ 11,
you had the facilities to write unit tests
in a much more C++ idiomatic fashion,
so it didn't look like or
feel like Java anymore.
This is a repository on
GitHub which has a comparison
of multiple Modern C++
unit testing framework.
I think catch is probably
the most used currently,
but all of these are really, really good.
I personally use lest, but the difference
between these frameworks is not huge.
Here is a first test.
That's what we need to figure out how
structured bindings work
and how does it work?
Really badly because we
always write the failing test
first because we wat to know
that our set up is working.
Then we fix the expectation
and this will pass.
This is so simple and
now you know the basics
of structured bindings.
So then you think hey,
that worked for a tuple.
Let me try doing that with a struct.
So you're writing your test case.
You create your structure
and you create some
variables and you use it
and you make sure that your
expectation matches reality.
This is fun.
I know, it doesn't seem like
it now because now you see
predigested tests written here
but when you're doing this
yourself and you're
exploring code and getting
immediate feedback of what
works and what doesn't work,
this is really helpful.
Okay now we figure out
okay, structured bindings.
Can we update the struct?
So again, we unpack the
variable into individual
variables that are
declared at the call site
and since we use an auto
reference, we try changing
it to a new value and we
expect that the new value
is not the same as the old value,
and again this does not work
really well as a slide show,
but if you try doing this of half an hour,
you find something you don't know.
You write 10 simple tests.
I'm pretty sure you will enjoy it.
You should do the simplest
thing that could possibly
work with this important caveat.
Okay, the technology world
changes really, really quickly.
I submitted the proposal
for this talk in June
and in it I mentioned somethings
I was working on in the spring.
We were working on getting
started examples for Docker,
a libclang Python script
to take a library and
create a single header file
version of the same library
and the libclang Python
script to general outlines
of libraries.
As you have seen this, or last week
Jan published a blog post
covered that really, really well
and about two weeks ago, Vittorio Romeo
wrote a rest program, but we forgive him
forgive him for using the wrong language.
It translates libraries
into self-contained
single header versions and finally,
if you have been downstairs,
you will have seen this poster.
I stole this picture from a blog but
this is SourceTrail.
They are in the poster competition.
You should go look at the poster and
examine this.
This is much more useful than anything
you can make on your own
and the license is really inexpensive.
So I recommend that.
So all those three projects
were overcome by events,
but the good thing is
they were overcome by
better things than I
could've made on my own.
Unfortunately for you that means that this
talk got a little bit shorter
than it was supposed to be,
but now you can relax, go
out, enjoy some sunshine,
but remember to come back
for Christopher's talk
in about two hours about the
teaching and learning C++.
It's up in 407 I think.
Are there any questions?
(applause)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>