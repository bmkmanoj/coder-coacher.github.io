<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Walter E. Brown “Programming with C++ Constraints: Background, Utility, and Gotchas&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Walter E. Brown “Programming with C++ Constraints: Background, Utility, and Gotchas&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Walter E. Brown “Programming with C++ Constraints: Background, Utility, and Gotchas&quot;</b></h2><h5 class="post__date">2017-10-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/n4ie7tPMXOQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well good morning everyone thanks very
much for coming to this talk as you can
see from the title about programming
with constraints
I picked this topic for a very simple
reason I believe that programming
thinking about constraints is going to
become a routine part of our daily tasks
and this is because it looks like we
have a new keyword namely requires
coming down the pipeline for C++ 20 some
of you may be familiar with it from the
concepts or concepts like technical
specification and I'll tell you all
about that we've made some progress with
respect to that and the purpose of a
requires keyword will be to introduce
what are called requires clauses and
requires expressions so we'll talk about
that but it turns out that although the
syntax obviously is going to be new to
C++ the ideas are not at all new and
accordingly in this talk I want to
explore what these ideas mean for us at
a technical level and how they have
affected our code of the past and how
they will continue to affect our code
today and in the future some of this
material is adapted from a paper I wrote
for WG 21 the Standards Committee
earlier this year you're welcome to go
look it up if you like and with that
let's start by looking at what I like to
call the bigger picture bigger picture
so let's start by looking at six terms
of art if you will a left column and a
right column take a moment if you'd be
so kind now this is not a quiz don't
raise your hand
got any answers but take a moment and
see if you can look at those and see
what they have in common
second column is headed with constraints
the first column is headed with
preconditions it's not an accident so
from my perspective what all of these
things have in common is the notion of
repressing requirements requirements
that some component often a function but
not necessarily just functions a
requirement that is imposed by a
component and that the component is
entitled to expect or assume if you
prefer always hold true and therefore we
as programmers can write those
components accordingly it's not
something we test for it's something we
assume to be true
so here's an interesting question how do
these terms of art differ why don't we
just have the word requirement why do we
have all of this vocabulary so it turns
out there are some differences among
them and the differences turn out to be
the way the component responds when the
requirement fails to hold when it is not
satisfied some of these requirements
affect the correct use of the component
but others affect the components
existence of course if it doesn't exist
you can't use it all right so let's talk
briefly about preconditions first right
as most of us I think know a functions
precondition is typically a predicate
that the function a C
goom's to be true when at the point that
the function is called okay that
typically means it holds at runtime but
nowadays we live in a constant four
world so that can move up to compile
time sometimes but the point is that
that precondition has to hold when the
function is called no sooner and later
we don't really care okay and it has to
hold each time doesn't have to hold in
between but at the point the function is
called the precondition has to hold now
for example
I think many programmers believe that
let's say from the standard library the
square root function in semantics I
think a lot of programmers would believe
that there's a precondition that the
value you supply must be not be negative
that's not true
the function has perfectly well-defined
behavior if you happen to give it a
negative number it gives you an arrow
for example that's well defined behavior
so that is not a precondition all right
a function you know a lot of programmers
write their functions and they test for
the validity of the precondition if you
do that you don't have a precondition
pre as in before you make the call it's
not the functions responsibility it's
the caller's responsibility okay the
standard the C++ standard and this is
not new this has been there all along
and there's the citation if you choose
to look it up if you call a function
when the precondition fails to hold you
get undefined behavior it might do what
you expect but you're not entitled to
account on that it is undefined behavior
to call a function out of contract we
say so you're probably aware that
precondition is part of what we call a
functions contract with its clients we
have some relatively recent new
nomenclature I'm not sure
why we needed this but if you have a
function that has no preconditions we
say that it has a wide contract while is
in wide open if there are any
preconditions one or more then we say
the function has a mirror contract from
my perspective I can tell the difference
between zero and anything bigger than
zero but that's the nomenclature we use
these days but this is really only
tangential to our main topic of the day
which is constraints so I'm not going to
talk very much more about preconditions
except you have noted the distinction
but here's a little breadcrumbs for the
future keep your eye out for and you
attribute sometime in the future maybe
C++ 20 maybe C++ 23 not sure still in
progress it will be labeled expects okay
now how do constraints differ from
preconditions well a constraint is
always a compile time predicate always
always always it's associated with some
program component could be a function
could be a template for example could be
any kind of template could be a variable
template could be a class template
doesn't matter can have a constraint on
it and the constraint must be satisfied
there's no what if it must be satisfied
or else now I suspect you're all
thinking the same thing that I am or
else what right or else the component
won't and mustn't be compiled
effectively it will not exist if the
constraint is unsatisfied will not exist
so if it's a function you mustn't call
it it doesn't exist
you can't take its address it doesn't
exist you can't use it but
fact that it won't be compiled is not
necessarily in and of itself an error
you might get a consequential error you
try to use it and it doesn't exist
that's an error that's not the fault of
the component that's your code that's
trying to use a non-existent component
okay but we all have some experience
with this in this particular regard it
is not unlike conditional pre-processing
just because something is not compiled
does not necessarily in and of itself
mean that there's anything wrong this
may be a desired outcome depends on what
the predicate is right but when you're
talking about it constraint and if you
take away nothing else remember this if
the constraint is not satisfied the
component will not be compiled some
cases may give you a diagnostic it
depends on how it's how its coded but
not necessarily and that's not
necessarily a bad thing that may be a
desired result okay you may have an
overload situation for example you have
multiple constraints one of them is
satisfied the others aren't you can only
call the one that exists all right now
I'd like to point out that this is not
at all new I know I said this before but
here are some examples C++ is all about
constraints from day one I mean you can
say this about any language that
features strong type checking and of
course C++ is famous for strong type
checking right well when you assign a
type to a variable well you make that
binding you are imposing a constraint on
that variable a constraint on how you
can use it you can't assign a string to
an int that's a constraint violation
that won't compile will it that'll give
you a diagnostic okay so we are all
familiar with constraints but perhaps
have not thought of it in quite these
terms before I'll give
some more examples shortly okay the era
that we refer to as C++ 98 c plus plus O
3 limited us to sort of these implicit
techniques but we have had newer
technologies now for almost a decade
because C++ 11 and even before that if
you count TR one for example we have had
some new tools for let's say explicit
programming with constraints for example
we got static assert and C++ 11 okay you
put that inside a component that
component will not compile unless that
predicate is true and you'll get a
diagnostic of your choice unless you're
programming in C++ 17 where the literal
became optional I had a little something
to do with that we got in C++ 11 in the
standard library we got enable if
typically used in a spin a context we'll
talk a little more about that shortly to
prevent the templates instantiation and
of course if it's not accentuated it
can't be compiled the constraint fails
it won't be compiled okay we got
expressions venae which is not as well
known but some expansion of the contexts
in which you can apply such techniques
before then we had a limited number of
contacts now we have a lot more ever
since C++ 11 and even more recently we
got more good stuff in this particular
area C++ 17 has void T in the standard
library I had a lot to do with that and
will not speak about that further today
but if you're interested please go look
at the video of my talk here at cpp con
from 2014 that's when I first sprung
void T on the world the last half-hour
approximately of it's a two hour talk
and by the way thank you to the 40,000
people who've watched that that's an
unbelievable number considering you know
my name isn't be RNA or or herb you know
but thank you all we also got in C++ 17
the contacts per if spelled if Const
expert but the feature is called context
for if and with it you get discarded
statements the predicate doesn't hold
that part doesn't get compiled okay and
in we've been working on C++ 20 already
C++ 17 by now is old hat for the
Standards Committee we've been working
on C++ 20 now for six months or so and
we have recently added to the working
draft and that's freely publicly
available if you choose to download it
if you're not used to reading legalese
you probably don't want to read the
actual standard it's a 1400 page legal
document is what it boils down to it we
were very careful with the wording
because in some jurisdictions it
actually has the force of law it gets
incorporated by reference into contracts
and things like that so putting out a
C++ standard is like negotiating an
international treaty in many respects
it's a little surprising but we've added
the concepts requires keyword and of
course I'll talk much more about that
later on so let me start by talking a
little more about what I'm going to call
pre-modern constraints so suppose yes
notice it's down near the bottom this is
how we used to have to write the code
and by the way this slide gave me more
trouble in PowerPoint than any other
PowerPoint really wants to show things
from top down okay so we need a C++
programmer to fix that but okay so let
me use this exam that's gonna be a
running example we'll revisit this two
or three times okay suppose what I want
to do is just to you know give me a
value and I'll raise it to a given power
where the power is known at compile time
so you know a little simple bit of
metaprogramming but you know no big deal
and the algorithm that I want to use is
one that'll give me logarithmic behavior
in terms of number of multiplications
the naive approach I mean what you teach
kids start with when they first learn
exponents is you know you multiply at so
many times you raised to the nth power
you multiply you have n minus
one multiplications okay well we can do
better if you want to say X to the 8th
you square X square that you square that
you're done three multiplications
that's logarithmic behavior so suppose I
want that algorithm it turns out the
easiest way the code that is with some
specializations I print a primary
template and a couple of specializations
okay but I want to make this a function
and you can't partially specialized
functions in C++
so what technique did we have to use we
have to dispatch to something else that
you can partially specialize right so
you know you got to declare that up
above right so it's my helper that will
implement that login behavior so I'll
have a primary template with two partial
specializations
there's the primary and it turns out it
will only operate on values of n that
are odd now that's not obvious by
inspection but it'll turn out that the
specializations will handle all the
evens so the only thing left for the
primary will be the odds but please
notice the stuff in yellow in particular
notice the third template parameter a
bool not named I never have to refer to
it so it doesn't need a name and the
predicate is the answer to the question
is an an even number okay so now the
specializations right if that's true so
here's where evens get handled if that's
true we do the naive you know square the
thing and then reduce n by half except
you need another case to handle the case
of zero which is even but I don't want
any multiplications so that's kind of
how you would do this thing and and
there you know you can play some tricks
and do a little bit better job but this
is kind of straightforward to look at
this is how what we would do in C++ 98
but we can do better and I'll return to
this example twice more but those are
constraints when you specialize a
template you're putting a constraint on
that specialization the constraint isn't
met that specialization won't be
compiled okay
now in C++ 11 I mentioned we got enable
if among other things if you're not
familiar with it let me give you a real
fast overview it's a metaphor
you handed a predicate you handed a type
the predicate is true you get back an
alias to the type the predicate is false
there is no alias this is a feature you
can only do in meta program you can't
write a function that refuses to give
you an answer I mean yes you can throw
exceptions you can calls to terminate
things like that but if you have a
normal return you can't have a function
that gives you no answer but in meta
programming you can't and what does it
look like well it's a primary template
and one specialization I've chosen to
have the primary handle the case where
it's true and you'll notice there's the
alias using type equals T and then the
specialization when the predicate is
false a constraint there is no alias
empty braces right so this is what
enable it this is how it's almost always
implemented I mean you can flip the role
of the primary and the specialization
there's almost no other way to implement
this and you can say ok that's pretty
straightforward but what good is that so
what well
first think about one thing think about
a call to that meta function where the
predicate is false but you're asking for
the type anyway as if there were an
alias
and most programmers who have not seen
this before would say well that's got to
be an error well it is sometimes an
error and welcome to Sven a now what
does that got to do with constraint
programming well we have to talk about
Savini a little bit first and I know
I've spoken about this before and some
of you are familiar with CNA but there's
a new wrinkle in C++ 17 that you may not
yet have encountered so let me go
through it at a sort of high-level okay
so there are two main steps in
instantiating any template declaration I
mean yes there are lots of more details
and don't propose to go into but there
are two principle steps and the first
one has got to be what are my arguments
what are the template arguments okay so
how does the compiler determine either
well you can see it's up there sometimes
deduce sometimes just get your hands on
how do you obtain the template argument
and it turns out there are now four ways
this can happen there used to be three
we now have four new and C++ 17 okay and
they can arise in combination if you
have multiple template arguments one can
come about this way one can come about a
different way okay so what are the four
well I've labeled them ABCD obviously if
the client supplies the argument we take
adverb eight and we're done okay
otherwise if it's a function template
the compiler can go and you know look at
the actual arguments in the call and say
okay what are the types of those
arguments and deduce and get the get the
template argument that way see which is
new for 17 if you have a class template
we now have a feature called deduction
guides previously if you wanted to
declare a stood vector you always have
to say stood vector of some type
during instance to the victor a double
stood vector of my type you don't
necessarily have to say that anymore the
compiler can figure it out under certain
circumstances if you provide the
appropriate initializers okay now this
is off topic so treat this as a
breadcrumb something you might want to
look into for the future but this is new
and the final fallback if none of the
above work maybe there are some defaults
in the Declaration of the template okay
so we now have four possibilities for
the compiler to consider and this is all
still the first step of instantiating a
template declaration so what's the
second step well now that you know what
the arguments are it's time to use them
and this is what's referred to as the
substitution step every placeholder
which are the template parameters has to
be replaced by the corresponding
argument okay all right so there are two
possible outcomes all right I mean
simply put it can go well or it can go
ill all right
so if all goes well you end up with a
well-formed declaration and you just
proceed normally I mean maybe the next
step is overloaded resume whatever then
whatever comes next in your compiler
just keep going no big deal but what if
it doesn't work out if the resulting
declaration is not well formed and of
course we call that ill-formed
it is considered not viable and that's a
term of art in the standard it's not
viable why not well in this case it's
because of substitution failure things
didn't work out and what happens it's
not an error
that component that declaration is
silently
discarded there is no diagnostic in
other words substitution failure is not
an error Savina the term was coined in
the early 2000s by de vivre and award I
believe okay so that in a nutshell
that's how CNA works and there's some
other speakers at this week who are who
will talk more about CNA I'm told so you
know what the question is what is this
good for you know how does this affect
programming with constraints well the
most common use of venae is via enable
if so I'm about to show you a set of
three functions constituting an overload
set and if you look at the Capretta cuts
at the constraints you will find that at
most one of them can be true and the
other two will not hold will be
unsatisfied which means those two will
be silently discarded and I'm left with
exactly one so let's return to my
example okay three overloads to do those
you know those three parts of my
algorithm all right if n is 0 return 1
but notice enable if requires here that
n be exactly 0 ok well what if it isn't
well then there is no return type for
this function enable if it has nothing
to return and the declaration becomes
ill-formed and is silently discarded
alternatively here's an overload of same
function you know same function
signature it's an overload same name but
with a different predicate this time if
n is nonzero
and even do it this way if that doesn't
hold that's also going to be ill-formed
for exactly the same reason and it won't
be compiled silently not a bad thing
because I'm going to want the case when
it's odd so I've written my constraints
so that they're mutually exclusive at
most one will be well-formed the other
two are silently discarded okay and this
is a typical use for enable if in the
standard library and of course I said
we've had this since these plus plus
eleven we've actually had it since tr1
but not everybody used to you are one
okay so programming with constraints is
really not new so why aren't we happy
with enable if I mean what's wrong with
it well not nothing really but I mean
let's be honest there are some
limitations to this idiom I mean for
openers it requires a template you can't
apply it to non templates if you want to
apply it to a function that's a
constructor it's a little more
challenging because there's no return
type so where do you put the enable if
you can make it an extra argument maybe
but that's visible to the user you can
make it an extra template parameter but
that's visible to the user you get the
idea it's a little more challenging okay
there's some design issues all of a
sudden okay and let's be honest further
what you get is not exactly transparent
okay if this were the first time that
you encounter enable it you might say
you know what the Dickens is this what's
going on here because you really have to
understand the idiom to be able to read
code like that once you do it's fine but
it's like anything else you have to
become familiar with it people like to
use the word weird
that just means unfamiliar all right
that's weird
that's because you don't get it yet once
you understand it it's no longer weird
right it's familiar and it turns out we
have newer techniques which brings us to
what I've called modern and postmodern
constraints
so C++ 17 as I said gave us context per
if and along with it we got what are
called discarded statements remember my
theme if the if the constraint doesn't
hold it's not compiled here they
explicitly become discarded statements
be a little bit careful if you haven't
used this before there is a requirement
that even the scarda statements have to
be well-formed that's a little stronger
than is actually true but that's a good
guideline to start with okay so for
example don't put a static assert in a
context per if here's a trivia question
for you do you know what part of speech
is a static assert it's a it's a it's a
declaration it's it's considered a
declaration if you look at the standard
there's your C++ trivia for the day okay
so you know every branch of a Const
expert if has to be at least possible
okay so it differs from like pound if in
this regard if it's not there you know
we don't really care so using a context
for if we get I think what I think is
the most readable version of my
algorithm so far it's one function as it
should be I don't have to mess with
overloading and my constraints are
embedded in the context for if right if
Const expert and is a zero returned this
and the other becomes a discarded
statement it's not there when n is zero
and if n is not zero
this branch is a discarded statement
it's not present okay else if it's even
do this else it must be odd do that so I
like this a lot
and I hope you consider it as I do a
great improvement on our coding style
and technique
but it still doesn't fit all situations
it fits a lot but it's still not a you
know a universal solution which brings
us to concepts only because we published
something called the concepts technical
specification TS this is a feature that
started out life being called concepts
light somewhere along the way we drop
the light part of it so maybe this is
now concepts heavy I'm not sure but it's
the concepts technical specification and
that's what formally has introduced the
requires keyword and brought us what is
called the requires clause that was the
first specification and I'll tell you
how that's been progressing in the
Standards Committee it wasn't quite
right already for C++ 17 part of it was
the part I want to talk about I thought
was ready for C++ 17 and I proposed that
we split it and take what was ready and
you know leave the rest for later I got
shouted down there were some people who
just took a scorched-earth approach all
or nothing
well they got nothing but that's I
consider that very unfortunate
nonetheless as it happens a requires
clause can be applied to any kind of
template any kind of template variable
template alias template class template
of course function template okay any
kind of template but also to an ordinary
garden-variety functional status with
lambdas is a little unclear at this
point but I'm I'm hopeful that we'll get
it in that context as well okay if you
apply it in the in in the case of an
ordinary function we have special moment
lecture we call it a trailing requires
clause because it follows the typical
declaration of the function okay like a
trailing return type it actually follows
that
okay so here are a couple of technical
details about requires a recharge clause
induces constraints now in a technical
sense
I've been slightly abusing the term
constraints we now are going to get a
technical definition of constraint now
let me start by drawing an analogy for
you okay
a lot of C++ programmers informally
speak of they say they have a lambda and
at some point they call the lambda well
that's technically wrong you can't call
a lambda when you evaluate when you know
when you run you the lambdas evaluated
you get a kind of function object that's
what you get when you evaluate a lambda
and that function object has an
appearance operator that's what gets
called that function object is known as
a no no no no there's a special term for
this closure when you evaluate a lambda
you get a closure it's not a function a
closure is a special kind of function
object why do you need that because you
have to do the captures you need a place
to put the stuff you've captured that
goes into the function object into the
closure okay so it becomes closed okay
that's why it's called the closure so
what does it got to do here
well technically when you write a
requires Clause you're not writing
constraints you write a predicate and
the compiler will turn that into the
appropriate constraints so we say the
constraints are induced by the requires
clause okay it's a slight shift in
nomenclature I'm gonna stick with the
informal I'm gonna call it a constraint
but please be aware technically the
constraint is what the compiler turns
this into
and of course if the constraint is not
satisfied this component to which you've
attached the requires clause will not be
instantiated or compiled in any way just
it won't exist okay that component
simply is ignored much like meaning the
machinery is slightly different but the
outcome is very similar okay it won't
exist that's the theme of this talk the
constraint isn't satisfied the component
won't exist and that can be a good thing
as we've already seen okay
you just have to be careful in your code
don't use a non-existent component
that's an error well that makes sense
it's always been an error call a
function f you don't have a function f
that's an error same idea what comes
along with this is a new consideration
known as subsumption because constraints
can be related to each other one
constraint can subsume another it's like
a subsets relationship and this is a way
of comparing constraints because one
constraint can be more constraining than
another think about my example I have a
constraint and is even I have another
constraint and is zero well in that case
n is also even but this is more
constrained okay and this can be
important the compiler can now tell
which is you know comparing two
constraints which is the more constraint
and this is one of the reasons why
technically you don't write two
constraints the compiler does it puts it
into a form so it can do this kind of
analysis okay okay
notice please nothing I have said relies
on concepts per se
yet this is all machinery that's
necessary for concepts doesn't require
that we use concepts at all I have been
programming almost exclusively with
requires clauses for over three maybe
four years now
they're wonderful I love them I have not
written the concept in three and a half
years that I can recall this is the kind
of programming that I do doesn't require
concepts now concepts are better in a
certain sense and that gets into
philosophical issues of what makes a
good concept and as far as I know nobody
has yet really addressed that to any
detail we have some ideas of what makes
a good concept nobody has ever set forth
a set of guidelines yet a good concept
should satisfy criteria ABCA I'm waiting
for that but I'm probably not going to
be the one to do that but programming
with constraints it's wonderful here's
an example suppose I have three
different transmit functions and of
course transmission relies heavily on
endianness right I mean there are other
ways of coding this but imagine for a
second but I think you'll agree this is
an unusual overload set how come because
they all have the same signature you're
not supposed to do this well now you can
with the requires Clause how can that
work the answer is almost too simple the
requires Clause becomes part of the
signature so now you can tell them apart
again all right
and what happens when you have one that
has no requires clause and another one
that we've got answers for all of those
interesting questions okay so as you can
imagine by now only declarations whose
constraint is satisfied constraint in
the informal sense go into the overload
set of viable candidates and then
overload resolution takes over and so on
and so forth okay and if the constraint
isn't satisfied it doesn't exist so it's
not an issue okay now since most of us I
think are new to requires clauses let me
tell you a little bit about what they
look like you can put any predicate you
want after the keyword requires any
predicate you want and in my case a
particularly useful kind of predicate is
a type trait right I want this function
only to be operative or this template to
be operative only if you hand me an
integer type or a floating-point time or
this or that or it has to be copyable
or it has to be movable etc okay and
those are type traits so I personally
find those useful but I've used
constraints of many different kinds the
point is any predicate works now if you
happen to lump a bunch of requirements
together and give that collection a name
you have a concept so if you've done
that then you can refer to that
collection by name you don't have to
repeat all the pieces of that collection
there's a form of factoring right so if
you have a concept and it happens to be
named C just to keep it short for a
moment then you can say requires C
brackets T and it looks like a template
instantiation and in some sense it is
isn't quite but it's similar okay you
can just say require C of T or there are
some shorter forms that are possible
Alexander stepping off for 20 years now
has been lobbying for us to be able to
write template C of T
which is absolutely equivalent to the
longer form class t dot dot dot requires
C of T okay that's what I mean by a
shorter feel there might be others as
well that's a little bit up in the air
right now this is a syntax that we've
been using for some time and this is
particularly one of particular interest
to Alexander step enough if you go
online and watch his videos on YouTube
which I highly recommend first of all
set aside a week or two of your time
because not only are there a lot of them
they are deep and you will want to think
hard about what you're hearing okay I
mean the man was a first class I mean
he's not retired that's why I say was
first class mathematician one of the few
people I know who've read Euclid in the
original Greek one of the few people I
know who read you CLE so what I'd like
to do now is to walk you through a case
study that happened to me early this
well late last year and I wrote it up
early this year okay like so many things
I stepped in this okay since I've since
I've been retired I get to play I get to
work on what I want to work on and I've
always been interested in the standard
library and I never had the chance to do
much with the standard library of my own
so I now have a private implementation
of what I call the interesting part of
the standard library and I'm not going
to do it all ever I'm not interested in
all of it but I'm interested in mostly
in utility components is that been a
library writer for most of my
professional career
so I write things for other programmers
to use little certain knack to that okay
so in particular I mean how much more
basic can you get then stood swap right
I mean we should be using stead swap a
lot more than we do a lot of times you
should not use assignment you should use
then swap if you do things with
concurrent programming do the work and
when you're ready
get the lock swap it swap your result
into place and release the lock so stub
swap is an incredibly important
component it is given WG 21 the
Standards Committee headaches
ever since we brought it in to the
standard because there are types that
want to customize how they swap right
imagine how you swap a vector you know
you don't change everything from one
vector to the other you take the pointer
from here and this pointer from there
and you swap the pointers you've done
it's very fast so we want to be able to
customize swap so it's what we call a
customization point but you know this is
that's another talk but what I did is
I've implemented
swap for our purposes twice I've done it
many more times but imagine that I did
it twice once I use let's say the now
classical enable if technology and the
second time I used only this requires
technology okay and it turned out the
bodies of the function would you're not
very interesting it's a traditional
three steps whoa right you know how I
used to teach swap to freshmen you got a
little kid who likes to drink chocolate
milk you got another little kid who
likes to drink white milk
they all have their cone cups you
accidentally put them in the wrong cups
how do you swap the milk and get a third
cup yeah yeah right
three steps Wow every freshman
understands that I I don't know maybe
four maybe freshmen like chocolate milk
I'm not sure but stud swap is absolutely
fundamental so I did this a couple of
times the function bodies were the same
but the function introductions obviously
were different because one had the
enable if the other one had requires and
there was no overlap okay and then of
course I wanted to be sure that I did it
right that it passes tests and instead
of writing my own tests I used publicly
and also privately available test Suites
for example clang as a test suite GCC
has a public test well you know I run my
stuff stuff through those test Suites
something's right now and I have access
to some private test Suites as well and
I was completely surprised because I
ended up with a subtle total on the
totally unexpected difference in the
behavior shockingly surprised let me
walk you through it if I may so let me
just refresh our memories this is what
the standard says about swap this is
what the declaration has to look like
okay I've alighted the stuff in the no
except clause that's not really relevant
to this discussion it's messy okay and
then and I'm quoting directly look at
the highlighted yellow words please we
call things like that words of power
they have a special significance in the
standard okay it's a formula you'll find
that over and over and over again if you
read the standard and it specifies a
special kind of constraint it tells the
implementer something he has to do these
words mean
we need spin a used to mean Savini now I
say seen a like behavior namely this
swap must not be instantiated if the
type is not movable now please recall
moveable implies copyable you don't have
to have new functionality if you have
copy functionality it's considered
movable it's also considered movable if
you have move operations if they're
available we'll use them if they're not
available with fallback to copy so
that's all subsea okay but we must not
instantiate this if we don't have move
ability
okay and if you try to call it and your
type doesn't have movability you can't
do a swap
using stood swap that makes sense okay
so here's what I did and I'm only going
to show you the declarations because the
bodies are not really very interesting
for our purposes so here's what the
enable lift looks like all right enable
if and the predicate is is movable and
if it is movable the return type is void
and if it's not movable there's no
return type it's ill-formed etc won't be
compiled okay so that's what I call the
classical way of satisfying the
constraint right and just to spell it
out in detail the enable LIF is the
return type they're two possibilities it
holds is basically what I told them you
get void it's well-formed everything's
fine the predicate doesn't hold there's
no return type ill-formed venae gone
everybody with me yeah okay good then I
did it again and the second one I mean
this should be pretty straightforward
there's a requires clause right I mean
this is a template notice where it goes
it's a requirement on the template
parameters so it goes after the template
and before the function declaration
right requires is movable and there's an
ordinary return type now right it's the
requires clause that induces the
constraint I'm meeting the same
constraint is movable and again there
are two possibilities if the constraint
is satisfied the declaration is
well-formed it becomes viable all is
fine if the constraint is not satisfied
declaration is non viable and it's
discarded in a scene a like way it's not
exactly CNA but you get the same net
effect cool and then came validation as
I said I ran through some test Suites
swap work like a
champ but the test suite also had a test
for a trait in the standard library
named is swappable I hand you a type and
you tell me yes or no
you can call swap on your type not
necessarily stud swap there is a swap
that will work with your type
that's what is swappable is for enable
if worked like a champ requires clause
failed how did it fail it's kind of now
here the details right I'm a condensed I
had to change some of the names to
shorten them so that they fit so the
test has its own namespace and s in this
case it introduces just a trivial type
named a and then in the same namespace a
swap now right now there's no overload
here because they're in different
namespaces so what happens when you put
them into the same namespace and you can
do that with a using declaration you can
do that with a I mean there's several
ways to do that okay so consider these
three statements in a row let's declare
a pair of variables of this new type a
and B let's bring the standard swap into
scope what they're using and now let's
call swap unqualified okay and this
reads like a final exam for like a
second term freshmen or something right
so what's gonna happen now this is not a
quiz I'm not here to tease you or
anything like that it goes like this you
get two lookups you get ordinary or
unqualified lookup and of course it's
gonna find stud swap because that's in
scope directly it's the only swap that's
in scope and then ADL kicks in and it's
going to find the swap in the associated
namespace because the variables come
from namespace NS and there's a swap in
there so we go look in there and we find
it now I have an overload set so now we
have to do
resolution and part of overload
resolution which finds both to be viable
so which one's better and the part of
overload resolution that answers this
question is called partial order does
you want to put an order to these which
one is better all right and the answer
is neither it's ambiguous all right
can't make the call it's ambiguous and
the actual line that tested this was a
static assert and notice the negation in
the predicate the test passes if the
type a Kappa Kappa is not swappable
right because of ambiguity right the
test passes if it's not swappable and it
turns out that works fine for the enable
if and it fails for the requires so
what's different requires clauses bring
new rules or a new rule okay it's a new
tie breaker it's along the lines of what
we have today more specialized or
constrained okay you have to requires
two candidates they're both viable
look at the constraints which one is
more constrained that's the winner
subsumption remember if one subsumes the
other it's more constrained that's your
winner okay so in my second
implementation stud swap was constrained
with a requires Clause therefore this
rule kicks in even though the private
one in the namespace was not constrained
the rule still kicks in you think about
an unconstrained template is like saying
requires true it's always satisfying
okay so the new rule applies
the test code is no longer ambiguous but
the test expects ambiguity and therefore
the test now fails I stepped in it this
was not expected okay now quick caveat
what I'm presenting of course is not yet
in the standard look at the next
standard that we're still working on
right but this works today has worked
for many years with GCC - F concepts
okay
recent developments we've taken much of
the wording not all but we've taken a
lot of the wording out of the ts out of
the concepts ts it's in the working
draft it's already been tweaked quite a
bit it's probably going to be tweaked
some more because discussions are
ongoing we've got a few years before
sequels plus 20 so what I'm telling you
today might still be true or it might be
slightly or not so slightly different I
can't predict the future I don't have
that kind of crystal ball but the
principles I think will hold up namely
C++ core language constraints when we
get them are more than just a language
replacement for enable if all right some
people would say much more if one is
present the constraint comes into play
whenever you instantiate a template
whenever you use the name of a template
it comes in during overload or
resolution as we've seen especially
during partial ordering as we've seen I
mean here's an example of what you can't
do so here's a trivial function where
the constraint is never satisfied right
require is false so that just doesn't
exist so of course you can't call it
you can't take its address you can't
even say deco type of that term it
doesn't exist it doesn't have a type
okay you must not use a component if it
doesn't exist
okay and I'm quite confident that that
will always hold true okay constraints
become an integral part of a declaration
traditional declarations that aren't
constrained this way namely what the
requires Clause aren't quite the same
you get an extra set of rules for
overload resolution for example we have
to be aware of those rules and it's
company you know it's become clear to me
that many of these details maybe most of
them excuse me are not yet very widely
well understood and even among experts I
mean there was a recent posting I'm
withholding the name of who did it an
expert someone I consider an expert in
C++ his advice is almost right okay you
have to do something out of the ordinary
to see the difference but it is as we've
seen detectable as I said I stepped in
it okay so Andrew Sutton who is actually
the editor of the concepts technical
specification he's here at this
conference I think he's speaking later
this week he wrote me at one point and
he said this among other things that if
you add constraints to an existing
overload set that's unconstrained it
potentially changes the result so you
need to think about that very very hard
okay you can't just replace enable if
with requires without thinking about it
because there is a tiny detectable
semantic difference and they make no
difference it usually will make no
difference but it potentially can make a
difference vendors of the standard
library are free to do this today
there's no rule that says they have to
wait for C++ 20 to make use of this
technology it's in compilers already and
boy can it make life
easier for standard library and other
library implementers it's a wonderful
wonderful tool and I recommend it highly
as I say I've been using it for years
near exclusively but as I said it's
detectable and it has the potential to
affect code in certain edge cases okay
you may have to go on a scavenger hunt
to find those cases but they exist as I
thought as I shown and with that thank
you very much do we have a couple
minutes we have a minute or two for
questions if you have a question please
come to a microphone anybody that looks
like we got two all right I'll do my
best sir okay so um thanks for the talk
first of all I'll buy sure you mention
that in order to be able to tell the
different overloads with requires class
apart yes the requires actually becomes
part of the signature yes does that also
imply that during name mangling the
expression in the requires gets mangled
into the name of third function the
standard does not mandate anything about
mangling that does sound to me like a
viable implementation technique if
potentially awkward but I'm not the
right person to address that okay okay
if this becomes standard the compiler
writer has to make it work
okay thanks yeah we just say how it has
to behave you figure out how to get it
done sorry I had a question about the
example you showed in this circumstance
whereby one would add a requirements
clause to a function that had no
template arguments yeah if on e and then
you disclose there which had a variable
whose or yes something that was called
local and it was totally unclear where
that would come from yeah and I should
have I should have addressed that at the
time forgive me for interrupting you
assume for the moment that there is some
kind of global by that name okay okay
and that there is an emu you know those
were sorry that I expected I'm sorry I
should have mentioned that the the
working paper act
has byte ordering primitives in it now I
don't know if they'll stay in the
present form but I try to use the names
that we have for the moment so so the
functions that we be selected might be
determined by some global variables of
constant variables which are constant
values which are determined at compile
time what does that sound like a great
idea depends how you use it okay I mean
does a saw sound like a great idea I
wouldn't give it to a five-year-old okay
one tip I you know I'm hopeful that you
will all go and share this knowledge
with your colleagues I'd like to offer a
suggestion if I may think about your
audience for people like us who've been
in the business a while
I've presented this material what in a
direction I call bottom-up for people
who are novices or apprentices think
about presenting this top-down they
don't need to know all the ins and outs
they just need to know what the
behaviors are and how to use it and when
to use it
they don't need to know that this is
constraint programming I've got some
hidden slides by the way so when you if
you go and download what I'm going to
upload you'll find a couple extra slides
that I did because I was gonna run out
of time one final question I'm sorry I'm
gonna run out if you want I'll be happy
to talk to you in the hallway thank you
do you anticipate that requires will
completely subsumes finais or there are
some set of problems you will still
useful I think there are still a role
for spin a I believe it's going to
diminish but we have large code bases
that aren't going to go away anytime
soon so we'll be dealing with Savini for
a very long time to come but moving
forward like new code starting in C++ 20
I would assume that once the word gets
out that requires clauses we'll take
over from CAA it somehow seems more
intuitive I hope you'll agree with me
anyway thank you all very much our free
Christmas</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>