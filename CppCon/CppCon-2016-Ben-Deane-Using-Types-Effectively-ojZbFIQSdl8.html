<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Ben Deane “Using Types Effectively&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Ben Deane “Using Types Effectively&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Ben Deane “Using Types Effectively&quot;</b></h2><h5 class="post__date">2016-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ojZbFIQSdl8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning so using types effectively
so what does that mean is the first
question so if you look back at the
recent evolution of C++ from one point
of view is largely about increasing our
capabilities for dealing with types and
that means things like massive expansion
type traits with eleven things like
deckle type auto we've got null putter
now and scope thenahms we've got the GSL
giving us more type safety we've got the
concept TS coming up so one of the
things that you hear a lot at
conferences lately is like how c++ is
getting things from functional languages
so i wanted to reassure you that this
talk isn't about any of these things
which you might think about when you
think about functional languages and in
particular not the M word but functional
languages like ml and Haskell do have
lots of things they can teach us about
types in particular using them
expressively and effectively and a key
thing is making illegal states
unrepresentable
and making illegal behavior via type
error and so that was kind of the
evolution of this talk see purpose is
definitely moving in this direction in
my opinion and so well the first thing
question is what is a type so one of us
this question I get lots of different
answers some potential answers might be
you know the original one of the
original motivations for putting types
in C that Dennis Ritchie had was that
the new hardware was supporting
floating-point and so his compiler
needed a way to figure the difference
between integers and floating points to
know what code to output a lot of people
because we're C++ programmers and
because we're concerned with performance
and because we come from the background
of C we tend to think about types as
within the very representational manner
I the way the data is stored in the
memory another way we can think about it
is sort of the object-oriented so the
view of types so characterizing what
operations are possible and perhaps what
are not possible or determining the
values that we can assign
into something or in some way
determining the semantic meaning of data
now just note about the representational
viewpoint when my friends tweeted and
gave me grist for this talk and said or
Facebook and said only lure would have
one equal equal true evaluate the false
hashtag want my day back this is back in
April so of course I replied how can one
be equal to true in my best you know
functional programmer hat one isn't a
jitter is a boolean
they can't be equal Liu is correct here
and it's your view of the world that's
warped I put a smiley face we still my
friend so in this talk I want to take a
little look about how just a little bit
of type theory can help us think about
better api's and more closely modeling
our data and so I want you to think
about a type of being a set of values
that can inhabit a given expression and
today then it might be finite like a
boolean or infinite like a vector but in
some sense a type is characterized by
the cardinality of the set the number of
things we can fit into that bucket and
types types in this sense are static
they are expression things that
expressions have and therefore things
that programs have so this is this might
with jokes it talks a tutorial because
you're going to do some work here so
let's play a little game to help get us
thinking about types so I'll tell you
your type and you're going to tell me
how many values it has so how many
things can fit in that bucket and there
are no tricks here if it seems obvious
is because it is shout it out I'll try
and listen so types of sets of values at
level one of the game how many values
here too right too obvious right good
then we'll one traditionally easy how
about now 256 yes you're very smart
crowd of course you are you're at seed
pecan but let's get a little harder how
many values now I heard zero I heard one
I'm still hearing zero and white so
there's some confusion there's some
disagreement it so there's a proposal to
make it a regular type it's true you
certainly can't instantiate a value of
void but you can return it for a
function here's another way of making a
type that has zero zero inhabitants and
here this rather curious construction is
yet another way yeah there's some
confusion because you can return from a
function but you can't instantiate a
value of type void so you know maybe
basic had it right basic had this
function versus procedure thing people
of my age tended to start with basic
maybe basic was correct there all right
so some confusion about void but I'm
going to say zero for this talk how many
values now one yes I heard one one any
value of this type you can make is in
the signature ball from any other value
so it's one how about now 300 or 256
someone says a representational thinker
in the in the room the answer is three
so if you were to make it true this is
in the memory this is a byte right so if
you were to make a value you could cast
it to a fire swamp danger and it could
be effectively at that point you would
have broken the semantic link between
the type and their absent ation so I'm
saying that's not a member of this type
this type has three members and that
this situation is somewhat similar to
what we think of as an unconstructed
object so after the memory has been
reserved but the constructor hasn't yet
run the representation is you know what
you're going to the memory is there but
you haven't yet turned it into an object
you haven't a turn into a member of the
type okay so three
and now how many values are there of fou
what can we say I yes I heard
cardinality of T so we can say about
this type food that it has as many
values as T has whatever that might be
for it whatever we instantiate it with
it's going to have as many values
alright so that was level 1 and already
we're seeing so if we think about types
as being number of things we can put in
the bucket then we can say that these
two types are equivalent and I hope we
can all agree on this point you can do
anything with a pool that you can do
with an inator button in this case so
let's move on to level 2 or you think by
aggregating types so how many values are
there of the pair 512 because you
multiply 22:56 by 2
yes how many values of foo again again
same thing 5 4 so exactly equivalent to
the pair and now how many values of the
tuple 8 again because 2 times 2 times 2
now how many values of foo are there all
right cardinality of T times come out
give you yes good you're very smart
crowd this is great that's the end of
level 2 so in type theory it is called a
product type just because you're
multiplying literally multiplying number
of inhabitants and we've had this in C++
and indeed and C for you know decades
that's just struct as pupils whatever
you want in one speak but it's all the
same thing
so on to level 3 now level 3 is
something that's new in C++ how many
values of an optional char
2:57 I hear loud and clear because
optional gives you the one extra value
it gives you the sentinel value outside
of your type and we add them together
now how many values in the variant 258
yes I hear a general consensus 258 again
same reason char 256 plus ball to 258
and the so now how many values in fou
that I think I'm hearing generally the
sum of the cardinalities of TMU right so
that so that's new in C++ right variants
and optionals and this kind of thing is
call the sum type in type theory and
it's just because you sum them together
so level four number four is a little
bit harder than I have to say the levels
one two and three but you're smart so
I'm sure you'll get it so how many
values are there of the function f that
is to say how many different ways can we
write F syntax aside but I hit two I
think I heard four it right if you don't
count side-effects
someone said two times - yes so four is
the answer the one that I'm going with
here are the four ways we could write
the function so the what we're saying
when we're saying different ways to
write the function we're saying
different number of ways to draw the
arrows between inputs and outputs and so
I hope you can see that these are the
four ways and in C++ these four
functions might look something like this
we can simply always return to always
return false that would be F 2 and F 3
here and F 1 is just identity and F 4 is
complement happy
okay now slightly harder how many about
how many ways can be right F now five
twelve somebody says five twelve because
two right because two times 256 so not
quite 256 squared is the correct answer
yeah
because if we look back at this picture
you can see that imagine that this is a
book where we saying ball to char we can
draw the first arrow 256 ways and then
we can draw the second arrow another 256
ways we multiply them together so how
many values for F now I hear 256 cube
from somewhere on the left hand side and
that is correct
so in this case foo has three values
char obviously 256 raise the one to the
power of the other yes you're right the
the so the function has to be
well-formed is the comment and what we
mean is that the function is so for the
same input it always gives the same
output yes it doesn't rely on external
side effects global variables you might
have hidden away its referentially
transparent all right so number of
values of a function there's a number of
different ways we can draw arrows
between the inputs and the outputs in
this sense so how many values now of f
which takes T's to use what can we say
right I think I think you're saying it
which is number of values of you ^
number of values of T it's what we've
seen before in the previous examples
okay so that's the end of level 4 and
then when we have a function from A to B
we raise the number of in happens to be
to the power of number inhabitants of a
and just as an aside this is a corollary
as to why the equivalence of curried
functions to encourage functions I'm
going to skip over that and give you
guys an achievement all right so so that
in that little game we already saw some
equivalences right so we can where we
would previously have let's say a bar
here holding a tea and a ball to say
what kind of tea it is we have a choice
now in modern C++ in in 17s it will be
to represent that as a variant and I
think the variable very soon become a
very important tool for proper
expression of our business logic States
and this distort kind of talks to that
and you know this is one of the reasons
why it's important that variant is kind
of never empty or only empty in arrow
state so that it can you know have this
kind of equivalence so nothing to know
about this is that so obviously in the
variant case we would think of T plus T
and then the in the case of bar here
it's T times 2 which is the same but if
we modeled our data with bar we'd have
to keep those two variables in sync
everywhere we changed them and the
variant is an easy way to do that so so
this is what it means you've seen a
little bit of this this one must have an
algebra of data types we can reason
about the quality of types and we can
find the equivalent formulations that
might be natural or better performing or
in some way more easily understood and
crucially we can kind of get rid of
identify and get rid of these mismatches
that we have right now between our
business logic state space and the types
that we have to use to implement our
logic if we can make the types match
more closely the state space of the
logic
we eliminate whole classes of errors
because we make illegal states
unrepresentable and this is this is a
big reason why I think that stood
variant is a game changer and probably
the most important thing since lambdas
okay
well let's look at some examples of that
so using some types as well as product
types that we know and love to look at
alternative formulations so here's an
example of course all examples are
contrived but this perhaps isn't too far
from some stuff massively simplified
that you find in everyday code bases
we're trying to model a connection so
we've got we've got some kind of state
of the connection and in all likelihood
it would have more states than this
having proliferated over the course of
another five years or so but so we've
got an enum for the state and then we've
got an address of a server were
connected to we've got some kind of ID
for the connection and then we've got
some idea of when we got connected and
while our last ping time was and we've
got a reconnect timer for the case where
we get the connection interrupted so
already you can see that you know some
of these fields that we have aren't
valid in various connection states like
when we're disconnected we don't have a
connected time or in fact you know what
tends happen is that that field gets
reused as a disconnected time sort of
without being without being commented or
enforced obviously we wouldn't have a
last ping time if we were disconnected
and we'd only have a reconnect timer if
we were interrupted so we could change
this around using variant to more
closely model our state space so it
might look something like this
so now rather than having just the enum
for the states we turn the states
themselves into struts and we make the
variant over those struts and so each
strut contains just the things that are
valid for just that state so when we're
connected we have connected time when
we're interrupted we have a disconnect
time now which is explicit and the
reconnect timer and all the other things
you can see here and so with this
formulation which is
in some sense you know exactly
equivalent in terms of the business
logic state space we've narrowed in the
actual state space the variables are
able to represent so we've eliminated a
bunch of books hopefully well hopefully
we didn't have the bugs in the first
place but we're all human so here's
another example common example about a
nullable field if you have a you know if
you let's say you have a social network
and there's a friend construct and you
are able to give them a alias and that
gets stored on the server you don't know
yet whether you've got the alias from
the server you don't I mean these two
fields need to be kept in sync right so
everywhere you touch the alias when you
get it from the server you need to put a
li as populated there's a there's a
temptation for code to treat empty
aliases as unpopulated but that might
not be correct you know sometimes a
general thing here is that often there's
no good sentinel type to use within the
type here often we use empty string as
the sentinel type to mean you know
invalid or whatever but in this case it
might not be so if we replace this with
an optional now we get exactly that
behavior wall optional does is gives you
that sentinel value and it's not
possible for two fields to get out of
step now because there's only one field
you filled in when you get the value
from the server if you haven't got the
value from the server yet yeah I'm going
to yet here's another made-up example
let's say you're programming some
monster AI for a game and you've got a
very simple monster AI and once there
can be idle just waiting around in the
world or it can a grow when a player
gets close to it and chase it for a
while before it gives up or you know
closes and makes and becomes fighting
again any numb for the state the fields
other than that innum are applicable in
some states and not in others for
example the an idle monster has no
target and the fighting monster has no
chase timer so again we're seeing the
kind of thing that happens every day in
code but the state space of the very
doesn't match the state space of the
business logic and so using variant
again all we do convert it into structs
that the structs be the enum effectively
there's contained within the variant and
now we can put the right things in the
right states so the question is don't
you have a bug here when a chance for a
bug here if you don't copy your target
from chasing to fighting possib I mean
so weigh that against the bug you would
have of accidentally leaving the target
populated when you're in an idle state
and some piece of code checking that
instead of the state I think it's easier
to to perform an assignment but in the
variant between chasing and fighting in
that sense than it is previously you
have a you have a definite state
transition yeah great question I get the
same question on the practice run and so
if you are so the question is I think if
you are going from chasing the chasing
state to the fighting state is there any
performance gain or is there you know
basically do you have to assign from
target to target you have to tear down
and reconstruct it depends on the
variant implementation I think the
answer is that pretty much you tear down
and reconstruct so in that case you
might want to factor out a subclass of
chating chasing and fighting which is
engaged maybe and contains the target
there are things you can do can you
access a variant with a subplot well you
would put these subclasses into the
variant and they would that would share
the other one you might still get a
construct though yeah these are
implementation issues I'm not sure about
Oh
so there are a few examples some types
now that we have them naturally kind of
model several design patterns which we
used too as well so I thought I'd go
back and take a look at those in
particular I think these four so command
is really nothing more than one big
variant it's it's typically you know you
have a very wide flat hierarchy and you
have basically well it might be replaced
by function or something but you have
some kind of executable command and then
you have a bunch of different commands
with states that isn't that is really
nothing more than a big variant
composite again treating part-whole
hierarchies the same very much suited to
modeling with a variant I think state is
basically variant and interpreter also
is something that very well modified
modeled by by variants if you think
about a JSON object that's one large
recursive variant and interpreter you
know as the pattern that allows you to
kind of visit that so yeah I mean this
is kind of what I've been saying
when you match when you make your types
match your state space of your business
logic you get rid of tons of bugs also
you get rid of tons of tests that kind
of tested all those corner cases because
the color case is just no longer exists
the types doesn't allow the corner cases
anymore so let's take a look at
designing with types so fitting types to
their functions is kind of what we want
for unsurprising behavior right so this
is important the bigger the code base is
and the more vital the functionality is
so what you want to do when you look at
a function is know from the arguments
basically what it does ideally we could
look at a function and know what it does
just by knowing that it has to use this
arguments and it has to use them in a
certain way to achieve
what it returns and so if you use this
kind of approach to make your api's then
it becomes much more understandable to
yourself in the future and you know
other programmers so let's take a look
at so we've looked at types modeling
data let's take a little look at types
modeling behavior one technique for
doing this is is broadly known as
phantom types and it basically makes
illegal behavior become a type error so
here is an example of an injection bug
just waiting to happen and I'm sure you
can all see why we've we've gotta get
form data and execute query and sanitize
form data if we ever forget to call
sanitize form data on the result of
calling get form data then our company
just died we lost millions of dollars we
lost our database whatever this is a big
deal Bobbe tables is not that another
friend so how can we use types here to
to prevent this bad behavior so so
here's kind of the setup right so the
phantom type here is is T now I think
you can see why it's called a phantom
type it doesn't actually appear anywhere
in the representation it just appears as
a template parameter and form data
itself is nothing more than a string so
the compiler is just going to you know
optimize everything away this is just
using types at compile time and then we
have these two tag structs which could
also be you know non type template
parameters if we wanted to this
alternative ways to formulate this but
now we can write our code like this so
form data is born dirty and we can only
execute clean data and so it's not
possible to have an injection bug here
you must call sanitize form data in
order to convert
you know the dirty to the clean maybe
there's not I put in an optional there
because you might want to do that so you
can you can constrain you know first of
all you don't accidentally get any get
any problems here secondly you can
constrain your tests if as long as
sanitized film data is is tested you can
you can narrow in on that part and
that's the part you really need to to
look at right so you've kind of narrowed
your space for what you need to test and
you've made sure that in the wider code
base you know the compiler is enforcing
that you actually can't have this type
of bug and this this kind of technique
of sanitizing sorry of phantom types is
also useful for things like units
libraries you know so you wouldn't want
to accidentally add meters to kilograms
and so you might use a phantom type they
both be you know integral or
floating-point types but you might use a
phantom type to wrap it around and make
sure you can't add the one to the other
something like a strong type def and as
I was writing this talk I realized that
effectively enum class is a strong type
def for integral types so we've looked
at types modeling data we look types
modeling behavior I want to play another
game with you guys now to show you the
value of total functions which is to say
functions that are defined on all inputs
or alternatively in C++ we might say
functions with no preconditions now
that's not the same well it's not the
same as saying that you know so for
example min here is a function or a
function template not every T will
satisfy what's required from it not
every T is ordered right so I'm not
saying when I say total function I'm not
saying that min here is accessible with
every type I'm saying that you know the
concept still applies that T must be
orderable
but you can see here the difference
between minun and square root perhaps
so if we have an order type it's clear
that for any two values of that type we
could compute min square root on the
other hand is a partial function because
it's undefined for negatives right so
the state space afloat is twice as big
as square root supports if you like so
so there are requirements on the type
here but the sort of regular normal
requirements you would expect there's
nothing surprising the types you can
assume that the types in the upcoming
slides are regular and you consume that
the functions actually do something
interesting as opposed to something
boring so let's play another game to see
how total functions result in really
unsurprising code now I'm going to give
you guys almost nothing to work with
I'll just give you a function bear
function sync just with nothing attached
and you'll be able to know instantly
what it is and how to implement it and
the only rule is that it's got to be a
total function so there are no tricks
but remember that rule and as always
there are ways to screw things up in C++
and make unexpected things happen but
assume there's nothing surprising going
on all right here's the first function
what what would we call this
I then identity yeah I'll call this
identity now this is sort of an old one
because for any given instantiation of
this function so the function template
we can say definitely that's identity
right because it pretty much has to
return the thing I give it it really
couldn't do anything else
you know default constructing something
wouldn't be interesting we assume it
uses its argument but for any given
instantiation we we know nothing about
what F does for integers it could do
anything because in the strange way we
know nothing about t and so we can say
its identity but we know a whole lot
about int and so we can't say anything
about that function sort of an oddity
alright next function what would we call
this
first-first yep I think we call it first
how about this one first first or second
choose yeah
select I think we'd call something
something like that so the idea is that
it uses boolean argument to select which
of the two other arguments to return
what might we call this map you might
call it map if you're writing in Haskell
maybe I don't know apply I had to apply
or execute or call maybe yep how about
this one
I heard transform
I heard sort identity yeah identity
would be the boring option generate
interesting shuffle yeah so the basic
idea here I think we could it could be
reversed could be shuffle it with the
right with the right concepts on T it
could be sort the idea is that we don't
really know what we can do at E but we
know what we can do with vectors right
so we can change around the vector any
way we like and we assume that the
teaser regular and copyable or movable
so yeah and and you know so with these
functions I the standard library writes
these in terms of iterators but you know
for the sake of ease I'm writing them in
terms of just containers and types but
they're equivalent how about this one
with reduce an accumulate well if I
don't see F taking a operation so
front or back I have front skin average
okay so let's assume the function only
does what you give it doesn't have
anything hidden front door back is a
good guess min or max potentially if if
if t although this function isn't
actually possible what do you return if
you have an empty vector so by looking
at the types this function shouldn't be
possible I mean you might say returned
if all constructed T then I would say
what if your type has no has no Sentinel
in it you know well if your type is a
color you know you might say return
black but that you know that's a that's
a chrome Yulin color I use elsewhere on
my code so so I said there are no tricks
but I did warn you but the odd thing is
that this function actually exists so
like that and of course front has
preconditions which is the vector must
be empty which is another way of saying
it's a partial function alright and you
know perhaps if we're writing STL to it
we would look at something like this and
and then we would call it front how
about this map map say the functional
programmers and the Cephas of
programmers say transform yeah so a
vector of vector T's and a function to
make T's into use and we give back the
vector of use and you can all see
obviously how that works and sure again
not in terms of iterators but
effectively the same how about this one
again the functional programmer says
filter yeah or in C++ we work it well it
could be more than filter it could be a
few things it takes a predicate and a
vector
returns a vector of the same type of
thing so so it could be it could we
would call it something like remove if
or perhaps partition you know basically
it has that predicate to run over the
vector and do something how about this
one it's not total yes now you're
getting it at because if what yeah what
would you return if you didn't have
something in the opposite if you had to
no opt well do turn so yeah that's not
possible by the types alone again and
see first plus anything is possible but
I'm just trying to look through a type
lens so how about this one
this good value lookup someone said yeah
someone's catching on yes this is
impossible because the key might not be
in the map but again this exists and
anyone who's tried to use this on a
condom at will will know this exists so
perhaps you know if we were writing STL
two we might think about this and we
would call it lookup yeah and we
wouldn't have to have things in maps be
default constructive or at least not for
that so what just happened I I gave you
almost no information there were no
function names here there were no
variable names
there were even though type names there
were no concepts I just gave you the
barest of type signatures that I could
that I could possibly give you and you
instantly knew everything about these
functions how what they should be called
how to implement them and with the
provider that partial functions gave us
a few issues so
so you know naming is one of the hardest
problems in computer science if we don't
need to if we can infer the action of
our functions just from the types
it makes naming a whole lot easier and
you can sort of identify well none that
makes naming easier but it makes
figuring out what the function does
easier and naming become less important
even and if sorry the names of the types
become more important perhaps perhaps oh
so naming is still important I'm not
saying it's not important but but at
least when we look at functions that are
well typed we have no surprise about
what they do and perhaps we have that
holy grail of self-documenting code at
least in some cases so I hope you can
see from this that if you write
functions without preconditions that
there's total functions with well type
signatures it makes them a whole lot
easier to use
it makes your API is unsurprising safer
to use harder to misuse and as I was
saying before whole categories of tests
sort of vanish if your types simply
can't express the edge cases that they
used to be able to you know because the
types didn't fit the business logic so a
little bit about testing so last year I
talked about unit testing and in
particular property based testing and I
have a little library that does that if
you get your types right what you're
doing is saying you know the property
based tests effectively say for all
values this property is true whatever I
feed to my function this property has to
be true so that is exactly what types
are types are universal quantifications
about what you can do and so types
I think scale better than tests so
instead test-driven development try type
driven development
I found it useful
now c-plus
I participant yet quite powerful enough
to say goodbye to all tests and it's
doubtful that any type system ever would
be but it's certainly already powerful
enough that if we use it effectively we
can reduce some of the drudgery of
writing tests just by making sure that
it's a compiler error instead so if you
want to go further down the rabbit hole
here's a few links that you can get from
the slides and here's a couple of quotes
thank you very much for listening since
we still have some time I have a little
epilogue the other taste for you guys so
a little taste of algebra with with
datatypes so back to this question how
many values are there of a vector of T
or what can we say about this and so
much that Alif not memory permitting
sure yeah but I'm saying if we say
infinite that's a little imprecise it
finite yes
so can we in some sense narrow in on how
many values T there are this this is a
tricky one one thing that functional
languages do is they tend to define
sequences recursively right and the way
that works is you say that a vector of T
or you know list of T in function
languages is so one here is representing
what empty right empty vector and then
we added together I we alternate that so
it's either an empty vector or a T on as
the head of another vector right at E
and the tail of the tail is another
vector so here we have an equation
representing the type of a vector so
once we have that we can go down with
our high school math
so and we can say right let's rearrange
take that to the left do that divide
through and we get this thing 1 over 1
minus T that's our expression right well
what the heck does that mean I don't
know how to take away types let alone
divide them so okay what do we do when
we don't know how to deal with something
mathematical ask wall from alpha
let's ask Wolfram Alpha what this means
oh I gotta ask on over here do I have a
mouse cursor I do all right let's see
all from our stats hopefully hopefully
it will say something enlightening all
right so it says a bunch of stuff and if
you can see so we scroll down scroll
down ah then we see this thing series
expansion at T equals 0 1 plus T plus T
squared plus T cubed etc yes so that is
interesting even though we didn't know
what to do with that this looks an awful
lot like a vector can be either one
element or oh sorry empty or one element
or two elements or three elements or
four elements so even though we didn't
know how to take away types have divided
types that expression was sort of
meaningless in some sense mathematics
gave us the right answer which is odd
okay so here are my goals for well type
code if you like I really think that the
addition of some types of C++ is a game
changer
as important as lambdas for modeling our
state spaces and making illegal types on
legal states unrepresentable I think
that phantom types is one way that you
can make illegal behavior a compile
error and that can only be a good thing
and I think that writing total functions
is to be desired for unsurprising
behavior and api's that are easy to use
and hard to misuse and if there are any
questions I'll take them but thank you
very much so how do I feel in up in a
hypothetical STL - to have both both the
partial functions and the total
functions the partial functions may be
for reasons of performance I feel that
total functions to certainly be a
default I think that if you're arguing
performance you need to measure things
and so you know I think the kits for
example the performance of needing front
B have the precondition rather than
retain and optional you know if you need
that performance yes but but I would
certainly like to have the total
functions be front and center yeah
so the comment is that many of the
functions in the library are are partial
because they were designed before
lambdas and if you am I getting it right
if you if you were to pass our lambda
into the function it could they fatally
inject the behavior you wanted in the
case where the partiality might apply
okay okay I would still say that you
know there are cases where in fact quite
a lot of cases when you start look at it
where you really there are a lot of
cases we have right now where we should
have shoehorn in some kind of Sentinel
value into our type just just for
reasons of needing a sentinel value
whether that be you know negative one or
some kind of default constructed thing
and we I think we jump through hoops to
get the full construction on more types
than we needed on because of this
limitation that we need to full
construction and and and Sentinel values
to be inside our functions inside our
containers so I think still think that
you know sense of modeling types things
like optional are already important yeah
Matt right so the question is about
replacing exceptions or error codes with
with variants or you know so effectively
a pair or maybe on whether it might be
before variant that's that's a valid way
to go I think you need more machinery
for I mean when you get to that you're
almost talking about then using like we
have further things like still expected
using a kind of monadic error mechanism
so that that's totally fine if you're
comfortable with that I think one of the
pros and cons let's talk about it
afterwards maybe I think you know I
think we can't ignore that that
exceptions and and error codes are kind
of in a lot of library code already and
a lot of code so you know maybe if you
would take a Greenfield thing and no
dependencies you could write in see for
us a performant monadic kind of error
handling deal right right I mean yes so
if the promise is it could improve
performance well maybe either I'd hate
to write a whole big system and then
find out that it didn't improve
performance attempt me once or twice but
in the back so in the example of string
I said that we often use empty string as
a sentinel value yeah so so the question
was how what was a question oh you've
seen people use optional where the type
itself also has a sentinel value and
empty wasn't allowed om m t is the
sentinel right and i think that's what i
was advocating so what optional provides
your type with a sentinel value
optional if t-star right yes yes if you
have optional of a pointer you have to
check whether you have no opt and then
what the point is now yeah this this is
I mean a pointer really historically is
an optional in that sense because it the
the the you know the practice of using a
null pointer is the sentinel value after
all it is in addressable is is well you
know well used so send you know for
pointers pointers are effectively
optionals i you know the what do with
pointers as a whole a whole different
thing perhaps and I would use I would
use the geocells not now maybe I would
basically yeah I wouldn't layer on
optional on top of optional Michael did
you oh sure
yeah I mean I guess so that's true so
Michaels point is that and some targets
embedded systems may be null is is
actually in piece of addressable memory
and perfectly fine so you wouldn't
necessarily have a sentinel in your in
your pointer type yeah you know
you
so the comment is that finance concern
is that using total functions may when
business logic changes may result in
more of a rewrite than using partial
functions may be true and so I guess
it's your choice how closely want your
types to fit your problem domain and if
you want some laxity there so that you
anticipate your domain changing then you
are trading off you know development
time for for safety in some sense yeah
okay okay so the function that that
takes a bull and returns a char has 64 K
ways to write it right 256 x 256 or 256
squared so maybe I can explain it so
here I have a bull this is true and
false and maybe there's 256 of you how
many ways could I give these out I could
give them both to the same person I give
the first one any number of 256 ways and
then I can independently give the second
one 256 ways okay all right I see so I
mean any given any given instance of the
function only obviously does one thing
but the point is that that the type of
the function has 64 K possible ways
possible inhabitants possible ways to
write that function is that coming
across
sorry one of the possible ways to write
the function would be to hard-code
returning the char yes yeah that was way
back I think so right right that so the
type of the function affords a certain
number of implementations ok and close
yeah this this slide I hope makes that
clear so the number of values the
function can have is the number of ways
of drawing those two arrows okay we're
at time thank you all very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>