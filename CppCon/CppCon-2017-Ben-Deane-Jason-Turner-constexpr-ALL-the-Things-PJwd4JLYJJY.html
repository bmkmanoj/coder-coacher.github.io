<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Ben Deane &amp; Jason Turner “constexpr ALL the Things!” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Ben Deane &amp; Jason Turner “constexpr ALL the Things!” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Ben Deane &amp; Jason Turner “constexpr ALL the Things!”</b></h2><h5 class="post__date">2017-10-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PJwd4JLYJJY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Welcome to constexpr ALL the Things!
This, as I'm sure many of
you know, is Jason Turner.
He is a independent contractor
and trainer working out of Denver.
He does C++ Weekly on YouTube,
he is one of the cohosts of
CppCast along with Rob Irving.
He speaks at lots of conferences,
and he finds time to do all
sorts of things besides.
- And this is Ben Deane,
who is a principal engineer at Blizzard.
Been working in gaming for
20 years, most of it in C++.
He is a functional programming geek,
which will definitely
come up in this talk.
- A little.
- A little.
And, um,
oh, and you're on the Battle.net team.
- That's right.
All right, so, in the interest
of not hiding anything,
when I first heard about
constexpr, this is what...
and about user-defined literals,
I thought, &quot;This should
be possible at some point.
&quot;Can we imbed JSON literals in C++,
&quot;have them work at compile time,
&quot;and have them control
configuration in code,
&quot;as one example?&quot;
And this I think is a great bellwether
for what constexpr can do.
So when I first, like I say,
when I first heard about constexpr,
and about user-defined literals,
I wanted to do this.
JSON is ubiquitous, JSON is
used for a lot of things,
it's very useful, it's
very well-known, it's
simple, but it's also recursive,
so it's sufficiently interesting
to try and do this with.
Oh you want me to, yeah, okay.
(Jason chuckles)
Sorry, we did this differently in Aspen.
So, of course the promise of constexpr is
that we get run time
efficiency by moving things
from run time to compile time,
also that we can simplify code
through compile-time computation,
so where we would have magic
numbers in code perhaps,
we could now just write
the more expressive
expressions that we use to
compute those magic numbers,
and they get done at compile time.
We don't need to muck
about with a preprocessor
to be sure of things not
making it into the run time.
And less cross-platform pain is nice.
If you can move things into the compiler
that were previously in some
other step in your tool chain,
so if you can do things
constexpr-wise now,
using the compiler rather
than say generating code
to produce your constants
or whatever, that's nice.
And if you're working cross-platform,
reducing steps in your
tool chain is very nice.
So moving very quickly along,
just a quick recap of where we are
with constexpr up 'til now.
So there've been three ages
of constexpr by my thinking.
C++11 was very limited,
we had one return value per function,
we had to do everything
with extreme recursion,
and we saw things like math functions,
FNV1 string hashings you may have seen,
this very kind of, this
linear recursive technique
down the string, something like that.
And then when C++14 comes along,
we get generalized constexpr,
so we're no longer limited to
this kind of very recursive technique,
we can write more straight line
C++ code that we're used to.
And because of that we get
some constexpr libraries appearing,
we get murmur3 hashing
instead of FNV1 hashing.
And so now we're at the dawn of C++17,
and we have some more features
available in constexpr land.
One of them is if constexpr,
and that is simplifying and will simplify
metaprogramming a lot.
We get a lot of constexpr
stuff in the STL,
in particular things like string_view,
which are more or less
born into constexpr world.
We get constexpr lambdas,
that is that the lambdas have their
function call operator now as constexpr.
And who knows, we might
get constexpr by default
on a few things.
But one of the problems with
constexpr up 'til now is
that you can't tell,
when you're in the
evaluation of your function,
you can't tell whether
you're being evaluated
at compile time or at run time.
And this is something
we'll touch on a bit later.
We'll come to talk about some proposals
that deal with this and some
other things constexpr-wise,
but this fundamentally is
one of the main problems.
Even if you write nice constexpr code,
if it doesn't get evaluated
and assigned to a constexpr variable,
there's no guarantee it'll
happen at compile time,
and it might accidentally be
admitted in your run time.
And you can try things,
there are various things you can try,
like SFINAE on constexpr, and this,
it tends to be a little bit brittle
and you know, certainly a lot more code
than you probably want to take on.
But we'll touch on more stuff later on.
So, take it away, Jason,
for the next part.
- All right.
So, this is effectively a
JSON value that we want
to be able to parse,
that we were just showing.
So we've got the problems of,
how do we represent JSON values,
and how do we parse them at compile time?
JSON is a discriminated
union of null, boolean,
number,
string,
and an array of values.
And also object types,
which is a map of string to the values.
So, we're gonna need some sort
of recursion in our parsing,
and we're going to need constexpr ways
of dealing with string, vector and map.
And well, all that turned
out to be a little bit easier
than I think we were
afraid it was gonna be.
But we will get there.
Constexpr strings, now interestingly,
C++17 adds standard string_view.
I have a hard time with using this
in a lot of constexpr contexts,
because I feel like it is
not intended for storing a string,
and we're talking about storing strings,
and it can only hold literal values,
we can't build strings.
So we need some way to
pass and store strings
and in general work with
character string literals.
And so string_view, like I said,
it would technically work
for some of these things,
I, again, I feel like it mixes metaphors,
don't like using it
for compile time stuff.
So we built up the static_string class,
which looks like this,
which uses a templated
array constructor to pull in
the data from a character,
uh, from a character literal, that is.
And we can make all of
our methods constexpr,
and it's pretty straightforward.
Although, and not directly
related to this talk kind of way,
when I've gone back and
looked at this talk,
I have noticed that there's
something kind of missing
from these slides, I
think, from these lines.
Does anyone have any comments
on what we could add to these
declarations for our methods?
Anyone?
You have to talk to us.
Yeah?
(audience member speaks indistinctly)
What's that?
(audience member speaks indistinctly)
Am I slicing?
Oh, oh, no.
No, I don't mean add a new method,
just in the declarations of these methods,
they could all be noexcept,
I just want to point that out.
But we didn't make them noexcept.
- [Ben] Right.
We doubled them up for noexcept, right?
'Cause it's part of the type system?
- You wouldn't have to
double them up here,
but we do have other stuff, and ...
So not all constexpr methods are noexcept,
but many of them can be.
So our vector ends up looking like this,
where we're just taking
advantage of the fact that C++17
now has a constexpr-enabled
standard array.
And we have our data and our current size,
iterators, push_back and all this,
it's pretty easy to write.
We just push something,
or add a value to it,
and increment the size.
Does that make sense?
- [Ben] Right.
And the size is fixed.
- Yes, the maximum size is fixed.
So it is a template,
and you can see right
there, it says &quot;Size = 5.&quot;
That becomes a problem in a minute.
(chuckles)
- But in the early slides,
you'll see limitations,
you'll see, you know...
We'll get to hopefully removing
some of those limitations later.
- Yes.
So, as we can see
on the push_back here...
(microphone fades out briefly)
Oh.
That was weird.
If our size grows beyond
the maximum size that's allowed
by our templated size type,
we throw an exception.
And this is perfectly fine
in constexpr context,
because if it were to throw the exception
during a constexpr evaluation,
then it would fail to compile.
- Right, and in fact, if you
didn't have the throw there,
and you went beyond the array size
in the constexpr context ...
- You would still get
a compile-time error.
- You would still.
- Yes.
'Cause if you try to index
past the end of array
in a constexpr context,
you get a compile-time error.
Also, but this allows us to work with it
both in a constexpr and
run-time context, plausibly.
- Right, right.
- So also, it's interesting to note here
that we are not able to use
standard next for incrementing
here.
So we can see,
using this little tool
that some of you may have heard of before,
Compiler Explorer,
that there's a bug in
GCC 7.2's implementation
of standard next that
it's unable to increment
because of its iterator category.
But...
- Right.
- These things are fixed in trunc.
- Yes, I believe so.
So yes, so next, advance,
which I think next uses,
and distance.
- Distance, yes.
- They are all constexpr in the standard,
there just happened to be a bug with them
in GCC 7.2 that we're using today.
- Right.
So now we can naturally
use our constexpr vector
like this, or more to
the point, like this.
We can write a constexpr function,
and at compile time, populate our vector,
assign it to a constexpr
variable in our main,
and then actually do a compile
time check with static_assert
to prove that we did in fact
add something to our vector.
Is this cool with everyone?
All right.
So now that we have a vector
that we can use in a constexpr context,
we can build up strings.
So we can, building on the model of
how the standard library's
basic string is built,
implement our own basic string
that inherits from our vector and
simply, you know, builds
a string out of it.
We have done a little bit of a cheat,
in that all constexpr
member variables must be,
or all member variables of constexpr types
must be initialized.
So we know that the underlying array
is going to be initialized all zeroes,
so we've taken the cheater step
of knowing that we're gonna
have a null terminator
at the end of our strings
automatically for us.
And we have not yet provided any methods
for shrinking the strings,
but that should be easy to do.
And then continuing from there,
we have our constexpr map,
which we needed for our JSON type here.
And, um,
we did, it's...
Maybe it shouldn't be called map,
it's more like unordered flat map
or something.
- Yes.
Ordered flat, no, yeah,
unordered flat--
- It's unordered.
All of these are linear searches,
but they all happen at compile
time with small objects,
it's kind of irrelevant.
- It's a map implemented
as a vector of pairs.
- Yes.
So it's a vector of pairs, as you said.
We have std::array, and...
Yeah, we'll call that out.
- Yeah.
So anytime you see a cx
qualification, namespace here,
that's our constexpr namespace,
that usually indicates that
there was some limitation we found
in the standard library's implementation,
in this case of std::pair,
and that we couldn't use it constexpr.
- It's unfortunate.
So then this gives us the ability
to do something like this.
Oh, it's...
- [Ben] I fixed it.
- Oh, okay. (laughs)
So we can have our constexpr map of colors
with names,
and then we get a actual
compile-time error
on the last line of our main,
because we tried to look
up a key that doesn't exist
and we're evaluating this
in a constexpr context.
This is, I feel like, personally,
in some ways equivalent to
or almost as good as an enumeration.
It's, I mean, an
enumeration is also in a way
a &quot;magic value&quot; of a string.
That's all checked at compile time anyhow.
- [Ben] Jason is looking for arguments.
You can come see him later.
- I am looking for arguments.
Yeah, you throw stuff out here at me,
that's how I roll.
Anyone wanna argue with me?
(audience laughs quietly)
Oh, all right.
So why not standard pair?
Again, Compiler Explorer is showing us
why it's failing to compile here.
&quot;Non-constexpr function.&quot;
This is the...
It's scrolling off the edge.
The assignment operator of
standard pair is not constexpr.
- [Ben] Right.
- Which is terribly disappointing.
- [Ben] And that's actually
done in the standard.
- Yes.
- I think.
- Yeah, so this is not a bug
in this particular implementation.
It is simply not specified
as being constexpr,
and as far as I know, it totally could be.
Do we have any standard
library implementers
that wants to, uh,
argue?
All right.
- I guess Marshall...
- Yeah, Marshall's not here.
- But this is a, actually,
to touch on that,
that's a sort of common thing right now
with constexpr in the standard.
There's a lot of places where,
maybe not a lot, but
there are places where
things that should, by our thinking,
be able to be constexpr
just aren't specified
as constexpr in the standard.
And it's just because
nobody's got around to it yet,
nobody's done the proposal,
nobody's quite thought
about it in that way yet.
- Some things, in some things,
it's like a weird little hole.
Like, everything about standard pair
except for the assignment operator.
- Right.
And of course, if you have a standard pair
with two things that are constexpr,
you can do, you know, .first
assign and .second assign,
and effectively you have assignment.
So to not have assignment
operator on the pair,
it's probably an oversight.
- Yeah.
So, we needed some sort of
a find to implement our map.
And does any, you know,
anyone recognize this find_if?
(crowd murmurs)
Yeah, I mean, this is
literally how it's specified,
like, in the standard.
This is taken straight
from cppreference.com.
The only difference is
that now it says
&quot;constexpr&quot; in front of it.
None of the standard
algorithms and the, uh...
Well, one...
min_element, max_element,
min and max are constexpr,
the rest are not.
- Yeah, so once we have
find_if, of course,
that's what makes the map work.
- Yes.
- The constexpr map.
- Right.
So then we've got Bryce here.
Let's see, &quot;Reviewing
code I wrote last week
&quot;I found three implementations
of constexpr transform.
&quot;Constexpr algorithms please.&quot;
And we totally agree with Bryce.
- Yes.
But he won't let us have
constexpr parallel algorithms.
- We can have constexpr
parallel algorithms.
I mean, we may as well.
- It's just the compiler
implementation detail, right?
- Yeah.
(audience chuckles)
We're not worried about
what the compiler has to do.
All right.
So we also had to implement
mismatch, equal and copy,
and found uses for several of them,
as the slide says here.
I was recently playing with
some more constexpr containers
myself on the flight here,
and implemented everything necessary
to do a sorted container.
And it's again just
taking the implementations
straight from cppreference.com,
adding constexpr to the front of it.
Works just fine.
So we end up with this,
which is our recursive declaration of
our JSON thing,
using our CX vector
and CX map,
and our static_string that
we were just discussing.
Now I completely lacked the imagination
to actually figure out
how to implement this,
and Ben had the idea for
our first attempt here.
It gets better.
But, as you can see, hopefully,
this has the max depth
specified in the template
argument on the first line.
And that means we are specifying
that this is going to a max
recursive depth of five.
So you could have at
most five nested elements
in your JSON thing,
and this was
expensive at compile time.
- Yes.
It gets to be kind of expensive
at compile time.
This is the simplest thing I thought of
that could possibly work.
So this was kind of the proof-of-concept
that we went through.
- Yeah, he threw it out
there, I implemented it,
and I'm like, &quot;That's amazing, it works.&quot;
I, like I said, lacked
the imagination for it.
(audience member speaks indistinctly)
Yes, go ahead, sorry.
- [Audience Member] Can you
go back a slide, please?
- Absolutely.
- Is there any reason why
you didn't use union there?
- Oh, why didn't we use union there?
- That's the one thing I didn't fix,
because I wanted to give you
the opportunity to explain this. (laughs)
- And I forgot about that.
We are using union now.
- [Ben] Yes.
- We weren't because there
was a misunderstanding
between myself and the compiler
for what was allowed to be
initialized and modified
at compile time in a
constexpr context with unions.
- [Audience Member] Okay.
- It can work here, yes.
Yeah, the implementation on
GitHub is still union, right?
- Yeah, oh yeah.
- 'Cause I thought
you had one more--
- We are using union now.
- Okay.
No, I mean, I knew we were,
but then I thought you had
another misunderstanding
again with Clang later,
once you tried to update it to Clang.
- I don't think so.
- Oh, okay.
- Not for that, at least.
- Okay, cool.
So, yes, you could use union here.
But you have to be just
aware of the fact that
everything has to be initialized
in constexpr member variables,
and that comes into play with a union,
because a union by default is
not initialized to anything.
- [Ben] Another question.
- Oh, sorry. Where?
- [Audience Member] Here.
So, when you're trading the container,
like you said, on like adding constexpr,
do you also get the
structural bits (mumbles).
You said you're taking the CPP standard
and then converting it into constexpr,
and you said everything works.
Have you tested structurally
and to see what speed is,
to see if it's still working
about the same speed?
- So the question is, by adding
constexpr to these things,
have I checked to see
if they're still running
at the same speed as
the regular algorithms?
I would say I have not,
but I can also say I have never seen
adding constexpr to an
algorithm hurt anything.
But I can further qualify that by saying
the textbook examples of these algorithms
is not necessarily how
they're actually implemented
in the standard libraries.
'Cause I know, like, some of them,
like GCC standard library
algorithm implementations,
have some, like, default
on rolling built into them
and that kind of thing.
And these textbook implementations
don't have any kind of optimizations,
they rely on the compiler
optimizer to do them.
But no,
just to
clarify, no, I have not
done any direct comparisons.
- And just to be completely
clear and transparent,
when we say we've made constexpr
vector and constexpr map,
they're nowhere near what
standard vector and standard map support.
They're just what we need
for the compile-time parts.
- [Jason] Although we do get
pretty far along the way,
with most of the functions.
- Yeah, I mean,
they're very serviceable.
- Yes.
So then we are able to do constexpr,
you know, keep building on this, and
so again, we're taking
advantage of the fact
that if you were to throw
an error at compile time
or throw an exception at compile time,
that you get a compile-time error.
And well, we can access
the arrays of things,
and we are able to
basically do this at compile time,
and it works.
- [Ben] Go back one slide.
- Yes.
- So I just want to point out,
so you see to_Array here,
you can imagine the other functions.
So there's a const version
and non-const version,
they return const ref or mutual
ref to the underlying thing.
As for to_Array, so for to_object,
to_boolean, to_number, to_string.
- Yes, right, yes.
This is just a tiny
snippet of all the things.
So yeah, we looked at that, sorry.
Why not variant?
We touched on this already.
Similar to pair, it's missing
a couple of key things
that are kind of critical.
We don't have a constexpr copy
constructor for variant, a
move constructor,
or a copy assignment
or move assignment operators for variant.
And this comes down to the fact that
variant wants to do placement new,
basically, for these things,
but--
- [Ben] And that's not
allowed at compile time.
- That's not allowed at compile time,
there are ways to work around it.
- I don't know.
- There are.
They also, so it's an
interesting side note,
but I should probably move
a little bit quicker here,
that the standard does guarantee
that if all of the things
inside your variant
are trivially destructible,
then it is also trivially destructible.
And it takes a little bit of
gymnastics to implement that,
but there's no reason why we couldn't make
some of the same calculations for
if they're trivially default constructible
and that kind of thing.
So real quick, all the requirements
for our compile-time types,
if you're looking in the standard,
these are known as literal types,
they must have at least
one constexpr constructor,
and they must be trivially destructible.
So that's it, when you're thinking about
deploying constexpr in your code,
that's what you have to worry about.
So as we've already mentioned,
we've got some shortcomings
in array, string,
string obviously can't be
used in a constexpr context,
string_view can't grow or change,
pair and optional and variant
have the assignment problems,
and standard swap is simply not constexpr,
which that one confuses
me a little bit too.
- And some of these are
shortcomings in the actual standard,
and some of them are just, as we saw,
some implementation things.
But yeah, for swap,
we don't see a reason why
it shouldn't just be defined constexpr.
- Unless it comes down to
some sort noexcept
guarantees or something, but
that should be something that can be
worked with, then, for sure.
So our containers have
a fixed maximum size,
they currently can't shrink,
and they require all the types
that are default constructible,
since we have to default initialize
all the things inside of our containers,
they must be default constructible.
So we're almost to the parser, right?
- [Ben] Mm-hmm.
We've got a few more slides.
- So, we could, um...
One option for making our containers
so that they don't require things
that're default constructible
is that we can put an optional,
like, make basically arrays
of optionals of things,
and then they wouldn't
have to be initialized,
and then we could initialize
them on will when we needed to.
(audience member speaks indistinctly)
No, std::optional, well,
it's constexpr constructible,
but not assignable, I believe.
Because it comes down
to placement new again.
- [Audience Member] Yeah, but
don't you move the problem
into the implementation (mumbles)?
- Oh no, I mean, we have our own
implementation of optional also.
That's, I believe, a tiny typo here.
An &quot;optional-like thing.&quot;
- Okay.
- Is that good?
- [Ben] Right.
- So yes, and it's...
- [Ben] This is your next slide.
- Okay, right.
I like the idea of being able to make
all of the standard containers constexpr,
so this is cppreference.com
for what is required
for a minimal allocator,
and there's nothing in here
that inherently couldn't be constexpr,
so I say we just make
these things constexpr,
like we have been doing,
or at least make them
optionally constexpr.
And well, that's left as
an exercise to the reader.
Just go out and make your
own constexpr allocators,
roll it in to one of
the standard containers,
and let me know how it goes.
(audience chuckles)
So...
- It may be happening
for some people.
We'll come back to that later.
- Yes, we'll come back to it.
- But for now, let's
tackle the other problem.
So Jason just talked about
how we actually represent
JSON values, right?
So we've got some idea of how to do that
with the recursive template.
So kind of the half that fell to me
was how do we parse these things?
How do we turn string_view
literals into JSON values?
And
so, to answer that question,
first we have to ask the
question, &quot;What is a parser?&quot;
And if Dr. Seuss had been
a computer scientist,
he might've said something like this:
&quot;A parser for things is
a function from strings
&quot;to lists of pairs of things and strings.&quot;
This actually is, this quote is from
Fritz Ruehr, who's a
functional programming lecturer
at Willamette University.
But so at the top here, you can see
I put a Haskell function signature.
And you'll see, in a few slides coming,
you'll see the old Haskell
function signature.
If you can read it, great.
Haskell's a great language
just for specifying function signatures.
But this just means the
type of a parser of A,
and A is like a template parameter,
is a function from string to
list of pair of A and string.
Now in C++, we might say something like
what's on the bottom.
This is a template alias,
which is a function.
But there're a few things
wrong with this C++-wise,
because we don't really quite mean &quot;list&quot;
or &quot;string,&quot;
right, or even &quot;function.&quot;
When we say &quot;string,&quot; we'd
much rather say &quot;string_view,&quot;
'cause that's constexpr.
It's a compile-time stringlike thing.
And when we say &quot;list,&quot;
well, what the list
represents here in the parse
is that you might have multiple
ways to parse something.
So we're just gonna condense
that down to optional,
meaning the parse can
either succeed or fail.
And we can do that in constexpr world,
using our own kind of
optional thing that works.
And when we say &quot;function,&quot; we mean,
of course, something invokable.
And in C++17, we mean constexpr lambdas.
So let's look at a very simple
parser that we could make.
So on top here, I just have some aliases
that make life simpler.
So a parser input is a string_view,
and a result of a parser is this optional
of a pair of thing and
rest of string, right?
So you parse the thing out of the string,
you've got some rest of string to work on,
and you've got your t
that comes out of it.
So that's what input_t
and parse_result_t are.
So match_char here, this is,
we parse it at input
and we parse it at char,
and it's gonna return us the parse result.
And the way it's gonna do that is it,
you know, you can read the
code, it's very simple.
If the string's empty or
doesn't match the char,
we fail, and that means returning nullopt.
Otherwise, we just return
the wrapped-up pair of
the char that we parsed and
the rest of the string_view.
I hope that's clear.
Now, but if you're paying attention,
you'll note that match_char
isn't quite yet a parser,
because we said that the
signature of a parser was
parse_input_t to parse_result_t,
and this takes the char as well, right?
So it's not quite a parser.
But we have constexpr lambdas,
so what we could do is capture that char
and return the lambda,
which is itself a parser.
And that's what this is.
So now, make_char_parser
will make us a parser
that matches the character we give it.
So we capture the character in the lambda,
and what we're returning is a lambda,
which is a parser, because
it's a function from
string to list of pair of thing, a string,
optional pair, right?
And so this code on this slide here
is exactly the code you
saw on the previous slide,
but just put into a lambda,
and it's now capturing the character.
So make_char_parser will give us a parser
for any char that we give it.
So now that we can do that,
we can think about some other
sort of primitive parsers.
So far, we can make a parser for chars.
Fundamentally, parsing works on strings,
so we're gonna want a few more things.
It's gonna be useful to match
any one of a number of chars that give it.
And so here is this function, one_of.
Again, it returns a lambda.
It's returning a parser.
And it's just doing, you know,
the kind of obvious string.
You see if the thing at
the beginning of your input
is in your set of your string_view
that you captured.
So that, I hope, is clear.
Similarly to one_of, we can write none_of,
which I'm not showing the body of,
but it works exactly the same way,
only the logic's inverted.
You're just checking to see
if the thing at the
beginning of the string_view
is none of the things that you captured.
And also, we can make a parser
that matches a whole string
just by capturing that string and
doing the obvious thing,
to check the string_view.
And that uses a constexpr std::mismatch.
So everything clear up to this point?
Everyone happy with parsing chars,
parsing strings, et cetera?
All right.
Now we have these kind of primitives,
now we can think about ways
to combine them together
to build up to what's
parsing greater things.
And some of the things
we're gonna want to do here
might start to look familiar
if you know the kind of
functional patterns involved.
One of the things we'd like to do is
change the result type of a parser.
So right now, we have a parser for chars.
If that char represented a digit,
we might want to change
it into an integer.
And so we'd want to put a
function in there that just,
we now have to write a function
that changes a single digit to an integer,
and we'd want to apply that to
our parser that parses chars
to make a parser that parses integers.
So we can write that function.
These are kind of parser combinators
that we want to write
to fold things together.
We might want to run one parser
and then run a second one
based on the result of the first one.
We might want to alternate two parsers,
so try one and if it
fails, try another one.
And we might want to run
two parsers in sequence
and then combine their results together.
So I'm not gonna go deeply into the
functional programming aspect,
but if you know these patterns,
they'll look familiar.
So this is fmap, this is
a thing that, you know,
changes a char into an int, for example.
So it takes...
And again, the Haskell type
signatures are at the top,
if you're familiar with those.
But it takes, fundamentally,
the function f and the parser p,
and again, what it's gonna return is
itself a parser, a lambda.
And what we do is capture the function
and the parser that's kind
of, we've got to change,
we run the parser that
you can see on this line.
If the parser fails, then we have to fail.
But if the parser succeeds,
all we do is run the
function on what it produced,
wrap that back up in a
thing and rest of string,
and return that.
So that's fmap.
Similarly,
we've got,
this is alternation.
So this time we take two parsers,
and the bit of template
metaprogramming at the top
just says that they're gonna
have to return the same type,
because what we're building
has to return either one,
and we need to know what type to return.
So we take two parsers, p1 and p2,
and we return a parser
that in its body just says,
&quot;Try running p1, if that fails...
&quot;Or if that succeeds, you're done,
&quot;but if that fails, try running p2.&quot;
And the thing at the bottom here
is just a useful thing for
building up combinators,
which is the parser that always fails.
So you can make it be of
whatever type you need, right?
So it's just gonna always
fail and return nullopt.
That turns out to be useful in some cases.
So that was alternation.
The final kind of primitive combinator
that I want to show you is,
I call it combine, for
lack of a better word.
But what this does is runs,
instead of running, trying one and then
diverting to the other,
this runs one and then runs
the other one in sequence,
takes the two results, combines them.
And this turns out to be very useful.
So you can see what it's doing,
it's saying const auto r1 equals p1.
You know, it's running
the first parser there.
If that fails, you fail,
then you run p2 on the
leftover string from p1.
You've run the first parser,
you want to run the second
one on what's left over.
If that fails again,
you still have to fail.
Otherwise, you just return the result of
calling the function on both results.
So it's a way of running
two parser sequence
and then combining their outputs
to make a parser for the
output of the function.
So this turns out to be very useful.
There are a couple of very
useful patterns of this,
and it's useful for, like,
when you don't care to save
the result of the parse.
So you just want to say something like,
&quot;Well, I know there
has to be a comma here,
&quot;but I'm not interested in the comma,
&quot;I want to see the next thing,&quot; right?
So I'm parsing something and I know
there's gonna be a comma,
but the comma's not gonna
be part of my output,
it's the thing I'm
interested in, let's say.
And so you just want to throw away
either left-hand side of the
parse or the right-hand side.
And so, what I did was, I overloaded
operator less-than and
operator greater-than,
just to do this combine pattern
where you throw away the thing
on the less-than side, if you like,
or the other way around
on the right-hand side,
if you're doing greater-than.
So you can see that when
we call combine here,
we give it the parsers,
the function we give it
just throws away the left-hand argument
and returns the right-hand.
Okay.
Few more combinators.
And now you can start to see perhaps
what we're building up to.
Now I'm just showing you
the Haskell type signatures for these,
but maybe you can imagine
kind of having seen
some of those C++ work bodies,
how these might be implemented.
And the thing these have in common
is their accumulation styles.
They work in the same
way as std::accumulate.
Many takes a parser and a
initial value, that's the b,
and then it takes a function
that folds the result
of that parser into b's,
and what you get is a
parser of b's, right?
So it's very much like accumulate.
You give it initial value,
you give it a function to combine values,
and what you get out is the final value,
only this time it works on parsers.
So many will match zero or many
runs of the parser.
Many1 matches at least one pass,
but again, potentially unbounded.
Exactly_n, you can probably
guess what that does.
It takes the int argument
as its second argument,
and so it runs a parser exactly n times,
combines the results together.
And then separated_by,
you can see where this is going, perhaps,
it takes two parsers,
one of which is kind of
your parser for things,
and then the parser x here is
like the in-between parser.
So if you're parsing a
list of things in JSON,
you're gonna want to parse
value, comma, value, comma,
value, comma, et cetera.
And that's what separated_by does.
So it'll parse values
separated by parsing commas.
And again, the initial
value and the full function,
and what we get out is the result.
So I'm not gonna, you know,
give you a wall of text
for the C++ on these things,
but you know, given
what we've talked about,
maybe you can see that
these can be implemented.
All right, so let's take a
look at a couple of parsers,
just so you get a feel
for what these look like.
This parser just eats whitespace.
It's one of the simplest
parsers we could make.
So, and it eats, you know,
just a very limited subset
of whitespace at that.
So space or tab or new line or
character return,
those are our char parsers.
We're alternating them all
together with the bar operator,
and then we're saying
the whitespace parser is many of those.
And you know, the accumulation function,
we don't care to catch whitespace,
so we're just parsing through
monostate and throwing away.
- So, C++17 makes
lambdas enabled for constexpr use?
- [Ben] That's correct.
- How much more code do
you think it would've taken
without being able to
use C++17's lambdas here?
- To be honest, I don't know.
I don't know that.
I don't know if it would even be possible.
I would...
Like, you'd be talking about
simulating lambdas by returning
local structural functions or something
in the templates?
- Yeah, yeah, yeah.
- I don't want to think
about that too much.
- Okay.
(Ben chuckles)
- But the important
thing to note there is,
if I go back a few slides,
so you can see that all of these
functions returned lambdas,
but there isn't actually a constexpr there
on the lambda itself,
and that's because
one of the defaults, you
know, for lambdas now,
lambdas are by default constexpr,
unlike regular functions.
So you don't actually have to put
the constexpr keyword in there.
- [Jason] By default, if
they meet the requirements
of being constexpr.
- Correct, right.
If they can be constexpr.
- Which one wonders
why we don't do that to all
the functions at this point.
- Right.
Okay, so that one eats whitespace.
This one parses a decimal integer,
a positive decimal integer.
And so what we're doing here
is building up the parser combinators.
We're saying &quot;one_of one through nine,&quot;
'cause a decimal integer
won't start with a zero,
and we're gonna bind the result of that
and parse it into
the function that we parse,
which you know, so...
One through nine will be that char x,
parameter to our next function.
And then inside of that, we're saying,
&quot;Well, after you've parsed
that one through nine,
&quot;do many of one_of zero through nine.&quot;
So you can have any of those digits
many times after your initial digit.
And then, we're accumulating
in the obvious way of
you know, shifting and adding.
So that, I hope, is clear.
Here we have a very simple string parse.
A parser for strings is basically,
you parse a quote,
followed by a bunch of
things that aren't a quote,
followed by another quote.
And you can see at the bottom here,
that's where this greater and
less-than operator overload
gets to be really nice,
because that's all that's saying.
It's saying, &quot;Do a quote, throw away that,
&quot;do the string parser that's not quotes,
&quot;keep that, and then do a
quote parser afterwards,
&quot;and throw that away.&quot;
All right.
So now we're getting toward the toolkit
for building JSON parsers.
So because JSON's a discriminated union,
a reasonable attempt to parsing it is
to have parsers for six
different types of things
and alternate them together.
And so that's what this does.
It's a bit of a wall of text,
but you can see there's basically
six or seven different alternations here.
You can see there's a
parser for null in there,
there's a parser for true and false,
there's a number parser, a string parser,
and then an array and object parser.
And we're doing a skip whitespace
before we parse a value,
so that all gets stripped out.
Now, I need to speed up, don't I?
Yes, that's the rest
of the previous slide,
there's array and...
Objects are parsing key values
in that we're using that
separated_by parser.
Now all of these at this point
are function templates, right,
because our JSON object
is itself a template,
and in order to be able to parse a thing
at any depth of the tree,
we need the equivalent function template
instantiated at that
depth, or for that depth.
So that, as it goes,
actually works,
and that was the simplest
kind of proof-of-concept.
This is how we knew we
were on the right track.
For single values, it works,
which is to say, limited recursion depth
and limited array size and object size.
It's got a few problems.
So problem number one is
a JSON number isn't just a
simple decimal positive integer.
It's this thing.
This is from JSON.org.
But actually, if you look at this
and think about our combinators,
we have all the toolkits,
all the things in the toolkit that we need
to write a parser for this.
It's just a little more complicated
than I can put on the slide for you.
But it can be done.
Similarly, a JSON string
isn't actually a string_view
because it's got escape characters,
and in general you don't
get a one-to-one mapping
of input to output.
You can't just say, &quot;Oh, parsing a string
&quot;is just taking a subset
of my input string.&quot;
And it's this thing.
But again, we have all the
parts we need to build a parser,
and with Jason's string,
the constexpr vector string,
we have the ability to put our output
separately from our input.
So we can build this.
Again, it's a bit too much to show you,
but you can imagine how this can be built.
Problem three is a little trickier.
- [Jason] (laughs) Yes.
- What kind of compile times
are we seeing at this stage?
- Minutes at least.
- Yeah, it was, I mean,
it worked, but it wasn't nice.
- Yes.
- So, and problem four is, you know,
even if we get past problem three,
this is pretty much a killer
for any kind of actual use, right?
You can't just say, &quot;Oh, by the way,
&quot;your strings can only
be so many characters,&quot;
or &quot;Your depth can only be this much,&quot;
or &quot;You're not allowed more
than six things in your array.&quot;
- [Jason] I think that 255 characters
should be enough for anyone.
(laughter)
- Right.
All right, so we need
to get rid of templates.
So this is a reminder, so
this is part of a JSON value,
so in our vector and our map,
we're recursing the templates
using the depth minus one parameter.
So, we just built a parsing framework.
Why don't we use it to
help us solve this problem?
What we're parsing out
right now is the JSON value,
but we don't have to parse out the value,
we could make a parser that
returns the number of values
that will be required to store the object.
And that actually is easier
than parsing the object itself,
because all we do is reuse
our kind of structural code
that knows how to parse
strings and numbers
and all that stuff,
but instead of actually
outputting the values,
we just output the number
of values that we need.
So an array is just one
value for the array,
plus number of values in its children,
object the same, everything
else is just one,
and we reuse all the
structural components,
and the number-of-values parser works.
So,
now that we have the
number-of-values parser,
the JSON value doesn't need
to be a template anymore.
Oh, that's coming up.
Okay, so, the struct itself,
the struct recur that was holding
all our parsing functions,
that was enabling us to do
mutual recursion on the parsing functions,
now instead of the
functions being templates,
the struct itself is a template
that just knows how many
values we're gonna need,
and will use our compile-time vector.
And then the JSON_Value itself
is no longer a template either,
because inside the vector or the map,
instead of having the
next-level depth objects,
all we need to do is store the offsets
into the externalized storage.
So to help you understand
that a little bit,
here's an example kind of how
the object layout happens.
So if we're parsing this array,
and it's got three elements,
and one of those elements
is itself an array,
the object layout comes
out like we see here.
So the element zero is an array,
and its children are
elements one, two and five.
Those are actually offsets from itself,
they aren't absolute offsets.
So you can see at position two,
we've got the child array,
and its children are
offsets one and two from it.
And so that's kind of how that works.
And then to drive the parse,
to figure out the number
of objects ahead of time,
we need this...
This is actually a GNU
extension right now.
GNU and Clang support it.
So it's this templated operator quote
for the user-defined literals.
This is N3599, I believe,
was the proposal.
It's not in the standard yet,
but it is invented by GCC and Clang,
and there's no real reason it
shouldn't be in the standard,
especially since it
enables things like this.
- And there are other ways of
declaring your string literals,
but some of them we
couldn't get them to compile
even though our reading of the standard
says that it should have,
I believe.
- [Ben] Uh, possibly.
- [Jason] I think so.
(audience member speaks indistinctly)
- It's the--
- The templated...
So, this is not quite standard,
because the templated operator
for this form of user-defined literal
is not in the standard.
But it is implemented by GCC and Clang.
- [Audience Member] But it is templated?
- This particular form of the
UVL, yes, is templated, yes.
- [Audience Member] Okay.
- Okay, so, but having done that,
we now have solved problem three.
At the cost of an extra pass
to figure out how many values we want,
we get much quicker compilation.
There's no recursive templates anymore.
All those function templates,
all those recursive
function templates are gone,
replaced by just plain functions.
And that means there's no
arbitrary hardcoded limit
to the depth of our JSON objects,
so we can have tests that
say things like this,
where I just mash on the bracket,
and that works.
Problem four, we still
have these arbitrary limits
on string size, array size,
and object size, right?
So I thought about this,
and I thought, &quot;Well, can
we use the same technique
of precomputing size to get around these?
And the answer is, for strings, yes,
because what we can do is,
in the same way we're precomputing
the number of values required,
we can precompute the total
string space we're gonna need.
And we use exactly the same
kind of technique to do that.
Where we previously have
rightsized a value buffer,
we'll just rightsize a
character buffer for the string,
and then strings will become
effectively string_views
into that buffer as we parse.
And we can wrap up that
number-of-values parser
and the total-string-size parser.
They're fundamentally working...
They can work at the same time,
'cause they're producing
independent results
from the same pass of the input,
and just return the pair of sizes.
And so that's what this looks like.
So if we have a JSON
object with strings in it,
and we've rightsized the value buffer
and we've rightsized the string buffer,
then our parse ends up looking like this
in terms of memory layout.
We've got our values again.
For the string ones, you'll
see that the strings contain,
effectively, the string_views
into the character buffer.
We still have limits on array
size and object size, though.
And we can't naively get
around these in the same way,
because parsing is
fundamentally a recursive thing.
It's fundamentally doing a depth-first
traversal of the parse tree.
And so for that reason,
things in an array don't
have to be contiguous.
You can see in this example
that because the second
element of that array
is itself an array,
the object layout is not contiguous.
The children of the top-level
array are not contiguous.
That means we can't represent them naively
with offset plus extend,
'cause they could be arbitrarily nested.
So again, the answer is,
we've got a parser
framework, let's use it.
And we can add another pass
to make a parser
effectively breadth-first.
And the way that works is that
when you're doing the
initial pass over an array,
what you're gonna store is just
the unparsed string_view
representing that array.
All your structural stuff works,
but what you get out is not
the recursed-into values,
but just the string_view of that array,
and then once you've done that
for all the children of the array,
then you can go back and do your parsing
and put the values at the
end, where they belong,
and get all your values and
your children contiguous.
So with that approach,
what we see is,
this is kind of an intermediate
stage of parsing this array.
So we've parsed the array itself,
the array object becomes
the thing at zero,
and then its three children.
So far, we've just done the,
we've just parsed out the extents
that they have in the string_view.
And then we can go back,
having done this and made
our children contiguous,
we can go back, and then
positions four and five...
Yeah, so, in position one,
we'll end up with a number one.
In position two, we'll
end up with an array,
whose children are four and five.
And in position three we'll
end up with number four.
But now you can see that all
of the children of an array
are contiguous.
And so, an array can be stored
as offset plus extend, right?
We don't need to store
n values in the array.
And we've done that with arrays,
so we can do it with objects as well,
because objects are just
an array of pairs, of keys and values.
And the keys are strings, and
we know how to do strings,
and the values we know how to do,
so we can apply the same technique
that we applied to arrays
to linearize the object children.
And here's the result of that.
So an object is really an array
of alternating strings and values.
So with all those techniques together,
finally we get to the point where
no templates and no limits
on our recursive depth,
on our array size, on our object size,
and this is kind of what our final...
Although, you know, the
ExternalView is repeated
three times, which it
doesn't need to be, here,
but for the sake of the talk.
But this is kind of the
final representation
of our JSON value as
parsed out by our parser.
So...
I think we're gonna run out of time, but
the conclusion to parsing is that
constexpr lambdas really
enable this, right?
So that was the whole reason
that I was able to build
up the parser combinators
and actually make this work at all.
And they enable a lot
more complex literals,
so once you have those combinators,
you can plug them
together in arbitrary ways
to parse a bunch of things.
JSON is just kind of one example of
what can be attacked with
this kind of technique.
Thanks to that template
user-defined literal operator,
which I hope becomes standard,
but at least it is in Clang and GCC,
you can do multiple passes,
and that means that you can
eventually solve almost any
problem with multiple passes.
And I don't know, but maybe
there's a concept applicable here.
- [Jason] Yeah.
- Now...
- [Jason] Up to you, if you
think you want to do the demo.
- Well, you know, I
don't want to show you,
I don't want to go through all this stuff
and then not show you guys,
or not show people, you
know, the proof here.
So I just want to show you
that this actually does work.
Here is the example that you saw
at the top of the talk.
So here we've got a JSON object,
and in particular, we've
got a key value here,
which is feature-x-enabled: true, right?
And then I've got an if constexpr,
which is gonna output
the appropriate thing,
depending on whether the
feature's enabled or not.
And everything here is constexpr.
Well, std::out's not constexpr, obviously.
But you can see that, you
know, when I compile this,
I'll get either one output or the other,
depending on whether this
constexpr thing is true.
So I'm just gonna make a shell here,
over here,
and, um,
I think I built it earlier,
so I could just run...
But you know what, I'm
gonna actually show you guys
how long it takes to compile.
Oh, I'm...
Oh, I'm in my, okay.
Okay, so I'm gonna do a make clean.
And this is a few years old laptop, so...
And if I hit make, then you'll see
approximately how long
it takes to compile.
And this laptop is not very fast,
but you know, it actually built.
And then if I run it...
Where are we? Oh, we're in build.
- [Jason] Yes.
- Ah.
So it's in source, test, test,
it's test_cppcon
dash demo1.
And it says feature-x-enabled.
(applause)
So as I was saying...
And so, I have a question
for you, Jason, now,
because--
- Uh-oh.
- A couple of days ago,
I started working up a little extra demo,
which Jason doesn't know about.
- [Jason] Apparently.
- But you know, I was saying that
this isn't just applicable to JSON.
The question I have for you, Jason, is
do you think it would be useful
in ChaiScript, for example,
if you could do regular
expressions at compile time?
- Oh, regular expressions
at compile time would
be helpful, I think, for all of us.
I know you had talked about
wanting to do that, but
parsing regular
expressions is not trivial.
- And I hasten to add that
this is very much a work in progress.
(Jason chuckles)
But...
So here...
Here I have a constexpr regular expression
with a _re literal.
- [Jason] Wow.
- And you can see that it's
just like the simplest email
that you could ever imagine,
simplest email check.
And here's Jason's email.
And now I've got some driver code.
This is test code right now,
so this is a work in progress,
but you can see I've got static_asserts,
that the captured values
are gonna be &quot;Jason&quot; and
&quot;emptycrate.com,&quot; right?
- [Jason] This is even more
impressive than JSON parsing,
and I have honestly have not seen this
until just this moment.
- No, this is totally new
to Jason.
(Jason laughs)
So, uh, what is it?
- You're keeping it real.
- Cppcon--
- Like, live unplanned demos
in the middle of the talk?
- Yeah.
Well, I had to change
something up since Aspen.
- Apparently.
- So...
Again, I'm gonna make
clean so you guys can see,
so people can see, you know,
how quick this is to compile,
or at least that it's usable in real life,
in terms of compile speed.
- Yeah.
- And then if I run...
- Whoa.
- Actually there is no output,
but the fact that it compiled
means that the static_asserts worked.
- That's--
(audience applauds)
That needs a standard
proposal right there, Ben.
We all need constexpr
regular expressions.
- Off you go.
- Well, okay, so I'm going
to set a new world record
for how quickly I move through 20 slides.
- [Ben] Yes, if people
want to go out for lunch,
we won't be offended, but, um...
- I don't think the
right window has focus.
Hmm.
What do I need to click on here?
- Try that.
- Okay.
- Yeah, okay, we're good.
- All right, so,
problems and things.
Oh, so you cannot...
Anything that has a non-trivial destructor
cannot be used in a constexpr context.
So we're gonna do a quick quiz.
Is this struct trivially destructible?
Everyone raise your hand
if you think it's trivially destructible.
All right, everyone agrees.
Yes, it is trivially destructible.
Is this one trivially destructible?
We all agree, mostly.
Still trivially destructible.
Is this trivially destructible?
(laughs)
I saw someone go like this real quick.
No, this is not trivially destructible
because it has a unique pointer inside it,
which is itself not
trivially destructible,
and the automatically-defined
destructor there
is not gonna be trivially destructible.
Is this trivially destructible?
(audience murmurs)
What?
Yes, simply mentioning the destructor
means it's no longer
trivially destructible.
So this is not trivially destructible.
So--
- And it's the same if you put
equals default there.
- No, if you put equals default,
then it is still trivially destructible.
If the defaultly-defined
one would be trivial,
then it is trivial.
- Okay.
- (clears throat) Excuse me.
So, this matters because if
we wanted to somehow create
one of our compile-time constexpr vectors
or something that could grow beyond
the allowed space that we specified,
we are perfectly allowed to
write something like this,
where our push_back...
Now, don't actually implement
code like this, it's horrible.
But, our push_back, if it
grows beyond a certain size,
is able to allocate memory.
We can do that if it happens at run time,
we can't do it if it
happens at compile time.
So this is great.
We could plausibly make containers
that're highly efficient at compile time
and can expand at run
time if they need to.
As soon as we add the destructor,
the class is no longer constexpr-enabled,
and we can build this thing,
but we are basically
required to leak memory,
because we don't have any
way of calling the destructor
if it needed to be called at run time.
So, there is a proposal out there,
I don't have the number
for it or anything,
where we can do this and say
if the body of the destructor is empty,
then it counts as trivially destructible,
or is allowed at compile time,
in constexpr context, anyhow.
That doesn't solve this problem, though,
because I have to make a bit of a
compile-time/run-time decision.
I personally think that our destructor
should be treated like
any other constexpr code,
that anything that you do at compile time,
that's allowed at
compile time, is allowed,
and if you try to do
something at compile time
that's not allowed at compile time,
then it would fail to compile.
So I could put a delete in here,
and it would only fail to compile
if it actually called the delete.
So, I'm gonna skip that slide.
- [Ben] (laughs) The
wrong line, is the answer.
- Yeah, so, the...
Throughout the course of developing this,
we had problems debugging it,
'cause actually debugging
compile-time errors
in this kind of context
can be rather gruesome.
There was a couple cases
where I had to, like,
remove constexpr so that it would fail
at run time instead of compile time,
and then hop into the
debugger and be like,
&quot;Oh, I had an off-by-one
error&quot; or something,
and it was difficult to suss out.
So we're working--
- I just had to
think very hard about types.
- Yes.
(Ben laughs)
Yeah, you had to think
very hard about types,
I had to think more about, like, indexes.
So there's several proposals out there,
all of them by Daveed, right?
- Several by Daveed, yes.
- So we've got
a constexpr operator that
would help you determine
if something is being evaluated
in a constexpr context.
That could be a lot of fun for us.
Constexpr_trace and constexpr_assert
give you more debugging facilities,
so if something happens at compile time,
you could get a message printed out.
And there's someone who hacked together
a static_print version of this
for GCC that I've played with.
That was awesome.
- [Ben] We probably should've used that
to develop this stuff.
It would've cut down...
- Well, yeah, but it didn't exist
when we first developed this.
- [Ben] True.
But, okay.
Well, earlier this year.
It existed at some point and we,
we could use it, probably.
- Yeah.
- [Ben] That'd be really useful.
- And then Daveed also has
this constexpr_vector idea,
which is basically the vector
that I was playing with,
but it can actually keep
growing at compile time,
so it would be a built-in thing.
And also, I alluded to this earlier.
So Antony and Alexander,
and I cannot pronounce their last names,
have written this paper
on actually implementing
constexpr allocators
so that we can...
You could...
They made a version of vector
that had a constexpr
allocator plugged into it,
or you could do a regular
run-time allocator with it,
and it works.
I've seen the code,
it's neat what they did,
and we should probably be
moving in this direction.
Yes.
And actually, Alexander
pointed that out to us
after we gave the talk.
- Yeah.
- At C++Now.
As we already said, all the algorithms,
they need to be constexpr.
These three, stable_sort, inplace_merge
and stable_partition, all have the option
of allocating memory at run time
for efficiency complexity
guarantees, right?
- [Ben] Yes.
- But, um...
- [Ben] But the way the
standard's actually written,
they're allowed not to do that
and fall back to a weaker complexity,
so--
- Okay.
- [Ben] They could be constexpr,
and it would technically be
in line with the current standard,
but of course at compile time,
they wouldn't be able to
offer the better complexity.
- Right.
We ran into some problems with iterators,
but there's no reason why
it couldn't all be constexpr, again.
So back_insert_iterator
is not anymore constexpr.
- We wrote our own
back_insert_iterator,
just because we had a constexpr vector,
and that was fine.
- Yeah.
But there's no reason
why that couldn't be,
even if the vector itself isn't,
but if we're building our
other constexpr containers.
So, things that should be,
we mentioned swap, we did
not mention exchange yet.
- [Ben] But it's like swap.
- It's, yes, exchange
should totally be constexpr.
It's not yet.
Pair and tuple.
We didn't explicitly mention tuple yet,
had the same problem with
our assignment operators.
Back_insert.
All of standard array except for
the fill member function is constexpr.
That one I'm really
confused about, personally.
Reference_wrapper, you know,
I've actually thought more about this
since we put this on here.
- Oh, okay.
- And I'm not--
- You changed your mind?
- I'm not positive, yes.
- [Ben] All right.
- But it's a plausibility.
Initializer_lists have
issues that we can't get into
in the next negative minutes
that we have available.
Structured bindings also have
things that we can't get into.
- [Ben] I was actually quite surprised,
because you know, structured bindings,
they're C++17, they're born
into a world of constexpr.
They are not constexpr.
- Cannot be used
in a constexpr context, yes.
And of course, everything else.
We didn't really mention this,
maybe touched on it a little bit,
that as we're developing this,
we've noticed lots of holes
in standard library implementations,
even the ones that are, like, &quot;We're done,
&quot;we're C++17 complete.&quot;
- [Ben] And this is by no means
a slur on the implementers.
- No.
- Don't take it that way.
This is just highlighting the fact that
it is clear that standard
library implementations
basically need a doubling up
of all their tests to deal with constexpr.
- Yeah, and the one
that I think is kind of
personally a little humorous is...
But yeah, I mean, not in, again,
not a jab at the implementers at all,
but in GCC 7.2 still,
you cannot actually construct
a string_view constexpr,
because it tries to call the
non-constexpr string lane
to calculate the length
of the character literal
that you pass through--
- From a string, you mean.
- From a character literal.
- [Ben] But, my regular
expression thing does that.
- I think where you're not...
I think you're...
You have to, if you give it
the pointer and the length,
it can, if you give it just the pointer--
- I'm giving it the
user-defined literal, the UDL.
- [Jason] That's a different
constructor, I believe.
- [Ben] Oh, right, okay.
- Yeah because that would be--
- Yeah, that is, you're right.
- So that works.
- Cool.
So just the bare char pointer.
It can't calculate--
- Yes, a bare
const char literal that fails on.
So, well, flat data structures
were easy for me to reason about,
but once we started to get
into these nested things,
that became a pain.
I couldn't, I lacked
the imagination for it,
Ben figured it out.
Constexpr code in a good way
forces you to think about
what the lifetime of your objects are.
And I'm really big about
making people think
about the lifetime of their objects.
And like I just said,
tree-like data structures
are difficult to reason about, for me.
And if you're building
your data structures,
you have to select a size somehow.
You can write a parser of a
parser of parsers to do it,
or you have to just come up with
an arbitrary number at some point.
And error (laughs)...
That was your line item
right there. (laughs)
- [Ben] Yeah.
I was getting some quite
long error messages.
Let's just say that.
- Okay.
- That's why I'm like, well,
I just had to go back and
think about the types,
and the error messages would
give me a clue sometimes.
- So Ben already showed how
fast those builds worked, but--
- [Ben] Yeah, this
laptop's about 5 years old.
- Yes.
I would like to point this out.
Those were not debugged builds.
- [Ben] Right.
Because in constexpr land,
there's nothing to debug.
- Right.
- There's no run time.
- But if you're doing constexpr work
in your regular full application,
you might want to make a debugged build.
This is with GCC's numbers.
GCC 7.2 still held up a true
when I was just playing with this.
Basically, my laptop can't
compile this debug build.
Takes six gigs of RAM,
so it's thrashing all over swap space,
depending on what I'm doing,
more than two minutes to build,
and resulted in a 338K binary.
Keep in mind, this is a 338K binary
that does nothing at run time, right?
Because everything was
calculated at compile time.
- This is very dependent on
the debug level, we found out.
- Tweaking the debug level
can have a huge effect.
- This is a line item for
compiler implementers, I suspect.
- Yes.
They get to do the hard work.
So, the release build I measured here,
it was only 328 megs
of RAM, not the 6 gigs.
About five seconds on my laptop.
It looked like, in the ballpark,
three or something on yours.
- You saw me build it.
- Yeah.
9K binary, 'cause well,
it's not doing anything.
And I just wanted to
make a quick comparison
before we wrap this up.
Anyone want to take a guess
as to how long this takes
to compile with GCC today?
(audience murmurs)
This is a full program.
- Yeah, this is regular
standard library, not constexpr,
just using regex.
- Yeah.
- Three seconds.
- Three seconds, I hear.
- Five seconds?
- About five seconds.
It's about the same time
as compiling our stuff
that's doing it all at compile time.
So...
We say all the algorithms
can be constexpr.
And standard library implementations
might need some more constexpr testing.
- [Ben] That would be
a great way for anyone
to contribute to standard
libraries, I think, run tests.
- And you know, programming
in a constexpr mindset
changes the way you look at these things.
Oh yes, cmath is not constexpr,
that's a problem for some things.
And let's see.
- [Ben] And constexpr
lambdas are all-powerful.
- There. I will...
There.
All right, sorry for taking long
and starting late, but--
- Thank you for taking
a little bit longer,
and thank you very much.
(applause)
- Thank you.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>