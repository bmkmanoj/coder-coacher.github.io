<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Roland Bock “How to test static_assert?&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Roland Bock “How to test static_assert?&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Roland Bock “How to test static_assert?&quot;</b></h2><h5 class="post__date">2016-10-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wTmAJAk7WV4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi so my name is frolic book and I'm a
principal software engineer at peopre
financial limited I'm also the author of
several libraries probably most well
unknown is SQL plus plus 11 and that is
a library that we're going to touch the
old times during this talk as an example
of the techniques that I'm going to
present
I'm also author of a library called kiss
templates which is for a lot that's well
known but it's our it's the library that
allows you to write templates like in
lion-o for instance PHP but with the
usual type checking and named chicken or
whatever you have in a C++ right today I
want to talk to you about how to test
study this word and many people just ask
me what the hell do you mean what do you
mean test study ghost rip static asserts
itself is something that is used for
testing so let's first take a look at an
example of how it study this rule is
used so this is an example of some user
code using SQL plus plus 11
so this is an embedded domain-specific
language for SQL in C++ and you can
express SQL statements as C++
expressions and in this case it's an
update statement so we update some table
tab and set the name to whatever in this
case John Doe looks innocent but the
library is a bit unhappy with us because
the library is all about
unchecking at compile time whether
everything is right in this case and
serve wrong there is no condition here
we update everything unconditionally
that is potentially an error and it
tells you so by saying something about a
return type or something some incomplete
type voyage okay that's that's fine but
it also says you should call where or a
function called unconditionally to
either indicate what the condition is or
that you actually want to update
everything
under study the third says so and that's
one of the popular uses for a study
research you create you have tests at
compile time that produce hard errors
and they yield handwritten error
messages which are hopefully useful to
the user in order for them to understand
what they might have done wrong okay
but this is only really cool if the
conditions are exactly right for the
Stratocaster if you get them wrong then
I mean either it come it doesn't compile
if their user is doing everything right
or it does compile if you if the user is
doing something wrong and then also you
have to take care about the message I
won't talk about the message in detail
the the important thing is to be
consistent in the style of your message
I think but otherwise on the condition
is the the important thing here and your
things to make things even more
complicated so not even do we have to
figure out whether everything is okay
but we there's also this this issue that
I received a few months ago for the
connected library for SQL plus learning
from someone who used the Mike's of
compiler so MSU C and for the same code
that I showed before myself just says
well very well cannot have type void
that is not very helpful and the
settings for is gone and I was I didn't
believe that and I my first reaction was
please show me the full error message
but this is in fact ephemeralization
that is everything you get from the same
code or the same conditions only a
different compiler so the steadiest
forgets gone and this is perfectly legal
because the standard says if a broke if
a program contains a violation of any
diagnosable rule blah blah blah blah
blah a confirming implementation that is
the compiler shall issue at least one
diagnostic message well yeah so it's
legal there are two diagnostic message
possible here the other compilers
give two messages
my Cisco father just chose us to throw
one away the useful one in this case
okay so that's that that's that means
studying so it is cool it has all these
properties and we can use it in
fantastic ways but yeah sometimes
conditions might be wrong sometimes it
goes missing so it needs to be tested so
in a sense you can say we're we're
testing our tests and from a library
author perspective this is even since my
study it shirts
make sure that your your code is correct
so I'm providing tests for your code and
I mean trying to test the test for your
code so there's several meta level
satisfied okay so the goal for this talk
I want to assert that my that all my
studied shirts actually fire exactly
when they should and well as a side goal
this would also be fine if I could test
that MSV see users actually also get
some some useful information good so
here's some basic approaches if you go
to stack overflow and search for how to
test stereo third you might get
something like this so first coasteering
and because he cannot test it that's one
popular answer you have to just do code
reviews are basically coastering
and many people just do that and i have
to admit in the past that i was also one
of my my approaches for this at least
for the for the part where you where you
want to make sure that the study was
sort of actually does fire in the bad
case the good case is easy right just
you just write test code everything that
you think that should compile and that
compiles and you have one side of the of
the test already done but the bad the
bad part making sure that that it
doesn't compile while you do some so
manual tests may be them sort of then
some code staring and then you're done
what are two good another option that is
also suggested several times on
stackoverflow is something like this so
you translate the study desert into a
runtime a sword okay that is probably
not a very good idea but it seems to be
popular or doing something like this you
translate the study assert into into
throwing some funny exception but yeah
everybody knows that here hopefully in
the room
are you certain most or very often used
to to protect you from something that
wouldn't compile anyway and so
translating that into runtime simply
doesn't work okay so since is a compile
time error we can just compile code and
and see if the compiler fails to compile
is there is a typical unit test write to
you you have something that is supposed
to fail the program that we test in this
case was more or less the compiler and
the compiler should fail with the code
at you that you presented for the test
failures for the test cases that should
fail so here's some some seem example I
won't go into in too much detail but the
ideas I have a function that I can call
with a file name and some some petra
some text Pegram's that i expect from
the static assert that I use make test
make tests calls their compiler with you
appropriate attributes and the test is
successful if this text is found in the
error messages okay this is one one of
these tests test files that I have and I
have a bunch of those you can see all
the blue line is the one with that we
want to test in this case you have an
aggregate function Max and somebody
calls Max on on this aggregate function
again that is a legal arrest 'real there
the library is supposed to catch that
and it does but it's a it's a bunch of
boilerplate
that you need just for this one line
that you're really interested in and
then you have to test that with a
regular expression and see if they sell
your attack it's actually fine there's a
lot of a lot of work for just one test
and I have about a hundred studies words
in my library and I would like to do I
don't know 20 maybe even more tests per
studies her so I would end up with like
2,000 or 3,000 of these files that
doesn't really scale and I'm not going
to do that so um then suggesting when I
handed in this talk from from one of the
reviewers was well compiler developers
need to test study sir it's a compiler
feature so they have to have features or
tools to test that so yeah and one which
is very overly available is blending
diagnostic messages you can actually
annotate a piece of code with the
messages that you expect the compiler to
generate and then with this funky
command down there running clang and
then clang will compare the messages
that is actually generating with the
ones that you say that you expect to
generate that is nice and a certainly
helpful and and there are a bunch of
test files in the clang repository to do
exactly this one thing that you notice
is that the expected error even for this
very simple thing here doesn't even fit
on the slide and if you had reasonably
complicated template code than this line
if you put everything in one line would
go outside of the building so well you
can use clingfilm art put it into
something something more readable but
then the compiler says well I don't
understand what you're saying
doesn't latch okay so
this doesn't really work so I don't know
for practical purposes
I wouldn't use done and of course it
depends on the on the exact compiler
compiler version and yeah as I've
showing it to brakes if you're using the
ancient knowledge tools good luck dude
but even if we used something like this
does this work in real life I already
indicated that long I mean you would
have to have many many test cases anyway
I would probably take forever to compile
all these but let's take a look at a
real example or Evernote very simplified
excel file should say we're going to use
this example throughout the talk
basically with very little variations so
let's try to understand what's happening
we have some struct a that has a
function bar which turns void we have a
template function foo that column can be
called with any type and the author of
the function thought well would be
probably very good if if this type T
would be either a itself or somehow
derived from a and we test this with
this stood is base of and if this
condition is not fulfilled then we fire
a static assert other and call T dot bar
afterwards ok and then we call foo with
an int which of course breaks right and
when we compile this and we see the
typical output from compilers like GCC
or clang is like this year get this some
study search failed with with a string
of the study circle and then just to be
sure that you know what we're talking
about tells the occasions to study you
serve with this condition and the
message again so you have the message
twice but that is not true for all
compilers sometimes you only get once
less you see only shows you once then
the compiler carries on it doesn't it
doesn't stop there even though it's a
non recoverable error
so at least clanging Jesus he just
continued and say and by the way you
can't call bar on your end that doesn't
make sense on the other end I don't know
I haven't tested this with NS you see in
some condition you've already seen this
doesn't happen because it stops us with
the first error okay so if you want to
really make sure that everything is fine
I there's a lot of innocent wins in
order to to really analyze this and make
sure that everything is okay because
different compilers do different things
and they might carry on so if you wanted
to do multiple tests in one file which
would be much easier and much more test
friendly much more much more believable
that somebody would actually write those
tests I wouldn't want to write the
patterns for for this kind of stuff to
make sure that actually the correct
lines really fired and about the
incorrect lines so and then there is
another case this is a function as it
was about one and a half years ago in
SQL plus plus eleven this is the
representation of the from clause of an
SQL statement the from Clause takes a
bunch of tables and well you have to
make sure that everything is actually a
table because just by saying this should
be a table it doesn't make it actually
happen but this really is a table you so
you have to test it test this on the
study is sort of everything is a table
okay and then we also have to make sure
that table names are unique because
otherwise the from Clause is illegally
if you have tables multiple tables with
the same name it doesn't doesn't work
okay but there's a good chance that the
second study wizard doesn't even compile
if the first study is heard fails and
then you're in trouble I I wouldn't even
begin to try to are to get this right
with
either a build system or or with the
diagnostic messages for client so we
need to do something else and the first
step is to clean up the mess we have to
get rid of some of this nonsense that
the compilers generate and there are two
techniques that I presented earlier and
others presented earlier and other
charts so let's get quickly through them
first is tag dispatch the idea is that
you move the implementation of your
function into something into another
function called whatever your function
name is underscore info or you can any
with any name that you choose so in this
case full emple and you give it another
parameter that you use to dispatch to
these functions in this case I have one
that takes a true type and another
overload that takes a false type the
true type version on dusty the normal
body and the phones type isn't even
implement because we don't need it only
gonna be called in the fail case anyway
and the the function here so the
interface function that you document it
in there and your API then contains the
static assert with this conditioning and
afterwards directly dispatches to the -
one of these two mple functions okay
makes sense whether it uses the same
check and is either true or false so if
the static assert fires then the the the
second input function will be called
yeah I
I'd say it's I'm sorry the question is
if it's a problem that the false type
has no force case doesn't have a body
I'd say is even as even helpful because
if for some reason
the the static assert is is turned into
a sea assert or something like that
somebody does something very stupid in
the study assert doesn't fire then at
least the linker says well this doesn't
work so it's a you can also do that yeah
right okay otherwise clear like
dispatched okay good
what I just said that the these follow
up errors don't happen is not exactly
true in the case the return type depends
somehow on the template argument if that
happens and then there is a good chance
that that the return type doesn't even
make sense in those cases where your
your templates arguments are bad right
so in the bad case well then you would
in this case so if we write it like this
and you would still get all the error
messages from trying to construct the
return type which means that the the
second step after Tech dispatch that we
have to do is we have to change the
return type for the bad condition and I
don't know SQL suppose Devon I used
something that's called that statement
because that is also an indicator world
took your statement is bad it's all
about statements in that library okay so
we do something like this basically the
same functions as before on but instead
of giving the same return type we're now
returning that statement okay and then
we have to do deco type or you have to
use tackle type to determine which
function is actually called to determine
the return type just in case you're
wondering
I'll C++ 14 there's this funny feature
of determining the return type
automatically or let the compiler do
that that won't work because in order to
do that the compiler looks into the body
of the function
and there's the static sir
okay so if you yeah so in that case that
even though the techno type which would
already break right so when we when we
use this code we're doing something
stupid so we call the function with a
with an end and then we do something
with the result something that is also
not working because it's broken anyway
then GCC and clang say okay well there's
no xxx in that statement if he must've
expected and there's also the study cert
so everything is cool and as you see
says well there is no X existed in that
statement
so we suddenly rep reduced this even
with this very very simple case the
situation that as you see doesn't give
us any useful information petal because
that is all that we get all right um and
well okay we were able to clean up a
bunch of of the mess but we're still not
closer to actually testing the static
assert you don't know we cannot somehow
access the ascetic assert inside the
function doesn't work so what we have to
do is you have to do something different
and I want to show you how to actually
make it testify so what do we really
need to do in order to test whether the
study is writ is firing or not well
there are two things first we have to
test the condition we need to make sure
that the condition is right the other
thing is that we have to make sure that
the status or is actually kind of linked
to calling the function
and we when you think about this in
there's nothing that says the study so
it actually has to be inside the
function there's not required okay so
what we do is we reorganize our code a
code a bit and so I'm trying to describe
what we were going to do in the next few
minutes and I mean I break this down
into simple steps and we will see how
this are magically evolves into
something that is actually making
studies first testable so the idea is
that well we have this conditional study
assert status or it has a condition and
certain somewhere we break this apart so
we turn we take the the static assert
rip the condition out and make it
unconditional but wrap it into some type
so that whenever we touch it it
automatically fires unconditionally we
take the condition and and use it to to
construct a type that either is this rep
status or that always fires whenever we
touch it or is something completely
harmless and then we use this this type
that is now conditionally either
dangerous or not then we use this type
for the tag dispatch it also has a
return type which seems to be useful
okay that's what I just said
so let's let's do that step by step
first we just find a small helper and I
don't know if you've seen all your tops
of Mines this is always coming up here
because it's a very useful thing let's
say it's a template that that takes some
type and it has a value that the value
is always false well look only the
compiler doesn't know that because the
compiler has to assume that well maybe
maybe some fine
day somebody will create a
specialization for this type which
hopefully nobody ever does but in that
case who knows what the value is or even
if there is a value but for our purposes
is always false
and it's called that the compiler
doesn't know about it because that means
we can use it to to create a static
desert in in a type in this case in the
constructor of a type that always fires
whenever this type is being used so we
have a struct that we call basically
what it's supposed to represent
so it's a asura dart is derived from a
type as a constructor with a default
template argument so it's a default
constructor and you can call it just
like that you don't have to provide any
argument again the compiler doesn't know
that it doesn't know how you would call
it and therefore it doesn't know what's
happening inside the study this word
static assert is always false you know
that but the compiler doesn't so we now
have something equivalent tool and I'm
just in C++ whenever somebody constructs
the same he or she will get a study
dessert all right Watson eat some
counterpart in this case I just call
this class okay it is empty it has a
compiler generated default constructor
that doesn't do anything in particular
it doesn't do it doesn't fire a static a
certain and then as I said in the
beginning we'll we'll take the condition
this is base of a and depending on the
type this meta function check art will
either return an OK or this rep static
wizard all right
okay and then we change these simple
functions a bit we don't do the tech
dispatch on true type and false side but
instead we do the type dispatch on okay
or anything else and anything else is in
our case then this 1/3 art is too bad
for made and we use this both as a
parameter for the function to determine
the overload and also as a return type
for this function and in the in the
interface of your library or a applause
you do the same type with declan type
the same thing with echo type as before
only in this case well cuz you can you
call the the constructor of this one
check art and then you call the function
with check out okay so well this looks
kind of similar to what we did what we
did before with the with a true and
false or a different retard type so
let's first of all let's test if
everything is still okay that we didn't
mess this whole whole thing up okay
right so two test cases get gold here
the first is is the well-known not
functioning and a second one is the one
that works okay that's good and yeah
sure Jesus E and clang say well XSS is
not a member of fun sort of artist
arrived for me and there's also the
study the search so everything looks
fine like before and the good call
doesn't cause any messages that is
expected so that's fine and M SVC or
still doesn't report the static assert
but at least we now have a return type
that is somewhat useful so even for this
crazy situation but the static sure is
gone
we have some information that the user
of this compiler camera
used to I don't know look it up in the
code which should have happened
or you could document this or whatever
um this is useful so it's not just lost
information right and if we ignore the
return type so if you don't try to call
a member function on it or if you don't
try to forward it into the next function
or whatever then NECC also says well
there is no status right here there's
this C 2 3 3 8
I think that's code for study desert and
yeah and also mentions the type so
everything is fine
so all compilers behaved reasonably we
haven't broken anything we have improved
those situations for NS PC users what
else so let's take a look at the return
type again the cool thing about deco
type is that it and I cannot give you
that understand at ease but it really
stays on the surface let's say of the
expressions and so it doesn't only go as
deep as really necessary to understand
what the or the type is did your that
you have here in New York expression so
in the the red pod it takes the look at
this check arc of key default
constructor and it knows well that is a
that's going to yield an object of type
of this type and it doesn't look into
the implementation of of this
constructor therefore it doesn't run
into the static assert okay and then it
can choose the right overload the
overload is also uncritical it doesn't
have body which could contain anything
dangerous it just returns something of
this type that by itself is also not
dangerous or nothing happens so it will
just say ok and the failure case all the
return type is this which means that
when we actually call the function we
run into this sighting assert
but if we analyze the return type well
then everything is golden because we
don't run into the static answer and we
still know what's
to happen okay make sense so that means
we can write tests like this so the
first line is we call foo with some
valid argument okay now we can use the
same and study sir to you make sure that
the return type is as expected
it can also call foo with something that
is not okay and can use is same and
static assert to make sure yes that is
that is the type that is expected
because we know that this one contains
the static sort that should be fired
when we call this function this way and
and we we've tested that this actually
it's gotta happen right so this means
that we can now use static assert test
study ascertain which is weird and when
I third first thought about this well
this is not possible because studying
sir is a hot error so you cannot
normally use it for testing setting cert
but by using this indirection this as
possible now so yes we can use study
assert to test setting assert and it's
one line per test and we can have
hundreds of tests in one file and it's
it's really convenient to do that okay
okay so now we just changed a little bit
of how the static is heard is is linked
to the function well we don't have it
directly in the function instead we just
move with it out of it and suddenly it's
trivial to test whether everything is
fine all right and I love this one so I
migrated lots of the study not not all
of them yet but lots of the studies
roots in SQL plus plus 11 to this
pattern especially to get less
complaints from Windows users and when I
did this I created a branch ran exactly
the sound
on msec our first client okay so plane
I'm still does the youthful thing so it
says something about the settings hurt
and says well this is happening in the
constructor of this cert where or
unconditionally called but M SVC says
well there is a steady assert here
and it's happening in this in the
constructor of this type so I have no
idea what's happening I have no idea
what the logic behind us
I will not invest even a minute in
trying to understand why this is but for
some reason now I even get the study
cert in MCC I have no idea where hassle
maybe it's about code complexity even
didn't really change much from the old
implementation to the newer whatever
good so um
short summary of what we've seen so far
so first of all you should clean up your
your functions when you use static
assert that is I think a must use tech
dispatch and failure return to reduce
the amount of error message does but
users get and then if you want to test
study asserts which i think is a very
important thing to do then I'll split
your conditional static sorts into a
wrapped unconditional static assert and
a conditional type that is either
harmless or this rep study destroyed and
then we use this conditional type for
both tech dispatched and in the in the
bad case as a as a return type then we
can write straightforward compile time
test for all our static asserts very
simple and if you remember this was
funny from function with multiple static
sorts
well that's easy too because it's much
cleaner than it was before
because this does technique with using
state conditional or you can write your
own equivalent of that withstood
conditional you have one conditioner and
check whether it's okay or it's it's the
failure type and you can change this
internal
so you can enchain multiple conditions
with multiple different reps static
asserts so depending on which condition
fails you can deliver individual error
messages or you can put everything into
a tuple and make everything fire it's up
to you so you have a much greater
flexibility of what you want to give to
your users I tend to just say one thing
at a time but you have the flexibility
to do whatever you want and it's all
still testable in the same easy way as I
just demonstrated right now this is all
very very cool you have to do one thing
when you use something like this is
every now and then you should write a
unit test that make sure that the
compiler actually fails in the way that
you expect just to make sure that your
mechanics for all of this are actually
correct because well if you if you
modify it a bit because you think that
that wall is this old approach that
maybe it's not performant enough compile
time performance and I want to do
something better you have to make sure
that the compiler actually fails in the
way that it that you expect it to fail
but of these tests you need just a few
and the majority of your tests you can
write in this way okay yeah have fun
with that we can continue with either
questions or I have some bonus material
about on how this might look like in the
future with with future features okay
question
okay okay so the question is if I can
show the the Metro that is used to to
create these things well I don't have it
here right now but the macro is trivial
the macro takes takes two parameters on
a name and a string and the rest is
always the same so the name is the the
name of the of the type the string is
the message of the static assert and
since it's unconditional you don't need
to pass any condition into edges I mean
all of these look the same yeah so the
question is if I use this macro written
condition with you conditional thing yes
so I have one line basically
constructing this this unconditional rep
static assert and or maybe multiple to
create multiple of those and then I have
a battery of of conditions linked to to
these rat studies earth
Richard you had a question Terry
okay so the question is what about
messages in study hazard in simplified
17 it explicitly gives you the
possibility to emit the message and well
you've seen an even code in one of these
slides where I omit messages as well
yeah yeah we are so for for things like
this where you just write tests to to
make sure that your library is okay and
basically you give you some studying
service to you you know test your code I
think that's that's cool because I mean
what do you want to write in there like
this is a type requirement or stupid
things like that and you would always
repeat the same message it doesn't give
you any value so for those yeah the new
feature is cool and until then I would
just just use empty messages but
otherwise um if that is basically part
of the interface and you want to have
studied the first two to tell users that
are using this code in an in a way that
is not intended in those cases I would
always could get a message in there
okay so if you want I can go to you some
future material another hand person sure
about this because this is my the other
stuff is a bit is used in production
ready code on this one here is just on I
don't know I did some experiments and
this is what I think that we might end
up with so conce expert if is something
that is on almost certainly going to
come in c++ 17 it's a it's a funny name
for something that is written if cons
expert and con if cons expert works like
this so you give it a compile time
condition and then depending on whether
this condition is true or false one or
one or the other of the of the blocks is
executed by the compiler is compiled
actually and and the rest is pretty much
ignored as to fulfill some conditioning
but i don't know syntax basic syntax
checking or something like that
but otherwise it is ignored and so if
you forget about all the testability
this is very tempting right now so you
have this you have this check let's
check our of t you can use our user
using to to make sure that you only have
to write this once because maybe this
check is is something this big and you
don't want to repeat yourself and all
the previous examples you had to write
the check at least twice here well you
can just use an alias type alias for the
check and you say if cons explore check
kolonko on value assuming that that the
fail cases all have a value of false and
the okay has a value of true then well
there in the good case we just call the
function body as it was and in the bad
case we return the
the check which will then fire the study
disorder okay so that is that is awesome
in terms of expressiveness I really like
that the and is one of the reasons why I
say that well Jana was I mean happy
about the features that come to see dr.
Santino I think there are very very cool
features I'm pretty happy with what's
coming there but in terms of testability
well here we are in order to make this
work we use return type deductr and as
said before well return type reduction
means that the compiler goes into the
body of the function or in the bad case
well it will run into this default
constructor of of check and return type
reduction works is slightly different
than deco type for whatever reason I
didn't really understand the standard
ease for that but all compilers agree on
that and it runs into this data concern
just for detecting they did they return
to it so we cannot test it this way so
yeah what we what we have to do is
something slightly different so instead
of having the the study assert in the
the return type we now use a compiler
generated return type which does nothing
so this is totally harmless again and we
need to use just some randomly named
static function again it's a template
function with a default template
argument so we don't have to care about
it and this fire is a study so okay
and then nostalgia um using pet
statement again like I did before but
this time is a template and this
template can be templated with one of
these reps setting a search and in the
constructor it will call this this
static function that we have her on the
static assert so whenever we call
whenever you construct this bad
statement then it will fire a static
ascertain okay and then we need
something for for a time type magic so
we created a type a conditional type
that checks whether this is the return
type or something else whether that is
one of these rep static stress
yeah they now all have to derive from
something or I have to have some tag or
whatever you have to have some marker or
that makes them detectable or so let's
use this data space or in this example
and if if they are one of these reps our
users value well we construct a type of
bad statement of T otherwise it's just
team where we can use it now the input
function is exactly what we saw we've
seen before so this function that is so
nice and expressive and easy to read and
easy to reason about and now everything
is fine
well if you call this function you call
the constructor of check the constructor
is harmless now so this is all fine so
when we when you return ton deduction
kicks in nothing bad happens then the
return type of our interface function
use this make return type meta function
which yeah it just calls this that just
uses the user's dekhna type or it
operates on techno type for our food and
people if the good case then the return
type stays it was it's the bad case
then we wrap the return type to do bad
statement of this return type and if we
construct this bad state in return type
then it will fire ok so in the in the
last line and this our return through in
pull of T this will be used as an
argument for the constructor of the bad
statement of T okay make sense and that
constructor call us to the static assert
as to consider some the static function
of the rep study assert and that will
fire okay ah okay so the question is why
does the study the sort function come
into picture so that's the that is the
the constructor the constructor takes
one of these rep study desserts as an
argument okay
and then we call the static static
assert containing function on your on
this type okay and in the our interface
function since the return type is a best
statement of of this rep distort assert
type and the constructor of that is is
implicitly contain converting a rep
study assert into this pad statement the
constructor is called and will then fire
the study sword make sense okay
yeah so I like this a lot
well secret 417 is available and I
finally migrate my library to that I
probably will use this pattern because
once you establish this on its it's easy
to use easy to understand and compared
to you to a lot of other mountains that
has to be done in this library this is
really nice
okay so yeah no yeah do you don't have
function over loads or the check only
needs to be called once then that is a
very nice feature and so no no
possibility of typos there right and
then we have concepts consoles right
hopefully and simpler first 20 this is
not they use that and enter Saturn and
and and youngsters who have envisioned
but if you if you prefer to have the
messages from your static assert then
this is one way to do it okay so the we
have two overloads now of the of the
interface function one requires that the
that the check that we do on the the
template arguments yields true so
everything is fine that we do just
whatever we want to do and in the other
case the other case is just the the
fallback case but it doesn't require
anything so that is less specific
it will only be called if the first
overload doesn't match and in that case
then we return check out of T which then
has the desired behavior okay so this is
if you want to keep your study assert
messages and your not because maybe
you're not happy with whatever messages
the concepts light implementation of
your compiler will generate what I think
is likely okay so yeah and otherwise
well if you if you don't use a technique
like this then you have to find out how
to test yours your
concept light enabled functions but I
think that should be pretty much
straightforward if you're into this kind
of stuff because that actually can be
done with fee night so you're back to
stuff that you can wrap a bit up and
then you're back to one-liners but yeah
for this you have to be happy with what
the concept errors a few compiler
alright more questions okay so the
question is basically can I kind of
reduce the amount of code that I have to
write to create all these studies
certain cases so and one of the
questions or part of the question was
what about the the okay type and do I
have to have several versions of those
No so for the okay type I just have one
day for all cases for the static a
service the rep setting source on I I
have this macro so it's a one-liner but
that that will generate a bunch of code
will generate a bunch of struts unless
as far as I can tell there's there's
currently no way around this and I I'm
not aware of any proposal to change that
because the study was hurried or the
message of the static assert has to be a
compile time string literal and I am not
aware of any way to to moving those
around or to have those as as template
arguments or anything like that
but in the end I mean the the difference
isn't that dramatic
you have to provide the string in some
way anyway because regardless of whether
we write a normal study who's hurt or
this rep study this retainer in a macro
or maybe later somehow in a template you
have to write this message anyway you
have to write the conditioner somewhere
if you organize your code a bit to to
work with this pattern the the amount of
overhead is very low for this technique
and the game is is enormous because you
now have the ability to test that this
studied your certain stuff which is part
of the interface that you're providing
is actually working the way it should so
for me personally this is totally
justified but yes I have to write for
every single static assert one of these
one of these classes and they have to be
are injected into some some conditional
or some other things so the question is
whether this technique is applicable or
so for studying certain and the bodies
of of classes so I try to avoid those I
try to to move studies that I that I so
I had that's a hedge study whose hurts
any classes I still have some of them
but they're all they're all not
necessary anymore due to the interface
that I've chosen for the library so I
have a bunch of factoring methods that
return objects of certain types and the
static certs are are being moved into
those factory methods and the classes
themselves don't have anything if
somebody creates or constructs these
classes on their own and then runs into
a horrible compiler errors that's their
fault or they're their problem the
interface of the library says please use
one of these contract I can't factory
methods
then the factory methods are protected
with statics which which are then
testable otherwise other techniques
would be to move stuff into the
constructor constructor is probably not
not that easy
oh yeah we'd have to have something some
function that he called from the
constructor for this to happen but you
could probably also juice a few things
with specialization but I would have to
think about this a little bit more the
onion did the short answer was what I
gave initially I try to avoid having
study this verse directly in the class
body right sorry no more questions then
thank you very much oh sorry if expert
functions could be used to pass this the
rep study research around I mean yeah I
mean if you get it constructed um
depending on on which version you're
referring to so if you get it
constructed somehow even sure you can
pass it around it's just an object but
as long as you don't touch the function
either the constructor or the this
static function that was used in the
context proof thing you can just pass it
along
it's one of the one of the use cases
within SQL plus plus eleven that you can
pass this this type around you can or
you can could also pass the object
around this way you can transport static
asserts to the to the library interface
boundary so if you have something some
static sort but just I just way deep
into your and you have template
metaprogramming nonsense but nobody will
understand except for you you can use
these rep static sorts to to basically
propagate the static assert to the
interface boundary so that is very close
to the
to the cold side ideally directly in the
function that the user was calling so
that the error message that the compiler
generates is as short as possible it
sounded to me like you were complaining
that the compiler didn't stop spewing
out error messages when the static
mister file yeah it sounded like this
talk you thought that was a desirable
feature so have you made the decision of
that was I wrong okay so the the
question goes in several directions as
one's I think but so the question is
whether whether it's good or bad that
the compiler carries on because
sometimes it does sometimes it doesn't
it's not always beneficial either way so
I don't know the when I first saw this
behavior of of the microscope compiler I
thought that's that's absolutely
terrible because it swallows information
that is really really important on the
other hand in many cases you wish for
less spew from the compiler so sometimes
it's really cool if it stops producing
all this nonsense I haven't fired a bug
yet I don't know because it's legal it's
a bit hard to fire a bug for that I mean
on the other hand II the behavior is
quite inconsistent so maybe I should
maybe it's a would be nice feature for
for compilers in general to you to tell
them okay well once you hit a certain
kind of error so for instance aesthetics
or just stop or it doesn't make sense
anymore maybe it's officially a flag for
that but I have no idea how complex this
is maybe we won't find any I'll talk to
Chandra about this
all right no no no more questions right
now then thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>