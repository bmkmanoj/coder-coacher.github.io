<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Richard Powell “The Importance of Being const&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Richard Powell “The Importance of Being const&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Richard Powell “The Importance of Being const&quot;</b></h2><h5 class="post__date">2015-12-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Y1KOuFYtTF4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi my name is Richard Powell I'm an
audio software engineer I put together
these slides for a discussion group we
had at work and I thought that this
would make for a really great talk I
called it the importance of being Const
it's these are slides about what Const
is how to use it what it does and some
interesting sort of side effects of when
you use it and what that implies for
your code so I started off with this
wanting to make it a slide deck more
about why uh what costco helped you do
and it's actually turned into being more
about how to use cons so let's dive into
this and we'll start off with a couple
of definitions about Const that i have
picked up from various books so starting
off a great quote from Scott Myers and
effective third C++ the third edition
not the modern one but his older book
im3 starts off talking about constant
how you should use constant why you
should use constant it says console
iäôs you to communicate both - both
compilers and other programmers that the
value should remain invariant whenever
this is true you should be sure to say
so because that way you unless your
compilers aid in making sure the
constraints isn't violated okay cool
sounds good and if we also look some
other places in the Google styling guide
coat styling guide it also talks about
constants this Constable's data members
methods arguments all add a level of
compile time checking is better to
detect early errors as soon as possible
we therefore strongly recommend that you
Scott's whenever it makes sense to do so
so great sources great thinkers and C++
telling you to use Const well what is
cost so if we look into the standard and
we read it what cost does it says a
Const object is an object of type Const
T or a non mutable sub object of such a
type and that's they're opaque statement
but let's break it down so and after
that statement actually has two examples
of how you would use it you get cons T
of a tea or a tea
it's tea and they say that these are the
same thing this is the where you put
your constant modifier on your object
and it says non mutable and what does
mutate me Mutai means to change or to
cause to change in the form or value so
declaring an object Const means
expressions which would modify the
object are not allowed okay great so
let's go through some expressions and
we'll just play a little game here this
is sort a little bit of artists
participation and I'm just asking if you
could put a thumbs up if this statement
is valid in the thumbs down if this
statement is not a valid expression so
all right we'll start it off so I've got
my int main I declare an int in a and a
long Const B yeah and I have a bunch of
statements so express statement one will
I compile great B know lots of thumbs
down okay so is line three
great it's definitely greater than e
they're equal yep this uh statement five
but I'm just comparing greater than up
right yeah it's a typo in the slides or
a typo that you could mend and this is
exactly where constantly helps you out I
really didn't mean greater than from
equal to
and what about this last one I'm not
modifying the value it still has to
create code for it that expression is
not valid so that is not a valid
expression even though it didn't
actually result anything he say maybe
the compiler could know that it's not
modifying anything and probably optimize
that statement away because it's it
knows what the answers going to be but
the type checking system has to say that
is a valid expression and the type
checking system will say that's not a
valid expression all right moving on
let's try something a little more
interesting here this is my one of my
go-to interview questions that will
bring two people and so I
an array of integers I have pointer BCD
Yi and I've all declared them various
versions so let's try that exercise
again line 1 valid expression thumbs up
line 2 valley expression yep 3 Oh some
down some up that's a valid expression
ok
line 4 okay that's definitely thumbs
down 5 ups downs in the middle nope you
got a bunch of downs right a line 6 and
how about the last two down and two
thumbs down so one thing that people do
is they often get confused on where does
the constand so the secret for
discerning these statements is to read
them from right to left so in that
statement I a P 1 P 1 is a pointer to
int Const or constant in so you kind of
have to rearrange your sentence when you
read it that way however P 2 it's a
little easier to read P 2 is a pointer
to constant int really easy and then if
we take a look at P 3 if here to read
that P 3 is a Const inter to int and
then before a constant pointer to
constant is and so this is the reason
when you read it this way if you're
reading it from right to left it
actually really helps you see why the
type preceding the Const keyword is
becoming the preferred way of writing it
and I highly recommend that's what you
start doing in your code is putting the
contact of your type it makes it a
little readable it's easier to discern
so let's pick apart that statement again
a Const object is an object of type
quantity or a nominal subtopic of such a
type that's one of the statements I say
and also what happens is once an object
becomes a constant object by the
compiler
like compiler can't really the compiler
is not able to remove the cons from that
type it's sort of in becomes that type
it's a new subtype that is what that
type is so you know once you've said
this is a type cost object the compiler
can't remove it and or my wife helped me
she came up with this phrase I'll leave
you with which is once you are Const you
are ensconced so you can take that one
home with you well not entirely I mean
it's true people will point out there's
a way to get back you can you can always
contour you know use a regular cast but
I think after we've seen from her
putters sorry bruh yarns talk is that or
as herb sliders talk about how if you're
subverting the type system if you want
to cut across the type system you start
entering into a world of danger so you
know that's where you've opened up the
drawer of knives so we're not gonna talk
about cons cast in this condom so we're
gonna keep it straight no casting no
subverting the type system so what
happens is the compiler when it is doing
these expressions to turn German if
they're valid for assignments will
actually take a look at the type and it
is free to implicitly add cost to
expressions to make sure that they are
valid expressions so here what I have is
a I started off with an int D I'm gonna
take a pointer to it and that's fine
that's a valid thing I can do I'm not
changing the types here when I say P
assign P to to P p1 p1 is of type in
it's a pointer to int it's not a pointer
to constant int
however the compiler can add Const to
make that expression valid so that isn't
that statement is valid it is allowed to
do that however it's not able to remove
Const and the interesting thing about p3
here is p3 is pointing you know you're
saying I want to assign p3 to be p2 now
p2 originally started off its existence
as being assigned to p1 and p1 was a
pointer to mutable ends and p3 is a
wants to be a pointer to mutable ins but
you
go through that route you can't the
compiler cannot remove the Const from
that point uh that type for p2 so that's
not valid but it is able to add cons for
p4 you know you're able to add a type
Khan Spore you can as I should say you
can make the pointer itself cause it's a
free expression that you can do and the
same thing over here if I originally
started off d2 as being a pointer a
constant int you can't remove the
continent's to it to make a pointer so
err that will not work and what holds
for pointers holds for references almost
so the whole statement everything I said
was true except the one expression
that's a little odd is r3 or sorry r4 so
you can't add ref qualifiers too or you
can't add consequence to the ref it's
sort of meaningless so huh yeah exactly
that's exactly right a reference is
where it's a alias for another thing it
is that thing essentially and so you
can't reseat the reference you can't
change the reference to anything else it
effectively is cons so there's no reason
you know sort of I don't repeat yourself
there's no reason to say that or the
compiler will actually not allow you to
write that statement so what's cool
we'll do our little exercise again so
what I'm gonna do now is I just slight
change I am going to create a food
struct and inside of it's going to have
an A and a B object and a is an int and
B is a constant so let's do that again
so line one is it a valid expression yes
line - is it a valid expression no right
and that makes sense because these are
what we said that's the B and the confi
are not modifiable okay because it's a
constant what about if I make my straw
cost I'm declaring now constant foo and
a nope and B no all right
and now let's say I took some pointers
I'm going to take a pointer to F so now
F points to a is pointing to foo and a
constant pointer or it is a pointer to
constant Fu's and let's do the same
thing now is a valid or sorry what about
say a line five yeah and six nope
pretty straightforward like the same
thing as before what about these two
statements valid okay and number eight
also valid so I was just as one of those
things is like you might not look like
that one I was trying to catch a couple
folks on because I'm actually modifying
the pointer itself and as I had done
before the pointer is not declared
constant that one only what it points to
is constant all right so what about
Const through a pointer into a struct so
what I have here is I have just a data
member at the top and I know these are a
little bit of contrived examples
probably in your code you have more
meaningful stuff but I just threw these
together for examples so I have a int on
in the static space and my struck foo
will have a which is pointing to data
and B which is a pointer to data but it
is a pointer to Const int so and the
same sort of exercise so instead of
incrementing the pointer I am going to
actually modify what's pointing to so
line one is that valid yeah - no okay
right now I'm going to say this is a
constant true is that ooh all right well
apparently my slides got mucked up so
how about we move on to line four
because that's the next one over here a
little bit out of order is lying for the
fourth line commented valid no it's not
and apparently line three got skipped
okay and then what about line five we
will in a second
my building got screwed up parently
last-minute changes to my slides we're
not we're done in haste I'll get back to
you line three on it so skipping line
three and moving on to line five so now
at this point we have a pointer to foo
and a pointer to Const whew
and line five is that valid and line six
great and what about if I label my foo I
go through a Const pointer to constant
food line seven and eight is line seven
valid a little bit it is valid and
that's interesting
what about line eight oh wait oh here's
line there's number three okay so line
eight is line eight valid it isn't that
so line seven is actually kind of
interesting when we look at it so I have
declared so that cost pointer foo is
actually a pointer to constant Foos but
I'm allowed to modify what a points to
in it and that's interesting what I'm
doing here is the structure itself is
constant yes I am NOT actually modifying
members of that kind of structure but
I'm modifying things at points to keep
that in mind
hold on to that thought keep it buried
away we're going to come back to it but
what it is is it's that is interesting
isn't it let's do some functions where
I'm going to pass it pointers so I have
three functions here actually well at I
have four functions but three of the
three functions and one function with an
overload and so I have function one two
three and three yes I lack imagination
when I name my variables and they take
foo pointers or who are pointers to
constant food
so function one takes a pointer to foo
function two takes like a pointer to
constant two and function three can take
either a pointer to foo or a pointer to
constant foo and well am i I will in my
function have a foo object a pointer to
foo and Akon's pointer to foo great cool
so now instead of like valid expressions
tell me if it's a valid expression and
if that's a valid expression what would
it print so line one is that a valid
expression cool right and what we expect
it to print thunk thunk one yeah
how about line two no not a valid
expression so it doesn't print anything
line three yeah okay and what we did
print function to yeah that's probably
for and line four and what would that
print function to so that actually is a
little interesting I'm going to hold up
and take a look at that that was
interesting is so line three
I gave it a pointer to foo or the putter
foo which is a pointer to foo but there
actually wasn't any function I wrote
that takes in a a pointer to food for
funk to funky takes in a pointer to
constant food and this is the point at
which the compiler is what it does is it
searches through its list of valid
functions that it can call and it
doesn't see anything that matches that
type so then it starts manipulating the
type of the object and adding things
that it can do it starts going through
the list of implicit conversions that's
allowable and adding cost is one of
those things that's allowable so now it
can resolve that call and for or gets
resolved cuz there's no modification to
you it just calls that function directly
when it looks work so now what happens
for line five does that is that a valid
expression and what would that print of
three and what's gonna print three but
which one phone three star and line six
rally expression and
the console version of it yes that makes
perfect sense right awesome guess you're
doing good you're okay moving on so we
dudes were a bunch of objects I've
marked Const it is possible in C++ to
mark functions as comments member
functions maybe mark costs sorry I says
yeah I'll state that again member
functions may be marked cost regular
functions cannot be mark constant so
with that I have if you take a look at
the syntax for function member function
has returned value a function name any
number of arguments and at the end they
say CV qualifiers and I didn't put in
but there's also ref qualifiers but
that's for another topic talk so let's
first examine what happens when you
generate functions and yes this was from
previous slides that it presented but I
just worked so hard on these animations
I want to do them twice so what happens
when we when the compiler goes ahead and
generates code for you this is sort of
is not exactly what happens but mostly
accurate so what happens is first a
pointer to this object is added as an
implicit first argument then what
happens is cv qualifiers that existed on
the end or move to refer to that object
so you'll see that they get moved so now
my this argument is a this is a constant
pointer to constant Foos
then the next what happens is at the any
place where I would call my member
function it gets modified to take in
that foo that F pointer as a first
argument and then all member variables
within the member function are prefixed
to reference through the this pointer
and then finally what happens is the
compiler translates the function into a
name mangled free function through a
process called naming link which is it
should be a great topic for a lightning
talk so this is where we had started and
this is where we end up so what we see
is Const through that object
so marking a member function is cost
means that this pointer is a pointer to
t cost so that's good so what that means
is the compiler will only allow
expressions that will not modify the
object and why is that a good thing I
say it's a good thing and the style
guide says it's a good thing why is this
a good thing
one of the things that is very important
about Kant's is it it helps you it helps
keep your it helps you protect your
invariants and invariants are those
conditions that must be true before the
function is called a member function
called in after the member function is
called there there's the characteristics
of your object that must be kept
consistence and they are often reflected
in the state of your objects so if you
modify your member functions
unexpectedly like if you accidentally
modified something you may be mucking
about with your object invariance so
conce helps you write code that helps
you maintain your invariance so like
let's let me show you a quick example if
I wrote a bad resource handler here
don't don't write a resource handler if
you do write a resource handler don't
call it bad resource handler but so this
is a bad resource handler I'm gonna take
in a resource pointer or whatever it
would be as my AR and I'm gonna clean it
up when my object gets destructed and I
have a function that does something and
let's just say over the you know course
of time it'll in that this code is there
somebody modifies your code
maybe you modify your code and you
accidentally modify your resource the
pointer to the resource you could either
have an uninitialized it you can move it
to somewhere else you assigned it a
random value and what happens is your
invariant got violated one of the
invariants of this object presumably is
that it the my resource pointer is
pointing to a resource that must be
released at the end it must make me
maintain valuable valid so you've broken
your invariant here now if I had labeled
it Const my error would have been easily
caught this code would not compile
because I'm modifying something
straightforward
of course good but then constants
infectious so then if you did this let's
say I
do something and did do something said
do more work and do more work itself
wasn't labeled Const right then this
doesn't compile it do I really need to
add cons to everything yes you really
need to add cons to everything
it is infectious in your code this is
sort of a good infection this is the
sort of this is what you want to have
happen I mean imagine the bugs you'll
find as you go through and label all of
your member variables or member
functions kant's that need to be acting
Const or you may find that actually
you're calling something and you're
doing something decidedly non-cost in
your function so what if I write this
code I have to member functions one of
them is Const one of them is non Const
and non concierge in says I'm calling
non Const and the concert instead I'm
calling constant what will this program
print we take a look here I have a foo I
have a constant food and function one
function two and what prints is first
calls the non-cost version and then
calls the conservation pretty
straightforward so it sees that a is a
constant function it sees that a if it
did the manipulation if you think about
what the compiler does is it's going to
move the a into being the first implicit
argument then the type of the argument
is taking is a pointer to foo
so that would actually be that first
function and then with B it's been
putting it in place and it's actually a
pointer to constant foo and that would
be what the compiler generates for that
second function what about now I've
removed that one will this code compile
yeah this code compiles and I get two
calls to this and this is the same sort
of thing that we've seen before with
when I was passing in pointers so that
function I'm passing in that a pointer
is a it is a pointer to foo for that
value of a but the compiler is free to
add cost to it so it cost looks it looks
through first of the available functions
it can call sees that it needs to add
console add constant
call that function what about this
version now I've removed my console
version of the function does this code
compile no code does not compile so a
pointer can be promoted to Const in this
way so same sort of thing I can add
Const when I was going the other way
around but with this way since B has
been light May is a oh whoops I copied
and pasted it incorrectly that shouldn't
be through this that should be food
Const but B is a constant or to constant
booze and you cannot remove that
constant all right so more valid
expressions this is so much fun okay so
we'll do these quickly line one is this
valley Oh so before I go on I have a
member function I've made a lot mark my
member function as console I am going to
manipulate data
I've been manipulative area Buhl's is
lying one valid no it is line two valid
nope line three valid no is lying for
valid I can't do anything to this thing
is lying for valid yes is line five
valid no and this line six valid yes
let's take a look at these two
statements these ones were the ones
these are a little more interesting a is
probably obvious but that line six is
maybe not as obvious
I thought cons meant I cannot modify the
object this is a I'm gonna take a little
detour into some concepts there is the
concept of bitwise Const and logical
cost so bitwise Const states that this
is how member function that has this
wise cons can't modify any of the bits
inside the object this is the compilers
view of the console it has this object
its views that object as a serie bunch
of bits
and the compiler will make sure that it
cannot modify the bits in that function
logical Const is it means from the
clients point of view that the function
hasn't changed anything also another way
of saying it's it's observably Const
this is sort of is not really obtained
geing the state of my program through my
cost function so if we look back at this
one what happens is a I am actually I
have my object my bits are here and I'm
with a I'm not actually modifying any of
the bits in my foo function object I'm
pointing through and modifying state of
the program through my a pointer and so
that's probably obvious cuz that's a
pointer but it's problem it's a little
harder to see when I'm doing it through
a reference because a reference is
effectively a pointer so we does
actually modifying state in my program
through that reference data so this is
something to be aware of this is this is
something that your compiler won't help
you catch because it's sort of unusual
or not unusual is not the right way to
do it's non-obvious to the compiler what
your intent is you should strive to make
your member functions observably Const
when you're writing them you should
strive to make sure that this doesn't
happen okay what do you need to do when
you need to do something non Const and
it cost remember function so I have my
bag of bits I'm not allowed to modify
any other state modify the invariants of
my object but there is some times where
you really do want to modify the members
of your objects and reasons for that
could be for caching and for logging
these are prime examples and they're
actually valid use cases these could be
things that you do want to do with your
objects so for example let's say I have
a data holder that holds on to a blob of
data or a point rich blob of data or
something and its job is to add more
data to my object and also it calculates
a checksum on it so I can call to get
checksum and it'll go and calculate
checksum on this object so I'm also
interested in profiling my code I want
to say well let me just find out how
many times get checks on this call
because maybe that's important for me to
audit my code to see how many times
check something called so I write do
some work with a
holder and I'm trying to get the
checksum and error this does not compile
so that cons functions getting in the
way how what can I do about it and this
is when you would reach for mutable this
is where mutable it's the oops of the
cost world it's the I really did want to
modify my data member it's kind of a c++
wiggle room so mutable tells the
compiler that the value will change even
if the function is constant so I can go
ahead and do it okay so now I'm good
okay or or mi this code good code would
this pass your code review or this code
is potentially toxic so let's take
another look at that and there is a
subtle bug in here does anybody see it
there's a race condition and because of
a race condition there's a race
condition because of threads so what is
a data race a data race is the wordy
definition the execution of a program
contains a data race if it contains two
conflicting actions on different threads
at least one of which is not atomic and
neither happens before the other any
such data race results an undefined
behavior the dreaded undefined behavior
so to say that in a more succinct way if
two or more threads access the same
memory location without synchronization
and at least one is a writer you will
have undefined behavior and so const
means data race-free so conce member
variable constant member functions must
be data race treat I mean the the reason
that they must be data race free is it
sort of a loosely open to interpretation
but I believe what the idea is that the
standard does say that it is free to
call any of your member functions at any
time if they're using objects
and it actually says it's free to call
any of the non any of the cost member
functions of your object so on any
thread so that means that you need to
make sure that your consummate functions
are data rays free so let's go through
and examine what I where the race
condition is because it may not be
completely obvious so what I have here
is I'm going to have my data object
holder I have a global data object Oh
older and I'm gonna call get checksum on
two different threads at the same time
and the green bar here represents my
threads where they're executing on which
line they're executing so at one point
in time let's say gee data has never
been called and so it's set to be zero
and thread one is on my right and left
and thread two is on my right so let's
walk through what happens so thread 1
goes first and D it goes and it reads in
the local variable into a register or it
reads in num times into a local register
then thread then it gets context which
doubt and thread won't run thread two
runs and it reads in the value of zero
into its local register then the threads
thread two runs modifying its local
register value and then thread 1 gets a
chance to run and it modifies this
register and then they both go and write
out their values and we see here when
two threads are running num x was only
incremented by one even though it was
called twice this is not good
the fix is easy as it said add
synchronization primitives and you'll to
around your data hazards so this is when
for example I could add a mutex here I'm
gonna lock my function before I call it
and then I will be data race free and
we'll see what happens when I do that
starting off here thread 1 runs it grabs
the lock thread two runs and it tries to
grab the lock and it can't grab that
lock so then three gets to run finishes
to completion number times called is
incremented to one and then thread two
gets a chance to run any
finishes and now none times us too so
now numb times has been called great
this is good
anyone see an issue with using a mutex
hmm oh thank you did I get clear okay
okay
yes it's mutable so mutexes are great
synchronization mechanism but they're a
little heavy there a little weighty
it's like using a sledgehammer to to win
yet when a little tiny hammer is really
what you want to do but this is the
perfect place for Atomics and if you
have the cpp reference comm which I that
should be your go-to place for reading
about information about the C++ standard
library it says here that the C++
objects of atomic types are the only C++
objects that are free from data races
that is if one thread writes to an
atomic object while the other third
reads from it and it sounds like exactly
what we're doing the behavior is
well-defined great cool I am going to
reach for a standard atomic here and
what would happen in this case so here
what happens is a thread one goes first
and atomic increments are well-defined
on different threads so even if thread
two comes across and runs and hits that
same way at the same time your processor
synchronization mechanisms or other
things will guarantee that atomic
increments are well defined across
different threads and then they both
return and number times called is equal
to great so one thing to note though is
about that is new Texas and Atomics are
a good synchronization primitive but
they are not copyable so you might think
that you know great new I want to do
this change I'm going to add an atomic
int or I'm gonna add a mutex and
suddenly your code may break in other
places because now you have made your
objects not copyable so be aware if you
start using these primitives that you
have to consider perhaps making your own
copy constructors which it's probably
not a good idea in fact actually you may
want to bury those synchronization
primitives into smaller objects that
have
to find copy constructors that you can
then use so what if I want to accelerate
my code if you will like what if
calculate checksum was very expensive
how could we speed things up so before I
said that there were logging and is a
great way of using mutable and another
valid use case would be caching well
this would be a great idea let's go
ahead and add caching so the idea being
is instead of calling get checksum I'm
going to first check to see if I have
saved off a previous calculation I'm
then going to use that previous
calculation if I have otherwise what I'm
going to do is I'm going to calculate it
set the cache to be valid and then
anytime I invalidate my object I add
more stuff and win it and validate my
cache I'm going to mark it as false and
so this is a great way this is a common
pattern people used to add values in
there except that Const now is getting
in the way same way with my incrementing
constants getting in the way here again
so so mutable I reach from uniball and
there I go I add mutable to my things
and now the code compiles are we good
does this code have any problems again
potentially toxic code I forgot Atomics
err I'll use Atomics oh and right
because I have Atomics I'm going to add
a copy constructor and probably I should
be adding a lot more things if I'm
writing a copy constructor I suddenly
have to invoke rule of four or rule of
six or rule o 7 or I forget which how
many how many I'm supposed to do but for
the examples of this let's assume I've
done everything right but I had a copy
constructor so now am I good to go
it's still dangerous code this code
still has a race condition okay so if
you look at your code here and let's say
that I had one thread where I was
getting the checksum in another thread
where I'm adding more data this is a
race condition this is a blatant race
condition here but that's fine I mean
I'll say that's fine because this is
actually an expected data race condition
I have two threads one of which is a
reader and one of which is a writer to
the same object so that's not a data
race condition problem in my code that's
a data race condition because the client
is using it wrong there they're holding
it wrong if you will they're not
supposed to do this and the reason that
I can say I say that that's okay that
they've done a problem is because I have
clearly marked my kant's functions as
cons they are read-only functions and if
a client is using a read-only function
at the same time they're using a write
function they're going to have some
problems so that's not what I'm talking
about
it could be different clients sir right
so so but it's sort of but it would go
with anything that someone would do on
sorry the question was you know they
don't have to be the same client
this is true but if you have any part in
your code where you have a reader to
value and a writer to your value you're
gonna have a problem and that is sort of
that's a higher-level problem I'm saying
that's a problem to the clients of your
code it could be the same code that's
doing it but actually don't know how the
same thread would call it twice it can't
but if you had two threads and they were
at different parts of your code and like
one part of your system grabbed a
library and another part of your system
grabbed your library object and then
they both modified the same thing then
you probably have a problem in your
design but right right yeah if yeah yeah
exactly like if I said that this is
valid I could have written my code to be
locked free or I should say I could
write my code to be thread safe and when
I say and I should clearly mark that in
my documentation saying yeah these
feeling these functions are valid to be
called together but if you had a Const
member functions if you have three or
four
member functions and they aren't and
they're all cost and it is not thread
safe that's unexpected to the client
that's that's the point I'm trying to
make so let me illustrate the data race
condition I said that existed in that
code why I have some toxic code there so
I'm gonna call get checks on my one I'm
gonna call it gets like checks on the
other and let me expand what that
actually would do so we see that thread
one on the left is going to you know it
first it checks to see is it cashed if
it's not set it to be true calculated
the checksum and then return it and
conveniently I put up there so you can
see what it looks the data members
inside of G data on the upper right hand
side so first so both threads enter
thread one proceeds so it checks to see
the cash and it says oh no this data
holder of the cash is not set so then it
proceeds and it marks the cash is true
now unfortunately at that moment it gets
swapped out and now thread two precedes
and it checks to see is the cash valid
yes the cash is valid great I'm gonna
grab that value and I'll return no
thread two returns to M cash checks sum
before thread one has a chance to
calculate the answer so it returned the
wrong value yeah so the issue seems to
be that cashed and cash checks some are
in the wrong order so what I mean by
that is if we look at the get check sum
function I first check to see if it's
cashed if it's not I will set it to be
cashed and then I calculate the value
mmm so now there I fixed it are we good
Oh still dangerous ah
well okay let's walk through that again
what do I mean by um dangerous let's
walk through so both threads enter M
cache is false the first of all it
calculates the checksum then thread two
proceeds and it calculates the checksum
okay both call get checksum all right
then returns it sets the cache to be
true and the other one sets the cache
may be true in the return so the Atomics
arts are synchronized so there's no
issues on both threads writing those
values they both eventually return the
right answer I'm assuming that calculate
checksum is also thread safe work with
me guys let's just make that assumption
so what's the big deal man I got the
right answer I mean it did do more work
than it needed to do I mean what if it
was two threads instead of author if it
was a hundred threads and they all did
this exactly at the same moment then
they would all end up calculating that
that might be really expensive or what
if calculate the calculate was a super
expensive what if it took like five
minutes each time and I have two threads
blocked essentially for five minutes I
would say that's functionally correct
but that's not the problem I have
there's another pernicious bug lurking
in here can you see it
all right hmm no I think more data is
fine like well fine is not quite fine
but I would argue that that is a race
condition from the client sort of if
it's sort of an external thing is
modifying it and so the problem I'm
saying is if if I were to access this
object only through its Const function I
still have a problem
all right so this is the one I this is
case one I worked through and we went
through that and it's all it's fine
it should take it may take a lot of time
it may do extra work but it's still ok
what about this case and this is the one
you might not think about this is the
one you probably don't ever think about
so I have thread one which is just gonna
call get chunks um and then thread two
is making a copy of my object alright
let's go ahead here and walk through
what happens so assuming the checksum
has not been set
thread two now proceeds so it actually
hasn't been set so what's data members
are unknown undefined so then what
happens first of all it goes ahead and
reads in the cache checksum which has
been 0 and it's the default now thread 1
proceeds it does all the work it
calculates the checksum and then it
finishes in sets the cache to be true
thread 2 now gets a chance to run it
reads in and says oh my cache is valid
but the calculate M cache checksum is
incorrect this is a horrible race
condition so the order of
initializations of the copy constructor
caused this subtle issue this so I would
point out this this is not actually a
data race this is more of a race
condition this is this happens when you
have any two data locations that must be
synchronized I don't have a data race
here I'm not modifying the same data
location by two threads I'm actually
modifying different data locations that
must be synchronized so there I fixed it
did I I changed the order of M cached
and M cache checksum and then I changed
the order of initialization in my copy
constructor am I good oh it's ok it's
but it's very brittle in fact actually
I'm not even 100% sure this is correct
but it's this is a scary code I mean how
well will this be
how do you even test this type of code
switching gears for a little bit talked
a lot about that let's go back to cons
and another question does Kant's
generate faster code we just had a great
presentation by about c++ and efficiency
and we loved efficiency but does using
cost generate faster code generally no I
mean when it comes to optimizations
Const is still principle useful as a
tool to help us as the class designers
better implement handcrafted
optimization then for the compiler to do
something special with it and let's look
at a little example let's go through
this and let's say I have a log it
function a modify it function and I have
foo and foo is gonna take in a reference
to Kant's day and a reference to be I
really do have a problem with my
variable names a and B should probably
fix that but first of all I'm gonna log
my value then I'm gonna modify a
completely different value and then I'm
gonna log it again I'm gonna log a twice
so then we take a look at the assembler
let's take a look at what the assembly
instructions that this produces and so
what we see here is first of all it
loads a and I compiled this with - oh
and it loads B then it calls log it then
it loads in sorry that should say loads
a sorry so read that as loads egg then
it calls in to modify it and then it has
to load a again into to loads and by the
way if you ever want to take a look and
you're you've got your laptop or your
phone and you really want to take a look
at the assembly there's a great website
I use all the time is a God Bolt org
there's a number of other sites to look
for assembly but if you really are in a
pinch and you have only your browser on
you this is how you can take a look at
some assembly code anyway going back I
see that there were two loads - well it
should say a but it says B so two loads
I must not have set my compiler values
high enough let me crank up the
optimizations to level three and that
should get rid of that low that double
loads it you only need to load it once
know the compiler still generates two
independent memory loads why is that huh
aliasing the compiler can't make any
assumptions about what happens around
the function calls like it doesn't know
what's happened outside of it only
really sees that these are you know we
see them and probably think of them as
two different values but the compilers
like now they could be the same value
for instance someone could have written
that code on the right there so your
compiler has to be very conservative
about those things so even though you
think that using Kant's may help you
with optimizations not really
principally a tool for optimization it's
a tool for writing good code so to
review Const it helps you find your bugs
a compiler time it makes it easier for
you to reason about your code it helps
you prefer preserve your class
invariants I would also I when I
mentioned I was doing this talk people
are likes please please PLEASE have
people start using this format for
writing their values and I agree I think
actually I'm it's a little difficult I
meant I had to go through my slides
several time to get it so I'm adopting
this practice but I would recommend
start writing your T Const and then your
variable name cons member function
should be observably Const and
thread-safe
and also constant necessarily make
faster code but it makes more correct
code and as we all know it is far easier
to make correct code fast than fast code
correct and questions so my friend here
will go around as you raise your hands
and he'll give you the microphone any
questions
just a question about the Const of the
the getters the read-only and you say
that they have to be data race free
obviously threads are new in C++ 11
we're just getting to them so my
question is if your objects only being
accessed you know it's only going to be
accessed by one threaded because the way
you structured your program do you
wouldn't have to worry about it because
the compiler is not going to create a
thread of another thread for you this is
probably true so I guess I'll say it as
you're saying if I know that I'm only
gonna be executing on one thread do I
have to worry about thread safety I
would say code tends to live in places
you don't expect it to your code that
you've written may end up somewhere else
and granted you might not be writing in
a multi-threaded environment today but
you might tomorrow and maybe it's good
to have practice out writing the code
writing thread safe code is very hard
and data race free code is can be hard
but I think for the most part this only
starts becoming a problem when you start
reaching for immutable and when you
start reaching for mutable you're doing
something unusual in your Constans for I
would say I think 99% of the time I've
never used the word mutable for it
constant I can write pretty good
observer code because generally really
I'm just for my accessors that are comp
they're really just gonna get something
they're just going to get a value there
aren't really modifying things and then
on those small cases the time when you
do reach for mutable that is now because
you've reached for a mutable you should
really think about what am I trying to
do here where will this code live will
it be thread safe how do I make it
thread safe perhaps actually it's better
to create so my cache example that would
actually that could be great as a cache
object whose job is to synchronize
itself and is you know it's got lots of
scrutiny and people looking at it
so I guess my answer is for you is be
aware that your code today may be one in
a single thread but tomorrow it may not
be so you should consider thread safety
I like using the pointer to
implementation pattern once in a while
but it doesn't really respect constants
because of the reasons you mentioned
yeah
any ideas so I've seen people implement
sort of a entire interface through that
it's actually I what they do is they
they end up repeating themselves
completely within there and but it's
hard because you're right because you're
you end up going through this pointer
and the compiler sees I haven't modified
anything in here so it's really up to
you and I think actually this might be a
reason to avoid trying to use the people
platter but it's it is a useful thing
for ABI compatibility so I don't have a
good answer for you I I'm curious if
anybody else does you know who uses
concert people that's a great question
the questions I'd say for the pimple
pattern one thing you can do is you
could rather than accessing the pointer
directly add a couple member functions
that you always use private member
functions that will forward the pointer
back to you and then your console and
can forward you the constant a star or
whatever you know it's similar to what
vector does you know vector gives you
constant raters when you call Const even
though technically kind of could have
given you of just a plain old iterator
any other questions well all right thank
you all</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>