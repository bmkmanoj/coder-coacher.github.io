<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Michael Caisse “Implementing a Modern C++ MQTT Client for Embedded Devices&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Michael Caisse “Implementing a Modern C++ MQTT Client for Embedded Devices&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Michael Caisse “Implementing a Modern C++ MQTT Client for Embedded Devices&quot;</b></h2><h5 class="post__date">2016-10-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/t3O7pio2B20" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right let's begin my name is michael
case I work with Kira consulting we're a
small consulting group kind of scattered
about six different time zones ten of us
a large number of us are either boost
authors or maintainer x' we like to to
write code all throughout the stack so
on any particular day we're writing code
inside of an MCU no operating system
maybe it's got 4k of RAM and after lunch
we're dealing with issues in site of one
of the server farms that has you know
eight or nine hundred cores and dealing
with distributed systems that we have
with these internet devices where
there's a hundred thousand of them
scattered about through the US and so
we're we like to just solve problems and
deal with things all over the place and
so some of you are recognized and you've
heard me speak about other things like
spirit and meta programming and and
things that have probably in your mind
at least nothing to do with embedded
systems but embedded systems are kind of
near and dear to me I happen to be a EE
I don't try to say that too loud at this
conference but you know I we call honest
work the type of work that you do and
you can explain to your mom and she
understands what you just said that's
honest work right so you get done try
and explain this amazing cool algorithm
you work done she's like I don't know
what you're talking about all right so
what is mqtt so this this discussion is
about embedded MQTT on c++ fourteen
library if we're gonna trace try to tear
that apart what what all that means at
the moment the reality is this the stock
is really not so much about the MQTT
client library as it is about an
approach i took to write a client
library and c++ 14 on a small embedded
device and that's what i'm hoping you're
here to hear about and and take
something away from so
mqtt used to mean message queue
telemetry transport nobody actually uses
that anymore they just call it MQTT
because it's kind of like old days when
there were things like trump lines and
stuff right it is an iso standard
it basically is a publish/subscribe type
model and it's considered lightweight it
does require a reliable connection so
that's one of the things that it depends
upon it depends upon whatever this
connection is to be reliable let's take
a look at kind of the basic idea here we
have a broker the broker is the
centralized point in which the different
clients will connect in this diagram we
have these five different clients and
the clients connected to the broker they
subscribe or they publish topics and as
they do so then those topics get routed
to the published topics get routed to
the subscribers that wanted to know
about it up here we have this toaster
and toaster is subscribing to town plant
toaster hash and the hash is the pound
sign is a wild card and it basically
means any other topics that exists so we
have topic separators the topic
separators are the forward slash they
allow us kind of a concept of like
padding and by using the hash mark it
says replace in up to n different
possibility so it'll match anything that
starts with town plant toaster all right
and then over here we've got the the new
plant power and it's subscribing to town
plant and then the plus means a single
replacement so that's a wild card for
just a single a single thing in that
spot power control so that's what it
would like and over down here we have a
switch switch number one and switch
number one is going to publish and it's
publishing to town plant toaster power
underscore control and it's publishing a
data that is on so this matches of
course what the toaster wanted because
it matches that first part so the
toaster turns on but unfortunately it
also matches the power plant so the
nuclear power plant comes on sometimes
the toaster probably was not expected it
might be fun I don't know this is the
basic idea though of MQTT just passing
messages around there so there's a lot
more
inside the broker John has actually a
talk later this week he's going to be
talking about building a broker so if
you're interested in that type of thing
go to John's talk and a lot of the the
smart of MQTT is inside of the broker
and what it's supposed to do when
clients reconnect to the safe state or
what not basic messages and mqtt are
very simple there is a connect
disconnect subscribe unsubscribe publish
and pink that's it there's nothing else
you can really do with these things so
very limited set of messaging and this
will provide then all the capabilities
we need the publish publish is sent from
the subscriber to the broker publish is
actually what's received also to the
client when a topic comes in they use
the same message for both sending and
receiving there are three levels of
quality of service QoS zero is at most
once delivery so I'm just gonna deliver
an hour send a message and I don't
really care to know if it's been
acknowledged or not at least once
delivery I'm going to keep on some
periodic timer sending the message until
I receive an act so there might be
another in flight and the the other end
might receive more than one and then
there is exactly once and QoS level
three there is a very complicated
handshake sequence that will determine
whether or not another has been received
or if one's in flight or whatnot and so
you only end up with one MQTT has been
used in a lot of different things Amazon
uses it in their Internet of Things lots
of people just you know that's yet the
next buzzword Internet of Things right
and so you'll see
mqtt either disguised as something or
extended rabbitmq extends it and uses it
as something else and it kind of it's
been around and it exists in a variety
different applications Facebook
Messenger is another one yeah MQTT so
it's not um not just this weird thing
that I dreamt up it's real
all right so what's embedded so we kind
of got an idea what mqtt is but what is
this embedded thing so this is always
fun what's embedded this is the
interactive part of class whoo now your
traditional computer interface okay yeah
that pretty much just covered everything
you guys are like no fun all right
you're any examples of what might fall
in that classification nobody ok small
microcontrollers so small
microcontrollers might have two or four
K of RAM we actually work on a product
line for a medical company the the
product line actually has four K of RAM
and it deals with them wireless
communications with a bunch of different
things army yeah
toasters toasters okay cell phones our
cell phones embedded why yeah see he
enters this okay at some level they're
an embedded device what's weird is if we
had this discussion ten years ago it
would be really easy or 15 years ago it
would be super easy background you know
it's like we knew what embedded devices
were and as time has moved on embedded
devices and the concept of an embedded
device has kind of morphed around a
little bit right so something can have a
gig of ram on it and running a full
operating system and you know be much
more powerful than any machine I ever
saw when I was in college and be in my
pocket and I'll call it an embedded
device and so embedded has a fairly
different connotation when we think
about the physical device but they have
a lot of the same qualities that we're
always looking for we're looking for
power constraints we're looking for
portability typically the the device
often has some type of time requirements
associated with it not always but I
think the term
has become fuzzed so while well maybe
you want to argue after the session
about what embedded means for now we're
just going to assume embedded is
whatever you want it to be okay okay but
this part everybody agrees on that you
know the world in general you're going
to put C++ on an embedded device what
are you thinking that is nuts that's
completely crazy people don't do that
people who put C++ on embedded devices
and just to kind of point it out I was
preparing to talk about this this in May
at busca nor CPP now and the day that I
decided that I was gonna speak on this
subject this came across the Twitter
feed and this is like a perfect diagram
of why people don't want to put mentally
they don't want to put C++ on embedded
devices now this happens to be this
standard librarian vector but there's a
belief a feeling that it's just gonna be
bloated it's gonna be large it's not
gonna fit performance is gonna be poor
and so I decided you know I'm gonna ask
everybody in the world that I know as
far as I can tell everybody who is in
the world must be on Twitter right so
how that works I don't know I asked what
are the top four reasons to not put it
on and use it on ended embedded targets
and we get things like more complicated
regulatory approvals so our company does
embedded work on things that are on FAA
certified devices and FDA certified
devices so I don't know that's more
complicated but smaller developer pool
that's definitely a real problem
bloated binaries we're gonna disprove I
hope and this is what what this person's
heard right how about this one
programmers going while creating too
many levels of abstraction I'm the
keynote yesterday that's the whole idea
it is
we can be very close to the hardware and
manipulate the hardware and the bits as
needed yet we can have zero cost
abstractions and I hope by the end of
the session you'll see that yeah we
truly can have some zero cost
abstractions they'll help us out all
right so general public devices don't do
it we we should not use C++ on embedded
but we're not going to listen to them
we're rebels okay so why do we need yet
one more mqtt library there are several
MQTT libraries out there under a variety
of different open source packages or you
can get commercial versions and like why
do we need yet one more so in in
December I was working on a project that
needed an mqtt client and thought I was
going to be using actually an open
source and qtt client and after taking a
look at the particular one we thought
we're going to use and then a few others
they all had the same problem which
here's a message sequence charge that
kind of describes it from the user point
of view or the program that's using the
client the MQTT client it's going to say
something like subscribe well subscribe
is something that needs to be sent off
to the broker the subscription it needs
to get a sub act back and then it will
return the QoS level that was provided
for the subscription this is a blocking
call it's like I call subscribe and the
client doesn't return until I get my QoS
level back this is like I don't know
some server farm somewhere else my cell
phone might not even be connected I'm
gonna timeout it's just this is not how
I want to deal with embedded when I'm
dealing with embedded type work I want
to deal inside of an environment that is
event-driven almost always so I want
something that's like this I'm going to
send to subscribe and it's gonna get to
the broker but I'm going to receive some
type of an event back that's telling me
I got my subscription ACK meanwhile I
can perform cycles on something else
so that's one of the reasons that we
need a different Institute e-library
some that was event-driven that allowed
me to treat this thing asynchronously so
blocking is a problem dependency
injection event notification and execute
executor or executors so we'll see what
an executor is in a second to talk about
event notification when in mqtt when
something says that yep I received the
message I don't care if the client
received the message I want to care
about whether or not the application
received the message that's actually
really the 2's level I care about right
it's not that the communication layer
received it the app received it and so
that seemed to be lacking also all right
so how about these other two things well
if we think about this as being the
client it might be that I don't want to
use TCP for my connection I just need a
connection that provides bytes whatever
I can do to provide bytes back and forth
that qualifies as the connection for the
serial device it could be a Bluetooth
device it be all kinds of different
things as long as I can reliably be
sending communication back and forth and
so I want to be able to inject what the
communication mechanism is back and
forth to the client I also want to be
able to inject the executor how is it
that I'm going to think about the
asynchronous activities that are
occurring at the end of the day this
might just fall apart into some main
loop that's running right a main event
loop that's super common depend upon
what what device you're using you might
have this setup as you're receiving
timed events and so you've got actually
an event pool of some sort and timers
are going off waking the chip back up
you go and do a couple things you go
back to sleep so there are things that
are already going to provide me this
concept of an executor I'd rather go
ahead and inject that into the client
library when when I decide what that's
going to be there's a lot going on
with this poor little guy he's got to
users are going to want to subscribe the
client might be in the middle of a
publish to the broker the broker might
be in the middle of singing a pub act
back the client might have already
received actually a published coming in
and now it needs to transfer that over
to the user there might be some time out
from a connection that's going on there
are a lot of different events that this
needs to handle and some of them are
dependent for example establishing a
connection with the broker you have to
establish the physical connection with
the broker ensure that it's actually
working it's gonna be the the logical
connection and then you need to
communicate to the broker so there's
some negotiation that needs to go on and
if you had some subscribes that we're
all right excuse me subscribes yeah
though we're already queued up you need
to send those out and so you can imagine
this is like this do this and then do
this and then do this you might be
tempted to like take a future and have
continuations but anywhere along the
line something bad might happen and how
you're going to tear the continuation
apart cleanly it starts to get a little
hairy and what you're really doing is
you're writing a state machine using
continuations you probably shouldn't do
that I don't think you should do that I
think you should do state machines so
we're gonna use a hierarchical state
machine instead to deal with the state
activities we just want to the state
machine only to deal with states and
then to delegate back up the actual
functional activities to some normal
function we can we can think about so if
we kind of blur our eyes and pretend our
client kind of has this not connected to
it's connected to the broker eventually
I started connect a broker then it
finally is connected then it's shutting
down and then it's not connected again
so this might be the high-level concepts
and where connect broker then is another
machine and it's negotiating with a
broker it's waiting for the connection
act if it doesn't get it then it times
out it does a retry count whether or not
it can do it again and so forth so we
can think about this each of these
states becoming other additional states
hierarchical states in this process
I like hierarchical state machines
myself because it lets me handle error
handling at different levels of the
hierarchy it's very clean I know whether
or not I've met all the cases I don't
have regulatory problems because I can
prove that I'm not going to deal I've
dealt with all the state transitions
that I needed to it's obvious what the
state is in my program so we're gonna do
that
so in May when this occurred I went over
to Kira Lisa's some some space from a
company that we partnered with for a
long time about eight years they have
picked placed machines and and seen see
machines and so there there's kind of
the R&amp;amp;D side that takes care of all the
physical bits and pieces and sink labs
and I went on over and I said hey what
do you have that that I might borrow
that maybe has bluetooth on it and they
had this thing this had a nordic chip on
it and they had just brought it up
they'd put a little sample application
on it and I said can I can I steal one
of those and one was coming off the pick
and place line it had not been tested
yet they said sure
you can take this one so I took it and I
thought this will be perfect they gave
me the code I've got this little device
this is the Nordic device we're not
gonna worry about that one that's
something else that they use it for I
didn't care about it I just really
wanted the Bluetooth off of it this you
know these are the specs not so much
embedded for some people in their world
but it worked for what I wanted because
I just wanted some communication
mechanism that wasn't TCP so this is
what the original test app did that that
we grabbed from them at the same time
they had an application there's this
proprietary communication layer that
they had that was speaking ele to a
phone and it was displaying the
accelerometer values as well as the
temperature on the device okay didn't
didn't do much but my job now was to
figure out can I take that and just drop
in this C++ mqtt library wedge that in
so that I have this I've got the mqtt
client the application which was C now
needs to compile under a C++ compiler
and can I just kind of drop in this with
about being too intrusive what the
original thing look like for the bit in
the middle we're just going to write a
proxy so the Bluetooth is being proxied
over to the TCP to an MQTT broker and
back and forth though it's not really
doing anything so for being this proxy
between TCP and whatnot all right got
some help from Augustine and your rune
they usually get roped into helping me
out a little bit somewhere along the
line we just call it means night
all right so step one step one is to get
the code just to compile with the C++
compiler right and how many of you have
done that before you've got some C code
and you're trying to get - did you give
up or did you like did you stick with it
all right you stuck with it good it can
it could be hard right but along the way
hopefully you end up making a lot a lot
of improvements to clean that code up
and here's an example of a piece of code
that was in there though that the
compiler forced us to clean up we didn't
have a choice it had to get cleaned and
the reason we've got this OLED right
it's going to take a pointer to some
number of by our pointer two bytes and a
count of how many bytes that will be the
part of this array of bytes and this is
the calling lines we can't do this in
C++ this is a temporary value that's
being passed by non cons there are lots
of things I actually problems here that
the coop I was just going to complain
about not only that it's totally unsafe
right we are taking the number of bytes
that we're sending and sticking that as
a parameter so they're just gonna get
out of sync so we look at this right
away we're like okay well in C++ 14 I
have a perfectly good way to write this
already so let's do that my perfectly
good ways I'm just gonna actually use
initializer lists because initializer
list are constants freshens I can create
one of them I knit knows its size and
I've got
a little wrapper here it's gonna take an
initializer list it's going to call the
original version of the right passing it
the begin which gets a pointer to the
type and that's the size all right so
this now from a user point of view the
code has become cleaner safer it's got
this
I made it concierge we're trying to be
friendly with our constant this but it's
got this ugly little cons cast and at
some point and when you're interfacing
to see libraries you're gonna end up
with that you don't you don't get upset
about it you just write it and move on
okay should be at the very bottom layers
now what do you think the overhead is of
doing this
what should the overhead be of doing
this zero right so zero overhead to do
this right so we were able to take and
just use initializer list have no
overhead at all so that's good we're
starting to get what we want now it
finally got it to compile and my C++ 14
version was just slightly larger than
the c99 version not too surprising both
of them are large this is the entire
application that they had provided so
it's been a little bit of time trying to
figure out what what can we do just with
some switches so the first thing is well
I'm never gonna use run type type
information and so let's just turn that
off and that had no effect but actually
I'm not going to use exceptions either
so I'm going to turn those off too and
when you hear people complain like oh
you embedded guys complaining about
exceptions all the time alright this is
me with my embedded head on by the way
as opposed to me with the other hat that
I have to wear most of the time so
that's 5k let's pretend perspective I
had 32 K on this device that's 1/6 of my
memory and I haven't done anything I
haven't called an exception there are no
exceptions in this code yet this is just
exception support that's a really hefty
price to pay for something that I don't
really probably want to use what what
happens when you have an exception your
system and things go bad I mean if this
is a medical device what are you going
to do right I mean you don't know your
state that's why you threw an exception
at that point you're not trying to
recover you're trying to put yourself
of state which is as safe as possible so
that hardware interlocks can kick in
watchdogs can reboot you something else
is going to happen right and and there
are a lot of different ways to do that
what we do inside of Kiera is we
actually use the boost exception throw
and in the process of doing that we
actually assign a global handler so when
exceptions are turned off we just make
the same call all the time as worth as
if we're throwing an exception
so when exceptions are turned off the
handle ER then receives then this call
and then it says oh there was an
exception in the system and we just just
handle it so there's still what appears
to be a very clean mechanism but there's
no exception so I got my 5k back I bet I
can figure out a better place to use
that than then acceptance of the moment
the other thing I noticed right away was
it was being compiled in oh three I
actually don't care about speed I care
about size size is a big deal to me so
right away just turned on size
optimization and now the C++ result for
the text is smaller than the c99 that is
not actually surprising it's what I
would expect and I'm glad it happened
because it makes the slide better so you
know the optimizer in C++ 14 is just
superior so we're gonna get better size
optimization all right so let's move on
now what happens with an empty main
mains with nothing Adam and I am on an
even playing field so c99 and C++ 14
I've got it all configured and tuned
enough that I've got pretty much the
same starting basis so it'll be anything
bad that happens after this point is my
problem
all right now I decided all so I'm just
gonna go wild
why not I'm going to start using vectors
and strings now notice I'm using this
MQTT vector and MQTT string it's not
something that I would normally do on an
embedded vise this this device we're not
running any operating system so it
doesn't really have heap management not
really right it's got some pool manager
somewhere that's taking care of that and
you would probably not call you'd not
use a vector and you're not used strings
normally and I just decided let's see
what the overhead is because at the end
of the day the interface of a standard
string and the interface of a standard
vector is a perfectly reasonable
interface so I can write something else
that adapts to it the other thing that's
very common and embedded is you write
your own allocator and you just pass
that in so it would not be abnormal for
us to have in the past with c++ o3 to
write an allocator pass it into the
client impute et client and then that
would then be utilized everywhere inside
of the client that we needed a standard
container that's so ugly so let's not do
that anymore so there's here's the the
definitions of string and vector but if
I needed to make my own allocator thanks
to now C++ 11 and aliases type aliases I
can write something like this one we'll
look at the vector one I can write
something where now the vector the t's
here but I can actually specify that
it's my allocator and I couldn't do that
before
so 11 allows me to do something like
this this is our first time trying it on
a project it seemed to work out pretty
well actually so we've got some small
modifications we might make about how to
define the allocator so that we can just
define an allocator for everything but
this is it I think there's a neat trick
as opposed to in the past in in embedded
development used to try to push
alligators down so putting a string in
there what did it cost me it cost me
three hundred and sixty four bytes in
text not so bad so we're gonna keep
strings now what does a client look like
the client itself it's going to have a
type of the connection and the executor
it's going to have this publish handler
which will default to this handler type
we could have stored this when the
client receives a message Communion it
has to make a call back up into the
application saying hey I received a
topic I've got a message this could have
been maybe a polymorphic function object
but I'm I'm not that crazy yet so this
type def could still be a polymorphic
function object but for right now we're
just gonna make it a known type the
other things that we're gonna store in
here this client interface we're come
back to this in a moment this is gonna
be important and the identifier of what
the client is and here is the state
machine itself so the hydrilla state
machine alright and we've got some other
methods connect disconnect subscribes
unsubscribes set the publish handler
publish under some variety of things and
you can see some of them are templatized
now there there are two ways to think
about templates if you have the hat on
where you're writing meta programs or
some other type of weird thing with
templates you have the hat on and and
you think about templates as being
pattern matching that's the best way to
think about templates they're pattern
matching but when I'm writing an
embedded code I have to think about
templates especially if it's not compile
time only things I have to think about
templates says code generation that's
where the code bloat is going to come
from right so if I if I would have to
write code that would perform that same
functionality with the different
signatures in just in order to make the
thing work it was a requirement then
writing it as a template is good but if
I write it as a template just so because
I'm lazy and I end up with code bloat
that's bad we'll see an example here in
a moment of hopefully bad versus good
now what does a constructor look like so
the constructor is taking the different
types that are coming in it's going to
initialize these sub machines and it's
going to start the machine running
initializing the sub machines it's
passing the the client machine so this
is the top level state machine and it's
passing and the address to the client
interface and this is gonna be important
in a little bit imagine we've got these
hierarchical state machines we want the
state machines to deal only with state
transition information and then when
they have to perform some task we want
them to call into a function that's got
the functionality somewhere somehow we
have to tell them where that
functionality is there's not any way
cool way to do that otherwise this is
what the state machines are going to
look like it's basically a struct we're
going to use boost met a state machine
and we have to associate it with some
back-end and this is why I like MSM
because when I'm thinking about a state
machine I want to think about state
machines as state tables so here is the
start or this is the state that I'm in
this is the event that's going to cause
the transition this is the state that
I'm going to end up in this is the
action that might be performed on the
transition as it occurs and then are
there any guards each of these things in
the table are a type so this is
basically a list of type lists and it's
all compiled time magic MSM is going to
take care of that and it's going to
produce at compile time it'll take it
some time to do this but it will produce
a very very efficient state machine now
it's going to produce a very efficient
state machine from run time speed but
unfortunately it had more code bloke
than I thought it should and Christophe
and I have been talking about how we can
use 14 constructs to take care of some
of that I don't know if we'll get to it
very soon but a lot of these things
could be fixed now with 14 all right so
we've got how do we right now the states
inside of a state machine well the
states inside the state machine are
actually just types again so like we had
here not connected connect broker so not
connected is a state we're going to
inherit from state and the states can
have entry code and exit code and so
we're gonna write that as methods on
entry now the F s/m inside of the MSM
library FSM is a reference to the
machine so if we have hierarchical
machines it's a reference to whatever
the machine is that you currently belong
in and this client was that thing that
we initialized it with that we have
quite seen what the magic was for that
but we and we just called some machines
and we initialized it so that we can
call things like update connection
status so what I'm not connected I'm
going to update the connection says to
disconnected here I'm when I come into
connected I'm going
be connected and when I'm leaving
connected I'm no longer connected so
that I must be disconnecting so that's
the exit code when I'm shutting down so
when I'm shutting down if I get a
connect message as I'm in the middle of
a shutdown that's not a problem that's
just something I have to defer I want to
deal with later and so inside of MSM I
can state these are the lists of events
that I want to defer until the next
state and it will take care of that for
me all right so then we have actions
now notice syn packet is the same action
for each of these and different events
that are going to occur and so what is
that well it's a type and it then has
the callable operator that's overloaded
for each of the each of the event types
and so when it is a published out it's
going to do this
unsubscribe it's going to do that and so
forth so you can see that the code
inside the state machine is just trying
to handle state only and then delegate
activity elsewhere and then at some
point in the state machine we say we
have sub machines these are old sub
machines we have is a type list and what
our initial state is when you come up
this is where I want you to begin not
connected all right
so stop just for a second this is the
interface I want the interface that one
is dealing with types and I want to deal
with being able just to say like the
initial state is not connected and I
want to deal with saying I have these
sub state machines this is the list of
the sub state machines and I don't
really want to deal with any
initialization of those I want to
somehow magically initialize those that
makes sense
so now what we're about ready to see is
something that would be like below below
your normal place where you would be
operating this is lifted out of Laden
which is a distributed state machine
library that we use inside the company
and that we wrote and what we have are
things like trans
tables they they are a list of of types
and then sub machines well this is a
also list of types and and all of this
is getting ready I mean these this sub
machine thing that we said but just this
list of types it's getting ready so that
we can take care of setting this client
underscore that we just saw use client
under store score comes from the base
that we inherited from and I want to be
able to set that for all of the
different sub machines along the way
well what is client interface so here's
one of the problems with doing embedded
and where code bloat comes from remember
at the very top the client itself is
specialized on the connection the
executor and the callback type as a
result those types have to get
propagated to everything that wants to
understand how to talk back up to it and
we can end up with all this bloat that's
occurring because there are types that
that are being generated in the system
that we may not actually need in fact we
don't need them because notice the types
of things that the state machine wants
to do it wants to send messages to the
broker receive from the broker queue
tasks update connection status it wants
to do this sind none of these things
need to know about that other
information at all and so if we can
somehow separate the type system that's
up in the client where we care about it
and we're gonna implement the actual
functionality that the functions
themselves from the state machine that
doesn't care about it then we're going
to actually be able to reduce the number
of types inside of our system which then
at the end of the day will reduce the
code bloat one way of doing that is
something that's called type erasure and
Poorman type erasure is just using
virtual functions so I've got some
virtual functions here for these
different these different things and now
I have this client interface wrapper and
it will go ahead and implement these and
that's what glues things back together
because the state machines can't know
about the types yet somehow they need to
communicate to something that actually
has the type associated with it the
client so we're gonna use type of
research to break these apart and now
this is where it's being stored here's
the connection and here's the executor
though those two are being stored in
here
this is implementing the interface
itself that provides that erasure all
right so here's that magic thing this
initialized sub machines keep in mind
this is all like this is the library
stuff that we're just using but what's
going on underneath the hood and the
reason we want to look at this is
because we're going to use some
abstraction layers we just did this is a
huge abstraction for a whole bunch of
work now let's look and see what that
work is that is being abstracted away
and whether or not we actually had any
penalty from it
all right so initialize sub machines
this here is the machine coming in this
is the interface and want to implement
I'm going to assign the interface to
that machine's client and then I'm going
to initialize the sub machines excuse me
I'm going to to get another type this
imple and I'm going to call descend on
the machine type and apply it now inside
of the meta state machine everything is
a type and types can be associated with
other types and there are other meta
program things to figure out what the
subtypes are I want to be able then to
use that and that's what this is it's
initialized sub machine now is going to
through its operator and getting the sub
machine types it's going to assign the
interface and then descend again into
the next one and now this is the the
descend that's occurring what's
happening is the code generator the code
generation that's occurring from the
template metaprogramming is finding the
types for all the different sub machines
that are existing setting the client to
it looking at those types that it just
found for the sub machines do they have
any lists associated with them for sub
machines generating code
descending back down generating code
descending back down over and over again
so what does that look like will descend
is some you know funky meta program
thing with this metaphor each and an
apply so it is going to take the for
each of the sub machines that are in the
tight list it's going to execute the
thing that was passed in that function
here is the rest of somewhere we have to
terminate it because it's this recursive
call so here's the specialization to
terminate
that's the metal list that's what we
write metal type list anymore size was
one of the things that we needed to know
well size is nothing more than calling
the size of for the ellipse type so that
gets us for the the the tech list gets
us how many of them there were we don't
have time to make it through all of this
what I want you to see is there's a lot
under the hood going on in order to
build this for us to give us this clean
abstraction we've got a for each that's
doing some this is a meta programming
for each here's the detail for that for
each which is playing some tricks and
expanding stuff out so some of you've
been in someone at one or more of my
classes on C++ 14 and 11 you've you've
seen this trick right so we're we're
have a very attic template we're
expanding out the list here and then
doing nothing with it just so this thing
will execute with just the parent if
there were no sub state machines all of
that code went away it resulted in no
increase at all with one sub machine I
got 28 bytes of text well that's
probably very close to what was needed
anyhow to set the clinton to make the
call and set the client it's not a whole
lot more than that adding additional sub
machines had
very small increase almost none so I
have now this great abstraction layer
right not something that you would write
every single time but I've created this
abstraction so that I can think about
problems at a higher level it's doing a
bunch of stuff under the hood so I have
that abstraction I didn't pay for it
that's exactly why we want to use this
language right so I've got a better
abstraction to deal with didn't cost me
anything all right so here we go we've
got some types if you've been didn't go
to Ben Dean's talk on types okay one so
you know the idea of using the type
system to help you it's probably a good
idea so we're gonna use types to
represent the different messages so
we've got these different types these
are bi-directional ones publish Pub ACK
they've got some data inside of them
that represent then what goes along with
that message that would be delivered
back and forth here's from the server to
the client these are the messages that
it exists that exists there and bam you
know this looks like a variant to me
this x3 is is a is a variant that's
inside of spirit inside of boost we're
just gonna use that one it lets us make
objects more easily recursive objects we
don't have any recursion here but we've
got a type now this variant that can
hold any of our message types so control
packet can hold any type that represents
the messaging that's going back and
forth all right so once we have all this
cool stuff well we might as well do
Fusion adaption and so what Fusion
adaption is for for those who don't know
what fusion is fusion lets us deal with
is it is a library for dealing with
tuples think of it that way so by doing
adaptions it lets me not intrusively
adapt and and explain that these structs
look like these tuples references to
tuples and that gives me some magic that
we're gonna use in a little bit now if I
was to parse this stuff I could write a
parser like this right and I'm in the
header state I'm going to do this and
I'm gonna be inside the length and then
I'm gonna do this and then body you know
we all we all written parsers like this
before right okay so that would be one
way to do it here's what the header
reading might look like forming the
packet might look like something like
that
notice it's like based upon the type
that's going on I've got to do something
a little bit different each time oh here
it was actually the sub act packet so
I'm actually gonna do this bit right
we've we've seen parsing like this in C
code well went through all that other
work and it wouldn't be a good talk that
I gave unless I talked about spirits
somewhere so we're gonna write spirit
code instead spirit is an embedded
domain-specific language that allows us
to write something that looks like a B
and F it's actually peg for parsing
grammars so what this says is a control
packet is this literal byte for zero
followed by a pub AK or it's a one zero
followed by a publish or it's a to zero
followed by a con AK and so forth so
this is now declarative
it's this thing followed by the other
thing well what is the definition of
suback well it is we're gonna skip the
encoded length followed by a big word
followed by zero or more quality of
service messages that came in what is
the quality of service well this ends up
being at first I thought a problem
because I selected for my quality of
service and enumerated class and so you
can't just like shove in integer values
and have them convert you actually need
to be very explicit but the reality is
being very explicit it's a good thing
right it can only in the grammar in fact
it can only be one of those can't be
anything else that's an error in fact if
it's anything other than that so I got
like this built-in type check now type
safety so going through we've got pub at
contact you can see that reading this is
better than my case statements galore
this is declarative it looks like what
the grammar should be something followed
by something else so now what's the cost
follow this thing right the spirit
grammars and the composition of all that
along with it does all the air checking
which I didn't have by the way inside of
the other bit costs me just barely over
3k so the way I'm looking at this is I
traded exception handling for a
declarative grammar that has the built
in air handling already for me that
seems like a pretty good trait and then
I still have two more okay I can do
something with figured out yeah the
reason is all compiled time magic so the
spirit grammar we write this
domain-specific embedded thing those
types are going to make more types and
eventually the compiler is going to take
all that and make the parser for us and
because um because it happens at compile
time the compiler can see a lot of
things that are happening and it will
optimize that to a really high degree
right no our TTI is enabled that is
correct alright so the takeaway from all
of those slides in what your eyes are
starting to glaze over
we speakers hate the after lunch spot we
call it the NAP spot
so the take away from all of that was we
wrote a whole bunch of code including
spirit so the reason I did spirit is
just because we help maintain spirit the
joelle de Guzman is the author's spirit
works with works for Kiera and you know
so we do a lot of spirit and there's
long those I wonder what happens mostly
so that I could like poke Joelle and say
it didn't work on my little embedded
device the reality is actually just this
last week somebody got it running on
there was little app melt chips
everybody's all excited about audrey
knows they had it running on an adrenal
so that's pretty the takeaway from all
that though is don't try to be smarter
than the compiler just don't see what
happens right give it a try
especially if it is
heavy-metal Grameen stuff because the
compiler actually has visibility to
things that it won't otherwise have
visibility to and it can optimize things
that if you just had function call
function call punch goal I doesn't know
what to do with that right but if along
the way it had to instantiate these to
figure it out it has complete visibility
all the way through the stack trace it's
gonna do something possibly different
all right so we could do the last bit
that we want to talk about so with you
don't want to serialize this way but if
you were to think about how do i
serialize stuff going back out I I in
essence I have an algorithm of things
that have to happen I've got to figure
out the length of these messages going
out there variable length I've got to
figure out that link eventually I've got
to figure out the packet size it's gonna
be associated with the variable length
and some other math I've got to figure
out oh I've got to get a buffer to put
that stuff in and then I actually need
to serialize into that buffer and then
return it we're just going to say those
are the steps we have to perform now
those are the steps we have to perform
kind of regardless of what the message
is this is a good place for a template
because I'd have to actually write these
steps or in essence the equivalent of
those steps into a call right one way or
the other because these are each unique
based upon the T type so this is a
really good place to use templates I'd
I'm gonna let the compiler generate the
code for me instead of me making more
code paths and not only that the compile
is probably gonna be a little bit smart
for me here is what would happen if I
suing is subscribed I've actually got
some real work that I have to do all
right so I write that work this is the
imple yeah so I write that real work
well how about if I am how about if I'm
doing variable packet length for a ping
request
well ping request actually doesn't have
any variable packet length at all
so this is going to be a constant
expression it returns
do you think that the compiler can
probably figure out that the variable
length is zero here yeah right it's
constant expression right so it's gonna
be able to figure out that zero do you
think the compiler could figure out how
to add zero and a bunch of numbers that
it already knows yeah it can figure that
at a compile time right so the compiler
is going to do the work for you these
things aren't going to happen because it
can figure this out of compile time
serialize the imple for the ping request
mmm it probably can figure this out too
fairly well so to the point that this
call provides it ends up not producing a
lot of code so pick your types correctly
use constants pression when it's
actually a constant expression help the
compiler along alright so some
conclusions templates are not evil
all right you need to think about the
fact that their code generators probably
when you're doing something like that
those last set of slides we just saw
that's generating new code for each type
it has to instantiate that and all the
stuff that's down below you can take
advantage of that or it's going to
produce bloat so just be careful about
it when you go know what you are doing
with templates so spend a little bit of
time using them and figuring them out
there they're a good thing to help you
not have to write as much code determine
your level of embedded look if if you're
targeting some large device don't make
life hard on yourself right just go use
the whole standard library how about it
use the standard light-blue the standard
containers to start with so standard
containers have been well thought out
they have great interfaces you can
implement something that takes up a
whole lot less room utilizing that same
interface so just start off with the
interface you want and then change the
backend if you need to
you type aliases are a great tool to do
that don't out think your compiler
alright so we finally gave this thing a
name because I like coffee
it's macchiato spelt wrongly so some
people don't like cute names for
libraries but we've got like Phoenix and
spirit and fusion and I guess so we have
all the cute names Robert Rama doesn't
like cute names for libraries because it
doesn't say what it does but you know
it's got an Emma Q and two T's in it
right so I think we're pretty good so if
you're interested in the library is on
going to be on github very shortly there
is a readme there so you can actually at
least subscribe to then get when it
posts if nothing else you might see some
techniques inside there that will help
you out with your embedded work few
minutes we'll take some questions
yeah that's a great question so the
question basically is so with spirit it
is lots of types after types the way
spirit works is that each of those thing
that we set up on the slides was a type
and there was an operator in between it
and then another type those will compose
at compile time to produce a new type
which will then have some operator that
will then compose with that to produce a
new type and by the end of all of that
you've got this type that is SuperDuper
long right so first of all we turned off
our TTI so we have no runtime type
information so we're not going to get
the bloat of holding that around because
we don't care but the the main part of
your question is we don't we're not
handling what's called an expectation
point and spirit which means that a if
you have a and then instead of the right
shift operator you just have like the
greater than sign it and then B it would
mean that B must follow a otherwise you
have a problem and notice we didn't
actually we had no expectation points so
one of the things we did is we to get
away from this is we designed to the
grammar to not have expectation points
and at the end of the parse we look to
see because what will happen is the
parse will fail as opposed to throwing
an exception it will fail and we will
look to see whether or not we have
consumed they begin to the end so how
much of the input buffer have we
consumed we should consume it all
because we know where the begin to the
end buffer is for message delimitation
how we consumed it or not if we didn't
consume it it's an error
and then we handle it as a parse error
at that point so yeah for all the
serialization is that way for the back
insert or way yeah right so no so what
happens is we if something throws then
it goes to a single handler and things
are just bad at that point questions did
we link in static library statically yes
because it's just running on bear any
other questions all right thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>