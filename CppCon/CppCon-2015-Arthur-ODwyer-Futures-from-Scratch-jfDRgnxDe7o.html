<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Arthur O'Dwyer “Futures from Scratch...&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Arthur O'Dwyer “Futures from Scratch...&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Arthur O'Dwyer “Futures from Scratch...&quot;</b></h2><h5 class="post__date">2015-10-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jfDRgnxDe7o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everybody by the way if you're
like sitting way over there you might
want to sit way over here because I feel
like the the the center of gravity of
the audience is over here so I'm gonna
be aiming my my voice over here even
though I'm Mike
so I'm Arthur Dwyer and this is futures
from scratch it says on the door outside
shared future from scratch and that's
because I was too lazy to change the the
name of the talk once I realized there
wasn't really anything super interesting
about shared future as opposed to
regular future this conference has been
heavy on concurrency talks and even
futures talks specifically I highly
recommend many of those other talks this
one is going to be much more sort of
basic if you're looking for like you're
gonna go home and implement future for
your employer please don't pay attention
to this talk if you're gonna go home and
implement it yourself and play around
with it and sort of understand the like
how it works sure this is a great talk
but this is not efficient there's a lot
gonna be a lot of memory management
going on in this I'm gonna use a lot of
shared footers I'm gonna implement a lot
of efficient operations in terms of
inefficient operations so don't take
this as the way it's really done but I'm
gonna show you how to implement futures
from scratch so first of all what is our
goal before I even start talking about
futures let's just define the problem
the problem is I want to compute some
expensive sum of two things so I take my
inputs a and B I do expensive
computations on both of them and I
return o a plus OB which the outputs the
the problem here is that I'm serializing
my computations I'm doing one expensive
computation then the other one then
adding them together that's going to
take twice as long as it takes to do one
expensive computation if I've got
multi-threading of course I can do
better so I could do something like this
where I spawn a second thread I run one
computation in that thread well my main
thread does the expensive computation on
B then I join the thread and then I
return away + OB all makes pretty pretty
much sense this is manual thread
management this is like you know when I
do a make a thread and then later I join
it that's like newing memory I'm later
leading it it's just horrible if you
forget the joint I think it gets worse
because I think the destructor like
joins for you it the it's hard to read
it's hard to reason about and it's
asymmetrical which I personally I hate
asymmetry you know we have the main
thread and the other thread or I could
spawn two threads and have the main
thread do nothing which is actually what
I'm gonna do in a moment so take that
with a grain of salt what we want to be
able to write is something like this
right I just say please asynchronously
do this expensive computation
asynchronously do this other expensive
computation and then return their
results okay let's try to get there how
do we implement this async thing okay
this is a primitive I'm going to take as
given we have a schedule or
fire-and-forget scheduler it's some
global object that has some worker
threads and you can call schedule you
just give it a function that takes no
arguments and returns nothing and throws
nothing either that's going to be
important just a unit of work and I can
just say schedule this unit of work for
later and it will take care of all the
rest it will make sure that happens at
some point in the future
Sean parent had a talk last year I think
that the they're covered in detail like
how you would do this with a threaten
basically making a thread pool an
earlier version of this talk I went
through all of that and it took an hour
so I'm not going to do that just assume
that we have that okay so now our code
looks like this right we make up a
couple of Lanza's that do the expensive
computations they don't return anything
they can't return anything so we just
store the results into Oh a-and OB and
then magic happens and then we can
return the results I think you should be
a little more explicit here in step two
okay so what is the what are those
question marks all right
I love metaphors so we're going to talk
about how did the live for messages
between threads we have our two actors
here Pat and frosty
we have frosty because I
I was looking for clipart of someone
waiting for mail and this was the cutest
one
so frosty is waiting for a letter from
pat pat is going to deliver the Levitt
letter to frosty but frosty is really
lazy in other words frosty could just
check the mailbox every 10 seconds and
just see if there's something in there
and eventually Pat's gonna come along
and put something in there and the next
time he checks the mailbox he's gonna
see it there
that's polling polling is terrible it's
spinning its bending waiting for stuff
so we're not gonna do that we're gonna
want some algorithm that allows some
protocol that allows frosty to just go
to sleep just go to sleep next to the
mailbox and wait for the letter to come
so when Pat brings the letter well she's
gonna have to wake up frosty song now so
here's what's gonna happen
Frost he goes to sleep next to the
mailbox Pat comes along Pat puts the
letter in the mailbox but frosty is
still asleep and doesn't see it
therefore Pat is gonna wake him up by
banging her cymbals really loudly that
wakes frosty up frosty looks at the
mailbox how does he know there's
something in it well when Pat put
something in it she raised the flag on
the mailbox
yeah that's the opposite of what she
does in real life but so frosty wakes up
sees the flag raised knows that's the
symbol signal also the symbols he knows
that the signal for him to go look in
the mailbox so he goes and looks in the
mailbox Pat by this time is no longer
touching the mailbox because she's
already banged her symbols and she's
left so it's okay they don't you know
bump into each other they don't have one
of those moments where they touch hands
and it gets weird
so frosty then has complete access to
this mailbox and he can open it up and
take the letter out and read it okay so
we can implement this oh yeah also uh
right frosty is lazy he wants to go to
sleep but you know he is sleeping by the
mailbox that's next to a busy road he
might wake up at some points so he needs
to be able to handle these spurious
wake-ups just because he woke up doesn't
mean that Pat has come along in banker
symbols it only means she's banker
symbols if the flag is raised right if
he wakes up due to some noise and the
flag is still down he can just go back
to sleep he knows it wasn't Pat because
Pat raises the black right and Pat and
frosty can't both be touching
at the same time okay so here's what
this looks like in code we have a mutex
on a condition variable ever by the way
who for who is this not like a refresher
who well ok nobody raised their hands to
this so that means that this is a wait
this is a refresher for everyone yes all
right all right so we we set the boolean
to true that raises the flag we notify
one on the condition variable and then
frost a in the in the main thread here
is waiting on the lock in a loop right
okay so the problem with this approach
notice that the this is this is doing
our expensive computation right so we do
this for a and then also we do this for
OB the problem with this computation
besides being a whole ton of boilerplate
code is that people move right frosty is
waiting for this letter but he's waiting
a couple years and in the meantime he
changed his apartments and Pat needs to
know that when she comes she needs the
delivered letter to well she thought
that was where frosty lives but now he's
over here and then it gets messy so we
need to allow the the two sides Pat and
frosty to sort of move move around might
be passed around as arguments to
functions and return values but still be
able to communicate with each other and
this is where futures come in or post
office boxes we need a basically we need
a post office box we need a mailbox that
lives at a known location we're just
going to allocate it somewhere on the
heap and our two sides which I'm now
going to abbreviate F and P and then I'm
gonna re expand out the future and
promise they get to move around because
they're just pointers but they hold
pointers to a known location these
pointers are movable okay so now we're
going to get into the the part of this
that is all code and fortunately it's
all readable because we have a huge
screen but this is where it gets boring
so we have a shared state this is the
object that's gonna live out on the heap
it's gonna be our our post office box or
mailbox and it's going to have these
members we're going to have the mutex in
the condition variable and the boolean
ready flag that's going to be our
mechanism for transferring information
and we're also going to have a certain
amount of actual payload here namely
we're going to have something of type
our like if I have a future of int then
R would be int and this is where I put
the int when I when I satisfy the they
promise I put the end there and then the
future can read it back out I'm also
going to put in something holding those
that exception footer which we'll get to
later now the the value and the
exception put are put together that's
basically an expected of our as I
understand it it's certainly the same
thing as a try of our in Folly and that
turns out to be a very useful
abstraction which I am NOT going to use
in this talk because I didn't have time
to rewrite my slides after learning that
and then our futures and promises are
gonna look basically like this I'm gonna
have a promise of our it's going to have
a pointer to the state in order to
eliminate all of the tedious bookkeeping
for this talk I'm just going to make it
a shared footer and it's gonna have a
member called set value that takes an R
again for simplicity I'm just gonna take
it by value and it's going to do the you
know walk the thing set the value raise
the flag and then notify all or notify
one let's say notify all because I it
makes things simpler you don't have to
worry about how many things you have the
future future of R is also going to have
a shared butter to the state that that's
allocated out on the heap and when you
call get on this future it's going to
lock the mutex weight on the condition
variable until the flag is raised and
then it's going to give you back the
value so that this is in a very very
high-level simplified fits on one slide
version of what future and promise are
doing they're communicating via the
shared state that lives somewhere
elimate okay so here's the real deal
yes one level of detail down what is
promised going to do when you give it a
value to set first of all if it doesn't
have a state at all that is if it's been
default constructed or it's in a moved
from state it's gonna throw then we're
gonna lock the mutex if it's already
ready if someone has already set the
value it was probably us just a moment
ago we're going to also throw out we're
gonna throw a promise already satisfied
by the way yeah these are obviously not
the standard version of this right I am
too lazy to write the standard version
of what we actually throw what we
actually throw is a stood future error
of a particular you know that's also
defined in the standard and I am NOT
going to write all that because that
won't fit on a slide but I will write
just throwing a string literal
okay so we've now established that we're
not a moved from promise and a promise
is not yet satisfied and therefore and
we have a lock on the mailbox so now it
is totally safe we're the only ones with
access to mailbox we can move the value
into them into value we can raise the
flag and we can clash our symbols again
in real code you would drop the lock
before clashing the symbols because
that's more performance here that takes
two more lines of curly braces and make
the font smaller and you wouldn't
appreciate it
we're also going to write this exactly
the same function called set exception
that takes an exception footer and does
all the same stuff but sets the
exception and this is so that we can
also communicate not only the return
value of the complicated expensive
computation that we're wrapping we can
also communicate with it throws I will
also note in passing that set value and
set exception are non Const methods so
this means in these sort of convention
that is developing
what this constant me and I cannot call
a set value on the same promise
simultaneously from two threads that is
undefined behavior I can call it once
and then later call it and as long as
what happens before the other that's
okay the second one will throw but if
neither of them is the second one they
bump heads and that's a problem
likewise on the future I'm sorry not on
the future side of things where we're
saying how do we get a future it's a
little bit wacky that when you create a
promise in the future you don't create
the pair of them together you create the
promise first and then you call that get
future and that gets you the future so
it's possible to have a promise and then
satisfy it by calling set value and only
later get the future out of it and then
you have a ready future but let's say
what are we doing here right you can
only get a future once so when you call
get future again an on constabie cuz
it's actually going to set a flag that
says you've already retrieved the future
from me
if you've already retrieved the future
I'm gonna throw otherwise okay here it
is
future side of things it also has a
shared butter to the state out there on
the heap it has a couple of member
functions one is weight
what weight is going to do is say if I
have a state then lock the mutex and and
wait on the condition variable and until
it's time to wake up weight is a
constant function so you can call it
from two threads simultaneously it's not
doing anything
unsynchronized here other than looking
at you know the value of the state
pointer which is not going to change
unless you are simultaneously writing to
it you know and obviously you can't
simultaneously write to something you're
waiting on or if you do with some
defined behavior because writing to it
is not Const and then we have this get
method which is non a Const because with
a regular old future you can only get
the value out of it once by value that's
just going to wait and then it's going
to either read throw the exception
if if there were an exception stored or
it's going to move the value out of the
place it was on the heap and give it to
you as the return value would get so
again this is probably all a refresher
let's see the interesting thing about
the implementation here by the way if
you were to go play with us yourself you
can do a clever little trick here where
what I'm doing here is moving the state
pointer out into a local variable so
that as soon as I do that it knows
itself out and then I can use the
variable that I've got to either read
throw to it so I still have a handle to
it myself but my object no longer does
so that I can safely like throw an
exception or whatever without having to
worry about cleaning up my object
afterward boom what's next oh yeah it's
got a couple of utility functions it's
got valid tells us whether the state but
whether it's valid or not if it's been
moved from or if it's been default
constructed then it's not valid and
there's this other function that is
coming under either this name or this
name with is underscore free pen to do
it called ready or is ready and what
that's going to do is just tell you if
it's ready or not it's kind of useful to
know it's a constant member function and
you you might have something conceivably
where what you wanted to do was you know
if I got a future that's ready right now
I'll just go ahead and do something with
it but if I would have to wait well I
actually have some other stuff I could
do now why wouldn't you just do the
other stuff in both cases some reason
that I'm sure some people have okay so
that's all easy what are we doing next
oh yeah we're gonna show how you use it
right here's our compute expensive sum
function and we are going to make some
promises get some futures from them and
then schedule to fire-and-forget tasks
to fulfill those promises by calling set
value I wait the result of expensive
computations we can
fire-and-forget those then we just call
get which waits on both of these futures
and that gets us the answer right
however notice that we haven't actually
moved anything around
we didn't make frosty go live somewhere
else we didn't make Pat go live
somewhere else we just took their
addresses so that that's dumb let's
actually capture them by by move using
C++ 14 init init capture so now we're
taking the the promises that we created
as local variables and we're just going
to move those into the fire-and-forget
tasks that we're going to send off
through our scheduler even though our
local variables are now in the old Aldon
if we looked at them we would see they
were not valid the scheduler you know
whatever queue of tasks it has is still
holding these promises will still
fulfill them and as part of executing
these tasks and we can still see the
result because we have these pointers to
our shared state but what if we do this
is another of these little corner cases
what happens if we only sometimes
satisfy a promise I promise and then
other times we don't fulfill it and we
just delete it we destroy it without
having fulfilled it what do we do well
probably we go find the bug and fix it
but how do we know that we have a bug is
it like undefined behavior or what it
turns out no it we will we will be nice
enough to our users that we all define
this behavior
whenever you destroy an unfulfilled
promise or whenever you override it with
the assignment operator or any other way
you could you know destroy the old one I
think those are the only two standard
ways it would be nice if they were like
a reset methods II didn't just have to
assign it a new default constructed one
but you know and any time it goes away
unfulfilled we say that the promise has
been broken and so we we just have this
little abandoned state secret wasn't
enough room to write private so I didn't
what it's going to do is say well if
we're valid and if nobody
and if somebody did get a future to us
then and we're not ready then just
pretend that we did call that function
we were gonna call on it through broken
promise and then we make it ready we
bang the symbols of the futures then if
there's anyone waiting they wake up and
they see oh I I threw broken promise
notice there's no way to distinguish I
mean if you're all if you are going to
be using promises and future's calling
promise thought said exception broken
promise is probably terrible but why
would you do that anyway you wouldn't do
that alright so that completes by the
way a c-plus Elevens future and promise
for the things that they provide future
and promise not all of concurrency let's
talk about all the rest of concurrency
at this point how many doing on time by
the way awesome so we have a problem the
problem is we have this fire-and-forget
scheduler which by the way we don't have
write like C++ 11 and 14 do not give us
the scheduler right we wrote that but
even given that we have that that's a
really fragile abstraction it requires a
lot of bookkeeping because we have to
like generate these local promises and
futures and pass the promise to the
lambda that you know all that stuff I
had the right before it's log
boilerplate and you have to remember
that every time you call dot get well
every time you call it get it might
throw an exception but every time you're
going to actually do your computation
inside this lambda here you know I have
to set the value to expense a
computation of a but if that through I
need to catch it and set exception right
so basically this is what I'm writing
and I'm writing that twice and
everything in red italics is stuff that
I really don't want to have to write
right the only thing I want to write is
expensive computation of a so let's try
to clean up all of that boilerplate we
have a solution for this standard
packaged underscore task you know as I'm
using this convention of using all
uppercase like camelcase names
I should have mentioned at the very
beginning so I'm gonna be using
camelcase names for things that like I'm
implementing and then if I use like
stood shared underscore point or you
know that that's the standard one so
let's implement package task this is
analogous to state function which I'm
sure we all know and love but it's
delayed action in that when I call the
mul you'll say here's how its
implemented it's going to store actually
a sted function or something called
unique function actually which is coming
I hope unique function is just like
state function except that it can
capture it's not copyable it so that
means it can capture things that aren't
copyable so that means it can capture
promises because promises aren't
copyable so you really need it if you're
going to implement package tasks which
is why it should have come before
package tasks but now it's coming and
it's also going to have a future as a
member variable and it's also gonna have
this promise already satisfied
bookkeeping because as usual if you try
to do something twice we're gonna throw
an exception to tell you you did it
twice so when you pass a function into
the constructor for package task we're
just gonna do all that boilerplate for
you all that boilerplate was in red on
the previous slide we're gonna set up a
lambda that captures a promise that also
captures the function that you pass to
it that takes some number of arguments
and forwards them to the function that
you just captured the function you want
to call the wrap it'll set the value or
set the exception of the promise and
that's it we're not gonna schedule that
anywhere but we're just gonna make that
a member variable a little private
member variable
and we're also going to get a future the
future that promise when you call
operator paren paren up the call
operator on a package task it will go
execute the task for you again not a
synchronous package task is not doing
anything with a synchrony it's not
scheduling anything it's just doing what
you tell it if you tell it to go call
that function that will go call that
function if you don't tell it then it
won't call
function but that means that now that I
have package to ask Oh what else do we
got going on here and whatever we can
use package tasks to build a safer
abstraction safer abstraction is async
and it looks kind of like this so when I
say async of a function the first thing
I do is I take that function and I move
it into a package task and I get the
future of that package task and then I
tell my scheduler which remember is not
one of the standard things you get yet
but it's probably coming in C++ 17 with
executor 'z I don't fully understand
executor yet but it's gonna be something
where you can fire off things for
execution
so we schedule this task for later
whenever the scheduler gets around to
executing the task it's gonna call this
operator paren paren that's going to
fulfill the promise our future is gonna
see that result so if you called get on
the future return from this function on
results that will block until the
scheduler gets around scheduling your
tasks and that's what we want
hooray we just built a sync okay we
didn't really build a sync because we
didn't pass in arguments as well so we
need the perfectly forward those
arguments that the underlying thing and
that actually turns out to be really
hard as I presented the lightning talk
just a moment ago so I'm gonna skip all
of these stupid hacks because we have
better things to talk about okay if you
believe me that we can implement those
then hooray we've just implemented async
completely from scratch alright so next
fun part let's make C++ look like a
JavaScript right we're gonna talk
basically about dot been by the way
that's what's coming
it's boiler first of all the let's let's
refactor this code a little bit to make
it easier to use it as a building block
so we had our set value right where we
took the lock we see if the flag is up
and if it is we throw and then we move
out we move value and we set ready and
but this is pet looking to see if the
flag is
now frosty never touches the flag the
only way for the flag to get up is if
Pat raises it and Pat is unique right
promises are not copyable you can't have
two promises looking at the same stated
state and you can't move a promise from
one thread to another without putting
some sort of synchronization in there to
get the value over there so that means
that if Pat is looking at the flag
that's safe Pat doesn't need to take the
mutex in order to do that so we move the
mutex down and we do that instead
exception two and then we can factor out
that whole bit of like take the take the
mutex raise the flag no to bang the
symbols right we we just factor that
whole thing out into a helper function
called set ready okay now we can make
set ready more complicated right hurray
for refactoring by the way who here
loves refactoring good that was a lot of
hands all right so now we have a single
place that says set this future ready
let's make that more complicated so what
we're gonna do we're gonna add to our
member variables out there in our post
office box in addition to the value that
we got or the exception that we threw
which again is the same thing as an
expected or a try we're going to add a
list of continuations this is a list of
unique functions again fire-and-forget
functions these are functions that will
not take any arguments will not return
any values and will not throw anything
if they do all bets are off
these are continuations so then in our
set ready what we're gonna allow you to
do with this new and improved future is
when it becomes ready we're going to go
and schedule on the system scheduler all
of its continuations we're not going to
execute them but we are going to
schedule them and then we're gonna clear
the list of continuations and we're
gonna bang our cymbals so this is how we
put something into the list of
continuations
this is too much code for one slide but
basically we're gonna make sure that the
future is that one we're going to
invalidate it by moving its state out
into this local variable and then we're
gonna make up a task that will call this
function that we passed in and we're
going to give it this argument which is
star this itself that is when I call if
I have a future F and I call F dot then
G that actually invalidates F and gives
me back a new future which shares state
with a promise held by a task on the
continuations list of the original
future did I do that right no the
original promise the original promise is
held by Atlanta you know what I think I
have a picture soon so bear with me if
you're lucky it's a picture of a cat I
think it's actually lines in boxes all
right once we have this continuation
we're going to if the future is not
ready we'll just add it to its
continuations list and again there's no
race condition here because this is a
non-constant nobody else can be touching
this at the moment and then we're going
to oh and if the future is ready we'll
to schedule it immediately right if you
call been on a ready future let's just
like do the thing now all right what's
our motivation our motivation is we have
this compute expensive sum and now we've
done our a sinks but now we're going to
take the result of expensive one of a
and called expensive two on it so
expensive - of expensive one of a and
this is a recap yes it's gonna look like
that right we're gonna make a future
we're gonna say dot then do this other
thing and I'll pause here because this
may be unfamiliar to people who have who
know then is coming but haven't seen it
used is this is this getting unfamiliar
see a bunch of shaking heads alright so
javascript programmers are cringing at
the amount of boilerplate going on here
the fact that I have to write this like
I write this lambda and then it takes X
and then I have to call X that get
inside the thing this is getting messy
let's make c++ look more like JavaScript
or like Haskell somewhere in here I give
a shout-out to Travis but where is it
it's coming all right what we're gonna
do we're gonna take ma the this this
future dot then and then a lambda we're
gonna keep that lambda but we're gonna
make it no longer take a future oh by
the way this Otto is standing in for
stood future of mid just in case that
wasn't obvious what we want to write is
something more like this
right where the the lambda goes
completely away because we already have
a name for our function on values we
want to take our function on values and
kind of lift it up into the Monad of
futures and promises we want to make it
a sort of meta function that operates on
futures invisibly with this thought next
thing and then we can just write this
right we could just say async of the
expense of the first expensive thing
thought next second expensive thing and
this is equivalent to calling dot then
with the appropriate things and that's
equivalent to scheduling things in the
appropriate way to make sure that they
get done nice and asynchronously so if
winning next is really easy if you don't
care anything about efficiency which I
don't
so the way I'm gonna implement next is
as a wrapper around then that just
copies all the boilerplate we saw
earlier this is horrible if you're using
a library that provides you something
like next it will not do this it will do
something smarter right yeah so Stryver
showed us
we can just a lot more efficiently if we
care - I don't care - though and it
wouldn't fit on a slide also in a paper
which I mentioned a while back more
improvements to stead future of tea and
three eight six five this is a I believe
a current proposal not yet in the
concurrent CTS I hope it comes because
it seems pretty awesome but I have no
special knowledge oh right yes it did
change also provides this function names
recover recover is another rapper just
like next except that instead of lifting
a value it says if an exception was
thrown then I want you to do this and
this is even less sufficient what we're
gonna do here is we're gonna wrap up
this function in something that takes a
future and if it didn't throw we're just
gonna return X I get but if that does
throw an exception then we're gonna call
this funk with an exception butter and
now we have something looks like
JavaScript because now I can just say
async of like build some string from
some input and then next with the value
I want you to convert it to a double and
by the way if either of those threw an
exception recover by giving me nan and
so this is if the that end eight three
eight six five gets in you'll be able to
write this and that's gonna be kind of
cool and it's going to be efficient as
well I should mention it's not gonna be
what I'm showing so there you go that's
pretty awesome there's also one more bit
of convenience wrapper
you can just say fall back to and give
it a value and that's the same thing as
a function that just returns that value
oh and it look it's the obvious thing
all right quick recap so I built you a
promise that has a get future asset
value asset exception and some private
things the standard one in C++ 11 also
has a couple of very obscure features
asset value at thread exits at exception
of thread exit these are provided
basically because it's implemented in
terms of condition variable and
condition variable happens to provide
you notify all at thread exit so you can
do interesting things when your current
thread exits if you want to how that
condition variable feature is
implemented I'm not sure I would assume
that it exists in the standard because
it exists in P threads I'm not sure
future built you a future that has get
weight valid ready or is ready then and
then the convenience wrappers next
recover and fallback to which are all
implemented in terms of then here but
will be more efficient things we won't
cover weight also has variants wait for
and wait until which exploit the
features of condition variable called
wait for and wait until okay there's
this other thing yeah you know you all
came to this talk as it said the shared
future from scratch on the outside I'm
not talking about shared future but
there is also a member function called
share that returns you it invalidates
the current future and it gives you back
a shared future which is to future as
shared putter is to unique putter shared
futures are copyable that should be here
it share futures are copyable you can
copy them and they have a few other
little quirks such as there get actually
is a constant member function that
returns a I Const reference to the
shared results so that way you can call
get on a whole bunch of shared futures
and they can all see the answer which is
good because if you could copy it but
only see the answer once it wouldn't be
very useful you can also call dot then
multiple times on a shared future which
allows you to make a sort of branching
tree each of the children will get its
own copy right you since you can't copy
regular future you can't attach multiple
bends to it because then two bends would
run they both got a copy of it you can't
copy you short feature you can so okay
I've said the word copy enough I was
originally gonna talk about when any and
when tall but they're not actually super
interesting and I'm sure you all know
what they do anyway it is a little bit
weird than the current current
concurrency TS if you call when all on
zero things it says all zero of your
things are ready awesome if you call
when any on a list of zero things it
will happily tell you yes at least one
of your zero things is ready that's a
little bit weird by the math math major
I'm not sure that that's really the
behavior that would make sense on the
other hand if I'm using it that may be
the behavior I want because why would I
ever want a future that doesn't become
ready I don't know all right so now I'm
gonna we have less than 30 minutes but
hopefully 20 minutes I just want to talk
about something that I've also
implemented in the repo which is kind of
interesting
then with cancellation this is something
that the Shawn Perrin also talked about
in better code concurrency but didn't
provide like a an implementation of this
is not a real implication this is a toy
implementation but just to show you like
basically what we're talking about the
the problem that I want to solve here is
that if I have a future F and I say F
dot then something else thought then
something else dot then something else I
can set up a whole tree of work to be
done
maybe loading resources from files and
isn't his example it was loading pieces
of an image as you like move around in
the image you want to start loading
things speculatively but quite a lot of
that work is actually turns out to be
unnecessary because by the time it gets
around to being scheduled by the
scheduler you've along since lost
interest in it you actually have other
things you would rather do first so
wouldn't it be nice if whenever I
destroyed a future when I destroyed the
last shared future to one of these
things out on the heap one of these
shared States
that would somehow cause the work to be
D scheduled all right so I can I can
hold on to futures as long as I'm
holding on to them the work will get
done because I might call that get on
the future but once all the futures are
gone and I can't get another one because
you can only call get future on the
promise once so I know they're all never
in the world B anyone who is interested
in this work I would like to just drop
the work and not do it now I can't do
this in the standard like under the as
if rule or anything because like the
whole point is that I want to change the
behavior of my program I I want to
actually not open files I would have
been opening I want to not do
computations I otherwise would have been
doing so I want an observable effect on
my program I want it to run faster so
how would I actually implement this if
that's what I wanted it turns out
package task is actually the place that
I would want to do this this is where I
pass in a unit of work and wrap it in a
thing that does it so if I want to
sometimes not do this unit of work this
is the place to do it
I could try something like this all
right this is very simple I just say I
made a promise I got the future out of
it I'm gonna pass that future back to
you and you're gonna maybe you know
share it make some copies of it but if
at any point the promise captured in
this work item I'm gonna schedule in my
queue if at any point there are no more
futures referring to that shared State
which is easy to tell by the way because
shared footer has this member called dot
unique that will tell you whether it is
unique if I if I have the only reference
through this shared to this shared state
then there are no future is also
referring to it and so therefore it is
safe for me to not do the work and I can
just destroy the promise okay awesome
problem solved right we have this told
you there's a picture coming up it took
a while longer than I thought where the
shared state on the heap I have a future
and a promise I take the promise I put
it into a package task and I move that
package task over onto the cue of the
system scheduler
then it gets more complicated as I call
f dot then f dot next which wraps F dot
then what that's gonna do is the shared
state a has a list of continuations
represented by this little grey arrow
which is an owning non smart reference
of some sort and I'm gonna put a package
task on that list of continuations it's
gonna have a future you know we're we're
when this is scheduled it will wait for
this shared State and that's why this is
totally inefficient because by the time
it's scheduled this will definitely be
done and it has a promise that allows it
to satisfy this shared state of B over
here to which I have a reference G when
some task finishes and as promised is
satisfied then as part of setting of
calling set ready on shared state a we
will actually schedule this task move it
down onto the queue and at this point it
will run it will satisfy shirts they be
ok so let's say that if we're at this
point where we have two of these tasks
we have some task which is on the cube
it hasn't been scheduled the earth we
have called dot scheduled to get it onto
the queue but it's not actually executed
yet and we have this other package task
which is still living out on the heap
and a queue somewhere in the
continuations list and we drop we drop J
we just delete it we destroy it so in
this case P 2 is now unique it has no
extant futures and therefore when we
come around to executing some other
tasks executing this this package task
it's going to check P to see that there
is nobody who cares about the result of
the work and therefore it'll just
immediately say I'm done nothing to do
unfortunately we didn't solve the
problem of a big chain of work because
we're still going to do everything up
through that very last step
just get the last step so that that's
uglier we actually want a different
system entirely the system we want is we
want to have the promise in the future
both with their shared footers to the
shared state and then we also want the
future to have this other idea of as
long as there's a future alive it
controls some cancelable tasks state
this is the state that I want to be
alive as long as someone is listening
and as soon as nobody is listening I
want this to die
so therefore the package task is only
gonna hold a week one or do it there's
gonna be a single weak pointer to this
thing and as many shared footers as
there are f's
or as much as there are futures now the
graph gets uglier this is the fun part
that it's like I'm like a Mario level or
something all right so I've called F dot
van and I've gotten the new future named
G G has its own shared State it's a
shared state of B the promise for that
new shared state is captured in a
packaged task which is currently on the
continuations list of the shared state
of a that guys promise is in the system
schedulers queue waiting to be executed
meanwhile when this task get executed
it's going to do some task on on nothing
right it's gonna do some task that's
gonna produce an answer it's gonna use
it to satisfy that promise and then
that's gonna schedule this that's this
middle walk and everything is actually
held together oh yeah so here's how
we're gonna implement this by the way
should be obvious from the from the
arrows and lines and whatnot but we're
going to
our future now needs two shared pointers
it needs the original shared pointer to
the to the states where we're gonna put
the result and it needs a cancelable
task state which is just a shared putter
to avoid that we can just set to
whatever we want you know the nice thing
about the shared fighters being a
somewhat type erased is that you can
just shove random things into them in
fact you can shove random things into
the captures list of a lambda and and
end up with a thing that's just keeping
anything you want alive as long as you
want it which is where these arrows and
lines really come in handy because then
you get to it took me quite a while to
lay out this let's graph michael webb
where do these clouds go alright so then
with cancellation here's what we're
gonna do we're gonna make a task and
write this this is what it looked like
before you can tell by the number of
blank lines on the screen this is our
old package task without any
cancellation mechanism we're gonna add
the following mess first of all I'm
going to take this F that before I was
actually capturing inside my package
task and I'm gonna capture it somewhere
out on the heap via make shared and I'm
just gonna leave it out on the heap
because that will allow me to delete it
irrespective of when the actual package
task itself gets destroyed and I'm gonna
attach that cancel task state to the
future then I'm going to capture a weak
pointer to that cancelable task state
and inside the the package task I'm
gonna say if there's still someone
holding a reference to that the weak
pointer if I can lock it and get back
something that's non null then the thing
I've gotten back is the function and I
can call it otherwise nobody has kept F
alive for me to execute therefore and
nobody cares about F therefore it's a
good thing I've lost track of
I don't want to execute it anyway I've
snuck something into this slide because
I have a vested interest in it this s
pointer dot unlock how many people know
what that does no hands
that's bad for me how many people know
what lock does alright unlock is the
opposite of lock it doesn't exist I want
it to exist and you go to Conan I'm
gonna tell them to make it exist but
basically I have a shared pointer at
this point that I've just made and I
really want to capture a weak pointer I
don't want to capture the shared butter
that would be bad I actually want to
capture a weak pointer but I also want
my code to fit on a slide and therefore
wouldn't it be nice if there was some
way to take a shared pointer and cast it
to a weak pointer you can do it with
cast but that's a lot of code and you
have to know what type it is like notice
here I didn't refer to the type FF
anywhere except up here and I wish I
didn't have to do that in fact maybe I
don't cuz i forward it F wonder if just
getting rid of that FF would just make
it work but anyway I have a shared
pointer I want to capture a weak pointer
it would be nice so then what happens
here just to get back to the mario level
here's our what happens when we call F
dot then now let's suppose that we drop
G on the floor when that happens it's
shared footers go away okay now what
else in here goes away when the last
shared butter - it goes away
well SSB down here still has a shared
pointer so it's still alive but deleting
this shared butter
- this actually kills it so it goes away
which shirt putters go away and we end
up with something like this I've left
the weak pointer arrow is still pointing
out there just to indicate that nobody
knows about them nobody who just died
there's gonna go set up the knoll or
anything but you know and they do still
control control blocks out there but for
all intents and purposes when you lock
them you get back null so that means
that when we try to schedule this task
it will try to lock its weak pointer it
will get no and it will say I don't need
to do this work and it will die and that
will kill its promise we have a slide
for that nope
I just have grumpy cat but that will
kill its promise which will kill shared
state of a which will kill the
continuations list which will kill
shared state of B and now they're all
dead and so we didn't even have to do
either of those tasks we didn't even
have to start executing this one to find
out that nobody cared we already knew
when we destroyed this it destroyed that
destroy that never even executed the
code that locks tries to lock this week
wire you know I put grumpy cat because I
didn't think that I was going to get to
the 87th slide but I just did so any
questions any unquestioned
after the taking the ready flag out of
the mutex so this is something by myself
was unclear about so if anyone wants to
convince me otherwise feel free but so
we had been walking the mutex and then
checking the flag so that we could throw
like promised already satisfied you know
had has already delivered the letter but
this is Pat doing the checking so there
is no way for that ready flag to change
while Pat is looking at it
yes yes that is also definitely true
yeah
frosty will not be looking at value ever
until ready flag is set and Frost he's
not gonna know that ready flag is set
until at least until we set it right and
possibly not until we do the the
condition variable notified actually
sort of propagate that change everywhere
I was initially a little bit concerned
that you know Pat herself this this
particular promise if if it's set the
ready flag then it would no it would
definitely see that change but what if
this promise sets the ready flag and
then you still move it over here and
then this one checks the ready flag well
they're still in the same thread so
that's actually okay but what if you
moved it across threads but if you
passed it to a function executing a
different thread and I don't think
there's a way to do that without
synchronizing those two threads so I
believe this is completely safe
I'll be questions already done guess
we're done</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>