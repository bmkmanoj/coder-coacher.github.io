<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Joel Falcou “I Wish I Could Use C++ 1x/y/z ” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Joel Falcou “I Wish I Could Use C++ 1x/y/z ” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Joel Falcou “I Wish I Could Use C++ 1x/y/z ”</b></h2><h5 class="post__date">2017-10-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gPj90zwLphw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">So hi everybody.
I'm Joel Falcou.
I will make today a
presentation about a subject
which is maybe something
that actually reach out
to a lot of people around there.
So public announcement,
this will be a vegan now,
templative programming presentation.
So you could sit and relax.
Let's start by a small amount of poll.
Is there anybody in the room
which in his professional
environment is still
stuck with pre-C++ 11 C++.
Okay so, let's make a prayer
for all those guys and girls.
(audience laughing)
How many of you are
actually currently building
a let's say production ready
software systems whatever
using C++ 11?
Wow, quite a bunch, C++ 14,
and who is you know like
how to say that who like to live in danger
and is still producing
production ready software
using C++ 17?
Great, okay fine.
So you two, you can go actually.
(audience laughing)
The question I will try
to ask and try to find
an answer around is what if you are stuck
in a situation where for different reasons
that we will go over, you have no access
to some of this modern C++,
well sorry, recent C++ features.
The notion of modern C++
is starting to be fuzzy.
So why I'm speaking about that.
So we at Numscale, we try
to build highly performant,
highly efficient tools for
people, and we make a choice
to try to write this software
with a minimum amount
of technical depth by adopting
the most efficient version
of C++ for the given task.
We understand that by being a startup,
we have the choice and we have
the opportunity to do this
choice, but it's not
something that could be
doable in any organization.
So I wanted to go over a bunch of things
that happened to us at some point
before we migrate.
And, how you can actually
sell to your management,
slash computer science department, slash
whatever boss the fact
that you need to upgrade,
and this upgrade need to be done quickly.
So I will let you interrupt
me during the talk
if you want to ask
questions, don't hesitate.
So, let's start.
What was the problem actually?
Well we're probably at
the best place in time
to actually do cool C++ things.
There is a large amount of interesting
momentum around the
current version of C++,
the next one and starting
soon the next, next one.
So there is a lot of things going on.
So it's a lot of
experimentation that leads
to very cool new ideas and practices.
Some of you may have seen
this week or last year.
And, the language itself
is getting easier to teach,
easier to actually reason about.
It's more workable than ever.
So the question is why not
is everybody still doing
C++ 14, 17 already.
The question is it's more a cultural thing
than something else.
So the solution are not that much.
Indeed, you can actually
make some kind of lobbying,
so you can switch to
whatever version of C++
you want to go.
Or, which is a more radical thing,
so you can get a new job elsewhere,
or well you can you
know like drop the ball
and do something completely different
as a source of income.
(audience laughing)
And, so if you have any questions,
thanks for coming to this talk.
I'm not serious of course.
(audience clapping)
So if you are not that radical,
well what's the actual question?
Well what is preventing people to migrate
to new compilers version or new compilers
all together because
sometimes it's more than just
changing version, it's
switching from GCC to Clang,
or GCC, wait sorry, Visual
Studio to GCC thing like that.
So it has a real impact which go beyond
the simple technicalities of the language.
You may have a huge cost to change
your compilation stack, your compilation
build system, whatever.
And, those fundamental
change are some things
that companies or
organization may be wary to do
because they put them
into an unknown situation
about how many times before
my production ready code
start compiling properly again.
There is also a bunch of
latency between the fact
that the standard is
issued, and it's available
in a given compiler even if it's done
far, far faster since
last couple of years.
I remember, maybe you
saw it, when C++ 14 was
ratified, you could
actually check the Clang
twitter live during the vote for the paper
to be integrated in C++ 14.
And, the tweet goes paper
this much is accepted,
and the next bit was oh
paper this much branch
merged into master.
So depending on the
compilers it goes faster
than maybe others, but you always have
this small lag between the time the thing
is acted and the time
the thing is available
on your computer.
And, for maybe most of us
that work with you know
this species of humans
that we call clients,
sometimes they have you know requirements
that we know make no sense,
but they are clients.
So we need to fit with whatever they want.
And, sometimes you cannot
deploy your new shiny tools,
build with the latest
whatever because they run
on a silly, aging platform
or computer, sorry,
of compilers versions.
So what are we actually losing?
And, that's the point,
I think, if you want
to use a stalk and slap
it on your manager's head
is you are losing a lot of things that can
actually be translated
later into cost reductions.
So code is simpler which
means it's probably smaller,
and if it's smaller,
it's probably far easier
to manage and maintain.
It's more expressive,
so the amount of errors
you can put in it because
you misinterpreted something,
or you miss write something
is less than usual.
And, if you make this
jump now and not in 2050
when the C++ 30 will
be you know like acted
while still compiling in C++ whatever.
You have this technical debt
that will be massively reduced.
And, to illustrate that I
picked a bunch of features
from like the C++ which
I think are interesting
both on the language
and on the library side.
And, just to make some kind of comparison
between a bunch of compilers.
So this is numbers I found
on the cppreference.com
website.
So if this wrong, well we can blame them,
and edit the wiki later but whatever.
So a bunch of things that
you probably saw already
if you went to Asa, Jason, or Kate talk
is the fold expressions, the constexpr if
and all the generic slash
variadic lambda functions.
That's three of the very
coolest things that C++
can now provide.
And, if you look at how they
got into different compilers,
you see there is a lot of
timing things between versions,
and some compilers still
doesn't support them altogether.
Whoever from Microsoft is
there, and this is wrong,
just tell me.
- [Audience Member] It's out already.
It's done.
- [Audience Member] Next release.
Okay next release, so 20
or 29 point something?
- [Audience Member] 19.5.
I have no idea what the name.
I will update that.
So that's something.
It's coming in.
Nobody is actually
slacking off, but you have
an interesting time
between the time it's gone.
And, same policy for the library version.
I tried to find some
information about std void T,
but I didn't find any.
So I think I saw Walter around there.
Do you know, Walter,
which version of GCC is
the first to get your support
for void T or something?
- [Walter] It's been well over a year,
two years maybe.
Okay so it's old.
Probably six something.
- [Walter] It's been there a long time.
Okay I will check that in.
So you got all these things.
But, what happened if you are stuck
with none of those versions?
When I submitted this talk, I make
the assumption that one
hour will be enough,
and then I thought about
the fact that if I want
to fit what I want to fit into this talk
in one hour, we have to
make some basic hypothesis
which are the fact that we will make
the hypothesis that you live in a world
where you have access to
C++ 11 on the databases.
If not, well send me an
email with your home address,
I will get some flowers
delivered, whatever,
because you're in a really,
really bad situation.
So let's say you have C++ 11 available,
and you really, really want
to play with the C++ 14 or 17
cool things and especially
the language features
because a lot of library
features from C++ 14 and 17,
you can find different version
of this already written
in library like Boost or the
Google thing we saw yesterday
or the day before yesterday.
So the library utility things
is more or less covered.
The language features is
what's probably missing.
So we tried to go over a
bunch of those features,
try to explain what they try to bring,
and can we actually make
something that look like
what they should be looking like
and try to understand how
many times you will be
spending doing this instead
of using the real thing.
And, we will be more specifically
targeting four things,
the polymorphic lambdas, fold expression,
and constexpr if which
are I think in my opinion
the main things that you
should be using right now.
And, we'll take a look
at integer sequence.
And, if you remember what
I say at the very beginning
of this talk that it would be a template
meta programming free
presentation, well I lied.
So let's go over that.
So polymorphic lambdas.
So I think everybody is
more of less familiar
with what the lambda function
or anonymous function
is since C++ 11.
It's this shiny, small,
anonymous block of code
that you can put into a
box and lay around and call
like it was a function
object whenever you want it
except instead of having to write
a huge amount of boiler plate.
You have this very terse syntax
which may or maybe not that
elegant, but that convey
exactly what this thing is.
You know it has this kind of parameters
which look like a function.
So is it working?
Oh yeah, fine.
So you have this thing that
looks like function parameters,
and then you have a block
in which you have the code
you want your function to be calling.
You can pass an arbitrary
number of captures
from outside.
So you can use function
derived from outside the lambda
inside it and so on, and so on.
It's very cool because this
notion of locally defined
function make a lot of code far more local
and especially in the case where you want
to use algorithms from
the standard library.
You don't really want to have a function
or a function object
lying you don't know where
that you will have to
instantiate it over there.
This slide is self contained.
And, you know right now that
you are calling this function
on each element of this
vector, and all the information
is there.
That's the very cool aspect of lambdas.
C++ 11 provided this version
of lambda in which the type
of parameters has to be concrete.
And, C++ 14 lift this by letting you have
polymorphic lambdas and variadic lambdas
which means you can
actually have something
that we basically behave
like a templated function
I mean a function object,
sorry, was a templated
function call operator which
can be variadic if you want.
And, instead of having
a huge mess of template
something, something around the lambda,
we decided to use this auto thing
which basically say I can be
of whatever type you want.
You can have any number of this auto,
and anything will resolve
to different types.
It's basically a templated
lambda without all the syntactic
crap you may have to work
which brings the lambda
up to the level of expressivity
of regular function.
Okay fine.
We can do this.
This is an example of variadic lambda.
No, no, no, sorry.
You can basically do
these dot, dot, dot things
like you would be doing
on normal functions.
This notation also gave
birth later to a proposal
to be able to write that
for regular function.
Yeah okay, fine.
What if I only have C++ 11?
Well sad.
You don't have many choice.
If you want to have a polymorphic,
slash, variadic lambdas
in C++ 11, you're basically down to write
a custom function object.
I mean no easy way to do that.
Well you can write it like
this, but this is actually
a bad approximation of what
the lambda was doing before,
and the real thing is far
more complicated because
what if I is of a type
that when you multiply
it by three, you get another types.
And, when you multiply
it by minus one, you get
another type which is not T.
So you may end up with something like this
where you use the truly
written types deduction
to get the things right.
So that's not something
you really want to write,
but that's all you have in this case.
So what's the pro and cons
are rather straightforward.
The pro is that the implementation is
rather straightforward.
It's basically what you
were writing in C++03.
The second point is that this
list of pro is rather short,
so I can go to the cons right now.
It breaks the locality of the code again.
99% of the appeal of lambdas function is
that you make everything
locally to your code type.
And, having to go back to
write the function object
somewhere, instantiate
it and so on, and so on,
makes everything awkward again.
But, if you really wanted
to completely generic lambda
function replacement,
you're stuck with that.
There is an interesting
cases which is the case
where what you really want to have is
not really a polymorphic
completely generic function
or lambda function.
Actually what you really want to have
is have your lambda function
work with a small subset
of different types that you know already,
but the only thing you can
write is actually write
this auto thing, so the
lambda capture whatever.
So there is an interesting techniques
that was proposed by David Brams ages ago
which I found rather interesting
but not that much used
everywhere which is to use
the fact that the lambda
when it get compiled
get turned somehow into a
function object structure,
and then a function object instance.
And, if you look at the
standard, it basically says
that these things actually is a structure.
It's a type.
It has an operator,
function call, and so on.
That means that you can use
it like any other structure.
And, the funny thing, for
example, is that you can
take a lambda as a struct
and build something out
of this type which it has a strange name.
It doesn't know what it is.
It doesn't know how to handle it.
But, you can write something like this.
So the structure takes two other types
which inherit from them.
And, you take two instance
of this F1 and F2 things,
and you just forward
them into your parents.
And you say okay now I want to use
the function operator of both
of them at the same time.
Fine.
What do we do with that?
Well you can write the function like this.
And, again that takes
two F1, F2, and builds
this poly of F1, F2,
and return you this bag
of things that happens to
aggregate those function
operators.
Which is to something
that starts to look like
a better approximation of a lambda.
So you can write something like this.
So you can say yeah I want
to build a local function
object, and I want that
if you pass me an int,
I will do something.
And, if you pass me a float,
I will do some other thing.
And, this thing is wrapped up into a type.
You don't really want to know what it is,
and you get your F.
So I put it into an F, but I could take
this written from poly
function and call it from,
sorry, from an algorithm or whatever.
And, it will basically
act correctly whatever
the value you pass there,
and it will just select
the proper overload.
It's like you build a
function that aggregate
an overload set into a box,
and you can use this box
afterwards.
And, the funny thing is
that there is nothing
in the definition of the
poly function that make
direct reference to the fact that F1 or F2
has to be a lambda,
something you cannot check
I think anyway.
It just wait for something
that behave like a function.
That's cool because the return of poly is
actually a function itself.
So you can make a second overload for poly
which is variadic one.
And, you say yeah if
you give me, oh sorry.
If you give me whatever
number of function things,
I will just you know recursively pack them
into a poly of poly of poly,
you know, and every level
of those poly things
would just repropigate
this operator function,
call up to the other one.
Which means that you can basically add
an arbitrary number of those overload sets
into this poly call and
get this lambda look alike
object which is defined
locally like a regular lambda.
It's not fully generic
'cause you have no way
to actually say and for
all the type do whatever.
But, you can actually
reuse this in the case
where you have a meaningful
set of type you want
to support into you polymorphic lambda.
So what happens if you want to use this?
So if you go through the fully specified
polymorphic lambda code
using the function object
and things, well it's
probably what you are
already writing because
you have no other option
especially for the poor lads around there
which is still stuck
in a pre-C++ 11 world.
It destroys the locality of the lambda
which is I think the worst
actual disadvantage of this.
And, you will need a non trivial amount
of rewrite when you
want to switch from this
to an actual lambda.
But, this rewrite is cool because you are
removing code.
And, removing code is
a thing you want to do
anyway when you refactor, so that's fine.
And, as for the poly solutions,
as we have this locality
back, we can actually use
this in a more open
ended way, and the impact
on the rewrite will be a bit less.
But, the question is what if your coworker
comes around and provide
you with this piece of code,
I mean the poly structure
and the two variant
of the poly function.
Question is how big is
your developer group's
reluctance to let that pass.
A code review would be
integrated into your actual
production code.
That's the main issue with these fixes,
you need to convince
the people that we work
with that it works, it
do what they want to do,
okay and they can put it
to a box and sleep on it.
That's the main issue with
these kinds of things.
It may make a bunch of
people uncomfortable
especially because it
looks like it doesn't do
anything, yet it does something.
And, you have probably a bunch of work
about explaining what this thing is doing.
Okay now, let's have a
look at fold expression.
So fold expression is based on the fact
that variadic template
by introducing this dot,
dot, dot code expander made a lot of code
far more easier to write.
So the dot, dot, dot
thing which can be used
as the declaration of a variadic pack
is also the syntax for expanding this pack
into something.
And, usually what you have to do is
although you can express
your variadic code
into something, you can expand naturally
which every element of the pack will be
expanded one after the
other separated by comma,
or you're stuck in writing
something that looks
like a recursive descent
of other structure
of the variadic pack.
So these glues things is
actually very interesting,
but what if we can't or
don't want to use this comma
gluing things.
Or, if the recursive descent
of the structure of the pack
is so bad that it start
affecting compile time.
And, fold expression was
a way to try to solve
these expressiveness issues.
So you can actually use dot, dot, dot
on a lot of binary operators
on the left, on the right
with the proper semantics that it means,
with the proper default
values that it requires.
And, so for example, if you want to write
a simple old function that takes
a bunch of arguments and
tries to logically end
them all togethers, well
it's basically a one liner
using fold expression which is very cool.
And, you can just all
your all function on that,
and this dot, dot, dot and
args just expand to that.
And, that's exactly what you want.
Okay fine.
What can I do if I don't
have fold expression?
Well first reflect that
a lot of people have
when they try to deal with variadic pack,
which is wrong, is to
say yeah I'll just use
this recursive version that
means that I can do something
like this.
I have a terminal case.
That means that if I call
all on a single parameters,
it just return whatever this thing is.
And, if I have more than one,
it's probably that I have
one and a bunch of others,
this is a traditional
structural head and tail separation.
And, I will say that it's
the add and the result
of all applied to the tail.
Of course, this probably requires a bunch
of universal referents
and forwarding and whatnot
just for the sake of the example.
It works.
But, it has a slightly side
effect which in some places
can be an issue.
Is how many actual function
is getting compiled
by the compiler?
You get one for each step
into the recursive descent
plus the terminal cases.
If you call this function
on a regular amount
of values, it probably won't
register on your radar,
but that's something that may
cause an increasing compile
time, and sometimes it's the basic culprit
of this technique.
A funny thing is that
at some point, I think
it was around 2014 or
something I don't remember,
quite awhile ago, this
thing popped up on Twitter.
So I don't remember the
exact order, but I know
that Eric Niebler and Sean Parent
and a bunch of others was involved,
and they basically slapped this content
to the face of one anothers.
And, the question was can
I write a value function
that takes an arbitrary
number of arguments
and a function object, and I want to apply
this function to all
my variadic arguments,
and I don't want to do that recursively.
Which bring us to the
six foot long things.
So does everybody
understand what's going on?
Me neither.
So let's go over it.
So what does it do?
It plays on the fact that dot, dot, dot
as a code expander
generate things separated
by comma in a very limited
subset of contexts.
One of these contexts is whenever you want
to build an array or you want to build
initializer list.
So what this thing does is
for every A in the pack,
okay I'm forwarding it, and I'm passing it
to F, and this function will process my A.
It will return whatever.
I don't care.
And, just to be sure it
doesn't blow the world up,
I will just ignore, I will
just void this result.
And, I will go over the other one.
But, initializer list
wait for a single type
of value to store.
So to be sure we end up in
cases where every element
after the expansion of
the pack is something
that initializer list can
int, we use the comma operator
to say yeah do that and just return zero
with the proper number of parents and void
and things so everybody's happy.
So what we're doing
there is calling F on A,
triggering whatever this means, okay,
and putting a zero into
this initializer list.
And, we do that for every
element in the parameter packs.
And, then we have this
comma F which is just there,
so we can actually return
a copy of the old general
object function just in
case this function object
has a state that needs to
be maintained and returned.
So that's probably one of the thing
you want to put into a box and sit on it
and never open it again, but it works.
And, so that's basically generator call
which is if you have A one, A two, A four,
it basically do F of A one, F of A two,
F of A three, up, up, up,
and you will probably just
you know ignore everything.
You will just stay there
with the proper number
of function calls 'cause that's cool.
So that's the generic application.
And, so we can actually use these tricks
of using the expansion into
a list of comma separated
things of dot, dot, dot
to do whatever we want
as long as we find a
way to put it in the box
that is about to support it.
So one way to write this all
function that we saw earlier
could be this.
So we have a result which
is true, and then we do
this initializer list
of thing in which we say
that we update result with
result and the current value
in the pack for every pack.
And, as this thing is a
bool, I don't have to do
the comma zero whatever.
I can just store that into
initializer list of bool,
and it's okay.
Okay do you have any issues with this?
I mean will it work?
Do we have an issue with
ordering the evaluation
of all the sub parts?
(audience member responding)
Sorry?
- [Audience Member] Evaluation order.
Yeah, you have the
initializer list on order,
but does it pose any problems there?
- [Audience Member] Just slower then.
Yeah it's probably
slower than it should be
'cause we want short (muttering).
But, it works.
And, comes the refactoring brigade
that probably says that you
can rewrite it this way.
You know by reusing the for each arg thing
by passing the lambdas
that do the correct thing
on the results and you
know passing all the A.
Both version are probably as correct.
I like this one because
you don't have to know
about the initializer
list fiasco whatever.
You can just put that
into the for each args box
and call it a day.
But, what's the impact on the code?
So the recursive definition would create
a purposeless amount of
function specialization
you don't really want to see.
And, the compile time may be a problem.
For the for each arg,
that's actually far easier
because you can keep
the exact same interface
for this function.
It will have one function
with no cooky specialization.
And, you can actually
abstract away this notion
of I'm just repeating
something over all the element
of a pack of things which
is actually far better
because we can now build things on top
of this abstraction.
So next thing is constexpr if.
So constexpr if basically
allow us to write code
that can depend on the
compile time condition.
And, this show that we will
only compile the branch
of the if that makes sense with respect
to the compile time condition
which help you write
code where you can make
decision about arbitrary threads
or arbitrary integral
constant and write code
that may depend on the
existence of an interface
or whatever without having
your compiler to blow up.
It helps you to refactoring a lot of code
that use techniques like
SFINAE in a bad way.
It open up for a bunch of
optimization opportunities.
And, you cannot just use
regular if with static threads
because if will compile
both branch anyway,
and we will be trapped.
So what you can do is
for example you can have
a type T copying up, and
if this type supports
some interface, well then
T will make you a sandwich,
and if not, you just return T.
Of course, if you call
that with a type which has
this make me a sandwich
interface, it will compile
the first one and then no problem.
And, if you pass an int or whatever,
it will only compile the second
branch and call it a day.
If you are trying this
with regular if by thinking
that the compiler will elude the fact
that the constant is always true or false,
it won't work because both
branch will be compiled.
So what happens if you want to do this
without constexper if?
Well you can do what every people did
before which is SFINAE
by enable the thread
by forcibly generate a
valid and invalid function
definition depending on the const, sorry,
the condition and the function contains
whatever branch of your if.
It's a bit complex to handle.
As soon as the condition starts
to be complex themselves.
It can be a very tangled
web of yes, no, no, no, yes,
you know things.
And, the problem is you're
not sure that everything
is correct until you
tested all the combination,
and you catch all the
cases that were ambiguous.
Moreover, as compile time, which is linear
with the number of alternatives
because before selecting
the correct one, the compiler will have
to generate everything and try to resolve
the overloads.
So another way to do this
is to use tag dispatching
which is basically integrate the selection
into the function overloading
itself turning that
into a compile time which is constant time
and makes the things a bit simpler because
you don't have to deal with this enable if
fiasco, you can just list
every cases you want to support
and have a way to select the
correct one in one scope.
Those two things are
a bit more complicated
than they should be
because they require you
to write a unusual amount of functions,
but that's basically what you need to do.
So we just waggle our
magic wand for awhile
and turn this into, well,
something a bit better.
So the idea is to look at
what constexpr if is doing.
Constexpr if take the
condition at compile time
and select between code fragments.
And, this fragment has to
be compiled conditionally.
So the idea is to say that
we have tool to generate
code fragments that's lambda function.
And, so we can basically
take lambda functions,
SFINAE or tag dispatching,
smash 'em together
and have a nice approximation
of constexpr if.
This notion of lambda
being a code fragment
that you can carry around I
mean it's a talk in itself.
It opens a lot of techniques
which are very interesting.
But, let's focus on that.
So what can we do?
Well let's take the
code we had just before
and look at what we can do.
So I will start from there.
So we have this constexpr
if thing which is
now a function that takes
two things T and the F,
the true and the false
cases and takes something
which is a type there C
which contains the condition.
And, what you do is you pass
that to a select function,
and the select function
use SFINAE to select
which version of the function it would be.
So if the condition is true, I would take
the path of the function
that return me the true
value T, and if not, I
will get a false one.
And, once I got that,
I make the assumption
that this T and F are
actually function object
that take no parameters
on their function call,
and I just call them directly,
and I basically execute
one true or false branches.
So you can use it this way.
So you can constexpr if
on the fact that it stays
integral if yes, it
would be nice to generate
these two codes, this code.
And, if not, you would
call the second one.
Well fine, except this
code is half of what
constexpr if should be.
Do you see why?
- [Audience Member] You
wouldn't be able to compile
if the T thing.
Yeah so now imagine that
instead of just printing things,
I put back the return T, and the return T
make me a sandwich.
And, I pass an integer, I
will get a compiler error
because the lambda compile on the spot
before being passed to the whatever.
Well, sad.
So what can you do?
You could actually make it so you have
to wait before compiling your lambdas.
So that move you from C++ 11 to C++ 14
because you will need
actual polymorphic lambdas.
But, one way to solve the problem,
there is a bunch of others.
If you didn't saw it
already, I will advise you
to have a look Vittorio
Romero's talks last year
about static code selection talk
which is another take at this issue
which is very interesting.
So what do we do?
Well we just make a small adjustment
to our code by saying that constexpr if
calls lambda selected
by the select function
and pass it something,
whatever we don't care.
But, this whatever has to
be from a dependent type.
So for example, you can
just pass an instant
of the condition types.
And, what you do is
that your lambdas there,
well they now take a polymorphic argument
which is anonymous because you don't care
about the value of these things.
It just there so this lambda is turning
to a template function,
object function call,
and it won't get compiled
until one or the other
gets selected.
So it's a bit
counterintuitive, but it gives
you exactly what you want.
So this is another example, but if these
are arithmetic, I consider that I have
one element inside, and
if not I will just try
to call size on it, and I will
print the size of the thing.
You can actually combine
that with whatever kind
of thread you want.
And, you basically are
where constexpr if is.
It's not that ugly as soon
as you put everything we saw
before in the box.
It looks like you know
the thing will be working.
Now that I think of it, I should've called
this thing if, and this call constexpr
because the migration
task could've been easier.
So basically, this.
If you want to turn that
into an actual constexpr if
later, just have to view
in the scroll somewhere
put parentheses on it and replace
the function call things by
brackets and you're done.
So well you have that, and you have
this explicit SFINAE,
tag dispatching things
which could be cool because
you probably already wrote
that already because you
have no other way to do it.
But, as I say, it require
a huge amount of functions
and function helpers and
specialization and what not.
It makes the code unnecessarily big,
and makes the refactoring effort
as much as large afterwards.
There's more emulation
to the rapid selection
into a box is actually better.
You can actually make
it as close as possible
as a constexpr if syntax, and
you want Vittorio's versions
use square brackets and
a dot notation to do
both branches which is quite cool.
I mean you can work around the elegance
and the you know syntax
issue there was a thing,
and it's done.
But, you will need
polymorphic lambda support
if you want to be
completely workable compared
to constexpr if.
So now what's left?
Well we have integer sequence.
So integer sequence is a strange beast
which come to help you
write very template based
code in a way so it doesn't look strange.
So the idea is to have a
type which is basically
a box of variadic number of integers
of whatever type you want and so on.
And, this integer sequence
basically contains
what you like, one, two,
three, four, five, six,
I mean in an order or
with a step, whatever.
And, one of the use cases to be able to do
something like this.
So this apply function take
a function and a tuple,
and if we basically take
every element in the tuple
and pass it to the function as argument
which is something that
cannot be solved properly
by just using the recursive
nature of the pack
because there is no way
you can recursively call
the function with something
and then something else.
It won't work.
So the idea is to do this.
So you pass the function,
you pass the tuple,
and you call this make
index sequence things
that takes the size of the
tuple as the parameters
and returns something
which looks like this,
this index sequence of I dot, dot, dot.
And, these things if
your tuple like let's say
has five element, you
will end up with an index
sequence of zero, one, two, three, four
which happens to be the
static index you require
to get access to the zero,
one, two, three, fourth
element of the tuple.
And, so what you do is
you just call std get on I
on the tuple, and you
unpack that for every I
in the integer sequence variadic pack.
And, so you end up with
F of get zero, get one,
get two, get three, get four.
So that's a very cool
tool because you can write
things like this.
You can do the other one
which is actually calling F
on every element of the
tuple and rebuilding a tuple
afterward.
I mean you can do all
of this and much more.
Well a problem is that's a C++ 14 feature
if I'm not mistaken, yeah it is.
And doesn't look like
that easy to emulate.
Well in fact it is.
It's not that big burden.
So what you want to
have is you want to have
this int sequence which
is just this variadic pack
of integers, and the idea
is to say that if I want
to have a sequence of integer
which is zero, one, two,
three, you can basically
say it's a sequence
which is zero, one, and a
sequence which is two and three
that I just concatenate.
And, zero, one, is itself
a sequence of zero and one
that I concatenate, so you
will recursively concatenate
numbers until you get your full sequence.
So what you need to have is
this what we call range cat
meta function that takes well two types
which are the two integer
sequence you want to merge
and the stop point which will be the value
you want to add to the other one.
And, so if you have two
integer sequence full of I
and full of J, you can
get one which is all the I
and all the J just slided
by the value of start.
And, you can just capture that this way.
And, so it's bit funky
because we keep telling people
that you know you need to
have your variadic parameter
pack at the end, and you
cannot have multiple of them
which is exactly not what I do there.
'Cause what is important there
is what the range cat type
definition wants.
It just wants two types and an integer.
There is not variadic upstairs.
There you reuse variadic pack just to be
a boat to construct the
specialization of rance cat.
So we don't care that we
have two sequence of int
because to combine it
with property know where
they are into the type, the
first and the second one.
And, so we can do this and just collapse
everything into a single integer sequence.
So now that we have that, what do we do?
Well we need to compute these things.
So we have this case where if you tell me
to make an integer sequence of nothing,
I will just give you an
integer sequence of nothing.
If you want to have an
integer sequence of one value
starting from start, I
will just give you start
into an integer sequence.
And, if you are more than
one, well I will take
your sequence, and I will
basically ask you to generate
the first and the second
half and concatenating them
starting with the middle
of your sequence size
which is basically what happened there.
And, so we recursively
do this until we end up
to zero and one and every value
just you know concatenates.
And, once we have that, what you can do,
we can make a small template, so you can
have something which is
far easier to manipulate.
Well it looks like I'm
just doing something
I just tell you to now
do which is use recursion
over variadic packs.
There is no other way to do it this way,
or if you have one,
I'm very open to see it
because it's complicated.
But, is it really bad?
For a given N, for a give
size of integer sequence,
how many types do I need to generate?
I mean we keep cutting things in two
in some kind of a tree orders that smell
like a logarithmic number
of things which is okay.
Well good thing is these kinds of tools,
I mean you can find
libraries with implementation
of that in it.
You can look at NP 11 or Brigand, Fargo.
You actually not have to write that.
The same way you don't have to replicate
the new algorithm or what not.
I mean there is probably
a library somewhere
that already implements that.
So as a conclusion about all of this,
you can reason non
negligible amount of effort,
but not that a big one in some cases.
You can replicate a bunch
of non trivial language
features from C++ 17 into
the other language version.
Now the question is should you do it,
or should your effort be
into this you know like
finding a new job or lobbying you know?
One of the things we want to choose there
is that yeah you can do it.
You can actually assess
how big the effort could be
depending on your familiarity
with the actual language
and what not.
Now what I will probably want
you to do is probably take
these things, and if you're
stuck with this kind of thing
just reuse these tricks, or
use them to actually show
okay this is all the crap I need to do
to make my thing work right now.
And, it's probably better
if you spend this effort
changing our compiler version
or our compiler altogether.
It's probably better for you to pursue
your whatever year AP
or whatever boss to make
the change.
Or, in the case of our very
you know nice customers,
try to put some sense into
their requirements if you can.
And, try to actually use these things
as point where you can
actually say okay this is
what it will cost me,
and I don't really want
to do that because this
effort should be put
somewhere else.
There is a lot of other language features
we could have gone over.
A bunch of them are actually
out of whatever emulation
things you can do.
For people that are
looking at C++ 17 and 20
and things like concepts and so on,
you can have a look at
things like, for example,
the range retrieve implementation.
You can find a good
emulation of concept inside
which is actually a beast in itself.
And, as long as these language features
starts to be more and
more you know ingrained
into the very language itself, it will be
complicated to get this
emulation working anywhere.
So at some point, you will
have to bite the bullet
and jump over whatever version you need.
And, the other thing
that we usually detail
to our customers or our
other company we work with is
don't do an incremental job.
So there's no need to go to
whatever 11 or from 11 to 14.
Go to where you are and
go as far as you can
into the support of the
language version you can
because if not, you are
just delaying the inevitable
and just adding cost and adding efforts.
So thank you for your
attention, and if you have
any question, I will gladly answer them.
Thank you.
(audience clapping)
That's okay for me you know.
(laughing)
Yeah go on.
- [Audience Member] Hi.
I'm Kuress Adu.
(muttering) iterations
was standard library.
Implementation is not up to date
and how to you know
work around that maybe.
Okay so the question is did we cut out
the cases where the standard library
was not up to date with whatever we did?
That's what you said?
- [Audience Member] Yeah more specifically
not like missing whole components.
So signature differs a little bit.
Okay the right missing components
or completely missing
a point implementation.
Yeah it happened to us a bunch of time
where the compiler is happily
claiming it's let's say
C++ 14 compliant except for these bunch
of standard library components which were
actually the things we wanted to use.
In this case, what we tried to do
is we tried to find a way
if the compiler permits
to tell him to okay what about using
this version of the standard library.
That may or may not work.
And, depending on the
compiler, it could be
defaulting itself to get
there because it's probably
something which is not very documented
or at least publicized in a proper way.
In the other case, what
we will end up doing is
I mean go and look at the
implementation of what
we were missing into another compiler
and re-implement it.
It happened to us at some point because,
I don't remember exactly what happened,
but one of the version of our compiler
has a badly implemented
version of integer constant
which I see doesn't understand how you can
actually botch implementing
integer constant,
but whatever.
And, basically there were
no conversion operator
to the integer types that the
integer constant was owning
which is something you
need to have everywhere.
So you cannot just take
an integer constant
and pass it to a function
waiting for actual integers.
So in this case, I mean
the cost of re-implementing
integer constants was
basically nothing because
it's a very small component,
so we just rewrote it.
We ended up with a sub
optimal implementation
of standard components especially
algorithm in other cases
because we are trapped
between two minor version
of a compiler.
And, what happened is the
patch of this compiler
was not coming out fast
enough for what we would
need to do.
And, we ended up trying to change
the standard library
that would support it.
Whenever this happens, I
think the best solution
is to try to I mean assess the complexity
of the component you need to support
and only rewrite it if
it's something trivial
that you know that you can write properly.
And, if not write, find a
way to make your compiler,
you know use another std
version which may or may not
be easy, or try to you
know bypass the issues
by trying to upgrade.
But, sometimes you can't.
Okay usually once that's
happened, you're in for some kind
of re-implementation anyway.
- [Audience Member] Are you
aware of the Open Source
libraries that offer me
standard abstractions,
or do we have to build ourselves.
So the question is is
there actual libraries
that provide these things.
Yeah, there is a bunch.
For example, if I take
the fold expressions,
the for each arguments have been published
a lot of times and that's
probably your best way
is to actually just write
something that looks like this.
For things like integer
sequence or for example
these polymorphic lambdas look alike,
I mean you have a bunch of
modern manipulator libraries
that happens to do all this
crazy type manipulation
thing and then things like
that because they needed
to interface with basic
non types based code,
and so you make something like this.
I don't have any name right now,
but I know that I found
some implementation of that
somewhere, and for the
rest, I mean try to look
at what Boost offers or things like,
the name of this thing, this
Google thing we heard about.
I mean you probably have
half a dozen of such library
out in the open with
different number of coverage.
That's something which is not very, I mean
it exists.
It's not very easy to find them,
but a lot of times, they're
not that much publicized
because most of the time,
you have lots of people
that can just jump over and don't care
about having this legacy
library to make the thing.
Mathieu weren't you working
on something like that
at some point?
Or, do you have that internally,
this kind of library that you know plugs
the old into the standards?
Was it you or somebody else?
I don't remember.
- [Mathieu] Sorry what?
A kind of library that
do all this plumbing
to uniformizing--
[Mathieu] Like the implementation--
Yeah of whatever.
- [Mathieu] Yeah we have
something like that internally.
So usually people do it internally.
That mostly what I saw
because it's either, I mean
most of the time people just
need these couple of features,
and they think, and sometimes
they're right that it's
better to just write them
because it's straightforward.
Another thing is that, for
example for the fold expression
emulation, you may end up
having to write something
that work on this principle
of making dot, dot, dot
do whatever you want for
the very explicit cases
you are dealing with right now instead
of just you know grabbing a generic backer
and trying to fit your stuff in it.
And, you may end up with better
code generation at the end.
But, if you dig around,
I think you will find
a bunch of that.
But, I mean they are not that publicized.
- [Audience Member] I have
one remark and one question.
For the fold expressions,
I think last year
Roland Block gave an
interesting lighting talk
about, Roland Block from
the SQL PP, lighting talk
on how to develop fold expressions
for getting the truth from all condition.
I think some of them were
easier than the one shown.
Oh yeah, probably.
I think you have a bunch
of other way to do that.
I tend to prefer the
variadic expander versions
for compile time reason,
but I maybe biased
about compile time.
So probably not a big
deal for most people.
I think you can probably do it in a bunch
of other way.
I have to watch this lightning talk
because it completely went under my radar.
So good point.
I can think of about one or two other way
to do this.
Now I think in the end
it will probably generate
very similar code anyway.
So it's probably more than
personal style preferences
or whatever.
- [Audience Member] Okay, and my question
was about the flowers.
Do you have like a form on the internet
where I can put my address,
or how do we work this out?
(laughing)
You send me a message on Twitter,
and we can arrange the flower thing.
- [Audience Member] Maybe
a hashtag or something.
Okay.
Thank you.
So thank you very much.
(audience clapping)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>