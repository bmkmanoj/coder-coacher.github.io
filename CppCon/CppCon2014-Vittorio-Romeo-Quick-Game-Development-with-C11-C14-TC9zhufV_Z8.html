<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon2014: Vittorio Romeo &quot;Quick Game Development with C++11 / C++14&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon2014: Vittorio Romeo &quot;Quick Game Development with C++11 / C++14&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon2014: Vittorio Romeo &quot;Quick Game Development with C++11 / C++14&quot;</b></h2><h5 class="post__date">2014-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TC9zhufV_Z8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to quick game development
with service plus 11 and 14 again thank
you for coming before we begin I like to
introduce myself my name is vittorio
mell I'm a computer science student at
the University of Messina and I've
learned the programming in C++ as
another day that my interest cover
software development gaming and game
development and also something really
passionate about is sharing my knowledge
I've created several video tutorials and
articles and open source code bases that
I like to share with people to help them
learn new things so about this talk
we're gonna I'm gonna divide this work
in two parts in the first part we'll
talk briefly about game development why
I think everyone we should try at least
once game development and why use C++
and why use the latest standards and in
the second part and I'm going to try
something a little different I'm going
to have a live coding part with several
code segments that I've prepared and
we're going to walk through all those
code segments and compile them and show
you the process of the creation of a
simple video game so what I want to
achieve achieve with this talk is
basically encouraging everyone to try
out game development and demonstrating
how easy it is nowadays with the newest
standards and the libraries that are
available for free again the moment is
what I like to call an all-around
development experience so how many of
you have tried game development in the
past nice so it's about more than 50% so
I call it a an all-around game
development experience because game
development involves the programmer with
a lot of stuff so if you're making a
game alone you'll have to take care not
only of the code and the implementation
with also the design and the creation of
the resources if you are in a team
you'll have to interact with people that
work on other kind of great creative
resources like graphics musics and
sounds and also you always learn new
things
by developing games like techniques for
networking physics and so on it really
involves a lot of different subjects and
also one reason that I didn't write but
I think is very important is that game
development is fine you see you make a
change in the code and you get instant
feedback and also if your game is fun
your concept is fun you you will enjoy
developing it and playing it so why C++
for game development this is a subject
that's been covered a lot in the past
but I believe that the most important
reasons are efficiency in fact suppose
plus as we all know allows us to create
zero cost abstractions and that's very
important because performance is one of
the key of one of the keys for a good
game also syllabus it is really portable
you can target a lot of different
architectures and most of the time you
don't you don't even need to change your
code and super spaz is also widespread
and by that I mean that there are a lot
of libraries and resources available
that can help the programmer with the
their game so why use C++ 11 and 14 for
game development all of these features
have been covered a lot in the past so
I'll try to show you some real-life
examples that I actually used in my own
game my own games for example lambdas
variadic templates and deckle type were
really useful in the creation of factory
functions like for different types of
enemies or for call bats I've used them
in my collision engine so that when a
collision happened a lambda would I mean
a full fire lambda and there would be an
interaction between two entities then
there is a very important thing that is
made much easier thanks to the new
standards in this memory management
which unique pointer it's very easy to
manage the lifetime of entities with
char pointer I manage the lifetime of
resources very easily because we can
share resources between different parts
of code and also something that I rarely
hear about too is offset
which was introduced in c99 and it's now
standard in C++ with suppose 11 and they
used that in an entity management system
to basically allocate some more bytes
for every entity and get a boolean flag
to decide whether or not the entity had
to be destroyed also there is a
fantastic header that was introduced
against it was plus 11 which is chrono
and they've used it frequently for game
loop timing and getting the frame rate
right all of the other features that I
didn't cover are extremely useful
extremely convenient but as I really
said they have already been talked about
a lot in the past so I'll just go
forward so let's get started our goal is
creating an arc another breakout clone
from scratch and step-by-step I'll
demonstrate how easy it is to create it
and the end result would be around 200
and 300 lines of code so the compiler
we're going to use requires obviously
C++ 11 support but since we're going to
use some seamstress 14 features such as
generic lambdas we need a co-sponsor 14
compliant compiler and my compiler of
choice is clang which is which fully
supports this plus 14 standard but c++
4.9 also supports all the features which
we going to use in this talk as for
external resources we're going to use
the SML library which is a very simple
and fast library for interfacing with
the input system the audio system in the
graphical system and it makes rendering
sprites and 2d objects to the to the
screen very easy it also manages the
windows and mouse and keyboard so it's a
very useable library and if you want to
you can follow this talk on your own
laptop you can download all the code and
slides on that little page and the
library is available on that website and
almost package managers if you are
losing a Linux distribution so now I'm
going to switch to the code
and during the code explanation
I will also switch back to the to the
slides to show you some diagrams so the
first thing to notice is I have a simple
compiled script that basically links SF
ml and starts immediately the executable
we compile it's very easy and let's
begin the development so I'm going to
start with the creation of a simple
empty window the first thing we are
going to need is the inclusion of the
SML graphics adder which includes all
common STD classes such as vector and so
on and also the modules required for the
window management I defined some
constants here for the width and the
height of the window by using the
constable keyword to make clear that
these are not going to change and in the
main method I I create a window by using
the SF render window class which is
basically a class that allows you to
draw graphics on it it takes in the
constructor a vector su parameter which
is a vector in the mathematical sense of
two unsigned integers and these are the
sides of the window and also a title for
the window next something important is
setting a frame rate limit so that we
can make sure our game will run at the
same speed on every on every
architecture this is I mean it's an AK
there are many better ways to do this
but for the scope assist of these
toolkits it's appropriate next we're
going to create the game loop for those
that are not familiar with game
development basically the game loop is
what allows the game to continuously run
and I mean it's the core of the game it
is composed of three phases usually the
first phase is getting the input from
the keyboard or the mouse the second
phase is updating the game logic such as
the entities and the third phase is
drawing the game entities on the screen
so this kind of loop is very easy to
implement we just use a while true and
in the first step we clear the window by
removing all the graphics that were
displayed in the previous frame and then
we check using s FML if the escape phase
is pressed and this is the input part of
our loop if the K is the key is pressed
we just break out of the loop and stop
the program and another reporting is
calling display on the window object so
that we can show the windows contents I
wanted to tell you that if you have any
question about the code I'm happy to
answer them and also if I'm going too
fast or too slow please tell me yes yeah
so the question was is there any use any
advantage in using the SML event class
so as well as another way to gather
input which are events basically you use
a look to query all the events that are
coming from the operating system to the
window and it can be used to manage
input so the difference is that Evans I
mean you can do the same thing with
events and global objects and there are
little more verbose but also more
flexible but for this cup of the talk we
will simply use the global objects so
it's a convenience factor so let's let's
close some terminals and compile the
first segment so as you can see we have
a blank window and we can close it by
pressing escape not very interesting
let's move on so in the second segment
we'll actually create our first game
entity which will be the ball so I'm
going to use classes obviously to
represent every single game entity type
and in the ball class I begin by
defining some public constants using
always context work possible and I'll
the first constant will be the default
color of the ball the second cost and
the default radius and the third
constants the default velocity so SML
officers the possibility to render
simple shapes such as
bangles and shine circles and convex
polygons with the shape glasses so I
simply have a field called shape of type
circle shape and by setting the radius
the color and the sides of the shape I
can simply render it on the window and
make it move so it's it also stores the
position another thing we're going to
need is a vector of floats which will
hold the current velocity of the ball so
that we can alter its direction and
speed the constructor will simply take
the starting coordinates of the ball
that will usually be in the center of
the screen and here we will simply set
the shapes position shapes radius the
color of the shape and the origin which
is basically the point from where we
will move the ball I have another
diagram which is very simple but this is
the coordinate system of s/m m/l
it is different from other libraries
such as OpenGL as they use the origin in
the center as FML uses the origin in the
top left corner of the window so let's
start thinking about the design of our
game every single game entity type will
have two methods that will be update and
roll this is a very basic design for a
game and in the update method we will
simply move the ball s/m m/l
offers us a move method on the shape
that will take a velocity vector and
continuously add it to the position
vector during the frames I have another
diagram for that very simple again every
update the velocity vector will be added
to the position of the ball and during
the time it will look like the ball is
moving it's very simple in the draw
method we will actually take a reference
parameter to a render window that will
be the target where we're going to draw
the object and we're simply going to ask
the target to drop the objects they
orbit sorry the object on it for us we
also have to initialize the default
color data member outside of the class
because of the link of the language so
in the main function we create an
instance of the ball and in the
constructor with us the center of the
window
and now in the game loop we have to call
the update and the draw method of the
ball so basically this line is the
update phase of our game and this in
this other line is the draw phase of
your game well we have everything that
we need so we can compile and test out
this segment so as you can see we have a
moving ball on the screen but
unfortunately it goes out of the window
we need to find a way to prevent that
and we'll do that in the third code
segment so the problem that we're facing
here is that when a ball is going out of
the window we need to make it bounce so
first of all we need to check whether
the ball is going out of the window in
any in what direction to do that it's a
very simple comparison between the right
bound of the ball and the width of the
window to get the right bound of the
ball we simply add the radius of the
ball to the x coordinate with it which
is in the center and we check if it is
greater than the width of the window and
the same idea can be applied for every
single other direction so the
implementation is very simple to begin
we need some Gators that will help us
get the different bounds of the ball
because we're going to use those very
frequently so we can get the X Y
coordinates the left right and top to
bottom
I mean bounce so they all of these
methods are constant and except because
they are very simple and they're likely
to get in line and optimize with the
compiler in the update method we
basically need to get to keep the ball
inside the window and the best way of
doing this and dealing with any kind of
collision detection and respond and
response is moving the object regardless
then if they object collided or went out
of the window solve that so we always
move the object regardless and then
solve the collision and so after moving
the ball we can find ourselves in four
different situations either the left
bound of the ball left the window so the
left
the left coordinate is lower than zero
so we need to make the ball bounce or
it's until it over the right and to do
that we set the X component of the
velocity vector to a positive value or
it's going out to the right and we set
the x value to a negative value or we
have the situation what is going out
vertically and it is the same exact idea
and the rest of the code is completely
the same so let's compile and try it out
as you can see the ball now bounces and
doesn't go outside the window so it's
it's working
in the Ford Focus code segment will
actually help the paddle which is the
little rectangle that the player will
control and to do that we create a new
class like we did for the ball and call
it paddle we have some constants here
that have the default with eight and
velocity and I also have a different
kind of shape here which is rectangle
shape not circle shape anymore and the
interface is almost the same there are
some differences because obviously there
is not a radius but there is a width and
height so you have to change some lines
in the constructor but it's very easy
and straightforward so the in the update
method of the paddle will call another
function that will process the player
input and this function will alter the
velocity vector based on what the player
splashing so if I'm pressing the right
arrow key it will set the velocity
vector as X component to a positive
value and then after coming out of that
function we will move the shape with the
new velocity vector so this is the
process player input function that we're
going to call in the update method it's
very simple basically we query the state
of the keyboard and we check if the left
key is being pressed also we need to
make sure that the paddle won't go out
of the window either to the left or to
the right so with the we will only move
it to the left if it's inside the window
to the left
I always clear basically we check if the
left coordinate of the paddle is inside
the window and if it is
we move it to the left otherwise we do
nothing in them which I call so the
right arrow key and the right direction
of movement and if no arrow keys are
pressed we set the velocity to zero to
stop the movement of the bottle in the
main function we do the same as we did
for the ball we create a bubble incense
and this time is not in the center of
the window but it's a little higher than
the bottom corner of the window and in
the in the game loop we update the
puzzle of the ball and draw it so it's
it's the same design as we did for the
ball let's compile and throw it out so
as you can see we have this rectangle
that I can move with the left and right
arrow keys and it cannot go outside of
the window because of our checks but
there is no interaction between the
rectangle and the ball as you can see so
we need to fix that so in this code
segment we'll actually deal with the
interactions between the ball and the
paddle the first thing we have to do is
create a generic function that helps us
understand when two objects are
intersecting as you may have noticed I'm
using a rectangle collision bound even
for the ball because for the scope of
this game it's okay it's not going to be
noticeable and we're gonna do a test
that's called a a BB versus ia BB I have
a diagram for that so a a BB stands for
axis aligned bounding box and it's
basically a rectangle and we can check
if two AAA BBS are overlapping by doing
some calculations and some volume I mean
some boolean ends on their values so we
basically calculate a vertical overlap
and a horizontal overlap by subtracting
the the opposite x and y bounds like we
subtract the first objects right bound
from the second objects left bound and
the same for the vertical bounds and if
there is a positive value in both of the
of horizontal and vertical overlap it
means that the objects are actually
colliding and so in the code this looks
like this we simply check that the dis
sorry this is the horizontal overlap and
this is the vertical overlap as you can
see we have three end that changes
together so if all of this condition are
valid the objects are intersecting I
hope that's clear so we also need
another function that I will call in the
update phase of our game loop that will
actually check if the paddle and the
ball are colliding and if they are it
will try to resolve the collision in a
realistic manner so this function takes
a constant paddle parameter because we
are not going to alter anything about
the paddle and it will it also takes a
reference to a ball and it's not Const
because we're going to make the ball
bounce so we need to call to change its
velocity we begin by checking if these
two objects are intersecting if they are
not intersecting we simply go out of the
function otherwise we simply set the
balls velocity to a negative value on
the y coordinate so that it bounces
towards the top of the window then we
have to do something a little more
interesting so in this kind of games
the collision between the ball and the
paddle is very important and the player
usually expects that if the the ball is
as it the paddle on the right side it
will bounce to the right so to do that
we simply check whether the ball eat the
paddle to the right of its center to the
left of the center and make it bounce in
that direction it's very simple we check
basically if the center of the ball was
lower than the center of the paddle and
based on that we change the velocity
either to a negative or to a positive
one and in the game loop it's almost the
same we just add this function that is
called every frame so every frame we
have to check for collision and solve it
as you can see I can move the puddle and
there is an interaction between the
bottom of the ball let's move forward
now we may still missing a fundamental
game element which are the bricks and
we're going to create a class for them
as we did for the puddle it's very
similar as they are both directed
rectangles we're just going to add a new
field which is destroyed in place of the
velocity field and it will be used in
the following code segments to mark the
destroyed bricks and remove them from a
vector there is nothing really method
but we'll use it anyway to keep the
interface the same and that's it
basically now I want to create these
bricks in a grid like fashion so I need
the vector of bricks because we are
going to have multiple instances and I'm
using some constants to decide how many
bricks I want how many columns and many
rows what column number should I start
creating bricks what row number and also
the spacing and the offset between the
bricks now with a 2d for loop I can look
through all the rows and the columns and
they can simply in place back a new
break in the brick vector using the very
early constructor syntax and the x and y
coordinates are calculated using those
constants and in the game loop to be I
mean to follow the same interface we
need to update all the bricks and draw
all the bricks using to the C++ 11 for
loops we've taken them by reference
obviously so that we don't make
unnecessary copies so let's write out
was the sixth segment as you can see we
have the creation of the bricks in the
grid like manner but there is no
interaction between the bricks and the
ball
in this segment we'll actually have the
ball collide with the bricks and respond
to the collision and destroyed a brick
so the all the classes are the same we
are just going to have some new code
here in the as a free function and it is
called solve breaking ball collision it
will take a break by reference and the
ball by reference and not non
conservancies as we're going to change
both of these objects so the first thing
to do is check if the objects intersect
if they are not intersecting we go out
of the function as we did with the
paddle otherwise we mark the brick as
destroyed now we do this instead of
directly destroying the break not only
for performance reasons but also because
we might have some kind of interactions
that access the break during the game
loop so we don't want to access a null
pointer or some kind of memory that was
deleted then we're gonna have some
complex calculations here that allow us
to make the ball respond realistically
to the to the collision the first thing
we have to know is the direction the
ball is breaking so this is done by
calculating the overlap from every
direction
you calculate how much overlap Wester
from the right how much overlap aside
from the left the top in the bottom and
you get the minimum values by getting
the minimum values you understand what
direction the over the ball actually the
brick as you can see here since the
overlap right is much smaller than the
overlap left we can safely assume that
the ball is a brick from the right and
we do this for every direction
we get the overlap and then we have some
boolean values here that will tell us if
the ball came from the left from the
right and we check that by basically
taking the absolute value of the
overlaps and comparing them so in this
case if overlap right was minor than
overlap left we were this boolean will
be false and we will have we will know
that the ball came from the right so we
can respond to that then we have to
check whether the
horizontal overlap is less than the
vertical overlap this is done because we
don't want the ball to bounce in two
different directions
basically if the ball eats the brick
from the bottom there see there is still
going to be a horizontal overlap but we
do not care about that because it will
be obviously bigger than the Y overlap
so we take the minimum overlap I hope
that's clear we have any any question
okay so we check whether the horizontal
overlap was less than the vertical
overlap and based on that and on the
direction we previously calculated like
from the left or from the right or top
or bottom we alter the velocity of the
ball either on the x coordinate or the y
coordinate now see as you may remember
we have all of our rigs marked and first
of all we have to check the collision
between the ball and every single brick
so we put that a function call inside
the for loop then we love to erase from
the vector all the bricks that have been
marked we can do that with the standard
algorithm which is remove if it's very
efficient what remove ease does is
basically it shifts and rearranges all
the elements of a container so that the
elements that satisfy certain predicates
are put toward the ends of the container
so after that we call eraser on the
bricks vector the first parameter we're
going to call it eraser with is the
result of the remove ease function and
that would be an iterator to the first
object of those that satisfy the
predicate so if you think about it we
put all the destroyed breaks towards the
end of the vector and we get the
iterator to the first one and after that
we use the STD end to get the end of the
vector and we delete from the vector in
one single instruction all the bricks
that are at the end of the vector and
satisfy the predicate so this is a very
efficient way and safe way to this to
deal with entities
because it is fast and also allows us to
interact with the destroy bricks before
we destroy them so if there is an
interaction between I mean if there is
any simultaneous interaction that wants
to destroy same brick
there is no no trouble we want to access
a destroyed memory object let's try it
out okay as you can see the ball reacts
to the bricks and we can destroy them
easily so we basically have a playable
game and it's about 200 lines of fault
but we have a lot of code rip a code
application and we need to spend some
time refactoring the code so the second
part of the live coding will start with
simple refactoring and then in the last
two segments I'll show you out we we can
generalize the game architecture to
allow the programmer to easily create
in-game objects and we'll use an
interesting architecture with a manager
entities and polymorphism so to begin a
refactoring we notice that we have two
rectangles that are the bricks and the
paddle and they have the repetition of
the same gutters so we simply put them
in two different classes one for the
rectangle that we told the shape itself
and all the gutters and one for the
circle it's very simple and this will
use like mixing classes we simply make
the ball in inherit from the circle
class and the paddle and the brick plus
inert from the rectangle class very
simple so we save a lot of lines and we
avoid some code repetition and it is
exactly the same so now that we know
this I wanted to show you some diagrams
here that will help us understand what
we're going to do so we want to have a
nice architecture that will help us
expand our game easily without having to
always add stuff to the game loop
their basic idea that you is that we
will have a base entity class that will
support polymorphism and also these two
mixing classes that will tell us what
the shape of the objects are every
single class will derive from entity and
the paddle in the bricks will use
inheritance as a mixing for the
rectangle and the ball we use
inheritance as a mixing for the circle
it's very simple also we're going to use
some classes to better develop our
architecture we're going to have a game
class that encapsulate everything about
the game that we can use to restart and
stop the game then we're going to have a
manager class that takes care of entity
management and by that I mean the
creation and the updating and the
drawing and the destroying the entities
and this manager class will hold the two
structures one structure will hold a
basically a contiguous set of entities
under the form of unique pointers to
support polymorphism and the second
structure will be an STD map that
automatically allows the that
automatically sorts the entities based
on their types using the type ID keyword
and allows the programmer to easily
retrieve all entities of a certain type
and do something with them so this will
be our architecture let's implement it I
start here by creating the game class so
all the code is the same year and until
we get here which is the game plus so
the first thing I want to do is create
an enum a scope tinium that is called
state and it will help me understand
what state the game is in so it will
will be sorry it will be possible to
switch between the post and in-progress
state by pressing the T key we are after
defining the end DM we need to store
some additional things so here we have
all the stuff that we add in the main
function and now they are part of the
game class and we also added the field
for the current state and I feel to
check if the post
button was pressed the last frame we
need that check because otherwise if the
if if the user was pressing the post key
it would continuously fire and pause and
unpause the game repeatedly every frame
so I added up I found a method to this
class which is called restart and allows
us to start the game prints again
basically it said the state the state to
paused and creates the bricks as we did
in the main function earlier and also
refreshes the ball in the puddle by
initializing them I also have a run
method which will start the game loop
and in the game loop we have something
new that that is the check for the P key
and if the P key was not present last
frame we basically doubled the status
here and if it was posted it will be in
progress or vice-versa it's very simple
and when the key is pressed we set that
boolean to true otherwise if the key was
not pressed we set it to false and
that's as I said to avoid continuous
repetition of the pausing or imposing
we'd also use the art key to restart the
game and the rest of the code is exactly
the same in the main function we create
a new game object we restore it and run
it and this is the simple game
architecture class so we can start our
game as you can see it's posed by
pressing P we can unpause it or posit a
can and by pressing R we can resolve the
game very simple now this is the
interesting part we need a system as I
explained earlier that will allow us to
quickly expand the game and not worry
about memory management to the creation
of classes and altering the game loop
the game class is now something that
doesn't need to care about the other
game objects so we're trying to use some
object-oriented design that will help us
do that basically we will need the
memory header which is the C++ 11 header
for smart pointers as we're going to use
unique pointers we also need the type
info and matter to group entities by
their type and
allow the programmer to get them easily
so the first thing we're going to do is
create a polymorphic base entity class
this entity class will hold the
destroyed boolean so that we can easily
remove all marked entities in the
manager class and also it without the
virtue of the structure to enable
polymorphism and I will virtual updating
method and a virtual draw method so this
kind of design is very primitive there
are much better way to do this but for
the scope of a small game such as an R
cannot clone it's very easy to implement
and it works very well so basically in
our game classes we're just going to
overwrite those methods with their game
logic and drawing logic now we need a
manager that will help us store and
manage all of these entities as you may
recall from this diagram we need two
data structures the first one will be a
simple vector of unique pointers of
entity and this will actually store the
entities which this will own the
entities then will in the map that will
take an unsigned integer as the key I
use size D because it's what the
standard returns for the type info and
for every type hash code the type ID it
will store a vector of entity pointers
as you can see there are row pointers no
normal encounters and this will help us
gather the entities in groups so to
populate and query these data structures
it's a good idea to create methods that
will help us so I'm using here biotic
templates to create a create method that
will take a type t manually specified by
the programmer which will be the entity
type and it will deduct some arguments
that will be forwarded to the
constructor of the entities we begin by
statically asserting that the t type
were passing to this method is actually
derived from entity then we'll create a
unique pointer to this entity by using
the new make unique keyword introduce
sorry making
function introduced in syllabus 14 and
we simply specify the type of the entity
we want to create and perfectly forward
all the arguments to the entities
constructor also we need to get the role
pointers from the unique pointers in
advance as we're going to move the
pointer into the vector and we we will
not be able to get the pointer later so
now that we have those these two
variables we basically start by adding
our new entities to the grabbed entities
map by getting the hash code of the type
of the entity by using the type ID
keyword and the T type and the ash code
method it returns a STD size T hash code
that will be unique for the T type and
we can use that as a key for our map and
then this will return the vector of
entities with that specific hash code
and we am place back the normal pointer
the row pointer in this this vector then
we'll move the unique pointer into the
entities vector so that will it will
take ownership of this entity and to end
we will simply return at the reference
and return the pointer to give the
programmer a reference to the newly
created entity now removing of entities
will work as we did for the bricks we
don't want to remove them immediately we
want to mark them and then remove them
when it's convenient and when it's easy
to make it fast and performant so we'll
add a refresh method that will basically
look through all the entities and call
remove it and deal with the allocation
and destructions of these entities so we
start by doing this process on the
grouped entities so that we do not
actually deallocate the memory but only
remove the pointers and we simply take
all the pairs in the map we take the
vector which is the value of the key and
basically we call the remove if function
as we didn't earlier in the main in the
main function we check if the entity is
marked as destroyed and after that we'll
we will erase all the entities
and then we do the same on the entities
vector which is the owning vector you
may notice that I'm using a Const
reference here because the element type
of the vector is a unique pointer so I
don't want to copy it obviously because
it's impossible I'm taking it back on
reference checking it if the entity that
insults is marked and after that it will
erase all the unique pointers from
director and that will automatically
allocate the memory as we know because
smart pointers are amazing and after
that we're going to need some useful
methods which will be the clear method
that automatically removes everything
from the manager we will also use C++ 14
is automatic function type deduction to
get all the entities of a certain type
without having to specify the long
return type and basically we pass we
manually pass a T parameter to this
function and we get back the vector
containing all the entities with that
type and another useful method that we
use is a for each method that will
automatically get all the entities of a
certain type cast them to references to
their type because we store them with
the generic entity pointers and do
something with all discussed identities
so basically we pass to this method
emanuelly provided T type and also it
will deduce a defunct type that can be
any kind of function such as a lambda
function function and we get all the
entities of the T type and for every
single pointer in that vector that is
returned from that all we cast the
entity to its real type because we are
assuming we know what you were doing
with the reference it and we call the
function with this the reference pointer
so it provides a very easy interface for
the programmer to do something on all
the entities of a certain type and I
will show you how it looks in a moment
then we need an update and draw method
for the manager because we don't do not
want to manually call update and row
on every single entity type so there is
this will basically loop through all the
entities and update them or draw them
it's very easy now in the classes that
we had previously we do not change much
code the only thing we do is obviously
specify the inheritance it has to
inherit from the entity base class and
also a very useful thing to do is to use
the override keyword which was
introduced in syllabus 11 and the
override keyword basically is put after
the name of a substance method and if
it's not actually of writing a virtual
method of the base class it will throw
us a compiler error so we know we're
doing something wrong may be misspelled
the name we do the same for the paddle
and brake obviously and now the
interesting thing is in the game class
the game class does not know any more
about the game types it knows only about
the manager as it stores it and in the
game loop sorry in there start method we
can see how easy it is to creating
entities with the new manager syntax we
do not have to worry about memory
management which we just call manager
create break with the arguments that
will be forwarded to the constructor so
as you can see it's really
straightforward it allows the programmer
to not think about memory management and
we do that for the ball in the battle is
basically we are converting the code of
the previous code segment to the new
syntax and in the game loop you can see
how easy it is to use the new forage
method of the manager basically here
what we're doing with using celesteville
14 generic lambdas to get all the ball
objects in a forage loop inside this for
each loop we're gonna call to order for
each loops that will allow us to check
the interactions between the ball and
the bricks or the ball on the paddles
and all of this because of the for each
method is done by casting the pointers
to the real types that the programmer is
specifying here and basically this
allows us to think about game logic in a
very simple way as you can see it's much
easier to reason about and to alter than
you
previously let's say we need to add a
new brick type we just put another for
each year so it's very flexible easy to
maintain and expand and lastly we need
to remember to call refresh in the
manager because this code block will
obviously mark some of the integers
destroyed and here we have two to remove
actually the entities from the vectors
and freed memory and we seem to draw the
manager and I will display the window
and I'll show you that the game should
work okay the game is the same as before
as you can see there are no visible
difference but the underlying system is
now much more robust it allows the
programmer to add new entity types very
easily so it's obviously a step in the
right direction and we have a some more
time so I will show you the optional
code segment that basically add some
finishing features to our game we will
add some text objects to tell the player
what's going on with add some win and
lose status with limited lives and some
special bricks that require multiple
eats to be destroyed so to do that we do
not have to deal with the manager of the
game anymore
we simply go to the ball class and when
the ball is leaving the window through
the bottom we set destroy to true so
we're gonna destroy the ball if it falls
down and lose a life for the player now
in the brick class we're going to add a
new field that as it is an integer field
and it is the required it's for brick
using the installation syntax we're
going to set it to its default one and
basically we're going to change the
color of the brick based on the required
deeds and they have three different
colors here that basically looked one
darker than the other and it will help
us understand how many hits we need to
follow certain brick
and now in the solve big back
traditional function we need to check if
the break is actually destroyed or that
if we need more hits
so we basically decrement the required
it's filled and if it is lower or equal
to zero we destroy the brick by marking
it in the game class we add two
additional game states which are game
over and victory that we hit will keep
track of the win and lose conditions and
also we will have the psalmist FML very
easy to use classes which are as a font
that represents a font on the user
system and SF text will represent an
object that we can draw and alter a
swing that will be displayed on the
string on the windows sorry we also need
to keep track of the remaining lights so
that we can set the state to game over
when its weight reaches zero so in the
constructor we have something new to do
we need to load this font from file I'm
using liberation cents from my fonts
folder and then we're going to use
various methods of the text object to
set the phone to the position besides
the color on the string it's very
straightforward as you can see the
interface is very easy to use in the
result method we're gonna add set the
remaining lights to 3 when we're gonna
set the required it's for the bricks
with a simple module for modular formula
that basically lays them in a very nice
a very nice fashion it basically the the
bricks that Drupal Moritz are in the
center surrounded by the simple bricks
and we need to make some more checks
inside the game loop for the state and
display something to the player so if
the state is pause we will display the
post spring otherwise game over or you
want it's very simple and then we'll
draw the text by using simply window
draw method is very easy after that we
need to check if there are no more but
no more balls on the screen if that
happens we need to decrease the
remaining lies so that to remember
we had this ez get old function that
takes a type so we simply asked the
manager if there are any elements in the
vector of both and of all objects if
there aren't it means that the ball was
destroyed because it went outside the
window and if that's the case we need to
create a new ball to allow the players
to keep playing and also decrease the
remaining lights if there are no more
bricks on the window the state will be
set to victory obviously because we have
area we have reached our goal and the
rest of the code is basically the same
but we have to set the lifes text to the
current remaining dice
we're going to use the C++ 11 to string
function that basically takes any
numeric object and converts it to a
string and we're going to append it to
the laps text and as we run our code
segment we will see that it begins with
the post by pressing T we unpause it and
we have our breaks some of them take
more hits as you can see from the color
and if the ball goes outside we lose a
life and when we lose our lives it is
game over so that's the end of the game
basically it's 450 lines with comments
but I believe it's a very simple coding
style it's very modern so it's easy to
expand it to understand and that's
thanks to the SML library but mostly to
the newest standard that allows us to
use this kind of modern style of coding
so this is the end of the talk thank you
for coming if you have any question
please use the microphone
about one at what point would you
probably go away from s FML and use one
of the common graphics libraries like
OpenGL or DirectX is there a limitation
on using the S FML so yes FML library is
very limited in terms of what you can do
about rendering it basically it allows
you to load your own textures and
sprites and render them on the window
but it's always limited to 2d
but the s/m m/l library doesn't force
you to use I'm sorry I had to repeat the
question basically what he said is it's
there any limitation in using the SML
library instead of more common library
such as OpenGL and my reverie is my
reply is SML allows you to render
objects with that very simple interface
but only 2d objects that can be shapes
or textures that you logged in like
sprite sheets and so on but as FML
doesn't force you to use that so you can
use a famil for the input management and
the window creation but you can use
opengl along with as a family under 3d
objects so it's a very flexible library
and it has some limitation but you do
not you do not have to use the rendering
system you're not forced to do it I
really like your usage of the of the
modern style I want to ask about the
context for intz and flows where you
went customarily just a constant someone
so what is the advantage to the style
that you chose other than is it just
illustrating the new style or is there
distinct advantage to doing it that way
so I've used the constructs per keyword
basically to demonstrate the intent that
that variable is never going to change
it was not required I could have used
Const or no basically no keyword but in
my opinion something very important that
we often forget is to display the intent
of our code if it is something that it's
not going to change we should mark it as
such so it's a simple way to tell the
people reading our code that is not
going to change ever inside the code
that's it and we also put back
up your information well where that
source code can be found yes
okay so you can find the source code on
my data page it's all open source there
are also a lot of other projects that
you may want to check out about game
development I have a series of libraries
that I use in my all of my projects
random utility libraries also some
wrappers for SML common stuff and - open
source games that are working on one is
released and the other is a
work-in-progress game and I accept pull
requests so if you want to help me with
the development that will be great so
thank you again for coming if there are
no more questions we can wrap it up okay
thanks everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>