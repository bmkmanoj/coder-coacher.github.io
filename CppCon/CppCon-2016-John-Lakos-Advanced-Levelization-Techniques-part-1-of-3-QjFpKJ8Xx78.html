<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: John Lakos “Advanced Levelization Techniques (part 1 of 3)&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: John Lakos “Advanced Levelization Techniques (part 1 of 3)&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: John Lakos “Advanced Levelization Techniques (part 1 of 3)&quot;</b></h2><h5 class="post__date">2016-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QjFpKJ8Xx78" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm gonna talk to you about something
that for some of you you may have
already seen some of before I this this
talk is really the full breadth of
physical design and it was originally
presented in my 1996 book but it's been
updated for the next version I wouldn't
say version I should say the next book
which is much larger in scope and I've
been working on for way too long so I
need to get it out but this is a
definitely a key piece of that first
volume of the next book so the first
thing I'm going to talk about is
background of material it's not actually
the level is asian techniques but the
the way in which we write software in
terms of components and I'm going to
explain them that's probably going to
take about 40 minutes so but I think
without doing that the rest of it is
kind of abstract it's abstract anyway
but without seeing the concrete way we
represent software at Bloomberg then
well it would be too abstract so I'm
going to do that the next approximately
hour and change is going to be the level
ization techniques themselves and then
after that I'm going to talk about
insulation which is a an easier topic to
talk about there's lots of code in that
one and then finally I'm going to show
you how we compose components to solve a
typical kind of business problem that
won't take very long at all but it's a
lot of slides mostly mostly like
animation so with that said I'm going to
start and hopefully this is working
please be working I've got it what is it
working now yep okay so I'll put this up
but don't worry about it because that's
just for the camera and the abstract
again is just for the camera you guys
have already decided to come here so you
know you'll see it so I won't belabor
that but I'll leave it up for the camera
for a second and then we can talk about
what the problem is and this is sort of
how I start out all of my lectures this
is a particular topic it's one of many
many topics that together wind up being
how we collectively write software
in in the core BD Group at Bloomberg and
so there are many dimensions and one of
the things that I discovered I guess a
long time ago is there's logical logical
design and physical design logical
design is is something that really is
what's mostly taught in school and
physical design is the other stuff that
isn't typically taught in school and it
requires us to be able to isolate
modernize our art designs into discrete
physical components and that's a big
deal fine grained physical components we
need to be able to express in English to
human beings precisely what behavior
these components provide and then we
somehow have to manage the physical
dependencies that result from
implementing that functionality it can't
depend on everything now not everybody
agrees with that sometimes people say it
doesn't matter what it depends on it's
an empty tail in my opinion after many
many years of doing this that is the
furthest thing from the truth
that could possibly be stated in terms
of maintainability so that is the
premise of level ization techniques so
if you completely disagree with me you
can either stay and be convinced or you
can say you know what that's that's
nonsense I have to leave hopefully you
won't do that and then finally it
requires attention to a number of
different logical and physical rules
that govern how we design software and
we're going to talk about more like
techniques to help you improve rather
than just following the rules but the
first part of this is to talk about some
really hard rules so the purpose of the
talk is to review some basic design
principles and particularly with respect
to components that I'm putting this up
here component properties and logical
diagrams implementation dependency and
level numbers this was all covered in my
first book many years ago two important
physical design rules when it's okay to
collate public classes in the same
component our three level aggregation
strategy and encapsulation versus
physical insulation
we'll talk about that a little later in
the talk when to include a header file
or not we'll talk about that a little
later as well then we're going to
introduce a variety of level ization and
insulation techniques in that order and
how to avoid cycles and your designs
also excessive or otherwise
inappropriate physical dependencies so
with that this is the outline that I'm
going to follow and clearly two is the
beef three is a little more informal go
quickly it's just an application of some
of the principles any questions good
okay so this is for all three oh yes
good good question all right so review
of elementary physical design so we're
talking about logical versus physical
here and when I represent logical entity
I'm talking I usually use an oval to
indicate the logical part and a
rectangle to indicate the physical part
that's just the iconography so logical
as classes and functions and physical as
files and libraries and so here you see
a bunch of components stacked nicely one
atop another and they form different
levels of dependency beni in each one
contains some logical content each
component that we write except for the
file that holds main looks like this it
has a implementation file that CPP file
it has a header file and it has a
component level test driver test drivers
used to exercise the functionality
within that component we're not going to
be talking about testing today that is a
separate talk very interesting stuff
unfortunately it rests in the third
volume which I was where I started many
many years ago and I finally will wind
up hopefully not too long from now all
right this is our fundamental unit of
design and it's not just a dot H dot CPP
pair it has four fundamental properties
so in addition to having being a dot H
dot CPP pair it has these four
properties in the first
of them is that the dot CPP file of a
component includes the dot H file as the
first substantive line of code can
anybody tell me why it needs to be the
first line why the first line why can't
it be later the H is independent of an
inner file it's independent we okay so
the point is that the dot H file needs
to compile in isolation if you do what I
just said you'll never have include
order dependencies because when you go
to compile and test this component if
the header file requires other header
files in front of it it won't compile
and then the client won't be surprised
when your code works and the clients
code doesn't compile so this is an
important thing and so we always do this
and we do this even if the CPP file
would otherwise be empty this is just
what we do and but besides all the other
good reasons the amount of time we could
argue about whether we should have a CPP
file or not for any given component is
Dwarfs any value that you might think
you get from leaving the dot CPP file
out so this is what we do so each
component has a dot H and a dot CPP and
the header file is included as the first
substitute of line of code ok the next
one is quite a bit harder all logical
constructs having external linkage
defining a dot CPP file are declared in
the corresponding dot H file what does
that mean well first of all we have
logical constructs with external linkage
before I explain that we need to notice
or understand the difference between
defined and declared so declared means
introducing a name into a scope defined
means providing the space or otherwise
describing the definition which can
appear only once
od are wise in the program so what this
is saying in a nutshell I have to
explain external linkage so external
linkage linkage is is something that
pertains to whether to declarations in
separate from
separate translation units can refer to
the same object if an object has
external linkage they can if it has
internal linkage they cannot so that's
what linkage means so when we put it all
together all logical constructs having
external linkage meaning that they can
be seen outside of the translation unit
that they can refer to an object outside
of the translation unit more precisely
then if they're defined in the CPP file
they have to be declared somewhere in
the header file and the reason for this
rule is we don't want to have ABI
leakage out into the public world we
want to make sure that if there is some
symbol that's that's creeping out of the
CPP file of our component that at the
human readable level there's a way to
see that so we could be declared private
he couldn't be declared public it
doesn't really matter in the header file
but it needs to be declared so that's
that one
now the next one all constructs having
external or dual binding now binding is
a word that I made up because linkage
was already taken but it still seems to
serve the purpose I'll explain in a
minute all constructs having external or
dual binding declared in an odd age file
if defined at all are defined within
that component so I really do need to
explain what I mean by binding if
something has internal binding it is or
any use of a symbol any use of a name
and and the associated definition are
are handled by the compiler the binding
of the use and the definition are
handled by the compiler if it has
external binding that binding is always
handled by the linker and if it has dual
binding it might be handled by either so
what's an example of external binding a
a global variable for example int I
semicolon that has external binding I
say X attorney and I in a separate
translation unit somebody uses that
declaration and then at link time the
two are joined by the linker same thing
from plain old C style function
same thing for member functions that
aren't in line and and so those those
have external binding internal binding
things are like type deaths and class
declaration versus definition those are
handled by the compiler that the
Association and then there there are two
constructs in C++ that have dual binding
and I mentioned one it's inline
functions they have dual bindings they
could be inline in which case the
compiler takes care of it or the
compiler could choose not to in which
case the linker will take care of it can
anybody name the other construct in C++
templates exactly this is this is good
this is great because when I give these
kinds of talks at my own work people are
a little bit less quick to just blurt it
out so if you can sir quickly we'll get
out of here sooner it's awesome I
appreciate that
alright so what this is saying is since
it says external or dual binding you you
must define it in the same component as
you declared it another way of saying
that is the only place you can have a
forward declaration is when its internal
binding you can't have a local
declaration of something that has
external or dual binding so what that
means is I can say class foo that's okay
but I cannot say void F open close
semicolon that's not allowed unless I've
defined void F open close open curly
closed curly in the CPP file or as an
inline function down below the class
does that make sense okay now there's a
good reason for this I need to have a
place where I know this thing is defined
just by looking at the header file I
need to be able to say ah this component
defines this logical entity and if that
isn't unique if that isn't fixed then I
can't really draw a graph because I have
no idea what the nodes mean so that's an
important property and the fourth one is
a components functionality is accessed
via and pound include of its header file
we wore
establish that that's possible and never
via a forward extern declaration use the
word extra in because I'm really talking
about things that are handled are
potentially handled by the linker okay
so I'm never going to make a local
declaration of something that has that
his handle ever handled by the linker I
am always going to pound include the
header file that is required to declare
it they all fit together the really good
thing about this is I no longer have to
parse C++ to know what my dependency
graph is going to look like because the
pound includes themselves form an
envelope of allowed dependencies and so
by looking at them with a Perl script
not playing didn't have clang 25 years
ago I can very quickly determine the
envelope of physical dependencies in my
system this is a great thing this is a
huge property I can't stress it enough
that's really the reason the other
reason which is just a note by the way
you don't get stupid breakage when you
change the definition of something and
forgot to change its local declaration
somewhere you know you get you get some
strange things if this were C you could
get a runtime error in C++ it typically
especially with functions a link time
error but not necessarily when you're
dealing with with with variables not
that we would ever have global variables
but just saying all right so any
questions oh that's the hardest by the
way that is probably the hardest thing
yes okay so the question is how do I
enforce that people do this I have a
flail on my desk I do I absolutely do
and if I ever anybody were to
deliberately do something other than
this under anywhere near me I would
immediately pick up the flail and walk
over to their desk we also have
something called BTE verify that we've
been working on for over two years
it's a clang based tool and it
guarantees all of these silly rules so
that's the other answer but I like the
flail better okay yes
okay so the question is what do we do
with templates and inline functions
templates and inline functions have dual
binding since they have the possibility
of being handled by the linker they are
not allowed to be forward declared they
need to be they need to be defined in
the same component in which their
declaration occurs put another way you
can't declare them in another place in
addition to the one where they live
where they live is where they live and
you need to have that otherwise you
can't draw meaningful graphs and talk
about where the definition is this is
important this is like core stuff okay
yes we use forward declarations for
classes and there are pros to that used
to be much larger than they are now and
there are cons to that it's harder to
re-engineer code if you don't have a
single repository of the way Google does
and we don't have a single repository
and so what we need to do is a little
bit more onerous when we go to
re-engineer things if we have to go
change all of our clients which we don't
have access to so there is a there's an
upside and a downside the upside is if
we make it change the class definition
our clients don't have to recompile and
we're going to see that in section 3 so
there is an upside to that as well and
we'll talk about that as we go all right
so I've drawn this pedagogical diagram
here we wouldn't really have a value
semantics type like polygon inheriting
from an abstract shape because it's not
very meaningful but still I want to
appeal to your intuition so shape is an
abstract class polygon is concrete
polygons uses points in its interface
what does it mean to use something in
its interface well if I have a function
that takes something in its signature a
type or returns it as a return type then
we say that it's used in the interface
because you can see it programmatically
it's there if I have something I of a
class that uses another class in its
interface it means one of the member
functions of that first class
uses the the other class in its
interface so that's really all it means
now there other thing is I might
possibly use something not in the
interface but still use it substantively
and in the implementation so if I use it
in the implementation but not in the
interface that's another kind of using
and then of course there's is a-- which
is a polygon public interface inheriting
from shape so those are the three things
that are are key and then there's one
funny one we'll get to that in a minute
so let's start with this is a a polygon
is a shape so we just draw this picture
you notice it's Bubble to bubble so we
have a polygon is a shape because that's
a logical relationship next we have uses
in the interface which I just described
and polygons uses point in its interface
for example to add a vertex so we have
this symbol the bubble is on the polygon
it's a clear bubble that means it's used
in the interface all right then
point list and point list link both use
point in the interface now you'll notice
that point list link has an underscore
that means that point list link is not
allowed be used outside of the component
in which it's defined you could think of
it as being a nested class of the
component we don't do nested classes of
a class because it creates extra levels
of hierarchy that are not useful for our
describing logical relationships or
physical dependencies so this is the way
we do with this again is enforced by our
tools and it's something that we started
a very long time ago when when nested
classes weren't really supported the way
they should be and even now we find this
better so this is the way we do it there
is a mapping from this to a nested class
but you lose certain things by doing it
you actually this is better strictly
better but anyway so so both of these
the point list and the point list link
use point in their respective interfaces
so hence you see the diagram and then we
have uses in the implementation and a
polygon is implemented by embedding a
data member of type point list in it
so polygon uses point list in the
implementation but you wouldn't know
that programmatically because there's no
interface part of polygons that exposes
a point list in it by the same token
there's nothing in pointless that
exposes a pointless link in it okay so
we have that so far so good question
okay a component is a dot H dot CPP file
having the same root name with the four
properties that I described in you know
remember that includes it's in the CPP
it's in the it's declared in the age if
it's declared in the age then unless
it's a internal binding then it is
defined in the CPP okay and then finally
if you use it substantively you include
it those are the four properties that is
what we defined to be a component okay
if it's not if it's not that it's not a
component if it's not that doesn't mean
it's a good component it's just at least
a component okay okay all right and then
there's this last one and this one is
hard to get your mind around and you may
not even believe me when I tell you but
it turns out that it's possible for a
component to use another component in
its interface in name only and what in
name only means is that you don't have
to pound include that component to
compile link and test the component
under test and shape is an example shape
uses point in its interface in name only
okay this does not happen in nature
unless you make it happen
except for abstract interfaces so if you
have an abstract interface then this
will happen and for example shape may
have a get origin function we would just
say origin but the idea is it's going to
return the origin of the shape and it
can do so by forward declaring class
point without ever including point
anywhere in the
even though the shape returns a point by
value if this is shocking to you
excellent
go try it the other thing is if shape
for concrete but used a forward class
declaration for point the include would
not be in the header file even though
it's returning a point by value the
include would be in the dot CPP file so
this is interesting
compile-time stuff that's worth trying
and getting a handle on because where
you put the includes matter and what
allows you to put the include in the CPP
is the forward declaration of the class
okay yes okay so uses a name only means
I have I have shape it says it uses
point in name only that means I don't
need to ever include point I never need
to see its definition I don't care and I
can compile link and test shape in
isolation yes yes okay so the question
is what if I want to to call size of the
return value of the function when you
use the when you use point when you call
the function that that where you
actually need to use point you have to
include it yourself right okay
yes sure okay so I understand the
question the question is this suppose I
have a function that takes a point by
reference in the interface right it uses
point by reference in the interface but
the function is implemented in the CPP
file all you need is class point in the
header file but you need to pound
include it in the CPP file
because it's using it substantively and
the header file it doesn't need to know
the size
no that's uses in the interface it
doesn't matter whether it's an inline
function or whether it's a non inline
function it uses it in the interface and
you must include it in the component
it's only when you don't need to include
it anywhere in that component or any
component on which it depends when it's
truly used in name only and I'll explain
that even a little bit more in just one
second
this is this is I know it's hard that's
why we need to go through this a little
bit otherwise what I would be saying
next would be absolutely crazy
it still is alright so the next thing is
depends on and depends on is is a
physical relationship it's not a logical
relationship and it goes from box to box
if polygon uses shape in the excuse me
if polygon is a shape then that's the
strongest kind of logical relationship
it's a compile-time physical dependency
and so it implies this depends on
relationship between the component that
defines polygon and the component that
defines shape okay that's called an
implied dependency as soon as I know
that there's an is a relationship across
component boundaries that's that's a
hundred percent okay then I have the
uses in the interface from polygon to
point and so that that implies a
physical dependency so if I use
something but it's not in name only
there's another physical dependency and
of course pointless and pointless link
both imply a physical dependency can
anybody guess where the last physical
dependency is there you go so this is
what implied physical dependency is once
you have your logical relationships
which are an abstraction on the actual
interfaces of the components then you
and also knowing the data members of of
course then you can infer physical
dependencies and that's a higher level
of abstraction still once you have that
we can go to level
and this is where I hope it will tie
down the difference between users in the
interface and users in name only so
something in this at least one component
in any subsystem has to be at level one
right the one that doesn't depend on
anything else so there could be more
than one so what for sure doesn't depend
on anything else here okay I heard shape
but anybody think point
okay so point for sure but because of
what I said about the includes it's also
shaped so these two are at level one
even those shape looks like it depends
on point because it has this nice dotted
line its collaborative dependency it's
not a physical dependency and so it's in
name only
it does not affect level numbers anybody
want to guess which component is at
level two okay pointless so you guys are
getting this right there's one left what
is it that level two or what okay good
so we're good with this right this this
makes sense it's old stuff so this is
called a component class diagram with
level numbers and it also shows the
physical dependencies so this you can do
to any design if you wind up with a
design that has the big air black arrows
pointing this way or cause us some crazy
cycle then you know you have a design
problem and the second part of the talk
is going to help you through that all
right so essential physical design rules
we have two essential ones I mean we're
talking like big ticket if you break
these forget about it okay the first one
guess what it is there you go that's the
first one the second one is a little
more subtle but it's important and
anybody want to take a shot there you go
somebody read my book no long distance
friendships it's not that you can't have
friendship that is perfectly fine but
you can't cross a component boundary
because as soon as you do that you allow
the possibility of checking out a
separate physical entity let's say a
list and if say you had it
that's allowed to change the list you
check out the list you add a tail
pointer you put it back in and at some
later time you build the system and the
cursor doesn't know about the tail
pointer and it just everything goes to
hell in a handbasket so you don't want
to do that you want to make sure that
everything that has private access lives
within this the same physical boundary
another way of saying that is the
logical unit of encapsulation should be
nested within a physical unit of
encapsulation and this by the way goes
to the notion of logical physical
coherence you want your logic and your
physicality to be coherent and not
separate like my logic is here here and
here and my physical part is here here
and here
no good they have to be one in the same
hope that made sense yes we can say that
friendship is allowed only within the
same component we we are saying that
that is a very good way to say it love
it all right
okay so criteria for co-locating public
classes we saw that that thing with the
underscore was co-located in the same
class as the point list but it's a
private class so or it's its component
local it's not allowed to leak out what
if we have more than one class that can
be used externally in a component under
what circumstances might we consider
doing that well you said what ok that's
that's very infrequently we try not to
do that ever even within the same
component but there's one thing that we
do regularly when we need to what is it
no but you should get the answer if the
first one is friendship if we need
friendship across two classes within the
same component for example an iterator
if we put the iterator not nested within
the class but let's say we put it ahead
of the class then it grants friendship
to the container that it's
perfectly okay to use the iterator and
the container and life is good and the
container has private access to the
iterator so it can set up construct it
as needed everything's fine
make sense okay so friendship is the
number one reason yes that is the fourth
reason but we don't call it flyweight
call it something much more descriptive
absolutely not inheritance most likely
no there any ideas okay well anyway I
will tell you that although the cyclic
dependency thing is there we try not to
do it even even though it would be
allowed the typical way of implementing
as I understand it I know I don't know
how everybody does it of implementing a
container iterator pattern is to have
the iterator nested within the within
the container and I don't want to do
that so I want to put the iterator ahead
of the container but unfortunately the
iterator would then have to know about
the guts of the container so what we'll
do is we'll actually use a level ization
technique and put the guts as its own
class before the iterator so we have the
guts the iterator and the container and
the container depends on the iterator
and the guts and the iterator depends on
the guts and it's a cyclic and it's
beautiful and you can build it up and
understand it without having to go back
and forth and wonder what the incestuous
relationship is between nested classes
so anyway the third one is a single
solution now with C++ 11 we don't really
need this anymore but this is not a C++
only talk because this is architecture
and this applies to any language that
has multiple translation units so here's
an example if I don't have a very attic
template or macro mechanism and I need
to have multiple entities that together
do the same thing as a very attic
template or a very attic macro then I
can put them in the same component and
it's okay because putting them in
separate components would be madness
would do nothing good it would simply
scat
you know you have to include seven
things to get something to work so
that's not the point the point is it
solves one thing okay here's an example
of what not to do here I have let's say
I have at the lowest level I have a
coordinate then the next level I have a
point the next level is a box the next
level is a box collection and the final
level is a garage got these five things
now you might say John how could I
possibly use a box collection without a
box that makes no sense but that is not
what you ask you say could I use a box
without a box collection the answer is
yes so for that reason this is a bad
idea and what we're going to do is we're
going to take the coordinate and make it
its own entity and anybody who wants to
use a coordinate is free from any
dependencies on these higher level
things and so on and so forth until I
get to the garage and if I need the
garage I need the rest but at any point
I can cut off the stuff above and use it
independently do you see the point here
fine-grain reuse very important that is
another talk but very important
questions on this okay good so this is
fine now finally what was it flyweight
was suggested the next one has this
descriptive term which is flea on an
elephant see flyweight you know what
does that even
what is flea on a no for me well I'll
explain so if you have something like a
logger and you have a scope guard that
is used to initialize the logger in
Maine and then get rid of it well that's
fine
we'll let you do that even though it's
technically two classes the the scope
guard is a flea right it's just a little
bit of sugar whereas the elephant is a
big thing now if you go the other
direction that then you have you have an
elephant on a flea and I might want to
use my flea but the flea would
definitely notice if an elephant were on
it so this is the bad idea we don't want
to do that kind of thing now I do have
to say that people can abuse these
things where they say something that
that isn't a flea on an elephant is a
flea on an elephant like a goat on a pig
or something like that we don't do any
of those things right it no ducks on
cows even now just flea on an elephant
that's it and
and be careful not to rationalize that
it's something different when it's not
okay
so now we've seen these levels of
dependency but they're but they're only
one level of aggregation components are
the first level of physical aggregation
and they have logical content but we
need more than that and there is no such
thing in the C++ language yet and
modules I'm hoping someday will serve as
the second level of physical aggregation
to be determined but I hope going on
record in any event we have them now we
call them packages and a package is a
collection of components and we don't we
don't extract the dependencies among
packages to define them we specify them
explicitly
so this higher-level package is allowed
to depend on the to lower-level packages
and that's it what do I mean by depend
on it I mean a component within the
higher-level package is allowed to
depend on any component within a
lower-level package on which it's
allowed to depend now question why is it
we specified this extra data that has
nothing to do with C++ rather than using
tools that just extract the includes as
I said we could and figure out what the
dependencies are to make it hard to to
introduced Oh make it hard to introduce
dependencies that we didn't want okay so
that's that's exactly right we want to
do that that's a good answer but how
about this one what if we're just
designing the system does anybody ever
design a system before they write the
code ever what if you haven't actually
gotten any components yet you're in the
process of designing the system and
you'd like to skip a physical design
specification for what the higher-level
architecture is going to look like how
are you going to extract anything from
that now your point is as we go along
maybe we deviate from this this process
and and get something wrong and then our
tools which of course detect this
because now we use the extraction
mechanism which we can do because we
followed the component properties and
therefore we can extract them instantly
as we build our stuff is great stuff we
find out we did something wrong we get
an error make sense this is old
technology this is literally 20 years
old all right now we can create a
hierarchy of the second level of
aggregation known as packages okay so
here we have it and we can actually take
it further we're going to have packaged
groups packaged groups are guess what a
group of packages and you just say well
really do I really need components
packages and package groups yes you do
packages are unique have have a name
that's unique throughout the enterprise
but they're too small to be units of
release in most cases you want a unit of
release that's substantial and the unit
of release if you think about it like
this a compact group is like a continent
and a package is like a country and
there are many countries on the
continent but they don't necessarily
speak the same language use the same
currency or anything like that
they simply reside on the same landmass
ie the same level in the enterprise-wide
physical hierarchy so that's what we
call a package boom and the three are
important will now look at something
else
they're also regular what I'm showing
here now is a packaging system where we
could have just a component or a package
or we could have a combination of
component package and package group and
so on and we could keep going up the
line and you can see that it's really
not very readable it's hard to compare
something that's really small with
something that's really large right so
it's better to have a bunch of small
things that roll up into something
that's medium sized and a bunch of
medium sized things that roll up into
something that's large and that large
thing is your unit of release that's the
idea and this turns out to be much more
approachable now turns out I tried to
write my book this way so that I would
have chapters I would have volumes which
were the big things and
I have chapters which were the
medium-sized things then I would have
sections which are the small things but
it turns out the sections are really not
at all close to the same length and they
vary so widely that it turned out that I
might not be a good metaphor although it
was a thought maybe 15 years ago it's
just not a good idea so I'm going to
wind up having to introduce an extra
level in my book it kills me but when
you have a section that's 5,000 lines
you know it's a little painful so have
to do a little better there but it does
work for software and the constraint is
that you want components to be more or
less the same size more or less you know
and the definition of that is can it be
tested from a single test driver and if
the answer is no you got to do something
and there are lot of things we can do
with that all right so this is a bad
idea instead we're going to have a
component package and package group and
that's exactly three levels of
aggregation it also admits a very nice
naming scheme will omit that for now and
then and our units of release are going
to be packages and package groups now we
have this other thing which is this
package group hierarchy but the way
we're going to implement that is we're
going to deal with it as separate
package groups that have their own
dependencies on other units of release
so this is the way we distribute deal
with our our packaging and so on so
exactly three levels of aggregation and
with that does anybody have any
questions because we're done with the
first part and I'm two minutes over what
I was hoping for
okay the quite the question is the
question is at the package at the
package level can we start dealing with
with system boundaries and I'm not sure
what you mean by a system boundary I'll
give you an example suppose we change
vocabulary types we're using our own
custom string for whatever reason we
want to go to STD string so that's it
that would be a kind of boundary where
we do a translation
right absolutely so sheriff the
third-party library would most likely be
a package group or a big unit of release
boundary a package is within another
typically within another package group
you can't have standalone packages but
the trouble is it's hard to keep track
of lots of little things if you imagine
something the size of a Google or
Bloomberg how many packages that there
would be even packaged groups it's huge
but packed but there's also something to
be said for grouping your packages based
on their dependencies so you can find
things and so you can have reasonable
dependencies right so yes packaged group
I think is what a third party party
library would correspond to but it
doesn't follow the internal structure
it's in a regular unit of release for us
any other questions yes oh yes okay I
think I understand the question what
makes a package a package so the answer
is a package shares a common prefix in
the medieval times before there were
namespaces what we used is a package a
logical package prefix and then we had a
physical package prefix there was
preceded by an underscore
now what namespaces came into being
after much resistance because I really
like the way it was done before because
I was used to it I realized that there's
really no harm in with the logical
prefix of turning into a logical
namespace so everything within a single
namespace or physical prefix is a
package they're grouped together and
they're put into a sync typically into a
single header directory during
development
now how you deploy it is different when
you roll it up into a unit of release at
the group level you put all the
different package headers into a single
unit of release directory perhaps or
even possibly combine more but that's a
deployment issue but the idea is that
everything within a package shares a
common
enterprise-wide unique prefix and it's
represented logically as a namespace and
physically as package name underscore
does that make sense okay so okay so
that I understand the question now you
should design if you're doing trying to
get hierarchical reuse you don't want to
hide and we'll explain this you don't
want to hide components from users you
want to hide the use of components from
users so maybe I write something I write
something that has to do with the
Gregorian calendar and it's perfect but
then I change my implementation of date
to the proleptic Gregorian calendar but
the Gregorian calendar component is just
fine I just don't use it anymore
so what I want to do is I want to allow
people who continue who used it before
to continue to use it but I don't want
people in date this is a little bit of a
bad example because it actually affects
the contract of date in a very evil way
so that's not really greetings it
doesn't hurt anybody who's you know in
modern times and be people who were
trying to calculate bonds in the 6th
century are going to have a problem so
it's no it's you see what I'm saying
it's just an example so we're gonna talk
about that but a package is really
nothing more than a collection of
components and with very few exceptions
all of the components are available for
external use and there is a mechanism to
stop that but it should be used only
sparingly because it defeats the purpose
of hierarchical reuse which is one of
the goals of what we're doing here
through fine-grained modularity you
don't want to keep our our our
implementations to ourself we do want to
we do want to make sure that if we
change our implementations we don't hurt
anybody but but we don't want to hide
them you want to hide their use that's a
good point yes how do we separate our
component hierarchy by packages ok so
the answer to that is we want to put
components with
same dependencies first of all in the
same package and we want to put
components that make sense
semantically not syntactic - but
semantically in the same package the top
level of one package that's interesting
depends on the bottom level you know I
think it would be you have you have a
package you have another package if you
allow a package to depend on another
package you're saying any component in
the higher-level package can depend on
any component in the lower-level package
okay oh boy yes okay depending on the
level if it's a very low level package
they have a collection of allocators but
cap allocators being worked on by
different teams and then and then and
given to a team that's responsible for
Manning typically there's a there's
somebody who's the package owner but you
know you can have submissions from a lot
of different well then they're people
that are doing their own application to
have an entire package group that
they're using to design their app so
it's an application level package group
and so they'll do that okay yes
absolutely the higher up you go the
bigger the deal yes right I'm saying
that having having them all mixed in
other words when you're statically
creating a collection of components you
want them to roll up into a package that
has a purpose that people can grok right
you don't want to have in addition a
package group here and then a component
here and say I have this other thing
here that rolls up
Paquette group in a component because
that that doesn't allow you to
recursively descend at a roughly equal
levels of complexity that's what I'm
saying
roughly but it's not necessarily need to
be like the same sized pebbles but it's
not going to kill anybody if you have 50
components in a package in a package
group and then this one has only 15
that's okay because it's not it's it's
really the idea is you want to try to
compare apples with apples even if this
Apple is bigger than this Apple it's
still an apple it's not a truck of
apples okay so let me let me explain
that the difference the difference
between the dump things in model and
what we do is you have a bunch of
application developers and they find
something they think is cool and they
throw it into the Demilitarized Zone DMZ
this goes in there no one's maintaining
it it's just there people can use it
whatever and that turns out to be as you
say a grab bag that is not what we do we
do just the opposite people offer things
to us and we curate it into a very
carefully crafted lattice of useful
stuff that satisfies our level of
quality is the opposite of what you just
said but you just said is not affected
ant I'm agreeing with you it's not does
not work what we do does work it's the
opposite though we receive it and we put
it into place or we write it ourselves
but we do not let people put it there
we don't have it we absolutely do not
have it there is no such thing and I
agree with you remember I'm agreeing
with you but I knew this 20 years ago
and I'm supportive agree with you then
and I still agree with you I'll probably
agree with you until the day I die
okay oh and just to just to mention the
previous the previous question was was
about it's bad to have cycles at the
package and at the package group level
right and the answer is absolutely even
more so all right
okay dumping is not allowed there's no
dumping here if anybody wants to just
read these questions yes okay the
question is you might be forced to
include the entire package if that's a
problem then there are things called
insulating wrappers that you can create
okay and that is a topic of section
three okay all right at the at the risk
all right last question no no now one of
the things that we want to do is I first
of all I don't I don't see the advantage
because we're not hiding anything from
the compiler we're just pretending to
hide it from the human being what we do
is we have the upper part and the lower
part and it says in line function
definitions down here so you can go look
down there but they're not in line
they're below
we never put the in line definitions at
that point all right a lot of good
questions I'm worried though that if I
don't keep going I'm going to get behind
to extent where I can't finish so even
though we have only five minutes because
we've had a lot of questions I want to
continue just starting on the next one
we're gonna break right on time so here
are some things that you might want to
just look at for yourselves make sure
you understand but in particular can
anybody remember how
do this what is it that allows us to do
this we have a single headed that
represents the component but that's true
of a lot of a lot of the places do but
what's true about that allows us to to
extract the component defendent
dependencies efficiently I mentioned it
does anybody remember the list of the
includes but there was a property
importantly all of the properties add up
to this but the fourth property that
says if you use it directly you include
it directly you don't declare it locally
the link the link one that's what makes
sure that we have covered the the
envelope of physical dependencies
otherwise you could possibly have a
local declaration that allows a physical
dependency to slip out without knowing
that you have it and then you can you
can calculate all your included get your
solution go to Lincoln and realize
you're missing a link or symbol so
that's why this is important I just
wanted to bring this out the the
properties are important all right we
have four minutes left I'm literally
going to start the next one and stop
like on the third slide but I really
want to keep going because I think you
should okay so here we go so level
ization this is a horrible word that I
made up a long time ago
but it but it it actually has a meaning
and I want to just let you know what it
is because this is what we're going to
be talking about level eyes it's a verb
we need to level eyes that design ie we
need to make it's physical dependency
graph a cyclic or love Eliza below are
you sure that design is love Eliza balai
II do we know how to make its physical
dependencies a cyclic level ization what
level is a ssin techniques would you use
ie what techniques would you use to
level eyes your design so this is my
shameless advertisement for my 1996 book
and the one that's coming out shortly
and I happen to be working on this
specific section back in my hotel room
when I'm not out here talking or
partying or whatever else I do so
anyway um there are nine techniques that
are described back Ridge initely
described back in 1996 and it turns out
that they're pretty much the same but
there have been some new incarnations of
them in other words new new ways to
implement the basic idea so we're gonna
learn these now and we'll apply them
later to real-world examples and with
the last minute I'm gonna do the first
one which is called escalation mute
moving mutually dependent functionality
higher in the physical hierarchy and
here we have an example of a rectangle
in a box and the two are mutually
dependent they both depend on point so
if you look at the rectangle you'll see
that it includes point and box and
you'll see box includes point and
rectangle that's a bad thing
the reason they do it is because there
are conversions mutual conversions this
is the this is the interface but anyway
so these this is the I'm sorry that was
let me go back sorry
this this is not the interface this
these are the data members they're
slightly different they have different
performance characteristics this is the
interface the public interface and
you'll see that they're slightly
different as well and you'll notice that
these are implicit conversion operators
right the Constructors I'm sorry not
operators constructors and so this
cyclic dependency is is is very hard so
it's in the interface as is there's
nothing we can do to fix this now you'll
notice that there are include box and
include rectangle and some people
believe that just by removing the
includes and replacing them with a four
word class declaration that they've done
something and it have done something
they've reduced the compile time
coupling but they have not eliminated
the physical dependency it's still there
okay this is no good so we have a
diagram that looks like this this is bad
right we know this is bad we have to fix
it somehow one way we could do this is
we could we could escalate box above
rectangle and that would look like this
what we've done is we've said that that
box depends on rec
that's good and we put in a both the
constructor that takes a rectangle and a
conversion operator that takes it to a
rectangle now I'm not suggesting we
actually do this but I'm saying this is
a technique that you can use make sure
that box knows about rectangle but not
vice versa and you get this diagram or
yeah and now the problem is the way
we've done it right now if anything in
rectangle dot H changes or all clients
of box need to recompile because we
included box a rectangle in the header
file of box now I'm missing two things
I'm mixing compile time coupling and and
and physical dependency that's ok let's
do it the other way this time we're just
going to have a four word class
declaration of box so look here it's
just class box now we have the same
physical design except that if something
changes in box the clients of rectangle
are not affected just the direct clients
of box so the best thing we can do is
take everything out of box and rectangle
that is mutually dependent and escalate
that to a higher level convert util and
so now we have something that looks like
this and we have rectangle dot H and box
dot H included in the convert util
because we're going to need to avoid
them we're gonna need to support inline
functions sorry and then more on that
later
this one though we include point here
because we want to avoid what we call
transitive includes we don't want
someone else's header file to include
point two when we use it ourselves and
here's an example of where we're going
to be using it ourselves in this convert
function right box the rectangle looks
like this okay
the details aren't important just the
idea that it uses it as all that matters
all right so now suppose we took this
out then imagine later we decide we
don't want to use the includes in in the
in the box and rectangle we're going to
replace them with class point if we were
to do that it shouldn't break anybody
but because we took the include out of
the other the top-level one
now it no longer combines so we don't do
that we put it back in and now it
compiles again and we're back to this
thing and the finer grain look at what
we mean when we talk about this is this
this is just the physical dependencies
excluding this is but file level
physical dependencies and component
level physical dependencies excluding
the logical relationships so with that
I'm going to stop there's any discussion
what anybody wants to talk about it
we're taking our break what do we have
15 minutes you're dismissed 15 minutes
we'll start on time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>