<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2014: Louis Dionne &quot;Metaprogramming with Boost.Hana: Unifying Boost.Fusion and Boost.MPL&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2014: Louis Dionne &quot;Metaprogramming with Boost.Hana: Unifying Boost.Fusion and Boost.MPL&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2014: Louis Dionne &quot;Metaprogramming with Boost.Hana: Unifying Boost.Fusion and Boost.MPL&quot;</b></h2><h5 class="post__date">2014-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/L2SktfaJPuU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">No hi my name is Louie I'm a math
undergrad and our computer some computer
programming enthusiasts and I've also
had the privilege of doing real Summer
of Code with boost this summer now I'll
be presenting my work of this summer
which is Luisana a library for
metaprogramming you know Express avoid
using C++ for G so first I'll start with
a small primary to set things straight
regarding context poor some
misconceptions and it is important that
we we make everything clear because
otherwise we won't really get what's
happening next then I will show how it's
possible to to unify type level the
computations like in the boost MPL and
value level computations like in the
boost fusion library into a single
library and with the same syntax then I
will explain the building blocks the
underpinning concepts in the library
will also present some case studies just
to show that it can be actually used to
solve real problems and finally we will
discuss some implementation techniques
and I've also got some bonus if we're
out of time but before we even dive into
this let's ask ourselves why do we even
meet a program what are the motivations
right well so one possible use case is
loop unrolling so you give me a function
and basically based on a number and
that's known at compile time I'd like to
call that function f n times right and
we really want the function calls to be
expanded at compile time so we don't
want to do it in a loop so that's one
possible reason why we might want to use
metaprogramming then we can also do type
computations so typically we're given
sequence of types and what we want to do
is perhaps query something about those
types so it could be that we so you give
me a couple of T's right and you want to
know which one has the smallest size or
you might want to simplify something
about
about these types for example order them
in an order that minimizes the hangman
requirement when you declare when you
declare our member in a struct or you
could do anything like compute the
common type between between all of those
types and things like that another
technique that we need metaprogramming
for and that is pretty much well known
is expression templates the basic
concept is that we instead of we write
normal C++ expressions but instead of
actually can evaluating those
expressions we we build a tree
representing those expressions and then
we can move around in those trees and
modify them traverse them and perform
eventually domain-specific optimizations
so in this example I'm adding two
matrices here but a-ok here and some
basically it's it's an it's a tree
that represents the fact that represents
the action of adding two matrices but
it's not really doing anything yet and
then when we actually fetch an element
inside inside of that sum well it just
has to go fetch the corresponding
element in elements in each of the
matrices and then add this instead of
adding the whole mattresses so it's a
thingy
but it's it's it's our time for it right
so we need we need we need to offer
of course there are more use cases like
compile time compile time task ordering
so you give me a set of tasks they all
have dependencies between them and I'd
like to compute I'd like to order them
in a way that all the dependencies are
respected and I would like to do that a
compiled by so basically you have a
compile time graph and you want to do
some kind of linearization maybe using a
topological sort or something but you
need some kind of framework to be able
to do that dimensional analysis so you
have quantities right but there are
units associated to those quantities you
do computation and the goal is to make
sure that the units will always fit so
this is another place where you actually
need metaprogramming introspection so
you have your user-defined user-defined
strict and you basically want to iterate
or the members or query something about
like about the members of your structure
in a generic way these are all reasons
what you might want to do
metaprogramming of course it's it's
mostly for library writers but still we
need it ok now what's the problem well
the problem is that the sender lacks
proper tools stand out still double it
is this really low-level we don't have
any high level algorithms to topple the
interfaces is pretty basic
we have likes to gets to double cat but
nothing really nothing really you know
nothing really I'll about to solve a
non-trivial test and also it compiles
very slowly if you create a couple with
a little with a lot of elements in it it
compiles very slow and there is no
center way to do type level computations
of course we have type trans and we have
to condition all and stuff like that but
for anything non-trivial we still have
to resort to other libraries like
increased MPL which which is
non-standard and it might be a good idea
to you know solve solve this problem of
metaprogramming
once and for all in a good way and
standardize if everybody's already so
and I need a solution because I want to
solve some non-trivial metaprogramming
problems so I built Hana which provides
very expressive and complete interface
there are a lot of algorithms and they
are very high level so you can do for
example you can compute all the
permutations with a topple you can slice
a topple you can do all this kind of
stuff that would usually be just like as
you stood topple and still integer
sequence well now it's all hidden under
a nice and expressive interface the
compile time performance is is much
better than in boost fusion and stood
topple because of implementing plan and
implementation techniques that I will
show later and it also Unified's type
level and valuable meta programming so
that you don't need to like two
different libraries I did boost MPL and
whose fusion to to do this so you can do
everything you can do with MPL and
fusion in a Hana nest in your library
and with the same syntax which is a big
game okay now why won't cast exper save
us well so this is like a guru of the
week style question is this coconut just
stare a little bit it's not right
even though even though the eye ear is
can sector this disk on valid it's
basically the same code that I just
ripped up the template I just ripped out
the template and it makes it clearer
that this can possibly work excuse me
what
no it's not valid the question was why
oh wait is it valid okay sorry
so it's gonna because I ear is not a
constant expression because yeah it's an
expression actually the thing that
happens and it's pretty tricky and it
bugs people out that the thing that
happens here is that even though this is
context where you lose the context
proness of the expression when you pass
it in that when you pass it in to the
function it doesn't compile playing
doesn't compile GCC and so so yeah it
doesn't work and if you just strip the
template if you think about it it's
really just a sign because this is just
like explicitly and since changing the
previous function but within in it right
and this can possibly work because this
function must it must be possible to
call this function with both constant
expressions and non constant expressions
what if you pass something that that's
run time here you can possibly static
answer it so yeah it only makes sense
that this won't about and it does but
that that's a big problem and what does
it means basically that you can't have a
you know you can't generate a constant
expression inside a function if it
depends on a parameter that's basically
it and it's very important because it
means that the return type of a function
may only depend on the types of its
arguments not on their values even if
you pass in class the expression got
sent expression is everybody following
this is like oh that's most important so
for the rest this is really really
important because yeah people sometimes
people think that we can we're gonna be
able to do some heterogeneous
computations with context expert but the
reality is that it just doesn't change
anything it makes it possible to do a
heterogeneous computations in inside
constant expressions but it doesn't
actually change the inner implementation
of the library is everybody kind of
following or it's pretty important
okay so here is the solution you need to
actually encode the the value of the
argument right inside its type that's
the only way and so you use it to an
integral constant or something
equivalent doesn't matter for this
reason Hana provides Hana provides a an
equivalent of an equivalent to sterling
to broad consent it overrode the plus
minus and arithmetic operations and
stuff like that comparison so that you
can actually and so yeah the return the
return so int 1 as some type and into at
some time some type and it returns like
a student real constant of 3 right so
they have different types and so you can
keep the context proneness of the whole
expression in but by storing it always
in the type of the resulting expression
is everybody following me here okay and
so these guys here are actually variable
templates okay so this is just like
creating a student integral constant int
1 and then default initially
initializing it but it's just a
shorthand syntax I do this with
expression variable templates okay and
yeah the boustan our consent assert here
is just because inside the
implementation I can't put static assert
at the moment because inside the
implementation I use lambdas and this
can't be constant expressions but but
you still have the the important thing
here is that the value resulting so did
this expression actually returns a stood
true type or a student false type and so
the result of the comparison is actually
held in the type and so you can retrieve
it anywhere and and use it as a consent
expression okay okay so this was just to
make sure that everybody was on the same
was on the same page for for can
separate type and value unification how
do we do that in hands well so what we
have basically is we have this world
here right which is the NPO
okay we have objects which are actually
types and we have functions which are
meta functions okay and we have this
other world fusion where objects are
well usual C++ objects and functions are
usual C++ functions and my goal is to
show that there is some kind of
embedding from this world into this
world
my goal is basically to find a bridge
that makes it possible to go from this
world here to this world and back and
back again and if I can keep all the
information from this world here when I
embed it in in the fusion world then
we'll have a way to perform type level
computations inside value inside the
fusion world yeah so the question is
isn't this already the purpose of fusion
well it turns out that you can't do type
although computations with fusion
because you can't instantiate a fusion
vector with Boyden it tricky part yeah
that there's a thing the people
sometimes and when I first started
considering this problem I was like okay
so basically the NPL is the result of
namespace of fusion it isn't because you
can't have like incomplete types and
stuff like that so it won't work just
like you can't instantiate a top-off
with void in it because it's going to
say like I can't have a memory that's a
void all right and so it's actually
trivial we take a we take a type okay
and we associate just wrap it in a dummy
type wrapper and and in our fusion world
we're going to consider these objects to
be our types that's it okay and then I
use and yeah for now just leave this
empty there's gonna be something here
but for now it for this part you know of
the bridge for going from type to value
you can just leave this empty and then
using a variable template we can make
this more cute so
so yeah basically if you want to
represent an INT in Hana or in the
fusion world you just you just trivially
wrap it into the type wrapper and then
you have an object that represents and
is everybody following okay and now I
know it's pretty much useless right now
I agree okay what we're gonna do now is
find a way to trace that bridge but in
the other the other way around and it's
actually very easy just make type
wrapper a new every metal function class
I made a function sorry in the booth MP
up sense okay now what happens if you
give me a type angry bracket T right
which is actually a type wrapper if you
give me that I can an object of that
type I can just use deco type then I get
a real type wrapper of T and then I
fetch the actual T by using column
column type so I'm able to take a type
to represent it as a value and then to
take a value but not any value a type
wrapper and re and bring it back to the
NPR world Freddy use this so far but but
but still this is like we're we're
building or embedding right now okay and
now let's so we lifted our objects right
from types to values and and the other
way around what happens when we try to
lift meta functions yeah
maybe come back
so here I'm implementing a head pointer
tread okay as as a you know as a
function in the value world this I
expect it to be a type wrapper some kind
of T capital I retrieve it using the
vehicle type column column type tray
okay and then I apply an arbitrary type
computation so I receive an object in
from the fusion world inside my lambda
okay then I I take this subject bring it
back to the NPR world do whatever
computation type computation I want here
now in this example is just to that
point with T whatever okay it could be
anything any made of any MPL stuff that
you wrote whatever it could be anything
and then just you shove it back into the
value world by just wrapping it again in
the type wrapper here so what we've done
is really do an arbitrary type
computation with value syntax okay and
that's cool because because then we can
put these guys but these but these guys
in two tuples right yeah the question is
would that make sense to turn this here
into a context where it would but you
can't in the current language but it
would but it wouldn't so you would be
able to call add pointer inside a
constant expression which is kind of
cool but but but that just what it gives
you like it works even if you don't
you're just not gonna be able to yeah it
works the same without you don't gain
like a core functionality
okay and it turns out that this lifting
process of taking an arbitrary minute
function and turning it into a function
is Jerry so you're this is a variable
template a suppose 40 variable template
taking a template template parameter
right so f is an arbitrary meta function
and then so you give me a minute
function f and I give you a lambda that
works and type wrappers and that just
applies the meta function to those types
and then and then hides you know the
result back perhaps the result back into
the integrator grabbers so this is a
genuine me an animator function and from
that from the MPO world I'm gonna turn
it into a meta function or whatever
however you want to call it right in the
value world and this is pretty cool
because it means that whatever you wrote
that worked with the MPL you can now
just meadow function it works with Anna
of course it also works for meta
function classes so say just the same
right so here I use a template apply and
blah blah blah but it's just a sign and
it works for template so when you are
yeah so if you give me a template I'm
just going to instantiate it with the
content of the of the type of the types
that you gave me right so what does that
give us these these left they allow is
to use a function application syntax
here to do type computations so yeah and
then so when you apply it it gives you a
type stood topple a type wrapper you
know that contains to topple of intend
chart and then when you decode pipe
Colin Colin type it you get baddest you
get back this to topple and char so
that's the way we can just unify MPL and
fusion because these guys these these
are objects right so you can just show
them into tuples so you can do whatever
you want with them in the fusion world
everybody following
so this is like the yeah when when that
clicked I was like okay I think we got
it
and yeah so Hanna building blocks so
like all so like all generic libraries
generic oh yeah libraries in general
programming anna is built around
concepts that live mostly in the
documentation and models of these
concepts and so that's what I'm going to
present I'm going to present the
concepts and also a couple of models
along the way so first yeah and the
concept I become from functional
programming so you might not be really
familiar with them but the it's it's a
way to split things that works very well
and I know it by experience so foldable
a foldable is any data structure that
can be linearized so it could be a
couple it could be a pair it could be
some kind of optional it could be a tree
whatever as long as you can take the
elements inside of your structure and
put them one after the other in a line
right your affordable and it turns out
that you can do a lot of useful stuff
with it for example you can you can take
all the elements inside a structure and
call and call a function right with the
linearization with all the elements in
in there linearized form as long of
course as the as you know the number of
elements that can happen
so this is the proposed to deploy it is
just one function from the interface of
followers okay this is the proposed to
state apply it you give it a couple or
anything that can be folded so you can
give it also you know maybe which is a
compile time still optional provided in
Hanna or stood topple or Hanna topple or
a hannah range which which looks pretty
much like I stood in two integer
sequence and so on and you can unpack
them so call any function with with
their contents then you can count the
elements of a structure that satisfy
some predicate you can also fold
left which is equivalent to accumulate
still accumulate you can compute the sum
computed predict counts the number of
elements in the structure and so on so
these are useful algorithms iterable
iterable represents data structures so
foldables that can also be that can be
linearized but one element at a time so
in a strict in the strict cont context
in the strict evaluation context these
two concepts are different but if you
are in the in like in a non strict
evaluation context like in haskell these
two concepts actually coincide so i
won't really dive into this into this
it's not the goal but it's an
interesting observation for those that
know let's go so you can fetch the first
element of a iterable the last one you
can go at a random index you can you can
drop any number of elements from you
know any prefix of such a data structure
and and you can do other stuff like yeah
dropping elements from the front of the
structure while some predicate or entail
some predicate is satisfied and so on so
useful to you then searchable represents
data structure is that that associate
keys to values but the keys do not have
to be they can be the same as the values
so for example a topple can be searched
and we also provide a map to compile and
map it can be searched so you can find
you can find the basically you can find
the value associated to a given key or
you can find the value associated to a
key that satisfy some predicate or you
can you can ask where is this is this
structure a subset of this other
structure and these kinds of methods of
algorithms
and list this represents data structures
that are basically isomorphic to us the
double and the reason why it's useful to
have to have to have this concept even
though there is no wiggle room for you
know for the way the models are modeling
the concept because they are all
isomorphic is because it still useful to
have different implementations so they
do the same thing but implemented
differently so so of course Hannah Topol
is a list stood Topol is a list boost
fusion vector is a list boost fusion
list is a list and and so on and you can
do a lot of stuff with list you can
concatenate them you can you can slice
them you can reverse you can compute all
the permutations you can filter them you
can do there are probably like three
algorithms or something that you can do
and them so it's pretty it's pretty
flexible yeah you can also take like you
can also take a perfect of any length or
a prefix determined determined by a
predicate in noise and so on so these
are like I love Allegro names yes okay
so the question is are these only
wrappers over like the MPL algorithms
and so on no they're not no they're not
because you can use look this doesn't
exist in the NPL that's a string that's
that's completely runtime and yeah by
the way I didn't say it but all the code
that you see on the slides is actually
it works it's it like it's complete
composed I just couldn't face it from
from suicides and and sometimes I do
minor modifications but yeah it works so
you know in the MPL this just doesn't
make sense this is completely dynamic
string right and I'm concatenate again
okay no not here
okay here right so I'm I'm I'm modifying
a top oh that has some something
completely dynamic there's that dynamic
allocation in there so no the NPL just
it's this is much much much more
flexible than Dampier
and this example I think everything
that's here can be done with Fusion
except perhaps this part here but yeah
so no there are not just rappers functor
okay so functor the word is kind of
misused in C++ but this is actually a
concept from category theory and in this
talk whenever you hear factor I'm gonna
refer to that and if I want to talk
about a function or a function object or
a lambda I'm gonna use that word so it
represents structures that can be mapped
over so it's like a container of
whatever you give me a function and I'm
gonna map the function over each element
in that container and give you back a
container that contains you know the
result of the mapping so it's basically
any structure that can be stood
transformed basically so once you get
once you're able to transform something
you can also apply a function on each
element that that satisfies some
predicate and you can also you know
replace the elements that satisfy some
predicate by just you know by just using
that this to transform with fancy
functions so so functor is really can be
basically mapped over and so you can
functor is the models of functors
that that and it provides our like maybe
which are which is like a compile-time
optional topple and I'm think I'm
forgetting some but that's basically
what I see right now yes
I'm so red
yes a function underscore this is not
this is not a lifted this is the plus
actually know what well we're only okay
so the question is can this be does this
have to be a runtime function right and
the thing is this is a generic longer
okay the the line between your runtime
function and compile time function for
whatever that means is just blurry
because this can if this is like a
student Agrella constant here if this is
like a Hana integral this is gonna
return this is just gonna return you
know so the interval plus itself which
is again an integral value is known at
compile time the compiler is just going
to completely elide that function right
so the value will be actually containing
the type in the return type of that
lambda so you can use yeah it sure if
you have a yeah sure if you want you can
use a lifted meta function here but then
whatever you map that the twice on is
going to be a container that contains
that contains type wrappers because many
functions even lifted only working and
type wrappers does that make sense is
everybody still following or did all you
someone okay
right and then record so it's probably
the thing that's most useful for for
everybody here
so usually defined structures so you
define your structure and basically it
gives you the ability to use it as a
compile time map you can fold it and you
can you can also transform it
I mean convert it to a map where you can
do more processing if you want and so
Hannah provides this macro to to
intrusively intrusively turn your
structure into into like a Hannah and I
record right which is basically the same
as boost fusion adapt or define struct
or stuff like that and there's also a
way to do it and intrusively but I
didn't show him show it here but yeah so
it's possible and you can also do it
just without without a macro if you want
it's quite simple it's documented yep
yeah sorry I didn't introduce it yeah so
basically yeah okay so I've got a lot of
stuff and sometimes I'm just try I just
hope that people will be like oh okay
this is kind of intuitive so basically
this return type wrapper returns a type
wrapper with the deckle type of this
expression so it's just a dummy way to
create a unique tag right because this
type here has to be unique and it's good
it's gonna be comparable at compile time
so like when you compare when you
compare this guy with another let's say
with this one it returns false
well stood false type and and when you
compare it with itself it returns to
true type because you can compare type
wrappers too
yeah exactly
this is this object yeah exactly so that
besa type wrapper yeah
and so comparing two types that were you
know lifted to the value level with type
wrappers is just it just does is same so
it returns a stood in through a constant
wool a comma studies same T and u right
yeah yeah whatever yeah sure I could
have used like just a student to grow a
constant as long as these guys are
different so then just anything that can
be converted kebab yes so sorry I should
have explained that sir
okay so yeah you can adapt your own
structure okay comfortable basically
inequality comparable concept for a
retro Regina stuff or durable stuff with
a strict quick ordering to it's less
than comfortable but for its original
stuff okay and Anna also provides a
consistent numeric hierarchy so it's
useful when you need it but basically
these are their arithmetic you know the
usual arithmetic stuff from abstract
algebra so the the hierarchy is split
well because it's useful when you need
it but otherwise you don't really need
to to bang your head against it so and
there's more like applicative monad
traversable of logical and under stuff
that's more either important for the
implementation or more functional so I'm
not really presenting it but but it also
exists and it's often useful right ok
case studies so we're off we true the
questions at this point it can be like
related to something more philosophical
about the library yeah
so the question is in fusion when you
like transform a sequence you return it
returns of view that's lazily evaluated
what would what does Hanna do know I
know there's a return of you
it actually maps a function yeah and so
for runtime performance
it might do a difference but it will do
a difference yep nothing the question is
the question is what does in what
what does Hanna not do that you can do
in a peel infusion
well nothing because it's really a
strict superset I actually took the
examples from fusion and MPL
documentation and rio implemented them
with Hana like a couple weeks ago when I
was writing the library and I just
wanted to make sure like okay I can do
that
I can do that I can do that I can do
that there's I think there's like lower
bound and upper bound for the MPLA
that's not implemented but seriously I
don't think it's useful either so yeah
it's it's a genius Combinator's because
yeah so H heterogeneous and convene
editors so it's pretty lame lame but
yeah I needed you know for another
acronym that sounded all right and
people wouldn't forget so I think this
is this is correct and company owners
are like stuff in function really
functional programming they're like
functions that do not have state
basically okay so taste at least let's
revisit our loop and rolling example
from earlier so well I do here I create
a range which is basically a integer
sequence but more flexible because you
can specify whatever you know the
beginning and the end and then I I for
reach over it and every time I just
ignored the argument here and every time
I'm just going to call the function okay
and so yeah and then I just call it with
whatever and I want so I like if
everything works I'm just gonna call
ffffff n times alright and now when you
compile it this is what it gives
so with all three the compiler the
compiler is really just doing what we
want him to do so this is a call to
vvvvv etc so this is what we would
actually type computations revisited
okay so we wanted to find out what was
the smallest type in you know you give
me a couple of types I'm gonna give you
the one with the smallest size so don't
get put off by this part here I'm gonna
explain it okay what happens here you
give me a couple of teeth I shove it
into a topo to do that I need to wrap
them in two in two types so I create a
couple of types and then I find the
minimum with a custom predicate which
I'm gonna explain
so with a custom predicate and so this
is gonna return right the minimum
element with respect to that to the
custom predicate so it's gonna return
some kind of type of type angle bracket
T okay one of these T and what I did
I'll type that I get back to some kind
of type wrapper so this is actually a
metal function because when I fetch conk
on type instead of inside our smallest
I'm getting the type that's inside the
type wrapper okay so this is really a
different way to implement an inner
function that would be let's just say
different in India okay and now the
special here the become predator so size
of it takes the type wrapper and returns
the student to our concert well actually
Hana integral constant that contains its
size of okay so that's like a lifted
size up and an ordering it basically
it's a predicate that it returns a
predicate that takes like like a and B
and then cause whatever function you
give it so in our case size of and then
returns whether the first one is less
than the other so it's it's yeah I stole
that from s :
and this gives us a very expressive way
right to to to express what we mean I
mean you can actually read this like
English or almost and this is a frigging
minute function so I think this is neat
and it works so here I just fetch the
Colin Colin type and that's just a
minute function is everybody alright
with this example okay now we want to
determine the optimal ordering to the
earth optimal ordering in which to
declare the members of structure right
to minimize the alignment requirement so
I read in Stack Overflow that the way to
do that was to or a good rule of thumb
was was to order them in decreasing
order of element requirement so let's
just assume that it's a right way to do
and it really pro with this kind of
stuff but what I do here is so you give
me a couple of types right and then I
shove it into and I show them into a
tuple okay and then I'm gonna sort them
just like we said I'm gonna sort them in
decreasing order of of element okay here
the predicate what it does okay so these
guys here are in fixed application so
this is equivalent to saying on parens
greater comma treta as to the length of
blah blah blah okay it's just a quote
it's in fixed application but you can
but it's still in but it improves the
expressivity by quite a bit so you can
sort you give it a predicate and then
it's basically the same as ordering from
the last slide right but now you get a
custom predicate here which is greater
is everybody I like being clearer so it
applies applies the tread element AB
which returns a steady integral constant
containing the elements of whatever it's
given of the type wrapper is given okay
and then it applies that and then it
applies yeah so that made of that
function here to each of its argument
and then compares it them with greater
so we're really
yeah ordering them in decreasing order
of element requirement and now you might
be saying like a but this is completely
useless because it's actually a variable
template so it's returning some kind of
topple some some kind of sorted couple
of type wrappers and that's true but but
wait so yeah okay so exact this this is
absolutely exactly true okay it's just a
couple of type wrappers and it's useless
so far but now you can do something
useful with it you might you might I
don't know fetch the first element you
might unpack it into a template to
create a specialization it could be a
topo or it could also be a user defined
type whatever you can you can fold it if
you want you can do whatever you want
with it now and yeah so now I just I
decided to unpack it into a tuple which
we into yeah into a to instantiate a
double specialization right with with
with its contents and that's what it
gave is everybody following okay so it's
a very different way to perform type
level computations we're not used to it
but it works and I think I actually
think it's more it's it's near it looks
better yep
okay so I'll repeat the question and you
tell me if I'm in the city correctly so
is there a way to like order them right
and to return the top oh but that the
top of such that the indexing is that
are the first of all am i yes okay so D
what is it possible mm-hmm we're
required a bit of work like maybe a
quick hack to do it right now I'd say
like you could zip I'm not exactly sure
oh you would do it for sure as possible
but like you'll have to work a bit sure
and yeah because it's it's pretty
specific to you know your your own
application or if you can find that it's
actually a general pattern then I will
very happily add it to Hanna but yeah it
would be possible you would have to work
a bit expression templates okay so do I
have that um okay I think you know what
actually skip the this example and also
the next one because I I don't want to
run out of time but we'll go back if we
have time at the end okay so basically
what I'm showing here is just a quick
and dirty way it's a quick
implementation of proto right it's like
250 lines and it works it's very very
basic but and I just want I wanted to
show like oh and I can help do this but
it's not the most interesting examples
always give it there's also this
erroneous linear algebra library that
allows you to build to have like
mattresses in which each entry of the
matrix can have a different type so it
can be useful to you know to
to carry the units inside a matrix to
make sure that the units fit when you do
your computations so that was actually
inspired by a real real real real world
use days by exact Lane which is just
here so it was yeah it was I basically
tried to re-implement a library that
yeah that yeah I'd already done using
Hannah and it's pretty naive but it's
also like just 200 something lines so
okay implementation techniques yeah so I
want to take my time here because and
we'll go back if we have them so
basically everything we manipulate in
Hannah the most basic structure that we
manipulate is a topple right and so we'd
like to have a an efficient way to
implement topple and in Lib C++ for
example top was implemented in a kind of
recursive way and and and it actually
sucks at compile time really the
performance actually really sucks so
here's my take on it wait so the meet
the real interesting stuff happens here
okay and listen okay what what happens
here the idea is that I use the lambda
capture as a compiler generated struct
with a very big number of elements right
so I use the fact that we can capture a
very attic back inside of lambda okay to
make the compiler generate a struct with
these members for me okay and now that
lambda that captures the elements okay
which is actually like the topple so the
lambda is the topple when you call it
you call it with a function when you
call it with a function and and it now I
can show it in it so you call it with a
function this is the topple this is like
the core of the topple it captures here
the elements when you call it with a
function
it shows its guts to the function here
it expands all the members inside of the
top oh it it provides a unpacked
representation of the of the elements in
the tupple it provides that to the
function okay and that here is just
boilerplate to make this into a type so
okay no problem it can become sex prayer
because we don't have you know lambda
can sex print in the language I really
wish this will change we'll talk about
it later but yeah so that's the the idea
is everybody kind of following me here's
how you can use it if you want to
retrieve the first element in the top of
implement it this way you pass it a
function that just consider is the first
element discards the rest and returns
the first element and then you so this
is like a pole this is actually the
lambda so the core of the topic and you
pass it your function so it will give
you the expanded representation of the
members of the topo here and you pick
whatever you want so then you can have a
way to you know fetch efficiently an
argument at a given index and it's
possible it's been implemented I got
this in the bonuses yeah sorry oh it's
there so this is this is basically
unpack into error is just this function
okay okay so yeah so you know you give
me
you give me any number of elements and
then I just make the storage which is I
create the function then store it in the
unpacking to air and then so when you
access it here and back into you're
actually referring to the lender to
lender right here
is everybody following yep okay so
that's it that's a that's a idea and
performance yep yep yeah okay yes sir I
should have yeah okay so the question is
there is no ref ref are you capturing
your references our goal here is to
actually capture is to make a copy right
when you when you call us to make make
topple you actually make a copy of
whatever you're giving it because just
your starting starting it in the top Oh
what what I'm not sure but I would use
like reference wrapper for that anyway
but but but if you can and you know like
this is naive and I don't do perfect
forwarding here but yeah well here yes
but you know so I stripped a lot of
stuff from these from these slides
because I want to make it just easier to
understand and there are also some
implementation issues that I won't talk
about so it might require some little
changes to the language or I would say
enhancements but I think this is worth
it so the green ear is to double this is
a bad bad bad you know it's a bad girl
and this is Hannah right and this is
fusion
so it just including it it's like 15
second right yeah and then it just dies
at 50 because you can't have a larger
than 50 and the reason I think the
reason why you know it seems to be sort
of the same as in that Pepsi I
sympathetics here it would be because
well it's probably free processed in
such a way that you know even a large
duffle is just actually one one okay
yeah so I got a confirmation for some
from someone that really knows it it's
stuff so yeah it's actually the reason
so yeah it's much better with with this
new implementation
same for the memory usage and now
another function so what's really neat
about these things is that when you use
this new alternative way to implement a
topo you also there are new ways to
implement the related operations that
that are now open to you so for example
topo cap you just dive into the guts of
the first double okay and yeah once you
once you can't a polecat right 2-tuples
you just can do it recursively by
folding you can do it for any number of
doubles so we're just considering the
two element the to double case so you
dive into the guts of the first double
now you get an expanded representation
of the first Apple as a parameter back
then you just do it again for the second
double so you get another parameter back
they represents the guts of the second
double and then you just concatenate
these packs which is very easy to do
into a new new double so that's it again
okay yeah I'd like to say that the
benchmarks are somewhat biased because
it's it's because the the benchmarks
will actually also come will also the
difference between the curves will also
contain the difference you know for just
creating the topple so it's a it's
pretty hard to do unbiased benchmarks
but I gotta be honest it's not like the
perfect the most perfect benchmarks but
still so this is ugly this is not bad
it's it's pretty you know it's well it's
decent at least yeah and so if you ever
need to concatenate like two vector two
tuples of 450 elements then please i
want your email yes you're doing so like
art per staff yeah same for the memory
uses okay so now what I need from the
next version of the language right
because this all works but it could be
better it could be much much better and
we just have to make put a bit of
pressure if if if we think that this is
a good way to go you know for metaphor
then we got to push the language a bit
if we don't then you know just it's just
it's just a cool experiment
cool google Summer of Code project
doesn't nobody's gonna ever use but if
we think that it's really worthwhile
then we might want to push the language
a bit but I can do it just by myself
contact Berlin does I want you two to
stick a Const exper in front of the of
the of the constructor of the structure
that is generated by the compiler and
also in front of its operator parents
that's just reasonable there is I don't
I don't see any reason why why it that
way and yeah I'd like that to change
I need lenders in some an evaluative
context I know there are some issues
implementation issues with with this for
example if you have like the type of I
think if you have the type of the lambda
inside a that needs to be an external
symbol then it's it's pretty hard
because you have to like make sure that
this type is different from all the
other types because lambdas are unique
types and so you get into into some
weird stuff but but it's actually like a
corner case and I don't think a lot of
people would like to have this feature
anyway I don't need it but but I would
preventing you know lenders from
appearing in all and evaluated contexts
even if they're called
you know I don't need the actual they
call type of the lambda I just wanted to
be able to I just want it to appear
inside the context the unevaluated
context and if I call it so so
preventing that from happening just just
to make sure that that the lambda the
the types of the lambdas don't appear
like in end types is just like using a
new tequila mouse so I'd like that to
change
and I'd like a bit better handling of
peridot packs in captures so for example
here I'd like to be able to do an image
capture with a parameter back so why
should be apparently back here
initialize with copies of X this is
useful for some you know implementation
Stephanie for example for the topple
this would be I need that to be able to
perfectly forward to use perfect
forwarding from the arguments and to
like to initialize you know the members
of the top off perfectly I need that for
this reason so so yeah so okay it's all
I have
so thank you very much so other
questions and we still yeah questions
and we have five minutes I yeah
any questions yeah this hasn't no no no
this hasn't okay the question is is this
in to boost my answer is no it isn't
we're working hard for it I really want
that that interview is yeah and
eventually eventually understand or door
I don't know might be able at you
because yeah I see I see some kind of
you know people are pushing to have
still apply and more to pull related
stuff well my my take on this is like
let's do it well okay yep okay yeah so
um this is claimed rank actually so yeah
C++ 14 but you know bug free
implementation so that's clean good you
need Clank trying to compile it GCC
won't work playing 2.5 unfortunately it
won't work I don't know why but they
close the branch did you know the you
close the branch for for the release
just a bit too too early and bug fix
some bug fixes they didn't get in
because it won't compile yep
I don't get it certain Jews weave
reference it first okay so the question
is let's say I have a tuple with objects
in it and I want to add the view like a
subview of only some elements right you
just remove okay so first what I would
do is store reference wrappers into the
tuples okay because right now by the way
right now
it's like use use it with you know
friendly types because if you have too
much copy it's gonna be it right now
it's it's not really it's not really
optimized for the redline so I would say
first you use reference wrappers into
the first double okay if you sell your
objects are big and then you just remove
the objects that you're not interested
what
well right now okay so the reason is the
question is do I really have to you know
jump with to use reference rapper to and
jump around to which is more complicated
right to get reference emetics okay so
right now it's only value semantics I
wanted to get an interface right I did I
focused on compiling performance and on
on you know correctness of a design but
not on runtime performance so right now
perfect for reading is that implemented
everywhere value semantics all all over
the place so if you want if you need to
reference semantics you're gonna have to
give me a bit more time yeah but it yeah
yeah yeah okay so a comment is it would
be simple to have just like any views
that do the actual reference jumping
around and yeah it would be pretty
simple I couldn't look into that sure
and I will because I think people will
want to preference semantics at some
point differently but right now it's
still a bit experimental yep
okay so the comment is that you might
not actually want reference and I think
so to use reference rappers as much as
you think so okay so I'm not really
gonna comment on that so but I think it
could be possible to make it easier to
have your friend semantics and use it if
you need it
whatever I don't care so yeah so if
there was no more questions well we're
actually out of time so we're gonna stop
here but if some people are interested I
got some some more stuff you know like
more implementation techniques this is
to access an element that a random
access in mortised of one this is the
proposed still apply which fits in one
line pretty cool you just unpack the
function in and other stuff so just come
talk to me if you're interested thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>