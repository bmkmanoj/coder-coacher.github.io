<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Arthur O'Dwyer “Template Normal Programming (part 1 of 2)” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Arthur O'Dwyer “Template Normal Programming (part 1 of 2)” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Arthur O'Dwyer “Template Normal Programming (part 1 of 2)”</b></h2><h5 class="post__date">2016-09-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vwrXHznaYLA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone to part one of template
normal programming
this is template metaprogramming without
the metal part I will be your your guide
on next 2 hours and 15 minutes and I say
that because we might go into the break
who knows but yeah what are we actually
talking about here what do you what
should you expect to get out of this
particular talk well so I looked up the
definition of meta programming about the
definition of programming respectively
and what fetus's programming is the
craft of writing useful maintainable
extensible source code which can be
interpreted or compiled by a computing
system to perform a meaningful task
meaningful task out the meta programming
that according to the designer of
someone in the audience knows which
language this guy designed I forget the
writing of computer programs that
manipulate other programs or themselves
as if they were data and I got the
impression go into a lot of talks at
conferences like this that we're about
templates in general they ended up being
about template metaprogramming which is
to say programs that spend a lot of time
manipulating themselves and not a lot of
time performing meaningful tasks so i
thought i would try to give the the
beginner's overview of what what are
templates how do we use them how can we
use them effectively
and do it without mentioning spin it and
do it without mentioning type traits but
still give you some interesting stuff I
hope this will be interesting this is
stuff that was interesting to me writing
it so it'll be interesting to you
hearing it so a motivation what our
templates why are they in C++ to begin
with presumably everyone has seen a
slide something like this before in C++
well in C we have a function like abs
and it takes an int and returns and
ian's and in c99
well you know later on they realized
that they also need a version of this
for long and they need one for a long
long and by the time you get to see 99
you have about a dozen absolute value
functions in the language and they all
have different names this is fun but we
can spend more time to do a meaningful
tasks in less time
manipulating our programs if we allow
function overloading
so C++ from the very beginning allowed
function overloading you can have
functions that take different types and
return different values and maybe even
do different things and we would like to
even even writing this as too much code
for us right we'd like to collapse it
into some sort of template there's a
function template is not a function it
is a template this is a template for
making a function and it looks something
like this and it gives us a recipe for
stamping out copies of the ABS function
with different T's right you can get abs
of int from this you get a double from
this and so on and we don't pay for what
we don't use
right that with the overloaded version
we have two functions we compile we code
gen two functions so we pay for two
functions all the time in this version
we can through the magic of implicit
instantiation which we'll see you in a
minute and by a minute I'm in two hours
you know you won't instantiate the the
code at all using a function template
looks something like this again so down
here where we make the call to it we
have to tell it what kind o how to
instantiate this template what what is
the type T that we're instantiating it
for and this is the simplest possible
way to do that you just say the function
name or the temp the template name the
name of the function template abs and
you give it a template argument T in
angle brackets makes sense right it will
not be instantiated with any particular
type through until you the programmer
explicitly mentioned that you would like
it instantiated for absolute value of
foo as soon as you mentioned that the
compiler has to go instantiate it in
order to figure out you know what is its
return type what are its argument types
and so on now sometimes the compiler can
deduce that you mean an absolute value
of foo for example in this case I can
actually deduce both of those but we'll
talk about deduction later hold that
thought until slide 21 it says but then
I rearranged all the slides so I don't
know I don't know when that slide is
coming we have the same concept for
generic types right generic functions
generic types we've also had seen this
sort of thing if you've done any C you
know you manipulate a lot of void stars
and you have no type safety type punning
error error-prone ugly or you could have
something like this where maybe you
generate this using some macros of some
sort
we have my list of ins in my list of
double obviously we'd like to have on my
list of T and you probably go up my list
of T macro if your programming and C n n
C++ we formalize that by making class
templates again a class template is not
a class it's a template for making a
class making many classes that follow
the same basic outline of stuff and
don't pay for what you don't use if
nobody uses my plus dependent won't be
instantiated by the compiler at all
template classes are still class that's
why twice I've said the opposite didn't
I well we have some terms of art here
sometimes when people say template class
they mean class template which is not a
class as a template however some people
like I think Scott Myers and possibly
even the standard when you reverse the
words a template class is a class
generated from a template a template
function is a function generated from a
template so if I have a if I have a
class template and I use it to generate
a particular class such as in this case
well in this case I know the template
yet but I will fill we're like s of int
that itself is still a class and it
follows all the general rules for making
classes such as your static data members
have to be defined somewhere if you want
to use them so here I have a class that
is not a template classes just a regular
class struct s and has a static data
member and I try to use it in main and
it tells me well like I'm undefined
reference in the linker right how many
people have seen a linker area that
looks like that from trying to use
static data members all right yeah and
then you do this and it works and that's
awesome and then you do this and it
breaks again how many people have seen
this yeah templates suck right but they
followed all the same rules of the
regular classes right just just like in
this case where I didn't define SDM well
if I had a definition now of course my
definition needs to be templated right
because you know I I don't know which
STM
use yet but if I make a template for
stamping out that definition then it
ends up working just fine now the
interesting thing about this about this
particular example is that I can
actually put that definition of that
static data member in the header file
for a template I can I can't put that in
the header file for the regular old s
where it wasn't the template but when
it's a template I can just sort of shove
everything in a header file and it
basically works that's actually kind of
interesting is you can't do that with
normal things but you can't do it with
inline things right in line functions
and as so C++ 17 we have inline
variables which we want to talk about
this morning he hates them but I love
them because why can't you just put
inline on everything it makes sense just
throw it all in a header file and it all
works well so the same rules basically
if you think about how inline function
work the same rules govern how templates
work basically more or less if you can
make something work with inline you can
probably make the exact same thing work
with template and we'll see that more
later when we get into instantiation
rules which was the slide formerly known
as slide 21 I think right cool oh I
forgot to mention entirely let's go all
the way back the beginning by the way I
have three links at the bottom here the
first link is a link to the current
draft standard which is freely available
the draft standard for the C++
programming language it's in for 606 and
whenever in the lower right hand corner
of these slides you see a little thing
in purple that refers less like a
section number and all that you can
actually go look up in the standard for
those of you in the audience who like
looking at the standard don't go to
Netflix but you know do do read the
standard I guess it's not multi-gigabyte
yet and the two other links here wand
box is a free way of compiling code on
line as long as it fits in the single
translation unit you can use GCC or
clang and find out what their output is
for particular thing you can test that
that code works in current like top of
tree clang and GCC and web compiler
clavinet
a Microsoft thing does the same thing
for some version of MS VC I'm not sure
which but if you want to test things on
FS VC that's another way you can do that
as long as the internet works which
apparently doesn't quite at the moment
alright so down here when you see the
little reference to n for 606 section 3
but that's what that's referring to and
it's where you can go for more
information if you want it about B
wording the government's inline
functions and also templates so there
are two relatively new kinds of
templates that the kinds of cover
already function templates in class
templates those have existed basically
forever they were to C++ 98 in C++ 11
we got alias templates and in C++ 14 we
got variable templates I'm going to talk
about variable templates first because
they're a lot like class templates in
fact they're basically syntactic sugar
they're basically syntactic sugar for
static data members of class templates
so here we have an example of a a class
template with a static data member named
value and it's static and it happens to
be Const or bullion and those those bits
don't matter but it's static and we can
print out its value and so on and forget
the some expression for now here's the
variable template version of this it's
very similar except we took out all the
class bits because it turned out we
didn't really want them they were just
sort of extraneous we needed them in C++
98 - to get this functionality but now
we have variable templates and they just
look like this right it's still a
template and then it looks like a
variable declaration notice the word
static is gone because it's no longer a
static data member now which is the
regular old data variable global
variable and we can initialize it the
same way and we can stick this in a
header and it will magically work by the
same rules that make inline Moe inline
variables network for things in the STL
by the way we get the best of both
worlds in that stuff that's been around
for a long time will tend to be
implemented as these structs like is boy
this is a type trait which I'm not going
to talk about much but you have is void
here with a with a static context / bool
data member
then we have another outside of the
class we have this free-floating global
variable called is void underscore V
that's just defined as the value of the
class so when you see all these
underscore V's and underscore T's they
tend to be Ilyas as for things that
already exist and this is a nice pattern
to follow in your old in your own code
if you're writing things like type
trades which I'm not going to cover much
because I'm not going to talk about
metaprogramming
so the question previous slide oh why
would I write something like this given
that the the fact that the template is
not really being used well depends on
what some expression is some expression
could be something that depends on T in
fact in this case it should be something
that depends on T because if T is void
we want it to come out the true and if T
is Introit want to come out false but
that's metaprogramming I'll show that
later
any other questions by the way we're
going through a bunch of slides already
cool all right so let's talk about alias
templates that this is a different kind
of beast for reasons that we'll see but
you can think about the basic idea the
same way in C++ oh three and of course
in C we have type deaths and right
around C++ eleven they decided that the
name for these things was not really
type def so they were really aliases
let's call them aliases but it means the
same thing it's a one type being an
alias a synonym for another type and so
you can take as in this example I have
the old type def syntax to make my back
int I then make a very similar thing
called my back double using the C++
eleven alias syntax they doesn't
actually use the word alias that uses
the word using so maybe they should have
called the musings and then also in C++
eleven we got the ability to take this
new syntax not the old type def syntax
forget the old type def cindex ever
existed but we can take the new syntax
for making aliases and we can make
templates for stamping out aliases all
right
is an alias template and so by itself it
does nothing but when I instantiate it
as with the the last line here and I say
my feko float it'll go and it will say
okay well how do I make a my FAC of I
say I would use the alias template and
San Shi a tit for float and it becomes
oh it's a stood vector a float I get it
and in fact those become the exact same
type right they are literally kind of
already made this point but just a
hammer this in they're literally the
same type so if I have this function f
that takes a my int which happens to be
an alias for int I can pass an int to it
alright I to have an int I pass it a
function expecting my end and it just
works because they're they're the same
type likewise I can have a state vector
event and I can pass it to a function
expecting a reference to my back event
and it will just work because they're
exactly the same type you know one is
not derived from the other it doesn't
have a member type the member type def
that comes out some they're literally
just exactly the same type as if they as
if you had used a regular alias to make
them synonyms alright so now we've
actually covered we hit a milestone here
this is meaningful we now know all the
different kinds of templates in C++ 11
or in sequel + 14 rather and they're
exactly the same as they are in sequel
17 we didn't get any new clients in 17
so now you're completely up to date with
C++ 17 so let's talk about type
deduction hey look at that it's still
slide 21 awesome
so type deduction alright so we're back
at this day where we're trying to use
abs which is a function template and
we're trying to instantiate it for a
particular type T and we just we just
want to use it without all of this extra
angle bracket syntax so here's how it
works I skip anything no this is how you
might experiment and find out for
yourself what type T is deduced for
various kinds of call expressions
I should explain the at the very top
here where it says
of pretty function how many people in
the room have seen pretty function how
many people in the room haven't seen
pretty function nice it's like 40 40 60
and 50 50 so what is pretty so pretty
function how many people have seen under
under function under under okay so all
of these are magic macros basically
they're they're expanded sort of by the
preprocessor sort of and for example
under under function under under expands
the name of the function so if I'm in a
function called main then under under
function under under expands to the
string main and I can use that just like
a where a string literal be it's just
like under under file under under line
right they just expand to these
constants that I can use as if they were
macro substituted it so function expands
to the name of the function
pretty function in GCC and clang expands
to a pretty printed name of the function
that just happens to include is it a
template and what are its template
parameters and what were they did do
stairs right so when I put as pretty
function I actually get something out
you see those comments there that is
literally what this code prints I've run
this code and it will actually print a
void foo Bren T bracket T equals and
close bracket newline so this is super
useful if you're ever trying to get into
the the nitty-gritty of type deduction
or which which of my templates is
getting cold
or why is T deducing as something I
didn't expect it to using pretty
function is definitely the way to do
that M SVC has something the closest
thing they have to it is something
called func sig with a double
underscores on both sides again it's not
quite as pretty as pretty function but
then it doesn't claim to be okay so in
this case we're just passing in a bunch
of these values and as we expect you
know foo o4 comes out to call foo of int
and through a four point two calls foo
with double foo of hello calls constant
two of constant our star which is
actually a little bit weird if you
recall that
string literals actually have array of
char type but that's just because we're
taking it by value and so it happens to
decay to a pointer and they're Thirds
rules for that but mostly I'm going to
ignore the whole array case because
that's a little scary
but let's let's talk about type
adduction let's go let's go deep here's
the deal with type deduction this was a
particularly trivial case because we had
one template parameter named T and one
single function parameter called X that
just happened to have type T so this is
this is the most trivial case you can
get but in general when I have multiple
template parameters or multiple function
parameters here's what happens first of
all each function parameter by itself
each function parameter can contribute
to the duction of each of the template
parameters or it might not it might it
might not have anything to say about
that template parameter in our case X is
of type T so it definitely contributes
to the deduction of type T and then if I
the second parameter Y it would
contribute to the deduction of whatever
from template parameters it was up all
of these deductions the deductions for X
and deductions for Y deductions for Z
etc are carried out in parallel they
don't really cross talk with each other
so we deduce what what does X tell us
what is y tell us what does Z tell us
and then we compare notes and we say oh
well X told us the T was int Y told us
that u was double okay so I guess T
isn't a newest toggle and we need to
make sure that we deduce all the
template parameters we can and that all
the deductions agree with each other if
X is saying that T is int and Y is
saying that T is double well they can't
both be right there's a disagreement
there and we got a compiler error says
deduced conflicting types for parameter
T and then there's one last rule which
is going to trip us up later which is
that any function parameter that does
contribute to deduction has to match the
function argument type the argument
being me the thing you actually called
it with has to match the type of that
argument
exactly with no implicit conversions no
integer promotions nothing like that and
that the reason is basically to to keep
things from getting out of hand if you
also allow it implicit conversions there
that would just be an extra level of of
maybe accidentally calling the wrong
temple
so so at the very end we lock that down
and say the argument types need to match
exactly so let's look at example let's
look at three examples here we have a
function f this is the the second most
trivial case it has two template
parameters and two function parameters x
and y that each contribute to exactly
one of the template parameters and if I
call F of 1 comma 2 well one is an int
so X is an int so T must be int and
completely separately from that Y is 2
was an int Y is a type u therefore you
must be int and so we deduce the T is
int and you is int and we compare notes
and find out there are no conflicts and
we have to do ste and U and we're all
set okay now with G G has to function
parameters but only one template
parameter T fortunately X says well T is
int Y says T is int they compare notes
they agree yes T is int we we are in
agreement and it works now in the second
G case X says T is int all right type of
one Y says well I got an unsigned value
T is unsigned int and they do this
separately right and then they compare
notes and they say T is in the end
unsigned int nope nope nope that's not a
thing we disagree and so you get an
error no matching function for call to G
of n comma unsigned int and the wording
of the error message may vary a little
bit and doesn't really matter the
important thing is that that's why it
happened the the function parameters
deduced that T was different things and
that's that's the end as far as template
type deduction is concerned you might
say well why doesn't it just like
promote them both to unsigned int or so
like that normally happens but nope
doesn't happen in this case very simple
rules for dim Playtech deduction and we
should be thankful for that because if
they were complicated no who would ever
understand them um certainly not this
entire room in two hours he Felice
question yes that is correct
how many people have seen this anyway
using stood max yeah so here we have a
function f that happens for during a
short or it could return unsigned int or
you know whatever and we just want to a
to max that with 42 right I mean I
didn't even need to make up into X in
this case I could have just said stood
max of F comma zero right and again I
get error no matching function for a
blah blah blah and the reason is the
same thing stood max only has one
template parameter right T and it takes
two arguments type TT X and T Y and in
this case the first X says T is short
and the other one says T is int and they
disagree and you get a hard compiler
error this is one of the downsides of
this rule there's a slide that follows
that but first let's go back to do these
puzzles in order which of these two
calls to Phu ought to compile and which
not what everyone is really digest this
for a little while but then I'm going to
answer it anyway because the answer is
half on the screen so two the first one
takes the the two function or the three
function parameters there's x y&amp;amp;z okay
and we're calling it with a state array
of into a tested array of double four
and 0.0 0.0 is actually part of the
puzzle here right because that's a
double and z is an INT but z doesn't
depend on any type on any of the
template parameters T and u it does not
contribute to deduction in any way all
right because there's nothing we could
possibly put in for Z that would tell us
anything about T or you it's always
supposed to be an
so Z does not participate in type
deduction X on the other hand does what
can X tell us about t and u well it can
tell us exactly what T is right because
if I pass the stood array of in this
case int comma something while T has to
be int there's no way it can be anything
but int so x contributes to the
deduction of T does it contribute to the
deduction of you it tells us the size of
you does that count
turns out not really because that's not
something that the compiler can really
figure out it I mean even if it did try
to figure it out and said okay well I
see that size of you must be eight like
how's it going to record that where
where in its table of information about
you is it going to say well I don't know
what it is but I know it's size maybe
that'll help but that won't help
so it just forgets that X does not
contribute to the duction about you
because it it doesn't tell us anything
directly relevant right T it tells us
exactly what T has to be you it doesn't
tell us anything but the size so we
don't care so from the first parameter
in the first example with still array
into eight X tells us the T is int Y for
the exact same reason tells us that U is
double NZ doesn't matter we compare
notes
none none of our notes disagree and we
know what T is its anthem we know what u
is it's double so now we do that we do
that last step and we check and we say
okay well so that means X has to be of
types that array of int comma sy bolt
size of double is eight on getting a
sitter 8 into 8 yep that all checks out
and it was the same thing for y and yeah
that all checks out and then Z gets an
int but it didn't participate in type
deduction so it so it got a double
that's fine we'll just converted to int
that's fine and so the first line
compiles the second line we go through
all the same type of action we figure
out the T is into the u.s. double and
then we look at that first argument X
which did contribute to the deduction
and it's a sit array of int comma 9
that's not int comma 8 that's a
different type they needed to match
exactly doesn't even matter if there is
an implicit
version there they needed to match
exactly and they don't so that's a hard
error check one following that all right
here's a similar thing in that this is
again inspired by real stories let's say
I have a function foo and it takes a
function pointer of some sort in the
function pointer you know takes one
argument of type a and return something
of type R and luckily I can deduce those
when I pass in a function pointer all
right I can say well if this is double
star f pointer parens int well my guess
R must be double and a must be int and
so deduction will work for RNA the
problem is if I pass it a lambda all
right of lambda a capsule is lambda is
always implicitly convertible to a
function pointer type by the way if you
didn't know that now you know that
lambdas are awesome but being implicitly
convertible to a function pointer type
doesn't help you call foo with it
because again the type needs to match
exactly and the capsule is lambda type
itself while being implicitly
convertible to a function pointer type
is not itself a function pointer type
and so you'll run afoul of that very
last step
protip here is if you absolutely need a
function pointer out of a a foo or sorry
out of a lambda just take a unary Plus
on the front there is no unary plus 4
lambda types but there is a unary plus 4
pointer types function pointer types and
so it will do the implicit conversion
before it applies unary plus and the
thing you get out of the unary plus is
in fact the function pointer itself
unless you're on MSV c and then you get
a confusing error message because they
have four different calling conventions
they don't know which one you mean all
right so now we get back to the slide
with though this didn't how many people
have seen this everyone's hand should be
up we just did this all right
alright so there are two ways to solve
this problem right the problem being
that this did max call does not compile
one of the ways to solve it is the
airframe rate reduced adduction must
match this argument type exactly so our
two ways of solving that are either to
make the argument types match exactly or
make the parameter stop contributing to
deduction so the first way make the
arguments match exactly
looks like approach number one there or
you're just taken as a static cast at
two ends right how many people have done
something like approach number one at
some point in their code alright
I advise doing approach number two
instead just because I feel it's more
readable so victor victor in stead max
angle bracket stands and approach number
two they be the thing we're trying to do
there is make the parameter stop
contributing to deduction alright so
let's go back to type of duction in a
nutshell well how to call specialization
explicitly basically I'm just putting
the type of T right there in angle
brackets how do I do that oh I thought I
was going to have another slide about
type duction in a nutshell here well the
stuff in angle brackets after I name the
template and I tell you which template
I'm using in this case add I can start
giving you the template parameters
explicitly I can say going through the
template parameter argument list
starting with T in this example I can
say T is int U is int and now I have
given you exactly the template
parameters template parameters go in the
angle brackets function parameters go in
the curly in the round brackets I've
given you exactly what T and u are and
that means that x and y no longer really
have any thing to say here X would have
told us about T but we already know what
T is we told you it's int Y would have
told us what u is but we already told
you it's int therefore x and y no longer
participate in type deduction therefore
they don't need to match exactly anymore
and I will actually call add of int
comma int with the char value X normally
that would be a char and it wouldn't
work but now
told you just make it an end and no
longer participates in type of duction
and so the implicit conversion kicks in
and it converts it right to int and
similarly the 3.1 is a double but it
gets converted to ends because I told
you that's an end it doesn't participate
in type deduction anymore now all of
these template parameters T and U and so
on I can specify them but I don't have
to I can specify only a prefix of the
whole list so I can say add of just int
and that tells you well T is int but I
didn't say anything about you so now X
no longer which is facing the duction
but but why does and it tells us what u
is in this case it says u is double when
we say okay I can even put nothing in
the angle brackets and that means I'm
not telling you about T or you or in the
case of function templates I can
actually omit the angle brackets all
together and that's what you see most
commonly in practice so type duck in a
nutshell any template parameters that
were explicitly specified by the caller
are fixed they don't participate any
further in deduction and then all the
stuff we saw before let's talk about
this little red underline bit
remember when we compare notes we need
to make sure that each template
parameter has been deduced at least once
so if we have a case like this here this
takes no arguments at all so T cannot be
deduced fortunately I can tell it
explicitly the T is int in the angle
brackets and then it's perfectly happy
and it works because it knows what T is
if I don't put anything in the angle
brackets or if I remove the angle
brackets all together which is what you
usually see in practice then it doesn't
know what T is it can't deduce it it
says couldn't for a template argument T
and that's a hard error again what do we
do about this well we can default the
template parameter question is there a
way to specify only the second template
argument you know there is not
is it written standard the deduction
will happen from you left to right in
the order I described yes and left to
right order is also kind of magic when
you think about it can I write function
parameters that have default values
right like once you start writing the
default values you have to keep going
you can't say there's a default for the
second parameter and not the third so we
like life left to right it's
left-to-right language okay so in these
cases we we can't infer it we add the
equals char star suddenly we can infer
it so even if it's not provided it works
fine so let's add that to our template
deduction in the in a nutshell here if
any template parameter that wasn't
specified by the caller couldn't be
deduced but it has a default value
that's still okay we'll fix it as its
default value and then we compare notes
and then we look to make sure that
things match the function argument types
cool now you actually know everything
there is to know about template type
deduction like well that's all the rules
that's cool oh yeah okay fine no if
there's no ampersands or okay all right
so let's talk about ampersand remember
this is the trivial case we have just
the plain old T we pass it an into comes
out as and no surprises let's talk about
this now we have a T star now I kind of
alluded to this earlier when I would
just did array example and you saw how I
can pull a T right out of the middle of
an expression and to do stat right out
of the stid array of int I can deduce
what T is because I sense the degree of
T that I'm interested array of int T
must be int in the same way if I'm
expecting a t star and I get an int star
I can deduce the T must be int all right
I'm going to assume some knowledge here
of L values and our values because it's
been five years people
so here this is an l-value reference
single ampersand and I'm taking an
l-value reference to a tea and the thing
I'm passing to it is a named variable
name the I which happens we have type
int and that means that the expression I
is an l-value
that makes sense to people mostly in
brief L values or objects that would be
missed by someone such as I because it's
got a name and probably family and
friends it would miss it
our values are expendable objects they
have their survived by nobody nobody
will mourn them and so it's okay to
stomp on your values but here I is not
in our value there's no our values in
this at all we have eyes and L value
we're expecting an L value and so we can
deduce that okay expecting this
reference to a thing and I'm getting a
reference for things in in so okay it's
an int just like a pointer example kind
of makes sense right all right let's do
our value reference here I have an F is
expecting t ref ref that is to say an R
value reference to a tea some of you are
preparing to raise your hands but don't
um NAR Val your efforts to a tea and so
I pass it an R value like 42 that's an R
value of type int and so T is int works
fine I pass it's did move of I did move
being the magic thing that turns things
into our values and it works fine okay
the deuces int now let's try passing it
just by without the stood move we passed
an l-value reference to an int what
happens it still works but it deduces
that T must be in Trev an l-value
reference this is interesting
interesting is going on here what's
going on here is something called
reference collapsing Scott Myers calls
to say well he calls the universal
reference but for written reference but
you can also just think of it as an R
value reference to a T and as long as
you know about reference collapse and
you'll be alright the rule to remember
when dealing with references is that
when you combine two reference types
when I take a reference to a reference
it basically me
means the number of ampersands between
them so if they both have one ampersand
they're both L value references they're
an L value reference to an L value
reference is null value reference an L
value reference to an R value reference
is an L value reference and our Valley
reference to an L value reference is
still an L value reference because if
anyone would miss it at all then someone
will miss it right if anyone's got nel
value reference to the thing it's an L
value reference but if everything
involved is our value references then
then it's okay we've still got our value
reference so what's going on here but we
have F of I I is an l-value int which is
kind of like an in giraffe let's say
it's an indirect T up there we have T r
FF we need to deduce T such that T our
value reference to T is L value
reference to int so obviously T can't be
just plain old int because then T ref
ref would be interesting ref it can't be
into referee feeder that wouldn't work
but if we make it int single reference
an L value reference then an intra is
still an intra we give an intrepid all
works and it works does that make sense
reference all right
so if we give it an R value reference
here we have a an R value reference to
an int we're passing to a function of X
in R value reference to a T I think we
already saw this of course it deduce is
T equals int
now you might say why doesn't it deuce
into ref ref because that just as well
would work and the answer is that's too
many letters
too many characters like why bother
sticking the ampersands on there if you
don't need them so it will prefer to
deduce int does this mean that int ref
ref is never deduced no like here's a
case where like obviously T has to be
interesting in persons at all involved
then yeah you're not you're never going
to see it deduce I don't write your
reference questions about this one
what's that
if I pass in a a temporary to the
function that it just expected a T you
expected at e-rep ref no that's exactly
this case isn't it when I'm passing in I
basically a temporary I mean it could be
two plus two just as well and the thing
that T deduces as is just int the
function parameter type is in reference
to reference collapsing oh this is a
very important thing to know when you're
dealing with templates in C++ 11 and
later it is less important but it was
still present even back in C++ oh three
with L value references suppose I have a
function f that takes or of some type
and then it tries to construct an RF and
I instantiate it with R equal to int ref
as I'm doing down here do we have a
pointer right there right so I'll graph
to a ref collapses to a ref this was not
standardized this was this was a
extension pretty much but every compiler
vendor had to deal with this if they
were going to do templates so everyone
pretty much kind of knew that yeah this
is how it should work but it was not
standardized until 11:00 and by 11:00 we
had to deal with this exact same issue
with our values in the template if you
call if you were call another function
you'd be calling the L value like you're
trying to call it constructors NT on the
L value constructor on that rather than
our value once it's in the template once
you're inside a template that takes a an
R value reference or an L value
reference are you are you then using
that bet parameter when you use it to
call some other function does that come
out as an L value and the answer is yes
always for any template parameter
because template parameters have to be
named
all right you have to name your template
parameters well you can leave a blank
button you can't use it so if you're
using it you must have a name and if it
has a name someone would miss it if it
disappeared so anything with a name is
always no value regardless yeah so even
in this case where t deduces is int and
the parameter of lowercase T is of type
int ref ref if I would actually pass T
to some other function in here T has a
name I would care if it disappeared on
me
so it would be an L value at that point
and I would have to still move it again
if I wanted to to turn it back into an R
value okay let's talk about more
reference collapsing but this time let's
throw constable little in there hounds
of all cv qualifiers so in this case I
have a constant I'm passing an L value
to a constant into a function expecting
a forwarding reference here let's do
some reference collapsing I is constant
ref we want to deduce T such that an R
value reference to T is still a constant
ref well constant by itself does not
work but I add a single ampersand to
that and it does so that's what the
answer is T is constant interests do the
same thing with the stood move of VY
there that's a constant R value
reference we should deduce T such the T
referee is constant R value reference
and constant works fine so that's we
have we have F of constant use the
answer for that one
okay now let's stop talking about these
forwarding references because they're
too easy everything just works with them
right let's go back to L value
references so I have F of T ref here and
I try in this case I'm just using the
static casts to just explicitly specify
what are the types of these things that
I'm trying to to show so if I pass in an
intra fob viously I get int because TR f
is interests
if I pass in into ref ref I there is
nothing I could possibly do to make T L
value reference come out as int R value
reference all right
because I'm
meaning the things this might be
confusing until you've realized you're
probably thinking about it backwards so
interesting into an l-value reference
there's nothing I can possibly deduce t
as to make that work so that's an error
and if I stick some qualifiers on there
like volatile and well things to do is
pretty much as you would expect right
and then I go to a Const and the
interesting thing about cost is it all
works exactly as you would expect except
that that last line where I can sit to a
constant or value reference and somehow
that works that will call F with T equal
to constant and it will take a constant
for F Prime at sin teresting that's an R
value reference quietly working with a
function that takes an l-value reference
didn't work with which is playing in
Torvald Oh in but putting constant in
there is T that that worked what's going
on here well so the compiler traces
deduce T by stripping off all the the
ampersands but not the CB qualifiers off
the argument type and then if it helps
make a match by reference collapsing
will reintroduce a single ampersand but
never to and in this case that actually
does help make a match you can't pass in
and unqualified in forever F to a
function expecting in Terrell
that would break all sorts of things
it's nice to be able to overload on the
R value s of a thing but you can pass
constant refraction expecting an L value
reference to a Const why is this and the
answer of that constants Const our
values are kind of like constant values
in that in C++ o3 we didn't really have
our values all we had was constant
values and so if you wanted to implement
operator overloading for example you
probably made an operator plus that took
a Const L value reference and a Const L
value reference and gave you back a
value and if we suddenly broke that for
our values and suddenly you know these
things that used to basically be cons
Dell values turned into our values and
if suddenly your operator overload of
operator plus or whatever didn't work
anymore
well that would suck so very quietly
there's a little bit in the standard
that says if I have an R value
and I have a function expecting a
constant L value yeah we'll just let
that work so that's why that last case
works in the specific case of Const
doesn't work for non cons doesn't work
for volatile but the Const is a little
bit magic in the standard and this is
one way that it is now you know
everything there is to know about
template type deduction as long as
there's no very addicts and luckily
that's still reserved for part two only
function templates do this deduction
thing right we talked a lot about the
type type reduction in a nutshell
involve the function parameters
contributing the template parameters so
it only works for things with function
parameters and that's function templates
those type deduction happen for class
templates alias templates variable
templates no does not because they don't
have parameters what would be to do
things from in fact they don't even have
a special case for well as what 17 I
think they do but there's a special case
in the syntax for functions right where
I can say just ABS of four and I don't
need to put the angle brackets I don't
need to tell it that's a template it'll
just figure that out for classes I do
all right but I can make I can make
brackets empty as long as it knows what
all the defaults are alright so let's
talk about the sum expression which gets
back to your question from way earlier
of what kind of thing can we put in the
sub expression well we need a way to
specialize the the template this primary
template for a particular T here's how
you define a template specialization so
we've got the primary template up there
at the top and that that's a cookie
cutter to stamp out is void of foo for
any foo but suppose we want it to be
different for one of the cookies we have
one special cookie that's Boyd so we say
template and we put an empty pair of
angle brackets and then we write it as
if we were going to use the thing is
void of void so you stick template angle
bracket angle bracket those angle
brackets are very important and then
write the function definition so if you
were using the specialization that you
want to write function or class or
whatever it is for function different
templates because they're type reduction
rules this usually means you don't need
to write anymore angle brackets at all
but when a type can't be deduced then
you do have to write these brackets
in that example down there I have tea
but I can't do sit from the parameter
list so I have to put little void in
there but if it's defaulted like that
right so here's my template
specialization which I'm specializing
ABB's of int just because I happen to
know about int min I could do something
like this template angle bracket angle
bracket this is a specialization and
then I call it I write it out as if I
were calling it or in this case template
type deduction works fine it knows that
X is an int and therefore T must be int
and it can deduce what T is T is int I
can even write that this is what you see
most often in practice but remember this
is just syntactic sugar for the long
form that's full specialization at the
end there is no difference between you
and brackets after the word abs or after
the word template getting rid of
template angle bracket angle bracket you
know at that point you've just got
overloading ya over function overloading
yes yes this has nothing to do with
function overloading because this is not
a function this is a template for making
functions real functions will we looked
for before templates yes
all right that's full specialization
going a little bit fast now because I
have like five minutes left
luckily we have a 15 minute break coming
up so we're just gonna stick around
alias templates cannot be specialized
this is important and the reason this is
important is that in this example here
I've got a function foo that takes a
MIVEC of T ref now if I were allowed to
specialize MIVEC of T for some T like
you have MIVEC avoid turned out to be
int instead of stood vector of something
then I would have a real hard time with
the overload resolution with figuring
out which foo one's supposed to call
but in this case because MIVEC of tea is
always an alias for stood vector of tea
because it can't possibly be specialized
the compiler can just go ahead and
substitute that right in it can say Oh
foo and then the first argument is my
back of tea which is really stood vector
of tea okay so you've got a function
that takes a vector of T ref and it can
just remember that and forget all about
the fact that was originally declared
with with a template or yes with a alias
template that make sense we may also
come back to that later but that's the
idea of alias templates they are
actually aliases that again they are
just synonyms they can get propagated
all the way through and so it's very
important that they not be able to be
specialized class templates can be
specialized here's the very similar
example using a pre C++ 11 way of what
we use is the using syntax but we have a
member type def here where I have my
Veck of T colon colon type and that I
can specialize if I want to I could make
a full specialization of MIVEC for into
let's say and I could say using type
equals double and what that means is
that when I call foo of V down here and
I say well V is a state vector event and
I'm trying to match that up with this
function foo that takes MIVEC of T colon
colon type and like well I don't know
what what the type of MV is before I
know what T is so this this parameter MV
does not contribute to type deduction so
it doesn't have anything to say about T
so I don't know what T is so I can infer
template argument T and so I get the
error how many people have seen errors
like this yeah all right well now now
you know why so class templates can't do
deduction because we don't know we'll
cover that later now you know everything
there is no about full specialization
partial specialization a partial
specialization is any specialization
that still requires further
customization by the user before I can
be used so here I can specialize my is
array type trait which I'm making here
and I can say well this specialization
works for anything that fits the general
pattern of T bracket bracket so arrays
of some bound unspecified bound and then
if I use it with int bracket bracket I
can say ah this does match my partial
specialization TTP must be int and okay
cool I can use that so we have a primary
template first that uses the regular old
regular template declaration syntax we
have partial specializations where they
still use template type name
such-and-such list and such and they can
have multiple parameters even and then
they have in the angle brackets after
the name of the template after the name
is array they have more stuff using
those template parameters that's a new
pattern that you can match when you
instantiate the thing or you have a full
specialization which is template empty
angle brackets and again the empty angle
brackets are important they're what
tells you it's a full specialization and
then it also has something in angle
brackets after there that of course
doesn't depend on any template
parameters because there are none
notice that the number of template
parameters on the partial
specializations we have here are
completely unrelated to the number of
template parameters on the original
template the original template primary
template had one here I have a partial
specialization which also has one and a
partial specialization with two template
parameters and I have a full
specialization which of course has zero
now these the TP and the N and so on I
can deduce them from whatever you pass
me but there's no way to specify them
specialization is called we still have
like 20 slides left and two minutes so
for which specialization is called first
you deduce all of the template type
parameters so in this case with a of int
star we have deduced and the primary
template T is in star that's super
obvious but then which partial
specialization do we instantiate well we
try to match int star against in order
well void nope in star is not void so we
don't use the full specialization and
then we look at the other two we say
well int star does match
keeping star TP would be int that makes
sense and it doesn't match TP star star
okay
so we'll use that second or sorry the
first partial specialization there the
third line within star star star
well that would match either TP star or
TP star star right depending on what we
call TP but the the second
specialization there with the two stars
that's more specialized because anything
of this form I could just as well plug
into this like the third the things that
match this or a strict subset of the
things that match this and it's very
obvious and so the compiler will say
okay I will use the more specialized
partial specialization in the int three
stars case that's partial specialization
partial specialization is allowed for
class templates and variable templates
because variable templates are pretty
much just syntactic sugar for static
data members of class templates it is
not allowed for alias templates because
alias templates do not allow
specialization at all it's just no no no
no no across-the-board they're they're
very simple just like type thefts but
partial specialization is also not
allowed for functions function templates
cannot be partially specialized if I
have something like this you might think
that that's a partial specialization it
is not wrong and this creates a pair of
function templates in the same overload
set it is not a primary template and a
partial specialization thereof the
partial specialization syntax always
contains angle brackets after the
template name always always always in
this case it does not and if you try to
put them there you will get a syntax
error if you don't put them there you
will get this weird behavior where it
kind of sorta seems to work until you
get into a complicated case like this
where I've put little snippets of code
in different orders or not in a
particular order because if you put them
in different orders you get different
behavior here I have a primary template
called is pointer which takes a tape and
I have a special specialization which is
totally fine function templates can be
fully specialized for voids are we also
have this other thing which looks like a
partial specialization but it's not it's
a new try
marry template and if this one happens
to come before this full specialization
this will be a full specialization of
this template you will see my mouse by
the way waving at things but if it
doesn't then this is a full
specialization of this other primary
template and so when I call it is
pointer of an actual void star we
definitely deduce that well T either T
is void star or T P is void star well
which of these functions which are these
primary things in my overload said is a
better match well this this one is
actually a better match here we have
only a hard error here already hard to
heard stop should I actually stop
already in that case we didn't get the
end of part one but stick around who's
gonna be more later but right now it's a
15-minute break</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>