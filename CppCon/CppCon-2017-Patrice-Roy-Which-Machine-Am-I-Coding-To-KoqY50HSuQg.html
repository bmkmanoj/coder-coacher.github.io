<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Patrice Roy “Which Machine Am I Coding To?” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Patrice Roy “Which Machine Am I Coding To?” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Patrice Roy “Which Machine Am I Coding To?”</b></h2><h5 class="post__date">2017-10-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KoqY50HSuQg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Hello.
How are you doing?
So, you decided to be stuck here with me
for the next hour or so.
Hope you have fun.
This is going to be weird C++ talk,
as there's almost no C++ in it.
I tried that thing in Montreal
for a C++ users group
about two months ago.
Crowd reaction was surprising.
People actually liked it,
which came as a surprise to me.
It seemed to be a dry topic
of sorts, but we'll see.
Should you not know about
me, well, I have a few kids.
I used to do military flight simulators.
I have a significant number
of animals due to my wife.
My wife works with animals,
so I have like 15 cats
and a number of dogs and all that.
I've been teaching for about
20 years now, 19 to be honest.
And one of my peculiar
clientele is video game people.
So I work with a number of
games programming companies,
well known ones.
And I work at university and
college at the same time,
so I teach a lot.
One of the things I do
in the standards community where I am,
others in the room are, too,
is I am involved with SG14,
which is the low latency
study group, and a few others,
but this is the one I think most of.
And I'll be there on Wednesday.
Should you all be there,
too, you'll be welcome.
So, you can ask questions
whenever you want.
It's probably simpler to wait a bit,
but I'll catch you if you do
have something in the meantime.
I don't mind.
You can disagree with me,
although I'm going to be
reading standards text, so.
It's not going to be as exciting
as Michael Case's reading last year
for the (mumbles) earlier this year.
If you heard about it, he
actually did a slam with it.
It's not what I'm going to do.
And I won't have all the answers maybe,
but I might have a few.
So, I hope it's going to
work out for you guys.
As I said, I'm a very
terrible PowerPoint user.
This one has way too much text, but still.
So, when you're writing a
program, you tend to be thinking,
&quot;Oh, okay, I'm going to be using
this feature, this feature.
&quot;I'm going to do...&quot;
And people tend to think in terms of
&quot;Okay, I'm going to be
passing my variables there.
&quot;They're going to be on the stack.&quot;
&quot;I'm going to be this and that.&quot;
They work for some kind of machine
that they have in their hands,
which is not the machine
they're really coding to.
They're coding to the abstract machine.
If you look in the standard,
the standard doesn't care
about the same things you do.
It cares about very peculiar,
a very different set of considerations
than people who work
with actual hardware do.
So, the purpose of this talk is
for people who are not aware of that
to get better acquainted with the machine
they're actually writing programs for.
This is the one that you're
going to run programs on,
but it's going to influence what you do.
So this is essentially
what's written there.
So to provide a practical overview
of what that abstract machine is
and how it affects the way you code,
or maybe, you should code.
The number of people I
get in a room with me
who tell me, &quot;This is
the way things work.&quot;
I'm telling them, &quot;No, it's not.&quot;
It's the way your compiler is doing it,
but it's not what standard says.
And what you're writing might
work like that way today.
It might not work the same way tomorrow.
Or if you change compilers,
you might be in for a few surprises,
so you better be aware of it.
So that's the goal.
There's a plan there which I will skip,
but you can read it, if you have time,
when the thing gets published online,
but that's pretty much
what we are going to do.
So, there.
So what is an abstract machine?
It's not the same thing
as a virtual machine,
at least in most people's view.
I tried to look around on the Internet
to see what people were saying about that.
There seem to have been a few
discussions two years back.
There's this guy there, Zubkov,
who's a nice guy and who's here in CppCon,
he has a talk later on today
if I remember properly,
who said something like, &quot;It's
simplest imaginary computer
&quot;that can actually run a program
&quot;that is wrote in the source language.&quot;
Or in the set of languages,
when he was referring to the JVM
where there's a number of these running.
So that's one point of view.
It's a simplification of actual hardware
that you can actually write programs for,
in your mind at the very least.
There's this person whom I
don't know who said once,
&quot;A model which permits
step by step execution.
&quot;We design programming languages
for a range of targets.&quot;
This kind of abstracts the
details of the actual hardware.
Why not?
So you're gonna try to think
for a specific architecture.
You're writing for something different.
Enlarges your vision, in a sense.
There's this other person
who wrote on Wikipedia,
so I have no idea who that person is,
who said this was, &quot;A
theoretical model of a computer
&quot;that you can use in theory,&quot; I guess.
Okay, very general terms.
Why not?
People probably use that.
He said not to be confused
with virtual machines,
because these are actually big beasts
that do very different things.
The .NET one, the Java one,
they're very different.
And there's this somewhat long
text but that you can read
if you wanna read the slides afterwards.
It's a very nice text from Mr. Mortoray,
who's the author of the Leaf Language,
who makes a very nice case
of why you would need or
want an abstract machine,
saying, well, your program
is instructions, really, and
you don't want to write your program
for a specific piece of hardware.
You want to write it in a general way
and transpose it to the
actual hardware at some point.
So it's a very useful tool for thinking,
to have an abstract machine,
something that you write for
that's not tied to a
specific set of resistors
or this kind of memory
or that kind of memory
or this kind of I/O.
Elevate the discourse a bit.
He adds, at the end, and
I used to say rightfully,
but someone in one the rooms
where I gave this talk before
said, &quot;Rightfully, I disagree!&quot;
Saying, &quot;Well, in academia,
&quot;Turing machines and lambda calculus
&quot;are examples of abstract machines.&quot;
So lnow that there are some people
who disagree with Mr.
Mortoray in this case,
but it's a point of view.
So the one we have in C++,
taken from one of the texts that Bjarne
wrote about 10 years or
so ago, well, it said,
&quot;We're using C++ in a lot
of application areas.&quot;
Of course, that's part of
what he said this morning.
The interesting thing about
C++ is what we can do with it.
So, how do we do that?
Well, we try to add an
effective abstraction layer.
We try to have zero cost
abstractions as much as we can.
And we're not writing for a
specific piece of hardware.
Of course, it would be very inefficient.
So we try to map directly onto hardware
as much it's reasonable to do so.
We have basic types that tend to map
to very specific entities,
bytes, words also.
Our pointers represent
a contiguous address model of
memory that we borrow from C.
Why not?
There's no abstract mathematical
model that gets in the way
between what you're coding
and the actual hardware.
So we tried to make
something that's very thin
so that you can actually
reason on something
that really looks like a real machine
even though it's not.
So, of course, you have to be careful,
because the mapping of types of hardware,
it doesn't always map in
the ways people expect.
So, a char is a byte, although
we have a free byte now,
which we have had no tests with
because we're still meeting.
But an int is not
necessarily a direct register
or the same size.
Could be different, so you
have to be careful with that.
We do borrow a lot from C with this.
The ideas we can express,
cache, memory-mapping unit, ROM,
we would not necessarily go there.
We can express it if we want to.
We can get closer to hardware,
but we don't have a machine
that says you have a cache.
That's not what we do.
So there's another guy named Chisnall
whom I don't know much.
We gave a really nice introduction
to the C abstract machine,
saying that things like
language constructs tend
to map to machine
instructions very closely,
which helps you to think in terms of
the efficiency you're going to get.
It's working very hard in C
to avoid things that cost you
something, which brings us
to the zero-cost abstraction model of C++.
You don't have garbage collection,
because it would cost you something.
You don't bounds-check the arrays,
because it would cost you something.
You can do it if you want,
but it's not something we do for you.
It's something that you
anticipate, should you want it.
You have your memory in C
exposed as an array of byte extensions.
That's what you think of it.
And you think of it as a flat array,
although that's not always exactly
what's going on in real life.
You have typed addresses so
you have pointers of something,
and you can reason in terms
of arithmetic based on that.
It's simple. It's efficient.
It works.
It lets you think about things.
(mumbles) text about that at some point,
also praising that model.
It's simple.
It's efficient.
It maps well to higher level concepts
like iterators and others.
There's a lot to be said about that,
even though some people
complain, of course.
So we have this big
beast named the standard
that says things about
the abstract machine,
that defines the rules
and the playground for us.
Without much of a surprise, it
appears early on in the text.
In the first pages, you will see
most of the meat of what's going on here.
If you've never read
this beautiful piece of
literature that is the standard,
(audience laughs)
the first few hundred pages
are essentially maintained by
a group of people name Core,
of which there are members
in this room, including me.
I tend to stay on that slide
there because I really like it
and the higher pages are
essentially library playground.
In between, there's not much.
It's pretty much
these two working groups
that write the paper,
and you'll see differences in style.
Now, Core has been said to be dry.
It also has the most beautiful examples
for those of you who
have a very twisted mind.
If you look at the very
beginning of the document,
you'll see things like
what you see up there.
I try to put emphasis
on some of the pieces,
and the links that you see, eel.is,
they're officially maintained now
by the ISO Standard Foundation.
So we can actually say that
they're real excerpts from the standard.
We can actually use that and
be confident that it works.
If you click on these, which I won't,
because my Internet
connection is shaky a bit,
you will see additional excerpts
from which I'm picking out the stuff.
They might slightly, slightly differ
from what I've put there
because I did these slides in February,
I edited them in June
based on the February text,
and there's been an update in July,
but it's very, very close.
I don't think anything has changed,
but I didn't verify every single word.
This one says that, it's
standard text so it's dry,
&quot;We define a parameterized
&quot;non-deterministic abstract machine.&quot;
Non-deterministic tends
to make people react.
(audience laughs)
(Patrice mumbles)
There's a specific meaning for that.
We'll come back to it.
&quot;Conforming implementations
have to emulate
&quot;the observable behavior of the machine.&quot;
You're writing things
in terms of that abstract
machine which doesn't exist,
and your compiler has to
transform your code in such a way
that it behaves as what you wrote.
It's pretty cool, as long as
you're following the rules.
You're feeling better now.
You're ready for a non-deterministic
machine, aren't you?
There's this provision.
We call it the as-if rule with quotes.
Everyone that refers to
it, it actually has a name.
It actually exists.
And what it essentially
says is that we can do,
the compiler can do a
number of transformations
that would hurt your
heart if you saw them,
because you write your code with care,
and with love, and we don't care.
But we're going to try very hard, not we,
the vendors will try to work very hard
to keep the observable
behavior of what you wrote.
If you follow the rules,
they're supposed to keep that for you.
It's as if they did nothing,
except that it works faster
and better and everything.
Parameterized and non-deterministic
in a very specific sense,
which is essentially what I just said.
That means the program can
not do things that you wrote
if the compiler judges
that there's no point,
that there's no observable
behavior tied to that.
I put a link there, normally
I would click on it,
but since my Internet
connection is shaky I cheated
and I used Matt's, who's
in the room, too, there.
Writing this thing, it's a
very, very bad piece of code,
but I use it very often.
I have students who come into my class,
especially when they're beginners,
and who ask me this very deep question.
&quot;Should I use while,
do-while, or for loops?
&quot;Which one is faster?&quot;
The first time my arms just fell,
but then you have to remember
that people who start,
they have no idea if
this makes sense or not.
They are really worried and
they want to sound efficient,
so they're wondering what kind
of loop they should stick to
and forget all the others.
So the fun thing is you write the code.
I wrote a program that
accumulates, essentially,
(mumbles) accumulate,
numbers from one to 10
in three different loops.
You write that thing, and you show them,
and they see all of this code,
and if they look at it and say,
&quot;Oh yeah, there's an additional jump
&quot;somewhere in the for loop,
&quot;because you have to step over
&quot;the incrementation and everything.&quot;
Why not?
So they look at this and say,
&quot;First of all, loops are very expensive.
&quot;There's a lot of code there.&quot;
Yup.
Then you add something.
You optimize the code.
As you can see right now
there's no optimization.
There's no optimization whatsoever.
And when you add 02, it's much nicer,
(audience laughs)
because they're not noticing, of course,
that you're not doing anything
to the computation you did.
So you're just computing things
and never displaying or saving anything.
There's no I/O.
There's no observable
behavior to your program.
It's pointless, almost like
the question was pointless.
This shows, kind of like
Bjarne was doing this morning,
if you're not optimizing your code,
you get what you deserve.
But if you do put on the optimizer,
sometimes, well, you
realize that it has a flaw.
That is, the compilers
say, &quot;Oh, pointless.&quot;
This is perfectly legal.
You don't have to stick to what you wrote.
The compiler doesn't really care
as long as there are rules
and they're being followed.
Another one that I've
heard from colleagues,
people who've been teaching
for longer than I have,
for more than 20 years,
like I want to do a find on a vector,
and I want to do a find on a set,
and I've been told that
vector is very fast.
So I'm bringing in research,
but they'll say, &quot;The cache,
blah, blah, blah, blah.&quot;
And yeah, depending on what you're doing,
sometimes one is better,
sometimes the other is better.
They come to me with something like this.
I did a vector find.
I did a set find.
And I used Fred, I think it's Tingaud,
his benchmarking tool.
Hey, that's cool.
I'm glad to see you.
It's very nice, and there's
a poster about it downstairs
if you wanna go through it.
So this very small thing
that essentially does
the same thing in terms
of conceptual stuff.
Inserting the same number of
numbers from one to so and so
and then doing a number
of finds in both cases.
And of course if you do it like this,
vector seems to be very slow.
Obviously, since optimization
is O1 in this case,
you get what you deserve,
because if you change
the optimization level
you get something different.
The set is not faster or slower.
It's just that the compiler noticed stuff,
and probably in this case the set
is doing more memory allocation,
which could be observable, I guess.
So there's something
costly there going on.
Whereas in vector, well, not much.
So you have to be careful with that.
So the as-if rule plays a role.
When it does, you enjoy it,
and as long as you're careful
with it, it's pretty nice.
So what is an observable behavior now?
Well, we have side effects there.
I/O for the library, something
that calls such I/Os,
you read an object that's
volatile or something,
that's what you have to pay attention to.
If there's none of that,
your code might go away,
but you didn't need it in
the first place, did you?
So it's very powerful and you want it.
You have to be careful when you have
more than one thread and
you have shared state.
You have to say explicitly what you mean,
otherwise the compiler might assume stuff,
like there's no threads.
And I've been reminded by people,
you can't have empty programs
and with only two instructions,
if you look at god mode,
and they're much bigger when you run them,
it's because there's libraries involved
and you link with them, and so and so.
It depends on your quality level.
You have to be careful with
your assumptions there.
There's assumptions that you might have
that aren't necessarily true.
You have implementation-defined stuff,
like the size of an int.
The number of people we do
this for, we never say that.
I've been taught, myself,
size of int is the size of a memory word.
I held that as belief until
I actually read the text,
and we don't say that.
It tends to be that way.
We tend to, for historical reasons,
to want the short name type
int to be the fast one,
but apart from that...
And size of some T, which might change,
even in some compilers size of string,
depending on your optimization level,
you get different numbers.
Why not?
You can count on size of char being one,
but that's not eight bits.
It's probably eight bits, though.
So there.
These implementation-defined
little things,
they constitute the parameters
of the abstract machine.
We had a very interesting presentation
in Toronto this year by Lisa Lippincott,
whom I haven't seen,
I don't know is she's if here this week,
she wasn't here last year,
a very interesting thing where she used,
I put a reference if
you wanna read about it,
she used the abstract machine
as leverage to make
programs more resilient
and make reasoning about
assertions stronger,
very deep things.
She used that thing and
she actually modeled
the abstract machine as a machine
using these as parameters.
Interesting thoughts.
On top of the implementation
defined stuff,
you have the unspecified stuff.
There are things we don't say!
People assume things.
When you have a new expression
with many arguments,
in which order are they done?
Well, we don't say.
We don't say.
Especially if we fail to allocate memory,
we don't say much about that.
If you have beliefs, that's
fair, but who can say?
These things are funny
because your compiler will do something.
Just don't have any portable assumption
as to what will be done.
This is what we call, in standard-ese,
a non-deterministic aspect, so
it's not as bad as it seems.
If you stick to a specific compiler,
you'll probably get stable behavior,
although you cannot count on it.
They are doing something, it's fair.
It's not dangerous, but the assumptions
on which you base these are non-portable.
My, you don't see it, but my,
ooh, I'm sorry, my little
thing there has a word on that.
There are people who want to fix an order
to when we evaluate some
expressions of a given expression,
and there are levels to which
I personally would stop,
and there are things
that I think are fine.
There are (mumbles) arguments about that.
These things that are reasonable
but depend on the
implementation, they exist.
There are undefined things which
you might have heard about,
these are things of evil,
modifying a const object,
doing all kinds of evil casts.
Well, if you do that, I'm
not even sorry for you.
We impose no requirement on
programs that behave that badly.
You're on your own if you do that.
It might work.
It might work.
A conforming implementation
that executes a well-formed program
will produce the same observable
behavior, blah, blah, blah.
However, should you be an evil person
who has even one of these
undefined operations,
well, we place no requirement
even if the operations
that are evil are below
and the code above seems nice.
We don't care.
If you do that, you decided
to go on your own playground,
and have fun.
I didn't put a link to
that in the presentation
because it's not a talk
about undefined behavior,
but there's this very nice
tweet we had a few weeks ago
that made us talk among ourselves
where someone had written
the function (mumbles),
who did rm/ -rf/
on a function that's never been called
and the generated code
calls it nonetheless
because someone is
accessing an old pointer.
Don't do that.
It's very easy to do things like that,
and you'll get bitten.
I've been reminded by some
ISO people from other groups,
the safety programming
languages groups also,
that if you're using a
standardized language like C++
you're actually liable to
get sued or stuff like that
if you're going in that direction
because you're expected to be an expert
doing reasonable stuff.
Some companies will hire you
because you're writing using
a standardized language,
so please don't.
Don't do things like this.
We have some rules tied
to program execution.
That's very nice.
RAII, idioms like that,
they're not named like that
in the standard, of course,
but they're part of the execution model.
So you can see that there's a link
with the closing brace and
some code being executed.
You can count on that.
It's reasonable.
It makes sense.
We define the rules tied to
lifetime of your objects.
That's standardized,
you can count on that,
as long as you're following
the rules, of course.
There's a number of other things
that we mentioned briefly.
What happens when a program terminates?
As long as you didn't break anything,
like throwing from an accept
function, I/Os and everything,
there's a set of things that
are named and said to be
the observable behavior in programming.
Your implementation can be stronger,
it can do more and ask more of you,
but there's a baseline
on which you can count.
It's standardized.
We find things such as
the order of evaluation of expressions.
What order are the operators evaluated
in the complex expression?
That's all standardized.
We have these things that are very nice.
The taxonomy of the expressions,
it used to be so simple.
Anyway. (laughs)
I almost feel bad showing that to people.
I don't show that to students anymore,
because they freak out.
We have these generalized L values.
That actually has a name in
the standard and seems as such.
So, object with field, whatever.
The pure R values that we use
when you have unnamed results
from function calls or
expressions or anywhere,
that's pretty cool.
The expiring values that will die!
Sorry for those who have
things in their ears.
I had to do this because
last year I did this
and some people started
complaining on YouTube
that they were listening to
my talk during the night.
(audience laughs)
I hope they'll try this one.
So there.
And we have this amusing thing
that's either a PR value or an X value
that we've called R
value, that's old speak,
and the old L value
that's a global L value,
that's an expiring value or whatever.
So we have all these categories
because they are all...
I won't get into that.
Main is special.
There's a guy named Adi Shavit,
I don't know if he's here
this week, I think he is,
I think he is because I saw
a tweet by him this morning,
who tried to make a recursive main,
and he was very, very happy
that he was doing Fibonacci using main.
It's illegal.
(audience laughs)
It might work for a compiler,
but we actually said, &quot;No,
you shouldn't do that.&quot;
You cannot call main in
your program yourself.
You cannot recurse on it.
It should return an int.
There's a number of rules,
like main is special.
There's some leeway
with the first paragraph
that lets us, that lets vendors
play tricks on an embedded
system to save space,
but essentially there
are rules tied to main.
If you return from main,
you're calling exit.
Program is over.
It's written.
It's not something that people thought of
and started spreading rumors.
Main is special.
&quot;The function main shall not
be used within a program.
&quot;This linkage is implementation-defined,
blah, blah, blah.&quot;
So you cannot have a constexpr main,
as far as I know, so
there's a rule tied to that.
So you cannot do anything you want.
Gary this morning mentioned
memory model when he was saying
that he shows sometimes
people, the students
how to write their own kind of vector.
It's tricky.
There are things that
right now are had to do
when you're not in the
standard library with that
when you write strings.
And he was saying at some point
you have to dirty your hands
and touch memory model in class.
Otherwise, it remains
magic, which is kinda true.
Unless you've touched that thing a bit,
programming looks like magic.
We have bytes there.
That's a fundamental storage unit.
It's the byte today, char before,
and there's rules tied to bytes.
So if people are complaining,
&quot;A byte is eight bits,&quot;
standard text there says well, at least.
At least eight bits, of course.
Bytes have unique
addresses, blah, blah, blah.
That's part of the machine.
We can count on that.
Sometimes you want to compare
unequal pointers to objects,
and you're doing dirty things
like comparing distinct objects
and saying they are equal or something.
So we have rules there
if you're pointing to different
elements in the same array,
if you're pointing to different
non-static members of the same object,
and the last one there,
&quot;Otherwise neither pointer
compares greater than the other.&quot;
So you can actually have situations
where you compare two pointers
and A is not lower than B,
and B is not lower than A.
They're not equal and you're confused.
Confusion stems from the standard.
You shouldn't do that.
You're a bad person.
- [Man In audience] Can you
compare less than though,
because it only says you can't compare
greater than the other?
(audience laughs)
- You should write an effect
report for that. (laughs)
So this guy said that,
just for the recording,
if you're using something else
than less than, what happens?
Write an effect report, please.
So, (laughs) the rules are there.
Yeah.
The compilers can re-order your operations
according to the as-if
rule, and you like that.
Your code will get faster in most cases.
Be careful with
multi-threading, as we said.
We are offering you guarantees,
which essentially say that if
you're playing nice with us
your code will be sequentially consistent.
So if you look at the output,
it will be reasonable
based on your source code.
As long as you don't add
something called a data race,
which is at least two threads
touching the same object,
concurrently, without synchronization,
and one of these is doing a write,
in which case you're way off
in undefined behavior land
and we're not looking at
you anymore, so there.
And the abstract machine
will see rules for that,
because of course you cannot
write safe multi-threaded code
if you don't have rules for these things
because the optimizer
will pass by and disregard
all of your presumptions
as to what your code is.
You have synchronization operations.
They're defined there.
There's a modification order of objects
in the abstract machine,
specific order as well.
There's no requirement that you can
totally order everything all the time.
There are things that
are rarely concurrent
that could act at the same
time in a given program.
Might make sense.
Why not?
But yeah, if you wrote
the correct program,
you look at it at the end and
you ask all of the threads
why they happened based on
the order in which your writes
to shared objects occurred,
and they will agree.
They won't agree beforehand,
but they will agree afterwards
as to why that happens.
It's pretty cool.
You can actually debug
code when that happens,
whereas you might not
in other circumstances.
We have also in the abstract machine
tied to the memory model a number of rules
that the SG1 people could
explain better than I do,
but still.
Synchronizes with, which says that
there are relations that describe
how a write to a variable in a thread
and a read from the same
variable in another thread
can behave depending on what you wrote.
It's very nice to have rules about that.
Sequence before, which says
in which order things
are expected to happen,
or at least that there's
a dependency between them,
that's part of the machine.
So if you're following the rules,
you'll get reasonable behavior.
Carries dependency, which
I would not get too far in,
because it's tied to
memory order of consume,
which we're still working on,
it's not exactly as we
would like it to be,
but which says that if you have operations
where the result of one is involved
in the computation of another,
we will not re-order things in such a way
that we will break your
code if we can avoid it.
Thank you.
You're gonna have time at least.
We have things like
inter-thread happens before.
It's pretty nice too.
There are ways to say what happens there
will happen before something there.
It's defined, so if you
follow rules you'll get that.
It's a pretty nice machine
if you think of it.
So when I talk to my games people,
and they come to me they
all say, &quot;Okay, that's fair.
&quot;That's all very abstract.
&quot;I don't really care.
&quot;I'm doing real things.
&quot;I'm doing real work!
&quot;What about a stack?
&quot;I put variables on the stack.
&quot;Where is that?
&quot;Where are the rules about that?&quot;
Interesting.
There's no such concept
in the abstract machine.
If you take the PDF version
of the standards text,
you look for the word stack,
you'll find STD stack,
which is a container,
an (mumbles) container, at least.
You could go code it yourself.
It's just something from
the mental to the machine,
and for good reasons.
We have things coming in like coroutines
that might not be using a stack at all.
As a colleague from SG1
told me, there are machines
where you have more than
one stack per thread.
You can play with that.
The thought that some of us have
seeing, well, you have a
single stack per thread
and that's where the arguments go,
that's a preventer thing.
It's not something that the
abstract machine describes.
If you look for it,
you'll see stack unwinding
tied to the B of your program
if an exception is thrown.
So the word stack is there,
technically speaking.
There's a number of occurrences of stack
in the section where the
library talks about STD stack.
That's about it, to be honest.
So it might be surprising to some
who start with that assumption.
So there.
So everyone says &quot;Okay, fair.
&quot;So how about my registers?
&quot;I have these things that are
as big as an int in my mind
&quot;where there's actual work being done.
&quot;So how does the abstract machine
&quot;express the instance of this idea?&quot;
Interesting.
No, it doesn't exist
in terms of the abstract
machine, at least.
It doesn't mean your machine
doesn't have a register.
Just means that the
abstract machine doesn't.
Doesn't talk about it.
Maybe it does, maybe it doesn't.
But if you look for the word register,
you'll see the register keyword,
which is unused right now.
We deprecated its older
usage, and then we removed it.
It will, I'm sure, come back
in strength at some point,
once we've all accepted
the fact that it's gone,
because it's a very nice word to have.
It's still reserved,
but if you do register
int for a for loop counter
because you're still living in the 70s,
(audience laughs)
you might have some compiler
options to set to make it work
because by default it shouldn't.
So, you have things.
&quot;When an object of class type X,&quot;
standard-ese is beautiful to read,
&quot;is passed to a return from a function,
&quot;if each copy constructor,
move constructor,
&quot;and destructor of X is
either trivial or deleted
&quot;and X has at least one non-deleted
&quot;copy or move constructor,&quot;
beautiful, I said,
&quot;implementations are permitted
to create a temporary object
&quot;to hold the function
parameter or the result object.
&quot;blah, blah, blah, blah.&quot;
There's the word register
in the note there.
There's one occurrence
of the word register.
It says &quot;This latitude is granted
&quot;to allow objects of class type
&quot;to be passed to or returned
from functions and registers.&quot;
That's what we call a non-normative note,
so it's not something that's binding.
It's an explanation.
Should you be using registers,
well, you have leeway there.
We're giving you some space.
Aren't we nice?
So yeah.
Non-normative, not part
of the abstract machine,
it's not part of the rules.
So if you're writing a program
and you want the correct program,
you have to conform to the rules.
It's important.
If you rely on
implementation-specific stuff
or unspecified stuff, it's going to work.
It will never be re-broken,
but your assumptions might not be met
if you change compiler
version or technology,
depending on what you do.
Most vendors can be expected
to be pretty careful, I guess.
So they won't break your code voluntarily
and they won't do unreasonable things,
but what you wrote is
not something you can...
Don't write life-support
systems based on that.
And if you're writing
undefined behavior using code,
you're writing a time bomb.
Anything could happen and
you deserve it, as I said.
This one is a nice one
because I used it as an example last year
in a class I was giving.
I don't know if you, oops.
You won't see anything.
I'll make it bigger.
Give me a second.
So I was writing this thing
about atomic counters,
because we were discussing other things
in the class I was giving.
And there's these two threads there
that are using an int concurrently
without synchronization,
incrementing it a number
of times like this,
and at the end, returning the number of,
the value of n past the incrementations.
So two times a million plus plus.
And the same thing with
an atomic int at the end,
where we're returning n.load at the end
because it cannot be copied.
And people were saying,
&quot;Well, does that really
make a difference?&quot;
So we checked, of course.
If you run this thing,
it's funny because you get,
without too much of a
surprise on that compiler,
with the raw int, you get the
wrong number, but very fast.
And with the atomic int, the right number,
but you paid something.
And the degree to which you pay
can vary from compiler to compiler.
It can be up to 10 times or something.
But then you get the
wrong answer this case.
Someone in the room was very, very nice,
came to me after class and said,
&quot;I tried it, and I get the
right numbers all the time.
&quot;I get the right numbers, so
why should I use atomics?&quot;
That's very interesting.
I picked one box in this case
because it uses a recent gcc.
Effectively, if you run this code,
it's the same code, I didn't show you,
but it's the same thing, code.
Raw int, very, very fast, and
the exact correct number.
Beautiful.
And do you know what the
difference is between these two
because they have same source code?
- [Man In Audience] Level of optimization.
- (mumbles) does optimization.
The first one was an optimization level,
and this one used O2.
So what I then, which I
think is a beautiful example
of what we've just been
saying about UB is that,
in the first case up there
we're doing concurrent writes
to a common int in two separate threads.
No synchronizations whatsoever.
So we get a bit of undefined behavior,
and we're really dealing with broken code.
The compiler is very nice.
It's guessing what I want
it to do, and it did it.
I have a totally correct wrong program.
It's a thing of beauty. (laughs)
And extremely fast.
So you could make a point
saying undefined behavior is tremendous.
It's making my code better.
Or you could surprised
and wary and saying,
&quot;Can I count on that?
&quot;Was that a right assumption?&quot;
Probably wasn't in this case.
In this case,
you're probably better
paying for what you want,
because you'll get more portable results.
But it's fun.
Change from compiler to compiler
and the way this thing is
being processed changes.
It's instructive.
So yeah.
The difference in the results
were the atomic writes slower
because of the accrued
synchronization takes something.
And if you want to have
very fast, correct program,
don't use shared state.
No incremental variables,
and add them to your
shared state at the end.
Much faster.
If you use a higher optimization
level like I just did,
your results will vary.
If you use, as of this writing,
if you use the Microsoft compiler,
you'll get a very fast, wrong program,
and if you use Clang or GCC,
you'll get a very fast, apparently correct
but totally broken program.
It's broken in all cases.
In one case, it shows.
In the others, it's hidden.
So yeah, the code is very, very bad,
and as I said, don't use shared
state until the very end,
and then write to it only
if you really need to.
How does this impact what
we do with the standard
and with the language?
I know that because it's bitten me.
I have another talk tomorrow
where I'm going to talk about something
I've been working on for a few years now.
And I have a feature that my users need
and that just doesn't fit.
They want to specify the
stack size of their threads.
It's hard to do.
We don't even have a stack.
We have to find a way to
say what the users want
without polluting the standard
with things that the
standard doesn't need,
because it would be harmful
to things such as coroutines
that really don't need it.
Should you want to write your
own proposal for a standard,
considering what we have
just been skimming through,
well, one of the things that you can do
is restricting yourself to features
that are actually part of the language.
So if you're saying,
&quot;I'm going to make registers
access much faster,&quot;
you're probably better off
talking to your compiler vendor.
They care about that.
The standard doesn't much.
We are going to do everything
we can not to be in the way,
but we are not considering
what your specific architecture is doing.
It's none of our business, really.
Our job is to let the vendors
write the best compilers they can.
Should you want, as I said,
to add something that doesn't
fit really, really well,
it's trickier, because we
have to find an abstraction
that hides this in a way
such that the standard
rings clean, at least,
of such considerations that are not,
that would not be in the right place.
And you have to ask yourself,
would it add something?
If you really want to speak
about a hardware register in the standard,
will the standard be better after that?
Unless you have a very convincing
argument to the effect,
people will probably say
no, and it won't pass.
And then you'll probably be thinking,
&quot;Well, they're all idiots,&quot;
because, of course, if one knows
that should your proposal not pass
it's because everyone in
the standard is an idiot,
which I can confidently say is not true.
These people are actually pretty right.
For those who are interested
and who didn't know about them,
there's less and less people
who don't know about them.
For the comparisons I did,
Matt Godbolt's tool is amazing.
For the benchmark, it's much
younger, but it's very cool.
Fred's stuff is very, very cool.
And Tim Song's thing to
explore the standard,
even though I didn't link
to it with the slides
because (mumbles)
it's actually lovely.
And you can actually count on it
because it's officially supported,
so really, really nice.
If you want to quote the standard yourself
or look at specific parts of it,
it does highlighting and everything.
It's really cool.
I used, for my quotes, the
standard from February.
There is a more recent one.
Should there be discrepancies,
they're my fault.
And the articles that I used as reference
or as quotes are also in there
should you wanna look at them.
Interesting stuff there.
The talk by Lisa is there.
I strongly urge you to read it.
Lisa is a brilliant person, really.
And I have my website,
where there's a lot of
stuff, but it's in French,
so some of you will think, &quot;Ew!&quot;
Most of you who will react like that
will react to the color scheme.
Sorry.
I don't see colors all that well.
So there.
What can I do for you?
(audience applauds)
Did that make any sense?
- Yeah.
- Yeah.
- Phew.
Any questions?
Comments?
Threats?
Hello.
- [Man In Audience] Hi.
So in a hypothetical universe where--
- Of course.
- [Man in Audience] Yeah,
where I actually have
a compiler that's giving me a
byte that is not eight bits--
- Oh, there are many.
- [Man in Audience] There are?
- Yeah, yeah, yeah.
If you go to DSPs and other stuff,
you'll get many of that, yeah.
If you're using general purpose hardware
and you're running Linux,
probably won't need them,
but if you're specific hardware,
there are a number of these.
- [Man in Audience] How
do you deal with that,
like as a programmer?
- A C programmer would
tell you there's char bits
in limits.h or climits if you write C++
that tells you how many
bits there are in a char.
So we have a macro for that
now if this was a fixed thing.
If you're in C++, you
can use numeric limits,
unsigned char::widgets
You want to use the unsigned one
because the signed one will
not count the signed bits,
and you'll get surprised.
You'll get an odd number of bits.
That would be surprising, I guess.
So the short answer to your question is
most of the software you would try to use
that is not aware of that
would probably be broken
due to the wrong assumptions.
They'd say, &quot;Well, chars are eight bits.
&quot;Everyone knows that.
&quot;Integers are four bytes.
&quot;Everyone knows that.&quot;
It's my hope that if you're
getting out of this room
and you don't write
sort of broken software,
the whole world will benefit from this.
That doesn't mean you shouldn't
use the bits in your thing,
but should you write something
that is dependent on no assumptions,
you should at least test them
with setting assert first.
Yep.
- [Man in Audience] So, given
that I can only count on
observable behavior that's
actually happening in my program,
and something that would
otherwise look like
a dead store to memory happens to be
into a memory mapped file,
should I always access
my memory mapped files
through pointers to volatile?
- That's a very good question.
The thing is, for this sort of question,
you probably have to look at
what your vendor is providing,
'cause memory mapped files
are outside of the scope
of the standard, too.
We don't have any standard ones,
so we don't have rules for that.
Compilers will be sometimes stricter
as to what their rules
are for their platform.
So the volatile rules for
Microsoft, for example,
were traditionally more stringent
than what the standard actually said.
Now, volatile is very much
under specified right now.
It's hard to use properly.
So what you should check
is what your vendor is
providing for (mumbles) tool,
and make sure that your
following the rules for that.
'Cause until we have
std::memorymappedfile,
it's hard to answer
that question properly.
- [Man in Audience] Thank you.
- I still have 15 minutes
if you have a question.
(Patrice mumbles)
Yep.
- [Man in Audience] Yeah.
In your example, you told us that
somebody was using an undefined behavior
but the compiler detected
what it supposed the developer meant
and meant something that kind of worked.
I'm a bit scared when my compiler
tries to determine what I meant.
I've been an HTML developer in the past,
and I know that all programs combat
from the fact that when you
forget to close a bracket,
it just tries to guess what you wanna do.
Wouldn't it be better if it
would just show a warning
or an error or just refuse to compile?
Why are we even doing that?
- There are many answers to that.
One of them, there are many other cases,
in JavaScript with the injected
semicolons is another case.
Go probably does things like that.
So there are probably compiler
settings that you can check
because it's a per vendor
kind of thing, you know?
What we say in the standard is
we won't say anything about your program.
You're dead.
To us, you don't exist.
Well, you kind of exist, but, you know.
We love you, but nope.
(audience laughs)
Another thing you can try,
should you wanna try it,
is use constructor functions,
'cause you're not allowed to use
undefined behavior in
constructor functions.
At least this will reveal some things
that might not have
been revealed otherwise.
That being said,
they're not all as strict
as they should be with that.
But should they want to be,
if you're using undefined
behavior in constructor functions,
they're supposed to compile off.
That may be a nice trick.
Yep.
- [Man in Audience] All right.
This is more of a comment.
- I'm sorry.
- [Man in Audience] Yeah.
So for example, when you
were talking about C,
C will do no area checking for you,
but you also said that
you can do that yourself.
And I have a comment about
that, that if you find that
in general C++ doesn't have
enough defined behavior,
well, you can use a library
that defines it for you.
If you're annoyed that int
does not guarantee anything on overflow,
you can make your own integer type
which throws an exception,
wraps as if it was twos-complement,
and you can get basically Java in C++
if you just rewrite all the behavior
of the Java virtual
machine on those things.
So really, some people would like to see
all the undefined behavior
gone from the C++ standard,
but if you have a behavior
that works well for your platform,
well, do that instead of
using the abstract machine.
- True.
That was the purpose
of the talk, of course.
But we do have a study group, SG12,
that works on undefined behavior right now
and is trying to reduce
the cases where it occurs.
So there are things where,
there will always be some, I guess,
but we are working on reducing them,
such things as doing a
mem copy to some storage,
which could be undefined
but could also give
birth to an object, say,
some casts which are improper
but kinda make sense to parameters.
Why not give them a meaning?
There are things we can do with that.
And as you were saying, indeed,
given that we have a
language that lets us do,
if we want to, zero cost abstractions,
we can actually use it.
Why not?
There are people in the room right now
who are working on floating
fixed point numbers
and doing very efficient stuff
and defining behavior as much as they can.
If you want exceptions all over place,
nothing is stopping you, of course,
You can use vector::at if
you're a very strange person.
Or you can actually use the tools
that will remove that for you,
using the ranged for loops and everything.
They will probably remove
all of those bugs from your
code in the first place.
But in C++, really reduces
the number of cases
you have to look out for.
So yeah, I agree with you.
Library solutions are probably better
than the abstract machine.
I doubt we will change
the abstract machine
to please those people.
It would be counterproductive
from a C++ point of view.
- [Man in Audience] All right.
- Anything else?
Thank you all for coming.
You're very nice.
(audience applauds)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>