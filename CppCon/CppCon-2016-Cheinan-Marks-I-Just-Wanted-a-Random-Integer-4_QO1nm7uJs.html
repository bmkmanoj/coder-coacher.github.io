<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Cheinan Marks “I Just Wanted a Random Integer!&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Cheinan Marks “I Just Wanted a Random Integer!&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Cheinan Marks “I Just Wanted a Random Integer!&quot;</b></h2><h5 class="post__date">2016-10-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4_QO1nm7uJs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right hello welcome to my talk
my name is hainan Marx I work at spiral
genetics and hence the cute little DNA
motif on the left and I just wanted a
random number that's all I wanted so in
my work I work with DNA sequences DNA
sequences are a lot of fun
they're single molecules every one of us
has three billion DNA bases in every
single cell of their body and basically
they are the same day we're what make us
stop us that's what the difference
between me and you is that's the
difference between me and a plant is a
bacterium all life that we know about
has DNA it's based on it this is not
what this talk is about DNA can be
represented as a string it actually has
an alphabet of for the alphabet is a C G
and T this is an example of such a
string in fact I was working with what
are called DNA reads these are short
snippets of DNA typically around 100
base pairs a base pair is a character
for us and they can go longer they can
go shorter but in my case I was working
with an algorithm that worked with DNA
reads these DNA reads needed to be
processed and one of the assumptions we
made was that the size of the read was
uniform throughout the entire sample now
a DNA sequencer typically will give you
a constant size DNA read from from its
output so that was generally a good
assumption but we were getting to the
point where newer sequencers were not
doing that and also to situations where
better statistical methods allowed us to
filter our DNA reads and then we could
cut out junky parts of the read but
still keep the good parts and so we were
getting variations on the DNA read size
and so I needed to vary the size of my
DNA reads going into this algorithm that
was my task so I'm a TDD kind of guy I
wrote the test I for this thing and
basically I wrote a test that took our
algorithm
varied the sizes of the reeds and so
what I wanted was I wanted a test it was
taken too long to cross the whole range
so I wanted to test that picked a random
read size and then within that read size
it would vary that read size within 10
or 20 percent that was what I needed
that was my unit test and so I thought
okay this is further more because this
was a test it was important to get it
good to get good coverage over multiple
runs of the entire range and I didn't
want to admit to any DNA sizes and
furthermore it was important to test the
edge cases specifically we had a tricky
edge case at 255 base pairs that I
needed to worry about so it was
important that we didn't miss those now
I'm an engineer if you were in Walter
Browns talk just now he gave great talk
about the random header he gave it from
a computer science point of view I think
and it was very interesting but I'm an
engineer if you know my talks I want to
do something practical I want to get
stuff done that's what's in my blood I
want to get my program finished and so I
am about to put a terrible thing up in
the screen
I wrote this yeah this started when I
was a kid and I wrote a game you know
and and the game this is what we did but
I was a kid I didn't know any better you
know now I know better but I was lazy
and I was thinking this is just the unit
test you know this is this is good
enough for a unit test it's not
production code it's not good to write
in real life I was rationalizing I think
the psychological term is and of course
if you went to Walter Browns talk or if
you watched STL's video or if you read
Ben Dean's blog or if you went to a
million other places you know this is
terrible
this is terrible in like at least three
or four ways
Rand is bad modulo is bad this is bad
don't do this okay I thought I was being
quick and clever and lazy and you know
again it's just a unit test this is good
enough I just wanted a random number so
for the purposes of this talk I'm going
to generate random numbers between 0 and
99 which is what this code badly very
very badly does maybe however in real
life that's not what my unit test did
but I'm going to omit all the additions
and subtractions that would have made it
go to the true range ok once and again
once I had that number between 0 and 99
I wanted to vary around that number plus
or minus say 10% so I went and I
remembered something about ran being bad
I had not watched STL's talk yet I had
not read Ben Dean's talk blog yet this
was actually a few years ago ok so I
knew that ran was bad and I went to the
manual and saw this little bit here the
lower order bits are much less random
than the higher order bits and what am i
doing I'm taking those beautiful low
higher order bits that are more random
and I'm throwing them away into the
garbage okay that I'm keeping those
awful lower order bits and throwing away
the good stuff it's exactly the opposite
of what you want to do could clearly
this is a bad idea but it's just a unit
test right this is not real production
code you know that the little guy with
the devil on your shoulder right he's
whispering it's it's good enough module
is good enough you know you're gonna
test things it's just a test
random is too complicated well so what
do they do I'm an engineer I wrote the
unit test for the unit test i wrote code
that exercised the random number
generator the so called random number
generator i showed in the previous slide
and looked at the DNA sequences that i
got from those numbers and you know what
they were terrible STD rand is not good
enough module is not good enough what
happened was that I was not catching
those edge cases that I needed and
that's the whole point of the unit test
right to you
unit test needed to catch those edge
taste cases I was getting poor coverage
of the edge cases with this with my rand
and with my modulo this was terrible
don't do that I realized that I can
do this so I sighed and I said said okay
well I guess Randleman is so what did I
do
I went to dr. Koh I typed in C++ random
I was running in C++ 11 and what came up
was STL's talk from 2013 I went and
watched it and it's a really good talk
he gives you some nice guidelines and
explains why things are done the way
they are and to sum it up if I may in
three lines use the random C++ header
use the Mersenne twister to produce as a
generator see the generator with random
and advice this is entropy and then used
an STD uniform inter distribution to
generate the actual random numbers okay
I can do that but I had some questions
after watching STL's talk what is
entropy exactly to me I was trained as a
chemical engineer so entropy is the
amount of work you can get from a heat
source using a Carnot engine this didn't
really make sense okay what exactly is
std random device people show examples
of using it but it wasn't quite clear
whether it was a function and object I
wanted to explore that a little bit STL
says that you should avoid the stack
putting the the Mersenne twister by the
way mt1 99037 is the Mersenne twister
for all practical purposes it and he
said avoid putting it on the stack he
says that that is because it's huge and
it is but were there was there more to
it than that
do I is in Mike's situation I work in
again in with DNA and so I work with 512
gigabyte machines putting five thousand
bytes in the stack is a rounding error
okay so I didn't really care but maybe
there's more stuff to go and then
remember that I was generating a random
size to my DNA sequence and then I
wanted a very dead DNA sequence within a
random range so I need to generate a
random number
Loup and then based on that random
number generated another random number
okay so the question is could I
construct a uniform int distribution
inside of a loop because at and I knew
from STL's talk that for example you
cannot do this with a Mersenne twister
that it's expensive to construct but he
was silent about whether you could do
that with a uniform distribution and so
I wanted to know that
can I is it cheap to construct is it
cheap to use can I do that in a loop
Walter brown on the other hand actually
made his static but I couldn't do that
because I needed to reconstruct it based
on the DNA size that I had you're
shaking your head okay so Walt Walter
says that he only made the static in one
example so by the way this is going to
be the outline of my talk the rest of my
talk is going to be about my search for
answers finding the answers to these
questions to the best of my ability and
the conclusion to my talk is going to
have nothing whatsoever to do with the
answer to these questions it was a very
surprising thing that I learned and it's
going to change the way I write code and
I want to share that with you and
hopefully will change the way you guys
write code as well so entropy what is it
well it comes from STD random device it
might block when it runs out I'm not
sure if FEL said they might block some
people said in my block it wasn't clear
what does it mean to run out of entropy
what is entropy what is an entropy pool
what does this all mean how do you run
out of it again to me entropy is is sure
I know it's randomness but how do you
run out of entropy so entropy is
randomness in fact I like I said I
studied Chemical Engineering so I'm not
a computer scientist but I did study
statistical thermodynamics and I knew
that entropy was the number of states
l can take and that is essentially
randomness right if if something is very
well organized there are a few ways that
it can be very well organized but if
something's random there's lots of ways
it can be random okay and so entropy is
randomness Computers okay we heard
something slightly different in the key
word in the in the keynote this morning
but computers are by nature not random
they are deterministic and that's a
great feature of computers I am relying
on the computer my macbook pro here to
show the same slides that I prepared
earlier in the same order that I
prepared them and I would be very very
upset if that didn't happen okay
so god forbid that my computer should
start being non-deterministic computers
can be pseudo-random Walter brown
explained that very nicely in his talk
by the way who was in Walter Browns talk
let me get a show of hands okay so I
won't assume that you guys were there he
really covered the header nicely and I
think my talk will mesh nicely with what
he covered and I won't repeat much
computers can be pseudo-random and that
can be nice because a pseudo-random
sequence is repeatable and what happened
here okay okay so so here's my proposed
random number generator to produce real
randomness okay this is a random number
generator you need to look at me now
this is my random number generator it's
a d20 okay it's an icosahedron it has
the numbers from 1 to 20 painted on it
you roll it and you get a random number
it's really clever 14 there you go
so 14 is today's random number and so we
could make a random number by taking me
you don't have to look at me anymore
shrinking me into a really tiny size
giving me a little tiny whiteboard okay
this little tiny person will roll the
die right the random numbers on the
whiteboard and then
requests would come in four random
numbers and as they come in the tiny
person would erase them off the
whiteboard and put it and give you the
random numbers okay this is what a
random number generator that is a random
device basically does now note it takes
a finite time to roll the die okay so
that it is not you cannot produce
entropy instantaneously randomness
cannot be produced instantaneously in
fact it's a fundamental as far as I know
it's a fundamental quantum mechanical
law that it will take time to produce
anything that produces energy and so any
time that you're going to do something
random it will take a finite amount of
time to do that okay so it takes time to
produce entropy that is physical law and
thus you can see that if the rate of
supply is less than the rate of demand
by the kernel you are going to run out
that is I the little person that we
shrunk it's stuck inside the CPU will
not be able to produce numbers on the
whiteboard fast enough because the
kernel is going to be asking for them
back and so here it's going to be
erasing them and it the whiteboard walls
be empty and thus you ran out of entropy
so that's what it means to run out of
entropy and now an entropy generator
might block until more entropy is
available so that means that basically
the little man in the or the little
person let's not be sexist little person
inside the computer is going to have a
clear white board and he's furiously
rolling to die and looking at what it is
and writing the number and that kernels
do many more so the kernel is just gonna
have to wait until he Murrell he or she
rolls to die and produces that number
okay so that's what it means to block
until more entropy is available now the
standard is silent about blocking as far
as I could tell and to me when the
standard is silent about something that
means it can happen or it doesn't have
to happen so let's talk about STD random
device a bit random device produces
entropy okay it can be used as a
temporary it's a C++ object that wasn't
exactly clear to me from the examples
the example
always instantiated but it turns out you
don't really necessarily have to do so
you can use it as a generator okay this
might be an estimate to some people but
you can it actually does produce random
unsigned bits and Walter okay Walter is
probably offended at this point because
he as he said random device really is uh
produces random bits but if you need a
youant number and that you int is
exactly the size produced by your random
device and random device will tell you
what that size is it has a min and a max
method then that actually can be good
enough and operator function call will
return that random number and that
random number will be determined by your
hardware and implementation so note that
this is a tricky thing we talk a lot in
this conference about
implementation-dependent right and the
the standard guys love to do that
because then it passes the buck on to
guys like STL who have to worry about it
instead of figuring it out themselves
but there are usually good reasons for
that
but in this case it's also hardware
dependent so your implementation might
do something and then you'll go to
another piece of hardware and something
different might happen and what you
really need to know about standard
random device is it can throw this is
really important and it can throw when
they cannot generate a random number
this isn't the standard okay so this is
really tricky because your test system
your development system might all
produce random numbers beautifully and
then you go to some other piece of
hardware at your customers site and for
whatever reason random random device
can't generate a random numbers it's
going to throw an exception and because
you never expected an exception to come
there you never caught it and your
application is going to blow up and
you're going to be in trouble so be
aware that random device might throw and
it might throw on somebody else's
hardware ok so just the fact that you
tested it on your hardware doesn't mean
it's always gonna work so please keep
that in mind
furthermore random device doesn't have
to be truly random again scare quotes
whatever that means
it might be pseudo-random and it
probably is slow I looked into the
implementation on my machine my machine
is a MacBook Pro running Ubuntu 1604 and
it is using slash dev and GCC 5.1 it's
using slash dev slash u random u random
is a device a Linux device that
generates a random number that is if the
hardware can supplied should be random
but it when it runs out instead of
blocking that's what dev random will do
instead of blocking it will switch to a
pseudo random in this case a Mersenne
twister to generate randomness so in
fact my random device will never block
it will switch to a Mersenne twister but
it doesn't do that very effectively so
let's talk about generators a bit okay
again I watched STL's talk STL I think
was pretty clear use the Mersenne
twister there's two flavors
there's the Mersenne twister 199 37 and
there's the 64 bit version the first is
a 32 bit version
seed it with STD random device it's
pseudo-random it's deterministic it's
fast these are all great things and in
fact for my unit test
I wanted something pseudo-random why
because the unit test is testing my code
sometimes something will go wrong and
when something goes wrong I want to
reproduce it so I printed out my seed in
the unit test I logged it and then when
there was an error and this actually
happened when there was an error if I
had truly random number generator I
wouldn't be able to reproduce my earth
because the next run might have worked
just fine okay so well here's a here's a
hint if you're gonna use unit tests with
random numbers log your seed and then
you can reproduce your unit test exactly
when it fails and fix your bug and
that's exactly what happened that's
exactly what they did
I had a failure I went to the log I
grabbed the seed I hard-coded it in
instead of random device I just put the
number and I reproduced it a hundred
percent and I fixed the bug life was
good
so I said it was fast and ice it was
faster than random device so when I say
something like that I want to measure it
I'm an engineer I don't believe it when
somebody tells me something's fast so I
measured it by the way I'm I don't have
any code for this talk because all the
code is really trivial but I'll be glad
to share if somebody really wants it but
basically I wrote a loop that generates
a billion random in I don't think I need
to share that code with this audience I
hope and what it does is when I used
random device to generate the random
numbers it took 44 seconds and when I
used the Mersenne twister it took it 3.6
seconds and so sure enough the Mersenne
twister is fast it's great everything is
good
remember however random advice might be
hardware its multi-threading
multi-threaded behavior is not clear
it's not clear what happens when you
access it simultaneously for multiple
threads does it serialize the accessed
or does it give you the same result it's
not clear it's tricky okay and the
Mersenne twister can be made
thread-local and so each thread has its
own copy and that may be a very good
idea in fact because if it's not as
Walter brown told us you're gonna have
to serialize access to it but if every
thread has its own copy you have to be
careful to initialize them correctly if
you initialize every single thread with
the same seed you are gonna get the
exact same sequence in every thread now
maybe that's what you want but maybe
it's not what you want so think about
what you're doing and initialize
carefully and remember that random
device might not behave nicely under
simultaneous access and so my suggestion
would be produce your initialization
first then get your threads going and
supply the initialization to the threads
later so you can do the initialization
sequentially or you can just serialize
access to the random device it doesn't
really matter so back to my plan
everything was going well STL Guidelines
really did a nice job they certainly
made my unit test work I could make it
work but I got to thinking and I got the
note that this slide is the reason I'm
not a billionaire so I started thinking
instead of making money and it occurred
to me that some questions still were out
there the Mersenne twister is pretty
good but it's five thousand bytes on
stack and it's slow to initialize now
officially the Mersenne twister is
twenty five hundred and four bytes on
the stack at least the ones we're using
here but I again I'm an engineer I
actually went and did the size a size of
on D generator and I got five thousand
bytes I don't know if this is a bug I
think it's a bug I'm not sure yeah okay
so STL says that this might be an
implementation cleverness basically so
I'm essentially trading space for speed
and that might be it interestingly
enough the 64 bit Mersenne twister was
twenty five hundred and four bytes in
the stack so all right I also said it
was slow to initialize and again when I
say something is fast and going to
measure it I'm also going to measure it
when I say something is slow all right
so I wrote a loop I initialized the
Mersenne twister and oh my god it's slow
it took fifteen seconds to initialize it
a million times okay remember I was
generating a billion numbers with the
Mersenne twister was the Mersenne
twister in three point six seconds and
here to generate to initialize it a
billion times would take 15,000 seconds
ie hours ok many many hours so it's very
very slow to initialize in fact it's
slower than random device well so you
might say to me well I'm not going to
initialize it a million times or a
billion times you know I'm why should I
use random device I'm going to use
operator function call and I'm going to
do
correctly but there's a catch if you
write code like this okay and you put
the Mersenne twister on the stack every
single time that you call F you are
going to initialize your Mersenne
twister
okay and now remember initializing the
Mersenne twister is very very slow so if
you call F repeatedly you are going to
get a serious slowdown in your code
because of this function and so to me
the fact that the Mersenne twister was
huge in twenty five hundred and four
bytes or five thousand bytes in the
stack was a minor problem but this is a
major problem and this is to me is the
major reason why you should not ever put
to the Mersenne twister on the stack in
the case of my unit test I was pretty
sure that I was going to put it in the
beginning of the unit test and I was
only going to call it once but you know
what I made it static anyway and when
you make it static you don't have to
worry about it now you only initialize
it once and things are better and faster
so back to the guidelines from STL's
talk
they really make sense use STD random
device to seed your generator and keep
the Mersenne twister off the stack it
doesn't belong there
make it static make it thread local if
you really really want to put it on the
stack do it but beware construction
costs don't put in the situation where
it's called over and over and over again
if for whatever reason you're running in
an embedded system twenty five hundred
and four or five thousand bytes is too
much the standard offers min STD r and
it's much smaller footprint it's much
faster and it but it's cycle is much
smaller okay so that it will repeat
itself a lot sooner than the Mersenne
twister which if essentially will never
repeat itself in somebody's lifetime
okay again
I'm me so I said something was faster
what did I do
I measured it and sure enough it is not
faster it turns out that the Mersenne
twister is actually faster than min STD
ran so Oh
the only reason then to really use min
STD Rand is if it is if that twenty five
hundred four bytes and the stack is
really important to you okay a little
diversion
this is mavin Nelson he was a French
priest lived in the 17th century and a
really interesting guy we're gonna have
a slight detour into history of science
he was the guy who discoveries called
the father of acoustics because he
discovered the relationship between the
frequency of a vibrating string and its
length and and that early physics and
the relationship to the notes and the
frequency relationship between the notes
he didn't get it quite right but he was
pretty darn close for some of the living
in the early 17th century you can only
imagine what it was like to do science
back then he and I'm gonna take I
learned this from watching Alec Stepanov
talks at a nine he is the father of the
scientific journal and this is really
really cool he was the first guy in the
world in the whole world to get the idea
of writing to scientists getting the
results and then publishing them out to
other scientists so the idea of
scientists publishing their results and
giving them to other scientists original
originates with mavin Mouse Nelson back
in the 17th century nobody was doing
this yet and so this was the foundation
to scientific journals to things like
the Royal Society there was one in
France - there was one in well it wasn't
yet Germany there was societies of
scientists didn't got together to
exchange results this is all thanks to
his work and so that of course led to
the scientific conference and so in a
way my van Nelson is responsible for CPP
con so thank you for that he is also
known for Mersenne primes and Mersenne
primes are what the Mersenne twister
uses and why the Mersenne twister so
named Mersenne primes are prime numbers
that have the property of being 2 to the
n minus 1 where n is prime so M sub 3 is
7 to the 3 minus
107 m sub 7 is 127 okay note that not
every prime end produces a prime number
in this way but in fact they're quite
rare the largest known Mersenne prime is
M 74 million two hundred seven thousand
two hundred eighty-one and it's a 22
million digit number it's ridiculously
huge the there is a list on Wikipedia
that you can find of all the Mersenne
primes I think there's 30 or 40 of them
right now there are known and there are
people constantly looking for new ones
why mt1 99037 it's because the period of
STD MT 193 7 is the 19 thousand nine
hundred and thirty seventh Mersenne
prime which is a six thousand digit
number so think about this if you are
generating random numbers with your with
with your unbelievable processor that
can that lets say it's oh not even
terahertz and what's what's past
terahertz I don't know let's say it has
a cycle time of 10 to the minus 18
seconds you're still gonna die of old
age before you're even close to running
out of random numbers with something
like that this period before you're
repeating yourself the period of the
random number generator is humongous
finally MT 199 37 and Walter Brown
touched upon this is a type def of the
Mersenne twister engine the Mersenne
twister engine takes a whole bunch of
parameters and does mathematical magic
with them and produces the immersive the
Mersenne twister engine you cannot play
with these parameters willy-nilly again
Walter Brown said that very nicely if
you play around with these I think he
said something about being a fool don't
do that unless you really really really
know what you're doing because you
probably are not going to get a good
random number generator and certainly
not better than what we have here a
couple of the interesting numbers to
note is that 32 is the word size of the
engine 624 is the state size of the
engine so we're going to store 624
32-bit numbers and of course notice that
32 times 624
just short of 2,500 so that's most of
your 2500 and 4 bytes is that array of
624 words and that's where the size of
this comes obviously you can make it
smaller but then it won't be a good
engine if you really really want the
dirty details I refer you to the
original paper about the Mersenne
twister it's from 1998 so it's pretty
recent and yet it's still good enough
that we've had a lot of experience with
it and know that it's a pretty good
generator so that's the end of the
diversion about marason really cool guy
gives the name back to our talk back to
C++ so the guidelines seem to make sense
but hang on a second this talk was
inspired by STL's talk in 2013 I was not
the only person inspired by STL's talk
in 2013
professor Melissa O'Neill at Harvey Mudd
College
also watched a talk and she writes about
in reddit and I know that putting that
URL is useless to you guys and even more
useless to you guys out there watching
this at home so you can either search
reddit comm for PCG random or trust tiny
URL and notice I put the preview in
there so you can actually check that
it's going to read it and not to my
secret evil malware site but you're
still trusting tiny URL that they don't
send you to some malware site but anyway
I urge you to go read Melissa O'Neill's
discussion of how she came about how she
watched STL's talk and came up with PCG
PCG random is her better random number
generator of pseudo-random numbers
generated that she came up with a couple
years ago in 2015 she published she
wrote the paper about it I don't believe
it's been published yet and there is
also a C++ library that's compatible
with random with random header that's on
github at this address it's much much
smaller in size than MT 199 37 and it's
much faster than MT 1 9
3:7 if you go to her website dub dub dub
PCG random.org her paper is there her
paper is really interesting reading i
urge you to try and read it it's not
that bad the mathematics is pretty is
quite readable in my opinion she also
has comparisons of the various random
number generators are very interesting
and enlightening and she runs them
through statistical tests and she shows
where the Mersenne twister falls short
and where PCG random supposedly does
better now i say that's faster than
Mersenne twister so what am i gonna do
i'm gonna measure it sure enough it's
two and a half times faster and
generating a billion random numbers than
a Mersenne twister but it's not in the
standard and if it being in a standard
is important to you then obviously you
can't use it I gotta say the library
that I downloaded from github made it
really easy to use with the random
header and it was not a problem all you
have to do is not type STD colon colon
okay it's not that big a deal obviously
since it was invented in 2015 we have
much less real-life experience with it
and so there might be some bug in there
I'm not in a position to evaluate this
mathematically not even close and she's
much smarter than me but presumably her
paper will go to peer review and will be
looked at by people who are qualified to
judge it and I and Walter Brown told us
that there is actually a standard
proposal to include it in a later
standard possibly and so that would be
really cool it seems to be a very nice
random number generator another really
nice feature that I like about PCG is
that it has multiple streams what that
means is that you've seeded with one
number but you can have a constant that
varies across the generator and this
will produce a different sequence of
random numbers for the same seed this is
really nice when you're doing multiple
threads because remember I talked about
the initialization problem this can
avoid the initialization problem because
you could use the thread ID for that
constant that the constant does not have
to have
any entropy in it it just has to be
different you're still going to get a
good series of random numbers but you're
going to get a different series of
random numbers and you can use and and
Melissa O'Neill's
algorithm will produce more streams than
you'll ever have threads I promise you
so go read her paper go read your
website lease and check out the party
tricks while you're at it okay so that's
generators let's talk about the uniform
and distribution specifically my
question was can I instantiate it in an
inner loop this was my big worry because
I was generating a random number and
then I was generating a random number
based on that random number so I was
generating inside the loop we know that
generating the Mersenne twister engine
is very slow and you shouldn't do that
what's the case with uniform int
distribution well I did what I always do
I peaked I looked into the
implementation in GCC 5.1 and obviously
you're in your implementation may be
different and what the constructor does
at least in my implementation is it
stores its two template arguments
remember the in distribution takes two
template arguments and those are the
range of the distribution right the
range of course is inclusive as stl
explains that's because you might want
to make the range cover the entirety of
your integer space and if it's off by
one that is the end is one past the end
as we normally do you're not going to be
able to get that last integer because
you only can specify that as your end
right you can't specify a 32-bit integer
that's one past the end of 32-bit
integers so the range is inclusive the
constructor stores those two arguments
into member variables it's trivial
operator function call branches and
calculates it does some multiplications
and divisions there's not much code to
it it's pretty straightforward in fact
it was really interesting to check it
out
standard this uniform integer
distribution is one of those things that
would be really hard to come up with if
you had to and I think it still had to
but I didn't I got I didn't read his
but I read the GCC versions but once you
read it it's really straightforward and
simple to understand and that's really
cool I I think it would take me many
many hours to come up with it but it is
not that complicated to understand so I
suggest check out your implementation
read the code it's not much code it's
maybe 10 20 lines of code or something
like that and I converted to math and
looked at it was very very nice and so
high I looked at then I looked at the
implementation of the integer
distribution it's really straightforward
but of course I want to measure this
right I'm not going to just say stuff
I'm gonna measure it and so this time
I'm gonna show some code this is the
code that I use in all of the setups
basically I generate a billion random
numbers using the integer distribution
in my case between $0.99 inclusive and
it took twenty three point four seconds
to generate these random numbers
notice that I'm constructing the uniform
distribution outside the loop right this
is how we learn to do this in basic C++
never construct something inside the
loop because every time through the loop
you're gonna have to construct it then
destroy it then the next time through
the loop you're going to construct and
destroyed again right and in this case
you can do it a billion times but I
wanted to know the cost of constructing
it so I stuck the constructor into the
loop and I would expect the results to
be about 10% slower just a bit slower
and sure enough it was four and a half
times faster that was my reaction I
couldn't believe it
I tested Einstein's assertion about the
definition of insanity which is
repeating the same thing and expecting
to get different results I repeated the
experiments I recompiled it I got the
same result I stared to disbelief I
actually went to sleep I was like no
this made no sense so the next morning
or the next evening I got back to this
and I thought well okay it's the
optimizer right it's 2016 optimizers
totally
I gentlemen know what they're doing I
don't know what they're doing they are
doing amazing things so it's probably
the optimizer so let's test that it here
the numbers for the constructor in and
outside the loop I turned off the
optimizer I reran it and I got exactly
what I expected
okay so the optimizer is doing clever
stuff here but what's scary about this
is that the optimizer is optimizing a
situation which I would expect to be bad
into something that's better
this is really scary because what am I
gonna do now change all my codes to put
constructors into loops I don't think
that's a smart thing to do necessarily
the furthermore all I know this is some
quirk in GCC's implementation and if I
use GCC the latest GCC 5.1 is not even
close to being the latest right if maybe
if I switch versions or switch to clang
or to Visual Studio I'm not going to get
this maybe it'll be worse who knows
right so this was a little scary
so I decided okay I'll poke into this a
little bit and I poked into the assembly
code and I it turned out it wasn't even
that complicated can you see that code
it's not really important if you see it
or not okay this is the code from
operator function call that gets called
when whenever you're generating a random
integer distribution okay as I said
there's not much code this is actually
half the code what it does is the
branches between two situations if the
integer distribution is bigger than the
random number generator range can
produce then it does one thing if the
integer distribution is smaller than the
range that the random number generator
produces then it does another thing and
of course the random number engine will
tell you how big numbers it generates is
Walter showed us it has it's one of the
methods that you call on it and so I'm
in my case the I'm going from 0 to 99
the random numbers generate a integer
from 0 to 4 billion whatever 2 to the
32nd is and so clearly I'm smaller and
so that's the branch
and I went into the debugger with the
optimizer turned off and I single step
through the code as I called operator
function called this is the code for
operator function call a single step
through that code and every line
executed basically okay so then I turn
the optimizer on I left the debugging
symbols on and I single step through the
code and this is the code that got
executed now I don't know if this is
enough to explain I mean it was four and
a half times faster I didn't cut out for
an you know enough eighty percent of the
code to make it four and a half times
faster there might be cache effects
going on here I really don't know I
poked in a little more I didn't I ran
out of time before I had to come here
and talk before I could really figure
out but what I do know is I now have a
subject for next year's talk so this was
really really interesting and very
surprising and but but clearly the
optimizer is doing something I think it
has something to do with the locality of
references here that when the optimizer
sees the constructor in the loop it
knows that we're calculating these
values already and doesn't repeat itself
it I don't know I'm not going to
second-guess it it's smarter than I am
it's doing its job nicely this is really
cool and yet really scary
so guidelines I'm not going to give you
guidelines I'm an engineer and I believe
in engineering judgment okay engineering
judgment is about taking the trade-offs
in your choices and weighing them
against each other and that's what
engineering skill and judgment is all
about right there is always trade-off
there's always judgment I think we're
all good enough that we're not going to
make silly mistakes if you're worried
that you will go watch the video of
Walter Brown's talk that was just before
me here he will cover the random number
he covers the random header very nicely
and exhaustively and tells you about
some pitfalls okay so once you're past
that bump okay that's where your
judgment comes in random is safe if you
follow STL's guideline you will never
probably get in trouble the only way you
might have a problem is if that 20 504
bites on the stack is a problem for you
if you're an embedded system that could
be a problem and yeah I actually have
one of my toys systems that I do as a
hobby that where that would be a problem
okay but generally that's not a problem
random is safe the random header is safe
the PCG algorithm is fast small and
simple it's cool I really like Melissa
O'Neill's webpage she's really smart her
papers great and I want to use it you
know and if you're if you're in a
situation where you just want to use the
coolest stuff consider it okay it is not
well tested there might be a fatal flaw
in it for all I I know she's it
certainly is not secure the Equality
random numbers and so I think ripple
will not be using it anytime soon I hope
not but it's really cool and it's fast
and simple and it would work on my
embedded device furthermore there's also
a C interface which gives you a simple
function that you can call and so if you
don't want to bother with the C++ random
header then you don't have to personally
I think you should because when you're
using the C interface you're tempted to
do silly things like use the modulo
operator to do a uniform distribution
which you should never ever do so use
the C++ one that's my choice for the
trade-off but really the most important
guideline which actually is a conclusion
is always measure your code and measure
the speed of your code and so what I'm
going to do from now on is I am going to
put performance tests into my code
because it was clear to me from making
this talk and I hope it's clear to you
as well that the compiler and the
optimizer can do very strange things to
the speed of your code based on minor
tweaks to your code and furthermore like
I said it would be nuts to go in and
start putting all of my constructors
into my loops but if I had performance
measurements for my code I could then do
this right and then I could put the the
Constructors into loops one at a time
rerun my performance and see what
happens okay obviously you use your
judgment they're probably loops where it
makes no difference where they run so
slowly and you know that but any times
you're
your time critical when you have that
measurement of your speed you then can
experiment with the code and with the
optimizer and with the settings to see
what's going on and get better results
potentially so always measure I am going
to start measuring my performance
religiously now from now on and just
like I learned to use unit tests many
years ago and I now swear in by testing
and because right when you when you
break your code you know it and then you
can experiment with different coding
implementations I am now going to start
measuring my performance and
incorporating that into my test suite I
think that is the most important thing
that I got out this talk I hope I
convinced you of the same so to conclude
STD random device generates random
numbers it doesn't do it very fast it
may not do it very well it has some
pitfalls but it does it in a typical
system like my system my laptop here it
actually generates hardware-based random
numbers whether those are good or not
depends on a lot of things and I'm in no
position to measure them there are
statistical tests you can use but as
we've learned this morning in the
keynote you cannot distinguish
sufficiently good pseudo-random numbers
from truly random numbers usually using
statistical tests alone so does it
really matter
probably not the Mersenne twister is a
really good engine to use STL mixed up
very clear if you're a little more
adventurous you can try the pc
generators and in fact I did try them I
really liked them whoops there's a typo
distributions are cheap to construct
they're cheap to use so throw them in
the loop go ahead and use them what's
really important with distributions is
that you use them don't ever do the
module now I want to be clear really my
conclusion applies to integer
distributions I didn't measure all of
the distributions and it's very possible
and in fact I just learned this from
Walter
talk an hour ago it's very possible that
some of the more complicated ones are
not cheap to construct and are not cheap
to use it really depends on the
implementation and his Walter Brown made
clear the implementation is free to use
the algorithm it wants in its
distribution unlike say the engines
where it's where it's forced to do is a
different specific way
Walter nods yes so I hopefully got it
right and but for integer distributions
at least in my implementation I don't
doubt any of the other implementations
are different they're cheap to construct
and use so do so don't be hesitate to
use them I not going to cover STD sample
because I don't have time Walter brown
covered it briefly too but STD sample is
new and C++ 17 in 14 at least some I've
compiled it's available in an
experimental TS and it allows you to
randomly sample from a distribution and
that essentially gives you sampling
without repetition this is a really nice
algorithm when I was a kid back when I
wrote junk like the modulo and used R
and I also wrote my sampling with our
repetition by what Walter calls a
rejection algorithm basically I
generated a random number if it was not
the one I wanted I just generated
another one until I got the right one
this is less than ideal sample we'll do
it right there are a better algorithms I
did look them up actually and implement
them since but it's available in C++ 17
it's new and it looks pretty cool but
the most important conclusion again I'm
going to repeat myself because I think
it's important benchmarking code measure
your performance and have the ability to
be able to tweak your code and see what
the effect of tweaking your code is on
the performance again that conclusion
really surprised me it has nothing to do
with random integers but this is where
my path led me when I just wanted a
random integer so thank you for your
attention I want to acknowledge STL for
his great talk that got me started and
inspired the whole thing Ben Dean's
blog has some really nice observations
on how not to use random number
generators and it's very well-written
and Walter Browns talk I hope you go
watch it if not we
seeing it not in the past but in video
it's a nice introduction to the random
header and thank you very much for your
attention and I will take questions in
the last few minutes Wow it's that clear
sure so STL's question was in my
production code that I ever have the
chance to use the distributions other
than the uniform integer and my and the
answer is yes it turns out that DNA
sequencing again produces reads so you
have three billion DNA is your DNA is in
23 chromosomes which are molecules of
DNA right 23 pairs of chromosomes
actually and those are essentially 23
strings of hundreds of millions or going
down to tens of millions and the smaller
chromosomes of characters of these ACTG
characters okay and what you do in
modern sequencing well not not modern
sequencing but what's called shotgun
whole genome shotgun sequencing is you
chop these up into little bits
randomly okay and you you read those all
right it turns out that the way you find
out whether a certain base what its
coverage we want to know what the
coverage of a base is okay and it turns
out I'm not going to go into this
biology but turns out that's a Poisson
distribution and so we have used the
Poisson distribution to simulate that
system okay we also use normal
distributions because the Poisson
distribution actually is a discrete
normal distribution if I remember my
statistics correctly and we did we used
any others
no I'll just note that I wrote I was
working on a statistics program many
many years ago back in 98 and was
unfortunately in C
where we actually implemented a whole
bunch of these things so we use basalt
we use normal and we use uniform int I
think I use uniform real I hate that
name because they're not real numbers
but let's not get into that I didn't
pick the name so those are the four I
used thank you any any other questions
okay well thank you very much for
attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>