<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2014: Titus Winters &quot;The Philosophy of Google's C++ Code&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2014: Titus Winters &quot;The Philosophy of Google's C++ Code&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2014: Titus Winters &quot;The Philosophy of Google's C++ Code&quot;</b></h2><h5 class="post__date">2014-10-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NOCElcMcFik" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Titus twinners I'm the tech lead for
the C++ library team at Google which is
responsible for many of the fundamental
infrastructure utility sorts of API is
in Google's C++ code base this means I
work very broadly throughout the code
base I have kind of the 10,000 foot view
of one of the largest code bases in the
world I make and review changes
throughout that entire code base I do a
lot of training and writing internally
the not really far off statement that I
make is Google's C++ code base is my
product one additional way that I effect
C++ development at Google is that I'm
one of the style arbiters which is a
group of three of us that are empowered
to make decisions about what does and
does not go into the style guide and
generally is setting the path forward
for our C++ code base in the next five
and ten years this talk is partly about
our style guide but only as a mechanism
to start the general discussion about
style guides overall I kind of want this
to be a meta discussion on what do you
get out of a style guide and how should
you make those choices this is really a
style guides how do they work sort of
talk okay
I thought about just retitling its style
guides but titles for this talk was
submitted so long ago that didn't have
the opportunity so clearly this is a
talk about style guides so clearly this
slide here is the most important right
we're just talking about how do we
format our code right right all right
anyone want to take the bait on that
this is a boring and stupid question
right specific
here more all right as far as I'm
concerned go use Klein format all right
how many of you have heard of clang
format any of you are using clang format
next year I want every single hand in
this room to go up because if you are
not you are just sadly in the dark ages
right like Oh
painful it is better on average than
humans by a significant amount I have
looked at hundreds of thousands of lines
of code formatted by humans and
formatted by the robot the robot is
better than you on average we do not yet
require globally that Google C++ code is
just blindly formatted because there are
some places where domain expertise and
and specific knowledge matter formatting
a matrix for interest there are for
instance still has some human judgement
to it the robot can't quite identify oh
look that's that Scott structure to it
failing that I rarely see this go wrong
so don't use clang format and this talk
is not about that so perhaps this talk
of is about what goes into a style guide
and I would say that this is still not
quite a high enough level question right
this is not about what does and does not
go in this is about why something would
go in okay what is the purpose of a
style guide all right what is your
organization getting out of having a set
of rules all right what's the purpose of
any set of rules that your organization
puts out all right clearly we have all
learned the important lesson from our
middle school PE teachers that rules are
there to throw your weight around and
make people jump through stupid hoops
right now you all need to get down and
get me 20 push-ups
all right this is not what rules are
about all right you should not be
setting rules in your organisation
willy-nilly all right rules have cost
okay a style guide is here to make it
harder for people to do bad things and
easier for people to do good things
since your style guide probably is
silent on questions of kidnapping and
murder
I am using these in air quotes because
let's face it there's a matter of taste
and judgment here right figure out which
things your organization cares about and
try to encourage and discourage
accordingly okay
generally for this talk I'm going to
talk in two parts and then let you guys
bring out the pitchforks and torches
first I'm going to look at the
underpinnings of Google C++ style guide
okay these are the things that we have
identified as the goals that we are
trying to serve with having rules right
we have identified eight kind of base
principle things that we aspire like
goals serve these purposes rules serve
these purposes then we will talk about
the contentious rules which is I'm sure
what got you all out of bed at 9:00 in
the morning and then we will have lots
of time for Q&amp;amp;A you can point out new
contentious rules to me and I can we can
spar it'll be fun
okay so in order to understand the rules
that Google has set forth you have to
understand the context in which those
rules are applied okay I will be
completely blunt I don't care if you use
Google's publicly available style guide
in fact in many cases it's probably
optimizing for a different set of values
than your organization needs alright how
many of you work for a company that's
less than two years old Wow seriously
there are no startups in the lines how
many of you work for a company that has
less than 10 million lines of code fewer
than 10 million lines a million lines of
code also interesting how many of you
have fewer than 200 coworkers how many
of you know almost all of the other
coders in your codebase yeah there are
we start to get big differences all
right about us
there's
4k ish C++ engineers it's actually
really hard to get a decent census on
this this is kind of my best guess we
work in a shared codebase it is a single
monolithic code base with a very strong
testing culture it weighs in it a
hundred million ish lines of code one
thing that is really critical for us has
become increasingly valuable in the last
couple years is we have an indexer for
our code base right this is maybe not a
term you're familiar with a lot of the
rules in the Google style guide from
back in the day were based on the notion
that if you wanted to figure out where
something was being used you may have to
grep for it it is not easy to grep for
operator equals or uses of operator
equals right this is not a trivial thing
all right
we have an indexer we started talking
about this publicly about a month ago I
think there was a talk at Twitter the
tool is called kite and what it does is
it takes the parse tree out of clang
because clang is the hammer for all of
our nails it takes the parse tree out of
clang and indexes all of the nodes in
the parse tree right across the whole
codebase alright so when we want to know
now
when is operator equals on this object
on this class being called we know
exactly everywhere in our code base that
that exists grep is no longer an
interesting part of our maintenance
strategy another important piece to be
aware of is that there is a wild
variance in C++ background we have a lot
of Engineers we hire a lot of engineers
we hire a lot of talented yes new grads
but I don't see a lot of university
programs that focus a lot on C++ I would
love to be proven wrong on this how many
like people graduated in the last couple
years and had more than a year worth of
C++ how about Java what did you guys
study
well as a simple yeah sure but like what
did you study in school if not I'm
curious right
Fortran clearly it's portrait we have a
wild back of wild variants in C++
backgrounds right so I would say that
most new grads if they got C++
background it all probably have like
maybe a year's worth of experience with
it in one class right so that's let's
call it a hundred man hours required C++
background many have more experience
than that but it varies then on the
other end of the spectrum we have ACM
fellows and Lifetime Achievement Award
winners and people on the Standards
Committee and etcetera etcetera etcetera
all right there's some weight range here
we want to make sure that everyone can
operate not just the experts thankfully
we have very very good code review
policies thankfully this does mitigate
some of the variance in C++ background
because it's going to take some expert
understanding before anything gets
checked in and one of the things that I
think is most important we expect we'll
be around for a while it is hard for me
to envision scenarios where we are not
largely working in this code base ten
years from now I kind of don't see
Google tanking completely and less than
that amount of time and I kind of don't
see go killing C++ off and less than
that amount of time at least not for our
usage if it happens that'll be
interesting but I'd be surprised
therefore if we have a you know
knowledge that we're going to be around
for ten years we need to start planning
to make sure that we're not dragging an
increasing weight after ten years
most projects checked in the same code
base drat I did sorry
most projects checked in the same
codebase most engineers have read access
to everything in the codebase most
projects in the codebase use the same
basic infrastructure build system common
libraries all of that okay that's us
right in these contacts
the rules get applied all right code is
going to live a long time be read many
times we are optimizing for the reader
not the writer which is actually
philosophy number one optimize for the
reader not for the writer we are far
more experienced with the experience far
more concerned with the experience of
code readers this is not unusual but
this is explicit decision and philosophy
number one write code is going to be
written many many many more times than
it is to be read many more times than
it's written right you will spend much
much much more time looking at it than
writing it we kind of don't care if it's
tedious to type it so long as it's clear
for the reader rules should pull their
weight we're not going to list every
dumb thing you shouldn't do this is not
a good use of rules right
specifically we don't expect the style
guide to be interpreted in a lawyerly
fashion occasionally it happens but
we're not going to go through and list
off absolutely every action that is
illegal we would rather have a
high-level rule don't be clever a
similarly valuable high-level rule would
be don't be stupid we should we should
add that we would like to value the
standard but not idolize it right not
everything that goes into the standard
is the solution for all problems
tracking the standard however is
valuable right the more that we stick
close to the standard the more that
publicly available information helps
alright CPP reference is a great
reference because everyone is already
using the same things spending the same
amount of time and effort on getting
internal docs up to date would require
more manpower than I have so value this
dinner moving now down into more and
more concrete things be consistent
alright
consistency allows expert chunking by
chunking I mean in a cog size sort of
sense if you look at how expert chess
players work they are not thinking about
the positions of individual pieces
they're looking at configurations of
pieces and how those are likely to play
out over time right there's a cognitive
difference in how experts perceive a
problem then how novices perceive a
problem this works when things are
structured in similar ways right if we
solve all of our problems with the same
set of infrastructure and interfaces and
we format them in reasonably consistent
ways it's much easier for an expert to
glance at a piece of code and understand
what it's doing this is much like what
BR nee was saying yesterday you know
with find if okay consistency also
allows tooling when everyone is using
the same mutex we can decide at some
point to add deadlock detection to how
we handle our mutex
for instance when everyone rolls their
own mutex no such ability okay this is
obvious and consistency of course also
allows us to stop arguing about stuff
that doesn't matter all of the
formatting stuff not things that fall
into the be consistent category the
obvious stuff include guard naming
formatting parameter ordering we say
inputs first then outputs unless there's
some reason to do otherwise how do you
name your namespaces declaration
ordering how where do things go within
the structure of a class null null
pointer naming of variables in general
camelcase
underscores all this stuff formatting
and don't use streams because our code
base consistently does not use streams
except except it kind of sort of did and
when we were going through actually
prepping this we decided you know this
actually fails all of the previous three
tests all right like it's not
consistent like we've already kind of
violated our consistency principle it's
my format strings are a little tricky
from time to time it's not obvious right
this just kind of it didn't pull its
weight and we weren't getting nearly as
much value out of having this rule as we
were taking pain for people wailing and
gnashing of teeth over this rule so
there is a change out right now which
sometime will get checked in that will
strike this rule so we're not zealots
one of my absolute favorite rules if
something unusual is happening leave an
explicit trace for the reader so the old
example of this stems from no
non-constant references right if you do
not pass if you only passed con stress
through interfaces that is if as a
function argument you do not take
non-conference --is then when you have a
value and you want to pass it to a
function that might mutate it by
necessity you have to add the ampersands
this leaves a trace to the reader
reading this and knowing that rule you
guys can all tell that this function
could conceivably modify arts and art v
this is valuable is there's some
problems with this rule the rule that I
like much better is actually a unique
pointer this one is hopefully less
contentious the design of unique pointer
and it's specifically the fact that it
does not have implicit conversion from T
star makes use of unique pointer to
demonstrate ownership transfer a
beautiful thing even and perhaps
especially in a code base with tens of
millions of lines of legacy code that
predated unique pointer alright so for
example at no point can you be
transferring into
ownership of a pointer across an API
boundary without leaving a trace that
you did so okay if I have legacy code
that returned a newly allocated pointer
as a raw pointer it's clear to the
reader right I used unique pointer hey
now I own it
great that's nice from old-style
returning art from a new style method
returning and storing it in that when
I'm returning a unique pointer and
storing in a row pointer there's an
explicit call to release right we do
expect that everyone understands the API
for a unique pointer even if they're not
using it or their old code is
inconsistent about it and similarly it's
clear when you're using it in new KPIs
same sort of thing applies going in the
other direction
yielding ownership into a function in
all cases at the call site it is clear
right it is not necessary for every code
reviewer to know the ownership transfer
behavior of absolutely every function
it's clear at the call site all right we
have left a trace it's self documenting
this is very very valuable some other
rules that help leave a trace for the
reader we really are big on override and
final the old rule used to be in a
derived class if you're overriding a
method leave the virtual on write
doesn't tell the compiler anything but
it does suggest to the reader oh hey and
remember this one's virtual you might
want to go look in the parent class
trouble is there's lots of ways that you
can screw that up you drop a Const you
have a typo you know bad kerning
whatever and if your function isn't
actually overriding right this is very
surprising right it's hard to debug
override and final solve this one of my
favorite things although they put the
keywords in the wrong spot
uh interface glasses named them as
interfaces function overloading our rule
of thumb is don't overload if it matters
which one you caught if it doesn't
matter which version of the overload you
caught then it's an overload if it
matters and the behavior depends on
which type was passed in name it a
different thing alright that's a really
good rule of thumb for when you should
overload something right and no
exceptions
because error handling being explicit
leaves a trace for the reader there's
other reasons for no exception there are
many features that C++ there more
surprising or dangerous at runtime or in
subtle cases than you might think
moving into even more explicit cases are
is this concept of let's just avoid the
stuff that's dangerous alright and in
some cases you know you could ask for
the style arbiters hey I'm trying to do
this I know that this is the rule is
this okay and we might say yes but it's
going to require a pretty strong
argument and probably some comments to
make sure that you don't you know allow
someone to accidentally copy and paste
the wrong thing blah blah static and
global variables of complex type things
that have you know destructors that do
work in a multi-threaded system they may
have been destructed while some other
thread is still running and accessing
them and then badness happens right we
disapprove for that reason this is hard
for a lot of people to really
internalize and subtle using override
and final again this avoids the surprise
of why did this not work I don't
understand I'm having trifa and
exceptions can just plain be dangerous
in a codebase that's not exception safe
avoid things that are hard to maintain
this is kind of the meat and potatoes
like don't do silly things most codes
should avoid the tricky stuff right you
shouldn't have to go to complex
solutions one of the guys that I work
with
as a great mildly off-color anecdote
which is every codebase at Birth commits
number one is granted abstractly one
sack of cow manure if you are wise no
let me rephrase if you are foolish you
take said cow manure and just smear it
all over the walls just paint the town
with it it would be a template here and
some macros and we no one can read our
code not a great plan if you're wise you
use said sack of cow manure and
fertilize the growth of the important
stuff right you only have so many
degrees of freedom in a codebase ok you
need to lock that down right use the
complicated stuff where it counts where
you have control over it where the
actual experts are working otherwise
write simple code write things that fall
in this category are the obvious ones
that everyone complains about macros
template metaprogramming in our case we
are very leery of non-public inter
Herenton because let's face it most non
experts don't have a great grasp of that
and multiple implementation inheritance
is hard to maintain are similarly hard
to reason so save it we have a really
big codebase really big codebase so
surprising number of rules this is
getting down into very specifics now
surprising number of rules really boil
down to
please don't pollute the global
namespace I put your own stuff in a
namespace don't using things into the
global namespace from a header I don't
care what you do in a cc file it is
extremely unlikely that whatever damage
you do to your private translation unit
is going to have any impact on me now my
problem all right but when you make
mistakes in headers especially if those
become popular headers then everyone
that includes that header and everyone
that includes anyone else that includes
that header transitively forever
is subject to that mistake this has been
costly we had one instance of a foolish
using that held up a compiler release
because changes for the two compiler
releases because changes to lookup
required oh hey look we have to add an
extra include here and now they conflict
and someone had a bad using in one of
those and we had to do more than 10,000
files worth of cleanup something on that
order if you want to know how to do more
than 10,000 files worth of cleanup
there's a talk about that at the end of
the day go to high rooms talk in this
room don't pollute the global namespace
right if even if you're a small company
my the one thing that I would recommend
is follow this rule to the letter all
right don't muck with the global
namespace because whatever you think you
understand about your environment and
context is at some point going to change
someone's going to buy your codebase or
you're going to buy someone else and
there's going to be a conflict in some
global symbol and it's going to go
poorly don't do it alright namespace you
stuff yo generally we prefer using foo
colon bar over using namespace foo some
of this is for explicitness right back
in the days before we had an indexer if
you had a list of all of the symbols you
were importing and from what namespace
that was from it was very easy to just
use find in buffer to figure out hey
where did this symbol come from right
now we have an indexer so that argument
is a little sketchier however there are
still changes to name lookup rules that
stem from using namespace and it all
gets a little more subtle than I really
comfortable trying to get everyone to
understand so I suspect that it's not
worth the cost for us to change that
rule and finally concede to optimization
and practicalities when necessary
alright we can have an ivory tower view
of
this is how everything should work but
from time to time we do have to actually
do a build and have a performant binary
so we have some rules about optimization
practicalities we do allow forward
declarations this is for cases where
you're optimizing your build time I use
this in scare quotes because I'm in
general not entirely convinced that this
matters in most cases at least in our
build environment I also suspect our
rules on forward decorations are
definitely going to change before too
long and I will try to keep the public
style guide up-to-date the big one that
we've learned lately is or we're
declaring anything with that template in
it is a really bad idea this led to
maintenance problems like you would not
believe
forward declaration maybe okay some
cases my suspicion is the rule is
actually going to change to library
owners are encouraged to provide a
header that specifically for word
declares the things that they think are
worth it and you probably shouldn't
forward to Claire yourself and nobody
should ever forward declare a templated
type we'll see we're still working out
kind of details from what we've learned
in line functions
yes sometimes in lining things is nice
for performance I strongly suspect that
most of the guidance in the guide right
now is out of date with respect to
inlining I keep meaning to sit down with
our optimization people and like try to
work out what the rules really ought to
be these days so I suspect that'll
change at some point and then prefer
pre-increment these are just four yeah
sure go ahead and do that if you think
it matters it'll make your build faster
and we don't mind okay those are the
things that we're aiming to serve and
some of the rules and how they apply to
those things there are two rules that I
think are contentious there are two
rules that I think are the ones that
people complain about with respect to
the Google style guide and these are
them know non-conscious references as
function arguments and no use of
exceptions
okay I'll kind of touch non-conscious
references there's a consistency
argument right we have a hundred million
lines of code that is almost perfect at
the no non-cost reference rule further
the one function that is commonly used
that violates this rule has given us no
end of grief there's it's troublesome
we don't have a it has not left a good
taste in our mouth as I pointed out
earlier leave a trace and explicitness
kind of serves this purpose and there
are occasionally referenced there are
more often reference lifetime issues
than there are pointer lifetime issues
because there shouldn't be but in
practice people look at pointer and
thank a lifetime problem
people look at reference and thing
nothing right and this leads to trouble
so that's kind of the set of things that
I think apply here and one of the things
that I really like really really really
like about pointing out why we have
rules is this is more or less the bar
that we would have to meet if we wanted
to change this rule right if you are
explicit about why you have set down the
rules that you have set down right then
both there is understanding about why
the rule when the rule applies these
sorts of things and furthermore what it
would take to change the rule right when
your mom says Oh cereal for dinner
that's just a rule when your mom says no
cereal for dinner sugar makes you hyper
and you never get to sleep right there's
some understanding there so you're like
oh okay so if I could find a sugar-free
cereal
then maybe we could talk right this is
how arguing works and then there's
exceptions we value the standard but we
don't idolize it like not everything is
necessarily applicable for our context
consistency yes
this rule stems from the days when there
were compiler books we have voided
exceptions because our code was less
stable right this is no longer the case
however 100 million lines of code that's
not trivial to deal with ok leave a
trace exceptions absolutely don't all
right when something couldn't go wrong
it is nice in code review for the code
reviewer to look at a thing that could
go wrong and see how you are handling it
or see that you are explicitly
not handling it right in code review and
exceptions you could argue that
hopefully it doesn't matter I'm not
comfortable with that argument
especially in a code base that has not
been exception safe this is a dangerous
and surprising construe stuff is going
to fall apart it's hard to maintain
consider I cringe a code base where you
need to change or add additional
exception types for error cases you
hadn't considered before I we are we
have gotten really good at making
changes to how our api's work we have
gotten ourselves a very malleable very
changeable very workable very
sustainable code base that terrifies me
like the OP the idea of trying to make a
change like that I don't even know where
you start and concedes optimization
because on average code locality matters
and exceptions do everything they can to
make that not the case I would love if
anyone has super good profiles in a code
base that uses exceptions and can show
that there is no performance penalty I
would love to talk to you because I
really would love to have more data on
this question
anecdotally I do not believe such a
thing exists which is that so in recap
I'm leaving lots of time for you guys to
I would love to talk have a style guide
alright tailor it to your situation what
things are you trying to optimize for
right we are very much trying to
optimize for the reader for the non
expert reader in many cases what I fear
so much is an SRE in the middle of the
night who spends all of their time
writing in Python being paged to deal
with the production issue because some
C++ lunk head wrote a clever thing all
right the SR e's can't follow through it
without being experts I don't want it in
my codebase
it's hard to argue with that I think use
your style guide to encourage good and
discourage bad don't just make up rules
think about why and periodically
reevaluate we are totally mixing the
streams thing we are really a ting C++
11 was not instant for us to adopt but
actually fairly quick I think
we're continually kind of reevaluating
the landscape re-evaluating the options
the compelling thing that that started
the ball rolling there was having
benchmarks that showed doing the bill in
C++ 11 mode actually got us performance
improvement because there was
performance improvement to be had
through ambient use of moves in standard
containers in the like right reevaluate
because fundamentally you need to be an
engineer if you are in charge of your
style guide be an engineer about it
don't be a zealot about it right you
should have reasons and be able to
defend those reasons for all of the
things that you're doing if you're just
saying this is the way it is because I'm
right that is not engineering that is
gsella tree right and I don't want to
work
a good base and with that lots and lots
of time for questions and there's
microphones which is probably better if
we can manage so I'm going to start with
mics so I don't have to repeat question
hey uh question on one piece of
background you didn't really cover in
terms of what the code base is that
you're maintaining what percentage of it
covers server-side code versus
client-side code and what percentage of
it is on what platforms can you give
kind of a lay of the land there
I'd say it's primarily the backend code
there's bits and pieces of it that are
built in other environments but
historically it's been the backend so
how does that mean primarily Linux as
well yeah yep you're doing okay on the
on the non-conference a--'s thing does
that mean that say using swap would be
bad no because everyone knows what swap
is okay all right I mean I'm not gonna
be a crazy person like yeah like there
are things in the standard library that
you have to know the standard library I
just don't believe it is possible like
Hiram and I know probably more about all
of the interface code in the codebase
than anyone and let me tell you it's not
everything all right like I don't it's
impossible for everyone to know all of
the interfaces leaving a trace means
that you don't have to for the standard
yeah you should know the standard and if
you don't know the standard you see oh
it says standard swap I'll go to cpp
reference perfectly reasonable I have
two questions that's okay
number one on on the constants thing
doesn't that sometimes reduce the
readability of the function itself
because you may have double pointed to
referencing and that I never found that
particularly readable doesn't it
decrease the readability in some cases
yes and I think we could have done a
better job with this rule and I suspect
that there are like compiler based
annotations and things that we could do
that would do an even better job for
optimizing like yes this is clear and
unambiguous whether it's worth doing
that given the amount of legacy that we
have I don't know yet like I'm certainly
open to some of those investigations and
we're doing some of those investigations
but yeah it's it's contentious because
there certainly are arguments on both
sides like and then the other question
was on exceptions obviously you're using
STL type containers that throw
exceptions in some cases do you have a
you have a policy for the sorry do you
have a policy for where you catch those
exceptions they have to be caught in the
function that makes the STL API call the
question is when we're using STL
containers and functions and things that
throw exceptions do we have a policy on
when you catch those and generally we
just don't because you can use all of
the STL containers just fine without
using the exception mechanisms right
like you lose at yeah but we have debug
mode range checking turned off so you
look you look for examples where you're
calling API is that my throw exceptions
you don't allow those according to the
style guide itself so now we just don't
catch them it's like if you're calling a
thing that throat give me an example
well gets they always want to add so hmm
I don't care about throwing out a memory
exceptions I just don't care like until
Bruce yesterday gave me the example like
I have not heard a snout exactly one
case where you can credibly recover from
that all right like I don't care just
die you're out of memory whatever you
try to do to recover is going to be
limping along like I what did I find
victor bounce bounce checking that kind
of stuff that vector bounds checking
like in debug mode our operator square
brackets does bounds checking and
otherwise use a SAN right address
sanitizer tools right if you are not
using address sanitizer and you ever
have a seg fault
I laugh at how much effort you're
wasting
the tooling story has gotten so much
better there are solutions to when
Chandler points out when you throw an
exception for us because of how we've
tuned the compilers it just crashes
immediately which logically is totally
what you would expect because we're just
not catching it anywhere so same end
behavior we just don't have to issue the
unrolls
yes we've previously used references to
mean can't be null pointers to mean all
parameters are check for null as an
optional thing if you're only using
pointers do you have any guidelines for
when something might be null or do you
guys check for null all the time on
pointers or never check it varies wildly
from team to team and and context to
context and guidelines on what to expect
as someone using an API if it will check
for null or not I think in most cases
it's reasonably clear like if it's not
intuitive like do I need this thing is
it an output parameter and I'm supposed
to fill in the results in this vector
you know like there's the the
unsatisfying answer is you have to go
read the docs and you go read the
comments on the thing and it says
whether it could be null or not in many
cases that's actually not necessary
because it's kind of clear from context
like how am i calling this doesn't
matter like could I imagine that being
optional yeah it's certainly one of the
contentious pieces the null ability
question is is big here okay so before I
you know take out my pitchfork let me
ask is this tool kife is this available
and does it work on other projects or is
Google specific the expectation is this
will be open sourced shortly I'm not on
this team but open sourced shortly they
want community involvement there yeah
all of this stuff and when it happens I
cannot stress enough how useful that
index turns out to be
like for reasons I would never have
imagined it is extremely valuable yeah
okay so now about the pitchfork think
exceptions yep you said don't used
construct that are dangerous but
yesterday there was a talk about the
exception safety where the argument was
made that not using exceptions is the
more dangerous approach and because you
are free to ignore errors now you're not
if you were turning by so we have a
standard error class we call it status
it's not terribly surprising name and we
have rigged the compiler so that when
you return status for my function the
build will fail if you don't do
something to that object thing you can
still okay that's like going to it there
is there is an ignore error method on
status about this explicit ESO but its
explicit for the reader so in code
review you can be like hey I'm not sure
it's kosher for you to be ignoring that
yeah another argument though it's
another argument I actually saw in the
in the style guide to a snit we enthuse
exceptions because our code base is not
coded to be exception safe yep so at the
argument what also yesterday was that
actually making everything wrapped in
the right containers and this even if
you don't use exceptions that's a good
idea
oh yeah sorry if you were ever to you
know let exceptions in you would have a
good I would have a miserable couple
years probably yes
no I totally agree like having are good
containers in rei and all of that stuff
like absolutely like i am wildly in
favor unique pointer do it go please
have good clean up you know we have a
finally type we have all you absolutely
no disagreement okay so just to finish
it up you also said to one of the
arguments I was we're going to be here
for more than 10 years on this code base
and so do you accept that expect that
for the next 10 years we won't see
exceptions in
on average I would expect that's the
case yes for most things I suspect we
will come up with a solution and be
willing to pay for it for exceptions I'm
not convinced of the value proposition
like I'm not sure if I could just wave a
magic wand and have a code base that
this worked nicely in I'm still not sure
I'd do it because of like the lack of
explicitness and because of compiler
performance even if it wasn't just the
legacy argument yeah I'm not sure it's
complicated um so one of the problems
I've seen with explicit error handling
is with the standard algorithms so say
standard transform you would usually
want to return a list of transformed
elements and a single error status so
how do you do the transform and half
reduce kind of thing over the of that
right um so status or output parameter
tie it like Chandler suggests check for
your errors first and then transform so
like yeah I tend to really enjoy the
standard algorithms cuz they all compose
well but then you toss the intermediate
steps in there and it right gets messy I
would argue that we underutilized
standard algorithms okay um and that's
partly because the legacy reasons partly
because many of our you know most
excellent most respected coders came up
before standard algorithms was really
usable and all that and so there's a lot
of very good examples of not okay I
don't know what that how the balance of
that will evolve over the next 10 years
but yeah we have work to do no other
side you have any policies regarding ADL
usage in your API
there are very very few api's where we
explicitly rely on ADL usage I can think
of only one and much as I dislike it it
was an improvement over the horrible
hack that preceded it
there was a serialization that like I
would like to deserialize this
information off of disk and someone at
some point in the past decided that it'd
be okay to let people template
specialize that for their own types and
this is not the way that you extend an
interface like that
so the ADL lookup solution in there I'm
less leery of but mostly you would
otherwise never yeah otherwise beyond
that I can think of no example eighty
Ashington ADL is argument dependent
lookup so it's the namespaces of
arguments get included in the lookup
yeah namespaces of arguments get
included and lookup of the function
which is kind of backwards of what you
would have expected but it's only for
unqualified names sure yeah yeah so and
so I'm sort of curious you mentioned
that you had over 4,000 developers
engineers on your team no no no no of my
team oh no no no within the organization
what was the number
4,000 ish C++ engineers yeah okay so so
once you have a style guide look that
you approve you know in your
organization you say this is our style
guide how do you effectively ensure you
know the consistent application of that
guide across the organization it seems
like it'd be a real big challenge it is
so we have things like readability so
for every change that's going to be made
to the code base like I'm making a
change in C++ I need a code reviewer
possibly more than one there are two
pieces of approval that I will need one
either myself or the reviewer must own
the code in question have rights to
check into the
that particular directory in our in our
code tree and to someone must have
readability in C++ which means we've
been blessed like we trust you not to
make a mess we trust you understand the
style guide we trust you generally
understand how things work around here
those sorts things either the author can
have that or the reviewer can have that
or they can summon a secondary reviewer
to like review style and consistency
things so that's one as a very human
process it's you know prone to human
errors and judgment and things and it's
a little wishy-washy but it works fairly
well there's also a paper out for review
now going to XE next year on we have
some static analysis tools that have
been hooked up at code review time and
this is things like client ID and client
ID plugins specifically internal to us
about our own types and that helps
identify like hey the things that you're
doing here this is not how the style
guide would suggest that you do it or
this is inherently dangerous in some
cases and those all get surfaced at code
review time which is kind of the perfect
time actually because that's when you
are working on it and when you are
amenable to change once it's already
checked in is a little late so these
things make a big difference also
broadly this very issue is what my job
is the the title that I have worked for
myself is C++ code base cultivator and
that's you know like I said the code
base is my product so I write about what
you ought to do and I give training and
all these things to try to increase the
number of people that know to do the
right thing and then I snarkily tell
people and if someone's giving you grief
in a code review about something that
you think you're right about summon
Titus and I will set him straight
so that doesn't scale terribly well but
it's fun
do you modulate these rules at all for
api's that are better public-facing or
do you I mean what do you mean by
public-facing I like Google protobufs
that that you know the public uses um so
like Google protobufs as the public uses
um when stuff is open sourced it's
harder like there's just no two ways
about it
we one of the side effects of we've
gotten really good at because we know
everything about our code base we can
change everything about our code base or
most thing that goes out the window when
you open source it because now I don't
know how your code is using it and I
don't know if I can make that check
badly probably yeah
no judgment and so like by nature once
the open source that it kind of slows
down any interface change I am hopeful
that in the next few years we can
revolutionize that by just if we make an
interface change to something that's
being released just ship a tool it'll
change your code to use the new
interface this is not out of the realm
of possibility at this point but yes
public facing stuff often has slightly
different rules chromium has a
descendent style guide from us with
tweaks and changes for their own
purposes yeah like you know the rules as
we hold them are for the average case
but we'll be practical about it all my
question is roughly what percentage of
problems does adhering to this style
guides solve for you and I'll expand on
that so the even in a perfect world
where we're all programs follow this
this perfectly don't you run into into
higher-level problems like well what is
this dis modeling that you're using all
about and how do you how you make sure
that people take a consistent approach
in how to solve a problem yes this is
part of why like running the style guide
and all of that process is a 20%
activity for three people as opposed to
a funded effort to build tools that
prevent all problems
oh if you want tools that prevent
problems you go to the sanitizers
where's Kostya Kostas not here go go do
whatever cost it gives you make address
sanitizer thread sanitizer like your
life will be so much better you'll stop
having problems sure but
so how guide is for the things that I
said it's for consistency it's for the
ability for us to make changes to the
code base and keep up with things in the
next 10 years it does prevent some bugs
in some things generally the overall
rule of have tests and don't be dumb
don't check in code the breaks solves
more of the bugs then style guide is
gonna so how do you how do you then
ensure that's that's people take a more
or less consistent approach in how to
solve a particular problem what at
specific just that just how they how
they what goes into a class how do you
how do you break them down ah
you overestimate our consistency I
regularly describe Google engineering as
the world's highest functioning Anarchy
yeah my consistency is ideal and we have
a surprising amount of it considering no
one actually has the authority to smack
any heads around and be like why did you
do that I will yell at people and be
like why did you do that but I don't
have any teeth behind it so right
whatever so let's say you were starting
today on beautiful C++ 14 out there
clang 3.5 and an empty codebase and you
were tasked to redo your style guide
what what would be different about it
what would be the rules that you would
change or add or remove er it would be
different right I would absolutely
insist on smart pointers I would do
everything I can to ensure that the code
was exception safe but probably still
wouldn't turn on exceptions
please REI all that good stuff I would I
think I would invest some time to come
up with a better solution for the non
conference argue
because I think there is a better
technical solution I just don't know if
our legacy makes it worth it was that
tupple is probably I think those are
those are kind of the high bits
I might specifically just say use clang
format all the time because there's an
awful lot of verbage devoted to where do
you put the spaces I'd like if I could
reclaim all of the mental power of all
of my engineers on like where do I put
the spaces and just like please no go
Clank format and then use tools like I
would make that trade-off in a heartbeat
right like no question thank you yep
okay so you said that you discourage you
forbid my car so you said that you
discourage global and static variables
right well of a complex type because
they cause trouble when application
exists due to static destruction right
so so so couple can use the mic huh use
the mic they can't hear you yeah so so
because they cause trouble when
application exits you - static
destruction which is invoked
automatically according to C++ runtime
right but so so three comments so number
one does this also apply to I mean do
you also discourage function scope
static function scripts that whose
destructors run yes yeah of course right
but static destruction is a solo problem
you can just call STD quick exit or
underscore underscore exit which which
which which does not do static
destruction you're not telling me
something new and you underestimate the
complexity and cleverness of the people
that have already taken advantage of all
of the degrees of freedom here we have
strongly considered just doing an
experiment to turn off all of the static
constructors no matter what we'll see
how that plays out I don't know when it
turns like it turns out we don't
actually pay that much cost for this
rule and
so I think it's not that bad one of the
other arbiter here disagrees so the
actual problem and that is the natural
problem is on static in it when you have
dependencies between static objects
across different inflation units and
this problem basically cannot be solved
because the order is hard the order
static construction is hard to achieve
unless you enforce linking order which
is difficult also true yeah yes okay
thanks
yep and I think we have are we done
two minutes oh okay
what about tap process spaces what's
Google's take on that if it is spaces
how many spaces well repeat the question
I'm in peppers or spaces oh that's good
guideline like there's a rule about it I
forgot the rule I used to use clean
format I don't care totally
uninteresting go so you obviously have
various platforms to support on this
code base right you go that with
different compilers what the majority no
there are some pieces of the code base
that build in in environments that we
consider exotic almost all of the code
base builds just for our production
environment which is glory so what's
your take on CSP 11 do you support it or
do you have compilers in the dental
support we support C++ 11 in almost all
of the code we have supported C++ 11
like I strongly suspect that there is no
code base anywhere near our size that
supports as much people as plus 11 as we
do yes we use the majority of it and the
pieces that are currently still on the
we're not sure about list we're working
out exactly how to provide guidance on
that but like I said this is kind of a
semi volunteer activity so the rules
involved slowly yes C++ 11 for certain
C++ 14 as soon as GCC support is there
I'm almost certain we'll just turned it
on yes I was wondering how did you get
buy-in for the style guide like when it
was initially adopted and the second
question is what did you do with all the
legacy code that was pre style guide
so this actually wildly predates me so
the codebase is kind of old the style
guide formed as I understand it by
someone writing up a description of what
the really good engineers did wasn't
even them and then once that was
codified the organization was still
small enough that everyone was just like
oh yeah that's what Jeff and Sanjay do
so I guess we're going to do that so at
some level you know look to your look to
your leadership at legacy code and
legacy code for a long time we required
that any change the style guide was
accompanied by you have to also make
sure the whole codebase does this which
was kind of comical because we didn't
know how to do that now we kind of know
how to do that but we also know the cost
of it so we're not as consistent as we'd
like to be but we do like we certainly
consider all that whenever we make
changes so anyway we're out of time
thank you all very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>