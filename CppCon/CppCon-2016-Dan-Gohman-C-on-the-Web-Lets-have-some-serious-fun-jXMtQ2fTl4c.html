<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Dan Gohman “C++ on the Web: Let's have some serious fun.&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Dan Gohman “C++ on the Web: Let's have some serious fun.&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Dan Gohman “C++ on the Web: Let's have some serious fun.&quot;</b></h2><h5 class="post__date">2016-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jXMtQ2fTl4c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">webassembly is targeting compiled
languages it's portable we're going to
are on the web we don't have bacon a
particular architecture it's secure it
has basically essentially the same
security model that JavaScript has it
can't touch to Apple filesystem I can't
corrupt a machine
it's stuck within my sandbox to the
browser and it's open a standard being
worked on by multiple writers a couple
quick overview of what assembly if you
haven't seen it run with it it's a
pretty normal architecture in many ways
what would certainly benefits a lot from
the convergence of CPU architectures
over the decades so my tip is sort of
odd details of CPU architectures that
tend to bubble up to the ecosystem have
basically converged and modern
architecture like x86 and arm more or
less agreed a lot of these basic details
I do I call out a particular that I took
place at 54 floating-point web assembly
has as float and double as a single
double precision and the floating point
is actually fully deterministic so if
you've if you've heard about this
systems having problems with like x87
routing differently different cases
where we simply does not have that
problem we just define x87 to not be the
correct rounding mode in the correct
mounting mode and we do have tests for
this is the I Triple E running boards
for single double precision endianness
is also something we can talk a lot
about which is big and interval engine
is better but the advantages of either
one of them are definitely out shadow by
the fact that if you have one end enos
across your entire ecosystem that's way
better than having one or the other
versus the ending misses so we picked
one we payed little-endian and we just
had the entire ecosystems going to be
the Lybian it eliminates a lot of
problems we're looking at sort of a
32-bit variant of what assembly in a
super bit variant technically there
isn't actually a variant it's just
within the system we talked to memory if
you use 32-bit pointers you can use
Victoria pointers right now the focus is
largely on 32-bit pointers particularly
on the web
most applications on the web I'm going
to use more than 4 gigabytes of RAM and
using smaller pointers means you use
those from overall anyway so the status
of up assembly working on what we call
the MVP the minimum viable product I'm
sort of made this to indicate that
there's a lot of things that we don't
that we do really want in webassembly
like threads like 0 cos th we want these
things they're not in the MVP but the
most important thing that MVP because
this is a massive new step for the web
reducing some massive new
the most important step is that we
actually do really something and we do
it with all the browser vendors on board
and that's actually something we've done
we've been successful at so far so we
still have at this point we have all the
major browser vendors working together
and cooperating to make a new standard
which is a pretty major a couple of it
and you can try it out you can try out
we have a demo today I'm not gonna play
for you you actually run this on the web
if you have Firefox nightly or Chrome
Canary you can even run up the demo of
course the demo also which have been
known to run in versions of Microsoft
edge as well so it's definitely a thing
that's happening now I also do want to
mention one other thing on the status to
the design of assembly is sort of been
fluctuating a lot over the last several
months it's actually been pretty much
finalized at this point so the design is
basically done and we're moving on to a
more of a Invitational focus pays of
just like finish the relation in the
browsers do so for optimization you get
to go faster I'm actually gonna look at
some develop relations coming up
adherence but in the back of all so
looking at C plus the one of the big
things we focus on breezing support
posts in the AVP time frame of
webassembly is Emscripten Emscripten is
a C+ compiler that has a lot of great
functionality that we use with as MJS
and what we're doing really now is is
focusing on keeping that little
functionality not trying to do anything
massively new but just keeping that
functionality and moving forward with
the benefits at webassembly provides so
I'm scripting has lots of good lots of
good stuff in it it uses clang and LVM
under the hood to actually do a simple
cause for network and optimization work
now there's a custom Jas
backend which is now also augmented to
be able as produced webassembly there
are C++ C in C for Boston libraries
there are libraries that provide
standard C Papa OpenGL bindings OpenGL
is actually sort of transparent leary
mapped onto WebGL inside the browser
which roughly corresponds to about GL es
two differently with different ES levels
WebGL 2 is coming to browsers relatively
soon which will essentially bring up who
GL es 3 AP is
inscriptions OpenGL actually supports
more than just that the GL es to subset
but essentially if you target that
subset you have on fast in the browser
because that's what the browser is
supporting fo GL and soon WebGL 3 or
WebGL two-brains GL es 3
SDL providing a relatively standard
interface for doing things like input
sound and other kinds of common tasks in
a script it also has a really broad
broad set of options for talking to
JavaScript and integrating C++ code with
JavaScript code so you can have direct
calls you can literally call it directly
from JavaScript into up assembly if you
don't you did retain complicated figures
passing around numbers or whatever it's
not too complicated but you want to do
anything more you typically use one of
the other options which was specially if
you want to pass projects around EMS ohm
is a way to literally just put
JavaScript right in the middle T plus
code it's actually a simple host macro
you can literally put the regularly code
as a string and the string the Java code
that gets executed to that point in the
codes that makes it sort of really
obvious for you writing C people's code
going to stick in some JavaScript
Interop you just stick it right in
middle of your code so eeehm is so the
question is why is it called EMSL e/m is
sort of short form scripting and the
analog idea being presented here is that
it's like inline assembly kind of like
JavaScript because this later face was
develop for Asmodeus in which s MDS is
kind of serving as the assembly language
of the browser so it's sort of emulating
I inline as in contract with what
assembly I usually I think going forward
we're gonna be able to do sort of more
actually inline as some kinds of things
but in terms of interrupts with
JavaScript this is actually very useful
mechanism and it also works in web
assembly even though web simply isn't
JavaScript what this actually does is it
puts JavaScript code off the side and
then sets up the glue to arrange for a
call at this point in the web selling
code to call out the JavaScript code
among the code so the programmers model
is just that you think okay I'm just
writing some JavaScript byte in the
middle my super post code it works now
underneath the coverage there's a lot of
magic being done sort of like take that
JavaScript code moving somewhere else
and money why do you sleep on so M bind
is a rather more fully-featured way of
talking to delegate from people post
code in bi and lets you pass objects
around you can even use smart pointers
to manage the objects which is really
nice and web IDL is an interface
description language they use for a lot
of different web standards and ap is um
it doesn't have the same sort of broad
swath of functionalities on mind does
but what by DL can be usable in some
situations and there's actually a lot
more
and the big picture of you if you go to
I'm scooping that over we have a really
great website that has documentation on
all these different options or how to
use them
elaborate occupation I'm not going to go
into detail of these unfortunately today
but you can find all about it on script
or you could also find out about inch
Krypton's file system emulation layer
which is really an interesting thing in
it's almost largely a compatibility
feature in the browser because the way
it works you can actually bundle up
files into an image and then bundle them
up with your application ship them on
with your application when your
application can then open them using
sort of standard seen sequel API is that
you file i/o on them there is why I sort
of say that sort of competitiveness in a
lot of situations forcing all of your
files we downloaded upfront the
application decreases your initial
startup time so many applications is
actually worthwhile to optimize to use
streaming io to stream mail stream
vector files and data files in on demand
rather than having everything be
downloaded up front now but the file
system layer is actually useful in many
cases just to have a sort of standard
interface you can port code with there
are several different kinds of
applications you can make with the
script inside just sort of the single
sort of fullscreen game although you can
do that this is the angular bots game of
course you've seen the demo if you've
played the demo online definitely goes
to full screen mode you push escape to
come out a full free mode and get back
in the browser so it's definitely one
sort the one monolithic application
statically linked one big with'em image
full screen sort of one large way of
using web assembly another large way of
using web assembly is to use it as a
hybrid application along with javascript
this is an application called autodesk
format and the way it works is that the
the 3d scene your games name here is
actually rendered without MJS and the UI
is actually being drawn with javascript
and dom calls so sort of this hybrid
where you're actually using both it was
assembly to do the sort of computational
part that's rendering the scene and then
JavaScript actually talked to the
browser and other UI another way of
using web assembly is to use it in the
library and this is actually something
that's got a lot of people really
excited it's almost like you're
extending the browser capabilities
you're adding new API to the browser you
can call from JavaScript so if you want
to write sort of a pure JavaScript
application but you want to actually
little library to do some extra funds to
if you can just sort of blunder them a
little bit of webassembly the library
this is a library that are showing off
called box2d which is does a physics
simulation and it's already sort of a
well why they used library for doing
stuff like this and you can sort of
bundle it up and you can have the rest
of your application written in
JavaScript or you can write it in in
SIBO class or the languages you can just
like have this as a library sort of a
third kind of application looking
forward so we have been scripting today
which we're focusing on is sort of that
that minimal disruption is a lot people
using Asmodeus with them scripting today
and it has all this great functionality
but we get a lot of feedback from from
power users and from other kind people
that want more flexibility in script and
kind of has a big bundle functionality
it's all bundled together what people
are telling us they want us to sort of
roof-rack transcript in and split out
the parts in taquoia like the more
useful parts so you can pick and choose
the parts you want to not have to have
sort of a whole package all at once so
it's definitely one of the big things
we'll be focusing on going forward we
also want to mention that LV on webbie's
handbook back-end that we're working on
if they worked on upstream so it's part
of LLVM it's being helped upstream since
the varying at this point it's at the
point where we can generate code for web
assembly you can do a pretty good job
there there's a lot of sort of
surrounding work that needs to be done
to actually make a full-featured tool
chain there's like clang driver work you
need to do sort of make clang just the
fillets will stand alone thing there's
there's an interesting question about
like which we have linkers we have it
like a dot o file format right now with
them scripting your doe file format is
actually elevating big code and it's an
interesting question of whether or not
web simply wants to support a separate
compilation model with its own data
files what that should look like
so there's definitely lots of work to be
done there and we have a lot of ideas
the feedback we get from other people is
that I just want a regular Super Plus
compiler and that's what we want to love
her too so now I want to take a tour
through web assembly I want to show you
some of the insides and we'll get into
sort of the end and version from c-plus
all the way down to native code and see
what things look like and what actually
has to happen to make the Sol system
work so here's my super boss code if you
if you written your own STD vector
before and who hasn't it's you this what
we've pretty familiar basically if we
don't have an opacity with two realloc
otherwise we're going to just go ahead
and append the element so you copilot
web assembly and you get something that
looks like this next
and I'm not really one for reading hex
dump straw a couple things I want to
point out here in particular so the very
first bite if you look up here is a no
bite
that's interesting because the null byte
is not a valid text characters in
particular it's not a valid JavaScript
source Val characters so in some
projects in a browser and some other
contexts if you want to know am i
dealing with with JavaScript or
webassembly
in particular on the web this is
important you can bury the very first
byte it will tell you if it's null it's
not JavaScript the next three bytes are
a SM which is sort of an arbitrarily
chosen magic cookie that says this is a
web assembly file the next four bytes
are a little endian coded in version
number now we're actually not hoping to
use this version number ever that the
idea of web assembly is to be part of
the web and to grow like the web does so
instead of having a monotonic sort of
set of versions that can go forward
features are going to be added
incremental e as a ser developed and the
browser's Navi out might not you might
not all employed the same features at
same time so people get a TB feed you're
testing we don't want to have to say
okay if webassembly version is greater
than three then do this it's going to be
if I have this feature than do this
that's that's really the way the web
works the way web somebody's looking to
work but we have version number just in
case in case it ever becomes necessary
to make a fundamentally breaking change
the binary format or to the semantics or
something else we can make about the
vertibird sort of this this emergency
mechanism we built in and that's really
it for the web assembly header format
the rest of the binary format just
consists of headers of sections and
sections just begin with an identifier
what kind of section they are a length
how long the section is and in the
context it's section it's literally just
a concatenation of those things so
taking a look at web assembly text I
know this is really small you probably
can't read it but we'll zoom in on some
parts here I encourage people not to
think too much about the particular
syntax what's going on here because
there's a lot of different ways to
present
binary formats in texts and this is just
one way that we're using right now for a
variety of historical reasons so at the
very top we have some of the declaration
section of declaring before we get to
the actual code of the function we're
sort of declaring what the what the with
the module contains so we've opened the
module the very first things
remember declaration and his operand
which is in units of pages pages and
webassembly are defined to be 64
kilobytes so we have allocating a memory
region of 1 64 kilobyte region and the
very next line is an export line we get
into this a little bit later in the talk
about imports and exports being sort of
the fundamental building blocks for
putting modules together but we're
actually exporting our memory or address
space I think it's really interesting to
think about address bases as an object
those have been ratified it's a thing
that you can import an export with a
name yes when you say modules not C++
module that's correct in this case
module is actually closer analogy to
like executable or a dynamic library
it's like in the help sense of
executable file or a shared object I
guess what else we call them so that's
this yeah that you're right there's this
modules used for many different things
so the website module is actually a
pretty key concept that a lot of things
are built around in a particularly ways
by using the term our module is because
that's the term that Java Script uses
for its modules so if you're familiar
with es6 modules this module concept is
fully compatible with that they both
have this imports exports concept in
fact webassembly modules can import
JavaScript exports and vice versa so
we're we're tying into that whole model
system that's coming to the browsers the
next lines are dealing with imports of
functions if you remember my super post
code I have a reality call and it's
actually a board column I didn't define
those in the module this is actually
somewhat unusual for webassembly in the
field today because in a typical
scripting compiled application you'll
have a statically compiled application
so things like we all like and abort
would just be linked into your
application rather than being imports
and what we see in upcoming slide that
actually looks like is imports has
effect on what the generated code looks
like so the next line is is exporting my
function we have a titanium name
mangling for my pushback function and
then the definition of the function so
one of the other things I want to point
on this slide is that all functions have
signatures
even imported functions that define
functions there's always a signature
there so realloc course has a pointer
and a size T this is a pile
thirty two avi so those just both into
three twos so we Alec has to I thirty
two arguments and I thirty-two result
value and I push back as a pointer in an
inch argument tells Pacifica I 32 as
well so taking a little bit look at the
actual code webassembly is a stack
machine and the stack machine works
really well for coding coding size if
you look think about a typical register
machine every instruction has the sort
of name where the inputs are coming from
and name where the output is going and a
stack machine most operations can sort
of just implicitly say I'm take my
inputs just popping about the stack and
my result goes gets pushed on the stack
and as a result there's no need in the
binary encoding to name the inputs and
outputs at least in the common case and
then we have what we call locals or
local variables as sort of the
general-purpose non as I say registers
that can be used for like everything
else things that need to be used
multiple times things that can't be used
in the life of ordering that the stack
requires so you can see if you member my
code this is actually the code for doing
the VA in equals Vida capacity so first
we're doing the get local that's the V
that we're doing the load that's loading
the the blank field and you can see
we've an offset this sort of building
built in cousin offset mechanism so
we're loading that push get so take the
value of local variable $0 zero push
them the stack then the load up brand
low destruction pops out the stack and
pushes the load of value on the stack T
local is actually kind of interesting
thing so set local would be the normal
thing to set to a local variable
what's that local would do is pop
ability off the stack and assign to it
local what T does is leave it on the
stack and assign it to a local it's
called T because you think I'd like the
UNIX T that I'll use going to two places
at staying a stack and going to a local
so this is essentially a way of of
having a value that has multiple uses
the first use will still be on the stack
we can still pop out the stack later on
but it's also available as a little
variable for us to use don't worry too
much of all those crazy details this is
the kind of stuff that compilers will
take care of you take care for you all
the stuff is done within the code
generator
under sort of walking through it so you
can get idea what's going on oh my
assembly the next lines is another get
local of the load this loading capacity
I figured out any is the not equal
operator
of course notice how I thieves you've
got any has no upper ends it's just
implicitly pop two things up the stack
push it's a result on the stack 0 1 and
then VRA is a conditional branch so
another interesting property about
assembly that sort of makes it different
from our group up somebody like other
assembly like we do is that it has
structure control flow this actually
gets really interesting but again it's
one of these things that is a see post
programmer you don't have to worry about
the exactly what's going on here the
compiler will take care of it for you
and and set everything up this is block
structure which is a hierarchical
structure that goes on and the rules are
kind of complicated but I want to get to
it right now I just want to mention that
there is a structure control phone so
the next step is we take the webs on the
code we send it to a browser and the
very first thing the browser wants to do
is compile it a native code I'm showing
you is actually the x64 code that we're
generating this is from Firefox nightly
or pretty close actually cleans it clean
up some things just representation here
it is pretty close to what Firefox is
generating on the left or on the right
I'm sorry
and I'm left I actually want just a
person note this is what LVM is
generating for x64 when compiling that
same people post code just for native
platform so you get an idea of so the
ballpark we're in a lot we see the web
with my code is a bit longer at this
point and I want to sort dive in and
explain exactly what those reasons are a
particular interest that I have in I in
this kind of system is what are the
things that are there because of web
assembly the language what are things
that are there because the implication
Firefox is actually using I on monkey
which is its jsg it to do the code gen
which is not the same code gen as LVM
Schochet
so see some of the answers are because
of webassembly ins of the answers are
because firefox doesn't have the
optimizations yet so the very first
thing i want to point out is the very
one the first thing the function does is
a recursion check what assembly requires
that when you put on a stack space on
your call stack that the program Trap
reliably there's no sort of undefined
undefined behavior when we are at the
end of the stack we have to have to
check there are fancier ways in BM is to
check for running out of stack space
this is a very very simple way of just
like load a known value compared with
the stack pointer and do additional
branch yes question
so that's a big question so the question
is I mentioned it was 32-bit code but
we're actually looking at six for
providers tiers so what this is is the
webassembly code is 32-bit but it's
running on a 6-4 with machine so that
the applications model of pointers are
32-bit within the sandbox and it's
between quiet or automatic fault machine
and say former miners so I mentioned
before that we Alec was actually a call
import or a call to an important
function in a typical native situation
with then McCleary this was sort of
equivalent to one dynamic library
calling into another one where you might
use like a PLT mechanism Firefox doesn't
have PLC's and ESCO generate right now
so we're just doing a very simple thing
like load the address from a table and
do an indirect call which is very nice
and PL T's are nicer but this is like
this in the category of things that it's
not fundamental to assembly just
something that Firefox could do better
it's an opportunity for us to improve
another one in that category so that VAR
c times 2 we're doubling the length this
gets optimized into a shift by one of
course if you really want to go for
outside six you have to optimize this
into an le a which is even fancier so
one other thing that quickly look at
before we get done geeking out what x86
code this is actually the code for doing
the V dot length equals V dot capacity
test and you can see the code is
actually really really simple just
literally just doing a load without sets
outfit for load about set eight and do a
comparison and go so it's very literal
in terms of what the web sign the code
looks like but there's a couple
interesting things going on here one of
them is that we have registered plus
register addressing going on here the
original code literally just had one
base and a cousin offset it was the V
base and then the length is an offset
but because web assembly code is sandbox
it's actually running inside of its own
address space embedded in the process ID
row space
RDI here is actually the application
pointer it's a 32-bit value of course
we've used the 64-bit encoding of it so
that's why shows up as rrdi here's a TDI
but it's actually a 32-bit unsigned
value and r15 here is the base register
of the address space so this is
essentially every every loading store in
this invitation we'll have our 15 as the
very first add register and then the
next register will be
user letter pledges users pointer and
then the course you can have a constant
offset this is an area where the
webassembly fundamenta does impose a
restriction on the application we do
have to have this sandboxing property
that's like a fundamental security
apartment that we have a sandboxing
however there's there is yet hope if we
still one up up mised address modes if
we don't want have to burn to registers
or burn an extra register on every
address mode to play for the sandbox
same thing one thing will be possible to
do here is if we look at the addresses
it's AR 15 + rd i happens twice in large
application you go she could have many
loads and stores that are basically
repeating the same basically address
space plus the same point or plus
different offsets it will be possible to
factor that plus out and do like an le a
and save basically i displace plus some
value once and then from that point on
you just have a single register you
could address with so a clever VM could
actually do things in that way then you
actually free up another register base
in your address mode so this is another
opportunity for for clever VMs to
optimize you can further but I think the
meta point here is that the the
generated Samba code is actually pretty
simple
I guess one other thing I can I can sort
of sight here is that this being x86 you
could fold one of the loads into the
compare because you can do that on x86
and same register so there's this bunch
of things that we can do in the
invitation that are not fun might
ultimately to make the code better and
there are key very few things that Obama
simply is imposing on us making the code
worse yes
um so in general come when you there's
no like data dependencies so it should
close easy and Dax
yeah so folding a boat into the compare
isn't gonna make it go significantly
faster it will make there's one less
instruction and if the main thing it'll
do is it'll free up a register the
disadvantage of this approach is that we
actually do have to write to a register
and only read it once but there's
register pressure in a larger example
having this register for you be a win
this is a small example it doesn't
matter here but yeah in general it is
good to do the folding because you save
registers and save reduced air pressure
so and and in terms of the the
micro architecture the fold the load is
going to get unfolded by the hardware
anyway so that's a good question Thanks
so we built a funnel tool you can
actually go to this URL you can take a
picture or something we have here in
this tool basically an interface where
you can type in C postcode and it will
show you the x86 code that we're
generating for it this is using the
Firefox engine and it actually has also
has a mode working that she's the LLVM
native code you can sort of do it
working side by side comparison so this
is kind of putting us on the spot as you
see we have some things need to do to
catch up to LVM or maybe someday we'll
know we'll we'll use lbm itself in the
browser
that's our development question but for
now you can go is here you can see it
you can do drug side by side comparisons
and you even file bugs directly from
that that web page so the next big that
I want to talk about in WebAssign way to
sort of explain how it works is to deep
dig a little bit deeper into modules and
what would mean that module differently
I think I mentioned before modules are
sort of the analog of like an executable
or a shared library so it's a linked
thing that has it's more than just a dot
o file it's actually sort of a
fully-formed thing that can be loaded
into the runtime and executed is
multiple functions in it and and you can
have imports and exports sort of the two
main verbs we have at this point and we
have a tool length base this is similar
to the mock o to old namespace where you
don't just import a flat name you
actually import a name of a library and
then the name of the game library to
your importing from which can
significantly speed up dynamic
resolution of symbols a set of things
that can be imported exported sort of
that is the ontology T well is memories
tables Global's and functions and it
would walk through what those all are
and what it means the important export
them and I want to mention that these
are the building blocks for dynamic
libraries web assembly doesn't actually
have a concept of dynamic libraries
built in you just have a concept of two
modules and if modules share enough
pieces and they're basically dynamic
libraries modulo some policy that they
have to add
so my example showed a export of memory
what that really means is that within a
module you could export your your
address space and other other modules
can access it so your JavaScript code
can come in and poke at the bytes of
memory or you can share essentially two
modules sharing a memory which is
basically one of the big building blocks
of dynamic libraries as two things
flipping in the same outer space so I'll
have a little diagram here of basically
a linear memory is essentially just an
array of bytes starts at 0 goes up to
some size we call current memory memory
can be declared with a maximum size
which actually gives VMs somewhat a
flexibility to pre-allocate address
space even if they don't pre allocate
the memory to allow it to resize if
actually and what memory can be grown
you can do votes on stores I'm showing a
value X which is just some index so you
can do a loading store from X to load I
32 edges for FTP you have 64 and there
are specialized instructions for doing
8-bit and 16-bit loads of stores of
course one of the fun things both
reifying address spaces into a
conceptual object is that you can think
about having multiple address spaces
this is the common case for C++ because
people plus language itself just has a
single address space for data but you
could imagine either a smart compiler or
language extensions of various kinds
that can have at multiplied your spaces
and if you don't need a pointer that
needs to able to point in double address
spaces you can segregate them and
advantage of doing that it gets a better
isolation so webassembly sandboxing
protects the application protests the
the browser and the user from the
application but doesn't pick any up
protect the application from itself and
splitting application in tumult wider
spaces one way you can have an
application protect itself from itself
the next major concept of web assembly
that could be imported and exported from
module is the table the table is a very
very general purpose concept web
assembly that's going to eventually be
used for London things right now it's
just being used for indirect function
calls so what a table is is just an
array an array where the elements are
opaque to the application so the main
use case here that we have right now is
that the array holds functions and so we
have this sort of index base starting at
0 with functions and the way the call
into our construction works to make an
indirect call is the operand 2 it is
just an index
table so in this case effect seems to
then you call the function quacks and
that's how Colin direct works this is
effectively because it's a separate
index base from the linear address space
from memory this is effectively sort of
a to address base situation which makes
it a Harvard architecture which is
somewhat interesting of course the next
thing that could be imported exported
from or assembly are Global's which are
literally global variables just like
global variables and c plus plus except
that they don't have they don't live in
the edge of space they can't have their
editors taken so in theory a smart
compiler could actually compile a super
post global variable into a wise and
global variable if I wanted to if I
could prove the address has not taken
there's not really a lot of reason to do
it unless that global is going to be
imported exported because the nice thing
about these is it could be imported
exported with a very much tighter
granularity than the entire address
space with with linear memory you have
to import and export the entire address
space if you can say I'm going to have
certain values I want to communicate
between modules I just want to put them
in a global variable rather than have my
entire address base key press around and
the final thing you can import maximum
of assembly to our functions we've
covered function a little bit before but
functions basically just contain
signature which is argument types and
return types and a body which has local
variables in it and code and code is
just the sequence of instructions so
those four things the big picture here
that webassembly doesn't have any kind
of like syscall instructions or i/o
instructions literally the only way of
talking to the outside world
is to interact with imports and exports
those are sort of the only communication
mechanisms so moving forward as we
talked talking about security the only
things we have to worry about in
security are the things that deal with
imports and exports yeah so these these
four things come together sort of the
building blocks of dynamic libraries
because if you have two modules of two
pieces of code at a runtime they're
sharing address space they're sharing an
indirect function tablespace they're
basically in in native terms you could
think of it is essentially two different
libraries loaded into the same process
because of such a they're sharing the
same address space and they're sharing
the same indirect function space so
the idea here is the separation of
policy and mechanism where the mechanism
is just this very general concept of
being able to import an export modules
and and the policy you can you can
implant a wide variety of policies on
top of this so there's a lot of
different ways to do dynamic libraries
in C++ and you can have different ways
of handling weak symbols and different
ways of doing adjusting simple
resolution all that stuff is going to be
essentially be a policy there that's not
going to be baked into the system at all
there will likely be very standard ways
of doing this it's going to be standard
tools you use for dynamic libraries but
it's not gonna be baked in and we expect
those gonna give us a lot of flexibility
frame planning interesting new languages
and new language features so with that
with imports at exports be the things
you have to worry about security let's
take a look at security and how web
simply actually is is made secure so the
first thing we talked about in the
import/export is linear memory and I
think the main thing you do with linear
memory are those those doors so how are
we gonna make those secure the very
easiest simplest way to do it is just a
stick advance check on every single open
store if the index is in bounds is less
than the current memory then it inbounds
otherwise it's out of bounds and you go
to the error handler that's sort of the
very simplest way of doing it but a
common trick that's being used in 64-bit
engines is if you're running it wasn't
32-bit help thing it's a 4-bit engine
and this is the code that we saw earlier
that's all happening that's why you
didn't see bounced checks we can
actually reserve address space up to
well we'll start with 4 gigabytes and
ignore the offset for now we can reserve
up to 4 gigabytes of address space and
then we don't need to have any pulse
checking because if you're in bounds the
load/store will just succeed if you're
out of bounds the locals will hit put
the address space so we've managed to
make so it's not beatable or not
writable so it'll seg fault and the VM
can catch the seg fault in and and dump
your handle at that point so this is
essentially technique so that in a
common case when you're running a switch
or a browser or an affinity with
webassembly application there's no cost
checking overhead of course well the
source can have sets so you can imagine
extending beyond the 4 gigabyte range to
a gigabytes because sucks yeah 32-bit
offset at most and if you want to do
things like fold in scale offsets you
can actually extend the address space
even further so it's
the idea is in a 64-bit process that
edge of space is not a precious resource
you have lots of outer space you're not
actually allocating memory for it it
just sort of this one of the terminology
you use is it's reserved the doc
committed every space so it's just it's
out there nothing else can use it and
it's it's mapped so that if you touch it
you'll get a seg fault it's not actually
contributing to memory being used of
course 32-bit browsers are also
important 32-bit engines are also
important so we've been looking at a
variety of hybrid techniques where we
could actually just have a single guard
page at the end of the address space and
this allows us to do things like if you
have two offsets that are the same base
post different ops or two loads of same
gauge with different offsets if you can
prove that one of them is a balanced and
the other one is within the size of a
guard page then you don't need to do
both checking for the second one and
using techniques like this we actually
found that you can easily eliminate over
half of the pause checks you're just
using a still cloths tracking technique
so you can actually significant because
this and we have we haven't even started
applying lots of the fancier advanced
tracking techniques things like ABCD and
this other like loop where kinds of
optimizations so the thing there's
actually a lot more room even even
beyond 50 percent for eliminate bounced
checks in 32-bit browsers of course
we're always on the lookout for for
hardware techniques to do sandboxing
more efficiently Intel us added a number
of features their chips recently which
are pretty intriguing although it seems
that right now the ones that are coming
available don't actually quite support
the model that webassembly needs for
doing sub boxing but we're definitely
keeping an eye out there for new
opportunities the next big thing Webb
said with it we need to sandbox the
import/export list is the tables and the
indirect function calls so again so the
same story here the basic thing you can
do is you can do about check on the
table so you do a call and direct the
operand to call it direct is an index
and the index is going to be in the next
table if you're beyond the end of table
then you're out of bounds like an
occultist work webassembly also has to
do a signature check it requires that
the types of the call color match the
types of colleague and that can actually
be done with a single you can you can
essentially a coda call signature as a
single integer it you can do that with a
single integer comparison this means
that there's somewhat of basic control
flow integrity built-in
but it's not full good novo integrity
it's just sort of a minimal control for
eternity at the level of the Wesen pick
system this is sort of an area still
being developed and there's this idea of
tables in when we have multiple memories
you also think of having multiple tables
and if you can split up your function
space into multiple spaces you can get
finer granularity on function junking so
there's a lot of different ideas about
the way you can use this for example
people whose lead tables are typically
compiled such that you have a struct in
your address space it doesn't just data
in it but that's not necessary because
applications can't point at their own
v-- tables there's no way actually get
at it from assume C postcode so we could
actually put C both plus B tables
outside the address space in a table
and use that too we do some of the
overhead of magnin superboss veto
alcohol another idea with tables is if
you segregate your your into our
function tablespace such that each table
only has functions of a single type then
you know that calling any function in
that table will have the correct type so
you're actually need you a type jack in
that case so these are some ideas of
Europe are going around of how we can
reduce overhead of indirect function
calls the other parts of webassembly the
imports and exports that we need to
worry about securing global variables
and functions don't actually have much
for security there's only nothing you
can do with a global variable that can
actually cause a security problem and
for functions really the only thing you
need to know is that with the call
Newark with the table mechanism you can
only call to the top off function you
can't actually call the middle o
function
you can't call into random data data is
not actually executable like all you can
call are the top o function so we have a
very strong control flow guarantee in
that sense and of course call stack
overflow is checked so there's no way
you can vote up with the stack and get
out the sandbox so I mentioned that see
if I am using multiple tables people are
actually looking at doing a stronger CFI
we can actually split up the function
space into tables that represent the CPI
post type system more precisely so you
can do full scope of our types of CFI
that comes with some extra overhead but
it is it is possible so this is the
category of things you can do to help
applications secure themselves I guess
themselves rather than just sitting
against the browser because the browser
is kept secure by the basic guarantees
sandboxing one of my top of my favorite
topics to talk about my behavior see
Paulo plus is still sequel plus it still
has its undefined behavior and they'll
see more as it does when you're
compiling with them scripting or any
other C política piler you run the
optimizer it's going to take advantage
of undefined behavior in the same way
that it always does even let us talking
about assembly that said when you get
web sembly on the other end
it basically has all of all the none fun
behavior results out does it work it's
much like when you get x86 code from a
compiler the compiler the optimize the
code took advantage one fine day havior
but once you get x86 code that code is
going to behave the same way modulo
threading and other various things that
are sort of exceptions to this but for
the most part that code you get is going
to behave the same way all the time at
all on all x86 limitations we're really
going for the same thing of assembly is
that you play see for most code your
undefined behavior you have a bug and if
you recompile your code with different
flags different compiler different
version the compiler it can do a lot of
different things but once you get some
webassembly output in fact of code works
in one browser it will work in another
browser there's no possibility that
you're on defined behavior is going to
still get exploited now modulo a couple
of areas where there is this very
limited amount of time determinism but
it's very very small there's no such
thing as naval these elements and
webassembly the optimization is it's a
really important topic when you're
running in a in a very resource
constrained environment like a browser
in many cases sort of standard operation
applies though to - oh three sort of
mean different things as they always do
and no one really knows what the
difference is you know - until three
years but you can try both of them and
see which one works for you
os compromise for size as well I
mentioned also earlier that that photo
point is fully deterministic so I took
we have 34 floating-point
specifies what happens but that does
mean that VMs can't do things for you
like up mize your floating-point in
various ways I would change the answer
so we can't change the division to
Baltimore reciprocal we can't do we
Association we can't distribute most
positive or adds that kind of thing but
it doesn't mean that those optimizations
are off limits for assembly because all
patients can be done in the compiler
producing web assembly so the idea is
you think about assembly as an is a is a
is don't have fast math flags but
compilers do so you pass these to your
like in scripted and it will take
advantage ease and do the supplications
for you ahead of time that way if the
value has changed is changed everywhere
there's no such problem as different
browsers giving you different photo
point answers the - yes no it's at one
time equals one flag is a time script
and optimization which is kind of a flat
optimization if you think of typical web
app doesn't ever actually exit you have
a page open interact with the page and
if you close the tab or you press back
or you do some low but applications goes
away there's no actual time where you
just say okay I'm going to actually exit
or I call my global destructors so - no
it's at runtime after you tell subscrip
and just omit the code for all the
global instructors and the exit code and
saving some code sighs I think I
mentioned earlier the streaming yes
that's on demand is actually really
important especially for a lot of games
that have very large graphics assets
they have to download if you've acquired
users to download the entire assets for
your entire game upfront it's a very
very large download it takes away one of
the big things of the web so streaming
things on demand is really useful use
your ills is actually really really
important things I mention its
optimization but really it's more of a
meta optimization as far as how you use
the web how you like about the web so
with the URL defeated the web if the
user clicks on something and they could
just be launched right in with the game
hopefully Wi-Fi in here is is fast
enough to make this enterprise a demo
we're still downloading ok well there we
go
so I clicked on the link and suddenly
I'm in the game I'm not actually very
good at first-person shooter this is
actually kind of old demo it's a fun day
although it's multiplayer and there's a
bot in here somewhere that's going to
come after me but the point is this is
actually a real interesting model for
attracting users and getting people into
key engagement application there's no
need to have them install an app press
something out looks like I didn't do
very well
but you just like you have URL posted
spitter posted whatever you want people
click on it make the playing the game
it's especially interesting for
multiplier games because you have people
clicking on a link and can be joining a
multiplier game all together at once it
can may happen very quickly because I
set a low friction overhead so step by
something I want I can sort of think
about in terms of deploying applications
and organizing them so webassembly I
mentioned the design is basically done
this point for the MVP which is a very
limited release but we have all the
browser vendors participating and
there's lots more to come there's lots
about stuff we want to add to
webassembly going forward let's get
there for our base set up we can build
on we're going to be adding lots of cool
features dynamic libraries are going to
significantly improve download times and
all applications to be split up and wrap
it up they've updated more in more find
a great way that comes with a chroma to
have a stable idea I seen sea Colossus
API so we can have dynamic libraries
that don't have version skew of course
threads with shared memory and a very
very critical feature for performance
Cindi debugging features live in MA
positions there's just tons of stuff we
want to do to make webassembly awesome
she put us all at the platform all right
I can move it up for questions
what are we
yes question so when you go to some
public URL and there's webassembly stuff
that happens what like you just showed
yep
would you have other URLs kind of
displayed that people could click on
that would go into different parts of
the same kind of compiled application or
but it would it go and different like
make a different server request and get
a different way um if that makes sense I
think it does I think the answer is you
could do it both ways yeah I'm not sure
I fully understand the question I think
so the answer is like most the demo that
we're showing are sort of full screen
applications where you click on
something and use there's a single
target to go to like you play the game
and just like the entry point of the
game is always the same no matter how
you arrive there but it's definitely
possible to have like you can pass
arguments into a pilot program or you
could have multiple web assembly images
there's different other ways you can
organize it you could have multiple of
assembly elements on a single page even
so it's it's you can direct people the
part of the page you could I think
there's just lots of ways you can
organize replication do you have given
people having different experiences yes
question over here or oh sorry go ahead
Lee Easter with assembly above H bye
yeah so the first question when there's
a segfault what happens so a segfault in
native code happens when you preamp all
dereference a null pointer for example
or oh so Natan is this the memory-mapped
trick for avoiding ball checking for
example you reach beyond the address
space you touch a page that's not Maps
segfault yeah so that so the user sees
in terms webassembly the purpose emily
vm it executes of what we call a trap
and shop means that the current thread
is terminated and if it was called from
JavaScript JavaScript will see a
JavaScript exception being thrown and
for web simply right now today that's
the most common use cases you're getting
call from Java scripts you'll get a you
can exception coming out of the VM
the other question was zero somebody dot
H right now there is no such thing but
we still have when you're using a
Krypton which is the primary thing to do
right now in the beauty P timeframe
you're getting all the inscript and
features are there the oven scripted H
there as well well so in scriptum is the
compiler that can produce either asthma
Jas or webassembly that's like it's
probably you're asking is that asthma
Jas versus web sembly codes I DIF I
don't have the numbers with me right now
but it's significantly smaller simply is
a binary format sign I mean I I'm saying
about half size my experiences it's it's
more than half but or it's it's smaller
than half but I unfortunately don't have
an operator that automated that I want
to be confident in telling you but it's
quite a lot smaller yes question so
webassembly speed is about the same
width as inverse feet today in Firefox
we're using our same engine it's all the
same code essentially running web
simulator running with us PS so this
result the same which is about 1.5 X
slower than native is in sort of many
any kind of common situations but I
watch through some of the native code
early on the talk and show that we
actually have a lot of examples where
Firefox is in generate optimal code I
mean those are things that we can do to
optimize that don't require changes to
the website language so over time
they'll be getting significantly faster
yes question all right so the question
is can you use web somebody to interact
with the DOM and the answer is right now
today with the current web assembly you
can't whoop simply does not have GC
features and almost all the Dom API is
you're basically dealing with GC objects
not coming as me Tom that is a feature
that's planned for the future that we
coming up with assembly well he's
expected to gain the ability to hold on
to a GC handle to talk to do see objects
and people to call them directly so
right now what you do is you call the
JavaScript and how the JavaScript call
it down for you now it turns out that
for most Dom API is the actual Dom work
is overhead so the overhead of
collective GS isn't actually that's
significant most the time but it is
significant that it is something that we
want to fix we want to have flow basilic
all directly into the Dom all right your
question yes so the question is they
have an application which is all written
in JavaScript today they want to know if
there's any advantage to taking
advantage of webassembly
so webassembly does not make JavaScript
code of any faster
there's no way to sort of compile down
to get into webassembly today so unless
you were to write new code in a
different language then the answer is no
or potentially if you were able to bring
in libraries and use them from your
JavaScript code the libraries could be
compiled into weapon sembly you could
call them from javascript code would be
another way you could do it but there's
not really any way to make your actual
JavaScript code one any webassembly in
run mini faster yes so it was combined
what is the week do now do export some
functions and then you can freely call
them from JavaScript or the conscience
yeah so I guess the question is with
Asmodeus it's relatively easy to bridge
Asmodeus with javascript because you can
call functions and the answer is well
somebody could do the same thing you can
call up assembly functions directly from
JavaScript and vice versa so if
webassembly exports a function in in the
jsapi when you get a website module
object that's a module object in
JavaScript and the module object has
properties for every export function and
those are just functions you can call
from couch grips so that's the way those
york says you're going from your chance
to file just oh that's right yeah so
that's bridging to the Dom is not
something most people do where both
because I'm scripting does it for you
but yeah essentially there's is a pretty
simple error that's British doing all
the bridging yes question so the status
of browser support now
so Firefox nightly and Chrome Canary are
able to run the current demos that we
have Marcus
Edge has been able to run some of the
demos I hope akin one that one that's
currently live on the website but
they're definitely there's an
implication progress and the WebKit is
also impatient in progress
I don't know we have someone who is
working on it I'm up good team here
earlier but he's not here anymore so now
but definitely all the browser's at
least working on it
and some of the brothers have sort of
publicly usable demos right now and
they're really these browsers yes
question question is do the brothers
have support for hooks for debugging
your profiling and the answer is not
very many right now that's actually an
open area that we won't definitely know
that we need to improve on so yes
definitely an area to improve in I think
it actual one of my my bullet points
sent one my slides here so going forward
add debugging support I'm actually kind
of excited about a particular aspect of
the debugging support you could think
about like a debugger for language like
C++ actually a fairly complex tool it's
going to do a lot of intense need to
have sort of mini rebel that you can
type Russians into and evaluate them
which means you essentially have a full
five super Louis compiler but sort of
that's a lot of Quebec City to build
into a browser and if you think about
we're pouring multiple languages every
single language you have to have its own
version of the debugger we don't have to
build all these things into browsers so
they're really the idea here is to have
AP is and allow languages to essentially
provide their own debuggers compiler
could pride their own doggers so you
take existing the dogger like say even
gdb or LD be some kind of bug like that
and compile it port it to the web
assembly API is using the whatever
meccans are available and then that
would be your UI so the browser itself
wouldn't have to hard-code the UI it's
possibility for flying support so
Firefox nightly actually has some like
minimal profile support you can actually
run the Sun webassembly code and get
essentially a profile of showing you hot
functions it's not it's not a very
extensive profiling tool if you're
familiar with sort of fancy tools like
v2 and whatever but it can show you some
basic what's hot kind of things also
definitely an area that we know there's
a lot of room for proof in yes are there
any
a preferable way to optimize relativity
so they're any simple plus features that
you should definitely prefer or avoid
built into made of so they have code the
main feature that comes to mind by now
is exception handling so in the MVP of I
was simply the very first version we
don't have zero costing age support and
essentially exceptions are being
emulated so if you have acceptance
superballs exceptions in your code this
can be pretty inefficient right now it's
ugly something we're going to fix in a
subsequent version of whip sembly we're
planning on having a zero cost eh
mechanism built in but until we get that
exceptions are helping to watch out for
if it's another question up here
question is there any plans for talking
into a dynamic library that's already on
the system or could be downloaded from
system I'm not aware of any plans for
that and it would actually be
significantly difficult because
webassembly code is running inside a
sandbox and native code is not built to
run inside of a sandbox bridging that in
particular if you wanna pass pointers
between the web silly code and the
native code they'd have to be some kind
of bridge layer and it's really
difficult to do automatically
yes question so question is when you
download one of these webassembly
binaries just say in a browser cache so
it uses the same mechanisms of the
regular browser cache for HTTP cache
that kind of stuff we actually also
cache the generated native code so when
on the first download application we
compile it into native code that takes
some time on the second load of
application and we'll actually just do a
quick hash of the of the binary see if
we've seen it before and we have the
native code in my cache would just
literally map the native code in and run
it so it's very the second one is very
fast experience we're working on driving
the first download time that's that's
like why web simply has a small code
size when the pasty code time is to get
that very first experience down so
that's really important but subsequent
loads are fast because they're cached
alright yeah
omit caching code cache net code their
codes them have pointers to have objects
embedded how do you do that so caching a
code and force example you have that
check to make sure that the stacked in
overflow yeah so I showed some made of
code earlier that had example with
native code they actually had a
hard-coded virtual address in it and if
we're caching the code I would you like
that and the answer right now is that we
do patching we just keep track of that
and patch it in which isn't particularly
great I think actually our main strategy
going forward is going to be to generate
pic and just use everything pic and
avoid actually embedding anything to the
code so we don't need to touch anything
code we load it in that's not even what
I got yet but that's right now we have
yes yeah so the question is we support
setup along to open if so how do we get
the qubits here the answer is yes we do
and I it's somewhat maybe this is
another thing I should mention and sort
of seal all those features to avoid it
set up along jump they do work they're
not going to be fast so the way they
actually work would you a set jump today
amps Krypton will actually translate
that into a call out to Java scripts
which will do a try block and then on
the stack callback in a web assembly and
when do a long jump
we calls JavaScript which throws which
will unwind the stack if you loop simply
back to the JavaScript is let's try box
still on the stack which will catch it
so this is all staying within the VM
it's all sandbox it's all good to go
but you're dealing with multiple sort of
FF I call Sid just get back doing it off
good try block which is never going to
be amazing and then coming back so is a
lot of just even just doing a set jump
is a lot of work we had so it sits and
actually looking forward when you talk
about adding the zero cost eh features
we're considering imploding such a
plunge up on top of the zero costing H
features just because it'll be so much
faster
all right yes question accessing like
Google storage so to spoke assembly up
support for accessing local start and
xdb and the answer is this thing
essentially the same thing for like
accessing the Dom so weapon simply
itself doesn't actually have access to
it but you can call the JavaScript that
jobs cannot talk to those API is and do
that kind of stuff
so in scripted actually has a support
when I talk about the emulating the
filesystem that's kind of stuff in
script an actually has support for
giving you API is that are more familiar
to a support programmer that are
implemented in terms of an X DB so you
don't see it with an HTP yourself but
and going forward when we add like
native access from web some way to the
Dom we can also add native access from
was happily to other Web API is like
index DB and other kinds of things like
that so those will be added as well
alright is people other questions you
want them to come up after the talk so</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>