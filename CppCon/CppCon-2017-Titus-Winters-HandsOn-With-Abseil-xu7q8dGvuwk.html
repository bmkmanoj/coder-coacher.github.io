<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Titus Winters “Hands-On With Abseil” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Titus Winters “Hands-On With Abseil” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Titus Winters “Hands-On With Abseil”</b></h2><h5 class="post__date">2017-10-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xu7q8dGvuwk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Alright everyone, thank
you very much for coming.
I have already spoken for quite
some time today, my
voice is a little raspy.
I suspect, given the number
of people that I said,
&quot;Hey, go ask that in the afternoon talk,&quot;
that there's questions.
Since I would really
like all of the questions
to be answered during the time
that people are here, I'm gonna do things
super backwards and take questions first.
And when we run out of questions,
I will go through some prepared content,
and when you have more
questions, please let me know.
'Cause as it turns out, I
spent a significant amount
of time getting this
release out and prepping
this morning's talk, and
this one is crap, so...
(audience laughing and applauding)
So, everyone that was
lined up for questions,
like four hours ago, please
come find the microphones
and if you don't, then I
guess I will do this talk.
But I was really hoping not to.
Question, great, please.
- I'll do the microphone.
- Great, wonderful.
Please, I'm not joking.
(laughter)
- [Participant] So this
isn't directly related to
the libraries, but I had an
elephant in the room question.
Do you think the standard
itself could live at head?
- Okay, so there's a
paper that I published
in conjunction with most
of the direction group
this summer, and had a first
presentation to Toronto.
And I'm supposed to have
something that the whole
committee can vote on at Albuquerque.
And it's not a, &quot;We're
standardizing this&quot;.
But it is a change in how we define
what compatibility means for the standard.
And by and large, this
is, currently the standard
operates under, &quot;You shall never
&quot;change the meaning of existing code.&quot;
And that's fine, except,
if you look at things
like the Curver team's TS,
we're inventing new
key words like coawait.
That's not the keyword that anyone wants.
We are just afraid to take a wait.
So the proposal runs roughly this.
The committee shall decide
this is the direction
we actually want to go.
We are clearly going there
for C++ and Plus One.
We need all of the compiler
vendors in C++ N, 17,
to issue a warning for
everything that's going to break
or change behavior in the next version.
So if we want await instead of coawait,
then when you build in C++17 mode,
and you have use of the name like AWAIT,
that would be picked up as a keyword
instead of as a your local function call,
a general internal warning.
Okay so then you just search and replace
and you will be like, oh okay
I need to change await to
myawait or I don't know,
you pick a better name.
And then you can update a 20
and the rest of the language
can have a better name.
And like so basically the
proposal is not that the
language can necessarily live at head,
but I'm definitely trying
to get the language to
operate in a mode where
new versions are rollout
and deployment plan as opposed to a bam,
this just happened to you.
And I think that's probably
about as good as we're
gonna get.
It's not done by any means.
But I think it's likely.
I had much less fight on that
than I expected in Toronto,
which is always a nice thing.
Most of the things that
I work on are about
we need the ability to change.
And that is true both for
Abseil and for the standard.
And now Marshall wants to chime in.
- [Marshall] Just a
quick follow-up on that.
I can't speak about the language.
I can speak about libraries.
- [Participant] You
should talk into the mic.
- I should talk into the mic, okay.
I can talk into the mic.
Anyway I can speak about libraries
and most of the standard library vendors
do not wait for the
publication of standard
to start implementing new features.
They're usually buried behind your, well
dash std equals C++ 2a, say,
in the next release of
C++, if you do that,
you get stood Indian.
Just as a very small example.
And those kind of things
you can start using them,
in a few months.
But their option is all hit or miss,
because different people have different
implementation priorities.
Is it Indian, I did Indian 'cos it took me
less than an afternoon,
as opposed to say I
was talking to somebody
just over the break, who
is proposing slot map.
If that gets adopted, that will
be more than an afternoon's
work to implement.
And it will go on to a schedule
and will happen eventually.
So you can do an
approximation to live at head
with your standard library vendor
except that you have to
take on the responsibility
to know that what they've implemented
and what they haven't implemented.
- And then going to back that,
Marshall is external commit
number one for Abseil.
Where he pointed out
that our object for when
stood string view exists,
was assuming the standard.
Whereas in lib C++, it exists
in much earlier versions,
so the very first external
commit to Abseils,
GitHub repo, is changing
the detection logic for,
if you are lib C++, then yeah
you have stood stringview
earlier than 17.
It's all one big thing.
- [Participant] Alright,
this is a two parter.
The first part is I'm
mildly curious about the
near-term timetable.
You mentioned a bunch of things
that you want to ship soon
or I don't know if you
said soon, but I'm curious
about what you plan on
shipping in like the relatively
near future, and the one thing
I noticed you mentioned was
command line flags.
So I'm curious how like
gflag, glog, gtest,
tie into all of this?
- Yes, so the biggest thing that my team
is gonna do for the next
couple of months is clean up
what mess we've made internally
because this has been,
I'm gonna tell a story.
When I talk to civilians about what I do,
description that I use has
been we have decided that
it's important to have a standard
foundation for buildings.
We have decided therefore
that it is important to change
the foundation out from under
the Empire State Building.
We are not allowed to close
the building or block traffic
while we're doing that.
And we have discovered
nuclear waste in the basement.
(audience laughing)
So all of the stuff
that we actually shift,
is the result of that but
we have also been doing
just staggering, like I
claimed at a director level
last week this might be
the largest refactoring
that humanity has ever done.
I'm not sure anyone's
gonna call me on that.
Anyway the first thing
we're gonna do is finish
cleaning that up.
The next priorities are like
you said, flags on logging.
That was in the initial release until
some of my people came up
with a design that let us
explode the oldest, craftiest
knot in the dependency graph.
And then we realized, oh we could delay.
So flags in logging is coming soon.
I really don't like giving time estimates
'cos it's really hard to estimate how long
refactoring is gonna take,
when there is a quarter
of a billion lines of code
that depend on you.
But I'm sort of guessing it.
It's probably winter or spring.
- [Participant] So is it spring?
- Winter or spring, yeah.
They are derivatives of the old Glog
and Gflags packages.
The flag's API has changed
rather more dramatically.
One of the things that
we really didn't like,
I think it was probably
three years ago was that
the flag's API is based
entirely on having totally
unsynchronized global.
- [Participant] Yes I know.
- Yeah it's not good.
- [Participant] You created
an mese-neraker base too.
- I'm so sorry, it wasn't me.
- [Participant] I know it was me.
I'm Nexium's system pro.
- So the flag's API that we
will ship whenever we ship it.
Magically, we designed
it specifically so that
there is an incremental path
from the old to the new.
I don't know whether we will
be able to pull that off
if you're using the current
version of external Gflags,
but we should have that discussion,
but by and large, it's
everything is accessed through
accessors and sellers,
so that they can be synchronized.
One of the side effects of that
is for strings in particular
you wind up with different
lifetimes than you did
in the old version.
John has more or less
demonstrated that this works out
in practice although it is
in theory quite worrisome.
We'll have more experience
with confirming that
that actually works in practice
when we actually ship it.
But yeah the new flag's
API will be both actually
thread safe.
Its atomics for atomic reasonable types.
It's locks for things
that are more complicated
like strings.
The logging API is largely
API compatible with
everything that's gone before it.
At least the simple parts
and the flag's API has user
providable type extensions.
It will also, I'm almost
completely positive
have support for containers
of permitted types.
- [Participant] About time.
- But I'm also going to be kind of
opinionated about you shouldn't
really have containers
of containers of containers
of flags of types.
So you could build that yourself,
but I'm gonna laugh at you
when you come to me with bugs.
So take your pick.
- [Participant] Just one
clarification request.
Your promise of tool
conversion may not apply
to the current Gflag Gtest?
- True.
We will do what we can.
We will do what we can.
I can't promise that we
haven't controlled that API
for many years.
I have discussed with
the current maintainers
of the external Gflag's package.
And that was very early and before we
had publicly announced.
So I think the two communities
need to have a discussion
about what do we want to do?
Do we want to just ignore the thing?
Do we want to try to
build a transition path?
What do we want to do?
It's not a bad existing package
that is just, we've used it
successfully for many years.
For many billions of dollars.
There's just some things that
we think could be improved,
that doesn't necessarily mean you have to.
So go ahead take your pick.
- [Participant] So I haven't
had an opportunity yet
to look at the repository
since you announced
it this morning.
We have at my team, we've
got a library that's pretty
similar I think, 'cos
we've got four declarations
and using a lot of C++17
like objects in 14 and 11.
And I was wondering if we
were to deprecate our library
and start using yours instead,
what kind of headaches
would there be?
So we use CMake for example.
Do you use CMake what
build systems do you use
and if your build system
settings are incompatible
with ours, how difficult
has your experience been
with migrating over to be compatible?
- So as it turns out,
I have slides on that.
Currently it's Bazel.
Soon it would be CMake in addition.
Bazel is what we use internally.
That is always going to
be our source of truth
as far as the build graft goes.
That said, protobuf and
gRPC have many happy users
that are CMake based.
I have nothing against CMake.
It's just not what we're expert in.
I really desperately
wanted us to have CMake
when we shipped.
(audience laughing)
But like I said, Empire State Building.
This was hard, that so
we'll get there soon.
Someone came and talked
to me after the talk
and was asking the same question.
I desperately want this to exist.
We don't have a lot of
experience with that,
'cos we live often our weird ivory tower.
So my strongest suggestion is go join the
abseil.io email list, and start a thread
if one hasn't already happened for.
Who wants to help us make CMake stuff?
My only requirement in that
space that I'm aware of
is that protobuf has
a requirement on CMake
from like two and half
years ago or three years ago
or something like that.
And so we will have to
be at least that old.
You can't use super current CMake.
Otherwise, yeah we should do that.
As far as the rest of that
question and things like
warnings flags and build flags,
low level libraries
should support everything.
It is irresponsible for
the thing at basically
the bottom of the stack
to not work with whatever
configuration you want.
It's very much like be
liberal in what you accept.
If you have dependency of everybody,
try not to be the limiting factor.
That said, not all warning
flags are the same.
There's a code that actually
exists in our repository
right now.
Anyone know what flag
I'm about to yell at?
Unreachable code can
just go die in a fire.
Those are constants to the compiler.
So compilers like oh I know
exactly what this means
and either the internals
of that conditional
or the break are unreachable
depending on what
configuration your build has.
Your compiler is
evaluating unreachable code
with respect to the
current build settings,
not with respect to all
possible build settings.
And when you're trying to
build on every platform
that is like common and sensible
you're gonna wind up with
a few macros in there.
We've tried to keep that under control
but like I spent a little
time actually in the last week
trying to make unreachable code, pacified.
And then was like you know what?
That guy is stupid.
No, unreachable code is
just not ever gonna be
a thing that happens.
So, sorry, we can have a deeper discussion
if that turns out to be a non-starter
but fundamentally please just
don't try to enforce that on
a very general library.
Did I hit all of your points?
- [Participant] Yes, I do have
a follow-up question though.
- Go for it.
- [Participant] You had said
that you wanted an upgrade
path in tools, it would help developers
follow that upgrade path
so it strikes me that
some of the build systems
might also have similar kind
of issues with upgrading.
Would you be able to create
tools that help developers
upgrading their own build systems as well.
- I don't know.
In theory, yes.
In practice, I genuinely don't know.
I will say from internal discussions,
one of the people that
has been really rara
since this morning slides,
is one of the very developers
on Bazel.
They were like please make this work.
Like this is exactly what we want.
It's not just a language thing.
It's not just a C++ thing.
It's an industry thing.
So yes, in theory but I
have not thought about it.
I have this lot of my thoughts
are probably applicable
in software engineering,
but like my job is just C++.
- [Participant] For what it's worth,
you can then do the role with
Bazel managers to live at head
and upgrade Bazel plots.
- The comment from the audience
was, for what it's worth,
within Google Bazel managers
to live at head and upgrade
Bazel files when they make
any compatible changes.
- [Participant] Thank you.
- Anyone else have questions?
(participant talking off mic)
Great I will go to slides.
The stuff that has been slightly prepared
I'm going to talk a
little bit about naming,
namespaces, exceptions.
I'm gonna skip the build
question because I think
we just covered that.
I will probably skip over and talk about
compatibility guidelines.
We may do a quick tour
of the pieces that are in
the repository right now,
little bit more in depth.
If there is time, I will demo things like
the debugging features,
trigger the deadlock detector.
Trigger ascent trigger descent.
Demonstrate the preadopt types melt away
in C++17 mode.
And then we'll go back to questions.
Generally speaking, if you
have questions at any time,
don't save them to the end.
I would really like this
to be more interactive.
I'm really not up to lecturing right now,
so we'll dive in.
One of the things that
you'll notice when you look
through Abseil is we have
an unusual idiosyncratic
naming style.
If you look at naming for other libraries
that you might be touching,
the standard or boost,
things like that, you will certainly find
a lot more things like on the left
than what we have on the right.
Abseil tends towards flasher
namespaces and prefixes on names
as opposed to nested namespaces.
But even the prefixes aren't
necessarily ubiquitous.
So what's up with that?
Did we just totally screw up?
I would argue not.
We could of course have prefixed
everything with additional
nested namespaces in there.
This is what the standard
seems to be leaning towards.
I would like to argue that
this is a terrible idea.
And that the standard has a misstep there.
I posted to standards mailing list
during the Toronto meeting arguing,
enumerating all of the
ways in which I think
nested namespaces are wrong.
And I will resummarize some of that here.
But one of the key points is,
I actually don't care
if that alphabetic list
of symbols in the library is useful.
I want it to be useful,
don't get me wrong.
But that's not the thing
that I'm optimizing for.
I've used CPP references list
of things in namespace stood
five times in the last six months.
I use CPP reference about
that many times a day,
in a normal day.
I usually know the name of
the thing I'm looking up.
And the more interesting
question is not so much
does this name make sense in a list.
Can I tell perfectly
what ConsumeSuffix does,
the more interesting question
is can I tell what this
does when I encounter it in
code and I'm not familiar
with that function?
Abseil like I have run, I
have had a significant impact
on the Google training
programs, the Google Styleguide
all of those things for years now.
This is what we have to make for.
I don't care how it looks in the header.
I care how it looks when you're reading it
and you're unfamiliar with it.
And this I claim is sufficient.
Nobody is gonna look at
this code and be like
I have no idea what ConsumePrefix does.
There is enough clue there
that you can figure it
out pretty easily I think, I hope.
Readability matters.
Maintainability also matters.
So consider how likely
are you to write using
foo widget when you want
to use something out of
the foo library or god forbid,
you are using declare namespace foo.
Don't ever do that.
Not even once.
You're probably not gonna do that, but...
(participant talking off mic)
Since SUV swap in generics, but sure.
Using foo subteam widget,
the odds just go up?
The odds just went up.
For foo subteam project widget,
odds definitely just went up.
Subproject widget, I have
actually encountered teams
that had nested namespace
and six levels deep.
This is not hypothetical.
If you're trying to use code
out of a thing like that,
does anyone want to fight against me
that it is more likely
that you're going to using
declare that than this?
Clearly this is human nature.
I don't want to type all
of that ridiculousness.
You're gonna fight?
- [Participant] I'm not gonna fight.
I'm gonna ask what
about namespace aliases?
Namespace subproject equals (mumbles).
- So the question is what
about namespace aliases?
Namespace aliases also factor
into this object as fine.
I just didn't cover it in slides, but yes
namespace aliases are a thing that counts.
And you'll see what the
punchline looks like.
So the question really is how
much does an API make sense
in context when you're reading that code?
I see a call that looks exactly like this.
SetContents foo.proto
some string cast of a
GetConfig, I don't know
what's going on.
Oh this was using absl file setcontents
at the top of the file, then
a few hundred lines of code,
and okay so with that in
mind, foo.proto is a file name
and I'm dumping the contents of GetConfig
into that file name.
Maybe you could've figured
that out without that context,
but the fact that I hid
file by using declaring it
is not helping anybody.
SetContents by itself
doesn't say as much as file
setcontents would have.
Maybe we should have
just named it that way.
As nested namespace length
increases, it becomes
increasingly important for
names to be clear without
the namespace names.
Anyone not buy that?
It seems pretty straightforward
once it's said out loud.
Kind of sad but true.
Similarly it's part of why
our namespace is actually
only four characters not six.
We really would prefer you
not to have to alias things
or declare them.
The worst part of this is from
a maintainability perspective,
the associated namespaces
for a name, include
all of the parent namespaces.
Is this not Java?
In Java you add a new
package in a new directory,
and when you import things,
it's limited to that package.
It's limited to that directory.
In C++, your namespace,
your associated namespace
search path is the
namespace that you're in
plus everything between you
and the global namespace.
So the side effect of that is
while it feels so good to
have these deep detailed
nested namespaces, that so
perfectly put everything in their
place, everything has
a place and everything
is in its place.
In practice, you're not helping anything
because name lookup in
C++ is very permissive.
You are not going to search just from
projects from project foo widget whatever.
You're gonna search in all of those.
And that can become a problem.
The rules for namespace
naming at Google historically
like before I was on the Styles committee,
was very much in line with Java.
We kind of wanted the two
languages to be very similar
and we were glossing over
the intrinsic technical
differences between them.
And one of the rules there
was namespace choice.
Your namespace should be an analog for
the directory's structure.
So if you were in directory net DNS foo,
you should wind up with
namespace net DNS foo.
And side effect of this is it's not Java.
You're not only exposed to
the things in net DNS foo.
You're exposed to the
things in net DNS foo
net DNS net and the global namespace.
And worse, every time that
you refer to something
the worst thing we ever
did was follow that pattern
and then have a util top level,
and everyone has their
own util local project.
So we have a util top level
and we have a bunch of
important utility code
in top level, so we have a
util status in the top level.
And you can't ever refer to util status
because your project has a nested util.
And they just become ambiguous
and your build breaks.
And your build tends to
break because someone added
include randomly to add other namespaces
that you hadn't seen before.
So Abseil doesn't do all of that.
Abseil very specifically
is a single flat namespace,
because nested namespaces in
C++ are worse for readers.
You lose context the deeper
you go because people tend
to using to clear them away
or they add aliases so that
you have a non-standard lookup.
And they're worse for writers
because they're actually
exposed to more namespaces
than you would be otherwise.
This is a terrible deal.
We should renegotiate this deal.
So that's namespaces.
Exceptions.
This is basically duplicating
what I said earlier today.
Yes we will try to support exceptions.
No we won't design APIs that require them.
And no you can't throw
exceptions from every interface.
Herb and talking about
synthesizing operator spaceship,
made offhand comment
to yeah and all of your
spaceship operator
comparisons should be noaccept
'cos it's gonna be expensive
and weird if it's not.
Increasingly one of the side
effects of the compatibility
guidelines that I've been
talking about for the standard
is gonna be yeah there's
stuff that we haven't
bothered to say you shouldn't
throw an exception from.
That you just probably shouldn't
throw an exception from.
Abseil will also do the same.
This is great time to
talk about exceptions
if anyone has more exception questions.
Really none? None, none?
Okay.
(participant talking off mic)
Why don't you say it at the microphone?
Yeah.
- [Participant] Talk in the mic.
- Talk in the mic that's on video.
This is John, he works for me.
(audience laughing)
- [Participant] Help us
we are all in the slave...
Sorry, sorry wait a minute.
So to clarify Titus's answer
from earlier in the keynote,
Abseil currently does not
have exception safety tests
but it will soon.
So we are going to be
testing and making sure
that our things as much
as we can that our types
do work with at least
basic exception guarantees
in most cases.
So it's not just, we are
actually taking them seriously.
- Anything else?
We talked about all this.
Don't actually want to do that yet.
So compatibility guidelines.
I am almost positive that one of the more
unusual and maybe hard
to swallow pieces is
we're telling you all
the things that you can't
do with this code.
And keep in mind, these
are all of the things
that you can't do with
this code if you want to be
able to upgrade smoothly.
Obviously if you just
want one version of it,
you can do whatever you want.
It doesn't matter.
It's difference between
programming and engineering.
I think we've talked
about those sufficiently.
The list on the website is slightly larger
and this question came up.
Dynamic libraries.
- [Participant] I actually
have a question about this.
What is your policy for
realizing you forgot
to forbid things?
- I'm gonna email the public
list and be like &quot;Hey!&quot;
(audience laughing)
Which actually, so until
very recently like I've been
trying to use the term
compatibility guidelines
consistently today.
It was like last week that
I sent a message to the team
saying, hey are we using the right term
because for the previous year it had been
the project contract, but
contract has kind of legal
overtones and meaning and
the lawyers were like,
no, no, no, no.
Which they're right, we can't promise that
at a legal level,
but we really don't want to break it.
We really want to treat you well.
We really just very,
very specifically need
like yes this code is what it is,
like we need the ability
to add new functions.
We know how it's been written,
like one of the side effects here is
don't rely on dynamic unloading.
Google is insanely worried
about, let's do this here.
By the way, Abseil is in
god build now, it's awesome.
Google worries a lot about destruction.
So this actually ain't any good because,
(mumbles) anyway I would
complain about this
in code review, because you
have a string at globalscope.
Destruction for a C++
program, like when you start
terminating your program, is
an exotic and dangerous time.
(audience laughing)
Because one thread is
going through and running
all of the destructors for
everything in your program.
And the other threads are
just chugging merrily along,
which is terrifying because
if your assumption is
I just need to make sure
that all of this data exists
before I have started things up,
that's fine except the end of your program
introduces a whole different
complicated set of dangers.
And there is nothing as
terrifying as having a thread
that is still serving requests
and it's still writing
data to permanent storage
that is referencing the
contents of a string
that has already been destructed.
The Google Styleguide
goes to great lengths
to talk about safe
initialization and destruction.
And that you cannot have
complicated things at global scope.
The side effect of you can't
have complicated things
like that at globalscope
is that they can't
and there will be a tip of this, tip 110.
I can do most of those by number.
MyCost to wherever it is.
We tend to wind up with
functions that rely on
so called magic statics.
Because the thread safe
static initialization rules
for C++11 say that,
oops, I did that wrong.
Missed a thing.
Static there we go.
The thread safe static
initialization rules
for C++11 say that no matter
how many threads are executing
that initialization, only
one will actually happen.
And then all of the rest of
them will see that result
and because we have heap allocated this,
it's never gonna get
destructed when that one thread
starts doing global destructions.
So it lives from the
first reference through
the end of the program.
This is lovely.
We have completely
solved our initialization
destruction problems.
So questions, I guess there's
obviously two questions here.
Just say it.
(participant talking off mic)
It is an extra atomic ball check
that's branch predicted.
Yes it's true I don't care, but it's true,
that is true.
The other one is, isn't
this a memory leak?
(imitates screaming)
(participant talking off mic)
What's that?
- [Participant] Walgreen's say this.
- Walgreen's says it might be.
(participant talking off mic)
No, there is still a pointer to that.
You haven't leaked it.
You haven't leaked it.
It's still reachable.
So there is question of
how do you find a leak?
It is unquestionably a
leak if you have allocated
a thing and there are no
pointers in your memory space
that point to that allocation.
At that point, yeah, you leaked it.
If you have allocated the
thing, not deallocated it,
but you still have a pointer to it,
that's iffy but debatable.
If you have allocated,
if this wasn't static
and I was allocating it on every
call, that would be stupid.
I'm not advocating that.
But what we do adhere to is
we don't go for what we
call Draconian leak checking
that absolutely every
allocation has to be freed.
It's the operating
system is gonna free it.
We're specifically talking
about Azure program
is melting in it's death.
As soon as it's done with that,
the operating system is gonna be like,
well all that memory is done.
Who cares if you call delete on it?
There's literally no difference.
The point where leaks matter is
if you have consistent
leaks, you leak it once
every time you call it, that's a problem.
If you have a leak where you allocated it
and there's no way, there's
no pointer anymore to it,
then definitely a problem there.
This debatable and we've
decided this is okay,
especially because this turns
out to be such a handy way
to avoid races add
construction or destruction.
(participant talking off mic)
Whatever.
(audience laughing)
The snark from my friend in the audience.
Don't go to his talk tomorrow.
What's that needs to be constant?
Anyway, this obviously has
ties to the, where did it go?
Where did it go?, where did it go?
The other thread, there we go.
Do not rely on dynamic unloading.
If we are doing this
consistently for bookkeeping
and globals and whatever, in
our synchronization primitives
and things like that,
if you load and unload
and load and unload and load
and unload and load and unload,
yup that's not gonna work.
Those are gonna be messy leaks.
Can't help you.
And on that I care more
about not corrupting storage
during process shutdown.
Then I care about supporting
dynamic loading and unloading.
You may have different priorities.
We can talk, but you're not
super likely to convince me
to change mine, but we
can talk, I love to talk.
Similarly, not all Abseil
libraries are suitable
for dynamic loading.
I believe that there are
some that very specifically
have program global
initialization startup stuff
that has been rigged.
This really, really, really
has to happen before May.
If you're only triggering that during
hey ideal open for this,
and gonna run some constructors,
I can't guarantee you
that's gonna work correctly.
Maybe it can.
And if you can make it
work correctly and send me
a patch that doesn't
look terrible to maintain
I'm happy to try.
I'm just not gonna promise it.
I hope that's fair.
The ADL thing.
Yeah that's most of
what's in there right now.
Any compatibility questions
before we move on?
Cool.
I would love taking the
temperature, show of hands.
Am I asking totally crazy
things or do you think
this is workable?
Workable?
(participant talking off mic)
God I hope so yeah.
- [Participant] Yeah exactly.
- Totally crazy? Nice.
One guy.
(audience laughing)
Cool.
Next up, a little tour.
So I mentioned there's some strange stuff.
There is actually quite a
fair amount of strange stuff.
If nothing else, I really
super want you to all play
with StrCat.
Yorg up here in the
front was nice enough to
send me benchmarks.
Maybe I should just spin that up.
I'll grab the benchmarks.
I hope there is no...
- [Participant] Policy.
- I know right?
(audience laughing)
(participant talking off mic)
I am mirroring the whole, snugly.
We'll just see.
Yorg.
(audience laughing)
Yorg, Yorg, Yorg.
Benchmarks, so according to Yorg,
this current benchmarks, and
I'll do this in a near dark,
so that's nice and visible
and not shorten my inbox.
Tip of the week.
Three, doesn't come up much anymore.
Might be six.
I've trained people out of it.
Pretty sure the tip of the
week three is use StrCat.
And part of that is this first benchmark.
No part of this is the worst benchmark of
both concatenating multiple
times and streaming.
These are terrible.
Don't ever use these.
Concatenating multiple times is messy.
Specifically because the
language has no way to
recognize a string of concatenations
as one logical operation.
We can't optimize things away
by moving the temporaries.
But it is entirely possible
that you're calling
multiple allocations the longer this gets.
And it is very likely that
you're doing an end squared copy
in the number of concatenation operations.
Having something like StrCat,
that is one function call,
is very easy for it to say
oh let me evaluate all
of these parameters,
figure out how long this needs to be
do one allocation and then
blast individual arguments
into that output as necessary.
The end result is almost
an order of magnitude.
I do not claim that your
string formatting is in
your critical loops or the
most important hot paths
of your programs.
But if you can save an
order of magnitude in
nuts and bolts sort of things,
you should get in the habit of doing that.
Yes profile before you optimize
but also just don't be stupid.
So thank you so much Yorg.
Like I said earlier, if we
shipped nothing but StrCat
I would actually be pretty happy.
Questions.
There will be a tip of the week on this.
- [Participant] We're
gonna keep the numbers?
- Yes we are totally keeping the numbers
'cos I don't want to learn
another set of numbers.
StrCat great.
Split, split is magic.
Is Greg here? Greg?
- [Participant] Font size it up.
- Font size it up.
Greg has proposed split
early on for standardization.
It's kind of stalled.
We'll try to restart that because
fundamentally this is the type of thing
that the standard really needs.
It's just usable.
And this is gonna be one of the places
where my read is there's
a little bit of a fight
between the pragmatists and the theorists.
It was a little bit
contentious to get starts
with and ends with into
the API for stringview.
Because you can build those out of find.
It's true, you can
build those out of find.
But it's a pain.
The thing that you want is
starts with and ends with.
You can build split out of
all sorts of primitives.
It's not the fundamental operation,
but this is used a lot, a lot, a lot.
And just having access to it
is a very nice quality of life improvement
for your day to day program.
One of the magics about split is
it will give you back
whatever you ask for.
Not in the order.
(participant talking off mic)
So we just do it in Gramble.
We can just do it in Gramble.
Its not bold at all.
Oh those aren't sorted right?
Let me fix this.
(audience laughing)
StrSplit, you are right, thank you John.
(participant talking off mic)
(audience laughing)
It's the worst.
(audience laughing)
Alright so, we need all
sorts of things don't we?
So the trick, the nice trick.
Also why doesn't this, oh that's fine.
StrSplit, that's a very small window.
Just does what you expect.
(participant talking off mic)
Yeah I suppose I do.
(participant talking off mic)
(audience laughing)
It's been a really long day.
It just does the thing that you want.
One of the things that
is actually interesting
and esoteric, it's not
entirely clear that we made
the right choice but there
is an interesting discussion
to be had here.
When you do the following,
so I have a string (whispers).
This is very nice for absolute string view
in absolute string split view.
(mumbles)
By default, it will convert
to string view for you.
So the side effect of this code,
there are no copies in
any of this except for
copying it to 2C act.
That is actually really deep
and important and powerful.
The other thing, the
thing that's maybe good.
So that's the stupidest
invocation of StrCat.
Oh there we go.
Super stupid invocation of StrCat.
Anyone want to guess what is
sort of funny going on here?
- [Participant] That it works.
- That it works, it is sort of funny.
This almost off the screen
is the invocation of StrCat.
It is returning temporary.
That temporary is then being
rinsed through StrSplit
and then looped over by
reference to the internals.
This obviously should work.
This is the way that we
want all of this to work.
And yet, by normal language
rules the temporary return
by StrCat has died long ago.
So we fixed it.
StrSplit has overloads
specifically for our
value reference for this case,
so that we can lifetime extend that object
so that you can range base loop over it.
On the upside, this means the
code that you want to write
just works.
On the downside, we are
weakening your mental model
for how temporaries and range
based loops interact poorly.
Sorry.
I'm genuinely not sure which
of these is the right answer.
I know which one causes
fewer bugs in the short term.
Don't know which of
these causes fewer bugs
in the long-term, but this is what we did.
There are buckets of little
tweaky things like this
floating around in Abseil.
- [Participant] Can for each
loops be fixed in the standard?
- Can for each loops be
fixed in the standard?
It is a medium priority
of the Google delegation.
I think it is possible,
but as with so many things,
it turns out to be complicated.
So don't know, anyway there
are three minutes left.
Questions.
(participant talking off mic)
What other things do we
have besides strings?
What have you understood John?
(participant talking off mic)
Something that's really like string view
but more general.
John really wants to show span.
John has spent a bunch of work.
We have a span.
It does not quite perfectly
match the current span proposal
because we have questions
as to whether or not the
current span proposal will make it through
in it's current form.
So the Abseil span model
is basically what we expect
span will look like when it ships.
This matches what Marshall wants as far as
the signedness of size.
- [Participant] We'll see.
- We'll see.
(participant talking off mic)
Yes, so yeah there are things like span.
We will try to keep span up to date
with this span proposal.
As the span proposal leaves
all of them at the point
that it actually gets
into something like a TS,
we'll match it more precisely.
Everything about Abseil
is we really want to be
ahead of the game.
We're trying to make this work over time.
Question?
- [Participant] What
does the name Abseil mean
and how did you come up with it?
(audience laughing)
- The internal code name
that started this was
derivative of Google is
splitting into alphabet.
And the first name didn't make any sense.
And when we started to realize
we were about to actually
start renaming and moving code around
we needed to pick a name
that was gonna match
something better.
And so very briefly it was a name
that the legal and finance
departments eventually told us
it was not okay, because
there are trademark things
and it's complicated.
And it turned out that that name was ABCL.
I'm not gonna comment on
the meaning of that acronym,
but if you have a project who
is named ABCL for long enough
you start saying Abseil.
(participant talking off mic)
Or my manager likes to troll
me and he calls is a buckle.
But you start saying Abseil
and then we had to change
it and so we're like
okay we have to change it.
Lets change that C to an S
and just keep pronouncing
it Abseil.
That is literally what happened.
Also basically everything
that's short is already
copyrighted and trademarked
in technology stuff
and that's kind of annoying,
especially when we really
want a short namespace.
So Abseil doesn't really mean anything.
I'm personally amused that
Abseil is the German word
for rappelling, so it is
controlledly going down
on a rope.
There maybe a comparison between that
and writing on an explosion into space.
(audience laughing)
I will leave that to you.
- [Participant] Thank you.
- Any other questions?
- [Participant] You
mentioned tooling with chip
at the five year mark to transition.
- Say that again.
- [Participant] Earlier
you said when you hit
the five year deprecation
point, you will ship tooling
to move people over and
then move the feature.
Would be possible to
get tooling like sooner
so that people who wanted move off camp?
- Yes.
Most of the tooling for
the easy things like
renaming Abseil optional, Stood optional
it may already exist.
It should not be a big deal.
We're trying to ship that soon.
The five year thing in general is
we will support five years
whenever it is possible.
There are exceptions to when
it turned out to be possible.
I just talked about magic statics.
You can't use magic statics
on MSVC before 2015.
So we don't have a five
year compatibility on MSVC.
We hope to build up to a
five year compatibility
before we start deprecating support.
But the target is five years
and it's not a requirement
in either direction,
but it's a general guideline.
- [Participant] Thank you.
- Session is over, any other comments?
Wonderful, thank you all.
(audience applauding)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>