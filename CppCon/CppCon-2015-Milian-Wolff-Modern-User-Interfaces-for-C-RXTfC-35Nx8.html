<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Milian Wolff &quot;Modern User Interfaces for C++” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Milian Wolff &quot;Modern User Interfaces for C++” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Milian Wolff &quot;Modern User Interfaces for C++”</b></h2><h5 class="post__date">2015-10-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RXTfC-35Nx8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay great thanks welcome everyone I'm
good to see you all it's a huge pleasure
for me to be here
I'm million I work for k-dub that's our
logo we are not the cute company we are
the second biggest so to say in the cute
ecosystem I myself am a cute approver I
work with cute now for I think seven
years or so I even maintain a small
module inside cute so um I would say I
have a fair share of knowledge in that
area and I followed CPP Khan and going
native before that the last years from a
home and building some of that even
streamed life into our offices was quite
nice but I always wondered like why is
cute so Ana represented there there
hasn't been a single talk about that at
these conferences to my knowledge and I
mean just a quick show of hands who have
used using cute quite a lot I thought so
I mean cute is being used by thousands
of developers out there and it's a very
very big part of the C++ ecosystem in my
opinion and this talk here is going to
be different from the talks I do usually
it's not going to be very deeply
technical rather it's going to be an
overview of what you can do with cute
why cute is in my opinion really amazing
and fills the gap in C++ so I'll give
you a short introduction of what cute is
and that's probably only going to be
interesting for those of you who are not
using it already then I'll show examples
of how you can create user interfaces
with cute you can use widgets or you can
use the new qml based cue quick API to
do that and finally I want to dive into
the essentials and add-ons because cute
is a huge framework itself and there is
a huge ecosystem around it as well
extending it further adding new features
and filling gaps and then last but not
least I want to
talk about a few misconceptions that I
see again and again from very
knowledgeable C++ people who are
apparently not very knowledgeable about
cute so yeah this is going to be what
I'll be talking about cute um cute is
been around for a long time it's more
than 20 years of innovating what you can
do with C++ many things it does by using
for example code generators we'll get to
that later it does stuff that you cannot
do with normal C++ in many areas
thousands if not dozens of thousands of
people use a day-in day-out for their
job we do that we see our customers
doing that as a consultancy company we
get called in and see the wealth of
projects that use cute it's very
astonishing in my opinion to see how
well it works most of the time but sadly
it's very underrepresented at many C++
conferences cute is cross-platform
whatever I'll show you here you can do
in all kinds of platforms you can run it
on the different flavors of Windows even
compact about it if you like to do that
you can run it on the Macs various Linux
flavors especially interesting for
embedded platforms in my opinion
real-time operating systems I mean those
of you who flew here with some come with
a new machine it quite possibly the
infotainment system is using cute
already or it's cars that are getting
developed and they will get new
infotainment systems based on QNX
or something else using heute and on the
desktop platforms and phone platforms
you get a native look and feel it's not
pixel perfect but it's getting really
close and fulfills its role very very
well and the thing here is that queued
has at its core at
platform abstraction layer that scales
really well otherwise this wouldn't have
been possible and we see more more
platforms being added and it works
that's very nice
so personally this is very biased why do
I like cute why do I stand here
motivated to talk to you about this I'm
kind of passionate about it but first
and foremost I like you because it's C++
everyone who keeps saying cuties in C++
I quite frankly can't get it because
it's very much C++ it's dozens of lines
of it and it really helps in writing
efficient code if it wouldn't be C++ I
would probably not use it then the thing
that we at Kade up here especially when
we do trainings and see new people
learning cute while we teach it to them
is that they say again and again the
cute is very simple the API is
consistent it's very straightforward to
get into it there is no high entry
barrier or anything like that and this
is in my opinion very important for
library to be used by many people then
there is the open governance model which
I as a open-source guy am very
passionate about as well in my free time
I work a lot on the KDE project and if
cute wouldn't be open-source wouldn't
allow open-source projects to use it
such as cute Kady I wouldn't have
learned it in the first place this was
what drove me to using it and seeing
okay this is actually very very cool
tool set and the open governance model
does not only mean it's open source but
also that everyone has a voice I can go
in make a change I can discuss with the
maintainer of cute core why something
should be done one way or another
there's no one company that says okay
this is how we are going to do it and
they do it it's very important in my
opinion and as I said already cute is
highly versatile you can use it on the
desktop you can use it for embedded
platforms phones whatever and
the people in the cute ecosystem or
community are very practical and
personally I like that I studied physics
it was very theoretical in the end I
decided that this isn't really not
something for me I rather work on
something as practical in a sense of I
want to get stuff done instead of
arguing about the theoretical best way
it could possibly be done but then no
one was ever going to do it right so
this is something I really like there
are lots of things I do not like about
cute it's it's a big project I mean it's
very unlikely that it's perfect in every
aspect definitely not the three points I
want to highlight here is first and
foremost the coat like legacy then cute
I mean it's 20 years old right there are
places in the cute API where this really
really shows the biggest example here is
exceptions cute does not use exceptions
itself you can use as a user of cute
your exceptions that's fine and we'll
handle that but internally it decided
not to use exceptions because of the
fact that back then I don't know 15
years ago seventeen years ago they
decided to support platforms where the
compiler was not able to handle
exceptions so they limited themselves by
saying okay we want to support this
platform and now 20 years later we still
pay the price in that aspect and there
are other cases where this is happening
there are a few performance traps in the
cute API I said it's very simple to use
it that's true especially if you look at
the containers I'll get to the
containers later but they have lots of
utility functions and you use them and
you think like oh yeah my code is so
nice it looks so awesome but actually
it's going to be very badly performing
compared to STL code where you are
explicit when you shoot yourself in the
foot and then the biggest issue I see
right now in the cute
immunity is that there is simply no
interaction or very little interaction
with the ongoing efforts of advancing
C++ as a language so no one is actually
being funded to go to the ISO CPP
meetings and helping that out and I
really do hope that the companies are
going to send people there and improving
that situation and also on the other
hand do hope that people from the ISOs
EPP community look at what we have in
cute instead of reinventing the wheel in
some aspects or at least to see what is
needed by a real-world project to solve
problems so while dislike these things I
can actually understand and accept them
their fact and I hope they will get
resolved eventually but it's not as bad
for me personally as you might think
so with that short introduction done
let's talk about widgets this talk is
going to be at this part the next two
sections is going to show you nice
images mostly of what you can do with
C++ a cute C++ the first part the
widgets is what has been around for here
20 years now it's very old technology
that kept evolving over the years but
it's definitely not dead this picture
here is K mail my personal sorry for
that that's my personal email client of
choice and I picked it not because it's
such an awesome email client which is
this in my opinion but rather because
it's very exemplar Tory for widget
applications these kind of you is you
still see and you will still see in 10
years I'm pretty sure in house
applications for example in financial
companies or for logistics or anything
very specific to a problem you need to
solve where you show lots of data like
here I mean you have tons of views you
feed with models you have trees you can
filter them you can search them it's
always lots and lots of data and cute
widget is perfect for that kind of
application what you also see is text
handling in curious very good and it's
very good at adapting to the locale and
internationalization of whatever the
users doing for example if you would get
a email from an person who can write
Arabian then right-to-left text is just
there you don't need to handle anything
especially there in your application I
really like that or you could even
display HTML content if you have to or
want to even but widget applications can
also look very different this is an
example I quite like because it's the
Spotify Linux client which is still cute
for bass but it looks super different
right it's still a cute widget if your
application as fast enough I couldn't
look into the source but if you just run
ldd on it you'll see what it links to
and again what we see are lists that you
can filter this probably again is fed by
a model and then you have a special view
on top of that and they just changed the
visuals and that shows how even cute
widgets can adapt to whatever you want
to display right then the last picture I
want to show is again project out of the
KDE community its critter the yeah I
don't know whether they actually started
right out by saying we want to kill
Photoshop they then decided to okay
that's not going to work Photoshop can
do lots and lots of things we cannot
compete with that so instead let's
concentrate on a very specific part on
the visual artist that draws so a
painting application it's not the in
German we say il a avoid me so that the
thing that can do everything from
generating HTML for your website to
whatever else Photoshop can do nowadays
but rather it's meant for painters and
it's very very good at that and more and
more people are starting to adapt
adapted in their professional companies
even and the thing is it's again acute
widget application there is the Open GL
accelerated canvas here making it very
efficient it's very nicely integrating
with the graphics tablets you have
custom widgets here for selecting
brushes and things like that and all of
that is quite straightforward to do with
cute so how do you actually use it I
mean the best way to do it in my opinion
is you use or you start off by using the
designer tool cuties on here it's shown
embedded in cute creator the cute sdk
let me put that straight cute creator
it's cool if you want to use it use it
but you don't have to use it if you use
cute personally in my spare time I
maintain the K develop API ID so I don't
use cute creator at all and I know many
people use Visual Studio that's fine or
Eclipse again that's fine you don't
bound to that right and with the
designer which you can also run a
sustained alone application you just
click together how your dialog is
supposed to look like and not only does
that work really well compared to what I
heard from other people using different
design applications for their framework
of choice also the things it creates
that the dialogs they actually are very
functional in a sense you can resize
them easily and these kind of small
things and it's still going to look good
so it's super easy to use this tool and
it works super well in my opinion on the
C++ side we see the first use of a code
generator in the cute field you include
a generated header file which has the
knowledge about how your dialog is
supposed to look like and then you say
I set up and do something I didn't show
I don't show the header here but mu I is
essentially a smartphone uh you could
use make new here or whatever make
unique I mean that's very easily doable
and then your UI is the view part right
and then you have a model somewhere data
so you create that one and then just
maybe put a proxy in between fulfill
Turing purposes or maybe you want to
sort stuff it's very nicely separated
all of that and then you connect some
signals and slots again very typical for
cute by the way this is how you write
signals and slots today and cute
whenever you think or hear people saying
yeah signals and slots are so
inefficient lots of string comparisons
that's cute four or three or whatever
deads archaic you don't do that anymore
in cute five cute five signal slots
connections accept any color ball you
can pass in lambdas you can pass in
Rossie functions do it and you don't
even need most of the craft that you
needed in cute for anymore nowadays with
modern cute this example I just showed
it was a bit streamed down but
essentially here is an example of how it
could look like in the end this is from
my heap Trek UI it's in my spare time
also work on a profiler which I'll do a
lightning talk about I think tomorrow
and it took me maybe I don't know let's
say one hour to write the model probably
less and then five minutes to click
together the UI and it's fully
functional and works very well and I
don't know any other C++ UI framework
that lost this kind of functionality
with such simplicity of use and most of
them don't even provide you with any
reusable widgets in the first place and
remember this works then on Windows on
Mac on wherever you compile it right so
cute widgets it's a
very proven technology it's been around
for 20 years as I said and it's super
for desktop applications these kind of
in-house things or rich clients or
whatever you you name it where you
present lots of data sorry it's not
going sorry um it's not going to die die
and it allows you to create contemporary
if not even modern UI for your code so
with that said let's get to the second
part or third part Q quick I said Q
widget has been around for a long time
and over the process of working on that
the cute people realized that there are
some problems that you cannot easily
solve with the existing API
the biggest problem there is getting
something that is hardware accelerated
cute widgets it's using of course you
CPU sim de structures and whatever to
make it as fast as possible but it won't
actually use your graphics card for
example to offload stuff it's super
inefficient hard to get fluid animated
interfaces with the widgets API so cute
quick is originally it was developed in
the Nokia de so that's where most of the
work happened and cute when it trolltech
was bought by Nokia undated wanted to
put that technology onto the Nokia
phones I actually don't know whether
they ever did that or if there ever was
a Nokia phone that used cute quick
maybe the n9 m but what we do know is
that these three phones are out there in
the market right now from left to right
it's the sailfish OS running on a Ola
phone it's a blackberry Passport running
the BlackBerry 10 OS and Ubuntu phone
all of them use cute quick to latest
cute v based IQ ml for their fluid
interfaces it's nicely touch enabled
it's hardware accelerated
sadly none of these three platforms is
really successful I don't personally
think it's the fault of cute but rather
the big contenders out out there I use a
blackberry as well I'm very happy with
it
from the fluidity a point of view so I
really think that cute quick is perfect
for these kinda applications you can run
it also on existing mobile platforms
here it's this is Midland Valley's field
move application it's meant for
geologists to be used on the field to do
whatever geologists do and you can see
that this kind of touch enabled fancy UI
is actually also usable to get real work
done it works on iOS and I think it
might also work on Android and I'm not
too acquainted with that but it's a nice
example of what you can do with it and
then this is a screenshot that the cute
company puts into their marketing
material and I quite like it because it
shows you the different form factors and
platforms that you can put on your put
your application on and here I
explicitly took it because of these
things like embedded platforms with a
display it's becoming more and more
common because it's so cheap nowadays to
buy a touchscreen and you can hook it up
to your industrial oven or something
like that and having visually pleasing
UI with the logic in C++ behind it on
the desktop it's still oh it's becoming
more more used as well you can use the
so-called components to construct
something which looks similar to widget
applications here I show the plasma
desktop from KDE so it's very common to
see that on Linux or beast machines and
this is again built on qm q ml 2 or q
quick 2 on q ml and they are now working
on pushing it to mobile phones as well
showing how easy it is to adapt from one
form factor to another
a very different use case but something
that many people need is that you have
your existing 3d content rendered in
OpenGL for example and you need to put
text on top all you need to put controls
on top qlq quick makes that super simple
and the same is valid for multimedia
content so you can put shader effects on
the hardware accelerated multimedia
stream you get and this is going to
perform quite well even on embedded
platforms the thing is when you write
these kind of cue quick you eyes it's
not C++ you write on the representation
side
this is QML it's a declarative language
you state what should happen instead of
how it should happen it's very easy to
get into you simply bind properties to
another like here the X properties or
where the button is positioned on the
left side it's bound to the checked
property and if I would check that
button it would flip from left to right
this is what this binding does here and
it's super cool then to add an animation
for that as well and if you do these
kind of things in C++ it's certainly
doable it's not going to win any price
on readability I'm pretty sure I do hope
that people come up with parents on on
what to do there right now the practical
aspect of cute solved it by introducing
this language with this which is
actually not that bad but you must not
make the error of saying okay qml and
javascript will replace all of c++ that
is not the case at all
you quick is meant to provide you with a
declarative language which you then use
for saying how something should work it
provides you with a hardware accelerated
scene
which is super efficient and very nice
to use and makes it super easy to create
fancy anime to do ice and thus thereby
making it cool to use it on embedded
devices or for OpenGL / lessons and
whatnot but it's meant to be used for
the representation only let me stress
this point again put your data put your
logic into C++ educator the companies
that come to us that have problems with
qml applications they always or not
always but often make the mistake of
putting too much into QML it's a the
same issue you can have on C++ widgets
application right you put all your view
logic in all of your data into the
widgets instead of separating between
data and presentation it's a very bad
mistake don't do it only use cue quick
for the representation side use C++ for
the obvious reasons for logic and data
and do keep your JavaScript to a minimum
it will kill performance it will make it
harder to find bugs and fix them and all
of the problems you have with JavaScript
so with that said I want to come to the
essential section because yes cutest
first and foremost meant to be used for
UI
it's a UI to code after after all but
cute is so much more than that if you
start using cute and you realize that oh
wait I need to connect to a sequel
database and I need to access the data
in their cute office you an API that is
cross-platform and gets the job done you
have access to a date/time API which
also comes with support for time zones
something that I think there are going
to be more talks on at CPE Khan here
very hard problem to get right here's
one solution that's being used in many
places already
more or less satisfactory I mentioned
already before that cute supports very
well accessibility and localization so
you can sort stuff based on the locale
of your user you can format numbers the
way he wants it to have it you can add
accessibility such that blind people can
operate your user interface so you can
hook it up to screen readers you have
Unicode strings pervasively throughout
the cute api the in famous cue string
yes it's not stood string it has no
short string optimizations there are
many things that may be wrong with it
but from a practical point of view it
gets the job done really really well
it's super optimized for what it does
utf-16 representation of strings so
similar to what ICU uses internally or
what windows uses for strings or java
does the same and these strings have the
string class has a very good api as well
but talking about misconceptions people
think that as soon as they start using
cute they have to use cue string
everywhere that's not the case only use
it where you want to feed or show data
to the user at that point you care about
unicode data anywhere else for example
if you parse raw let in one string so
something like that from this do use
either stood string or queue by the
radio anything else cue string is only
meant to be used for putting data or
showing data to the user in the end
there are the signals and slots in cute
which are in my opinion really well done
they come with a minimal amount of
overhead if at all thanks to the code
generator you can add things and slots
later on while keeping binary
compatibility which is also extremely
cool there is a any type wrapper like
boost any called cue variant
if you need that it's there you can get
file system access that's similar to
what hopefully we'll get an stl sooner
or later you get asynchronous i/o
networking these kind of things you can
even use state machines where by the way
um the C++ API for state machines sucks
it's so hard to write all the
boilerplate code I'm not sure whether
any one of you had the pleasure of
working with the C++ state machine
library it's really really bad the comp
colleague of mine spend time on adding
qml bindings for the state machine code
and cute and suddenly you realize that
oh right this is what you actually want
to write and this is something we see
more and more that people use QML the
language so not the cute quick graphical
part of it but rather just that the
language itself as domain-specific
language for whatever you need in your
application and there's API to do just
that so if you need if you look at the
language and say oh this is actually
nice I want to use it for I don't know
my build system people in cute have done
that for some reason or what else is
there I don't know
yeah state machines is the obvious
example think UML is really cool and you
should have a look at that it makes it
much easier to maintain your code as
well compared to writing all the crafts
in C++ so um this is Q core or was Q
core this is still cute core but also a
few external modules they're cute itself
is separated into multiple libraries so
you don't have to use or pay the price
of shipping megabytes of megabytes if
you don't and use all of that but again
all of this works on various platforms
right it's if you start using it on one
platform you can be sure that uh later
on someone demands a Mac version of your
application it will work so especially
here I want to stress that you
use it to access services via Bluetooth
you have support for near field
communication I showed the example for
multimedia integration already you have
perverse of support for printing and
things like that it's very helpful and
all of these are things that many people
don't realize you need in a graphical
application because oftentimes when you
create an application after I don't know
a few weeks someone says like ok it
would be cool if you could hook up I
don't know generate me a PDF report for
the data I see on my UI right if you
would then need to start looking for a
separate library that does the job then
you need to figure out how to integrate
it with the rest of your code with cute
that's super simple because many many
features are there already were like
inside cute itself or they are being
provided by external provides yeah KDE
again I'm connected to that I care about
it and they spent a lot of time in the
progression from cute 4 to cute 5 to
upstream the various features they found
were missing in cute
they had it back then in KDE lips it was
called and they upstream a tremendous
amount of work into queued itself so now
if you need for example temporary files
or directories and things like that it's
their log files standard path access and
whatnot it's in queued proper some
things are still separate and the
so-called KD frameworks is a collection
of these tools each one of these bullet
points here is a more or less individual
library and you can use them for example
to access zip files or tau bolts or
something like that there's a very nice
cute API for compressed il called K
archive you have a collection of high
quality proxy models that do for example
recursive searching in a tree model I
feel free to use that it's all open
source it's high-quality test
for years and peer-reviewed and whatnot
so I think in an abstract I said
something like KDE is for Q what boost
is for STL I think that's really the
case
KD is where the innovation takes place
and then it gets upstream in the long
run to acute problem then there is
include org it's founded by Canelo
Schumacher also from KD Fame and it's
meant to give you a central website
where you can go to if you're looking
for anything that's missing in cute at
the moment it lists 184 cute libraries
that solve various problems and it makes
it very easy to install them so it shows
you the library where to the license
were to get it even a ruby tool to
install stuff the command line and
update it and stuff like that so again
if you use cute do have a look here if
you ever find anything that's missing
okay so this was the overview of what
you can do with cute there's a lot I
left out tremendous parts there but I
felt it was important first to establish
the baseline before going into the
misconceptions I will talk about these
four points here code generators
containers C++ 11 or XY whatever didn't
latest and greatest is and then in the
end the development process of queued
itself so let's start off with cute
generate a code generators not cute
generators people keep complaining about
mock the metal object compared people
even decide to fork an ancient version
of cute to replace mock for some reason
the thing is Marcus just one of many
code generators being used in cute and
the others are the UI compiler I showed
that for generating dialogue layouts and
things and the last one is the resource
compiler both of them are never going to
be replaced by C++ code I doubt
that someone will start adding the
ability to parse and read files from the
disk and generate code from that because
this is what you do here right the
resource compiler takes for example
image files and compresses them if
needed and puts them as binary data
directly into your executable making it
super simple to deploy your code
anywhere right you don't need to send
the full folder with hundreds of images
it's just going to be one executable
that's going to work everywhere
so the code generators are meant to
improve the productivity of you as a
developer
they really simplify code maintenance
especially UI compiler in KDE or even in
customer code I've seen it k-dub there's
still old code that uses the manual C++
way of setting up a layout and it's such
a hassle to update that whenever you
need to like ok how does this actually
look like you have to figure it out by
just reading the code I don't work that
way I want to like if I want to change
something visual super cool to actually
see it and then change for example the
order of widgets or adding margins and
padding's and whatever and the code
generators are there to overcome
limitations in the C++ language some of
them hopefully will get resolved
especially for mock overtime but others
like UIC or RCC I don't ever see C++
fixing that and also let me stress
something here
yes Q does use code generators as does
many many other people's people or
companies out there that maybe not use
cute a very good example here is the
keynote from Mike Acton from last year's
CPP con he said that the games community
at large uses many code generators in
various places for efficiency reasons
mostly or just to make writing code less
mundane you can do it in C++ often time
but that would mean repetitive code or
very ugly macro based code bases
so let's talk oh yeah before I continue
going in-depth with mark
I want to say something that also many
people don't get for some reason these
tools all of them that cute chips are
very well integrated into various build
tool chains better integrated than many
other code generators like I don't know
yak or bezel on or something like that
you make obviously has NATO some more
support for it but don't use cumec quite
frankly it's it gets through a job done
but in my opinion see make is a much
superior build system and that one as
well has native support for auto mark
and running RCC and UIC transparently
it's it's super easy to get done there
is even a add-in for Visual Studio if
you use that so you just run build and
it will do its job it's not hard to
integrate these tools into your tool
chain at all so let's talk about mark um
people think that the so called meta
object compiler is mostly used for
signals and slots it was definitely one
of the main reasons back then but
nowadays in modern q5 that's not the
case anymore I mean sure you need it for
signals that's true but for slots you
don't need it at all oftentimes you
don't even have slots anymore you just
add a lambda and use the new signal slot
connection syntax right but rather today
in cute 5 you use it for reflection I
mean this is an implementation of
reflection you can use in C++ today I do
hope that the work in an ISO cpp
standard is going to extend what you can
do with C++ so we can replace more and
more of what mocked us by something that
C++ offers you natively but the last
time that Olevia go far the maintainer
of mark looked at the standards papers
they didn't he wasn't able to replace
mock completely yet there's a very nice
block entry written by him on the matter
if you're interested in the lies
on that and the queue meta object the
reflection is also the basis in the cute
world for wealth of features like IPC
mechanisms or language bindings so qml
of course is the obvious part here for
the properties and property bindings
it's essential to have the features that
Mark gives you but it's also being used
pervasively for Debose for web channel
the module that I personally maintain
with which you can transparently call
queue object based C++ code from
JavaScript running potentially inside
cute WebKit or cute web engine view but
also works with nodejs or anything else
and then there's a project spearheaded
by Ford
we're also colleagues of mine working
for helping them bringing it to
fulfillment is the remote objects module
which is IPC on a type safe level across
C++ it's also very interesting project
there so I said it already new signals
lots you don't need to create the
overhead of a queue object just to get
the slot to then maybe run something in
a delayed manner like here with cute v
you just use Atlanta this is how you
should use it there's no string
comparison here nothing it's type
checked at compile time like questions
yes yes even the question was whether
this was even across threats yes it does
work across threats what you need for
threats is just a declaration that the
parameters you pass over that they are
declared in Kanaka can be accepted
encapsulated and moved across threats
but this is the same for the old signals
loading syntax so this is not related
here at all so this is really what you
should use everywhere and then let's
talk a bit about
efficiency mark has been around for 20
years and I know that copper's biased is
in famous new fork of the ancient cute
4:8 version is not as old I don't want
to say the code date road is really
really bad but I just want to highlight
here something that they probably do not
take into account and that people in
queued have taken into account for 20
years now the code you generate with the
code generator can be optimized really
really well to the sense that the code
it generates is shared across different
applications and it is very minimal
it can only emit the code it's actually
needing so you can see here that the
text and data sizes of the different
library so this is cute for where cute
GUI was still one monolithic block and
then the second bar is for cute GUI and
cute widgets in cute five where it was
separated into two I took both into
account here and then you have copper
spice UI library so something that is
relating to cute GUI in four eight so
you can see the overhead is nearly twice
as large
if you dissect the binaries and look at
where this comes from
it's just signals and slots or they
implementation thereof it has a huge
overhead also when it comes to
relocations which really really kills
your startup speed for embedded
platforms so as soon as you try to
replace mark for the sake of replacing
it please at least think about the
impact that's going to have especially
when it comes to the efficiency okay
the next misconception I hear again and
again from people trying out cute that
you have to use the cute containers
don't there are many of them if we use
them do understand implicit sharing to
copy and write pattern that cute
implements you can write super efficient
code when you leverage that properly but
it's not a magic bullet you have to
actually understand how to use it right
if you do use them on
use q vector and q hash by default and
the rest only if you really find the hot
spot that you profiler shows you I never
had that case so really do not use Q
list except if you have to interact with
existing cute API that uses Q list
it's a pity again code legacy but in
your own data models for example it's
super fine to use STL containers or
boost containers they're very good and
probably many parts even better than the
cute counterparts there are the cases
where the cute containers are better but
only use them when you want to use them
there's no reason you have to use them
then C++ 11 and cubed people keep saying
that Oh cute is so old because you
cannot use a modern C++ with that this
is not true it is true that up to 5.6
the people working on cute inside cute
libraries are not allowed to use C++ 11
or not rely upon that but they do
optionally enable a ton of features
there like constant expert default
deleted r-value references no accept
null pointer whatever to improve the
quality and the performance of the
library today with 5.7 finally we can
actually depend on a modern C++ in a
little 11 enabled compiler to then use
it inside cube for example this is going
to be used to replace the handwritten
assembly code for Atomics in cute and we
will instead use STL counterparts there
which is reducing the maintenance effort
and ourside better integration with
existing tools and whatnot so this is
really something I look forward to but
it is something for me as a cute
developer looking forward to you as a
user of queued on an application side
you can use the latest and greatest
these plus plus features now today and
it's going to work and then last but not
least I want to mention the development
process because there again many people
don't quite get it
open governance I mentioned that already
everyone can chime in everyone can add
features or improve code it's open
source but it's licensed it's dual
license so you get the LGPL GPL codes or
alternatively a commercial license when
should you use one or the other that's
your decision in my opinion as a company
who invests money in a product and wants
to make sure that it's available for the
next coming what 10 years or so you
should have an intention to actually
fund third further EQ development by
buying licenses from the cute company
again not k-dub but you can go through
us but it's not the thing right you want
to make sure cute thrives and continues
to develop and that's why you should buy
licenses and there's one thing in queue
which really stands out to me as
exceptional that's the KDE free cube
foundation it's been established years
ago by the original founders of politic
and they decided to make sure that no
one can ever take the intellectual
property of cute and kill it you cannot
buy it and then just shove it onto the
under the earth right this KT free cute
foundation literally says that if new
features get developed and our if the
existing code gets changed without
releasing it for one year then
automatically all of the intellectual
property and the rights there to go over
to Katie evey there's a misconception
people think that automatically all of Q
becomes beast licensed that's not the
case KDE V the nonprofit organization
that runs KDE things gets the right to
then decide what to do with it it can
for example release it as beast but it
could also say no let's create a
consortium of companies in the field who
are then maybe even allowed to do again
sell licenses under a dual license model
right don't mix that up and by the way
this is also one of the main reasons for
the CLA you have to sign when you
contribute to cute that's for the sole
purpose of being able to rely since as
needed as the KDE evie decides to and
with that I come to end there are any
questions please the question was
whether what the task based threading is
I mentioned on the KT slide here that
one that's the threat weaver library in
KT frameworks it's my opinion far
superior to what you get from cute
concurrent or even plain stood a sink if
you are interested interested in there
to check it out its high quality I like
it a lot
yes I noticed a lot of gap in many
places and accessibility think of
accessibility is like wine they don't
include colorblind or presbyopia or
photosensitivity
in the thing and what's the things they
worry about so there's there's no fill
of that gap what does he do and that
quite frankly the question was regarding
accessibility which is mentioned here
whether cute except for caring for blind
people also takes into account color
blindness and other yeah issues I quite
frankly can't answer that because I have
not worked with the that yet but if you
have any questions to their do contact
federal at one he is the maintainer of
the accessibility stack in cute and he
cares very deeply about that so probably
there are ways to get it done I know
that in the KDE community which is very
large and it's being used by many many
people they are
people that have these kind of issues so
I don't know what they do there but I
wouldn't be surprised if there's a
solution to it but I can't tell you what
it is
sorry more questions okay the question
is when we talk about cute quick that
it's what here huemul and javascript and
whether cute has the dependency on
javascript right that was the question
first let me put this straight you can
use javascript in qml doesn't mean you
should
and for some places it's very handy to
do so but you should keep it to a
minimum and this is optional and you can
for example use the cute script module
it's again a separate module to get
language bindings to JavaScript or use
qml engine as a JavaScript engine to get
language bindings you can do that but
you don't have to in cute widgets for
example you don't get any JavaScript at
all does this answer your question okay
thanks
the question is whether you can use qml
with just C++ yes I mean in the sense of
you still write kml right this is not
C++ and then all the rest the data and
the logic is on C++ set this is the
ideal case in my opinion quite often you
will cut corners because it's just so
much simpler to write one line of
JavaScript instead of creating a C++
function and then calling back and forth
but most of the time yes you write the
magnitude of code in logic in C++ and
use qml just for the representation
the question is what the output of the
qml thing is it's actually a virtual
machine machine so to say like by
default it will produce binary
code and then run that it's very
efficient they spend a lot of effort in
making it as fast as possible for this
use case and it's very good at it
there's also a commercial qml compiler
it's a code to code transformer so it
takes the Comal code and translates that
into c++ which is then compiled by your
compiler running all its optimizations
on it and thereby creating even faster
code with even less overhead and there's
a sorry but qml compiler from the cute
company and regarding the how to
interact with qml and cute the
documentation that Q has is very good
you should have a look at that and they
have lots of chapters on just that part
like how to get data from C++ to qml and
vice versa and there's support for that
fair okay yes the question is about the
Android support and whether the gap is
reducing and what you can do on android
compared to what you can do in other
platforms especially widgets have been
mentioned with OpenGL content I am again
not the expert my colleague böck done
would be the best person to ask there
I'm pretty sure there has been a blog
post maybe a few months ago and just
that matter if I'm not mistaken on our
website CARICOM slash block I think me
and my colleagues put technical blocks
there and he definitely had a very long
series about Android and cute and
I think he mentioned something there but
again do content him directly or come to
me afterwards and I'll get you the
contact details does this answer your
question
oh sorry the question is how to figure
out whether buck is fixed if you find it
in 5.4 5.6 the answer is you look into
the bug tracker there's it's open right
it's you just either report the buck you
find and then someone will try it out
and say okay
actually this is a duplicate this is
here the main park and it's been fixed
already alternatively you can go into
Garrett or just get check out the latest
and greatest and see whether the code
has changed personally I really like
this about cute it's open right you can
actually look into what it is doing and
if something goes wrong you go in there
and either fix it yourself and submit a
submit a patch or you check upstream
whether it's been fixed already maybe
you can even back port they fix then if
you want to so yeah I would start with
the the bug tracker if you use IRC
there's also cute labs channel on or the
cute channel on freenode where you can
ask these kind of questions and people
will help you out Stack Overflow is very
active community there there are lots of
mailing lists as well where people will
help you out if you have any question
there this is your channels and how to
get in touch with us does this answer
your question yeah okay show me one part
of the UI and then I have to go further
to see the second part in that same code
that's the desktop show all of it
that let me repeat the question as I got
it and whether acute quick and qml
supports storybuilder to adapt to
different form factors in a sense that
one screens only shown on a small
display whereas multiple screens or
content biases shown on the desktop for
example if you mean with storybuilder
some graphical application then no
people from the automotive industry are
investing money in improving cute
tooling around these kind of things as
far as I know but it's possible today to
write qml code which automatically
adapts to different form factors there's
very good support for that for example
to load different images based on the
DPI or whatever to change the layout you
can even here for example this kind of
code could be a so-called component
which you use in different files and you
can load these components based on the
DPI or resolution of your device right
so you could have one component for a
small form-factor in one component with
slightly different code for larger
screen and because it's so simple to
write that it's actually working very
well so does this answer your question
ok so with that I have to come to an end
thanks for attending</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>