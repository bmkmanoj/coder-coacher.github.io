<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Steve Carroll &amp; Daniel Moth “Latest &amp; Greatest in Visual Studio for C++ developers” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Steve Carroll &amp; Daniel Moth “Latest &amp; Greatest in Visual Studio for C++ developers” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Steve Carroll &amp; Daniel Moth “Latest &amp; Greatest in Visual Studio for C++ developers”</b></h2><h5 class="post__date">2017-10-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jsdn3kXFVdA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">- Hello everyone, and welcome
to this Visual Studio for C
Plus Plus; developers' session.
Thank you for choosing to
spend your time with us.
My name is Daniel Moth,
and Steve Carrol is gonna be joining me
for some cool demos later on.
Before I move on, you guys should realize
that this is the most important slide.
That's because Steve and I manage
the C Plus Plus product team.
So if you have any feedback
with the direction we're going,
our emails are up there.
Even if it's just praise
to say how well we're doing
and that you love
everything that's going on,
you can email us at
Daniel.moth@microsoft.com.
If you have abuse, criticism,
bugs, you wanna throw stuff,
email us at steve.carrol@microsoft.com.
That's how we split the responsibilities.
I get the praise, he gets the complaints.
Seriously, this is the
most important slide.
You should write down the
URL that's on the slide.
That' our blog address.
Everything that is going to
be in the rest of the talk;
URLs, content, and so
on are in these slides,
and were gonna upload to that
blog at the end of the day.
You don't need to write down
anything during the talk,
you just need that one URL
and you're set, you're golden.
Very important; take that down now.
Over the weekend, we added to our blog
our annual C Plus Plus developer survey.
I wanted to repeat that here,
so please go to aka.ms/cppcon
and take the developer survey.
If you do that, you will
have a chance to win this;
what's on the slide right now,
which is the Xbox One S bundle with games.
We're gonna actually physically
give that out on Friday
to the lucky winner over here.
Even if you don't want the
Xbox for whatever reason,
maybe you got too many
at home, I don't know;
please do take the survey,
'cause it does help us
influence the direction
of where we're taking things,
which is better for you.
Even if you're not using our products,
help others by giving us your feedback.
It's worth it, so please do that.
The other thing I wanted to
do before we get into the talk
is share a bit about
our mission on our team.
Like I said,
we're in the C Plus Plus
program team at Microsoft.
We're in a group called
the Developer Division,
or DevDiV for short, which
is all about developers.
That's all this group does.
Specifically, our goal
is to improve the lives
of every C Plus Plus developer out there.
Not everything that we do is applicable
to every C Plus Plus
developer, but a lot of it is,
so we stand by that broadly scoped goal.
The way that we try to do
that is by various ways.
One way is by
enthusiastically participating
in the C Plus Plus standard
to improve the language itself
for every developer in the world.
That's one thing.
Another thing we do, of course,
is shape and improve as much as we can
the visual C Plus Plus
compiler and libraries tool set, so MSVC.
Our goal with that is for
it to be the best choice
on Windows for targeting Windows.
The other one that you'll be familiar with
is the Visual Studio IDE,
the Integrated Development Environment.
Our goal there is to have
the best IDE on Windows
for targeting any platform.
Finally, we continue to
improve Visual Studio Code
and the C Plus Plus extension
to Visual Studio Code,
which is applicable to all developers
as it runs on all platforms.
These are four of the
areas where we invest
a lot of our energy towards our mission.
We're not gonna talk on this talk
about the first point any more,
about the C Plus Plus Standards.
I'm sure many of you know that
we send around eight people
at each one of the three meetings
that happen every year
as part of the standards.
We actually review proposals,
participate in proposals,
we lead proposal ourself.
Not to be underestimated,
we actually validate early
versions of proposals
with our compiler so the end result can be
better for everyone,
both in the compiler and the
libraries space, in fact.
We're not gonna talk about that.
Instead, what we're gonna focus
on here are the middle two.
Before we go and focus on the middle two,
I wanted to just touch on
the last one for those of you
that don't know about it;
which is Visual Studio Code.
Visual Studio Code is not an IDE.
It's not an Integrated
Development Environment,
it's an editor.
It's a fully featured editor.
It has source control integration,
it has debugging support,
it has extensibility,
and it's cross-platform.
It runs on Linux, Mac OS, and Windows.
If, for whatever reason,
you don't want to use Visual Studio,
can't use Visual Studio and
your upbringing is more like
VIM, or Sublime, or Emok,
something like that,
then this is the tool you wanna check out.
If you wanna learn a lot more about this,
we have a talk here at CppCon,
so you should catch the recording of that
when it goes online.
The reason I say you should
catch the recording is because
it's taking place right now,
and you cannot be in two
places at the same time.
So stay here, you don't have to go there.
You can catch the recording
when it goes online
later, that Ron Liu is giving.
That's Visual Studio Code.
So how are we gonna
spend our time in here?
We've structured this talk into two parts.
In the first part we're
gonna focus on MSVC,
the compiler and libraries toolset.
We kinda treat that as its own product,
'cause you could absolutely be using
that on its own without ever
going near Visual Studio.
The second part's gonna
be about Visual Studio,
which many people use in
conjunction with a compiler.
But you can actually use Visual Studio
with any compiler that you like.
So it's a separate thing.
In terms of what we're gonna talk about,
you can see on the
slide the kind of things
that we're gonna drill into.
But you should know that the
first part is kind of short.
Shorter, I should say,
than the second part;
and it's all slides.
Then on the second part,
there's gonna be mostly demos.
So that's kind of like what
we're gonna go through.
Just a quick question as we
dive into the first thing.
How many people in here use
for one of the C Plus Plus
code bases the MSVC, our own compiler.
Can I see a show of hands?
Is that everybody?
Try and see...maybe try
the other way around.
Who isn't using it?
Show of hands.
Okay, so you guys are here
to do competitive analysis.
I get it, that's fine.
We'll talk about it.
For those of you that do use it,
I'm sure you want to know how we're doing
against the top priority
for the MSVC compiler team,
which is conformance to
the C Plus Plus standard.
We're not going to go
into any of the features on this slide.
All we're gonna do is use it
in order to report progress;
how we're tracking against it.
So all that white text that
you see in the blue boxes
are all things that we completed as of
the Visual Studio 2017 RTM
release in March or earlier.
With that we'll be seeing
in March we delivered
on our promise to be conformant
with all the new features
introduced by C Plus Plus
11 and C Plus Plus 14
as the check marks
indicate up on the slide.
Since that RTM release of
the compiler Visual Studio
in March, we shipped 15.1,
15.2, and in August we shipped
15.3; the version 15.3
of Visual Studio 2017.
With that, even more conformance
came out with ones that
are in the yellow boxes.
If some of you are on Visual Studio 2015,
that's a whole bunch of conformance
that you are missing out by
not using our latest compiler.
That should be incentive for you to move.
AT the moment, we have
15.4 preview is out.
In November, we're gonna have 15.5.
With that release of 15.5 in November,
we'll actually have even
ore conformance implemented,
as the purple boxes are showing.
Notice that on this slide,
they don't have C Plus Plus 98 (mumbles)
but there is one feature
in there that many of you
I know care about, and I'm
seeing nods about it already;
which is the two-phase name lookup.
I'm delighted to share here
that with that release,
we're actually tackling that as well.
This is part of our rejuvenation effort
for our compiler code base,
which is a very mature code base,
so by introducing the ST based plaza,
we're able to tackle that,
finally, and get that out there.
Now 15.5 isn't gonna be the
last update to Visual Studio.
There's gonna be a 15.6.
We're not imaginative with the name,
so it's 15.5, then it goes 15.6.
With that release, I'm excited to confirm
that at that point, once we've
finished all the brown boxes
across the compiler and
BID in IntelliSense,
we will actually be conformant
with the C Plus Plus '17 standard
and we'll be completely caught up.
That is our goal there.
Beyond the actual blessed standard,
there's also the technical specifications.
The slide had just enough
room for that as well.
You can see the color-coded
boxes as to how we're doing
against that behind the
experimental flag since, obviously,
we don't want you to
inadvertently take a dependency
on one of these since the
spec is moving itself.
Please try the experimental stuff.
Give us feedback.
Both for our implementation,
but also for the spec itself.
You can see there,
I mentioned on the slide
some were permissive minus,
and we talked about that
last year but I wanted
to touch on it again here
for those that don't know.
Basically, permissive
minus is a switch that puts
the compiler in a mode where
it will honor and enforce
pre C Plus Plus 11 standards.
It's off by default, because
we need to give the community,
the ecosystem, and the open
source libraries enough time
to get used to the fact
that our compiler will now
actually, by default, enable
Microsoft specific extensions
and Microsoft specific behaviors.
All the template code has a
chance to break under this.
Wherever we encounter code
bases that don't build
with permissive minus, we go and fix that.
So the biggest achievement
recently, I think
was the actual Windows STK headers.
For RS3 that's coming
next month we've actually
made that build completely
clean with permissive minus.
Also, with new projects that
you create in Visual Studio,
because they're new, a new code,
we actually have permissive
minus on by default.
I'm not gonna go through
all the other switches.
We talked about those last year.
The point here is that you
can adopt the conformance
that you want at your own pace.
It's not like a big switch where
you gotta go fix everything
and make all of your code bits conformant.
If you wanna do that, you can.
But you can take chunks and move
at your own pace towards that.
This comes with upgrades.
We're talking about all this coformance.
What's the easiest way for you
to feel the benefits of that?
That is by actually using
open source libraries,
or libraries that
previously wouldn't compile
with our compiler, but now do.
Some of these were in that category.
These libraries here,
is just the example of
what a we build live daily.
We don't just go and test
these libraries once.
We take the live branch
with our live daily bits
and we build them multiple times
under various different modes.
What we do is we clean
them as we go along.
We're removing if diffs and
anything that's protecting
against conformance gaps in our compiler.
As we plug those gaps, we're
gonna fix those code bases
so they can be clean, and
portable, and readable, and so on.
You'll notice, to my point earlier,
that the permissive minus
is 55 out of the 58.
So I as the team, I'm like,
&quot;How about the other three?&quot;
They said, &quot;Well, we have put requests
&quot;out to those project owners.
&quot;If they accept, the code will be clean
&quot;and we'll build under permissive minus.&quot;
We're actively helping here,
the community come forward.
Maybe in the past we weren't
always the best citizens
in the world, but now I hope
you can see that we're really
trying real hard to make sure
the right thing happens out there.
So that's about conformance.
Speaking to the same thing
of improving your code;
now that we're closing the
gap on our conformance goals,
we can spend more time on other
things such as code analysis
or compiler diagnostics.
Last year in this talk that
we did, we had this slide.
I'm not going to repeat it,
but it was the beginning of us
starting to invest in the
compiler diagnostics base.
Since then, we've released
around two dozen deliberate
improvements to warnings and errors.
I wanted to share a few of those.
If you look here on the
slide in the first column,
there's the code.
In the second column you can see the error
that you would get, which was
basically just a syntax error
where we just encountered something
that we weren't expecting.
In the last column,
you can see the improvements
with the new diagnostic.
You can see up there it says,
&quot;Use of dependent template name
requires template keyword.&quot;
Plain English,
and it really helps you actually know
exactly what's going on.
Also, notice the little carrot,
the upwards pointing arrow.
I'm told by our developers
that we do that better
than other compilers in
terms of pointing exactly
where the issue is.
You can go verify that for yourselves.
Before we move on, if we look
at the last example there,
that's a case of ambiguous
initialization order,
where we wouldn't even give you an error.
Now we actually tell you,
again in plain English,
what's going on.
Beyond the warnings, other
things that we're doing
to improve your code
is the C Plus Plus code
check analysis tool.
The C Plus Plus code guidelines
were announced by Byarna in
this conference, two years ago.
We demonstrated then,
type and bounce checkers,
and also a preview of
the lifetime checker.
We've been shipping rules of checks,
whatever you wanna call them;
every single time that we
ship, we ship more of that.
On this slide, I'm just
summarizing under which sections
of chapters we actually have
made most investments recently.
If you want your code to be
conformant to the C Plus Plus
code guidelines and you want
to take advantage of that,
then please do go and turn this on;
'cause it's not on by default.
Go to the project properties,
like the screenshot shows,
and you can turn that on.
Let's switch gears from
things that we are doing
in our compiler to help
you with your source code,
to what our back end compiler
does in terms of executing
your code faster in terms
of the code data generates.
Last year we're here,
and we talked about the
new SSA-based optimizer,
and we shared at the
time that we're seeing
about seven percent improvement
over the Eigen benchmarks.
This year we're sharing
that against SPEC 2017,
when we look comparing
to our previous selves,
we're seeing about nine
percent improvements.
If you're wondering which
specific areas that come in,
I'm not gonna talk about that here,
but they're on the slide for
the low level geeks among ya'll
said they're really interested
in what we focused on.
These are some examples.
There are folks at the booth
that can tell you much more about that.
What I'll say before I
move on from this is;
the reason we're sharing
these benchmark numbers
is because you can go
validate it for yourselves.
But really, internally,
the way that we really move
the performance needle is
with the benefit that we have;
that we build all these
really large code bases
from internal Microsoft teams.
If you think about Office, or
Bing, or code CLR, or Chakra,
or Windows itself;
all those teams have their
own performance goals,
and they're driving us hard
to improve the performance
of the code that we generate.
That has ripple effect
benefits to all of you
for your code bases that run on Windows.
That's hard to share externally
to kind of measure the progress,
which is why we're also using benchmarks
as a way to communicate that.
We feel good about the
investments that we're doing here,
and we'll do a lot more.
On the same thing of performance,
but switching from runtime
performance to build throughput;
again, if you looked at
the SPEC 2017 benchmark,
this time from a build
throughput perspective,
we have around 20%
faster than the compiler
that ships with Visual
Studio 2015, update three.
These are all very good reasons for you
to want to move to the latest.
Last year we shared this,
and I want to share it again
since we're the topic of build throughput.
The debug fastlink linker
option is now on by default.
That gives you two to
four times faster linking.
That's definitely
something that you'll feel
the performance of it as you
move to the latest version.
Also, IncrediBuild have a
product that you can go buy
from them that paralyzes your
build across multiple cores.
We have negotiated a free
extension to Visual Studio,
so you can just go get that.
The only limitation is that if you have
more than eight cores
on your develop machine
it's not gonna use those
as it goes and builds.
You should absolutely go check that out.
At this point, that's all I have to say
about the MSVC compiler libraries toolset.
I've kind of started cheating,
'cause I'm talking a bit
about Visual Studio here,
and we touched on that when we talked
about the C Plus Plus
code check analysis tool.
Now we're gonna really go and switch,
and talk about Visual Studio itself.
Before I do that, does anyone
have any pressing questions
on what you've hear so far?
Yes.
(man speaking off microphone)
I can't remember if it's on by default...
(man speaking off microphone)
You have to have to opt into
the compiler diagnostic carrot.
(man speaking off microphone)
Turn that on yourself.
(man speaking off microphone)
But there's already code bases.
Remember that we're trying to make sure
that the upgrade thing is smooth,
so there's code bases out there
that this could potentially
have broken if it gave you that
error just out of the blue,
so we want you to enable it.
(man speaking off microphone)
- [Man] People search the building.
I've put to have scripts
run over the building.
I (mumbles) when they
start putting in carrots.
It just messes it up.
They think the build failed.
- [Steve] Eventually, but
we need to have a time over.
(man speaking off microphone)
- [Steve] Correct.
- [Man] How we compile Stuff.
- [Steve] Right.
- Yeah, it's a diagnostic.
(man speaking off microphone)
Alright, so unless there's
any other pressing questions,
we'll move into the Visual Studio portion.
This is where I ask how many people here
are not using Visual Studio 2017?
Don't be shy.
Actually, that's quite a few.
Now you're gonna see why you really,
really want to move to that
and go convince whoever
it takes to go do that.
For the rest of you that are using it,
you might learn a thing or two as well.
The first thing to talk about
are the release cadence.
I didn't even put all the
releases up there at the top,
but I touched on those as I was
talking about the MSVC part.
We ship very frequently, in
case you haven't noticed.
It's a new world.
We ship very frequently,
which gives us the opportunity
to do really small value;
and as you report issues,
it's a smaller turnaround time,
'cause we'll ship soon after.
The first thing you encounter when you go
and get Visual Studio
2017 is the screenshot
that I've got up there.
This is not just a redesign
of the UI lair for our installer.
It is actually a big architectural
change behind the scenes.
This is what we call a
workload based installer.
That means you go and pick your workload,
which maps one of these tiles.
For example, here I've got selected
the desktop development with C Plus Plus.
Then you can install only the
things that you care about.
Why is this awesome?
There's three reasons.
One is that we'll put
less stuff on your disks,
since you've actually selected
specifically what you wanted.
There isn't one big
default, so that's good.
Because we're gonna put
less stuff on your disk,
it's gonna be much faster to
install, so that's also good.
Because you've selected
exactly what you wanted,
there's not gonna be any visual noise
of things that you didn't want.
For example, if you select this workload,
in under 12 minutes you'll
have the Visual Studio
installation you aways
wanted for C Plus Plus.
If you didn't care about C shop,
you're not gonna see any of that stuff,
and your disk is gonna
thank you for it as well.
There's a fourth reason.
If you look on the side,
you can customize each
one of these workloads.
You can customize the defaults.
One of the options that
I'm highlighting now
with the arrow up there
is that now you can get
the Visual Studio 2015 toolset
without getting the rest of
the Visual Studio 2015 ID.
This is huge for the
reason on the next slide,
which is we really wanted
to make sure this is a very,
very easy upgrade.
If you go and select that option,
essentially when you then
go with Visual Studio 2017
and open your existing projects,
you just don't upgrade
them and now they're using
the old compiler while
you're taking advantage
of everything that's new in the ID itself.
It cannot get easier than that
in terms of moving to the latest ID.
That is huge.
Some of you may be
thinking, &quot;That's great,
&quot;but you've just been talking
&quot;about all the value
that you have in MSVC.
&quot;I want to take advantage of
that conformance, performance,
&quot;and so on; so I will want to do that.&quot;
When you want to do that,
you go to project properties
and just like the screenshot shows,
you'll select the latest compiler
and now you're in business
using the latest bits.
If someone heard this that
was out on the street,
not you guys in this
room, they'll be thinking,
&quot;But now if they're on the new compiler,
&quot;I have all this cleanup
I have to do on my code
&quot;because you're more
conformant, and so on.&quot;
But you guys are not thinking that
because earlier we talked
about compiler switches.
So you remember that you
can actually go and take
as much of a chunk of that as you want
with the appropriate switch
and go at your own pace.
Now some of you may be thinking,
and I'm saying this because
we've heard it from customers,
is, &quot;I love this.
&quot;I love embracing all the new
stuff and cleaning up my code.
&quot;However, I depend on
third party libraries.
&quot;They're not moving forward,
so I can't move forward.&quot;
Essentially, the third party
libraries that are not built
with the latest compiler
that you wanna use
are holding you hostage
to the old compiler.
That is why, for the first time ever,
that we've managed in this release,
to have binary compatibility
between the two run times
and the two toolsets.
What that means, to spell it out,
is that that third party
library can actually stay built
the way it was with the old
compiler while your calling code
that uses it can move
forward to the latest,
and that will all still work.
So you're no longer
held hostage from that.
This is a huge thing that
not everybody understands
when they're thinking
about a pain of upgrading
and thinking of third party components.
That's something to take back
to the decision makers at your companies.
At this point, someone may be thinking,
&quot;Well, I use some open source libraries,
&quot;and I do want to get the latest.
&quot;There's all kinds of goodness
in the latest versions
&quot;of these libraries.
&quot;Do I have to go and clean
them up all on my own?&quot;
I wouldn't be asking that question
if I didn't have an answer.
The answer is no, you don't.
There is VC package.
If you're thinking, &quot;What is VC package?&quot;
We'll do a whole slide on that.
VC package is something that
we announced last year here;
it's one year old now.
It's a free open source project,
which is a repository of
open source libraries,
which are growing every day.
You can go there and find the
library that you depend on
and it will already be built
with our latest compiler.
If you have a library that's not there
that you'd like to be there,
email us and we'll take care of that.
If you wanna learn a lot
more about VC package,
then you'll want to go to
tomorrow's open content talk
at the friendly time of 8:00am.
That's where Robert and Eric
are gonna talk more about it.
You're also gonna see it in action now,
as Steve is going to demonstrate
everything that I've talked
to up until now for the
Visual Studio parts,
including a bit on VC package.
Then I'll come up and we'll
talk more about other stuff.
Are you ready, Steve?
- I am, I'm ready to push the button.
Can I press the button?
- [Daniel] Alright, Steve, over to you.
- Alright.
Hey, look, code.
I'm gonna just walk you
through that process.
We were having a sort of
pre show here where we were
discussing the fact that
there's only so fast you can
get people to understand that something
has changed important in the world.
So we really wanted to stress this point.
I've got a 2015 solution here.
This project has a dependence
on one third party 2015 library.
As you can see,
this is me opening it
for the very first time,
and I'm going to be given
the retarget dialogue.
So we want you to go forward, of course.
The first thing we do is we
give you the option to move
to the latest Windows SDK and
the latest platform toolset.
141 in this case represents the
VS 2017 stream of compilers.
To get started, I want to
show you that, of course,
that's not necessary.
You can click no and click OK, and again,
it's been like that for a long time.
It's amazing how many people don't know.
As you can see up here,
now it is a Visual Studio
2015 marked project,
but this is 2017 and
everything just works.
If I go here, I get full IntelliSense.
I can go jump to definition.
All of these things work.
I have this machine set up the
way Daniel had in his slide,
where I've installed the VS
2015 update three toolset
from this rather than installing all of it
just to get 2015 on this application.
What I'm gonna do; this is
basically a little graphics demo.
I'm just gonna show you
that it actually will work.
This is gonna build with the
Visual Studio 2015 tool kit.
If I run it under the debugger
and you look very carefully,
I want you to stare very closely
at this until you are all hypnotized.
Upgrade to Visual Studio 2017.
Upgrade to Visual Stu...
Alright, so that works.
Now what I wanna do is I wanna walk you
through all of the steps to get yourself
to sort of like modern happiness.
The first thing I wanna do is, hey,
I dismissed that dialogue
before and I wanna make sure,
in case you did dismiss
that dialogue before,
that you know how to get it back.
If you click on here and
you go to retarget projects,
it will again give me that.
The next time you open it
after you've dismissed this one time,
you're not gonna see it again
until you select it manually.
This time I'm going to
accept the defaults.
I'm going to take the latest STK,
and I'm going to take the
latest version of the compiler.
You can see up here that
the marking is gone,
'cause this is now a 2017 project.
I'm gonna build, and amazingly,
this is actually gonna work even though
I have that statically
linked component in here.
Just to show you how that
worked, I just wanna...
Nothing up my sleeve, magician style.
I'm gonna go in here, I'm gonna
show you inside the linker;
here's where SDL2, which is
the name of the static library
that I've done in here.
That is still getting picked up.
That is the 2015 based static library.
So I built it, and now, again,
if you do that you can
get hypnotized again
and more likely to do it.
So that's great.
The next thing I wanna
show in your process
of taking your old code
forward, as you take your time,
is come in here, into the project.
Learn how to use a mouse,
trackpad in this case.
Then if you go into here on C Plus Plus,
you go down to the language thing.
This is new in VS 2017.
It's the first time we've ever had
language specifications like this.
If you click in here, the
default will be C Plus Plus 14
because that was the
newest existing standard
at the time that we released our TW.
But now you can select in
here and choose the 17 spec.
I'm gonna do that.
Again, I'm gonna go in here.
I'm gonna build.
It's gonna work.
There's not any breaking changes in this.
Now, if I go in here and
type &quot;Include optional,&quot;
or whatever your favorite
header is and build;
that will work, as well.
Great, so what do I wanna do next?
Next thing I think you
wanna do at your code
is take advantage of the fact
that we are locking your code
into the non extensions
version of pure C Plus Plus 17.
What I'm showing you right
here, these bits that you'll see
for these first couple of
demos are all 15.4 preview.
In 15.5, we will add an
official thing for this.
For now, whenever you want to
you can add a permissive minus
here in additional options.
Again, this will lock you in
so no one accidentally adds
some sort of one phase lookup based code
into your code base.
So you kinda get clean, get the RS3, STK,
and then go forward.
Again, it just works.
I'm pretty close at this point.
(man speaking off microphone)
Not in this demo with the amount of time
I have left on this topic.
But come to the booth
afterwards, Zach, please.
I think I'm not cheating.
The next thing I wanna
show you is VC package.
We've talked a little bit about this.
This is the VC package webpage.
It's as easy as go to get
hub, look for VC package,
and it's basically a batched file.
Clone this thing and bring it down.
The magical directory in
here is this ports directory.
This will tell you ll
of the things in here.
Is Eric in the room?
He is not.
But if he were in the room, he
would tell me that there are
now, I think, 352 different
libraries in VC package.
We went from zero, or we
launched with 19 or something,
to 300 actively maintained
packages in like nine months.
It's been fantastic.
As you can see here, I
have STL2, so that's great.
I'm gonna go in here.
I did it off-hand, 'cause what
will happen if you type this
is it will actually pull it
down, apply some patches,
and build it, and get
it locally installed.
I have STL2 installed locally.
Then what I did was VC
package, integrate, install.
What this will do is
what it says it will do.
It will make it so that any
MS build based project will be
able to pound include
anything inside of that
as well as linking will just work.
Let me demonstrate that.
Of course, in this particular case,
'cause I already had it in
there, the 2015 version,
I want to replace that one.
Perhaps there's been a security thing.
Perhaps you want a version
with the latest performance.
If I go back into the linker, and input,
and delete out STL...
And again with the
learning to use a trackpad.
Hit enter, and I rebuild it one more time.
Now it will rebuild against
that VC package version,
and now everything is 2017.
Everything's latest back, and
everything is no extensions.
Thanks.
- [Daniel] Thanks Steve.
- Daniel, back to you.
- Alright, so we talked a
whole bunch about upgrades,
so your existing projects.
But some of you said
that you're not using
Visual Studio at all.
In fact, let me test that.
How many have C Plus Plus code bases
that you don't use Visual Studio at all?
(man speaking off microphone)
I see a real proud hand, and
then someone is like more,
&quot;Can I say that?&quot;
Yes, you can.
We hear that rarely.
It's shocking, but it happens.
We found that one of the
reasons is that folks
use different build
systems and Visual Studio's
very much MS build oriented,
or has been traditionally.
So that's been a blocker; it's
perceived as too much hassle
to bring it into Visual Studio.
For that reason,
we went and invested in
what we call Open Folder.
Open Folder's exactly what it sounds like.
You take Visual Studio, and you point,
and you browse your disk, find
your C Plus Plus code base,
no matter what build system you're using.
You hit open, and now that
code base is in Visual Studio.
You may wanna get some richer
IntelliSense, maybe debugging.
Maybe you wanna build from Visual Studio
rather than from the command line.
In those cases, you just
type little bit of JSON
to let us know some
information that we need,
and then you can get the
full Visual Studio experience
with your build system of
choice without having to go
anywhere near MS build or
Visual Studio projects,
or anything like that.
A special case of that is CMake.
I say a special case, it
literally is a specialization.
You'll browse as I just described,
and if we detect that that's
a CMake based code base,
you don't even have to
give us the JSON files.
We'll just do that automatically
and you will get a native CMake
experience out of the box.
I want to express that it's native.
It's not generating the project
behind the scenes or something.
It's a native experience
of CMake in there.
Steve now is gonna demonstrate both CMake
and the Open Folder.
Steve, over to you.
- Okay, back to this.
Rather than going in and
collecting...clicking?
Collecting?
Open project, I'm gonna click Open Folder.
I'm gonna go on my disk, and
all I have done to prep this,
literally all I have done to prep this,
is do a get clone on bullet three.
This is for our Google
friends in the front rows
who are not using Visual Studio.
This is a code base from Google,
it's a sort of bullet physics thing.
Because they don't use Visual Studio,
there is no Visual Studio
solution or anything in here
that we are using.
All I have done is pointed
it directly at that folder.
Because it does, indeed, have
a CMake list dot text file,
when we open the folder
it will detect that.
It will lay out the IDE and
get all of the configuration
information it needs
from the CMake server.
I wanna be clear, were not
in the background doing
the CMake generation of a solution file
and then opening that up.
This is real.
It will go in, it will detect CMake,
switch into this mode
and use the server thing.
To get started,
let's take a look at the
CMake list dot text file.
This is the main one for the project.
As you can see, we get some
colorization going on here.
Indeed, if I come in to
this file and start typing,
I do get some helpful
IntelliSense in there.
That's nice.
I wanna be clear that I didn't do
any configuration for this at all.
Indeed, if you wanted to
do some, what you would do
is you would come to this
Cmakesettings.JSON file.
This sort of takes the place
if you've ever used Cmake
from the command line before,
of the place where you would
put it on the command line stuff.
If you look in here,
I've got a bunch of
different configurations.
You can see that by default
we're using the ninja generator here.
That's the default one.
But if I come in here and I type this,
you can see I have the ability
to use the Visual Studio
generators for 14 and 15.
I'm gonna get that back outta there.
Again, to prove that there's
nothin' up my sleeve,
I'm gonna show you that all
of the UI features that you
would expect in the open project
or solutions scenario still work here.
I can use the new, cool, find
all references experience
inside of Visual Studio 2017
with this, and it just works.
This particular project has a
number of different targets.
I have selected the one
called AppBasicExampleGui.
Again, for Visual Studio,
because it's an IDE,
I think to prove that this
is a full fledged experience.
I'm gonna kick off the debugger, here.
I'm gonna click that.
I'm gonna hit this breakpoint.
I get all the sorts of usual Visual Studio
experience that you'd expect here.
Then if I pick it,
you'll see some blocks
break up and now hit.
That is how Cmake works.
Its more or less, it just works.
The next thing I wanna show
you is CMake is intended
to be magic, but not
everything can be magic.
Sometimes you have to tell us things.
This is an audience of
C Plus Plus developers
who like to tweak things,
so let me show you
how to do something a little nuttier.
I'm going to use Visual Studio
to have IntelliSense build
and debug using GCC with MinGW
and MSYS from Visual Studio.
I'm gonna go here, samples.
I'm gonna choose my MinGW demo.
I will warn you that it is
a very simple MinGW demo.
I'm gonna walk you through very quickly,
the three files that are
necessary to unlock this behavior
if you wanna use Visual
Studio with something
a little bit more exciting, like MinGW.
The first one is cppproperties.JSON.
I wanna be clear, Will back
in the back of the room, here,
wrote a blog post.
If you go on your favorite
web browser and search
for Visual Studio and MinGW,
you will find basically
the template for how to splat
some environment variables into here.
I literally took that and put it in here.
There are to halves to this file.
One of them is just about
setting up your environment.
Obviously, if you wanna
build with the MSYS
slash MinGW environment,
I need some access to some of
those environment variables.
You can either launch
this in Visual Studio
so it will inherit them
via the MSYS shell,
but what I've done is I've copied
those environment variables
into here directly.
The only line in this I
changed from the template
on Will's blog post is the GCC version.
I wanted a more modern one,
so I updated the version
that was inside with Pacman for MSYS.
The only other thing I did is down here
in the configurations
section where we create
the MinGW 32 version.
I had to that, of course,
where on disk I had installed this.
Once you have
cppproperties.JSON installed,
then you got everything you need in order
to use full semantic
Visual Studio IntelliSense.
Just to demonstrate that, I'm
gonna again go to definition.
I went to definition on
C out, but the key thing
to know here is that it brought
me to the right IO stream.
You can see that this is
the one, the MSYS 64 version
of MinGW 32 for the
version of GCC that I used.
All of that's unlocked
just by sending a couple
of environment variables and putting
some boiler plate into that thing.
That's wonderful.
Now we've got IntelliSense
so you can edit code.
If you've ever used the S
code, this next JSON file
will look familiar because
they're very similar.
Task.vs.JSON is how you specify
any custom task that you wanna run.
The most common one, of course, is build.
This context type cone build, here,
is what tells you basically,
&quot;Hey, Visual Studio,
&quot;wire this up for all
of the build commands.&quot;
Here you can see in this one,
'cause it's super simple,
I'm just doing a G Plus
Plus command line directly.
In other examples of this
that I've done myself,
you would just basically
put the word make here.
Once you do that, if you
right click over here,
now we can build main CPP,
and it will use Min GW to
build that and pipe back
the arrow messages as you have.
Again, Visual Studio, me
and Daniel are biased,
we both used to work on debugger;
so the next thing I wanna show you
is actually full MinGW
debugging inside Visual Studio.
As you can see, I right clicked on this.
I went to debug and launch settings,
if I did that a little
too quickly for you.
The three on the bottom are the classics.
These are Microsofts compiler
and debugger things you want
managed, mixed, or native.
But we've got two new ones.
One of them I'm gonna
show you in a minute,
called the GVV for Linux one.
For right now,
I have selected the one that
matches up to MinGW and GVV.
Now, when I go into the program and,
assuming I have this set up right,
which I'm not 1,000%
sure I do, there we are.
This is debugging with GVV
inside the Visual Studio IDE
on a MinGW application build with GCC.
Thanks.
(audience applauding)
- Thank you, we're only six minutes over.
That's great.
Okay, just orientation;
this is where we are.
We've done everything
up to the green arrow.
Now what we're gonna do is very
quickly, and I do mean very,
very quickly; as you can
probably tell, I can speak fast.
I can also turn it up a notch.
I'll try and do that now.
We're gonna go and look at the
other workloads that are in
that installer,
the Visual Studio 2017
installer I showed you earlier.
One of them is the universal
Windows platform development.
Those of you who want to do UWP,
you need to go and check
the C Plus Plus books.
It's not checked by default.
That's my tip for you.
In case you don't know, we do
have a unified Windows store.
I think it's really cool,
'cause you can create
a single binary and it will
run on desktop, mobile, Xbox,
HoloLens, this runs everywhere.
At run time, it actually
adapts to the form factor
and the input types of the
platform that it runs on.
Also, you see up there C Plus Plus WinRT.
There's a session on
that this week at CppCon,
so you can check that out.
The last thing I'm gonna say on this slide
is that bottom bullet.
We've had from the
previous release, in fact,
a way for you to set up
Visual Studio to share code
and target as many platforms as you want,
like Android, iOS, and Windows.
Now, new this year,
is that we can also have
Linux targeting from there.
Steve is gonna show you that in a minute.
Moving to the mobile development
of C Plus Plus workload.
I have to say, in case I haven't already,
you can combine these workloads.
Check as many as you like to create
the combination that's good for you.
This one is the one
where you're gonna target
Android and/or iOS.
This continues to work like it used to.
We can still roundtrip with Xcode
if you're doing iOS development.
On the Android side, we can
give you full IntelliSense
and debugging; not just
for the C Plus Plus code,
but also for java code,
right there in the IDE.
We do updates through later
API levels in any case.
We're looking for your
feedback for those of you
that have tried this.
What else do you want us to do, here?
Come to the booth or grab us
if you see us and let us know
what else do you wanna see
in this mobile development
C Plus Plus space?
Moving on to the Linux workload,
which is the latest
one to join the family.
This is new in this Visual
Studio 2017 release.
It was on an extension before.
This particular workload,
if you select only this one,
in under six minutes you'll get
a Visual Studio installation
that gives you all the
Visual Studio goodness
of debugging and editing the
song, but targeting Linux.
Last year we did a real cool demo of this.
By we, I mean Steve.
Of the Windows subsystem on Linux.
Since that time; then it was
kind of a beat kind of thing,
since that time with a
Windows 10 fall creators,
that's actually released.
It's fully out there now
in the Windows server.
That essentially allows you
to have multiple distros
running concurrently on your Windows box.
You don't even need a separate
Linux machine, or a VM,
or anything like that.
That's pretty awesome.
We demonstrated that,
so we don't want to
demonstrate that again.
Instead, Steve is gonna show
you that sharing of code
with Linux and Windows,
and some other things that we
have recently done for Linux.
Steve, over to you.
- Okay, great.
As you can see, this is Boon 216.
I've got it running inside a
VM on the side of my machine.
We're much further along
than we were last year
when we showed you something.
This year, I wanna show
you shared projects
and then I got a little
something at the end.
Again, if you missed last
year, how this works is you go
into connection manager and
you click the add button.
All we need to know is
the host name, the port,
the user name, and some sort
of authentication methodology.
I have previously set
this up so the default one
is now pointing at that VM here.
I have it on an internal
hyper B switch on my box.
The next thing that's different
this year from last year
is cross platform cube, here.
This is using shared projects.
You see this double diamond thing.
This is a shared project, and
if you look inside of my...
Oops, not that one.
You look inside the references, here,
you can see I have two other projects.
One called Windows cube
that has a reference
on that shared project,
and one called Linux cube,
which is a Linux project and
has it on the same project.
There's basically only a
single source file in here,
but that source file is shared
between the two of them.
I'm sure you can imagine what
this looks like on Windows.
Just to sort of get it
built and get going here.
This is a rotating cube.
It's not a demo unless a cube rotates.
We got that going for us.
The other thing that you
can do here, of course,
using that same technology
I was just talking about
in the last demo was if I go and I click
and debug the Linux one,
and find the right place,
and wait a second, you can see;
here's the cube debugged with GDB on this.
The most important productivity
feature for this is,
of course, the quality
of the visualization
of any debugged things.
We do, indeed, have visualized views.
So when you're debugging
from Visual Studio,
you'll get a nicely visualized
version of that thing,
not necessarily what the raw
implementation looks like.
That's very useful.
As you saw, at least on Windows,
that was rotating pretty quickly,
so I'm gonna go in here and
demonstrate for you very quickly
what I think is a really
cool IntelliSense feature
for three cross platform scenarios.
I wanna slow this down, so I'm gonna type
you sleep 1000 in order
to slow down the thing.
You see this purple squiggle?
Red is bad squiggles.
Purple squiggles are different.
Purple squiggles are
moderately bad squiggles.
If I hover here, you can
see exactly what's going on.
That's great, Steve.
You can use 1,000 microseconds
and sleep for them.
But there's actually not
an equivalent function
inside of Windows.
You'd need to use the capital S sleep,
which obnoxiously uses milliseconds
instead of microseconds.
This is telling you before
you've even built that you have
a non cross platform clean
thing inside your code.
You can go in here
and add the appropriate
F dots or whatever.
That is the cross platform cube;
and that's shared projects for Linux.
I actually kind of dropped
a little bit of a Easter
egg in an earlier demo.
What I'm gonna do now is I'm gonna go back
and I'm gonna reload the
Open Folder on bullet three.
I wanna stress that I did not
change the settings on this.
But if you saw earlier as we were looking
at the configuration,
there's actually two at the bottom, here.
This is new in 15.4, for sure.
What happened there is I switched
to the Linux debug
configuration and now CMake
is sort of switching configurations.
You can see it's changing the IntelliSense
to point to the Linux based
versions of things, instead.
Now, if I select the right...
I think it's that one, and I click build,
you can see it does a build.
The build is happening remotely, remember.
Now it's gonna hit a break
point, 'cause I set one.
Now you can see the slowly
emulated cubes breaking apart
inside Linux with no
reconfiguration at all.
You're just switching back
and forth that one switcher,
and you're getting from
Windows mode to Linux mode.
This is super useful.
Alright, thank you.
Daniel, back to you.
- Cool, thanks Steve.
You guys like that?
Is that cool?
(audience applauding)
Yeah, that's more like it.
See, if you beg, they clap.
- [Steve] Shameless, we are.
We are shameless.
- Something related, the
internet of things, IoT,
Windows things, or running Linux;
obviously everything
we showed you applies.
If you're doing any embedded
or IT kind of development
and you go to Linux targets,
all of this stuff we
showed you just works.
That's definitely a scenario
that we are prioritizing.
We've got improvements in
that, like with the York TCK
allows you to replace the
compiler that you would wanna use.
Last year we said that we
intend to also add support
for Microcom controllers,
MCUs, and, indeed,
in 15.5 you will start
seeing some of that.
Good news here for
embedded and IT developers.
Iot, Internet of Things;
these things are connected.
If you're gonna connect them to something,
then we encourage you to go and check out
the Azure Iot SDK, which
supports your IoT needs.
From here, I'll switch to the
last workload that our team
kind of developed so we think
it could be useful to you;
which is one on game development.
Notice how at the top there
is the unity workload,
and then all of the C Plus
Plus related game development
is in the other workloads game development
with the C Plus Plus, and that
includes Direct X, Unreal,
Cocus, game engines that
we support out of the box.
This is also an area where
we really want your feedback.
What else do you want us to do, here?
We're working on this for a
while, it's fairly mature.
Is there anything missing?
Come and find us at the booth,
or stop us and let us know.
I will say, before I
move on from this slide
that more and more these
days game development,
those games are powered by
some kind of cloud service.
There's a URL up there on
the slide so you can find out
what the Microsoft cloud
can do for your games.
With that, orientation;
we've got two slides and a demo to go.
We're gonna go and dive
straight into productivity.
This is the bucket of all the
things that make the quality
of your every day developer life better.
These are things that you do every day
when you go and develop code.
Last year,
we had a 15 minute demo of
just productivity features.
We showed you a lot.
Since then, we've done even more,
so Steve now is gonna shOw you
some of those newer things.
I think he's gonna be
using 15.5 for this one.
- Yes, this is the 15.5 bits.
These you can't get yet, but I
promise they are coming soon.
The first thing I wanna talk about;
I got a cryptography thing again,
just some code we cloned off
of GitHub to do demo with.
The first thing I wanna talk about,
which is a productivity feature
we don't talk about as much
in these situations; which is
just your source code intro.
Visual Studio has a quite
sophisticated set of bindings
for Git, so I'm demonstrating here,
I went in here and I clicked view history,
got the full history on master in here.
A new feature in the 2017
line is if you select
two different commits,
you can right click in here
and click compare the commits.
It will bring up the team
explorer with those two compared.
It'll tell you, of course,
what the messages were
for each of those commits,
but also it will give you just
the files that were changed
in between those two.
Now when I go in and
I select one of these,
I can see the diff of that
file between those two things.
It doesn't matter which version
I have checked out it will
just give me the difference
between those two commits.
I think this is pretty useful.
Let's be honest, most of the purpose
of source code control things
is blaming other people for problems.
Good, I'm glad that you do, too.
We also have a very nice visualization
for the git blame thing.
It's fun to go through
other people's source codes
and do this on them.
In this one, I noticed as I was
going and prepping this demo
that this person,
Way Dai had gone in and
wrote a bunch of code.
This guy, Jeffrey Walton,
had gone in and added a bunch of asserts,
and that made me think
I wanna hire that guy.
I'm sorry if any of you are in the room.
I just picked this randomly at GitHub
and now I'm making fun of you on stage.
Does anybody test their code?
(audience laughing)
That laughter was uncomfortable, people.
We noticed, actually,
that many of you don't use
the built-in unit testing
inside Visual Studio,
and we've done a lot of work
in Visual Studio 2017 to
try to make it much better
for the average C Plus Plus developer.
Coming in 15.5, we're gonna
have support for Google test.
It's like you guys sat there on purpose.
Google test as well as boost test
are now gonna be in box with things.
Before, you had to use our test adapters,
and now we support others.
The way that goes and works is if I go
into the solution explorer,
and you click on your solution,
and you go add new project;
one of your choices,
one of your project template
choices is Google test.
If you select OK to add
that to your solution,
you can then select which project
inside that solution you want to test,
as well as decide whether
you want to consume it
as a static library
and how you wanna consume
the runtime libraries.
I've already gotten this set up
in the interest of going fast.
I'm a solid programmer.
I wrote one test for
this entire code base.
As you can see, what happens
is this gets detected.
Your code base, once
you have this in there,
you have G test stuff in there,
it will scan your solution to find them.
Test explorer will find them.
Then you can click this.
It will run.
I believe...it's building first.
Let's all wait patiently
for that to happen.
Now the tests have kicked off.
You can see that the test has failed.
It gets all sorts of good
information when a test fails
so that you can see, for instance,
if it's thrown an exception there's
a whole logging thing
in here, which is great.
You can click on here to
debug it once it's failed.
The thing I wanna show
you right now is a feature
after my own heart; analyze
code coverage for all tests.
I'm sure I'm doing quite well here,
because I wrote that one test.
It's kicked off, so it's
gonna build it again.
What's gonna happen is it's
gonna instrument the code,
all of the code, and then run
that unit test against it,
and then it will tell us how we did
in terms of our code coverage.
Running one test now.
I'll tell you that this
is the first piece of code
I ever wrote at Microsoft,
so I'm (mumbles) fourteen years ago.
You can see I'm doing a fantastic job.
I can see immediately,
across my entire project,
I have six, seven percent coverage.
I think that's done; let's ship it.
Next up I wanna show you
just one or two more quick little things.
The first one is going
to be...where'd you go?
Function stepping before.
I've got two features
left I wanna show you.
One of them is editor config.
In case you don't know, while
that's loading I'll tell you
that editor config is like an
open standard for expressing
what your desired editor
formatting choices are.
You can see I have it in here.
We talked a little bit about red squiggles
and purple squiggles earlier.
This person, who has
written this source file,
has selected tabs; so
I'm surprised there isn't
a red squiggle here, 'cause
that's just not right.
I was hoping to get booed
or something for that one.
I go in here, I'll save that.
- [Steve] Boo.
- Thank you for playing along at home.
Then it will quickly change the code
to match that editor config.
This is a good way, nice cross editor way
of setting up what your preferences are.
The next thing I'm gonna show you
is a surprisingly highly
voted feature on user voice;
so we finally dealt with it.
This is actually the before picture.
I hope you can bear with me on this one.
What we have here is three functions.
We have a plain function, member function,
and a function object
that returns a witty
pop culture reference.
If we go here and we run to that.
Let's go ahead and build that.
Let's get to the breakpoint.
So this is stood function
wrapper around plain function.
How many times do you
think we have to step into
before we reach plain function?
Think of a number in your head.
One...ah, ah, ah.
Two, three, four, five, six,
seven, eight, nine (mumbles).
Twenty two is actually the correct answer.
Who has 22?
Of course you all did.
I didn't make you write it down.
Indeed, the climactic
conclusion to this demo
is coming in 15.5; you will
have the following experience,
as soon as your solution loads.
(whispering) Just one second.
(whispering) Come on, man,
this is killing the sus...
Is this building suspense,
or killing suspense?
I can't tell.
What's your guys' feeling?
Alright, I got the
breakpoint set, let's go.
F5, yeah, build it, sure.
One...ah, ah ah.
Alright, that's it.
Thanks, that's function stepping.
If you used to function,
it's gonna save your life.
Think of the children.
(audience applauding)
(man speaking off microphone)
If you have to debug the
implementation of stood function,
you work for me and I pay you enough.
(man speaking off microphone)
I will say go to the Visual
Studio booth afterwards
and say these words, and I
swear to God it will work.
Say, &quot;Can you tell me more
about project fee fee foo foo?&quot;
Go.
I'll explain later.
- Thanks Steve.
By the way, we keep
referring to our booth table.
It's literally around
the corner from here.
Just go out, turn right, and
just find the purple shirts,
and we'll answer any
questions that you have.
Also requests, if you have requests.
Steve showed editor config,
which is like a standard.
Maybe you wanna see something
else (mumbles) something else.
Just let us know.
He showed Google test and boost,
and office (mumbles) test.
Is there something else you want to see.
I don't know cache, like something.
Just let us know what
else you want us to do
in all of these spaces.
We're just around the booth,
and you can also email
us like I said earlier.
We're talking about productivity.
Some could argue that performance
is part of productivity,
especially performance of the
AD as you interact with it.
Like earlier, when he
was killing the suspense,
you want it to be fast.
We talked about build throughputs earlier.
That's part of that, as you
do the edit, build, debug,
you want the build stuff to
be as squished as possible
so you can be productive.
But we've also done other improvements
and we shared these last year.
I'm curious, actually,
how many people were in this
talk last year or (mumbles).
- [Steve] Yeah, die hards.
- That's not everybody.
Could have repeated the same
demos, they wouldn't know.
- [Steve] Would have
saved me a lot of time.
- Then, actually, I should stress;
look at these dramatic improvements.
I was gonna pass this by.
You need to know about this.
Look at those numbers in
terms of solution load.
Seventeen times faster; that's crazy.
We've actually invested
a lot of energy here
in the performance of the AD itself.
Like we say, this is performance
you will be able to feel.
We're not done.
Internally, we're working...no
we don't have time.
Internally we've got bits
where we're improving
the design time experience.
Think of go to the finish
and find all references,
refactoring.
Our goal there is to
go orders of magnitude
better than where we are.
I can say that easily,
'cause his team has to do it.
I'm just the program manager,
that's a specification.
Make it orders of magnitude faster, Steve.
This is an area that we're
really trying to improve.
So again, we want your feedback.
What are the scenarios
when you use Visual Studio
and you're like, &quot;I wish
it was faster there.&quot;
Just let us know, 'cause we're
really prioritizing this.
With that, before we go to the summary,
there is only one more slide
which is really to thank all of you folks.
These are the two primary ways
that we like getting feedback
and you've used that.
On the User Voice, with
your suggestions and votes,
and through reporting
problems in the tool,
you have told us about issues
and we have addressed them.
This is the number of votes
that we have closed and bugs
that we've fixed just coming
from you into the tool.
Give yourselves a round
of applause, really,
thank you very much.
(audience applauding)
If you wouldn't have told us about it,
we wouldn't have fixed it.
That's in addition to
everything else that we did.
With that, this is the last slide.
We talked about all of
these things; conformance,
performance, Linux, Android/iOS,
IoT, game development.
I just like throwing
words out there...CMake.
Basically, like I said
at the very beginning,
we want Visual Studio to
be the best ID on Windows
targeting any platform,
any scenario that you have;
and our compiler to be the
best compiler on Windows
and libraries toolset that
is on Windows for Windows.
That's what we're doing,
and there's also Visual Studio code;
so catch that recording online.
The last thing I'll say is that
I don't know how many of you
have been following kind of
what Microsoft has been doing
over the last few years, but
it's a different company.
From the inside we feel that,
and we're happy with it,
I hope you guys can sense it
from the outside, as well.
I don't know how many people
would have expected that we
would be shipping a cross
platform free open source editor.
Who'd have thought that a few years ago?
It's actually the number six project
in GitHub in terms of
number of contributors.
I looked that up over the weekend.
Also, last year Microsoft was
the number one contributor
on GitHub in terms of
open source contributions.
It's a different company.
I hope you seen some of it here.
But then, we can always do more.
So please, do come talk to us.
What else can we be doing
to be better citizens
of the community and to offer
a better product for you?
You can email us, again,
any abuse, Steve Carroll,
and compliments, Daniel
Moth at Microsoft dot com.
Enjoy the rest of the conference.
(audience applauding)
- [Steve] We didn't screw
up the time, did we?
- No; somewhere we forgot
to say something important,
I'm sure.
- Yeah, probably.
- We have two minutes for
questions if you don't wanna come
to the booth and you wanna ask them now.
- Costya, what's up?
- [Costya] Do I have any new
features for memory safety?
- New features for memory
safety; I don't think anything
that we wanna talk about, short
of the CPP core check stuff,
which I guess you could
look at as that (mumbles).
Not at this time, sorry.
- [Man] I have a feature request.
This is probably gonna
be completely insane.
You know how you have the
immediate window in Visual Studio?
- Yes.
- [Man] I wanna be able
to type windy bug commands into there.
- That's not a crazy...
- [Daniel] That's not
a crazy thing at all.
- [Man] Can you do it?
- [Daniel] Well, we've heard you.
- Find McNillis and me and we'll talk.
- There's also; the win bug guys are here.
So you can also ask them,
'cause it would be a collaboration.
- [Man] The other thing I
wanted to ask is you mentioned
the Google test adapters and stuff;
does that work if you just open a folder
that's like a CMake project,
and then it discovers a G
test project in your tree?
- Not yet.
- Not yet.
Did you wanna speak to that?
(man speaking off microphone)
- In the microphone, though.
- He'll tell you why it doesn't work yet,
but it's on our plans.
- [Man] I just want solutions,
I don't need reasons.
- [Man] Basically, the core
test platform of Visual Studio
currently doesn't support Open Folder.
We're hoping to change that in the future,
so that it is supported in any environment
that you happen to be using.
At that point, once the
test platform supports it,
then we can make sure our
test adapters actually support
Open Folder mode.
- We're definitely gonna
keep going on testing.
We're just getting started.
Yeah.
- [Man] I noticed that
Unreal engine was in the list
of platforms or projects
you're testing permissive on;
but they have their own build tool...
- Yes, they do.
- [Man] That doesn't let you
ass any arbitrary parameters.
How are you dealing with that?
- That is a very good
question I do not know
the direct answer to.
If you grab me afterwards,
though, I can find the developers
who have that thing set up and
see how they're hacking that.
- It's true for a lot of the
libraries in the real world
codes that we test internally,
it's not that publicly you
can just go hit the button.
We have to do work to get
them into our compiler.
- There's a decent number
of people working just
to make sure that that keeps running,
'cause we just think it's so important.
Especially with going fast,
with releasing updates
that are in place, it's critical
that we not make mistakes.
So that's why we invest in doing that
more than we have in the past.
- We're out of time, but we
can take one more question.
- Hey (mumbles).
- [Man] Yes, I wanted to ask;
is there any plan to have
the Visual Studios compiler
run on a non Windows platform
so you can build the Windows toolset
or create automated builds
to build the Windows toolset
or Windows applications, or
run even the native unit test
without actually having
the Visual Studios running?
- No.
- But you should talk to Zach.
- That's the short answer; no,
and there's no plans
for that at this point.
But if people keep asking, you never know.
But now, people are not asking.
- Alright, so we'll be around
for as long as they'll let us.
Thank you for coming.
- Thanks.
(audience applauding)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>