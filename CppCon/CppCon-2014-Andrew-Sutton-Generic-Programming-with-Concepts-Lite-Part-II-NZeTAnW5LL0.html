<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2014: Andrew Sutton &quot;Generic Programming with Concepts Lite, Part II&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2014: Andrew Sutton &quot;Generic Programming with Concepts Lite, Part II&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2014: Andrew Sutton &quot;Generic Programming with Concepts Lite, Part II&quot;</b></h2><h5 class="post__date">2014-10-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NZeTAnW5LL0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome back for those of you who've
decided to brave another hour of this I
hear there are some other good talks
alright so just a quick recap of what we
talked about the last 45 our last hour
so so basically concepts light is
primarily note well I say it's primarily
motivated by the need for better
Diagnostics like that's just my
perspective on it I'm sure that if you
ask pyaar nahin will say that he had
many other broader ideas in mind but
this is this is the perspective that I
come in from so concepts i basically get
this idea that we can constrain any
template and some other things with this
requires clause so the question then I'm
going to start asking is a little bit
different now I'm not going to not
really going to show you what what the
next set of features but I'm actually
going to kind of ask maybe oh yeah so
for example sorry I just wrote these
slides this morning and it rehearse them
quite as well as I could so this is our
previous declaration for last talk so
you have a template typename seek
typename function requires that
expression and then you have the usual
declaration apparently with the trailing
for Klaus ignore that apparently I did
right ignore the for loop that's
supposed to be a definition and we're
going to we're going to improve the way
that this looks later by fixing the bugs
so the what I actually want to talk
about are the kinds of constraints that
we really want to write and so far we've
only written type traits and type traits
are in my opinion type traits are fairly
uninteresting but there are a bunch of
different questions that we can actually
ask about these types of these
constraints so you know is some type the
same as another time is this type T in
some set of types s or is type T a case
a special pattern that matches type you
or is T a subtype of to you subtype of
you Wow bugs yeah t is technically a
subtype of tes that's that's an easy
question to answer and then you know
this other question sort of like can I
use T in this way which is a very very
interesting question and of itself
so the reason I bring this up is that
all of these constraints these questions
do we ask of types and constraints it's
not it's not just a yes/no question
really what we're doing is we're setting
up an expectation within the context of
that template says you know here's my
GCD function i require t to be integral
it has to satisfy this is integral thing
and that automatically gives us this
expectation within that template that we
can use t as you know a built-in integer
type it has plus it has minus it has the
shift operators as you know modulus or
whatever and that all of those operators
have the same basic meaning from from
one one argument to the next that any
instantiation is algorithm for type
satisfying these constraints will be
correct because we know that we're using
the right object right the right
notation inside of this out every
constraint that you ask sets up some
abstraction like this every constraint
one x now this leads very quickly to
this discussion of separate checking
which is to say that can you actually
make the compiler learn about those
abstractions and then go actually check
the template definition against I was
abstraction and the answer is the
sometimes yes is difficult and it takes
a long time so you can we chose not to
with concepts light and that's this by
the way is exactly why concept light is
called concepts like we did not try to
solve this half of the problem it's not
easy obviously if you try to push back
from integer you're not going to succeed
very well yeah the original concepts
proposal did include that include
mechanisms to solve this we actually
asked because we have constraints and we
can ask pretty much anything we actually
have a much broader problem to solve
unfortunately I've made life difficult
for myself or I've made life difficult
for my student
yeah the abrading Sprint's honors thesis
project is related to separate check
your concepts so we're going to try to
figure out how this actually works and
how this is going to work in practice
and how we can actually integrate this
feature into c plus boss in sort of a
non intrusive way there's some
interesting things that happen if you
just sort of flip the switch and make
every template checked which is that you
pretty much have to adopt constraints or
concepts in one shot you don't you don't
really get a clean migration path from
one version of concepts to the next all
right yes substitution substitution
failure happens at the point of
substitution separate checking happens
as you parse the template definition
itself so it's checked separately from
its instantiation there is no
substitution all right so these are the
kinds of questions that we want to ask
and let's let's look at some of these
abstractions we're actually building up
here so his type T the same as you the
way that you might spell this in C++ the
day is to actually write standard is
saying this is a type trait and
basically we're saying that T has
exactly the same properties of as you
this doesn't seem very generic right
like hey is t an int sure why not but it
turns out to actually be kind of helpful
in certain cases where you want it like
have a set of operations that return
types we're possibly different types and
you need to say that they're actually
the same time like begin an end this is
where I is going to point it Eric and he
would tell me that I knew blur and he
would tell me that I was wrong is
apparently beginning in return of
different types but this is one place
for you through you would use them if
you if you try to define a template like
this this is totally legal you can do it
I just I don't know what you're trying
to get out of it because you can do this
and it's basically the same thing except
this is not a template so I don't know
you can do it it's interesting they're
not quite the same you're right because
this is not a template specialization
and therefore it is more specialized
than that so there's there are some
interesting if there's an interesting
interplay that can happen with these
days I'm not I'm not disputing that it's
just an interesting thing that falls out
of the light okay so we might ask is
type T a member of set of type size
so this this abstraction is really a
essentially an idea that's sort of
dominated by a set of types sherry
presumably the same syntax and semantics
we hope they're the same syntax and
semantics right now the way that we do
this today the typical approach is doing
this today with typed rates so here's
integral and it's actually defined like
this in a lot of different library
implementations you basically just sort
of enumerate the set by having a primary
that says every type is not in the set
except for int is and long is and
carries and and all these other types
right unfortunately that doesn't really
work so well for third-party libraries
we kind of talked about the last area
hour so if you try to use this big in
class with this type obviously it will
it will not work because big int is not
in a set of types named by standard
standard integral that content that's
that abstraction forget I said concept
the other problem with this is well
it'll ated to that it's actually a
closed set right if you want to go and
extend the definition of this set you
actually have to go modify the
definition which actually is not that
hard to do with partial double
specialization but you still have to
modify that sentence um that's not
actually a closed set yes right that's
true too yeah you can't you can't
magically add new integer types to the
language that would not be a good idea
so we also have these cases like is type
T a case of you so this is really we're
sort of define an abstraction based on
the shape of the type so kind of what it
looks like how you spell it and again
presumably all at the same syntax and
semantics now there's really no good way
of actually spelling this is a
constraint we can't say it's not easy to
write a type trait called is template
specialization of you can do it in
special cases but I did not do and just
to show you the sort of the vanilla
version that we're all we're all used to
so there's sort of kind of an implied
constraint on this function that
whatever argument you supply must be a
special case of vector of tea it has to
be a specialization of this template and
of course we all know that every
specialization of vector works the same
and so therefore this algorithm is going
to be
no matter what arguments we provide
right now is your opportunity yeah
vector bool does not work with sorc
actually is that true anymore it's
required to work okay okay it used to be
that it did not work so I'm behind the
time my upon this is one of the this is
one of the kind of questions that you
get a lot in many many many many many
many languages is T is subtype of you
know presumably we're going to say that
the subtype generally taken be a base
class it doesn't really have to be some
type is actually a fairly general
concept it's just that in C++ subtype of
sort of the we attended default
inheritance for that we could also think
about this in terms of conversion we
could I don't want to but we can so if
you guys are familiar with Java generics
or C sharp generics or any any language
that has subtype and strengths on their
on their parameters I think a lot of
functional programming languages deal
with this stuff system f is that right
so it kind of imposes actually that's
not quite true persistent so kind of
imposes this oo model and everything
because if you're asking for example if
everything has a base type then all of
your arguments that work with that thing
actually have to be derived from
something and for for whatever reason
this isn't really a good idea like maybe
it doesn't have a base class it doesn't
and so maybe this idea isn't really the
best way to express constraints for
every single thing that you want to ask
about an abstraction it's very very
limiting the number of things that
actually go into a hierarchy in the c++
standard are very very few yes yeah yeah
still used I'm not going to we're not
going to throw it so for example we
could do something like this we can
define sort which as a template which
requires some I sortable a standard is
based on would be a traditional way of
asking for that and that inside of that
sort algorithm do we know that we can
rely on aunty to actually or s here to
actually provide the interface of that
class because it's derived
now it becomes kind of interesting
comparing that versus this if we were to
go the other way I think we could talk
about type erasure except that now we
have sort of type preservation with the
first one right so here you call
sortable with letter no vector or
something like that or you know object
oriented and you actually lose the
static type at the call site with this
one you actually preserve the with the
template you actually preserve the
static type of the argument be costly so
it's an interesting contrast and you can
certainly use this to very interestin
umber of different problems although
what executives are not quite sure we
haven't we haven't really explored this
too much ad hoc constraints are my
favorite is their last so we have this
question like can I use T in this way
you know can I can I write this
expression with an argument of type T or
an operand of type T can I can I access
this member variable or this member
function where can I access this a
member type like value no pico and core
values it's so in C++ 11 we can we can
actually do this it's not pretty has
anybody tried writing one of these type
traits that actually checks like has
plus or get nested typing you like it
right it's fun we love it and it's not
that that's not the topic of this talk
so ask somebody else there will be
plenty of people around here who can
help you do this if you really want to I
did it a long time ago I will never do
it again it's awful okay Walter Walter
will tell us how to do this for c++ 14
hopefully more elegantly than the way
that I did it is man that's bad all
right the end result of that is that
that this is actually we might end up
with something like this so here's a
function called add and we are we
require has to has plus and I just want
to point out that this is not really and
by any stretch of the imagination meant
to be indicative of a good generic
programming style it's actually quite
the opposite what you're looking you
don't you don't want things like has
clients plus you want you want sort of
meaningful concepts no I did
I like my head I like my ads to be
broken so there are a couple of reasons
why this is not an example of good good
practice most useful function ever so it
turns out that these these these ad hoc
requirements what I'm calling ad hoc
requirement they end up being sort of
fundamental for this the what we
generally perceive as a generic
programming for C++ the way the generic
programming is practiced today is is
built on this idea that you can look at
an algorithm or that you look at a
generic algorithm and you lift up all of
these little individual type constraints
and then you you express that as some
cohesive abstraction that's generally we
call a concept and it allows reuse by
similar but unrelated interfaces in this
by the way is Alex stepping on you know
that so what we call a concept today is
really that set of requirements for an
algorithm the set of syntactic and
semantic requirements for algorithm the
syntactic calendar there the syntactic
requirements tell you what that
algorithm is actually required to
support or the data type is required to
support can I access T colon colon value
type or t-con iterator can I can I add
two things so i subtract two things can
I pre-increment your post decrement so
those are the kinds of things that the
algorithm does the other thing that we
have inside of concepts or have with
concepts are semantic requirements and
these are the supposed to be there to
actually explain what those requirements
are supposed to do or sorry what those
required operations are supposed to do
and actually that's not quite even the
right way to phrase it those
requirements actually explain what
behaviors are required in order for the
algorithm to be in the way that Alex
probably phrase is provably correct
because if you don't have any guarantees
on the semantics of those operations
then your algorithms do literally
anything it doesn't matter what the
syntax is you know just format your hard
drive no big deal we like having
semantics associate with those operators
and it's kind of interesting if you
think back about all those other types
of obstructions we can define through
those questions those kinds of
constraints we can actually go back and
pin the semantics of those required
operations to something somewhere except
with these things
you know if it's a subclass you're
asking for a subtype of string there is
a virtual method somewhere in that class
that you can point to and say that is
the meaning of that operation if it's
the same type well that's the same type
so that the same the the requirements
are explicit if it's if it's in a set or
if it's a vector then we kind of hoped
at the point to an operations say we
hope this works there's an opportunity
to break things in there a lot by
because we have C++ and the language is
flexible do that but the idea is that we
need to be able to provide these
semantic constraints to say what those
operations actually do I'm going to
point this so this is like my one slide
that actually talks about concepts it's
like the summary of n 3351 concept
design for the LCL in one slide concepts
are most useful when they occur in a lot
of different algorithms same time so if
you have a bunch of algorithm to share
common common syntactic requirements
common behaviors then you really want a
concept that describes what those
algorithms what those requirements
actually are what that abstraction
actually is you know we can certainly
define one-off concepts it's not a big
deal like I have a template I should
probably have a concept except that that
one-to-one mapping kind of leads to this
idea that you have a million concepts
that seems kind of skewed all right so
what are the actual requirements of all
I know I know the previous we've said
there if it's a sequence and predicate
but that's actually not correct and in
order to actually find out what we want
to require we have to look at the
implementation and figure out what's a
lab so the first thing we'll look at is
the fourth so for the range base for
loop aha range it requires you to be
able to use call standard begin it
requires you to call standard n on s
there's some sequence type X and it
returns some value and we're just going
to call that value on both of these
functions return some value
syntactically we also require that that
return value can be incremented through
+ + I and that we could dereference it
and bind it to a constant value
reference to some type which we're going
to give a name to it a little one these
are the syntactic requirements of of a
range base for loop specifically of this
range base for loop by the way you can
modify those
we also have this statement so here we
have some function f and it's called
with X so it has to be at least take an
argument of type X has to return
something that can be explicitly
explicitly converted to pool right now
we could go through the exercise of
looking at a whole bunch of algorithms
do the same thing and then try to find
good names for these but we're gonna
skip ahead and say we've already done
that because we have so sequences really
arrange that sequence type generally
we've been referring to these things as
ranges although again Eric people would
probably correct my notation and Shawn
parent would probably throw something at
me so basically it has something called
begin end and returns the result type of
those operations is something we'll just
call it some type it er hitter is
required to be an input iterator mean at
least in this algorithm meaning that you
can increment it you can dereference it
by the results at consol value reference
and then predicate is the sorry function
is actually interesting because it's
unary predicate but not specifically
just they're not generally just any
predicate it's actually a predicate on
the value type of the iterator their
returns to the return school the
predicate so we can actually write these
things like this this is this is what we
have weight actually write this guy out
so requires range of our the input
iterator there sorry range is a concept
input iterative concept and predicate is
a concept the things in blue or alias
template aliases or alias templates
alias templates that provide access to
to some of the required operations it's
just notational these are actually
pretty easy to define yeah no it doesn't
because if you had a former range base
for loop that for every element X you
wrote start every x equals 0 so you're
assigning to every element then it
doesn't need to be it doesn't need to be
readable get the right it's different
requirement
so still a bit verbose we're gonna we're
going to work on this as we go all right
so the question is how do we actually
define these things unfortunately we
provide support for this so if you think
that I'm going to sit up here and start
talking about five traits no we are not
doing that today all right so we
actually did end up adding language
support to help you to find these things
I go through a bunch of slides pretty
quickly so in concepts light a concept
is simply a named constraint it's
basically a very much one of two things
it's a variable template whose
initializer is a constraint expression
or it's a no Larry function template
with a single return statement that is
all that's also a constraint expression
so we have some fairly some fairly
draconian restrictions on these things
concepts are interesting because they
don't actually get instantiated ever it
turns out so you can't explicitly
specialized them you can't you can't
partially specialized them you can't
explicitly instantiate them it is a
single definition that defines they
constraint on template arguments that's
the only way it gets used it can't be
recursive they have to return bool other
things so this is how you would actually
specify a concept as a variable template
with concepts light we actually ended up
adding a new a new expression here which
I'll talk about a second so ready
concept is now a declaration specifier
it means that the following declaration
is going to be a concept which has
special meaning and special restrictions
I can be applied to function templates
can be probably too variable templates
it can be applied to nothing else not no
member function template either not even
sad all right this thing is a requires
expression so this is a new a new
primary expression in C++ grammar
basically this is going to introduce a
set of requirements the the parameters
here given as T range or simply provided
for notation to help us write these
constraints they are not actual objects
they have no life time they have no
linkage it is purely to convey actually
how many guys are familiar with deck
eval
this gets rid of deckle Val the only
purpose for that was to get rid of deco
Val because I hate it oh alright so we
have two different types of requirements
in this concept the first one is a type
requirement so basically if you write
type name something that requires that
when you substitute into that something
you get something that names a tight you
basically get you get a type out of it
so if you try to substitute if you if
you if you try to ask for the iterator
type of an int for example hopefully
this type doesn't define anything you'll
get a substitution fail which would be
effectively the same as false these
things in curly braces on the left they
wrap an expression so the it's braces
expression arrow type these are valid
expression requirements when you
substitute into a valid expression
requirement if that doesn't return a
valid expression if that doesn't yield
something that actually compiles which
is kind of a not a great way of saying
that it fails right so again if I if I
ask to see if begin or end of zero is
true then those end up being false yes
in this case its standard you can do
that with with some extra namespace
stuff yeah Brazil type is convertible
250 yeah yes no next all right so this
is what it would look like you're
defined it as a function here no the the
expression or left must be convertible
to the type on the right
so I can have an example of a type
requirement on the slide yeah yes it can
be a concept no that's not implemented
because that requires the more advanced
auto stuff that's often influences yeah
so you can say begin an arrow arrow
input iterator for example that works
out okay what auto yes sure you can I've
just said you can iterator type is a
type of alias type here that's an alias
it's not not a concept if you wrote
arrow input iterator of tea we're sorry
actually if you wrote arrow input
iterator semicolon that would say the
result type must satisfy it is something
that satisfies the constraint of
requirements of that concept you can do
that there are no examples of that in
this time yes for all intents and
purposes let's go with no you can
actually write it inside of a requires
clause so you end up with requires
requires and I left that in there on
purpose as a way of punishing people who
want to do that but no requires Clause
is not valid anywhere outside the scope
of a concept there's a very very good
reason for that which is that you have
no guarantees that these will never be
able to compile anywhere outside of a
very limited context of life
so we put a giant box around them and
say you must do these people are you all
right so this is what it looks like if
you don't define it as a function excuse
me and obviously the next question is
well why do you have functions and
variables and it turns out that we
actually started with functions because
that's just what C++ at a time there
were no variable comforts and we started
this and actually it turns out that if
you do use functions for concepts to
define concepts you get things like
being able to overload on on template
parameter error T so you kind of like
equality comparable of tea equality
comparable of tea and you works out fine
you really want to you can write things
like equality comparable 04 tempered not
like non type template arguments works
out fine then we get variable concepts
in bristol and people decided they
didn't want to write parenthesis so we
ended up making those concepts also now
you have two ways of writing it happens
just another quick example the concept
this is the predicate concept just to
show that these actually work Marietta
templates so predicate is a its concept
the first argument is your function
object or your function pointer or your
caliber or whatever RX just a sequence
sequence of things you want to try to
call with it and so if you want to know
if you can call pred with RX you right
you know pred of orange dot I thought
expands and if when you substitute that
turns out to be valid then it's a
concept of satisfied if not then it's
not yes I could put one in I just didn't
because it's it would push it off the
side of the slide I'm making I'm making
some some sacrifices for readability you
would have you would of course use the
notation that you want to use that you
actually need for your concepts and I
believe that you're going to end up with
some forwarding in there although I'm
not a hundred percent sure I'll you know
actually now that I think about it maybe
not maybe not right it's never run so
our value x value GL value might not
matter
if pred only takes our value reference
parameters then I think that you would
that's a good question I'm not sure yeah
I don't know I'll have to think about
that one yeah so it's move only types
you if you if the type of ours is
actually rough wrap then these things
get pushed down and I think you may
actually synthesize the right types in
the expression but you would actually
need a move or a forward to cause those
to propagate into the into the wood note
yeah yeah in fact we actually do that
with move with the move constructor
stuff so yeah you do need moving forward
in some cases all right so now we have
this interesting question what happens
now we have this nice new fancy support
for for defining concepts how does this
play with the Diagnostics well again you
know obviously you can't call hall with
those values because we completely
misunderstood the documentation function
and we actually get some very
interesting output so for example this
will actually tell the you that the
concept range of int is not satisfied
because with these values this is not a
valid expression that is not about the
concepts that are the Diagnostics that
you get out of concepts are extremely
extremely precise because we can define
them like this there's actually special
notation that exists in the language
allows you to reconstruct error messages
that reflect precisely where the
failures actually went wrong of course
I'm line unfortunately this green
statement doesn't actually show up
anymore i changed the way that things
are processed and it kind of slipped
away it used to save this so i don't
feel too bad but it'll come back and we
can actually do a lot better i designing
diagnostics has never been an easy thing
it's actually quite difficult if you've
ever tried it figuring out what to
diagnose and how much to diagnose and
then what the right way to say these
errors are are
we can be fairly difficult but the one
thing I can tell you is that if you have
requirements like this has to be
convertible to that T must be
comfortable to you and you fail that
that actually shows up in the error
message int is not convertible to stray
so we can actually pull the diet
messages directly out of this those
constraints yes requirements it will so
currently we will diagnose every failure
from any any requirement of a constraint
so it'll do a full analysis and if you
actually go grab the current version and
run this code you'll you'll see a bunch
more stuff in there that I've kind of
taken out because I don't know like
where it's coming from it it just
remember slips into the slips into the
output so I need to go back through it
with a comb and make sure I'm getting
the right stuff okay one of the other
one of the other things that we get with
the concept keyword is actually sort of
an odd thing we get the ability to
actually recognize concepts in different
places than just as part of an
expression so now we're actually going
to make this simple right now one of the
new features that comes in with a with
concepts is to go to take the consult
the concept name and use it to declare a
template parameter so if I have a
function called sort I can just say
sortable container and that says this is
basically going to be type name T
because that's our concept the sort of
container constant could be defined and
the meaning of that is actually just
going to be this so two colors typename
tea and into the observable comparing
see so it actually just it introduces
the parameter and then checks it a nice
shorthand declaration and it's precisely
equivalent if you declare one and then
you declare the other they are actually
redecoration of each other yes
they can be used with template template
parameters can be used with non type
template parameters ya see cannot be
deduced to be a nova you reference type
in this case because it'll match it does
in forwarding and concepts do not
actually play very well together because
of that that that little adjustment to
the the forwarding rule means that you
sometimes get L value references or cons
diwali references in your constraints
and it doesn't it can break things the
reference type isn't you know copy
constructible so things break you
basically need an alias type to strip
away the L value reference system and
forward that into the concept
unfortunately I thought about it I chose
not to do that because they're there may
be cases where I actually went that
reference type to be preserved like if
you asked for coffee constructability
you want to say come on T rep and if you
automatically strip it away it's it's
lost its I I admit that that's one of
the things that it's kind of like
bothering me about about this but it's
okay for now yeah I'm sorry in your
people oh yeah oh yeah right right yeah
and
right yeah outside currently that's
actually true but remember i'm going to
point out that the shorthand notation is
not a replacement for the template
syntax right there are still templates
that we want to write that don't this
doesn't really work that well I have a
better example so if this is our
declaration we can go ahead and just
lift that first constraint up and get
the range of our and then I think the
next one we probably want to work on its
predicate so that will just look like
this right oops no we seem to have lost
a little bit of information because it's
not he isn't just a predicate it's
actually predicate on the value type of
the range and so in order to specify
that you just kind of you do this and so
the way that you always interpret these
things is that the declared parameter is
actually ends up being the first
argument of the constraint when you
check it so range of our and predicate p
value type and it turns out to work I'm
not I don't know if I'm 100-percent fond
of the syntax but it actually does
simplify things a little bit it's not
too bad you just kind of got to train
yourself to rethink that so question so
do we have the ability to take any kind
of declare template parameter that takes
any kind of type or were non type or
template thank you i think that i think
that you can actually do that i think
that i think that the language actually
allows you to do that yeah well you just
change predator two different concept
and you just pass it ours yeah you can
totally do that remember we can we can
define concepts to be pretty much
whatever we want there is this is just a
very simple transformation right so if
you if you want to be if you want to be
inventive with your concept definitions
you can you can actually get a lot of
interesting things out of this including
I think stripping out our value
references from afford it
lvalue references from afforded Oregon
so for example if we end up using these
concepts a lot we might want to define a
new one and this is kind of work where
this idea comes we want to get rid of
the last constraint here right so we can
actually find a new concept called an
input range or in range because it fits
better the slide this just required are
to be arranged and it's iterator type to
be input iterator and so then we can
actually lift the entire set of
constraints into the declaration one
shot so now range is defined as in range
or and then this predicate now sometimes
we have lots of algorithms that have
exactly the same kinds of requirements
and the exact same kinds of template
parameters so we actually figured that
you know if we're gonna well why bother
continually Rida clearing the same stuff
over and over and over again what up hi
P so we went ahead and added notation
that allows you to actually declare
essentially to reintroduce a concept or
constrained set of template parameters
and that's that's this notation it's
called the concept introduction so all
none in some or all of any of some of
your or none of your business standard
library they all have exactly the same
template parameters they all have
exactly the same constraints so we can
actually use this notation to just sort
of skip over the usual template
declaration header now query is nothing
spectacular so it's not very interesting
just it's just a concept declared here
is a function and it just requires our
to be so it has two parameters RMP
requires our to be a ten range in the
again the predicate so basically this
stuff that stuff and then this
declaration of all is actually exactly
equivalent to this one so it just expand
whatever you so when you introduce a
template through a concept introduction
and declare a temple to a concept
introduction you basically end up
reading all of the template parameters
in in that concept locally for the the
following declaration and then the
entire concept name acts as a constraint
on those parameters now it might seem a
little bit odd that we would do this
like how many how many times does this
actually happen like this does this give
you any big savings it turns out that
yeah it does you guys know how many
algorithms are different flavors of
algorithms in the stl like this what 110
algorithms I think 112 something like
that you know how many different
variations there are the weekend that we
can do this with like a dozen yeah yeah
yeah yeah yeah we sort of reverse the
usual everything kind of we were looking
at the syntax for like well we could
just make it look like a macro where you
would sort of do you know query with
parentheses and then it would sort of
expand the same way we ended up with the
braces because it was too macro e you
don't want to confuse people although i
think that's that might end up using
others who had a computer question okay
yes you cannot forward to Clara concepts
concept must be defined at the point of
declaration yes no now we have not added
another Turing completely no no and I
will tell you why that that constraint
expression is based on a very very
simple logical language that does and
understands and then it understands or
that's the only thing Zoe those are the
only things that you can reason about in
the constraint language inside of the
compiler that we will it will never be
turning it will never even approach
being turing-complete because then you
get to this weird like undecidable logic
and you can't effectively do overload
residence yeah
I'm sorry to disappoint you if you're
looking for more ways of writing GCD or
something like this so if all of that is
still too verbose for you then you can
Steve you can actually use a concept
name it's a type specifier so if
sortable container is a concept that we
can just write sortable container see
and this will actually that means this
pretty straightforward and of course
that means this and all of these
declarations are exactly equivalent
they're the same thing it's just
notation now it is to sort of mirror the
features that we get an auto same idea
right so we can declare f of some
concept you can declare a vector of some
concept and then a function point are
taking taking another concept and
returning at some concept and the
meaning is basically the same as you
would have before except you're just
lifting the constraints in these case so
the first one some concept just becomes
a constraint T this becomes a constraint
t so you have a vector of this and this
one becomes essentially that so again
very simple transformation very
straightforward really nothing very very
difficult about this yeah well be so
just adding constraints to a declaration
does not make anything crudely correct
you still got to get your pen and paper
out and work through the actual proof of
correctness for that and there there has
been some work on actually supporting
and to some extent reasoning about the
correctness of code specifically based
on on a definition of concepts in fact
this is a Gabriel those races woman
that's down the road down the road this
this will not do that yeah
well no because this is implemented in
GCC you could use GCC to know I mean C++
is already hard to parse you can't you
can't parse C++ without doing contacts
lookups anyways you have to consult your
context if you want to know your next
parse this just this builds on the same
system yeah or what oh yeah yeah these
can definitely go in namespaces an alias
oh no no I think we had that question
earlier as to whether out if a
constraint mentioned an expression in
some other namespace should that
namespace be pulled into the set of
associated namespaces and I think the
answer was no and I saw a thumbs up in
the background so I don't know I'm still
leaning towards no just because I don't
have to do any more work all right so
the goal of the shorthand is just to
simplify these things we want to make we
make simpler things simpler and you'll
probably hear talk on that tomorrow if
you have a CBR de don't don't think this
is a replacement for template syntax
please there are certainly ways that you
can use this code to make your of your
stuff worse like a lot worse like this
which is exactly why it went to sort of
all instead of predicate or instead of
with the all thing yeah so you can do
that sure it works instead of instead of
this being a type it's just the deckle
type of our yeah it's pretty right don't
do this this is not a good use of not an
effective use of shorthand notation
please do not do this if I see in a
mailing list somebody say Andrew told me
to write my programs like this I will
find you
we'll have words all right one last
thing that I'm going to get a bunch of
questions on we have a rule that if you
declare two variables with the same
concept than they have the same time or
two parameters the same concept that
have this angel now I know I know that
you think well Otto doesn't work that
way why doesn't this follow the same
rule that auto tunes and I will just
point out that Otto is magic and we can
define it to have whatever meaning we
want when a user find name is actually
used as a type you generally don't
expect that type to change mid
declarations right if I say void f int
int that name it doesn't have different
meanings between the death birth within
the first parameter the second parameter
I would be very surprised if it did so
this rule exists specifically to improve
consistency with with piping we want
these things to look like types in when
they're used yeah wrong you're wrong no
good I actually had a slide with said
but and then it came across the giant
words wrong no I'm serious this this is
the way it is this is actually a good
idea so there was there was a paper last
year from boton de bello and myself that
was proposing an extension of this
notation to allow you to differentiate
these things it turns out the syntax is
completely incompatible with concept
introductions don't tell boat on yet so
we need to adjust the syntax of it but
it would be a be a tiebreaker forces and
it's actually it's not bad like you just
put a new type named after the concept
like you could write input iterator I
don't like colon T inputted right or
colon you and then they would have
different types yeah
they would be different yes because they
have different spelling other okay so
the rest of this talk is about
overloading and specialization the
interesting stuff so concepts
light-sports two different methods of
sort of opening up opening up a
definition for extension one is
refinement you guys this is probably the
most familiar for you the other is
generalization I should probably call it
corset because if you have a fine and
coarse a nice opposite anthon them but I
stuck with your nose so refinement you
end up strengthening a concept by adding
additional requirements right so if we
have if we have an input iterator or if
we can define a bidirectional iterator
by taking an input iterator and then
adding adding to that set of
requirements for decrement yes well
technically they're both true but yeah
forward iterator sure we're just
skipping forward iterators today they
don't exist okay so if you think about
these things in terms of their sets of
constraints and by sets of constraints I
mean if you if you dig down through all
of those concept names all those
template IDs and you pull out the
individual requirements that show up in
in the requires expressions those are
the requirements that we're talkin these
these sort of very atomic like here's a
fragment of syntax it has to be valid
here's a type name that has to be valid
here's a conversion that has to be valid
those are the sets of constraints that
we're talking about is that these atomic
constraints then we can actually think
of the bidirectional iterator see I'm
continuing with this no forward
iterators then we can kind of think
about the this refinement has actually
just being the Union set union of these
sets of constraints do not confuse this
with the different sets of types which
kind of an interesting dual relation
these are sets of constraints it's easy
to do I confused myself sometimes also
right and so we can say the
bi-directional iterator refines input
iterator because it has more constraints
it's it's an input iterator forward
iterator plus a little bit more you
think about it that I know that this is
clearly more than this union picture but
I I like the soup
now this is this is by far the most most
common types of extension you're going
to run into and I say by far and I
really don't mean that this happens all
the time like the number of cases of
refinement actually existing the
standard library is really not that big
there's the iterator hierarchy there's
the container hierarchy see I mean
technically there's copy and move and we
can make a hierarchy out of that too but
yeah it just does it doesn't happen all
this probably with some of the threading
stuff I'm not very familiar with it yet
so i would need to be educated they're
so generalization is actually a little
bit different so here we have actually
weaken a concept by removing removing
constraints so for example I might
actually just fine iterable as a
container or a range and I'm not really
removing constraints I'm just taking the
disjunction of these things but it
definitely defines a week or concept so
here it herbal is weaker than either
container or range if you think about it
and assume there's a way to
differentiate out a container in a range
so if you if you think about it you know
container has some operations arranged
has some operations and some were in the
intersection of those those sets of
constraints we have we have beginning in
right now that disjunction actually
defines the concept the sort of unnamed
concepts at the interregnum concept the
intersection of these two sets that's
what this is about that's what
destruction actually does here it's not
really used very commonly so why did you
support it well because it was easy and
because it turns out we think it has
actually very useful applications
especially when you talk about bridging
libraries together so if i can define an
algorithm that takes you know a set of
types from your library an Isetta types
from my library then instead of trying
to find a new concept that refines both
of you just say well it's either this or
that and let you know sort of what the
users figure it out so we think it's
going to be used I will point out
however the heavy use of disjunction
actually comes with a penalty compila
fine penalty the the algorithm is
required to decide these things for
overload resolution for specialization
can be
quadratic I could which is exponential
it grows but we haven't seen this be a
problem in practice yet just just don't
define a concept to be like at the the
lowest level you know a or b or c up to
30 or 40 things that's that's probably
not a good idea don't define is integral
as int or care or don't do that alright
so why does all of that mad well it
turns out that it matters them because
we actually want to be able to overload
and specialized based on these things
and the rule that we actually use to do
this is actually based in logic it's not
it's not really set theory it's actually
its logic so if we can determine if a
compiler can determine that for some
constraints see whenever some
constraints see is true we can determine
it d is also true then c is a stronger
constraint than B or C refines d and if
you guys go get elements of programming
by stepping off that's exactly how he
defines the fines for fine as a logical
implication so this actually lets us
extend to to do some very interesting
things oh and I will point out that an
unconstraint template you know just
template typename t whatever is always
less constrained than any other
constraint it's the it's the least
constrained at all so for example if we
wanted to find advance we can do it this
way you just you naturally define it in
terms of the concepts that you want to
use so there's an advanced for inputted
reducers and events for bidirectional
iterators and for random access
iterators and each one of these is you
work down that hierarchy that refinement
hierarchy it either weakens the
precondition of the previous one or it
strengthens the postcondition a
bidirectional iterator the bidirectional
overloaded weakens the precondition for
advanced it allows you to go backwards
you can actually advance by negative
numbers the random access iterator post
condition of the effect is that it
happens in constant time and then when
you call these things the compiler
actually compares two constraints of the
algorithms to figure out which is the
best given those arguments so if i have
a linked list and i get an iterator to
and I advancing so the input iterator
overload is valid
the bidirectional overload is valid
bi-directional iterator overload is
valid the random access iterator i
should say viable the random access
iterator is overload is not viable
because list does not provide random
access iterators and so between the two
that we have left input iterator and
bidirectional iterator we have to choose
the one that's just the most constrained
so we actually look and actually compute
logical implications on these things to
determine whether or not input iterator
implies bidirectional iterator or
bi-directional integrator apply it
implies input iterator and turns out the
latter is true and so that one gets
select similar idea for template
specialization here i have an
unconstrained base class or
unconstrained sorry not base class
unconstrained primary and two
specializations CLS directivity is going
to come back so we actually have a real
complex number with some concept real
and i have an integer complex number or
goucher integer and again these are
specializations so for any
specialization satisfying those
constraints the compiler chooses which
one is most appropriate based on the
satisfy constraints it's actually easier
in this case because real an integer are
disjoint they don't there's no overlap
there better not be any other wise you
always get ambiguous cases all right so
taking advantage of these ideas and this
is only a very topic of discussion of
that stuff but taking advantage of these
ideas actually requires you guys to
think about the sort of the way that C++
deals with specialization as a whole and
figuring out where concepts actually
fits into this mob right so the way that
we actually do it today this is c plus
plus 11 and 14 or whatever so if the
most general we have kind of like any
type now below that we have sort of
specialized types and concrete types of
the very bottom this is my this is my
usual pyramid of specialization it well
triangle specialization all right so at
the top we might have you know template
with type in mt or auto so something
unconstrained it accepts anything and
for the specialized type we can think
about patterns you know I think we're
back to these questions these are these
are you know is this a case of that he
star as a pattern vector t is a pattern
in the very bottom we have concrete
types and if you're actually going to
build a function that has overloads for
each of these you can actually work out
a specialization relation because if you
declare a function takes an int star it
will always be called mana taken in star
or any other point or T star that'll get
called and then for any any arbitrary T
that'll get so the specialization
hierarchy is built it so where does
concepts fit into this any guesses gaps
between that's why I left space there
right so more specialized in any type is
a constraint type more specialized in
any constraints but any special edition
of constrained specialization so if you
think about type name T here than in
this case we might have a template
parameter declared with the concept in
the shorthand notation or instead of
auto you might just use the constraint
type specifier Khan or any requirement
of the form requires concept of tea so
these are one step more specialized
injure than then sort of abstract or
generic types specialized types are the
same constraint generic types we can
actually start adding those concepts to
the types inside of there and so you
build it layers out like this that you
can actually add sort of syntactic
requirements to pattern so you can
actually build these very interesting
hierarchies again concrete pipes yeah
yep and it'll variety of the algorithms
no you you you do specialization by type
first and then if you have any any
leftover candidates that are still
equivalent Lee as specialized then you
start comparing constraints so you
always do my type first and then you go
to constraints all right so how do you
actually use this last last couple of
slides I promise this is the value type
type I like this one so if the base of
this is basically just going to be a
pipe trait it's it's a primary template
its unconstrained it has no definition
would be like leaving off definitions
what we don't have associated types we
have a definition for a constraint type
so I'm assuming that there's a concept
or something called member value type
this guy is just the more specialized
version of this that should
I should say using a type name t colon
colon value type I apologize and then
for specialized types for built-in types
like pointers or arrays we can actually
define these things as a match against
the pattern and so if you call this for
any type you get nothing if you call for
some type that happens to have a nested
member associated value type it'll pick
that one and if you happen to pick it
for pointers it'll always pick the
pointer over the specialization so you
can actually define this type trait very
straight very simply by reliant on sort
of this idea of how concepts and types
interplay in fact that's actually the
way that origin does this the order
language all right so concepts light
briefly very suddenly does this stuff i
will mention that it actually does i did
mention that approves compile times in a
kind of weighted test unfair cast and
there's a whole bunch of stuff that i
actually left out for a good reason
because then i'd have a third hour to
talk or fourth and I'm getting kind of
tired so I didn't talk about what makes
a good concept I didn't talk about what
makes a good generic library these these
are these are topics that can very
easily fall out of this discussion or
follow on this discussion new
programming gotchas they they happen all
the time there's a whole host of new
features that people are going to mess
up or the people are going to confuse
and do the wrong thing I mentioned a
couple of those I have no new and clever
programming techniques for you
fortunately there's it's it's there's a
lot here and there's a lot of there's a
lot of room for people to figure out how
to do things the right way and going on
how to do things the wrong way so maybe
next year I'll come back and tell you
what I've learned in that in the past
other questions yes
Oh virtually zero yeah I don't care yeah
no i don't care i'm not interested in
haskell type classes i'm not interested
in java generics or C sharp generics I'm
interested in solving the problem that
sequence process was that not the answer
you were expecting well I mean that
happens that happen in the in the 2000s
right we had C++ select concepts that
was actually based on a really rigorous
study of other programming languages
language other program languages
features and that work had been done so
where's the value what's the value of
meat we doing it was good work but I
didn't see any to continue down that
path other questions yes I hope fingers
crossed here I don't know about clangs
plan but if you ever see herb talk about
planning for visual studio it always
concepts only shows up in the bottom
right or so I strongly of the opinion
that Microsoft will be working on an
implication so if not already I don't
know details yes I actually knew that I
didn't know if I could say it so yeah
yes yeah right technically you can use
both at the same time I do not recommend
it unless you absolutely have to yeah
yeah it looks weird yes laughing right
you I ask that one more time yeah well I
don't auto just expands to an empty set
of constraints like it's just it invents
a template parameter and then there
there no constraints associate of it so
you can actually mix and match you're
gonna have you can have constrained type
specifiers like the concept name and you
get them auto and you have another
concept name so you can it's just it's a
very basically just turn a crank
whenever you see one of those you create
a template parameter if there's it's a
constant its concept name then you
generate a constraint that goes into a
requires clause if you if you've written
auto so if you've written auto you can
actually stick a constraint after a
function after the after the declaratory
echo type to refer to the declaration
you can do that other questions yes
yeah you can give me you can write
negation so you can write not whatever
but there's no there's no like deeper
logical meaning to it it's not we don't
we don't actually try to negate a
syntactic requirement it just takes it
takes it as an atomic it takes the
entire negation as an atomic expression
so it's either true or false that's all
oh yeah you can you can negate things
substitution thing a substitution
failure is always a substitution failure
yeah yeah you can't you can't recover
from that how he really this did not
substance fail substitution it wasn't
something right all right any other
questions yes well Howard so what would
that expression look like you'd have not
some expression if the entire thing is a
substitution failure you don't know it's
not a piecewise substitution failure of
expressions so you don't end up you
don't what right right yeah substitution
failure is a final value in that that
that logic love turtles yes
it's the other supported there are some
interesting rules with them I didn't I
didn't talk about them because or not
it's more time it's just there's a lot
of stuff there but yeah there you
definitely write very attic concepts you
can you can also declare very attic
template you can declare our template
parameter packs that are constrained you
can declare template parameter packets
constrained by a very edit concept it
interplays reasonably well yeah yep yeah
the only the only thing that I would
have to say about about doing that is
that if you if you end up writing very
attic concepts the the checking
mechanism is almost certainly going to
be some kind of template metaprogramming
to do any kind of interesting like
overload resolution based on that it
just becomes true or false anything else
all right well then I guess I'm done
thanks for coming I hope you guys
learned a lot
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>