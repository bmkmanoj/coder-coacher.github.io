<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: Marshall Clow “STL Algorithms - why you should use them, and how to write your own&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: Marshall Clow “STL Algorithms - why you should use them, and how to write your own&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: Marshall Clow “STL Algorithms - why you should use them, and how to write your own&quot;</b></h2><h5 class="post__date">2016-10-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/h4Jl1fk3MkQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay let's get started my name is
Marshall Clow I work for Qualcomm one of
one of my jobs is that I maintain the
the C++ standard library implementation
for LLVM Lib C++ I'm I also work on the
Standards Committee defining what it is
that this that the C++ library does or
can do or has to do or must not do
anyway one of the things that various
people have talked about in the last
several years is using standard
algorithms as in your code and just see
this okay and I'm going to talk a little
bit about that and then I'm going to
talk about the advantages and
disadvantages and then I'm going to talk
about extending the list of algorithms
that you have available to you by
writing your own anytime if you have any
questions about this just put your hands
up and I'll try to answer them right
away occasionally I will add answer them
with hang onto it I have a slide coming
up about that but mostly I'll ask them
right away the other thing is this
there's a fair amount of code in this
talk but none of it is particularly
intricate it's it should be fairly
straightforward and easy to understand
also all the code on in this
presentation compiled and ran
successfully at least once before I
pasted it on the slides and started
inking with it to make it fit so it
worked once okay so start with what is
an STL logarithm is tail stands for
standard template library not Stefan
kilala web just to disambiguate and this
was a proposal back in 92 or 93 by
Alexander stepping off and a couple
other people to basically help generic
programming in the C++ standard library
and that proposal was picked up and
incorporated into the standard library
so really we should talk about just
what's what is
standard library not the standard
template library because one
incorporates the other and there haven't
been separate since I think they it was
adopted in 94 okay
so what basically we're going to talk
about algorithms what is an out what is
an STL algorithm it is a templated
function it is a function template that
not an OP not a class that you can
instantiate but rather a templated
function it does something useful
something you might want to do in a
generic way and also very important it
has a good name on the standard library
gets to squat on on useful names like
copy and find and erase and remove and
things like that so when you're doing
your stuff you either have to put in a
different namespace or give it slightly
less generic names there are a bunch of
collections of algorithms besides the
ones in the standard library there is
the boost algorithms library which is a
collection of useful IRAs there's the
the Adobe source libraries ASL that have
another collection of good algorithms
and there are probably I'm certain there
are bunches more that I don't know about
you know hidden in in code bases that
are not open source or just I don't know
about them I haven't heard about them
and so there's a lot of different
algorithms out there so why should we
use an STL algorithm why do you want to
use this instead of writing it all
yourself I mean right we didn't go into
software developers to be software
developers to use other people's code we
we know wanted to write code right so
the STL algorithms are carefully
specified and had been had been
implemented to be reasonably efficient
they have they've been debugged they've
been tested on a wide variety of
platforms
certainly for lib c++ when i check in a
new version of you know countif or
something like that there are 30 bots on
ten different architectures that go off
and and run a bunch of tests and come
back and scream at me if i broke
they also the the algorithms in the
standard library tend to be very very
basic their building blocks you can
build other algorithms on top of them
and including them and this is really
nice
also in general you writing code using
these algorithms is easier than writing
them yourself there was a conversation
with Chandler just this week was talking
about working on a particular chunk of
the LLVM path optimization chain and he
was he was working on a particular data
structure and he writing some code and
looking at it's complicated and he
realized that he had just he had just
implemented poorly his word not mine
okay just so you think I'm not slamming
on Chandler even though he's not here
because he's got to talk right now
he had implemented poorly STD partition
and he said once he realized that and he
replaced a big chunk of code with a
called STD partition and then did the
stuff that was not perfect you know and
the not part of partitioning his dataset
he was much happier his code was smaller
it was easier to reason about it was
easier he was more confident that it was
right yeah it's easier to review later
so I have a chunk of code here actually
I have two chunks of code here the white
code the two pieces the pieces of white
code are the same the pieces of green
code are different can anybody tell me
what those two pieces of green code do
they're separate okay I heard somebody
say bubble sort and that is in fact
correct this this is an implementation
of bubble sort so if you were looking at
somebody's code and you came across
either this one or this one which which
do you think you'd rather see if you are
doing a code review and one of your code
workers presented this one or this one
with you to you
which one do you think would be is
better which one would you rather review
which one is easier to ensure yourself
that should ensure for you to ensure
your eat assure yourself that is correct
convince yourself that it's correct okay
I look at this up here and I look at
this thing here where it says I is less
than equal to V dot size then right
below J is less than V dot size minus
one and I wonder why are those different
is this actually is this code actually
correct what's going to happen here if
Isis over to one element array or a no
no air element array and I have to go to
a lot of work I have to I have to spend
a lot of cycles thinking about this and
maybe even pulling it out and running it
through some tests to convince myself
that it's correct this one on the other
hand I can I'm pretty sure it's correct
I look and make sure that the right
parameters are passed to sort if there
was a comparison predicate here I'd look
at the comparison predicate make sure it
it actually defined a total strict order
or weak strict ordering and then I'm
done just for your information I did
pull that code out I didn't write that
myself I googled bubble sort and found
an implementation online and and slap it
in there but I I stuck it in a test
harness and ran it against a few test
cases and it is correct
it does sort things but that's it
doesn't actually fill me with confidence
to see this now I have to spend a lot of
effort trying to convince myself that
it's correct
okay so we're going to get some examples
of algorithms the simplest algorithm
this may be the simplest algorithm in
the in the standard library min it takes
constants --is two constant references
and returns the lesser of them it
returns returns B if they're equal so
well a couple of things to take away
from this this is very general it
compares two things of the same type it
has a couple operations here that you
have to have to be valid on this type
you have to be able to compare them has
to be able to do a less than um because
we're passing references here reference
reference return a reference we don't
have to worry about copying them we
don't have to worry about you are these
default constructible or anything like
that all we need is to be is to use less
than on them there's also a version of
actually there's not I'm thinking of the
one but this is a very simple algorithm
it has very little little very few
requirements on the type T the Center
library prefers to minimize the use of
that minimize the list of capabilities
that it imposes on the objects it
processes in general less than and equal
are used as opposed to say greater than
or equal or greater than or something
like that
which means sometimes you see the
conditions if you read the read the STL
code or that the algorithms code you'll
see they go through a couple hoops to
use less than instead of greater than
well you know less than is just greater
than equal to turned around so it's not
really that hard to do it just sometimes
is a little bit awkward and on iterators
which will which we'll see in in a
minute
we took the standard library tends to
use not equal and pre-increment
okay here's another one
copy this may be the most most used
algorithm in the standard library copy
it takes two different kinds of
iterators and this you say input
iterator and output iterator but then it
didn't fit on the slide so I adore a
Witter it takes to it to input iterators
that denote a range and an output
iterator to write to and again it uses
this interesting for loop construct to
avoid having to do post increment you
could write this is while you know while
first is not equal last star res plus
plus equals star first plus plus but
then you'd have to use output iterators
are not out excuse me got output eaters
but post increment on the on the
iterators and we try to avoid that on
their hand the compiler will in fact
generate pretty much the same code the
compiler will will generate very
efficient code for this even though that
the the phrasing of the for loop is a
little bit awkward so what happens here
now what do we what are we doing here
with with these operations we're
comparing iterators we're incrementing
the iterators two different kinds of
iterators i order an order and then we
are we are reading from this we're in
directing both of them but we're in
directing and reading from first and
we're writing to res and then we're
returning res by value so we have to be
able to copy it out put it earlier um
how many were you of you were in
patrick's talk this morning up in the
theater at nine o'clock he spent an hour
building up a theoretical basis for
iterators so he talked about copy a lot
but you know this is the nice thing
about this as Patrick pointed out this
morning is you only need one copy if you
push the traversal and the writing off
into the into the iterators then there's
only one copy algorithm and it works for
lists it works for arrays it works for
vectors it works for file streams it
works for whatever I mean there's
there's a very
a very neat trick where you can have a
you can you have a sequence and you want
to print it to the console you say copy
from beginning of sequence end of
sequence and then you pass it in and
Ostrom insert iterator and it just
copies them to the o stream inserted or
it was puts them out on the console or
writes them to see out say okay any
questions about min or copy its in think
so so let's write our own these are not
going to be horribly complicated two
second algorithms there's designed to
more to just show you these are the kind
of things you can do yourself and I I
expect that many of you have written
more complicated ones already you had a
question the question is why is the why
are the input iterators here the the
input is why are these not consider
ators um well there there's two kinds of
cost for iterators okay there's this
iterator is a constant it or you can't
do anything with it so this would be
cost space iterator and then there is
containers you know have two kinds of
iterators they have iterators and
constant or ease those are constants or
iterators and those are two separate
types it's a Const plain iterator is
different from a constant score iterator
and the reason is the reason is this
doesn't say constants because these are
template parameters here and you can
pass a concentrator here just fine what
your what what you're not expressing it
but but since you would have to you
would have to specify in the input
iterator that this is something you're
not that cannot be written to well it's
not that you can't write to it it's just
that we're not going to write to it so
it doesn't have to you don't have to
pass a Const iterator here it's just the
fact that we're not writing to it in in
this algorithm
could be a it could be a writable
iterator we're just not writing to it it
does it doesn't help with performance
now that was the other area the
follow-up question who does it help with
performance and no I don't believe it
does okay so we have a which I'm going
to talk about a made-up algorithm called
adjacent pair so we have for each for
each you give it a sequence and a
functor a functor is something that's
callable that's that's really the
definition of functor it can be its me
lots of things but basically if you can
call it like a like a function call then
it's a functor you know if you if you
put a pair of friends at the end of it
and and pass parameters to it then it's
a functor anyway adjacent pair what it
does is it calls it calls the functions
not just one for each does it for each
element adjacent pair would do it for
each pair of elements and when I say
each pair I mean pairs next to each
other the sequence so if you had a
sequence that was say 1 3 5 7 9 the
pair's would be 1 3 3 5 5 7 7 9 okay so
let's think about this for a second and
you say how would you write this okay
and fortunately I have done so so let's
look at a couple of things here we
talked about again up here this was a
much longer name when I started but
didn't want to fit on the slide so I
used FW iterator for forward iterator um
this this is a template name a template
type name doesn't actually have any any
enforceability but it gives the reader
an idea that yes I need forward
iterators here because we're going to go
through the sequence more than once it
takes two iterators a sequence two and a
function to call and basically you drop
an iterator at the beginning
and then March them through the sequence
one in one element of time advancing
them both so that that we have one three
if ends mode three five five seven seven
nine and that's about all there is we we
passed the the functor ex gets the two
elements from the sequence because we
dereference the iterator on how that
actually happens depends on f because
the template function it might be that F
takes these by by reference by
consequence or by value or maybe F takes
them x takes some related type and there
are implicit conversions there it's in
any case that all just works one of the
things I want to notice you notice here
is we have up here if first is not last
because um you you want when you write
your algorithms you want to make sure
that you handle degenerate cases you
handle the simple cases correctly you
know copy right if you say copy from an
empty range what does copy do it does
nothing it doesn't signal an error or
anything it says you gave me nothing to
copy I'm going to copy nothing and now
I'm done adjacent pair for each you say
for each of an empty range and here's
this functor it calls that functor for
every element in the adjacent in the in
the empty rage ie none of them and so it
calls the function o times adjacent pair
handles said as well it if you give it a
zero element range it calls a functor no
times if you give it a single element
range it calls a functor no times
because there are no pairs um so you end
up calling calling the functor with
pairs you know n minus 1 times for an N
element sequence you know 1 3 5 7 9 has
four pairs in it again this is not that
not a rocket science algorithm ok this
is not you know solving world hunger or
you know optimizing assembly code
would or anything like that this is a
very simple algorithm we're just going
to do but it's it's to illustrate that
you can write an algorithm that does
actually something significant a few
lines of code and if you have a need for
this functionality you can pick this up
drop it into your code base and use it
the idea is that you as you go along you
will build up a set of algorithms they
may be very general algorithms like copy
or sort or something like that or they
may be specific to your business or the
problem yours hat you're trying to solve
but the point is is that you can
abstract them out a little bit make them
more general use them in multiple places
you can once you've abstracted them out
they're easy to write tests for you can
write tests and make sure that they do
the right thing in all the cases empty
single element multiple elements and
then you have confidence then with in
using them and then you start seeing
things in your code that looks like this
do I have I think my laser has died
anyway things like you know call to sort
did i mention by the way that it's
important to give your algorithms good
names because there's a lot of semantic
meaning behind sort everybody knows what
sort is supposed to do
ok everybody knows what copy is supposed
to do you mean we have to read the
documentation to discover exactly what
copy does but you can look at that in a
chunk of code and you can see that that
it's going to copy something or it's
going to sort something it's going to
fine something okay so giving yourself
giving your your algorithms a good name
instead of say Q and X 1 1 3 7 is a
again helps with understanding when
you're reading the code or you got there
hard ah thank you thank you Howard
yep oh now mine's working in thank you I
was put it up here because it will
probably fail again anyway
so again writing writing important names
writing good names no useful names names
that convey meaning is is a big part of
this okay how about this what if we
wanted all the pairs not just the
adjacent ones how would you write that
algorithms similar problem slightly
different and when I say all the pair's
I mean say again we have one three five
seven nine one three one five one seven
one nine three five three seven three
nine five seven five nine seven nine you
know all of the pair's but not nine and
one basically all the pair's
irrespective of order now we're
wandering into combinatorics here but
that's okay anyway so we have here we
have for all pairs okay and it is the it
starts out the same because we want to
do we want to not do anything quietly
successfully on a empty sequence but
what do we do here now we we have two
nested for-loops we still drop the
trailer but we go from this loop so
basically updates the trailer and this
goes for the trailer to the end so you
get one three one five one seven one
nine and then the trailer gets
incremented the next time you get three
five three seven three nine three five
three ZS seven three nine and it gets
again five seven five nine and so on
obviously this is an N squared algorithm
this you know this is because there are
N squared
possible pairs in a thing of size n all
N minus 1 squared but that's okay
this is an order N squared algorithm and
it is not really much different if you
go back and look at the structure of
this it's basically you're adding we're
adding another loop down here
it's a different algorithm but it's
related so let's see any questions so
far
yes yes if you have questions please
don't wake them I believe that the these
adjacent person for Paris will not work
if the sequence is only two elements
believe it will not work if there's only
two elements yes because then after plus
plus first first shows the last and the
first look one start or am I mistaken so
in fact if there are only two elements
two elements after you pass was first it
will point to the second element now
so the will head will have first first
post bus and and last remember last is
one past the end okay so I am mistaken
no worries yes
I could have specified on funked more
precisely by using STD function and say
that it takes two parameters of a
particular type I certainly could have
but um this actually accepts a wider
range of factors in particular it
accepts things that have where the where
it may have multiple parameters that
have default values or things that it
takes parameters of types that are
implicitly convertible from whatever I
pass it to whatever it accepts and
certainly there are places where that's
a good idea
if for example you don't want this to be
a template parameter um then you could
you know then you because standard
function gives you type erasure you can
you can plot pile a whole bunch of
things into a standard function that
takes two parameters of particular types
but this is more flexible you certainly
can pass a standard function here other
questions I'm sorry the question was D
is the reason I use it first not let non
equal the last as a person first less
than last ah because suppose I'm working
with say a list okay with forward
iterators they don't define a ordering
of the iterators i mean less than will
work if i'm working with raw pointers
well okay if i'm a list you know a node
might be here and au might be here and
oh by here
there's no ordering of iterators in
general random access iterators may have
ordering but forward iterators and
bi-directional ones do not all right all
the only thing you really get with non
random access iterators is equality not
equals
okay more algorithms these are ones that
that I have had need for and written in
the past copy while this is actually I
wrote for the boost algorithms library
it basically you give it an input range
and output and a predicate and it copies
things from the input range to the
output range until the prep as long as
the predicate is satisfied so if you
were just say you know give me a
predicate that says these numbers are
odd and you give it one three five seven
nine it will copy the entire arm the
entire input sequence but if you give it
one three two four six it will copy the
one and the three and then stop and
return and leaving that the input
iterator leaving the input sequence
pointing it - now there's a the first
time I wrote this I had a bug well let's
let's actually go over the code right
well first is not last and predicate
first copy okay so except for this this
P first this condition it looks just
like copy so the first time I wrote this
I just returned the output it area
because that's what copy does and
somebody pointed out to me that how do
you know how far in the list do you got
as you've tossed away the input iterator
that you've modified and this is not
important for input streams input actual
input iterators things like streams you
know single path streams because you can
recover the iterator from the underlying
source they say it'd be a an if' stream
or something like that but if you're
traversing a list or a string or
something like that you have no way of
knowing how far it got in the in the in
the sequence and so instead now I
returned a pair of iterators the the
input iterator the modified inputted
area which points to the first thing
that wasn't copied and the outputted
rare interestingly enough when Alex
Steph and I wrote the papers about the
original paper is about the STL one of
his guiding principles was don't throw
away useful information
in your algorithm if we turn it back to
the users they might throw it away
return it to the caller they might throw
that information away because it's not
useful to them but you should not make
that decision for them you should in
fact return it to them because they
might need it and then he put copy n
copy underscore n into the STL which did
exactly that did just like this it
advanced an input one of the iterators
and places and then threw it away and
didn't return it so I feel a little
better that time that I'll accept but
I've made the same mistake I would
doesn't mean I'm as smart as him not
even close but I'm glad to see was a
little bit glad to see that this was not
something that I some mistake that I
made up all on my own but anyway um a
real simple algorithm this is three
lines so many three lines of
declarations and three lines of code and
if you need something like this paste in
your code base and use it there are a
whole set of related copy algorithms
you know there's copy if write copy all
the things that that the predicate
matches that goes to the end of the of
the sequence copy while copy until you
know and various people have needs of
those um you can decide you know if you
have a set of these you can decide
exactly which one is right for you and
they're easy to write this one's a
little little trickier and it's actually
not really complete here um because
there's lots of interesting design
decisions here that I chose not to do to
in to keep this on a slide but this is
split it takes a pair of iterators and I
and a value and and a functor and it
basically searches for the value in in
the sequence and it calls the function
s-- basically this is you know splitting
say a string
on commas it finds the comma passes from
the beginning of the string up to the
comma to the functor and then start
searching again immediately after the
comma for the next comma and calls the
functor again and continues until the
string is exhausted so as it finds it
calls first found always calls the
functor every time it searches because
maybe you know you may even if you if it
didn't find a comma you've got the stuff
at the end of the string and then if if
it got to the end of the string then it
breaks otherwise
excuse-me goes around again lots of
things you can do here okay this
question is what's the best control
structure here do you want to really
call a functor do you want to pass an
output iterator which can which is given
the pair of iterators so it can write it
into a container Gore would probably
argue that you want to do this with
co-routines some kind of stateful
operator I don't know
also you can generalize the matching
functions here it doesn't have to be STD
fine that finds just a single value you
could say find one of a set if you
remember STD string has these these
calls for fine first of and find first
not of you could pass in a regular
expression you could pass in a sequence
you know you could separate things by
ABCD there's all sorts of things you
could do here this is a very simple
implementation of split and yet it's
very useful and very general Beaman Oh
Patrick loosers
good point
he Patrick pointed out that you want the
we want these to be forward this first
and last to be forwarded readers not
inputted Raiders because find requires
forward iterators you certainly can't
advance it and then say here here's the
sequence that I've destroyed yes demon
mm-hmm so um right
what Beeman said is is that when I wrote
find I my comp and and based on what I
said use thinking that fine find really
could be a customization point and you
could pass a second functor in and have
it search on those and I actually have
thought about that especially since we
have Wow and see if I saw so you have
these search algorithms that implement
various search a little different you
know we have these search objects that
implement search algorithms and yes you
can certainly do that what I would like
to see actually if I have written one of
these and and stashed it away because I
got busy with other stuff that takes
yeah takes a a searcher algorithm rather
than a value and actually put a couple
more besides the ones that are in the
C++ 17 standard yes oh absolutely fine
might be a very good default right one
of my searchers the searchers I wrote to
test this was something that took a
single object and just found it and
called STD find on right it is a good
default especially since you know you
you're breaking up a CSV string with
commas say or something like that
question here
oh the question is do I need a tea here
or can I write it er : : value type I
could write it er : : value type I
believe but at the same time that
actually precludes some interesting
certain some some possibilities for the
searching there if you have a searcher
for example that takes can do
heterogeneous stuff we have some of that
in map and so on where you where you can
do if you if you did that then the
conversion would happen here at this
calling site as opposed to happening
here say or maybe not at all if if the
searcher hat was polymorphic and so by
putting that by using T you you put off
that decision and maybe you know give
the user a chance to not actually have
that conversion happen at all I thought
I saw somebody over here
no okay down here in front and then your
next why is that the function passed by
copy instead of by by reference or
something up or by perfect forwarding um
because a perfect forwarding um mostly
because that's what most of the of the
standard library does the newer portions
of the standard library can pass it
either by value or by perfect forwarding
I tended to match since since I was
doing things like copy and so on I
tended to match that that would be
that's an interesting little project to
do to research those and see what the
actual difference is and we need to need
to do a survey of a bunch of code bases
to see you know do we do people
routinely call these things like this
with big stateful functions that are
expensive to copy if because if they are
if they do then yet by a by a forwarding
reference would be a good idea
would would help a lot but if they don't
if they're usually function pointers or
lambdas with minimal captures then it's
not going to make a difference so that's
something I ought to look into thank you
you had a question over here yes is
there any reason to be concerned that
found would never be equal to last okay
so let's let's start with ten that
actually happen okay um so every time we
go through this through this loop this
this will return something at that is at
least first right okay if if we get to
last we're done otherwise we we we move
past the thing that was found so we are
we're advancing through the sequence
every time through this loop okay now
even if even if first and found are the
same we're still going to advance
through the loop now if if you cannot
get to last by incrementing first over
and over again you're going to get stuck
in fine but you're going to get stuck in
in all the algorithms in that but it's
one of the prerequisites of basically
all the sequence algorithms in the
standard library it's in general if you
passed out first in the last of an input
sequence um one of the requirements is
that last is reachable from first I mean
if we go back to we go all the way back
to copy same thing if if last is not
reachable from first yeah then then this
is not an okapi is not ever going to
return find is not ever going to return
potentially okay how we do I've got 20
minutes okay let's do copy while did
split all right general guidance for
writing your own um somebody said once
so hunger is the best slice makes your
food taste really good when you're
hungry
same thing here right what you need if
you find yourself needing
something needing a chunk of code to do
a particular task now and and you've
written it in a non-generic matter look
at it think about it for a little while
you say is there is there some general
solution hiding in here that you can
tease out you know it can you tease it
up make it a little more general so it's
applicable in somewhere in some other
part of your codebase
if so pull it out a little bit make it a
little more general it doesn't have to
be Universal you can you can have
algorithms that you know have a bunch of
requirements it has to be like this and
so on the more general you make them the
more widely applicable they are and so
the it's more likely that people other
people will use them but you don't want
to do that at the cost of efficiency you
want you know you want your algorithms
to be quick because then there's more of
advantage to using them than to roll
your own also step rise refinement write
it try it make sure it's correct look at
the code we factor it think some more is
there a better way to do this sometimes
you realize that the problem you're
solving is different from what you
thought you were solving and so you end
up with you end up with something that's
like well this is good but this is this
is not the problem I really want to
solve and then you say darn and you say
okay this is there's a bigger problem
here waiting to get out I can make it
more general just like this and it
solves my original stuff and a lot of
other things but I mean how many people
if were here was it a couple years ago
for B Arni's keynote or last year for
Sean's talk and he talked about the
algorithm called gather the history of
that nobody ok I'm gonna spend a couple
minutes talking about gather because
who's my algorithm I got hired into
Qualcomm to work on Eudora which is an
email program which is now dead and but
it had a couple cool features so it was
a nice email program
tough to compete with free when lots of
people are giving away free email
clients but oh well one of the things it
had is if you hold down a modifier key
and click on a name in a mailbox it
would pull all the emails to that person
if it was sent or from that person if it
wasn't a sent mailbox together it would
basically impose a custom sorting order
it would pull them all together and if
you click if you held down that key and
clicked in the subject field it would
pull all the messages with that subject
modulo we and forward and so on is
really really nice and I've never seen
any other email client do this it was
like you could pull an entire
conversation together and it lefted them
selected which then you could move to
another mailbox or something like that
you you click on the date in the in the
date column and with all the messages
for a particular day these kind of
things anyway so I started thinking
about that and it's like that sounds
like a useful algorithm and so I went
off and implemented it and I called it
gather and I looked at it and I looked
at and I showed it to Shawn and it was
like this is a nice little algorithm and
he looked at it and said yeah that's a
really good idea I can use that and he
looked at it some more and he said you
realize this is just two calls to
partition don't you and I said I hate
you Shawn because what it is is you have
a click you have a point really clicked
right an element there and so you have
now you have two halves of a section you
have a beginning and end of the messages
and you have a point where you clicked
and so what you do is you take the first
half of it from the point up and you
partition the messages you can actually
call stable partition so it keeps the
relative order and all the messages that
match a predicate which are like have
this subject come to the end and then
you do this again with the the other
half except you invert the predicate so
all the messages that match the
predicate come to the beginning and you
end up with all the messages you want
right there in the middle and everything
else is in the same order it was before
and I was doing it with you know swap
and rotate
and so on and he said two calls to
partition way too easy and it turns out
that partition does the exact right
thing if you give it an empty range and
all that stuff so if you click on the
lots you do this on the last message in
there or the first message in there it
just works so you want to you know you
want to think about what you need you
want to make it general but then you
want to make it you don't think about
how can I make this better is are there
tools that will help you with this and
this goes back to Chandler the the
anecdote about Chandler you know I wrote
partition poorly there are lots of you
know you can use the existing algorithms
as building blocks you know in here I
used STD find as a building block but
yeah if you can find Sean's talk about
about STD gather it's he's got a really
nice explanation about it and are not st
together just gather it's not in the
standard library and and he's got
animations that show exactly how it
works I think that was last year I know
that be Arnie used it in his keynote two
years ago at the first CPP con anyway so
other typical tips you want to handle
degenerate case as well okay you don't
want to force your callers to check and
make sure that they don't hand you an
empty sequence or four pairs at
something that has one just do the right
thing figure out what the right thing is
and do it when we define a set of
predicates in the standard library for
any you know any of all of none of and
you give it a predicate question is what
does it do if you get an empty sequence
all of returns true because everything
in the sequence matches the predicate
and so on and just you need to figure
out what the right thing to do is in to
it be aware of the operators you're
using when I talked about I talked about
one of the other ones you know we talked
about
papi sorry we there was talked about
what operations we used on the iterators
what operations we use now the value you
know min is that Minister nice small one
it only uses less than it doesn't do any
copies or anything like that doesn't
have any iterator doesn't inclement them
you worry about your complexity you know
is this a is this a login is this an N
log in is this an N squared n cubed
heaven help you and think about iterator
categories or people here familiar with
iterator categories I mean I know
Patrick is because he want work that
work through them this morning but we
have you know we have input iterators
and forward iterators and so on and
bi-directional and so on you think about
iterator categories do you do you want
to work with input iterators right we
have problems with inputted raters is
they basically they model a sequence you
can only pass over once sometimes you'll
end up having completely different
implementations based on the iterator
category Lib C++ for one for one
algorithm for find end actually has
three three different categories three
different implementations one for random
access iterators one for forwarded
raters one for bi-directional iterators
because you can do things more
efficiently if you have more inclusive
more category more sorry capabilities
some of the some of the algorithms like
the for iterator version of equal for
example or is permutation or so on
perform much better in simple cases on
random access iterators you know is
permutation takes two sequences and says
is this one a permutation of another
this is an expensive operation it's
basically N squared operation but if you
hand me a pair of random access
iterators and I can determine that this
one's three elements long and this one's
four elements long I can tell you right
away
not not a permutation of them I don't
even need to look at any elements I can
tell you that random access iterators
give you constant time calls to STD
distance that tells you how big the
sequences
and so so yeah if you if you know what
your iterator type is you can sometimes
do much better so let's look at adjacent
pair again and this was right we have
forwarded readers so we drop an iterator
and say great this is the same code as
before okay but somebody says no no I
need you to make this work with input
iterators and so you say okay and you
think about it for a while and you
realize that you can write something
like this rather than dropping an
iterator you can save a copy of the last
value and use that for your comparison
now I just want to point out that this
is effectively copying the entire
sequence one element at a time into this
local variable and you have to actually
figure out what type this is so I'm
going to introduce something new that
probably most of you are aware of but
I'm going to talk about the standard
library has this this this type is
templated class called iterator traits
that tells you things if you give it an
area tells you things about the iterator
it will tell you what its category is
what kind of iterators at random access
is input is output and so on one of the
things that will tell you is what is its
value type what what do you get back if
you dereference it okay and so you can
write this type name stud iterator
traits input it area value type jump and
that is the right type and that will not
you you you won't have any conversions
here and so on
now of course in C++ 11 14 years right
auto but it's important to know what's
going on there you are in fact copying a
value out of the sequence and saving it
away so you are effectively 1 don't each
time through that each time through here
here and then here you are copying the
value if this is a stream of characters
it's just not a big deal but if it's a
sequence of things that are expensive
and big and maybe hold things that are
or even if they're not copyable then
this isn't going to work and so you
somebody says to you you want this to
work for input it areas this is going to
be mostly more expensive than the one
that works for forward iterators not for
me to say that that you shouldn't do
that you know your situation is
different from mine is different from
his everybody's situation is different
and maybe you need this functionality
but at least you should be aware of what
what you're asking for or what people
are asking for here question over here
um are you allowed to dereference
employers more than once before
incrementing them I believe you are the
question was are you allowed to nd
reference input iterators more than once
between incrementing them I believe you
are but now you're going to make me go
look certainly if you are not you can
introduce another local variable in
hearing and fix that but I have to go
look let's pretend that you can because
otherwise it's not going to fit on the
slide it's a good question though so the
question the other question is how do
you choose an implementation again
iterator traits is your friend array or
traits inner iterator category is it
names a type and the type is one of
these things a set of tags that are
defined by the standard library there's
input iterator tag and forward iterator
tag and bi-directional iterator tag and
random access iterator tag and also
output it or air tag and so and there's
an inheritance relationship between them
they're all subclasses of each other
which means if you say you say you take
a forward iterator tag that will match
up against a bi-directional or random
access and a forward but not an input
iterator and so you can add template
specializations based on that and you
can this is called tag dispatch and you
can just patch based on them so here
here's chunk of code here's a couple
chunks of code declarations actually
this is the this is one that takes
forward iterators most in the web I've
named this imple okay for implementation
forwarded Ori or forward iterator
forward or forward iterator tag this is
the original implementation okay we did
saw 2015 slides ago input iterator input
iterator same thing inputted Reiter tag
this is the one from a couple slides
back and then adjacent pair introduction
to digit return adjacent pair included
first last F type name iterator traits
iterator iterator category open paren
close paren C++ 14 you use open open
squirrely brackets closed scoreless
wiggly brackets but you're constructing
an object of that type and passing it as
a parameter now these are empty structs
they're the the constructor is a no op
they are if only they would be size zero
if only we had size zero objects that so
they're going to be one byte long or
whatever your compiler decides is the
size of an empty struct so they're very
cheap to construct as in allocate some
space they're very they don't they don't
have any member functions
they're just types that you can use to
choose an implementation and this this
technique is used all throughout the
standard library when you have to have
different implementations based on the
iterator type and we were at the end and
we have about five minutes for questions
so anybody has any questions okay over
here
um so you're looking here you have two
increments trailer equals first oh um my
thought is is that if I were going
suggesting another way to do this to to
do an assignment as opposed to two
increments here right in here um I do an
assignment versus a sign trailer to
first and then increment trailer and I
don't know I would have to measure to
see which is which is which would be
better which would be faster this this
is a pattern I'm very familiar with it's
used in a lot of places it's so it never
even occurred to me that doing an
assignment and then an increment might
be faster
Beamen says hand up
so let me let me try to summarize what
Beeman said I think I got implicitly I
got the impression that you think that
the difference will be small but but in
particular he said that that the he
thinks that that any difference here
would be dependent on what version of
the compiler was and if that that if you
in fact had a had a noticeable
difference that it was going to it might
disappear the next time the compiler
upgraded their optimization strategy
which is that a fair summary I think
it's clearer to write there but but that
maybe just because that's the
formulation I'm used to hmm hmm I don't
know
- over here about 1 than - is there any
reason that these algorithms like this
and a bunch of the other ones in the
standard library cannot be made Const
expert and the answer is yes for some of
them and no for others and the follow-up
question was are there any plans for
making them con sexpert and yes there
are you won't see that in c++ 17 but you
will see that pretty soon afterwards
there were some people playing with
stuff at the last standards meeting
basically trying it out and we
discovered that some library
implementations were at the current time
were not amenable to that and that other
compilers other Lamentations were
amenable that but they managed to crash
their compiler so so there was no real
happy happy implementers there there was
that the one people who were feeling
pretty good about their library but
their compiler crashed and their other
people who were looking at their library
said oh I got it I got to do some work
here to make this context / but but if I
just hack something together my compiler
was happy with it so mmm there's another
question over here
yes
one more behind split yes ah um Wow
good catch the question was why why is
there a post increment on result here
when rather than having it up here in
the loop because if you go back and look
at copy it does a pre increment on the
output iterator here which is more
general I mean this copy while yes
copy while puts imposes an extra
requirement on the outputted read must
support post increment thank you other
questions all right thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>