<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Edouard Alligand “C++: How I learned to stop worrying and love metaprogramming&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Edouard Alligand “C++: How I learned to stop worrying and love metaprogramming&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Edouard Alligand “C++: How I learned to stop worrying and love metaprogramming&quot;</b></h2><h5 class="post__date">2015-10-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/u_8MMuVFz_k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome and thank you very much for
coming here if you have the wrong room
now is the time to flee this talk is
going to be about meta programming it's
a practical talk and the main concept of
this talk is to tell you how I got into
it because I'm a C++ programmer like you
not a researcher and not a professor I
was a bad student to be honest and the
reason why I did programming meta
programming they are practical and of
course there's also the taste of maybe
some time trying to do some puzzles but
if I do my job bad I get fired or the
company goes under or I don't know so
there are very practical reason behind
it if you think about meta programming
you can think about people in a big room
doing serious stuff like because
programming is hard so meta programming
must be meta hard right as you're going
to up a technical guess with the French
that technique doesn't always work as
you expect it to work so how I got into
it my background is I'm actually a
kernel developer system programmer so my
main tool was C for a while then I
switched to C++ just to get this from
typing and also because I like the
generic approach of programming it was I
think 10 years ago or something that in
2006 some day I was working in Germany I
was doing file system drivers for
Windows NT and also files file system
driver for FreeBSD and things related to
a virtual memory management the
constraint when you're working on this
project is your software has to be
correct obviously because every program
on the operating system is relying on
you and it has to be fast because
so you have the two generally opposite
constituents of having a correct and
fast program and the point of the first
contact I had with general and not
generic programming metaprogramming is
had a colleague told me about boost
static assert you I was like because in
system programming you have like tons of
asserts in your code because you can't
sometimes debug your progress so to test
your hypothesis you put asserts
everywhere like I think I should have
memory actually think I should have
stuff so he told me about booster you
cathode and I said what's a booster you
can cert it said it's an assertion at
compile time and I said what the point I
don't care about assertion a compile
time he says yes you care imagine that
you could check for the size of an
integer and then I said whoa this
awesome why it's awesome because very
often with drivers you have like oh I
think this device is little endian and I
think my appendix system is began yet
and actually I'm wrong and so we can
start to check at compile time like
macros and that kind of stuff and you
have the feedback about your hypothesis
when you compile which is immediate it's
not even it's not before you run a test
or you write a test it's when you
program that you have a feedback and
that's actually probably the first thing
I did is to go back to my programs and
do that kind of things and that's how I
got started it's actually the first the
easiest thing can do and ok so you get
into you meet a program what do you do
next so it was 10 years ago
imagine that yeah boost Atticus all work
very great and it's impressive because
they even managed to have some sort of
meaningful error message within template
metaprogramming is like wow yeah they
managed to have a feedback as you can
see in C++ 11 you can even specify an
arbitrary string we're going to see
examples about checks you can do in your
program and you are going to build from
it we start from the checks then we will
go to something more advanced like
computing stuff at compile time and then
we will write programs that generate
programs that general programs that
generate programs that at some point end
up being a program that is run by the
user what I do since 2008 I work on a
database and again the constraint is to
have something that works fast and it's
reliable and it's very painful to debug
like you have I don't know about report
about it oh when we had 100 terabyte of
data and we do this we have a bug okay
try to reproduce that if I'm not going
to talk really about the product you
have a question about it you prefer to
ask but this talk is not really about it
but the contest is everything I'm going
to talk about in stock is actually from
this software project something that we
did decided to do and we decided to do
it because it was useful called project
it reduced it reduced maintenance cost
greatly we had less bugs we had very
fast code and at no cost and we're going
to see what no cost meaning one-time
cost not the cost for required some
dangers obviously so what do we do with
this and what can you do with it so
first thing as you can see checks went
compile time checks and you it's
concepts are coming ok concepts are even
more advanced way of doing it
but right now today you can do compile
time checks with a tablet
metaprogramming
and something more advanced than just
the size of an integer
you can't generate constant at compile
time like you can have something you
know we will see a concrete example of
this later you can have generate parser
it's I should have been to your file
Cousteau he talked about doing
domain-specific languages there is the
famous boost spirit library will use it
and it's compiled time protocol change
up I think might be moot is broken
protocol generation and we have even our
own serializer which is done on compile
time that is we write the goal is to
write a very small amount of code I have
the compiler work for you because anyway
in front we welcome the five days four
years so the poem is just forget about
what you think you know about meta
programming today with I mean I'm
working and we're working with visuals
to do 2030 we're working with clang
we're working with GCC we compile on
freebsd linux mac OS windows 32-bit
64-bit even our platform I mean we're
talking about concrete whiskers it
compiles everywhere it works everywhere
and we have very very very small amount
of default we see that we C++ 11 a lot
happen in the language that makes it
very easy and it's not longer about
having tons of tons of an understandable
error messages and it's doable and if
there's only one thing I would like you
to give today is that you go back and
you say ok I'm going to try something
today on my code with those techniques
because it's possible it's easy and it's
there's no the entry cost has been
lowered and you're doing C++ already so
you already used to do crazy stuff
so yeah the compile-time no longer - no
longer - we'll see about that
going to also to talk about labor we
that we've done with joel falco template
metaprogramming library instant compiled
time so it doesn't exist anymore yes if
you use C++ oh three metaprogramming
library yes it takes about two days to
compile your code but now it's instant
compiled time you go to spirit actually
you go to every recent version it's
instant compile time so this is no
longer a problem and even if it were
compile time is cheap compared to
development time so just not a good
argument cut code complexity the yes
this was a good point no longer the case
I think Oh kids advanced C++ right I'm
not going to say that yeah you it's the
you should start with C++ with template
metaprogramming no but it's manageable
compiler support today I think it's fine
even if you can switch to if you can
have even if you're working on windows
piece of studio you can do even 2013
works fine and 2015 works even better
and clang it's a table and the only
thing that happened I can think if
you're working like an embedded projects
and your stick with the very old
compiler then in that case okay I if you
paint for you and you can't do it skills
just go to my talk and you have the
skills just invest time if you can on it
but it's really manageable and then
there was this known rational reasons
about her have to go out of my comfort
zone I it's not what I like blah blah
blah doesn't matter just just do it it's
cool
what is it okay very quickly if
programming is about writing code and by
compiler I mean all the set of tools
that are going to generate a program
okay this is we could say this is
programming
metaprogramming then would be good
compiler
maybe could maybe not if you like it's a
static assert that fails there is no
college that the nation' instruction you
sent to the compiler compiler again and
then maybe binary nothing special and
the question is why do it because then
you could say that if this is better
than this right why why make things
harder and there are actually real
reasons because the compiler is more
clever than you are
I'm not trying to insult you in any way
but it knows everything it that it's not
possible you know everything that it
knows it optimizes better it's not lazy
that is if you have to generate the code
that takes 100 of remember structure of
100 members are you're going to say I'm
not going to type all of this and it
does it for you it will not do mistakes
like typos there is no typos in meta
programming
well there is typos in your meta program
but and once it's right it will not do
typos because Oh at some point I'm was
wrong and I did it's not the way that my
function is called or anything doesn't
happen and the question is actually
makes you more efficient that is if you
sum the time do you spend learning meta
programming and then the time you go
faster we after is it worth it like if
it takes ten years to go ten percent
faster of course not worth it but it's
not a lot of at the end of the talk you
will be able to write a small metal
programs I assure you you go out of
there and you'll be able to do it so
it's one hour and okay well maybe a
little bit more because then it doesn't
work like in the talk what happened what
what's it
nads magic trick check you know you
watch tutorial video and the guy says
yeah so you want to learn to play the
guitar
and he does this this and you try to so
it doesn't work so you see it's easy and
actually my ID is concept the philosophy
behind is is everything a computer is
able to do you should not do because
your job is to instruct the compiler the
computer to do work it's not to do the
work compiler can do and everything the
compiler kill the computer can do Jerry
does it faster and better than you to go
back about in other things you don't
with meta programming there are a lot of
hints you're giving to the compiler that
enables him to enables it yes I don't
know to do very aggressive optimizations
and each showed up in our code at the
end of the talk as see about the most
advanced stuff that we did it's a shame
I realize now should have burnt marks in
it about what we managed to do we have
actually a serialization code that takes
a structure it analyzed it and it
generated the serialization could for it
and if it detects that it doesn't have
to do dynamic memory location it will
only use a stack which is if you want to
do it by hand it's not possible you
would have a lot of ifs at one time like
Oh in that kind of structure then I can
do it generate the code at compile time
and so it's super fast okay you want
code I feel it okay so all my examples
are based on the library we've done
withdrawal
it's called Grigor so what's a polygon
it's a thief poor whatever you want to
call it we have a lightning talk
tomorrow
and the library is available on github
boost software license feel free to do
whatever you want
I used this library because it makes
everything easier it's not really about
to show off especially although maybe
and it's very lightweight template
metaprogramming library okay so the
first thing we're going to talk example
between a list it's not really a list
mathematically speaking it's a list that
if you want to be pedantic it exists so
you write this in C++ what happens the
compiler would say okay I'm going to
generate the instruction to move the
stack pointer make sure that you have
some room and then I will going to feel
the memory are we are with the values
you gave me and that's when you run your
program you have this in your memory so
this is one time this is C++ what about
metaprogramming template metaprogramming
what is a list in terms of
metaprogramming it's not a topo let's be
clear about that it's a list of types
what's the list of types it's just a
type hope I'm not losing you it's just
and the reason in memory is zero there
is no instruction in your final code
there is nothing only thing where it's
going to happen is that the compiler is
going when it compares your code to
allocate a list of types and said okay
you you declared this type okay I
understand but then when it's going to
generate your code what it's actually
doing is nothing and the question you
might be asking so what the point of why
she what are you saying you think that
you're going to write code that is
useless and doesn't generate anything so
how is it going to help me concrete
example why you would want to have a
collection of types so in this case it's
a set not a list it's a set it's exactly
like a list with the same difference
between us to list and to least
understood the set and what happens is
where is it universal
oh yeah you have to learn Russian to do
the template metaprogramming so yeah
that so you have to spend five years to
learn Russian and that's why all these
guys or these people are Russian or
maybe sometimes French yeah you're
afraid ah so you have a set of types and
what you want to do you have a function
and you want to say okay this is a
generic function but I want to have a
very specific explicit message so in
this case what do you think you're do
this is not correct what you're doing no
it says and you don't want to have two
hundred lines of arrows you want your
program to stop immediately because you
want it to say no I only want my
function to work with the type I have
set here and although it might be a
little bit convoluted just see that as
tool you have now in your toolbox keep
that in memory and see then later how
are we going to use it so you have a set
of types and you want to function to
make an error when it got something out
of the list and believe me this kind of
trick had to last because then you have
you can do whatever message like oh of
course I added a little joke here but
you can have a message oh if you have
this error it probably means that you
forgot to declare the function somewhere
else and it's 100 billion times better
than a comment because nobody reads
comments give you example of after about
comments and the compiler doesn't
understand comments so if you're not
rigorous after commanding someone and
you team some at some point is going to
not update the comment you see is not
dislike so again in the C++ 11 you have
better tool kit for our types trades a
tickly in the standard so YouTube asked
toolkit that is if you just open your
text editor you have your C++ 11
compiler you don't need to include boost
you don't need to include anything and
you already have type traits which
provides you with many many useful
functions like
I want to know if my type isn't ago in
the circle and so like like we have is
it need to go yes I know I need an
integral type and you have integral
constant to say oh okay you could do
static constant int something to do the
same thing just to show you the ticket
and so you have your factory function
with okay the factory function is to be
useless in that case but just to show
you what you could do so Han comments
and template metaprogramming no that's a
bit fast but we've seen what we can do
with types so I guess all of you in your
programs at some point you have magic
values especially if you do audio or
images at some point you have constants
or whatever and in that case I wanted to
do something simple is like factor in
five say at some point you start your
project and you say okay the magic value
is factor of five I will make 120 factor
five and you put a comment because
you're good programmer and you want to
the people working with you to to know
that and then somewhere later you
realize oh no it's not the correct value
the current value is factor of six but
you forgot to update the current and so
two years later there's burg someone
wizard says but what no seven but what's
the good value so someone is going to
spend maybe lose a couple of hours just
to understand waste but maybe it's not
there but wouldn't be better if you
could just write this because if you do
this assuming that your factorial
function is correct then there is no
error you don't even need a comment and
I'm not saying that you should not come
at your code
I mean comments are good but it's even
better when you don't have to because
it's absolutely obvious what it does in
that case it's okay my value
I read the code let's say I'm Lea
bugging the code I have no idea what's
about okay so the magic is factor of six
okay fine and when you want to change
you don't even have to either be math
genius or use pocket calculators
okay now the good value is factor seven
just change one value in its correct
no possibility for error and it's again
the whole idea of template
metaprogramming is just to have a seed
and let the compiler grow the tree
that's why I had tree image further it's
you what you do is just design the cedar
say okay I want you to do this and this
but I don't care about how you do it
its job of the compiler it's my IDE just
do it so how to program a factory
function to do template metaprogramming
is i think you have to understand two
concepts the first is different between
compile-time and run-time so we saw that
with the lists so what's the difference
between a list of values and a list of
types and then it's an to understand
recursion but since you're programmers
you should somehow understand recursion
you have this you could you have all the
intellectual tricky to do it
so in that case recursion is okay factor
we all agree that it's a way to define
it so it's template and it's I'm going
to multiply with the value means the
values 1 and at some point I have to say
when do I end my recursion and to end
the recursion what you have you use
template oh yes so you just say ok for 0
I want you to do something different
for you I want you to reach n1 and just
to show you that I said a lot of things
earlier about o it compile instant leads
do you see a cut you don't see anything
ok it's going to be dessert studio 2013
suggest a crappy laptop
going to be five a thing okay so it's
absolutely not what I want to do I don't
know what it's doing what did I do
it says we compile yes so just loading
and you see it's very fast it's not like
oh I'm going to include a lot of stuff
and I probably think it's going to be up
see it's just so it's a very simple
program and I just funning not and also
so you see it's very fast it's easy to
read no include except toys I think yes
so very very simple and so if you work
with version earlier than visuals to
2013 you might want to a couple of rough
edges if you have used GCC and clang you
will have absolutely no problem at all
this is a very simple template
metaprogramming
let's do let's see something a bit more
advanced
this is a typical interview question at
a quasi db4 by by the way like can you
do some general
let's do type manipulation list
manipulation at compile time so you saw
that we have type of list a list of time
but the type of list is actually list of
time what about I want to write the code
that say I want the last element in my
list of types is it difficult to do so
you have what you can do is actually if
you've done a little bit of functional
programming it's like popping the head
at every precaution until you which list
which has only one element in Bregan
that's how it's implemented we have a
trick I'm not going to show you
darkus thing because as you can see this
if you have a very large list then
you're going to ask the compiler to
create a type for every mean is going to
recurse we have a trick and we're going
to make it faster but even that is very
fast and to go back at just a site side
set aside why is it faster now to do
template metaprogramming why it compiles
faster a new opinion why why do you
think sundar leads faster I think it's
because it's not I think I changed the
reason it's because of variadic because
it's not macro tweak anymore you
actually it's actually the compiler
reading you could and understand exactly
what you're doing it's no longer
generating like hundreds and hundreds of
line of C++ and then compiling it it's
reading the C++ you're doing oh okay
you're doing variadic okay understand oh
I'm good it's very fast now that's why
it's so fast if you do the same example
that we did with boost NPR it's just
slower not because boost MPL is poorly
written it's just because it's macros
generation and so we has to go through
all the time so this is how you get the
last element in the list just pop the
head at every recursion like this so you
see you have a type and then it has a
see it's not before from here and then
it says okay I get to the next point
just remove the head until I which list
with only one element then the list with
only one element the last element is my
element nothing like how many lines six
lines and you basically we implemented
back the equivalent of back and front is
obviously trivial because font is just
like here you do if I have this kind of
stuff then I return the head
you just have your basic function for a
list in meta programming language and
very small amount of C++ so what
happened is yes to go back to the
conversations product templates now if
you want to do a type which accepts
verdict number of elements it's built in
in the language no more dog tricks
according to the well it's something
about dick type yes clearly because when
you can get values it changes a lot
alias templates better traps rates and
improve compilers what we did so far is
interesting I think but is it really
useful like you say okay it's nice sure
sure it's nice can show that to my
colleague and then be clever for five
minutes
but is it going to make your program
better is it going to really give value
to to you customers because that's what
matters and customers use or whatever
and let's take a typical pattern which
is the current pattern which is a
pattern I like personally actually no I
don't like it that's why we're going to
improve it so it's basically when you
want to in our case we have the shell so
you user types come in and you get you
want to learn the comments that the user
sends which can be anything you don't
know so imagine if your server then you
receive comments and you want to run it
and every common is an object first
problem is it's easy to forget things as
you add comments it's the typical
pattern when you start with let's say
you have your program you have five
comments but of course with the last
program you're going to
more and more comment so it's typical
button when you when you add comments
you waste your time because oh yeah I
forgot to change this line and yeah I
have to inherit from this interface oh
yeah okay fine
and then what I don't like with this
pattern is that it forces you to relate
comments together which have maybe
nothing to do except that they have to
be run at some point which sucks and
then if you want to make a list of the
comments you have because let's say you
want to say help and I want to have the
list of all comments and type all the
comments I have and print help and you
have to do some work and this which I
hate
either way virtual the virtual keyword
is forbidden no code base it's I think
it's a bit weak and we can do much
better than that and we're going to see
with how with meta programming we can
remove all this form so you come and
don't have to inherit from anything that
just have to have the same aspect they
just have to provide you the user with
it's a generic programming approach so
you come in let's say in our case they
just have to have one function execute
and one can help with return the string
for the help of the common and execute
thus the actual work you group you
commands in your list so every type is
the list and then because you need some
runtime
polymorphism at some point let's say you
use a variant and that's another
powerful feature of meta programming is
you do things only once like you have
you command you write the comment you
have your list yet there is only one
place where you make the list of your
comments and you transform that list
into something else so here it's a
variant could be anything you want and
you need only once and we're going to
see so you can
say okay fine but if I make a new common
the only thing you have to do is you
right you come in like do it we write
the common and then you just add it to
the list and you can even do that in a
way that if you forget to add it in the
list it's not going to compile because
the function executes that is going to
take the comment that is run you have a
static assertion that checks it's in the
list so you you protect yourself from
your own mistakes at compile time so
which means you don't have to write
tests right now you have to write a test
and follow me so it selects lots lots of
mistakes suppressed and you need to
print all comments just do this and
nothing has to do and I think what is
very important is to have only one
location to do things and do things only
once okay that's good so let's do
something more advanced like to maximum
there's a talk just after mind about
reflection I think it's good transition
to the talk because we're also going to
talk about transition reflection
transition would it be nice if you just
write a structure and it generates Jason
and you don't have to write a single
line of code in your structure you don't
have to hear it you don't have to write
anything just write the function and you
have somewhere a function which says
which jason could be anything else just
for example could be binary data and it
would just have somewhere function
cogent json generate and it would take
from transform you function and then
generate the jason we have it
Jew and the primary series Asian because
some kind of serialization is it's
always either intrusive that is you have
to add inside your structure a function
that says okay transform into something
or you have to eat white a generic
function like outside of your structure
and it's always back to the same problem
we have with the common patterns you
forget to do something you have to we do
the same thing over and over again you
can fall easily forget for example you
create a new structure and you forget to
write the serialization comment or you
wrote it wrong and if you don't because
if you think about it it's really just
about listing the members and
recursively passing them and just
generating the code so today what you
can do to do that is to have a user
library like booze fission booze fission
ads compile time introspection because
introspection the problem is if you have
run time introspection then it's costly
because if you're doing C++ it's very
likely that you care a lot about
performance and you care maybe a lot so
about memory footprint so with the boost
version what you do is it's going to
generate all the boilerplate required
and then you can iterate on the member
of the structure so when you think that
you can iterate on the members of the
structure then you realize that you're
very close to your goal of writing
generic serialization functions and
perfect civilization would be that it's
extremely fast that the code generated
is extremely optimized because with
template metaprogramming what you can do
is you remove a lot of if because at
compile time you know exactly what you
have so if you know what you have you
don't have to check it at runtime
everything you do at compile time you'll
have to do it at runtime provided that
the compiler doesn't have a bug don't
worry
should be fine it will not allocate
memory if not needed for example when
you see realize an integer you know
exactly how much memory you need because
again you know if you integer is like
four bytes large so you know exactly at
the maximum how much memory you're going
to need so you don't have to do a
defensive programming like oh I'm going
to allocate something read my object and
know you know at compile time which
memory you need so you can just read the
first uh glue your stuff and you're done
and the code is correct because you're
going to spend some time to write the
boilerplate to read your code but you're
going to do it only once and when it's
correct
you're going to add earlier of the
structure and going to be fine no error
possible and then it's convenient
because once you've done this the other
people in your team they they don't
really have to catch it must be magic
you know I think the the best way to say
that you've done something good about
your library on your software is like
when people use it it's magic they don't
care they they just write the structure
and they know it's going to be perfectly
cellulite but oh yeah every two years
someone's going to come to you with very
obscure bags takes a lot of time to fix
but it's concentrated in one location
and the jokes is of course I have the
time to show you how to do it today but
you have all the blocks to see it's
actually good exercise you can do try
something very simple if I have some
time at the end I have actually the
source coding here I can show you but so
these are the third you say stay until
the end and a bit fast so conclusion
so what would be the reason to do it or
not do it I'm assuming that you can
invest assuming that you start from zero
that you know absolutely nothing about
it
that you really start funds you so of
course there is some time investment
that you have to do to learn a bit of
the techniques and you have to you
require modern compilers okay I'm
assuming you have that there's a trap
which is the complexity trap which is
like when you try to do it in more
clever than you are London's new thing
is anything but
oh it's fine and then you build things
which are very complex especially when
you start with template metaprogramming
in the next slide I give you some tips I
mean I've done spend wasted a lot of
days doing oh yeah I could do it like
this and tree there's always a simple
way like you want when you discover a
new tool you want to a new toy like this
you want to do it everywhere which is
not something you should do obviously
because sometimes there is an obvious
straightforward approach but I think if
I go back I mean the project is now like
six years old what did what did we gain
by doing this by choosing this approach
we started in 2008 using experimental
C++ 11 compilers and back then I mean we
had a lot of compiler crush so what did
we get
I think we gain the most is scalability
like now we don't have the problem that
the more you add code the more expensive
it gets
of course the code base grew of course
it's it's it's a large software so it's
difficult but like the serialization
that kind of thinks yeah it's fine will
you do it only once the performance
performance yeah some aspects it give
especially everything related to
serialization all the checks everything
you do at compile time you don't have to
do runtime yeah I think it shows up
there is a good library inside boost
which is a boost
meta state machine library it managed
to generate extremely fast state
machines because it relies on all the
twigs and many others because it does
everything at compile time it says ok so
this is the state transition and ok I'm
going to optimize everything and right
immediately what you want and
reliability with all those checks we
have and the fact that less code you
write the less likely you're going to
make mistakes it's as simple as that so
some tips to get started if you want to
do get started into template
metaprogramming just go for C++ 11 just
make sure you do that because it
comprised faster because you have you
start to have a good set of libraries to
do it it's more flexible with usings you
can its the code is more compact and
it's not because it's metaprogramming
that it's difficult or hard just forget
about that it's not a good way to to get
into it if you just start with your
program and you do simple checks like
like we did at the beginning of the talk
then it's safe because if your check is
wrong then okay if you're going to have
an assertion at compile time but it's
not going to be dangerous for your code
base and gives you the time to build up
the scale like you start to do least
check that my type is in the list and
then I'm going to merge lists and then
at some point you start to be good and
you say ok now I'm ready to maybe do
compile-time constant computations and
then at some point you are being put in
a room apart from the rest of the team
and because he deemed special and people
don't talk to you anymore and then
you're ready to do template
metaprogramming
and remember that your meta program are
just no more program bad habit to have
is to say oh but it's obscure and I
actually you know what's rewarding with
template metaprogramming is when it
compiles it means correct awesome right
I mean all template metaprogramming I
think is maybe one of the only library
which when it compiles means correct
because all the tests are done at
compile time so it's extremely rewarding
it's a bit of a fantasy of a C++
programmer that the only thing you would
have to do is to compile your program
and with compile it means correct and
you have nothing else to do correct
assuming that you model your IDE etc and
the specs are correct but it's what you
want to do and I think in 20 years this
is how we're going to program that most
of our job is going to be make the
program compiler and when it comprised
it's done but you have to maintain that
so don't just write obscure stuff that
assuming that no one else is going to
read them and make sure that it's
actually usable and readable and
maintainable whatever you want so the
toolkit you know I don't know why I said
clang personally I think it's maybe not
the best compiler but it has it's maybe
the one with the remember messages are
the most obvious which is very useful
when you do template metaprogramming
also it has a lot of tools like you have
compiled time debuggers the kind of
things then inside the standards you
have things like twits tuples I don't
know what I put to this and at least did
the slicer
well boost NPL if you are stuck with all
compilers sure you can use it's very
powerful library boosts Hana it's not
yet
boost I think it's going to be in 161
boost vision if you want to do like we
did inspection and more powerful things
this vision can be seen as the bridge
between runtime and compile time like
you have hybrid objects that a mixture
of compile time in like you have can
have topples you can have you can have
map which takes us a key type which is
interesting like you have a structure
and you say give me the object the
runtime object which match my type we
can do the kind of things might sound a
bit strange but just know that somewhere
in your brain and the day you need it
you said oh yeah awesome and sure feel
free to have a look at the library we
wrote do you have a lightning talk
tomorrow night I think that's 8h
something I don't know just knew I have
to be somewhere tomorrow so yeah so next
time that someone tells you yeah
metaprogramming some of your things that
today useless and I'm never going to use
it my program because it's arcane and I
think no not not anymore okay um maybe
done no in denial
it's also possible but my experience is
that it's extremely useful and for the
reasons I give so so if you have
questions an answer by the way do you
know where the reference to the title of
my talk
does anyone has any ID yes exactly dr.
strangelove so do you guys have any
question yes
okay so the question is my experience is
with metaprogramming
the problem is to debug my code to make
sure that I that I spend a lot of time
because I don't understand what the
compiler is telling me basically and
because I have a lot of indirection and
then I don't understand what's going on
so in clang you have a lot of compile
time debugger I have one tweak which is
actually might sound silly is when you
don't know what the type is by very
often you're doing your program and at
some point says no bla bla bla bla
expected bla bla bla bla so what what
you do is you take the object you have
and you try to assign it to a car or an
INT and then you're going to get an
error message cannot assign exactly my
type to int and then I okay I understand
it helps you to go back to your problem
I know there are a lot of playing
debuggers compile-time get the burgers
that allows you to somehow dump what is
inside the compiler but I never used
them what I do also is I do a heavy use
of static a source especially on the
bottom of your program helps you to have
better error message because you can
write anything you want in your
associate however it's an answer your
question yes
so the question so there's a question is
why not construct caustics per MSS
because we just do 2030 yes you right
this is the compiler we use in software
I think most of our customer banks and
although the service most of the time is
server version of software is running on
Linux or FreeBSD the client version is
running on Windows so we cannot give up
the visual studio so sorry yes but
you're right context simplifies
everything yes okay so the question is
so the question is side-effects like the
fine print magically what happens with
my object size so like I said the object
size doesn't change because you're not
creating you're not creating values
you're only creating types but however
what happens is memory consumption of
the compiler is going to greatly
increase so what you may have is despite
what everything I say because I spend my
time lying is that actually your
compilation time can grow or because
you're going to squat use 64-bit version
of the compilers it's just a must
because you're going to hit the 2
gigabytes limit of the compiler very
equally at runtime
you should have zero cost support side
effects a side effects is if you do it
wrong you can exponentially increase the
complexity of your code so that's why
you should start simple yeah so what
side effect really carries suddenly your
software doesn't compile anymore
because you using 32-bit compilers and
then it used to give us a forum and then
it doesn't go on anymore that's the most
obvious side effect I can take other
questions no the question so thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>