<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2017: Fred Tingaud “quick-bench.com” | Coder Coacher - Coaching Coders</title><meta content="CppCon 2017: Fred Tingaud “quick-bench.com” - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2017: Fred Tingaud “quick-bench.com”</b></h2><h5 class="post__date">2017-10-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mDkuJvxlF4I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Hi.
So, I'm Fred.
I'm the author of quick-bench.com.
It's a website where you can
run micro-benchmarks online.
The website looks like this.
You have this, oh sorry.
This editor on the left side of the page
where you can write some
crucial benchmark benchmarks,
and on the right you have blue buttons.
If you press one of the blue buttons
you will run the benchmarks and have bars.
We can also time it too
to run each benchmark.
So bigger bars mean that
the benchmark was slower.
Google benchmark
So you have a function, it takes a state.
And you have this Y loop inside
which will run as many times as it has to
in order to have a stable value
for the time it takes to run inside.
Everything outside will be run once
so that's where you want to
put your initializations.
We are going to try a little experiment
with a few algorithms from the stl.
First, I made a function which generates
one million random numbers
using Mersenne Twister.
I copy pasted it from sack overflow.
First the sort benchmark
will look like that.
I get my random vector
and inside the Y loop I'm
going to copy it and sort it.
I'm copying it each time
because I don't want
to run multiple times an
already sorted vector.
And as I'm copying and
sorting, why I want only
to benchmark the sort part.
I'm going to make a
reference with just a sort.
Oui, it's just a copy, sorry.
And see if it makes any difference.
And yeah, it does.
So we can completely ignore
the copy part of the benchmark.
Great.
We are going to start
with sort and stable sort.
I don't know about you,
I expect stable sort
to be a little bit slower than sort.
It is, great.
And it's not that much slower in fact,
so if you are editing
you can probably use
stable sort when you need.
Another interesting
algorithm is nth element.
For example, if you're looking
for the median of a vector
you give it a position inside a vector.
It will partition the
vector around this position
and put in the position the right element
as if it were sorted.
And it's way faster than a sort
if you're Looking for a median.
So great, it's a good algorithm.
Another interesting
algorithm is partial sort.
It does quite the same
thing as nth element
except it sorts everything
before the nth element
instead of just partitioning it.
I expected it to be
slower than nth element
and probably faster than sort.
And it's totally not.
It's way slower than the complete sort.
Sort probably we can do better
ourself by equaling sort
on the result of nth element.
Yes, so including sort on
the result is way faster
than doing the full sort.
It doesn't mean that partition sort,
partial sort is used less.
It means that you should use it only
if you're looking, for example,
two or three best result of your vector
or something like that.
If you have to divide a size by something
probably use this last algorithm instead.
So I encourage you to
test with bench yourself
and you can also follow me
on Twitter @FredTingaudDev.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>