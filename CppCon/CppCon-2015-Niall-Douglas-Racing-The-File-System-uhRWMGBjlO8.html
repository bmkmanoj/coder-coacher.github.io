<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Niall Douglas “Racing The File System&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Niall Douglas “Racing The File System&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Niall Douglas “Racing The File System&quot;</b></h2><h5 class="post__date">2015-10-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uhRWMGBjlO8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and this is a workshop on racing the
file system so I appreciate you're all
here instead of going to Andres talk
pretty amazed actually that more than
five people turned up to this material
because this is certainly not nobody
even thinks of this stuff usually unless
you're a database writer and yeah it's
you can get really mind-warping after a
while so hopefully I'll be able to cover
some of that during this this very short
hour I could do with about three hours
and even then I could barely scratch the
surface of the fun that his file systems
but I'm this gonna be a workshop so it's
gonna be very very straightforward very
simple and if we run out of time I'm
going to skip all the complex stuff I'm
gonna skip straight to the end because
there is a potential loose library that
makes most of complexity go away so you
should just go use that rather than
trying to do it yourself but this will
explain how the first principles work
how's the plan at least alright and
thank you very much for turning up to
this rather Mandrake because he's a lot
more entertaining than I'll be so the
contents of this presentation are going
to be basically what is a race I hope
you all know the races but I didn't also
explain what is a filing system race why
do they matter
who cares most programmers don't most
programmers write code assuming the file
system never changes then you find out
much later on when some horrible thing
happens you get pin for the blame why
why they do matter I'm going to cover
some mostly portable race free idioms
and patterns that are useful for working
around platform-specific
lack of support I'll then talk a bit
about proposed boost a if IO and then
finally I'll just give a quick idea that
quite pardon me
a quick idea of exactly what you can do
with this stuff why any of its
politically all that important so when
you do have a good conceptualization of
races on the file system how to work
random what kind of interesting C++
stuff can we do after all it is a C++
conference so what's a race 101 campsite
remember this I'm sure from your very
first lecture at university there are
two types of race data race and a race
condition most programmers once they've
got enough experience don't really think
about much difference between the two
because they're so interlinked so data
races will cause race conditions race
conditions can cause data races they're
actually two separate things and the
main difference from our purposes and I
apologize for the lack of a proper
academic explanation single biggest
difference is basically that the first
one is often can be automated to the
diagnosis a classic ones playing thread
sanitizer trial grind hell grind for
data races second ones a lot harder
there's no real way of automating this
you just basically got to get a really
experienced skilled programmer they got
to go at it until they figure something
out there's an even more 101 come say so
imagine to yourself there are two
threads or two processes and these are
running concurrently without any
particular synchronization so you got up
here that x equals repositioned zero at
the same exact same time you have
another x equals reposition zero we then
go x equals x plus one and concurrently
we go x equals x plus one well then go
position zero equals write x in for
thread one and in thread two we also say
position zero equals write x cloris the
classic outcome which hopefully no one
in this room is in any way whatsoever a
doubt about the position 0 is only
incremented by 1 not 2 any questions
good so what is the filing system race
almost exactly the same as what you just
watched the difference is now thread 1
is doing a peer Evi from a file
descriptor into some arbitrary into x
proposition 0 and later on in the same
thread is doing a PV same file
descriptor into the new variable
why let's say it's a position for from
another thread over here we're doing a P
right V in between this P read V so it
goes P write V in another thread and
it's overwriting the first two locations
in this font descriptor
so the first eight bytes is what's being
assumed here and what you get then is
that the X being read here no longer
matches with the wiping read here and
this produces the classic outcome where
thread one sees one version of X and a
different version of Y and you basically
have a torn torn read so the write comes
in gets the way of these two yes explain
that to me again please
so the question was that he's saying
here that X is 4 bytes y is 4 bytes he's
saying here that the P write V on this
side would overwrite the first 8 bytes
of the file is that correct because it
is that's because of my nasty pseudocode
which is completely not valid C or C++
so if they the point was made was that
he had misread it yes I have cut a whole
lot of corners to fit onto onto the
slides I chose this nasty style now
because later on I'm gonna have a lot
more code on so I just made it even more
compact and I kept a consistent
throughout I know the idea is here that
the first eight bytes are being
overwritten as an entirety but because
you've got a split read and then spit
right so it's reading the second half of
this one and this first half is coming
from what was it over there before it
that makes sense so here's another
with a file system and race conditions
this is a problem with concurrent path
changes this will capture a whole load
of people out as we'll see later really
expert people even so imagine to
yourself that thread one is using in the
route path name slash Nile slash door
and we open a file descriptor to set
path file 1 over any another thread
we're going to rename slash Niles slash
now the old and then rename slash
something else - now it's over here we
read /nya slash store slash file one
from this Nile and we're now reading
stash now stash door slash file - from
slash other this is being renamed in
between the two so now thread one gets
mismatched file one I'm fine - does that
make sense you might wonder so what so
what becomes another interesting one
deleting a directory tree so one of
those things that you're going to do in
second year comp site and you don't
really think much about it so we're very
simple you numerate the directory
content for every directory that you see
inside the directory you're numerating
your accursed back into yourself and you
go and do another enumeration afterwards
you come back out of rehearsing to the
directory you delete the directory
because you know that step three which
was executed inside the recursion that
deleted all the files already this is
correct for POSIX this works this is a
standard depth-first traversal algorithm
for deleting a directory tree but guess
what it's incorrect Microsoft Windows
and here's the crazy thing you could go
look at a whole lot of professionally
written code out there and it gets this
wrong every single time on Microsoft
Windows
I saw this pattern in Python and you
think the people who write PI didn't
know what they're doing but the
directory tree algorithm in Python in
the past was incorrect it simply used
the POSIX semantics
it doesn't work in Windows there's not
it's not safe it'll work 99% the time
but it's racy is actually incorrect I'll
show you what the correct algorithm is
because asking you all what whether the
correct algorithm is might be a bit
unfair so this is the actually the
correct algorithm for Microsoft Windows
what you do is instead you enumerate the
directory for every non empty directory
you recurse for every file you try to
rename it to some random name in
percentage temp and percentage type I
mean some environment variable expands
into some temporary location on that
particular Drive for every empty
directory you rename that also to a
random name in temp and then tallit and
then you loop all of these until a
directory tree is deleted can anybody
tell me why this is correct on Windows
Sagan the comment was a system read-only
files you suggested it might be locked
there's actually an even more
fundamental reason than that can anyone
take s hands something very peculiar
about Microsoft Windows in the audience
you suggest that file delete is not
atomic you're getting very close the
account was the updating of the
directory tree even closer
no one quickly got to it the waiting is
you could ask this question in a roomful
of file system experts and still you
wouldn't get the right answer I'll tell
you what the right answer is it's very
funny when you delete a file on
Microsoft Windows you don't actually
delete the file on Microsoft Windows you
mark the word file to be deleted at some
later point whenever Windows gets round
to it normally that's less than a
millisecond but it can be second depends
the reason for that weirdness is because
really Windows NT is actually VMs
underneath the bonnet VMs kernel from
bacteria messages and backs VMs was a US
Department of Defense secure running
system so what happened was that when
you went deleted a file in fact VMs back
in the day we're talking 80s 70s
it will go off and say I have to now
scrub all the contents of this file and
make sure it's completely securely
deleted and then I'll delete the file
comes back to VMs is the same kernel as
Windows NT it's that's the same
semantics it still will take some
arbitrary period of time to actually
delete a file and that's Titan is not
not instant it can surprisingly very
I've seen it myself with my own testing
you have a lot of load on the operating
system the filing system it can take oh
10 15 milliseconds delete a file and of
course you can't delete a directory
while there's in the actual file within
it
so this will actually fail randomly
unless of course rename it first and if
your library named the file was opened
that's great and then you can delete it
and lead out the tree and then when the
files actually do get deleted they'll
get deleted eventually everything works
so here's the actual algorithm correctly
marked out replace any notion of
deleting on Microsoft Windows with mark
for later deletion and suddenly
everything needs to make sense and of
course I have mentioned here that you
need to have all the files have to be
open with file share delete which is
because my default are on Windows if you
open a file you don't allow anyone to
rename or delete it but if you specify
the file shared leap flag and it lets
you rename and delete it although mark 4
relates to deletion is the actual
correct thing now you might be thinking
yourself this is actually a curse
terrible it's not POSIX it turns out you
can do a whole lot of really cool stuff
hacking using these semantics that you
do stuff in Windows that you just can't
do in POSIX but uh I don't know if I'm
lucky to get onto that in this
particular talk so many questions I put
in percentage temp to indicate some sort
of environment variable substitution it
does actually doesn't matter where you
put it as long as it's not in a
directory that you're deleting in my own
algorithms I just move them up to the
directory above the tree that I'm
deleting and you mark them all as hidden
and with random filenames and therefore
usually in Explorer you don't see them
and they just eventually silent
they delete themselves off without
anyone noticing doesn't matter where it
is lungs is not in the tree that you're
deleting Sansa Christmas right
the Kamikaze can take time to copy a
file to another disk you're not doing
any copying in this situation because
when you're trying to delete a directory
tree or you're moving so you're always
renaming so you're deleting the entire
thing you don't want to copy anything
you want to get rid of it as quickly as
possible the comment is you can't move
the file to some arbitrary folder any
arbitrary folder because it may be a
different mental partition yes that's
correct
and implied in this is that percentage
temp is a more definitely on the local
Drive you can just assume it that is
guaranteed to be true okay cool any
other questions at the back so the
question was you had some confusion over
why the fact that these two files being
loaded from two separate locations might
be a bad thing
yes so the question was this for example
the reason why this would matter is say
what happens at file one is a user
database of passwords and file2 is a set
of ackles for security for those
usernames and then you swap out the
ackles just the last moment with the
database of users you see where we're
going yeah and in fact that's a whole
class of security vulnerability any
other questions okay
so here's the thing you're kind of
probably getting an idea now there's
lots and lots of horrible things that
happen with the file system they're all
really non-obvious because we're not
really trained to think about them
trouble is ultimately we get taught at
university that file system is just
exactly the way you see it it's not
going to suddenly change out from
underneath you
Microsoft tried to introduce a an idea
of transactional NTFS back with Windows
Vista I remember rightly and they roll
this out with great fanfare because it
was you know huge thing that we can all
go do and guess what nobody used it
Microsoft were really upset they spent a
huge amount of time developing this
wonderful system and nobody used it so
they end up having deprecated again in
Windows 8 I think so that now marked all
of these API is you know we're going to
get rid of these into the future mainly
partially because they're not particular
compatible with RF here are EFS which is
a new reliable filing system which might
be stopped it's going to replace NTFS
with but equally just nobody use them
it's real shame because it's painful to
implement it's kind of funny because
Linux is currently going off in
implementing transactional filing system
extensions and the next question is if
they didn't use it on Windows which is a
huge operating system very very popular
is anyone use it for Linux and I don't
know the answer to that anyway
I'll mention there that there's a whole
class of security vulnerabilities and
they are called towels so that expands
out into time of check to time of use
these are very famous
these are UNIX is riddled was riddled
with these in the past so here's the
basic thing thread one checks whether
this particular out so imagine your
process is some set UID root level
process and you've got some path that's
coming in from wherever a configuration
file you're checking to see if the
access to this particular file is is it
is okay by the thing that's calling you
so is there permissions to do this and
then afterwards when you said oh yes
well they're definitely it's good
you open the path and you write
something into it usually someone trusts
put where the input now what I was there
is you have a malicious program a
malicious program in some other
concurrent context will suddenly relink
out
just in between the check and the open
some new paths of application and this
is a classic classic security
vulnerability the classic one is the
password file so what you do is you send
something to a set you ID program and
it's capable of writing to root level
files and then you suddenly swap out the
password file just the last moment and
you override the password file of any
arbitrary thing including giving
yourself root privileges this is a
massive thing and in fact this has a
whole page dedicated to it in the CV cwe
so that's the page with the link and
these are just I just copied the first
four so you can see this is not service
attack PHP has an arbitrary code
execution for all do to talk tile is an
arbitrary file modify our pile modify
and 2008 they did a pretty big purge
from that up to 2010 they went right
through and audited all the code and
they managed to pull out an awful lot of
this stuff but then it kind of made this
big impetus that we need to come up with
some API is that don't have this problem
in the first place which is exactly what
I'm getting to next any questions all
good cool okay so here's the are design
ideas we aren't going to go and think
about the filing system as being an
ecstatic and changing place anymore but
because that's kind of hard what we're
simply going to do is we're going to say
never use an absolute path just don't do
them any time you're writing an absolute
path slap yourself really hard in hand I
just don't do it so what you do instead
use an open file descriptor slash handle
as a base for a relative path operations
I'll show you how to do that in our next
in the next few slides next thing to do
is to combine these relative path system
API is with the design patterns that are
about to come from the rest of this
presentation and that'll let you do
various race-free behaviors of various
kinds
so POSIX
takes one approach and the main approach
by posix is that it has a whole lot of
extra api surrounded to posix that allow
race free filesystem behavior and
they're collectively called the at so
star at functions because every single
one of these ends with a net and they
all do exactly what their previous thing
does without the at just that the app
ones take an input directory handle you
can get these in linux freebsd are sex I
think
evening UNIX now has them any of the
implements POSIX as a very good
likelihood of implementing these
although they have caveats that's just
say the consistency of implementation
isn't as portable as it could be
Microsoft Windows as always is a bit
different but not that different
surprisingly enough if you skip the
win32 layer which you want to because
it's terrible you go straight to the NT
kernel API which is fully available to
user space processes and is documented
and it's not actually as illegal as
people seem to think it is you can
program this NT kernel with no in 32 at
all
it's beautiful you've got all the same
app functionality as you get off POSIX
so you can pass in some base handle to a
directory and you can do relative PAP
lookups and it's wonderfully it is
really really beautifully designed API
really which POSIX had just copied what
Windows NT did because it's spot-on the
only thing is that because we have dust
programs and dos programs get race
conditions too and people exploit them
but they added a whole lot of extra
baggage so one of the big problems is
you can't rename a directory containing
any open file handle on Windows you've
already probably seen this in your own
code another really one interesting one
which most people probably haven't seen
is you cannot rename a file into a path
where any path component has any open
handle on the system with the privileges
to rename that item so in other words
the upshot of all of this is you can't
change paths that are being used on
Windows they have a whole other locking
in way to stop that from happening and
that reason why is because all the
programmers were writing it assuming
that the static unchanging filing system
says Windows makes it static and
unchanging and that guarantees that
you're never going to get surprised
it matches programmer expectations
here comes the first pattern using
relative paths instead of absolute paths
so earlier on where we're all very
familiar I assume with opening a file
you'd hope so just open it with the path
earlier on I showed that you can have
split file opens where one file being
opened was mismatched with another file
this now goes away so what you do is you
open the directory that you want to go
and access you then use open at using
the directory handle to the trick so
that you just opened the file one
internally the kernel will take /nya
/foo or whatever the current path is and
depend on file 1 and then opened that
way that's completely erased free in my
own code I have this unit test more like
a soak test I suppose it's really an
integration test and what it does is it
creates a whole set of directories and
it opens a lot of files in those
directories and then those file system
changes within those directories while
another thread is permanently renaming
all the directories and needs it as fast
as possible that verifies that you
really really are even under conditions
are very heavy load this stuff safe
worked perfectly so you no longer slice
file opens which is great here's the
next pattern
just don't use paths at all by using
direct by FD operations so by direct by
FD what I mean is this here is creating
a hard link so what you're doing is
you're creating hard link to this file
and I'll stash food such file 1 to slash
file 2 instead of doing that which is
racy because we're using absolute file
absolute path you open the file handle
to slash now slash crew slash file 1
we'll just file 1 FD you then specify a
null string as a destination you didn't
specify this magic constant which means
that for this path we're going to use an
absolute path after all and then we put
slash file to and then we use this magic
macro extension which simply says that I
permit empty strings just here because
this is actually as it turns out an
extension by Linux to the POSIX
race-free api's and while that let does
let's you take we don't care what the
path of that is right now it could be
anything it could be changing right now
very rapidly doesn't matter we're going
to link it to slash file two completely
invariant to any form of change this is
supported on Linux and Windows and yeah
it's great you just forget about perhaps
don't think about them anymore any
questions okay as I mentioned this is an
extension that Linux provides and
windows provides it naturally so here's
an example of a call where it has not
been extended in such a fashion so when
you come to unlink a file you come along
and you say slash now slash slash file
one we're just going to unlink it make
it go away
but then what happens if someone is
process of permuting slash Nile or slash
through and renaming it all over the
place you'd end up deleting the wrong
file which could be a security
vulnerability an attack any from a
malicious problem so what do you simply
do is you assume you have here a file
descriptor is open the file you want to
delete and again you pass in and I want
to unlike that that's what this API
could do if Linux had implemented it I
have it open as a bug tracker on the
Linux kernel and they might implement it
they might not but currently only
Windows currently does it so the
question becomes as if we were building
say a library say a boost library and
this boost library needs to implement
DirectBuy Defty deletion on all
platforms how we're going to work around
the problem the system is sufficient so
what do we do we do a interesting
pattern called ID no checking so here's
the thing
all of the major uplink systems
currently available in the market
provide a magic proprietary totally
proprietary API for looking at the
current path of an open file descriptor
so Windows has one Linux has one or sex
has one or six has a particularly bad
API actually it's it has a tendency of
overflowing buffer encrypting memory
because he feels really badly designed
but we'll skip that part
point is is is there is an API that's
available FreeBSD has the interesting
notion that it only were
the directory handles so only if you
have an open file handle to a directory
that can't retrieve its path it's a
normal regular file previously currently
and do that and that is by design
according to the kernel fragra so you
have the ability to open for a current
file POSIX guarantees that you can have
any file I know that has the same St dev
and SD I know is the same file so you
now have the beginnings of the
primitives you need to do risk free path
traversals effectively using this i know
checking pattern which works ends this
so let's just say i have an open FD to
any particular location we don't care
where what the algorithm simply does is
it goes and gets the current path of
that file descriptor it splits the path
into a base name and leaf name you then
do an F stat at on the open the
directory don't have set out to try and
pull in the F step for the leaf name and
then you compare the STD Devon the SD I
know if they're equal you've just
discovered the correct parent directory
for that particular file if they aren't
then you've had a race so what you do is
you loop back and try it again and just
keep looping looping looping looping
until you eventually get it right not
particularly efficient under conditions
of lots of change but is rare actually
in practice that a file system changing
that much it's just it could be changing
at any time it is reliable and here's of
course the great advantage because you
can now do sibling lookups so I'm sure
you're all we're well aware of storing a
some data into some store file and you
might have some index so the classic one
would be the male program on UNIX or
even my own email program which is
Pegasus mail so it gives an index into
flat mailbox and you need to race free
lookup its index which is always going
to be stored alongside it's even under
conditions of paths being changed very
rapidly and this this this pattern can
do that so we've worked around first
problem in also do you race free
deletion so if you need to delete a file
and you only have an open file
descriptor to that file you've no idea
where it isn't can be
renamed at any moment and there's a
potential for data loss because you
might delete the wrong file you solved
this because all you do is you open up
race free open its parent directory once
you've got the parent directory you can
do unlink at using that parent directory
handle you can unlink the leaf name
again by comparing the inode make sure
you got the right one that's of course
slightly racy
but it's not race it's race free up to
the point of the containing directory
question sure I believe I missed a bit
so the bit that's missing oh no I did
actually put it in so you split the
fathom you open the parent directory so
that we then go into dear FT and you get
a nest at at so some this is your base
and then you're finding the leaf name
within that base go on the point was
that what happens when you have multiple
hard links the same file within the same
directory and you are correct that would
indeed be a bug this is why I in the
library I only make any grace guarantees
whatsoever
up until the containing directory so
it's up till that dear ft after that
anywhere from there in words you're
completely on your own you're interested
in making a valid point that if you have
hard links that span directories you can
get some very interesting cases that pop
out that hurt the head after a while
hard links are surprisingly complex when
you let them proliferate any other
questions sorry I have one of their my
apologies
well if it so the question was is there
not a problem with time in between
getting the path splitting it and then
doing the directory open and the answer
is yes there can be and it doesn't
matter because when you do the F set at
St Devon St I know will no longer be
equal you've got an interesting point
though because what happens imagine this
this tax rate goes slightly a bit head
recce it may not be aware of some of you
but x4 has a nasty habit of really using
inode values of stuff that's just been
deleted so what can happen unfortunately
is that you can delete an item so you
open your thing you're in the process of
opening it it gets deleted and then it
goes reopened again
sorry so the file with the I know gets
lead and I get recreated but now to a
different file and then when it comes to
compare the St dev and the STI no you
now have correct values but you're not
referring to the wrong file and the
reason why that is never allowed to
happen is because you must never ever
close the path my finger over you never
close the path of the item that's here
as long as you keep the handle open that
file directory to the original file is I
know it is pinned and it will never be
recycled by any operating system but if
you were to go off and close the FT
while running this then yes you would
run into that particular race these are
the fun front parts that you can have
any other questions at the back said Ian
so the question was if you keep a file
descriptor open to the directory it will
never recycle I notes as I miss explain
myself it's if you keep the file
descriptor open to the item that you are
checking and then have a directory file
descriptor to the directory you'll never
get the inode recycle as long as you
have an open file descriptor to the item
because it should never be deleted it
should be is a case you're right that on
some filing systems where they emulate
the inode number then that can be more
interesting but they're not POSIX
compliance that's okay
any other questions okay so you now can
do sibling lookups yay so here comes the
next person this one should be familiar
to anyone who's ever had to do anything
on UNIX at any time so this pattern is a
pardon me this pattern is atomic
renaming so this is a classic one that
you always find that whenever someone
comes along and they say oh I was
writing some new data to my file and
some other thing came along and only
read a partially completed torn read and
then this standard advice as always is
use atomic renaming to work around the
problem so the idea is so the idea is
create temp file and in fact this is
such a common idiom that Linux has
recently added this lovely new flag
called ode temp file an Oh temp file
will create a completely anonymous new
file that does not exist but does exist
exist just enough the purpose of being a
temp file but doesn't appear in the
filing system either way you can use a
random name so in my code I have a
cryptographically strong random number
generator and you spit out a 256 bit
random number and chances of that ever
colliding with anything are
extraordinarily low you better write the
data into it once you finish writing all
the data into it of course nobody can
see you're a randomly named file because
it's so random
unless someone didn't directly
enumeration what you're not going to go
do you're fine so the idea is you have
some /foo some file called foo it still
sits there you're now creating a new foo
file let's call it there once you finish
writing Blaire completely you then do an
atomic rename replacing foo with Blaire
such that anyone who now comes to lookup
foo will now see the new updated version
and then anyone who has a file handle
opens the previous Edition will still
see the previous Edition up until the
last file descriptor close in the system
then it'll get D allocated on the file
system and be kicked out it's a classic
pattern Stack Overflow is full of a
particular pattern I seen we've all seen
it before hands up who has Oh bit less
than half yes
a bit less than half have seen this this
is interesting I thought now all hands
would go up if everyone was here for
this so that's good you've all learned
something new the classic reason why you
don't do this in portable code has
always been Windows because Windows
didn't provide it in fact that's that's
that's a lie
Windows NT has always provided since a
year dot but it was never exposed to
win32 up until Vista and here is the
name of the wonderful API is set file
information by handle using the file
rename infrastructure with the flag
replace if exist is true and anyone say
why move file X is the wrong answer
anyone able to say that nobody because
move file e^x does provide I will
replace this file if it already exists
but does anyone know why move file the
X's behavior here is a bad bad bad for
atomic rename nobody knows this is
correct
so the question what the point was that
the MU file the X takes a path which is
not handle this is a very good point
there is a second reason and is the
semantics of MU fiery X unfortunately
when it tries to go and rename an item
and replace the items existing if it
fails it will then attempt to copy
because it tends to copy it breaks the
atomic renaming ruins your I know thing
and therefore is completely useless so
the correct answer is this completely
non-obvious thing and the reality why is
because this actually thunks through to
an NT kernel call directly with no no
other change that's the structure that
happens to be NT kernel users and that's
the fact it uses so literally runs
straight to it it's a straight to flip
through func however point is that if
you're now writing portable code you can
now do atomic renaming of Windows this
is a big thing
since Vista okay
so time is getting a little short I am
going to quickly take you through and a
very quick overview of the four
techniques for doing concurrency control
on the file system without using locking
well different forms of lucky I'll give
you I probably won't go up to the very
last one because last one is pretty
advanced you know you could go to a file
system conference you could present on
this and your entire room would be
packed with people and still only 10% of
people in there will still understand it
so I'm just gonna say go look at the
slides if you're really really really
interested do lots of research on the
internet it gets so hairy after a while
but I'll certainly tell you where they
exist and here are your four patterns
you've all heard of exclusive lock files
they're the standard one exclusive on
POSIX or Windows also has a similar
thing so in other words what you do is
when you create a file you say please
don't let me create this file if
something already exists with that same
name and that way then the first person
to get their to create a file has the
exclusive block and they are the person
with the ticket that they can do
whatever they want and when you're
finished you simply delete the item and
then the next person comes along to
create the file first is the first
person I'll show you the api's for that
shortly second system is byte-range
locks you might think that they are the
obvious thing to go do but there's a
very good reason why they're not the
right thing to do and that's because
POSIX has one of the most stupid items
that POSIX has anywhere in the entire
POSIX spec about byte-range locks it is
a defect that's been there since 1982
there's a defect that was recognized as
an out blaring defect back in 1982 and
people said why the hell are we adding
this because it's stupid and they said
because AT&amp;amp;T UNIX does it but that's
because 18 tears was broken but we're
gonna add it anyway and it isn't somehow
persisted since then even though it's
completely daft
luckily Linux has just recently replaced
it so when I say easier on Windows and
Linux Linux has finally fixed it as a
315 that's due to Jeff Layden just
getting really irritated that 25 years
we've gone past no fixed it so you just
went ahead and did it the third pattern
is atomic pen plus extent deallocation
so any recent file system can do
stuff it is amazingly powerful because
it's one of the very few ways to pour
typically dule durability so if you want
to do an acid compliant filesystem store
and you want late rather than immediate
durability this is the way to do it you
want to do a portrait and then final one
this is one I probably won't cover
because we've run out of time this is
like voodoo magic stuff ordering
guarantees you will probably grow older
by 10 years will you try to program this
stuff you may notice I've become fat and
gray recently fat gray it's because I've
spent my time tearing my hair out
and why does x4 behave the way it does
because the people who wrote it want it
to be that way it give you some idea of
the relative performance benefits and I
stress this is this is an average
guideline it's not actually accurate and
over here is a logarithmic scale it's
it's what you should expect so locked
files have this sort of performance
range locks have much much more
performance upend an extensive way more
performance again these are all orders
of magnitude effectively that POSIX
read/write guarantees the ones where you
lose all your hair and become very fat
and die soon from heart disease that's
that's crazy performance but yeah so
this is the one that everybody here
should should be familiar with these are
exclusive lock files as I promised
here's the API to go do them it's very
straightforward
you basically for the while loop while
it goes off and tries to create
exclusive file it'll failed if you can't
create a file exclusively exactly the
same thing there is with Windows you
just use create new flag you also want
to specify the file attribute pinprick
like because if you don't you lose about
40 percent of performance on your locked
files on Windows it's basically windows
needs to know it's really a locked file
they're not actually a real file that
you're writing and that's how you do and
then it'll go much faster so if you
didn't actually benchmark that you
probably wouldn't know it this is great
this idiom is really simple it works
everywhere network fighting systems
works between POSIX and Windows already
to the same network drive perfect
everybody understands them that really
complain but there are some problems
firstly they're exclusive or not
exclusive as the only two things you can
do with them you can't have multiple
readers parallelizing there's a big
problem obviously if power suddenly gets
cut because you then you have a stay
lock file just sitting there it's even
more complicated because what happens if
your system is under a huge amount of
load and RAM is short your swap files
are being thrashed and you have some
algorithm in place to break stair lock
files and that happens to timeout and go
off and delete the file while
something's still using it that can
cause nasty bugs corruption of data and
lost data windows doesn't have that
problem because it has this lovely
delete on closed facility so as soon as
this is one of the things I mentioned
earlier on this gets in the way you'll
be deleting a directory hierarchy in the
race free fashion because files that you
delete hang around for a while but here
they're really useful because here you
can simply say well this lock file I
don't care if this process ever exits or
there's ever power loss always delete
this file and it works beautifully so
Windows here is where I deposit you've
no problem to steal files on windows
unless of course you've got some silly
loop in your program where your program
just hangs with a separate matter a big
problem for as Chandler would often say
Chandler goes on about power consumption
well lock files are terrible for power
consumption if you do a lock file of an
Android device you have no choice but to
sit there loop loop loop loop loop no
way of sleeping and because of that
you're just burning the CPU so it's
expensive on CPU and battery that's
triple lock files and these are actual
benchmarks so when I say you can get
about 2.5 k operations per second on
Windows and the complexity is log
Waiters for K on on Linux and lovely
constant time complexity Waiters FreeBSD
just knocks the ball out of the park is
FreeBSD often does 10k block file
operations all constant time great stuff
any questions
waders is the total number of things
trying to claim the lock file so if you
have okay so if you have eight things
all trying to concurrently write
something that would be the number of
Raiders you can tell that Linux and
FreeBSD has been quite a bit of time to
do constant complexity to Waiters
windows less so the reason why Windows
doesn't do is for the next slide
so by train remarks yes that's the
number of block file operations you can
do for a second that we a peek on a four
core 3.7 gigahertz CPU Intel CPU so
basically my work machine at home that's
the benchmark ahead obviously on the
bigger machine you get more any other
questions the question was would it be
affected by the SSD versus standard hard
drive
yes SSDs are slower which is not what
you're going to expect and you know why
they are slower the reason why is block
size so almost all SSDs use a 4k block
size whereas the older hard drives use a
512 byte block size and interestingly
lock files have to write out a single
block so therefore they're writing for K
on the 4k device and 500 bytes on the 5
and 12 byte device and lo and behold the
4k one is is actually slower so any of
the newer big hard drives or an SSD are
actually slower than any old-fashioned
mechanical hard drive which is just not
what you expect the question was about
mechanical latency and how does that
figure into this the answer is it
doesn't figure at all because lock files
never exist long enough to ever hit
physical storage so they exist purely in
the kernel cache and therefore and the
job is because it's a 512 K versus 512
byte versus 4 K block size it has to
write the memory internally so that's
why you're getting a mem copy
effectively and that any other questions
ok right range locks yes
so much fun and you'd think that these
are the solution to everything what you
do with byte-range locks is you say I
want to lock some offset in by some
length for reading or for writing so
exclusive or or shared and that just
works except on POSIX allows the non
modifying operations to parallelized
it's fantastic
automatically unlocks whenever the
process exits even better unexpected
power off not a problem
shred can sleep so it's not bad for the
CPU or a battery performance is actually
about same as a lock file on Linux
Windows is way faster and with constant
time to wait as complexity and again
FreeBSD just knocks the ball out of the
park but linear interestingly to waiters
so only Windows as a constant time to
wait as complexity here come the big big
dragons in the corner as I mentioned
Windows is great it is even async so in
Windows you can say I want to lock this
region and call me back at some future
point when I'm ready fantastic just love
if we could do that in POSIX I am
supposed to write a paper with Jeff
Leighton on proposing this for POSIX but
it's going to be a while out I just keep
not finding the time the great trouble
with POSIX and gets in the way of
byte-range locks is that up until the
linux 3:15 and on linux at least the
lock according to POSIX has to be per I
node on the system so as soon as you
call any clothes on any file descriptor
that refers to thy node it will simply
release all locks on that inode for the
process which is completely brain-dead
and makes it useless in a multi-threaded
process because either your multiple
threads possibly with file descriptors
open to the same inode soon as anything
goes and closes it's got instant data
corruption terrible there are also some
problems with cross-platform network
shows so if you have a Samba share don't
help you to Center Samba share but if
you did have a Samba share you try to do
a bite range lock you have a huge huge
problem on POSIX our seven length are
signed because why wouldn't they be
signed because it makes total sense that
they bite range lock would be signed on
an unsigned length file so you lop off
the top bit and of course POSIX windows
does it correctly with unsigned offset
and extends and therefore you now have
to make your problem because if you want
to lock all the file from this moment
until the end of the file how do you
specify that in a way that windows and
POSIX can both understand when you're
locking the top bit off the length and
the offset and the answer is lots of
complex code
results and portal Samba does a whole
lot of work to go and do that question
at the back oh yeah yeah if you go to
the December mailing list and you read
about what they've done to work around
this problem you will find a whole lot
of very sad and despondent people
because they get never-ending bug
reports from when Microsoft Office went
often did a bite range lock on the Samba
drive that was on Linux and then some
other thing was using it and then it
doesn't spazzed all over the file and
they say Samba broken 8 my files and the
Samba people say no no we really didn't
it was that it just happened to be
really unlucky that these two systems
collided in this particular way that ate
the file and is really not our fault and
there's a flag you can switch that will
make it no credibly poor performance we
get it right every time and they say but
then all our files saves take 10 minutes
question was are the offset and length
specifies 32-bit values they where once
upon a time a long time ago but they'd
be 64-bit for quite some time
it doesn't still help you because
they're still signed that means any the
trouble is is a lot of the time you want
to lock from here to the end of eternity
on a file that's a very very common
pattern when your bike range locking so
from the end of the file currently to
any end to infinite is the question of
expressing infinite and the two systems
have totally different ways of
expressing infinite so in POSIX 0 length
means infinite on windows it does not
but then sometimes 0 length does not
necessarily mean infinite because there
are exclusions for example if you read a
log you won't necessarily get back
infinity it's it's oh it just gets so
much fun and poor old samba the
assignment developers have really poured
so much time and effort into getting
this to work properly and horrible and
if s if you're glad to know just gives
up so then if s makes some attempt to do
some locking across POSIX systems but
you're all bets are off if you're trying
to get Windows to talk to an NFS share
with byte-range locks which makes sense
so any questions in that truck
so the question is is there any way of
knowing if you're talking to such a
share on the program yes but the trouble
is that Sandler could be configured in
one of about 20,000 different ways each
with balancing different things of
whether you know performance comes here
or performance comes there I also
they're different versions of Samba and
different versions assembled and
different things going throughout
history and past and sometimes you'll
flip it something into compatibility
mode because say Windows XP can't speak
the same language as say Windows 7 to a
Samba share so there's no way you can
tell you're on assembly sure but you
can't say how it's been configured
that's the great trouble so any other
questions ten minutes okay all right I'm
gonna flip through the next set of
things we're gonna basically skip it
this is an evil evil technique which
will make your head explode but is
really powerful you can deliver a really
fast file system algorithms using this
pattern I'm not going to say very much
bad other than say that it really works
well I implemented using this pattern
for the AFI review I'm going to mention
quite shortly I used Suzuki because I've
easily academics and you can write a
distributed mutual exclusion algorithm
using just purely atomic append and
filed extend the allocation and
amazingly the lock file performance by
implementing this algorithm is as fast
as byte-range locks on the system except
it's completely portable in runs across
samba and all systems run equally with
it and you can do multiple lockers
because it's constant time to weight it
so amazingly powerful but it's just
mind-warping how to implement it in your
head when you're converting the
distributed algorithms into purely
atomic append based techniques so isn't
the I can tell you it works this is
where all the fun happens if you want to
go and completely absolve all locking
except with the kernel does so if you're
on a system where you're never ever ever
on a network drive ever
and you are unwi SD because bsd is same
and lovely or you're using x FS and x
because x FS has done a whole lot of
extra magic to make it work properly and
Linux
or you're on Windows and this whole
technique may work for you and I'm not
going to explain it I'm afraid all I'm
going to say is that it does a hold of
the stuff which is very similar to
atomic lock free programming on C++
performance is absolutely superb you can
get millions of locks and unlocks anyway
here we are I'm gonna skip straight to
this because we've only got eight
minutes left this is a library that came
up that I've been working on for some
years the idea behind it is that we get
rid of all of these platform-specific
differences and we create a unified
filesystem programming model which is
portable it works everywhere exactly the
same works with all features in Windows
and Linux it sacrifices things like for
example I mentioned earlier that FreeBSD
isn't that youthful pull the full path
of a file only directories so for
example that facility is not functional
in other words pulling the path of a
file race-free does not work perfectly
on FreeBSD well that's just cuz of the
operating system and we're not really
caring as much as we could do about
performance or the performance is
important what we care about is the
system is equal across all platforms so
what does it provide it provides a race
free file system API so if you want to
use the file system TS but not get any
unpleasant nasty surprises at the races
this could be useful it provides
arbitrary file system back in so you can
say I want the local hard drive I want
to zip file I want whatever else and
it's a pluggable extendable kind of
thing 98% a synchronous file system API
and hundred percent of synchronous gotta
gather file i/o so it's a bit like
azio except it's for files and of course
it provides error code variant this
other fancy stuff go on question was
what does ninety-eight percent mean for
an a synchronous file system API the
answer is that it's ninety-eight percent
because some calls it makes no sense to
make a synchronous classic one being
atomic rename that is constant time no
matter what it's very very fast so
as he said 90% of the API not necessary
forms it is so there's a few calls in
there which are synchronous because it
makes no sense to make them asynchronous
here the stuff that provides the single
biggest thing is missing out of all the
lovely list of items is the ability to
do a synchronous fire locks unlocking
portably and the reason why is because I
need to go rewrite as yours core reactor
first the reason why I need to go do
that is because as euros core reactor
which of course is gonna become the
network in TS it unfortunately is built
around soccer the networking IO and
trying to get it to do locks doesn't
work very well so I'm gonna have to go
off and rewrite that at some point but
I'm kind of caught the reason why is
because the co-routines so Gore's
co-routines that are coming for C++ 17 I
need those in at least clang which is
not far off done now and in Visual
Studio but this one shipping efficiency
of 2015 currently can't do exception
throws I think they're adding that in
update one so I'll be very shortly able
to get started on this but I'm kind of
blocked by other people I have written
their lightweight melodic features
library which is the first chunk of that
and it's much faster than standard
futures it all seems to create some
co-routines into the whole lot of other
fun stuff I'm gonna write the reactor
using that so that's great that's in the
future at some future point right now
we've got the current library it works
fine it's just the new engine allowed
the same API they just built faster
that's a while out so you now know the
libraries there as I mentioned it we're
not for review and he got rejected so I
should mention that I would say the
biggest reason overwhelmingly was that I
don't make sense to people so in my
documentation the single biggest
criticism was what the hell are you
going on about now and hopefully this
talk probably proves by it
I just can't communicate I don't know I
don't know we'll see what happens
so what can you quickly do with this
stuff I
currently called about what I'm gonna
present at these conferences next year
I'm either going to present lightweight
futures or I'm going to come present on
a transactional key value store which
builds into the core of the C++ runtime
and I'll just give you some quick look
at what fun that might be here's my
current prototype that I'm currently
working with here is class data store
you can store a blob you can find a blob
and you can begin a transaction so you
can create the blob and do that I'll
show you some extra code that's using it
just a second here's the transaction so
the transaction lets you look up a key
ID key and you'll notice the template
key so it could be any arbitrary key but
it is and you can commit if you don't
want to commit simply destroy the
transaction throws it away here's some
code that's using it so this is the unit
test case that actually uses the code
and it's pretty straightforward the way
you do it is you store some arbitrary
blob these are actually scatter gather
buffers so you can actually supply a
gather set of buffers for the blob and
it'll just knock it in it's actually a
content addressable database so the hash
they take the hash the content you can
look up the content using the hash you
then speaking a transaction and we're
saying here that we're going to use the
index called default it's a string index
you add Niall maps to a ref a ref here
is AC straw and that is simply capital
Nile same goes Douglas Clara then what
you do hit commit to make sure it's
successful that's how you write a value
read-modify-write start a transaction do
a read do a modify do a commit the
reason why we do lookups in the
transaction is because that's how you
handle conflict management so if someone
in a concurrent thread came Alana had
modified Nile then this transaction
would fail because it would say that
he's been modified as therefore a spit
transaction and therefore we're going to
refuse to commit it and then you can go
back reach right do it again and just
down here there's another bit of
checking there to make sure that it is
in the same state that's what I
I might present in this next year if I
get it to a point where I'm happy with
it send it in to see what happens or I
might go back to lightweight futures I
honestly don't know but
I think it could be really fun to have
in C++ I think the ability persists data
could be enormous so thank you very much
and happy to take any questions
Wow
totally blown your heads everybody seems
silent chance to stun there's something
at the back Sadie answer yes so the
question was I'd like to have unlink
able to work directly from file script
yes so how would you deal with that when
it'd be working with I nodes rather than
names the syntax as I showed there where
you pass an empty string you allowed
that the empty string says that I don't
care what the name is so you're saying
that the kernel doesn't know which file
open just the inode yes so the point is
that there could be a large number about
howlings that's okay because any of the
existing kernels already have the
ability to have osut means so if you
want to delete a specific hard link then
you can't because you wouldn't know
which one it is because you're referring
to the inode yes the way that Windows
works around that problem is it keeps a
separate inode per hard link and that's
why you're able to delete directly by FD
for that but you made a very valid point
actually thanks for that I think there's
another question on the side no not
anymore
okay anyone else I really must have hurt
your heads
okay thanks very much everybody</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>