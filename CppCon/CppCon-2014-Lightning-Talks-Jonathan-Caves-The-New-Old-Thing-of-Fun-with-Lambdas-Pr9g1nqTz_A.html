<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2014: Lightning Talks - Jonathan Caves &quot;The New Old Thing, of Fun with Lambdas&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2014: Lightning Talks - Jonathan Caves &quot;The New Old Thing, of Fun with Lambdas&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2014: Lightning Talks - Jonathan Caves &quot;The New Old Thing, of Fun with Lambdas&quot;</b></h2><h5 class="post__date">2014-10-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Pr9g1nqTz_A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we have Jonathan caves next John's going
to talk about generic lambis because in
C++ you can never escape from the past
and he knows this full well because he
works on the visual c++ compiler team
give your dongle their surface team
surface here this is 15 minutes there we
go the title this is taken from sorry
Ike wonder I wasn't more wonder the
title of this is taken from a Raymond
chance blog the old new new thing I just
changed it around a bit and also from a
blog I find on online which was titled
fun la Villa lambdas I'll spent most of
the last year working with both generic
lambdas and very otic generic lambdas
and once I have it work hard working I
was looking for fun examples of people
doing stuff with this and when I went
out onto the web I find a guy called
soup sumanth tambay who's died in the
Bay Area had written this three-piece
blog post called fun with lambdas and I
looked looked looked at it and thought
oh wow that's fun I wonder we can
compile that that is the code it's scary
for first first thing in the morning but
what it's doing is it's a nested generic
lambda called list which returns a
generic lambda another jury gland are
called map which when you apply it to a
list who's over the elements of the list
and applies a function to each element
of the list and then a simple generic
lambda called print which prints out
about a value so you put them together
at the ball at the bottom and you create
a list you apply map to to the list and
map or flour applies print to each of
the the the the elements of the list and
I was very happy that when I compile
that it showed one bug and the fix
fix that and the gap old ran so it's
nice so I assume at in his blog posted
that he tried example with clang and as
you'd expect from seeing the code the
output is 1 2 3 4 he tried him of GG a
jeep GCC and he got four three two one
now as we all know there are no bugs in
flying it's obvious that GG GCC is the
one with the bug and that's what he said
in his blog and his deduction was the
bug is in the order that the pack
expansion is stored inside the lambda we
go back to the example here where you
can see the pack expansion the inner
lambda expands the pack and also
captures bye-bye that x value which
means that the expanded form is captured
by x x value and he assumed that g GCC
was switching the order there so we
compiled it and ran it and i got four
three two one so there's two compilers
are agreeing and one compilers not
agreeing so where's the bug now except
if you target armed with our compact
compact that come up the compiler and do
that case you get one two three four at
this point i was ready to phone up the
if the John John Spicer ddg it just
asked about John what's the right answer
this can you have a casting vote please
so yeah what is the correct output what
is the bug what is going on here because
this is a very simple piece of code it's
very clean it's very nice but compilers
cannot agree and what the output should
should be if you look at it closely the
issues with this line here where you
take the list and you apply funk to the
elements we
because this is functional you end up
returning a list but you fly funk to the
elements inside their compartment come
come come compiler if you expand the
pack you end up with that liner of the
print and I've out of the numbers are so
just you can see that we always it print
ZZZ Z 1 which is one print to print
three print print print print for it
looks clean it looks clear what's wrong
the new old thing we are right back in
see the original sees that is that
standard the order of a valuation of the
postfix expression and the arguments to
a function call is not specified a
compiler is free to execute this code in
any order it thinks is best I'm given
x86 architecture the way the all
compilers refer to do it is to go left
22 left to right because that way so do
the last one first and then do the first
one last that saves you a couple of
instruction instrum instruct
instructions because you evaluate push
evaluate push evaluate push Cole it's
faster but it ends up getting the result
wrong well not wrong unspecified but you
try persuading your user that printing
the result for four three two one is
correct and they will probably stop you
using your product this happens
elsewhere and C C++ in these cases are
probably a bit waste the first case is
probably very very well well well known
you know you're using I twice within
within the Express expression what is
the resulting value is it in is v-0 and
initialized to 1 or the v1 is
initialized to 1 if you don't you don't
don't know the next one is a bit rarer I
don't know many people who have
complained about about this but if you
start using lambdas if f1 actually
happens to be a lambda you do see see
see this in the problem is that to the
back end the optimizer the f1 expression
on on the left of the arrow is just
really the first argh argh argument to
the function it does moves it across and
preferred sitting on to the head of the
argument so again it does f2 first and
then F 1 this is bitten me in the last
few months imagine f 1 is a function
which says go get me the current lambda
your work you're working with ok the
function MMF says go and please walk the
body of the lambda looking for any
implicit captures ok f2 i knows what
goes off and gathers up the bot the body
the body has a nested lambda in it it
updates the stack the vector of lambda
proset assessors and then call us ff1
which gets the nested lambda not the one
in the RV via the outside so you end up
writing ya know what you doing is like
like like like like this is you always
end up writing more code and spread
things they say things right but
remember the example the beginning by
just fly back to it if you start messing
with this you lose a lot of the
cleanliness of the code it ends up being
come much more complicated you'll fit
over this you're treadle of that you are
the Sun something here so maybe sub
template metaprogramming and a couple of
days you have stuff i stood stood still
stood still pair which is my example of
you know how hard can i how much code
can you need to store two things you
know really
so can we fix this is there a solution
and the solution solution is you fix the
order of about Val valuation we say C
and C++ until now have been wrong we are
going to say compilers must do it and
left to right order there's possible but
there are M implications this the code
unless you're on x86 will be slightly
slow slower I think most applications
wouldn't notice you know given the miter
time it takes to go and get something
from Maine Maine men and that memory an
extra push is not going to cause you
much trouble but for some apps this may
be too too too much it also will change
behavior maybe there are people who are
very happy fat the code prints prints
out for four three two one that that's
what what they want now they're going to
get the reverse behavior people know
that people have lived we've lived this
have adapted their code to it on a
perfectly huh happy herb as Sutter is
pushing for the committee to fix this
for c z+ us at 17 he feels this has been
a wart which has been around for too too
long but the worry is that it is going
to cause trouble so have a sure hands
who thinks we should fix this who thinks
we shouldn't okay fifty-fifty that is
going to be a really fun meeting so
that's the I'm done well and here's some
time time time back okay I've got
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>