<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: John Lakos “Advanced Levelization Techniques (part 2 of 3)&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: John Lakos “Advanced Levelization Techniques (part 2 of 3)&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: John Lakos “Advanced Levelization Techniques (part 2 of 3)&quot;</b></h2><h5 class="post__date">2016-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fzFOLsFASjU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so demotion is the next one
moving common functionality lower in the
physical hierarchy so what does that
look like suppose I have an event queue
and an event and the event queue knows
about events in the interface but the
event knows about the event queue
because the event queue has some common
stuff that's shared by all the events so
what can we do about that well we
clearly have a physical cycle we don't
want that and here's the example listing
and here's the common event info and
here's the way we access the common data
this is how we have set up our
components and classes and you know
whenever you start designing with the
idea that both things know about each
other you're going to wind up with
physical cycles so we have to do
something about this this is the the
runtime look this is not a component
diagram so you have to be able to switch
between the runtime diagram and the
static diagram this is a runtime diagram
when we have an event queue object
pointing to a bunch of events via some
sort of list object okay
and each of the event objects points
back to the event queue and everybody
knows about everything right we don't
want to do this so the trick here say
trick the technique is to create a new
entity called common event info which is
much like taking the guts out of a
container and putting it below the
container where event would have the
role of iterator and event queue would
have the role of the container so this
is just like that and now what's
happening is we have this kind of
dependency the the event doesn't depend
on the event queue at all it depends on
the event info all right so what does
that look like here's our level ization
and we're going to go back and look at
the the new diagram and it now looks
like this are not diagram but the the
new components we have three components
and we're going to instead look at the
runtime this is the old one we're going
to do the magic and now see we're
actually pointing at an object that's
contained by the event queue we're
pointing at the event queue info object
does this make sense
this is classic by the way when you have
something that points at something else
that points back that the first thing
but not all of it this is how you fix it
so it looks like this now does this make
sense this is actually this is a very
common pattern it's when something
points to something else and the other
thing points back to part of the first
thing take the first thing out
make it a lower-level component and then
embed it in the object and now you've
got to clean dependency graph okay
that's all that's all there is for that
any questions okay
all right remember I talked about uses
in the interface in name only opaque
pointers takes advantage of that so I
was asked a question at the break about
what happens when you have an account an
account and a person and they both need
to know about each other
so let's take the example of a manager
and an employee where they both need to
know about each other and the example
here is that a manager manages a bunch
of employees but you might ask the
employee a question that the manager
knows the answer to so the employee has
embedded in it a pointer to the manager
and is going to ask the manager the
question so that causes a cycle here's
some code where we have in particular we
have an employee that that you can ask
it how many people work for your manager
and just the the the use case here is I
have I have a user and the user has a
function called ask employee num staff
and it takes an employee and the
employee we call employee on and
and it says numb staff so you're passing
it in by constraints and what the
employee D employee does is in its
implementation it goes and asks the
manager you know goes and finds out from
the manager what it's the number of
people working for it for the manager
and and of course this causes an upward
dependency which we don't want so we
want to fix that and the way we're going
to fix that is we're going to use an
opaque pointer which is uses in name
only so the employee is going to use
manager in name only
and the way we're going to do that is
we're going to take away the pound
include from the employee here we have
the employees about including manager H
and we're going to turn that into class
manager and then we're going to change
the int numb staff constant method on
the employee to just give me that
pointer please tell me who your manager
is and then we're going to go over to
the manager we're going to put a public
method on manager that says how many
people work for you and once we do that
we have this diagram again now it looks
like this where we have a client that
knows about the manager knows about the
employee at physically but the method
this method still takes just an employee
even though it knows about both takes
the employee and now the the way it gets
it it says employee please tell me your
manager okay I have that manager how
many people do you have so the idea here
is the higher level user knows about the
manager type but doesn't know about the
manager object until the higher level
client says to the employee who's your
manager but does know about the manager
type so this makes sense in the context
of this higher level method so I'm going
to go back to this for once one second
more here hold on this is what it looks
like and the client is at a higher level
so therefore the client knows about the
man
your type knows about the employee type
the employee does not know about the
manager type but the employee does hold
an opaque pointer to the manager okay so
this works you can do the same thing the
ideas within this ask employee function
yes I know about these two things I take
the same arguments so nothing's changed
its just the implementation of the
function that I wrote at a higher level
that's implemented differently but I
haven't changed the topology of my
design except for that yes okay so what
was said is this holds true only if the
employee isn't calling any member
functions of the manager that is
required yes absolutely and what we did
was before it was and now it's not
because we eat the one case where it was
we changed it and said no you have to do
this in two steps you can ask the
employee who your managers but you can't
know the managers business and that
works this is opaque pointers how do I
deal with the manager is also employee I
changed the names in the example so that
it fits my solution excellent all right
I need a drink all right
so one thing I would say is you know you
have the the pattern in a way what is it
what is it called the composite pattern
and that is how I would actually
probably deal with what you just said
but this is not the time with employees
fair enough okay but it's a it's a
worthwhile point all right dumb data
sometimes you want something that's even
more opaque than an opaque pointer so
this is this technique using data that
indicates at a dependency on a peer
object but only in
context of a separate higher-level
object so this is painful this is when
you're doing this you really mean
business you really want to do something
special so here we have a graph and the
node and the edge know about each other
and that's a problem and the the node
and the graph both know about vector
because the node has a vector of edges
the edge has a node as head and tail and
the graph knows about all these things
because the graph is your is your rapper
object and we don't want this and I use
graph because it just seems to be an
intuitive thing for everybody because we
know what's going on and so we'll see
this come up over and over as we go
through the different techniques so this
is the opaque pointer solution to the
graph where we have the graph and the
node knows about the edge a name only in
the edge nodes about the node and name
only and the graph knows about
everything and you can ask all your
questions of the graph and it'll just
work ok so here's an example of that and
you'll notice that we here we're
including no dot H and an edge dot H and
they're both including the the other guy
and now we're going to convert it so
that now they're using them in name only
which means we get this picture and that
means we have to re-implement graph and
change its interface so that all the
questions are asked of the graph rather
than the note in the edge there are some
other issues with this by the way that
will address slightly later but but this
gives you the idea but suppose you don't
even want that suppose you really want
this where the node doesn't know about
the edge at all and the edge doesn't
know about the node at all well that's
interesting how do you do that so the
way you do it is kind of Java like in in
a sense because what you do is you
replace all the pointers with indices
and that's what we're going to do here
we're going to get rid of those class
declarations entirely and now everything
is just going to be an ID so it's going
to be an index into a higher-level array
and when we do that we get this
this this graph dot H and we have no dot
H and edged H and vector and that's all
included in graph and they have vectors
of nodes and vectors of edges but the
nodes the nodes story IDs and the way
we're gonna have to deal with this is
we're going to change all of those
things to IDs and now when you ask a
question you're gonna have to do some
interpolation this is the opaque pointer
version and we're gonna change that to
this the dumb data version requires you
to go through translation in the graph
and the code is absolutely ugly but it
has this nice property it turns
something that is not external izybelle
into something that is external izybelle
like you can externalize a graph but you
can't externalise a node or an edge but
now you can because there are no
pointers there are no process depended
things these are all fundamental types
that are we would call full full-blown
value types so this is an interesting
thing this is the way we would write
these kinds of functions now without the
node or the edge knowing about the other
type at not even in name only so it's
just the logical extension of an opaque
pointer Java style yes ok so the
question was create an abstract type
would reduce would increase type safety
okay so if you're doing this you're
already desperately low level this is
might as well be writing and see so I
understand what you're saying and yes we
could probably do some things to improve
it but in its purest form what we've
done is we're turning an ID by returning
a pointer which is a bunch of hex digits
into a number and I yes of course I know
of an edge pointer and a node pointer
won't be confused right you won't
confuse the two because they're gonna be
independent types whereas an integer you
could get them confused and call edge
when you mean node and so on so yes you
could create tight
versions of that but I didn't but you
could I'm not saying you should but you
get the idea any many more thoughts very
whether the question is can we use
template parameters to do something with
with with creating separate types I
think just creating an edge integer and
a node integer index somehow would where
the types are distinct would add some
level of type safety perhaps as a rule
just historically I haven't been very
big on turning integers into typed
integers just in general and the reason
for this is I and this might be a good a
good place to do it but for example if I
had something like I don't know age and
shoe size to me they're both integers if
that's what makes sense and creating a
separate type for each integer is more
than overkill it actually causes a loss
in interoperability whereas having a
date type compared to an integer is a
very good thing because the algebra of
date and integer are dramatically
different whereas the algebra of the
integer that's returned when you ask for
somebody's age or you ask for their
whatever Social Security number you know
those are integers as far as I'm
concerned so but but that's another
topic anyway yes there are ways to make
it safer and in fact that it's so unsafe
is probably indicative of why it's so
low level and ugly that we probably
wouldn't do it unless we really were on
a mission and this would be done only at
a very low level it would not be an
interface level but I wanted to show it
anyway yes
okay you're ahead of me that is that is
part five of the callback section that's
at least 20 minutes away redundancy when
I first went to Bloomberg I really got
my butt handed to me because I had a
tiny little bit of redundant code in a
bootstrapping at the very lowest level
of the system this was 14 years ago it
was like heresy that I would ever think
to have any redundant code at all in the
entire system now if you only knew how
much redundant code there is it's it's
unbelievable that I was so chastised but
anyway
okay deliberately avoiding reuse by
repeating the small amount of code or
data to avoid coupling this is not as
bad as it sounds I'm talking about a
tiny amount I'm not talking about
cutting pasting you know wild amounts of
code I'm talking about very a surgical
thing but let's take a look at this
suppose I have a large system and a
small system and I have some clients of
the large system and I have a lot of
clients of the small system okay now
everything is going along just fine and
I realize oh there's some redundancy oh
my goodness what am I gonna do so I say
oh well I'm gonna just not I'm going to
get rid of that redundant code and I'm
gonna depend on something else so let's
say that that code is is leap year so
that's not a lot of code but you know
maybe I don't want to have it in two
places because I could get it wrong now
it turns out that somebody decided to
have this redundant code and and
unfortunately he got it backwards so it
was it was about one February 29th ago
when when it was whether you could trade
on the day or whether it was a trading
day or not and they just got it
backwards and so you know it worked up
until that year and then it stopped so
you really don't want to write complex
code in a lot of places unless you're
going to test it if you're going to test
it then it's not as bad but not
everybody tests their code so anyway
things change now this is a
it turns out this isn't is proleptic
Gregorian leap here and oh well it's too
complicated let's make it really simple
let's just have min for intz only so
there won't be any contention now is it
okay to repeat this code or do I
absolutely have to reuse this and I'm
gonna argue it's okay not to reuse this
if it's going to cause a problem what
problem could it cause well let's say I
take it out and I call this other thing
now that's not so bad because it's over
here in this tiny little thing and these
clients are slightly unhappy because now
I pulled in a dependency on something
for nothing you know absolutely nothing
but all right I did it
they're little unhappy but they just
changed their link line and it's fine
now imagine I go the other way and I say
well I'm going to have this tiny little
thing depend on this huge thing and all
of these people will come running to me
and screaming and say what are you doing
so that was a bad idea obviously the
right thing to do is to demote it to the
right place in the physical hierarchy so
that both of them can depend on it and
no one's going to complain because
that's going to be in some central place
hopefully where they already depended
anyway makes sense so that's the goal
now suppose you have a situation like
this now you can't that you can't win
because if you do that these people are
gonna complain and if you do this these
people are gonna complain so you really
can't do either so that's not acceptable
you just can't do that so unless there's
a place to demote it then don't do it
bottom line is it's not worth it for
that little tiny little speck of code so
turns out for vocabulary types types
that are used widely throughout the
interface of functions interfaces of
functions you have to demote it you
can't have it in two separate places so
you have to think about these vocabulary
types and by vocabulary types you know
you think of something like a date or
you think of something like an alligator
protocol or something like that where if
you have to
one's nothing works so anyway so here's
another example suppose I have something
at the bottom of the system and I have
this very it's very heavily used by this
other higher level thing and maybe this
higher level thing has a really cool
component at the top that that that does
a great job maybe this is a wonderful
threading implementation or something
it's amazing it does everything so it's
well packaged it's generally useful it's
awesome but it turns out at the bottom
of this thing I need the simplest little
lock or the simplest little bit that
comes from this thing now some people
would say we'll just use it you know
just just go ahead and depend on this
thing and now you can imagine you know
my head explodes right because this is
crazy talk
now you could also just say well it's
not that much why don't I just move it
down here so I'm going to move a little
bit down here and it's not so bad it's
just a little bit but it prevents this
cycle which is absolutely horrific now
this is the kind of thing I got screamed
at for or when I first joined that was a
long time ago the culture has changed
dramatically and people don't really
scream anymore they just they just act
you know benignly
okay anyway over time you can see that
this thing could grow into something
that's really awesome and you say you
know what that's not really that big a
deal is it
so I'm saying sometimes this is the
right answer
I'm not saying cut and paste code please
don't get me wrong but sometimes you
need to do a little bootstrapping and
it's okay if that's the right answer
okay questions on that yes
okay her tattered definitions that I
heard enum or define when I said
vocabulary type if there's something
that needs to be shared right an enum
would be considered a vocabulary type so
there's something that needs to be
shared go across interface boundaries
that's what that's one thing
now remember also if you can demote the
thing to a lower level in the physical
hierarchy that's obviously preferable
okay yes okay the question is why don't
you always demote it
what if there's what if we really
talking about int max and you're gonna
actually create you know package group
and then a package and then a component
so and you're gonna have one little
thing in there and there's and you don't
expect that they'll ever be anything
else it's just not reasonable that's why
yes you can be wrong but guess what
later you can demote it and that yes I
don't think I've heard the story maybe
you'll tell me over a drink all right
ha all right now this was really the the
technique of of last resort when I
originally wrote the book in 1996 but it
turns out that it has come into its own
in the last 20 years and so there are
really five variations of this even
though they're really kind of all
callbacks so we have a client supplied
function or data that enables
lower-level systems to perform specific
tasks in a more global context now
originally the idea that I had was you
have two things that are cyclically
dependent so you just have one install a
callback in the other and you kind of
fake the idea that that somehow they're
levelized but they're really not they're
just this is just all syntax and it's
nonsense and stuff so I don't I I do I
really was very down on it in the
original thing I've changed my mind it's
still a call back but you can do it in a
much more respectful way these days
so there's several flavors of callbacks
so the first one being data then
function functor protocol and concept
and that's what I said we're going to
get to the concept one and that's some
stuff
we'll get there so the first one will go
back to the manager employee and one way
we can sort of do the same thing that we
did before but without making it without
doing a callback function callback is we
can actually install in the employee a
pointer to the member function or the
data member of manager that is
maintaining the count so the idea is
something like this where we we have
class manager and at construction we
install a pointer to the use count now
that means we're really we're returning
the dereference pointer to some piece of
the manager and so we're going to create
that separately because we don't have
direct access into the vector and then
the idea is when we add an employee
we'll bump this count and and everybody
who's an employee will pick up the thing
we're talking about does that make sense
so it's just it's just a kind of acute
thing now it's effectively demotion what
it really is kind of like is this we've
pushed the int down lower in the
physical hierarchy but it's a
fundamental type so we really haven't
done anything we've just sort of a
different incarnation of pointing back
to some sub part of what we were talking
about ok so this is a variation in value
this is something that was pointed out
by Tom Cargill inheritance is about
variation in behavior and and and data
is about variation in value and here we
don't have a variation in behavior we
have a variation in value and so we can
just use a pointer back to the
lower-level data all right next one is a
callback function and this happens often
you know you'll have some application
and it has some some things that you
want to install in a lower level library
but if we're not careful about things
maybe the lower level library winds up
pointing to the or using the save and
exit in main now of course this is
ridiculous no one would ever reasonably
do this hopefully but anyway stuff
happens so we don't want to do this this
is a cycle and a horrible one at that
because it involves main but with just a
little bit of changing around what we do
is we we make sure that there's a way to
install a callback in the library and
that's a very typical thing to do you
install a callback and in fact the
callback
now main has access to the to the
callback and the it also has access to
this specific module down in the library
and so the dependency is in this
direction so main installs the callback
and then the callback gets called by
this lower-level library when
appropriate and it turns out now that we
have this save and add function that
used to be a external linkage and now we
can actually even make it static and
local to main we don't need to have it
pollute everything else because you know
even though it's static you can still
install it just like you could an
external linkage function so kind of
cool something people do alright so
here's another example let's say
callbacks functions so back in the back
in the day when we had not wonderful
things like functors we would do things
like installing a function along with
its data and it would look something
like this and there would be a cycle and
so it turned out we went to something
that was a little better where we had an
event manager and we would simply
register
an event and it's data together and then
the function would would have a void
star and it would point to the data and
that the function would know to cast the
data back and life would be good and
life was good and we could have the
include in the any darn thing or we
could move it over to the implementation
it's all fine
and then one day we we got functors and
then we said you know functors are
better because they can wrap up the data
with the in the function so let's it in
vocable and so we make a few changes and
turn it into this and change our
scheduler event manager to look a little
more like this and then we change this
this schedule thing to look like maybe
this and if we waited till C++ 11 it
might look like this and life is good so
functors were better because they're
more modular and that's nice but there's
still callbacks right so not much man
magic here so I'm going on two protocols
or abstract interfaces so I happen to
like this game called blackjack and I've
always actually started when I was 14 I
was I was trying to figure out
conditional probability I spent the
summer writing the entire tree for the
game of blackjack on a continuous piece
of paper it's a big tree and I was using
one of those micro-fine flare pens and
it took me many many weeks to write this
all down but I did it I don't know why I
was crazy but I did and and I actually
figured out what conditional probability
was as a result so that that's a good
thing and I happened to go to MIT and
learn blackjack well before the the
people who Kevin Spacey was talking
about in the movie 21 I wasn't quite as
successful as they were though because
they really were out to make some money
and I was just having fun
okay well that said so here's my example
I thought the player knows about the
game and the game knows about the player
the game really being the table
and so there are things that you might
break out and this is all kind of just
tongue-in-cheek
because if you think about it what is a
deck of cards what does it really do and
some people you know you have to think
you have to have 52 card objects and all
of that of course that's all nonsense
but it still looks like a good slide so
I'm going to put it down here and here
here you know I have possibly the game
of twenty-one and a player and there's
certain functions on the game of 21 and
there's certain functions on the player
and they involve each other and we need
to do something about that and a really
good solution to this problem and it is
a problem because they know about each
other in the interface is to break the
problem up into the abstract player that
the game of twenty-one knows about and
the player the abstract player who has a
notion of the game of 21 in the abstract
pure virtual functions but doesn't
actually pound include the game of 21
and then the real player actually does
pound include the game of 21 and here we
have a levelized system and it just
works that's it it's it's that simple
it's kind of so simple it's it's ill
making and you could imagine that you
could have every component in the world
be an abstract interface and every
component in the world be the real
version of that and have every one of
them depend on every other one like that
you really haven't done any good for
yourself but this is a technique of
level ization in a pinch that you can
use but it does have a benefit and the
benefit is you can you can do more than
one of these players you can have for
example a real player a test player so I
can introduce a testing version of the
player so I can you know test the the
game of 21 separately before testing it
with the real player that's actually
really important and then I get really
interested maybe I want to have a
networked player and start my own
business so this is getting cool you
know now I can really do something fun
and make some money so this is this is a
nice property of this technique that
just
happens to fall out okay so the next
thing I have I want to start trying to
to use things at a higher level through
some sort of pointing back or whatever
but I know that's a bad idea
let's say I do that I create a backward
dependency well now these two components
are cyclically dependent well they're
the other technique that I can do is I
can create an abstract interface either
in that component or below that
component where a higher-level
component now inserts the the
higher-level component via the abstract
interface into this component and by
doing that I avoid the cycle I do the
same kind of thing of separating the
dependency from the abstract interface
and I can do that there but I can also
do that on a larger scale suppose I want
to depend on the thing at the top which
could happen but it's no different now
I've created this cycle across all these
components well that's not good but I
can do the same technique by saying the
higher level the very high level
component knows about the top of the
pyramid but it can insert the top of the
pyramid into the protocol below this
lowest level component upon which it
depends and I don't have a cycle again
so this is a very common technique when
you have a bunch of stuff and you don't
want it you don't you want to insert
yourself in there but you don't want to
cause the cycle so you create the lower
level interface
and the higher level actor and then you
can depend on it and it can depend back
on on the interface so this is a it's
been used forever it just works
there are many many instances of this
does this make sense
I'm just curious a little bit it does
okay is anybody like wildly confused and
so what does that stuff he just did no
okay good great maybe I won't select the
book as much as I have mid all right all
right so now we're going to talk about a
callback as a
set which is kind of a wild thing I
think it's wild someday we'll have
concepts and then we'll be able to do
this but even though we don't have
concepts yet it still works so suppose I
have I want to be able to stream out the
value of my value types date time
account all our value types and I want
to be able to stream them out in some
sort of byte stream and then stream them
back in later so all of these things
take a byte stream in the interface and
right now this is what this is what I've
got and they're all externalizing this
way and notice they're externalizing
well they're flat now they've been
they've been streamed out flat and I
just had to do this because I think it
looks really good
okay so unfortunately the byte stream
needs a char buff to hold the bytes but
the char buff needs to be streamed out
by the byte stream what's up with that
so this is actually kind of the cut case
where I got in trouble because I
actually had a low-level string they
didn't do much and then I had a high
level string that did everything and oh
my goodness but anyway so I have the
byte stream in the char buff and they're
you know like this they're they're
they're including each other it's it's
very unfortunate and that causes a cycle
and the cycle is not good so what would
you suggest I do having just seen what
we did before what would you suggest we
do okay so let's do that
excellent let's let's do this we could
do this right in fact we did do this and
then it looks like this can anybody see
a problem with this okay excellent
now I do want to point out that it is a
myth or if you saw the keynote it is a
frame that virtual functions are slower
than I want to say inline functions
it can be true but it's not always true
and in fact if you have have to say it
if you have an alligator that you've
created on the program stack the derived
alligator and you pass it in to a
templated container the client knows
about the alligators in line virtual
function notice I said in line virtual
function and how it's used in the
container and if you happen to be
working on on GCC today it's as if there
were no virtual function at all it was
just embedded in the type we've already
done that experiment it's not so with
clang so I'm encouraging the clang
ownership to start D virtualizing these
kinds of functions where you have access
to all the source and can do it the way
GCC does ok challenge made but it turns
out there are cases where virtual
functions really are too slow and this
is one of them and so we're not going to
do this we are going to do something
crazy what we're going to do is we're
going to define a stream concept and the
stream concept is whatever the interface
to the stream utility or stream object
was whatever it was that's our concept
and any type that has those methods and
satisfies that contract is going to be
fine that's our concept and then we're
going to put the care buff lower because
we can because now that the real byte
stream depends on the char buff and
guess what they're both going to
mythically depend on this phantom
concept that doesn't exist and they're
gonna do the char buff is going to do
this by the way with the template method
what do you think of that it's crazy
talk ok but it works so now you have
this char buff and it's got this
template method that takes the stream
you can pass in any stream you want
we're just gonna pass in the stream we
want it in the first place you could
pass in a test stream which could be
used with extra sentinels to make sure
that you really got it right or the
original production stream or any darn
stream you want to put in so we got some
more flexibility here but we have
absolutely no virtual functions there is
no overhead whatsoever
and now notice again this is a template
function a templated on the stream
concept and now you just forget about
the concept it's just this and it works
so this is this is a crazy that you can
externalise the char buff and the char
buff is used in the stream that
externalizes it it's all testable so I
think this is crazy I just I think I
love it what do you think yes what I
mean by externalized able is I have a
byte stream a concrete object that has
put into a put in 16 put in 24 point in
30 to put float 32 put flow to 64 put
char you know the char array put you
know what all of these fundamental types
and then I have the same get version of
it it gets them out in a stream and so
when I say external eyes it I take let
me take all of your whatever you want me
to put in fundamental types which it
recursively could be nested or whatever
into you know and put them into a byte
stream save it out to whatever send it
over the wire and read it back in again
that's what I mean by external I send it
out of process in a way where it can be
recovered and that's called streaming or
external ization or whatever yes the
question is when do you use a protocol
when to use a concept a concept is a
tightly coupled situation and a protocol
is a loosely coupled situation so if you
need high performance like you do in
this case clearly you would use the
concept approach the template per
approach if you need the decoupling
which which we'll see
much later in the next session then you
would use a protocol for sure you can't
scale compile time couple things the
infinitely it doesn't work
so take the example if you want a real
example take polymorphic allocators
that's that's like V example we really
do not want to have compile time if
enforced compile time coupling there
because we want we want it to be
interchangeable okay so do we have any
other thoughts on this okay what is my
stopping time now for 15 okay oh boy ah
okay so we have a manager class
establishing a class that that owns and
coordinates lower-level objects so we
have for example a list now manager
class really isn't a level ization
technique but it's an organizational
technique and it kind of fits in we want
to make sure we don't do silly things we
don't want to have a list that that
manages a list that manages a list that
manages a list it doesn't feel right you
know a list manages links and we
certainly don't want to have a link that
manages links that manages links because
that also doesn't feel right somehow
what we really want is some sort of
weight we certainly don't want this
crazy technique that was developed a
long time ago that's designed to blow
out the program stack where you
recursively delete the next link listen
we'll go there so these are these are
all ideas but they're not necessarily
good ideas what we want is a list that
manages a sequence of links and the list
is the manager class and so we have
something that looks like this and it is
a principle that we don't have types
manage types we have higher level types
manage types objects of that type so we
want a list of links we don't want a
list of lists right now that obviously
they're recursive situations where who
knows but ideally when we're building
plain old straight normal things this is
that this is a design principle and of
course we would do it this way so that's
a list now let's go to a say a graph
a graph is something where if you don't
have a wrapper it's really hard to make
work if you try to do this Note edge
thing where you're holding on to the
graph by a node and the node the node is
superior to the edge the edge knows
about the node and in name only this is
a bear just try to do it it just doesn't
work and the equivalent the edge being
superior and and and trying to manage
the node in itself doesn't work so what
we really want to have is something like
this situation where there's a graph and
the graph goes about the node and knows
about the edge and this by the way the
graph is externalizing believen though
the node in the edge aren't so that's
what a manager class is supposed to do
and again it's it's it's it's a strategy
for dealing with ownership it's not
really a level ization technique but I
threw it in there anyway because I think
it's important all right next
factoring moving independently testable
sub sub behavior out of the
implementation of a complex component
involved in excessive physical coupling
that's a mouthful okay suppose I have a
widget and my widget not a lot of
accessories it's just it's just a lot of
functionality that's thrown in there and
it's really big and it's really hard to
test what could I possibly do well one
thing I could do is I could pull for
example the widget imp out of it and
maybe there are a lot of private methods
but in the widget in all the private
methods are public the widget imp is
there for testing purposes so I can test
the widget imp at a lower level but it
turns out the widget imp has all these
static methods in the implementation
right so I can't test those there
they're hidden in the implementation so
I could possibly break them out into an
implementation util bunch of static
methods of a struct and all those static
methods are independently testable so I
start at the bottom I test those then I
test the widget in in terms of the
tested functionality in the utility
and then of course finally I test the
widget knowing that most of the
functionality is already working
perfectly and I'm just wiring it up just
like you take the chassis of the TV case
off the the chassis work on the TV put
the chaise back on attach the knobs and
it's all good okay
so that's the idea there this is the
architectural a significant
client-facing interface these are the
private methods they become public and
file scope static methods in the CPP
file are made public and separate
utility struct okay just the general
telescoping when something gets too
complex another example is you might
have a date class in the date class has
a lot of complex functionality like a
large cache for relevant dates to go
from your your month day to serial date
so that's another thing you might do and
here's your ears your date interface and
and here's your your date impute ill and
the data impute ill takes most of the
functionality away and puts it somewhere
else so you can test that and then your
date class is just your your vocabulary
type and value semantics type rolled
into one whereas the util is just a
bunch of functionality that you can test
directly if you happen to re-implement
the date class with another util no
problem that one is still valid and can
be used by somebody else which is why we
don't want to hide it okay so now
suppose we have this situation where we
have a network machine and a cable and
it turns out that they all seem to
depend on each other and it was supplied
that way by our let's say our clients
our clients that I need this exactly
this you have to implement it and what
can you do because it's a big cycle and
it's a bad idea but you don't have a
choice
she had a choice you would not do this
she would do something else and there
are many things you can do if you have
flexibility over the interface but what
if you don't so what you can do is you
can treat this as one component and then
you can factor out the end
pended li implementable sub
functionality into three separate
components and this is often possible if
you work hard enough and you can test
those things independently of course
this goes to level 2 now but then once
you've done that what happens to the
higher level component it becomes
smaller fits inside its complexity
bounds because now all you're doing is
providing the wrapper that refers to the
implementations the separate
implementations and this is this is
basically what there is to factoring
there's probably many more ways to
factor something but this is basically
the idea ah ok questions ok the question
was why does the why did this the the
static members of in the CPP file go to
a utility class with static methods and
the answer to that is we don't think
that free functions are big enough to
merit having their own entity we want to
have an thing that is approximately the
size of a class that groups the
functionality into something that we can
treat as a unit so it's kind of like you
have to go pick up all your marbles and
put them in the bucket we'll deal with
the bucket but we don't want to deal
with each individual marble as if it's
comparable to something the size of a
class that's really the reason it's also
a pattern that we're very used to when
you see static foo util and a bunch of I
mean you miss our class foo you struck
foo util and a bunch of static methods
you know what it is it's just a very
familiar idiom and we don't want to go
there I mean the tons of reasons why
having to do with with not getting
accidental overloads when you misspelled
the implementation and the in the CPP
file in the namespace and we don't want
to deal with
argument dependent lookup because we're
not interested in that we want to call
the function we don't need it overload
set we don't need any of that so there a
bunch of reasons and part of it has
happened but it's fine it works gets the
job done we love it
another reason is you can't use using we
don't want you to use using so just
short ok that's really the reason there
are a lot of reasons they're really
they're like seven reasons I get mail
you the reasons I don't know if you'd
like it but okay alright so the last one
is escalating encapsulation and I hope I
get through this one if I go over by a
couple of minutes forgive me but I
really think this would be a good place
to break I'll try to do it as quick as I
can
moving the point at which implementation
details are hidden from clients to a
higher level in the physical hierarchy
so imagine you have car engine and spark
plug alright
they each have their own sphere of
encapsulation each one of them is
accessible by clients what I mean by
that is you can see that the car used as
an engine you can see that the engine
uses a spark plug because it's used in
the interface okay three different
spheres of encapsulation now imagine I
change the car to use the engine in the
implementation all of a sudden the
engine is not in the interface of the
client-facing pieces which are car and
spark plug okay so when that happens I
just have a car because yeah the engine
is using a spark plug in the interface
but I didn't know I was using an engine
so it doesn't matter
so effectively when I say car uses
engine in the inner in the
implementation the only thing I have is
a car yes I could go use an engine in
another car but this car doesn't have a
way to know that I'm using an engine
programmatically so this is important
that means that what's going on between
the engine and the spark plug who cares
right with respect to clients of car now
this is a kind of a interesting thing
what if I changed the engine to fuel the
engine from spark plug to fuel and I you
put a user's in the interface dependency
from car to fuel
well then the car uses fuel who knows
about the engine it looks like this
those are the new spheres of
encapsulation for this system does that
make sense in some very abstract way the
cool thing about the this we'll see is
that when something is not in in your
when it when it's not visible in in the
touch points that you're trying to to
present it can change and your client
does not to not need to rework their
code that's the the key point of this so
for example let's look at our graph
again now right now we have we're going
to add to it we're gonna add no data and
edge data to sort of round this out and
here I have three levels I have a vector
by the way is at zero when I have
something at level zero it means it's
external to this local subsystem so now
what are my spheres of encapsulation
here I have I have graph using node and
edge and I have I have node using no
data and everything's used in the
interface so basically they're all
they're all their own deal right that's
the way it is right now the only thing
that isn't both graph and node if you
look don't don't expose vector in their
interface so these are the these are the
two spheres of encapsulation right now
or the two the two joint spheres of
encapsulation okay then suppose I say
that I'm going to expose no data and
edge data only out of graph but I'm not
going to expose node or edge now all of
a sudden we get something that looks
like this
we're the only pieces of this system you
know our graph no data and edge data and
whatever goes on inside underneath graph
is whatever I want it to be and you
don't care because you don't know that
I'm even using node edge or or vector if
that makes sense so this is another
technique and this technique happens to
be extraordinarily general so it's
important so
we have let's say this and we want to
put a single component wrapper on top of
it so I've got this nice wrapper I can
do this because it's all in the same
component and it's all my business and
that's fine I could do that if I wanted
to and they could then refer to this
lower-level
and my unit my sphere of encapsulation
is this right I don't expose any of that
stuff what I do is I have my own proxies
and I can reach inside the other one I
can my node can reach inside my edge and
pull out edge because it's all in the
same component and I can have friendship
going any which way I want to so that's
fine
but it doesn't work in general so I'm
going to show you for a multi component
wrapper suppose I have a date and I have
a date set and I have this dependency a
date set uses date in the interface and
of course I can put date in the date set
then I have my date my date uses date in
its implementation it's a proxy for date
and my date set user's date set in its
implementation it's approximate proxy
for date set and my date set uses my
date in the in the interface all right
so I want to put my date into my date
set and you notice that I have these two
spheres of encapsulation but how does my
date set reach into my date and grab
date and put it into date set and the
answer is it can't because it doesn't
have access to the date through the my
date interface because it doesn't no
it's just another client it doesn't know
so this in general isn't theoretically
possible or at least it wasn't until
recently but then I discovered some
magic so that's what I'm going to
present is the last part of this and
then what you can do is make it a single
component wrapper in which case this
works just fine right because if they're
in the same component you have
friendship and you just pull the thing
in and it just works single component
wrappers don't scale you can't have
arbitrarily large single component
wrappers another thing people try to do
is they try to somehow hide a header
file
in that way trying to try to create some
communication hiding header files is bad
you know having the cookie go away we'll
just hide the cookie and you'll have
this thing that left that takes a cookie
but we don't have the cookie header file
so what are we going to do so this is a
bad idea for two reasons
it convolve 'z architecture with
deployment and it inhibits side-by-side
reuse of the hidden component so this is
a bad idea so now we're going to see the
magic it's hideous but it's the best we
can do imagine I have a whole collection
of components sitting down down here and
they all do all these crazy things and
we don't want to burden our client with
all the work that we're doing down here
because we're it's under development so
what we're going to do is we're gonna
clone this system up I'm gonna clone it
up and we're going to make a set of
rapper packages now it looks like this
where every single corresponding
component with the same name but it's a
different package depends on the
corresponding lower-level component in
its implementation and all it is is a
single data member and now we're gonna
look at things where we say well I don't
really want to show that dependency so
we just take it away and it turns out
well as a result of that some things
fall down and then we say well there's
some inheritance relationships I
certainly am NOT gonna expose those so I
get rid of those and they go away and
then I say well I don't need that users
that I don't need that one so I get rid
of that and it goes away and now what I
have I say I really don't like that
sagging arc I'm gonna make that go away
so now we'll we have we have a view on
the original system it can't do
everything the original system could do
but it can still do some stuff and it's
whatever we want to expose whatever
components whatever sub functionality we
leave in is what our view of our system
is and that means we can have really
ugly stuff that could let things get out
of sync at the lower level we simply
don't expose that functionality at the
higher level but how on earth do you
reach in from one thing get it out and
put it in the other when they're in
separate components so this is the crazy
stuff imagine I have this left thing in
this right thing and in the wrapper I
have this left thing and I have this
right thing
and the idea is the right the right uses
the left in the wrapper and the right
uses the left in the system and the
right thing wants to grab the left
things lower-level piece and put it in
the right thing but it has to somehow
get to it
so this magic that happens is every one
of these holds simply the lower-level is
its only data member and then we invoke
something that's true in both C and C++
that people will not believe is legal C
or C++ and that is we can actually know
that the thing on the left if it's there
it must have a corresponding lower-level
thing by the same name it's required
that's what the rule of the packages and
so we can believe it or not we can we
can depend effectively the right can
depend on the left by doing this ugly
thing which is a reinterpret cast what
I'm going to do is take the address of
the guy on the left I'm going to
reinterpret it to be the thing it's
supposed to be depending on and then I'm
going to get it back and I'm gonna store
it in this this imp thing this damn
thing and then I can just invoke it and
it's edits I know it's crazy but but
you're actually allowed to do this kind
of thing so take a look at this it's
it's actually it's actually legal it's
guaranteed
I had Alastair Meredith look at it and
it's legal so do you understand the
concept I have this thing there's no
interface to do it at all but I know the
dirty little secret of this package is
everybody is shadowing something with
the same name and the lower-level
package therefore I can take its address
reinterpret cast it to the lower level
thing on get back the reference
effectively and then use that in its
place to put into my lower level thing
and it works so you can tell me you hate
this and that's okay but there's no
other way to do it and if we finally
eventually had modules that had sort of
package level friendship it wouldn't be
as good as this because that would
expose everybody to everybody else's
internals and all this does is expose
you to the public interface of the low
thing nothing more so anyway I'm going
to stop there because I've gone over a
little bit but that was the last level
piece of the of this so we can take a
break</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>