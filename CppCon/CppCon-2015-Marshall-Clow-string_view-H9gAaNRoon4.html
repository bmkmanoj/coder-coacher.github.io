<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2015: Marshall Clow “string_view&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2015: Marshall Clow “string_view&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CppCon 2015: Marshall Clow “string_view&quot;</b></h2><h5 class="post__date">2015-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/H9gAaNRoon4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon my name is marshal Clow I
work at Qualcomm down in San Diego and
I'm really talking about string view
today some of the things you can do with
it some of the things you probably
shouldn't do with it
so a little bit of administrative
ministry administrivia excuse me if you
have questions along the way just put
your hand up and and I'll point at you
don't need to save them till the end
although some questions I may look at
you and say you know I have a slide
coming up on that just hold onto it for
a second but I'll try to answer him
right away so I'll start with the first
question
string view is this what Dr nee was
talking about on Monday and what herb
was talking about Tuesday um no this is
something else this is uh this is
something that has been working its way
through the standards process for
probably the last 18 months is currently
in the library fundamentals ts a
technical specification and you can get
it in a recent version of both crying
and libs are GCC and I am not sure what
the status is in Visual Studio
somebody's in the room knows I'd
appreciate knowing Visual Studio 2015 it
would not surprise me to discover that
they had shipped some an implementation
of string view in 2015 but I do not know
for sure okay so given that what is
string view there's a whole pile of
words there and we'll try to unpack it
the class template basic string view
describes an object that can refer to a
constant contiguous sequence of care
like objects alright first question I
thought you were talking about string
view and what's this basic string view
basic string view is a template that's
templated on the type of a type of
character and a character traits class
and so specializations of basic string
view our string view and some other
classes in much the same way that
standard string is a specialization of
standard basic
stream so there are there are four
specializations of basic string view
that are defined in in this library
fundamental studious there's string view
which deals with characters W string
view with deals with W care T utf-8 or
utf-16 string view that's not the right
name that deals with 16-bit UTF
characters and the same 432 just like
there are four specializations of basic
string view for dealing with the same
four character types so there's a very
much a match between strings and string
view and we'll see that during the
presentation that there is there's a lot
of commonality between string and string
view which is not really surprising
because string view is meant to
interoperate very cooperative very
closely with strings
so what's other words here refer to a
constant contiguous sequence constant
Street if you have a string view you
cannot change the underlying data okay
constant this is this is emphasized by
the name string view this is a view into
some strings you can look at them you
can't change them you can change things
about the view for example you can
narrow it and make it refer to less
characters or you can reassign it and
make it point at different characters
but you cannot actually change the
characters contiguous sequence okay it's
a sequence of zero or more characters
that are contiguous in memory like in a
literal string constant that you write
double quote ABCDEF those are contiguous
in memory like in a std string in a
buffer that you have malloc tand you
have put characters in in a vector of
care those kind of things continuous
meaning they're not in a list or in a
deck or sum or a tree or of some kind
but they're they're right next to each
other in memory and care like objects
this basically means that
they those types that they standard
usually refers to is what it talks about
characters so there's Karen's
and W care and utf8 care and utf-16 okay
any questions about that let's start
here and go back there yes okay so the
comment was that Visual Studio 2015 does
not have a string view in their library
fundamentals ts implementation
shame on STL I'll have to give them a
hard time yes it's it's better defined
than that later on but I'm not sure I'd
call it well-defined it it has to be a
fundamental type and I so you know you
could you can manipulate using them
setting them copy and so on other than
that it's pretty much always used for
the four types I mentioned if you
specialize there for other types other
fundamental types it should work just
fine but I don't think anybody really
tried it there's there's more words in
the library fundamentals that say that
limit it limit its applicability but I
don't remember the words off the top of
my head I saw another hand back there
yes so the question is it does array V
you have the same limitation that you
can't modify the underlying underlying
sequence and the answer is this
currently in the library fundamentals -
yes there is not an array view there are
a couple proposals that people are
talking about and but none of them have
been put in either standard or a
technical specification they've mostly
been foundering on the the disagreements
on the best way to handle
multi-dimensional arrays a
one-dimensional array view is actually
really simple and could be very useful
but people are looking for a more
general solution yes
okay so the question is is the is the
implementation close to what boost
already has is boost string ref or the
LLVM implementation um yes but it is not
identical I actually wrote the boost
implementation from an earlier version
of the string view proposal because it
was originally called string ref and it
was based on a combination of the LLVM
the LOV 'm class and a class that was
internal to google is a guy that
proposal came from somebody at Google on
Jef Raskin and I mean I don't know who
initiated inside Google what Geoffrey
was the author but anyway and so the
boost string wrap is not quite the same
as this but actually fairly soon I will
be updating the boost string ref to be
pretty much identical to this and it'll
be adding a few more features I haven't
looked really closely I don't think
there's any really breaking changes
although I'm very tempted to change the
name of the one in boost to string rat
string view instead of string wrap and
that would certainly be a breaking
change yes I saw another hand here
okay okay so the the comment was that
Titus had asked herb at a previous
committee meeting whether or not that
the committee had adopted the the
convention of referring to things as
view when they were where they were
references to an immutable sequence of
some kind and they answer he got was yes
that was last November but over here
okay so what does it look like um
well it look like it's it's a string
it's a pointer in a length that's all it
is okay that's all the string view is
inside start a certain arranged length
gives gives you effectively a one a
pointer to one past the end I mean you
could implement it as two pointers it
doesn't make any difference really
except internally okay giving that a
string view has almost the same
interface as a constant STD string so
basic string view care which is also
known as string view has almost the same
interface as basic string care okay
there's a traits class there too and
both get sides but except with anything
that might modify the underlying data
stripped out so there's no insert
there's no erase there's no non Const
operator brackets there's no clear
there's no pop back there's no push back
I don't know what else I'm sorry substr
substr is not a problem because substr
substr does not change the underlying
data replace would change the underlying
data you know what that one's pretty
easy to write as a free function but I
think that that the idea was this
and that's a good question why not well
because we because we place on this STD
string changes the underlying data so
that the feeling was this was loose is
meant to be pretty much a drop-in
replacement for a constant string
reference and so having something with
the same name that conceptually does the
same thing but behaves differently was
thought to be confusing yes over here
I'm sorry it does not have ceased ER the
question was does string view have
ceased er and it does not and the reason
for that is very simple it cannot as it
cannot reliably provide the null at the
end STD string with an STD string
there's actually another character on
the end of the string that's a null that
the object maintains so that when you
call see stir it just hands you a
pointer to the start of its data see
stir and data ours are synonyms on a
standard string and that the object
ensures that there's a null at the end
string view because it doesn't actually
own the characters can't change the
characters it points to can't do that
give you an example if I take a see stir
say of you know I have five a string
ABCDE F and I take a street okay it
create a string view which starts at the
scene as three characters long de F well
sorry two characters long de the next
character is gonna be an F and and the
string view cannot put a null there it
could allocate some memory copy it in
there and put it all on and return that
to you but that kind of defeats the
purpose of a string view a string view
isn't it to be cheap it's not it's
supposed to avoid copying data it's
supposed to avoid doing memory
allocations I saw another hand go up
nope
okay
just how is it implemented yeah sorry
pointer I got one to hit me so what's
that not owning but again I mentioned
that a little bit not owning bit is
basically it doesn't own the doesn't
have any control over the characters it
points to none at all it's just a
pointer no link what does this mean it
means that it pushes the lifetime
management back on the collar back on
you if you're using it so if you have if
you're doing something like say parsing
a file okay and you allocate a buffer
and you read the contents of this text
file into the buffer or memory map it or
whatever however you do that and then
you start parsing it it's really easy
for you to pull you know to make string
views that point to part of the file and
pass them around and so on and this is
all fine until you're done with that
file and then you ud allocate that
buffer or on memory map the file and
then all those string views point to
something that isn't there anymore and
it's your responsibility to make sure
that you don't use them anymore yes
No so the comment was if you have like a
backing store file and you had a string
view into it would the backing store
have to be constant so that you would be
assured that nobody else would change
this data underneath you and the answer
to that is yes if that was the pattern
that you were worried about but most of
the times most of the uses that I have
seen for string view it's like you know
like parsing an input file or something
you've got off the network or something
and it comes in and then it never gets
changed if you if you're if that's
worrisome to you that that the data that
the string view is pointing to that
might change then yes you have to make
some kind of arrangements to ensure that
it doesn't change tightest yeah the same
well the same would be true of using any
con string ref right that you have to
worry about somebody changing the string
that the reference refers to at any time
yeah I I had a long discussion with
somebody a few months ago about in C++
11 now that we have now that we have a
threading model I pointed out to them
that there's been a difference a
semantic difference now if you're if you
write a function that takes a caught
string ref right before C++ 11 what it
meant was what you what you could say is
fine this isn't going to change for a
lifetime of my routine okay
now it means I can't change this and
that's a subtly different thing you know
something in another thread or whatever
Ken can change it and the same thing
applies to a string view except that you
know you don't necessarily have to have
a threading involved okay so when would
you use a string view instead of a
string so let's let's back up a little
bit and talk about
I do want a string actually no we'll
wait wait for that till I get an example
but anyway if you anywhere you pass you
have a pure function a function that
operates only on its inputs or maybe
some global state it doesn't actually
hold on to references and so on anywhere
you're passing a Const string rap or
maybe a a cost care star you can pass a
string view returning from from a
function where you want to return a
reference to a part of a string or a
string that you know it's the lifetimes
okay and also the reference to a large
you know a part of a long-lived data
structure okay example toy example but a
good example and this is where we start
getting into why so here's a real simple
example we have some code down the
bottom that calls a routine on a
constant care star and checks to see if
the first character of it is a C and
what does extract part do it takes a
Const care star but it takes a character
reference by and constant and creates a
substring out of it so how many strings
are created to just run this code so I
can I can say I'm I'm confident that
there are there at least two okay I'm
also saying if if a compiler does not do
return value optimization there's two
more there's at least there's at least
two and possibly four let's walk through
this okay
the call to the call to extract part
right it takes the character literal
ABCD efg counts its length allocates
memory copies the data into the memory
it allocated construct say a std string
and passes it to extract part by cost
reference cons reference then our
reference extract part excuse me calls
substr passing that also arc passing
that by conference because because
that's a member function so it has an
implicit this parameter at the front
which it passes by cost reference so
there's not another copy made substr
creates a new string allocates memory
copies data internal to substr returns
it which might be another copy although
really compilers are getting better
these days they're probably not a copy
there but there might be and then
extract part returns it again region
which might be another copy but
hopefully not and then we call front on
that on that temporary that's returned
to get the first character compared to
see and then throw it away
so I count one length calculation for
memory allocations let's just let's just
say there's only two but in any case to
two memory allocations two sets of
copying data and then two memory
deallocations all for some all to
determine that some things a see ok
small the small string optimization
helps a little with this you could get
rid of some of the memory allocations
you know in this example you might get
rid of all of them all the memory
allocations but you still have to copy
the data and you have to have to count
the length there was that what you were
gonna say okay sorry stepped on your
line anyway that's a lot of work for
this okay so why do we care about
temporary streams yes
probably can't elide the copies as well
but you still have to create at least
yeah yeah I still have to create to you
can you lied the copies on the way out
the returns maybe yeah so anyway yes it
is the smallest is common it was a small
spring optimization is awesome and also
said that for this example it's quite
possible that the compiler would unlock
in line everything and try to get rid of
most everything yes but this is a toy
example why do we care about temporary
strings
well temporary strings are actually not
really that small I mean they just of
three pointers I mean at which on a
64-bit machine is is 24 bytes they can
cause memory allocations the SSO the
small Turing observation helps with that
and you have to copy the data ok copying
character data is not hard you can use
mem copy or something like the moral but
it's still you have to copy data and
there's nothing quite as fast as not
doing anything so one of one of the
things that it also has changed from C++
C to C plus plus 11 is there's just
general frontmatter in the in the start
of the standard that basically says in a
threaded environment access to a shared
resource has to be serialized it has to
be by protected by a mutex or something
else or you get race conditions and then
you you're in undefined behavior land
and that is just so not good
yeah I've given talks on undefined
behavior I don't think at this
conference but at ACC you and it at C++
now but in any case you don't want to be
under in undefined behavior land that is
not a happy place for for getting
reliable results out of your software
anyway the point of this is the heap is
a shared resource okay in a
multi-threaded environment access to the
heat at right
meaning allocations and deallocations
system have to be serialized okay and so
if you're creating a temporary string
that requires a heap allocation and
somebody else is doing something similar
you're gonna have to wait till that heap
allocation is done before you can start
yours and yes you can play games with
allocators and thread-local allocators
and so on and mitigate this but even
better like I said before is no work is
much better than even the smallest
amount of work so if you cannot do heap
allocations you're you're ahead of the
game which is why the small string
optimization is such a big win it's not
even that it saves that much space it's
that you don't have to go to the heap
okay same example one little change
right string view that's the only change
to this example okay that's the only
change so what happens here um we okay
we call extract part we have to create a
string view string to has an implicit
conversion from a Const care star okay
it has to traverse the list because it
needs a pointer and a length
traverse the constant to find the null
on the end so it knows now that it's a
and seven right seven okay it passes
this to on to extract part extract part
then calls substring on it because
string view has a substring member
function it's the same as STD string or
excited it's pretty much has the same
error face as a constand 'red string
which returns a new string view that
refers to characters two three four five
in the original string view returns that
returns that and then we call front on
it which returns the first character C
so what have we done here we've created
two string views maybe four if you know
if we don't have return off value
optimization
but we have no heap allocations no
copying of data we have to traverse the
sequence once to actually find out the
length at the beginning so instead of
instead of two or four he up a location
x' and two or four copies making data
copies we have none of those and your
code runs faster now this is this is the
kind of thing this is the kind of thing
where Springview shines okay you have
you have something that takes a a
contest II D string ref and you want to
and you can replace it with a string
view when what your your function
doesn't make a copy of the string or
hang on to a reference to the string
because then you have lifetime issues
right or you know you don't stashing it
in some kind of data structures
long-lived data structure and you don't
need to write to the underlying string
you hence the constant okay um any
questions about yes/no there's a
temporary string view constructed if the
the constant the string constant exists
exists for the entire lifetime the
program the question is who's owning the
memory and the answer is it's it's a
it's a string literal that lives they
don't lives in your executable yes well
the question is why not an array
constructor one that doesn't have to
construct the string there is a
constructor that takes a pointer and a
length but when we discussed that
there's yeah embedded nulls are a
problem but the other thing is how many
is that there I mean that that has type
that has the type of an array of eight
because there are really eight
characters there there's the null
and so when the array constructor do you
want it do you want a string view that
has eight things in it with the null on
the end no you almost almost always want
seven but sometimes you do want eight
and so it hence the embedded null is
common and so the thought was you know
what treat it's a null terminated string
find the null if you know how many
characters you want you use the other
constructor where you have pointer and
length I think you were next I'm sorry
say again the could the could the
compiler could I don't know if it will
but it could yes
mm-hmm well in this case the illness
there are eight eight over there so
here's that here's another interesting
thing I about how this the basic string
view was was templated on a on the
character type and I kind of glossed
over the fact that has that it has like
standard string it has a character
traits template parameter as well and
one of the calls to character in the
traits class is length and so you can
you can in fact specialize this and use
whatever delimiter you want if you want
to 55 as is your end of end of sequence
marker you can do that this is you know
just like STD string and so so basically
the the what people decided was you know
people wanted the the default case was
felt to be this you know it's a you know
it's a character literal which we all
think of as null-terminated
and then if you have something with
embedded nulls or something like that
and give the length explicitly yes the
question was because this has the same
semantics as STD string there's not any
any range checking in the substrate
called no that's not true just like STD
string it will not give you a string
which stretches mirror it's returning
you a new a new string and so if you say
like 2 7 it will give you from position
2 up to the end of the string give you
back an empty string just like the
standard string yes
yes
yes that's right
so the question was is if you have a
long string and you don't want to pay
the cost of the link because you already
know it yes you can can you create a
string view from a pointer and a link
absolutely there you know three
constructors right there's one one from
an STD string one from a from a note
upon T Const care star which is a you
basically calls the character traits to
find out what the length is
and then there's one which is just a
care star pointer and a length and so
that one doesn't ever ask anybody how
long it is because it knows so if you
want you know you had a text file that
had an embedded Knowles you say begin
end actually I believe there are no
there are not I was going to say there's
there's a constructor with a pair of
iterators but I don't think there is
because then the onus would be on you to
ensure that they were contiguous as far
does it kind of transparently convert to
string no there is a call there's a
member function on there called two
string which will create a new STD
string and return it to you it was felt
that this would be a bad idea because
that's potentially an expensive
operation you have to allocate memory
you have to copy things it's meant to be
explicit if in fact this gets accepted
into the standard I would expect that
STD string would would get a converting
constructor from a string view but that
it would be explicit you would have to
actually say that I I want this to
happen rather than happening it happened
implicitly yes why does it what
um why did we not define a UDL for
string view we had some discussion about
that and at one point we we had SV for
them and I don't know what happened to
that thank you
you might even still be there
I don't know certainly if it gets put in
the standard we should have one of those
set so the question was they can explain
UDL UDL is that is shorthand for a
user-defined literal and it's basically
it's a it's a way of defining a simple
way to construct objects for example if
you say quote two three four quote s
that will construct a standard string
with two three four in it and we would
have SV or something like that for to
create a string view the same way okay
next slide here's something that we see
a lot that the LVM team saw a lot when
they were moving to string view they had
you know some call that took a Const
care star and life was okay you know and
they they had some strings and they
wanted to call it and so they calls
Easter and this is stilt this is fine
this works but somebody said you know
Conn secure star hmm that's the problem
we don't like that anymore that's you
know that's old and tired we should use
the new shiny stuff and snow Titus and
his team went off and wrote a tool that
ran through all of googles codebase and
change these all desks contest TV reps
great right perfect
so who can tell me what happens in that
last line okay I can tell you the first
thing that happens is it is it compiles
and it runs correctly I can get into
that but how about anyway on this side
yes it will make a temporary copy of the
string right it will take the string foo
call its cease remember get a Const care
star make a temporary string allocate
memory copy
data calculate the length and then call
legacy call and then destroy the tamper
a string this is this is a silent
performance stealer for you
so next step
legacy call string view we still we
still don't have to change the any of
the calling sites okay legacy call hi
mom
okay you have to traverse to find the
length but you had to traverse to find
the link when you had a con string as
well but you don't have to actually copy
any data you don't doing memory
allocations um the call of Foose Easter
again you have to traverse and find the
length but there's no memory allocations
there's a temporary string view made
there in both of those cases but those
are cheap and in the last case if you
just say foo which is absolutely the
right thing for this version it's still
the right thing here because there is an
implicit conversion from a cess TV
string to a string view and that's
really cheap because basically it calls
the two item constructor pointer in
length it calls it data size boom you
know no counting no copying no nothing
yes
yes that's absolutely true there's that
there's a semantic change here if you
have an OLE in the middle yeah they'd be
yeah
yeah haha yay yay tests
yay tes okay
any other questions about this example I
mean I apologize for the slide wariness
of these examples you know I have to
have to fit on a slide which means
they're really kind of toy examples but
still right right so no they know that
what I'm saying is except for this
bottom call here okay it's all going to
behave the same because here if you
assume that the that legacy call
basically went from the pointer up to
the null okay yeah no I did not mean to
imply that I meant to imply you know
something that's been in your code base
for a long time yes right unless they're
explicitly unless they're taking
function pointers in which case then
then it's
I'm sorry say that again I do care
string view is implicitly constructible
from a care star what but not oh yeah
right yes you you do in in in this case
yes you change you change internal the
legacy call but the same with that right
if you change it from a constant care
star to a to a string ref you still have
to a string reference to string you have
to change the the body inside I was
talking about changing the outside okay
right you do you yes well if you do have
to make fundamental changes yes if you
if the first thing you did in the legacy
call was to calculate the length and
then work basically bit off of a pointer
and length then you're golden
but if you were if you're doing things
that assume that it's null-terminated
then yeah you're going to have some
makes more changes internal but I
figured that you know internals the
legacy call those are those are things
that change in one place and those those
are easier to fix than things that
change in ten hundred or a thousand
places or a hundred thousand places
anyway um string view is constructible
from these three things I've talked
about this a little more a little bit
before the null-terminated string or
this string that they basically not even
a null-terminated string but a string
pointer this requires traversing the
string to find the link all the other
ones the other two are very cheap no I'm
not not to iterators because it's easy
to have iterators that don't describe
contiguous storage yeah but if you have
two pointers you just subtract them and
you have a length you know we could do
that inside or you can do that
externally it's it's there are there
moral equivalence
okay other questions about the
constructors string view interoperates
with STD string you can compare them you
can compare us an STD string to to a
string view or to a null terminated
string you can the whole idea was that
you could basically drop in string view
in places where you had a constant
string because they have the same
interface lots of people have thought
myself included that the interface to
STD string was politely say a bit
overdone string view has the same
interface in general it was felt that it
was more important to have it have the
same interface than it was to say you
know the string is a little overdone it
was meant to be a drop-in replacement
yes it doesn't give right you yeah if
you if you're going to if you have a
string view and you need a null
terminated string you're going to have
to do some work yes because it doesn't
give you see stir that's exactly correct
yes what yes you have you get algorithm
you get iterators you get caused
iterators they're the same they're both
constant but you have both iterator and
concentrator types and you can and you
can do our begin RN c begins c and all
all the the iterator goodness so yeah it
works very well with all the standard
algorithms as long as it doesn't change
stuff so you can do find if or copy if
or or search or whatever and and i will
point out that it works just fine with
the the other stuff in the standard
library that has a whole bunch of new
searching algorithms including your boy
or more and boy or rehearsal they were
great with string view because they
don't know anything about string you yes
can you knew somebody was an asset can
you construct a string view from no
pointer
sure absolutely
um you better give it a zero length
because you know you know you can't
actually indirect a null pointer you
can't reach through a no pointer
but yeah it's undefined behavior but I'm
sorry from a false no it's it takes a
pointer I'm not a iya
I sure hope not no I mean we have a
typed language
let's not abuse the language you can you
can can you can do it from nil putter
certainly I'm in fact that's the default
state if you default construct a string
view you get a length of 0 and a pointer
of null and like like um STD string you
can call data and you can call size and
it'll give you the pointer it'll give
you the size if you get a zero size you
better not go looking at the pointer you
and then you
you know this the conversion from a
string to a string view is in is an
implicit conversion it's a string view
to string it would be explicit yes it's
not explicit right now because the
string view is in library fundamentals
which is not actually part of the
standard and so we're not we didn't
change STD string it must it must have
been ok must be brand new because I
missed that because yeah we have we have
the the thing they call two string which
returns a string okay yes right we we
prefer the users to do the size because
as go back to this example here this
this this string this this thing is an
array of eight characters so you want a
string view with the length of the size
of eight even though there are seven
characters there plus a null so that's
that was why he said you know first they
the default there is to just take
calculate the length from the traits if
you if you want it yes
that was the question is are there any
observable differences between a null
string view and an empty string view and
the answer is yes there are this was a
matter of some controversy and a long
discussion are there differences between
any two strings that compare equal well
sure you can call data on both of them
and compare the pointers and they're
different if you have to string views
that compare equal which might say that
they're there both of 0 lengths they
compare equal you can call data on them
and compare the pointers and you find
that the pointers are different yes
absolutely they're they're both empty
string views there's not really anything
at any any idea of a null string view
there's a string view whose data pointer
is null but that's not a null string
view it's just it's an empty string view
anything any pointer and a 0 length are
going to compare the same okay
did that okay we have some added
functionality as well for our string
view not a lot that's not in standard
string there's this idea of removed
prefix and remove suffix which is
basically a substring operation that's
specialized for the beginning in the end
you can think of what remove removed
suffix does right it just adjusts the
length and remove prefix adjust the
pointer and adjust the and adjust alexis
slice it over into and it's this is very
very cheap because there's no data being
moved right you just update a pointer in
it or a size writing trim for example
for a string view would be should be
really easy you know you go to the end
and use and you trim off stuff and you
go to the beginning and you trim off
stuff and you're done and you know
there's no data to move around you don't
have to actually to delete the
characters out of the middle and shuffle
everything over much cheaper than in a
string yes
question is does it provide built-in
protections for under run or over run
for remove prefix Andrew suffix I do not
believe it does
you're just I think it in the standard
it just says you know precondition that
that the number of characters you're
removing has to be less than or equal to
the size okay
drawbacks of string view and there are
really there are two okay the first one
is that the gentleman over here has has
popped on a string view is not
necessarily null terminated and in
general it's not okay it when you when
you create a string view out of a
sequence of characters you have no
guarantee that the next character is an
own the string view has no way of
knowing that in a way of enforcing that
if you need a null terminated string
it's easy to make one but it involves
creating a string right allocating
memory copying data stunts putting the
null on the end if you can live without
that restriction then string view is can
save you a lot of effort but if you have
stuff that you have to you know that you
have to pass to some legacy C API that
you can't change then this is going to
be a problem and strings you may not be
the best solution for you um the second
problem is lifetime management there's
no connection between the the string
view and the storage it points to except
what you make yourself and logical or
programmatically or or just no that's
fine however you want to do that this is
why the examples will have to do with
you know simple procedure calls it's
really good for passing as parameters
instead of a con string wrap this is
this is one of the place that shines as
long as your procedures you know just
just do calculations based on the data
and don't actually change it and don't
like hang on to a reference to the
string and want to refer to it later
then it's this is a really good solution
or if you know you're a compiler and
you're you're parsing a source file and
you have it you have this big buffer
following around hanging around in
memory and you know that's not going to
change then it's a good solution if you
on the other hand if you those don't
satisfy you those you can't satisfy
those requirements or that doesn't meet
your usage model then string view may
not be the right choice for you it's not
meant to be this be-all and end-all
solution to every problem that's it's
meant to be something that solves a
fairly common problem in a lot of code
bases so you know consider that consider
the drawbacks consider the limitations
and if it works for you that's great
because you know you will find a find
significantly less well memory access to
data copying hopefully smaller passing
parameter passing things like that
questions about this yes life yes he
says sounds like lifetime management
brings up some thread safety right life
so it does passing through string refs
across thread boundaries is again the
onus is on you to manage the lifetimes
not the string rack there was another
hand over here
yes
you
consider this example you have a string
view that points there you cannot change
the underlying storage because it's
probably mapped to a read-only memory
region yeah but not that the the the
idea was and and reflected in the name
was was that string view was meant to be
something that you could look at with
the original name was for this was
string ref and it's still called string
ref in in the LLVM codebase but the name
was changed a string view specifically
to remind people that this is a
read-only view into some storage as
opposed to a general manipulator of the
storage mm-hmm okay right this is not
that adapter sorry uh yeah on the other
hand really it's not that big a chunk of
code it is it was trust me I've written
this a couple of times this is not hard
to write and the nice thing about it is
since it's a template my next slide
tells you where you can get it you can
look at the at the implementation and
see it's you would it isn't is less than
an afternoon's work it takes longer to
write the test than it does to write the
code tightest here the question
right or even if it's not very rare it's
much rarer than the read-only case I saw
hand over here in the back okay okay so
the comment was suppose you have a class
that takes that has two two strings as
member funk as member variables and and
you initialize them in the constructor
if you wanted if you want to to allow
your callers to initialize these these
member variables with a string a Const
care star and a pointer to length you
need six constructors with string view
you only need one constructor that takes
two string views and then you copy the
data into the member variables lifetime
management is not a problem but you've
also you've eliminated five of the
constructors because the string view is
so I that was no that wasn't the word I
was looking for I'd I I'm going to say
promiscuous even though that isn't the
right word because it is it accepts a
lot of different combinations
it's accommodating thank you that's a
that's a
better word anyway that's not as an
advantage I had not actually thought of
but yeah I like that
okay yeah if you add a third string
suddenly you have you need 12
constructors instead of 1 and the other
thing is is if you have string members
right and you want to hand out pieces of
those to somebody you can return string
views and and then tell them that this
string view is good as long as the
object lasts yes so who is first okay
got it so the suggestion over here is
that your your constructor could take
the strings by value and then and then
move them into your member variables it
does not have all the same constructors
as string the question is does it is it
it is part of the design that has all
the constructors of STD string it does
yeah pretty much yeah I'm thinking of
yeah the the two iterator constructor
for example the string has string view
does not why not because to iterators we
have no way of knowing if they're
continuous they refer to contiguous
storage if you have two iterators and
you know they're contiguous take the
address of the first one you know do you
reference and take the address and
subtract them and hand me a pointer no
length yes
right yeah there's there's not really a
point in construing view unless you know
you as a member variable and or
something
it's a mutator but yeah and the other
thing is the string views are meant to
be passed by value and so you know
there's not really you know you don't
really need to point them pass them by
cost reference you just pass them by
value they're cheap to copy right yes I
I know um the only reason I can think of
it to have a contouring view is is if
it's a member variable of one of your
objects and you you're expressing the
fact that this is not ever going to
change during any any lifetime of your
object yes
okay but I have a couple slides left and
I've just been notified that we are out
of time so let me pop through these last
couple five slides and then we'll go out
in the hall and I'll ask answer your
questions for as long as you want where
can I get string view string view is is
available in the latest Lib C++ and Lib
STD C++ but not yet in Visual Studio
2015 boost has string ref which is based
on an earlier version of this proposal
and this will be updated as soon as I
get around to it which will hopefully be
soon future directions there have been
multiple proposals for array view which
is a similar thing they have they have
foundered on mostly people disagreeing
on how we handle multiple dimensional
cases but you know this is a place where
there is continuing work going on and
Eric nibbler who is giving a plenary
talk tomorrow morning about his work on
ranges this is a more general solution
not limited just two contiguous
sequences or just care like things I
highly recommend Eric's talk tomorrow I
he's going to take what seems to be a
simple problem and it turns out to have
surprising surprisingly complicated
things are surprisingly difficult things
and shows you how to solve it actually
fairly simply and I'm done so I will
take more questions outside</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>