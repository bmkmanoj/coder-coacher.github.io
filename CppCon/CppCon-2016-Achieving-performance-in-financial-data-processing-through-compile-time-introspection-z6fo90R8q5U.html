<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CppCon 2016: &quot;Achieving performance in financial data processing through compile time introspection&quot; | Coder Coacher - Coaching Coders</title><meta content="CppCon 2016: &quot;Achieving performance in financial data processing through compile time introspection&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CppCon/">CppCon</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CppCon 2016: &quot;Achieving performance in financial data processing through compile time introspection&quot;</b></h2><h5 class="post__date">2016-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/z6fo90R8q5U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon everybody my name is
Eduardo Madrid I'm gonna be the
presenter about how to do a little bit
of introspection in C++ applied it to
market data financial market data I have
a kind of an ambitious program so I will
have to go fast and for the people that
is concerned whether this is a
presentation that assumes a financial
knowledge it isn't it's going to be
practical it's going to be mostly about
simple small
meta programming techniques to
accomplish the introspection and gain
benefits from it I think I should
explain why the title my title is a
quite a mouthful so when I referred to
ultimate performance well we are adults
we know that that is not attainable what
I mean is that we're gonna approach how
to get more performance when we have
done everything else right by the use of
introspection and introspection doesn't
only give us or performance or at least
this approach that I am trying to
present to you will not give us your
performance was gonna give us all the
benefits as well we will talk about
those and why introspection might help
well the general idea is that here these
techniques are to help the compiler
understand better what's going on what
is it that their program is going to be
executing at runtime in that way the
compiler will be able hopefully to micro
optimize more than otherwise the the
presentation I hope is gonna be of
practical importance or practical use
for the attendees we're gonna see I'm
gonna give you a glimpse or for the full
complexity of the market data that a
very important financial exchange
provides to further emphasize they make
the practical nature of the techniques
that I'm going to be talking about
for financial data in the case of what
we do at the company their work for
performance is important of course the
literally money's on the line and I hope
that these techniques are are not going
to be just an exercise to accomplish of
what the subject of participation is but
they they are useful in a more general
way all right
so compile time introspection what do I
mean by that introspection is a facet of
the more general topic of reflection but
it refers to only when the program is
reflecting about itself without the
intention of changing things like for
instance typically that we will talk
about in a minute iterating over the
members of a class is just reflecting
about what are the members of a
particular class
there is no no no no need to change
anything so that self inspection process
that they code reasons about itself
without changing is an introspection
they wait accomplish these things
require the more general subject of meta
programming so we're going to be seeing
meta programming techniques applied to
introspection and to the objectives that
I set up in a bit well I come from
Creole Capital Management it is a large
trader of futures it is an eager
consumer of the type of market data that
we are going to be talking about for us
the performance is important we work on
a Linux environment we do automated
trading we had to be conservative about
dual-chamber actions so unfortunately we
cannot adopt out the very latest stuff
when as soon as you just released on
this to do testing and perhaps some
isolated production deployments we don't
require c++ 14 if we don't need to but
if if we need we're open and are you I'm
really thankful
because it made this presentation
possible I have gotten a standard
sponsorship you want to be participating
more in the community so please please
feel free to contact me offline after
the presentation I am a senior developer
because I have a very long history
developing in C++ I have been educating
people about C++ and I teach the modern
way of programming in C++ as opposed to
the whole one and I get very upset when
people try to tell me that
C++ is as it used to be 20 years and I
am also blogger and I'm going to take
the liberty to plug a couple of times to
my blog and what are the reasons that
enabled me to come to introduce B 5
years to you hopefully there is going to
be novel is because I carry experience
with our functional programming and
logical programming especially
especially Prolog and I think they are
very relevant to C++ or meta programming
templates and all the whatnot
the reason being like for instance we're
gonna see that at the gist of it all
pattern matching is extremely important
when you do meta programming and button
method relies on the overload rules of
the language which are extremely complex
so learning pattern matching through the
rules of overload of C++ it's extremely
hard so perhaps it is a good idea to
come from a different background in
which those things are more natural you
will be surprised but I have less than
three years doing a meta programming
um what happened was the term when I was
a interview that the job that I have
currently one of my later co-workers
asked me I made a programming question
and I sort of was able to answer it
better I
and the weather the seed of interest
that brought me to this object because
whether it has practical application or
not is something that we're going to be
talking about and I hope that I helped
you to persuade that it may have
practical application more than then you
were thinking before and Rohan if you're
looking at this representation I hope
that this I see well the the point is
that unfortunately this is not a
presentation for beginners because we're
going to be going over some it all the
different subject matters that assume
understanding of them in particular
specializations and overload resolutions
and if you also know what is a
substitution failure is not an error
made abroad I mean that injection we
have already gone takes the void T and
some other concepts it would be more
helpful to you and you will get a little
bit more of the substance of when I'm
going to if I drop you at any time
during the presentation I hope that you
will see that even if you did not
understand that part later on when it is
used you just know that there is
something that accomplished something
and yes yes it is totally available in
any version of C++ that I know of
because you can implement it yourself
trivially and we will see that sure not
in the starter yet but the concepts
behind are applicable today all right
what if you don't know of the advanced
topics that I just mentioned don't be
afraid
when the time comes I will explain what
they do and you may not catch all of the
details of how they do it or what are
the different possibilities that you
have about it but it will be something
that term that will be understandable in
the context of the rest of the code and
I have to report that unfortunately
Mehta program does have complications it
is kind of hard to get it right
sometimes okay
how can inspection help a program well
I'm not going to go about the
theoretical discussion keeping the
emphasis on the practical application I
am gonna just show seminal examples so
daily session is one of those examples
it is a frequent LED feature when it is
so common that you want to persist your
data and to persist your data unit you
need to know its internal structure and
knowing this internal structure if you
could do it within the program itself
then there will be instruction that
would be helpful frequently when you
have deserialization requirement is that
you're gonna iterate for each piece of
data we'll all of these members and
recursively apply the serialization so
it's a shame that unfortunately C++ we
don't have any facility to iterate over
the members of a class nor we have a
facility that will tell us what are the
names the identifiers used for the
classes and the members so these only
gives us two options 2016 number one is
to do it through code generators even if
you are the code generator yourself well
that's going to be code generators
because it is boilerplate code
or you can use preprocessor macros which
is its own set of evils this
presentation it has an objective
inspiring you to come up with your
building blocks so that when you need to
do inspection you make a very simple
code generators let us start with a very
simple example we have an ax structure
that I call it aggregate because that's
what it is an aggregate of two different
data elements has an integrator has a
string alright how do we convert you to
string we have many choices if we want
to be very thorough maybe we want to put
the name of the structure that the data
item belongs to in this case the string
aggregate and for each member we may
want to say okay this is the name of the
member and call on the value of the
member this is what anybody would do
including a code generator manually so
the internet output would be like you
can read over there by the way does
everybody is able to read from the
distance thank you so what are the
properties of these our first attempt
that we have a program well it is
encoded of course because it is encoded
you can make it maximally efficient you
can make it as efficient as you as
possible but unfortunately it is brittle
because anything that changes about the
definition of the structure the
aggregate effects nationalization and
you might make it
incompatible and your test may run or
your compiler compile no problem so it's
kind of tricky because the real problem
is that the names of the members and the
name of the aggregate itself and the
role that they play are pieces of
information that are not linked
language in any way so to instrument
reflection or introspection that is the
very first thing that we have to do to
to bind the names of things the order
and their nature to to the Iraqis
themselves okay
before that the alternative case let's
say that we're programming in Java that
has a wonderful set of reflection
capabilities however you will have the
penalty of using them that will be a
runtime penalty you may not want to to
incur it the code is now resilient
because it doesn't matter how it changes
the reflection API will take care of
making things that everything is
consistent there are links between the
identifiers and the nature of the stuff
is actually a part of the data that the
program can handle but the compiler does
not gain any extra information you're
not telling it anything that it didn't
know that will help or not to optimize I
think it is a missed opportunity if the
intersection data is available at
compilation time that you had to wait in
a language such as Java for the runtime
to let you use it so if we achieve
compilation time introspection then we
considerably may achieve code which is
as efficient as possible because the
compiler will have all the instruments
to to make it efficient and at the same
time will be resilient this is something
that actually I think happens frequently
because so even before I made this
effort on implementing inspection for
MVP 3 recurrently I had been trying to
serialize data and doing things that
require introspection and I just have
the sense that when the the world
publishes some specification that needs
to be put in
ughter it will give you something a
language agnostic way and technique the
that agnosticism means that you have to
translate it to C++ somehow and then a
code generator is the perfect kind of
tool to do the the translation so the
translators from specifications to C++
are not money makers so we went to to
spend as little as possible on them but
we want to make full use of it and it's
not the place to do optimizations in my
opinion because what you think you are
solving in terms of performance at the
code generator may be a fallacy
you can change instead of just
converting the specification from
something to C++ you me do it in ways
that make it much harder to the later
stages of use of the code and whatever
to to optimizer or all those things so
it can truly be a person is a ssin and I
want to keep things clean a one
separation of concerns the compiler is
good at optimizing the code generator
should concern itself only with with the
conversion of the specification to C++
that way you can trust that the
conversion of the specification is
correct because you didn't complicate it
with optimization concerns all right
so going back to the to the example that
we had before yeah I came up with the
building blocks that you see on the
screen for implementing this very simple
serialization requirement so I have a
template called
members that take some type
and that template is empty I have a
template to bind and index to are type
and a value of that type and the T they
type in missile template it's going to
be a an address of membered pointer we
will see that in use in a minute
and if you see member binding basically
all the members that it has is a to
rename their template arguments template
parameters inside and I'll to capture
several types I have a stroke pack which
you can use topple if you don't like it
but I love I really like one nine
declarations that convey a very clear
idea so I just do that
instead of using a standard topple or
like they are there there are many weird
things in their members is an empty
template pack is a negative very attic
template member binding only the class
internally its own template parameters
and we see that strange pattern of type
dainty tea valve so how's that possible
to be useful in any way I want to go to
a parenthesis but perhaps I'm gonna just
keep to the point where those things are
used and this is an example of what
something like my code generator does so
it generates the structure that cannot
represent some aggregate in the
specification that that it is
translating and what I am doing is to
specialize that empty angle brackets
means Anna specialization in this case
the template members on the aggregate
and internally I'm going to say okay the
type of that our specialization is going
to be a pack that contains two types
those types are they the binding of the
address of member one
and zero and the other one is the
address of number two then I go and say
in this presentation I am saying what is
the name of the aggregate and I declare
a function called names that is an array
by basically just gonna return an array
or is an array with the names of their
members so this is an idea of how to use
it so I want to go back to to the
parentheses and in my opinion
metaprogramming is weird and one of the
reasons is that number one it is the
clarity that has opposed to imperative
and it borders more from functional
programming then the kind of programming
that we are used to in C++ by the way if
you see in my slides the color yellow
that means those are advisor that I'm
trying to give so those are my opinions
expressed as advice in my opinion you
should learn concepts such as prologues
unification because that is what in the
c++ world is called a substitution the
it is much simpler to learn unification
in the prologue and then come up with
truly complicated patterns then do it in
C++ with all of the attendant by the
finale of the other things that simple
sauce does for functional programming
Haskell would be great in the world of
templates everything is immutable you
cannot change once you have the clear
something nothing cannot change ever in
pattern matching is prominent too and
those are things that we don't normally
program with in C++ but they are very
very frequent in functional programming
and you working with for the Attic
template Caesar just work with the head
of the list and the tail of the list
just like you would the fundamental data
type of the whole of the lease per
programming language okay
when I mean weird are you trying to
convey also that is fun because you face
challenges that will have you learn and
you jerk you learn not just C++ would
much more I had to give acknowledgement
to stiffened you first that I was
fortunate to attend one of his
presentations when I was working at
Bloomberg LP in New York but away any
Bloomberg LP employer in the audience
nobody Oh excellent
so in this presentation we had a brief
conversation afterwards and uh he was
telling me that a C++ is so amazing
because all of the meta programming
stuff was discovered or invented it was
not designed for it so they there got me
thinking how is it possible that
something is so powerful that lets you
go in in totally unexpected directions
and that's part of the inspiration of
learning to learning C++ Hana on a
deeper level because if you just have a
practical attitude to it these
complications may put you off and you
think that it is no good for you to use
your time in it but maybe not maybe you
are tapping into things that may let you
go in completely unexpected directions
and Walter brown TPP corn two years ago
inspired me to someday have an audience
like I have today because um he was
presenting his invention of a void tea
and I thought that the idea why so
subtle and simple at the same time that
that's again like a the richness of C++
that is so unexpected this is like a
simple sauce is practical for me but it
is another thing too
these subject matters at the edges of
the language with sometimes in uncharted
territory and the good thing about it
may be that you can become a next Intel
pioneer yourself it for sure will give
you a different appreciation of why the
language it is the way that it is and
the evolution that it is having I hope
that you will discover that the
techniques to do meta programming are
independently useful and it may be a
mercy fight so going back to what we
were doing before these guys over here
all three of them are doing structural
patterns in structural things structural
templates that let you declared things
and through their declarations it is
that you accomplish something practical
well bear in mind of T cells light what
has just happened aggregate has been
decorated with extra information it is
not intrusive you don't need to put
things in to aggregate to decorate it
you decorate it outside so here's a an
interesting thing when you have a
template specialization you can in a way
out meant arbitrarily they things of
your type argument and we will see later
in the examples how you use for the
decoration in a trivial way by just
saying hey members T what is your name
alright one little tip recommendation
here when I say the names it is a
function class function has supposed to
data member this just because otherwise
you will have to define it a link
against it if you put it
has an aesthetic member then you don't
have to do any of that and there's no
performance penalty it's not trade
sensitive so it's just fine
nate is also a runtime tool so are we
not talking about compilation time
introspection yes but what are you going
to do with the name of something a
compilation time you don't have an
answer for that question so I just defer
to run time for the strings of the names
of stuff another weird thing is that the
language currently doesn't have a way to
specify with a single parameter single
template parameter both the type of a
member pointer and the member pointer so
every member will necessarily require
two template parameters the type and the
value of the address of the member
pointed itself and the simplest way I
guess is to just take on type it like I
do
in the Declaration on for the member
type for member binding and of course
the zero and the one mean the relative
position has members within the
aggregate okay how we're going to do
that how are we going to convert that to
string this is the first example that
I'm going to show you this is a complete
example what I'm going to do pyaza in
the line that says using n equals
members T that is when I begin to use
the specialization and all of its extra
information so from M I can get the name
of that team that aggregate look please
observe that the the the T type is a not
restricting type so I just go and say
okay give me the
operation of that type and if he doesn't
have the decoration then of course these
will explode it will not run but if you
call a template with a an argument that
it's not valid the same thing will
happen so no surprise here but now I am
going to call a funny function that I
call the green pack so I am going to
forward the same value that I am trying
to print but I'm doing something funny
here which is to pass in a parameter of
M colon colon type which is the pack
remember the pack is a death in Divine's
the the members to the aggregate using a
the member binding template null pointer
so by doing that I allow the overload
mechanism to select between an empty
pack which is here in the middle and or
the the case in which the Breen pack has
at least a head in the list so even
though print Parker is a template that
potentially has one two three four five
arguments and of which one of them is a
a very radical list of types it doesn't
matter because of the oh I have a typo
here sorry about the confusion
you
I was telling you that um yeah there are
a bunch of template parameters but in
the call I'm not using any
specifications of template parameters so
this is a very important recommendation
when you're using function templates
please make it so that you deduce
automatically all of the template
parameters if you do that chances are
that you're doing it well so the part of
these are new pointed that is not just a
null pointer that is a type at null
pointer and that conveys all the
information needed to capture the first
selection of the general case and from
them
I get what is it type of the aggregate
what is the type of the member the value
of the member the index and the rest to
recurse so what I do is to use that
information in a normal way by just
using the the insertion operator and
Dana will recur on the tail of the list
of types that I had before and believe
it or not that's all we need
that's gonna do the right thing so to
recapitulate this part because this is
very important this is to take away of
the whole session the the print tag is a
template function it takes three
arguments the output stream the
aggregate value and a pointer to
something that doesn't have a name it's
not not even used in the definition
block because all I care about it is
it's time enough template parameters to
fully indicate the aggregate type the
back of the member bindings the first
member
binding and the rest etcetera a corner
to print pack do not specify template
parameters these are a trick of using a
null pointer with a type it is a form of
type injection so you put an extra
parameter that doesn't do anything at
runtime but it conveys information in
particular the type it is probably the
most practical way to to deal with a
parameter to template functions so
please try to make it awake
observe that implementation is recursive
and the recursion ends by calling a more
specific overload but please do not
confuse a more specific overload which
is a here the one for the empty pack do
not confuse a more specific overload
with a spirit a more specialized
template the two things are very
different
well there also complicate things a
little bit what if I wanted to have an
example of civilization in which the
members themselves can be aggregates to
have their own members and all the
whatnot
well there is a big complication because
now we had to make a differentiation
between the types that are decorated and
the types are not decorated and we will
learn our or I will show you techniques
to do exactly that they wait to make a
design recognition isa through overloads
you have to do an overload the most
there must be are a fall through case
and if you're doing overloads you need
to have very good knowledge of how they
the resolution happens
you may have the problem that eventually
you resort to trial and error and it has
happened to me many times they compile
it's diffident copilot versions have
subtle bugs that make you lose a lot of
time one general recommendation is once
you understand the concept of loyalty
that we will talk about later use it it
is like a chainsaw to clear a forest of
complications
Voytek are you able to read that the
very first red line in the in the slides
that's all pointy in some idiotic
template that takes any number of types
and it aliases void it seems that it is
not good for anything however it is one
of the most subtle and powerful concepts
that I ever seen in C++ how are we going
to use it it's going to be used in
function arguments to detect whether
these template parameters are valid
types boy T is used to detect whether
it's a template parameters are valid
what happens when they are valid that if
you put it let's say in a in a function
overload then that overload continues to
be valid for the resolution set and the
variable set and if it is not if one of
the types in there is not valid there's
something called a substitution failure
is going to happen meaning that the
component tries to match the template
arguments to a template and you cannot
do that that a substitution failure and
this is not an error that's why FINA is
called fini the point is that that
overload will be deleted from the valid
set one recommendation is to use a void
pointer in the
Oshin declaration but do not default
them why because even though that forces
you to inject a new pointed at the call
site using a defaulted parameter gives
you two overloads the rules of
resolution for our laws are complicated
enough by you using a default parameter
you multiplied by to the number of cases
so I think as a practical recommendation
whenever possible don't do that remember
that overloads with ellipses are the
other laws of that last resort that is
why if I can match the overload at top I
will use it if I can't I will use this
one so that is the way today to
recognize the pattern of a type having a
specialization on the having they
members of utilization for it because I
am requiring on the first case that they
type type name members t : column type
is valid so the whole idea needs to be
valid if it is not then that gets
deleted and the only one that survives
is the order so a big the call sites are
going to put in a void pointer
explicitly but so both overloads on this
slide can match but again the the one
that doesn't have the leap Caesar wins
they the overload resolution alright
just wait to see if we can go for a
complete example
this is what I prepared for you has an
example and this is an extract of what
my code generator generates so you can
see here that it has much more of what
we have seen so far but if you go online
you will realize that in this particular
example is not being used
actually this is not the right example
okay so we are putting together the
things that we have been talking about
we have the members the member binding
and so on now instead of having had we
had before the the simple case of an
aggregate that has just all members now
we're going to define a super bagra gate
that contains a value since it is a an
aggregate the has introspection itself
we are going to decorate it by providing
its a member binding at the name the
array of member names and we use it here
and so this would be our our new a pack
now we have three members and so on
these ends what the code generator will
work what we will do for you now
it's gonna begin what I would call the
introspection library code and I have
the two cases that I described in the
slide before a print pack function that
is going to do the traversal the way
that that I explained to you and look
that what we're doing here is a where
recurring in two different ways
we will recur for the members
on two string implementation which is
the one that does the work and we are
also going to record by going to take
care of the rest of the list so this
ends the recursion for the pact the case
in which the the two steering input when
the type T does have an especially
session members for it will do the same
stuff that it was doing before and I
have to string that will call to string
input by augmenting the list of
arguments with more parameters so what
I'm doing here is to use trampolines to
string imple would be a trampoline for
for the string because you're changing
the types so the process of changing the
types is very useful all right and we
have a simple example so let's compile
it
it does I don't know if you guys can
read from the distance but we do get the
the output that we were expecting
questions so far could be a good time to
ask questions if you need them okay
there are many ways that we can improve
this code we can also do inspection on
instance and class functions we can take
advantage of inheritance in many ways we
can do compile time selections of
subsets of the members sometimes let's
say that you want to care only about a
certain subset of the members you can do
semantic avoids that realization like I
do in the more general example that I'm
going to show you later and you can
forward the configuration options to the
serialization primitives there are many
things that you can improve in here but
we have to skip because I want to show
you three other examples so the null
values in MVP threes application is
specific and I hope that you see that it
has generality so and in the
specification of MVP 3 there are 30
different ways in which value is allowed
to be known normal types that have a
magic value so if you receive a data
item whose member is a an optional that
has that magic value then you know the
time it is not really there it's gotta
be there because of the encoding but the
applications will ignore because it
doesn't have it something like
enumerations in this case that they have
the null value numerator the unions have
a membrane no value and its values true
and I say 3 plus 1 types because the
aggregates that contain things that may
be null well if all of these members are
null if then the whole aggregate would
be null and I program that these will
allow me to show you what the compiler
does with inspection
okay for the first case I characterize
them by using the template optional that
has a type parameter and a value of that
type an example would be in 3d to null
is a an optional for from interior to in
which that constant represents the magic
value again this is just an
instructional pattern I did something
that I shouldn't have done but I did
which is I represented the gist of a std
in a belief and it's very simple I'm
going to show it to you because now the
ideas just like void T once you
understand them you can use them aplenty
and they become natural if you submitted
template and specialized on true so when
it is true it does have a type member
and the true without the input is just
the aliasing so that I don't have to be
writing tightening through in pull on
the parameter colon column type so I
just used true and these are my two so I
need to declare a function is null then
I am allowing it to be a constellation
function in the case that the template
overload satisfies the property of the
argument being an optional I'm just
gonna check against the magic value and
here are the other cases number one is a
the the other cases require a trampoline
and it is named is null in pull the
first case is just a fall through with
ellipses so if none of the other succeed
this is
the one who's gonna be taking the the
the second overload is the one that
takes care of enumerations so I am
requiring that the type has argument ISA
an enumerated type by using the type
trait is a new and once I know that that
in is an enumerated value I'm going to
try to use it's a null value member and
compare it to to the argument to the
function in the case of a Union the
second then the next overload the third
overload I have a household a the
property of it being and Union and I
must check whether the the Union value
the you know membered null value is true
and finally I call a small
implementation on a more complicated
thing which is the case in which the
type of the argument has an ax
specialization members and I will call
package move on them another trampoline
the way to prevent is to traverse the
members is just the same has in
serialization so I'm not going to go
over them again but for completeness
sake this is the call it's just
basically the same well I'm gonna end up
doing it anyway
just reversing taking care of the head
and turrets into the detail so that's
what K takes care of the aggregates
let's hear a performance experiment this
is a tripe that comes from the
specification itself maturity month year
has four members and they they each can
be known so um what do you think the
great do you have an expectation of what
is the assembler there's going to be
generated for the function phone okay
does anybody has an expectation what
will be the assembly for that function
calling is null what is that that the
assembly is going to do well I'm going
to show you it just does for comparisons
so all of the techniques of recursion of
the list of members the extra argument
in the type injection the trampolines to
recognize the patterns all of them
disappeared from the object culture of
course that we optimizing data they it
disappeared since you may not be
entirely convinced I'm just gonna try to
run an online example hopefully it's
going to work
using the excellent tool of the GCC
compiler Explorer and that's what GCC
six generator with optimization without
optimization of course is gonna be a
nightmare stick in a long time and
everything come on
so well this is a case in which a PI
Internet failed or oh that is the output
of the case of it came in the wrong
order this is this is correct because um
you may want to do the body debugging
code and metaprogramming is extremely
hard because this is the kind of thing
so you're gonna be the debugging on okay
what about if I put off that I'm going
to set one of the values to five
shouldn't the compiler automatically
realize that the whole aggregate is not
going to be null because at least one of
its members
isn't that is exactly what happens why
does this happen because the compiler
knows that weak must be different to 255
and that comes because the code
generator put it in but the inspection
moved the effort to traverse the members
from the code generator to an AA
performance penalty in C++ there's one
of the benefits of saving work that I
wrote on we can program is null at any
time you must Center at the time that we
programmed the code generator so you can
extend things you can extend things
regardless of the code generator you
don't need to modify either you can
override this library with overtones of
your own for your own types or types of
the specification that you want then
here it to be different if you would
using that if you would be using a code
generator that didn't have any
generality into it no genetic
programming then probably would be
overloads for each specific type and
that would prevent you from our loading
them again so you would they out of lock
also the compiler has more reality
- what's going on well these are just
five minutes to end the session and what
I have prepared for you aren't
reiterations of aspects of what I've
showed you before but they are
increasingly more complex we're going to
go over them and in the MTP 3 there are
messages and I characterize them by
making them unnecessarily sation using
an ID of a template message team the the
messages have nested data they have
arrays and they can be more than one
super ray so before going into more
complicated stuff this is a very simple
example of what a message would would
look like and what I'm doing here is a
I'm just going to define pattern has
something that will try to discriminate
between the thing having a message on
that idea specialized or not so in the
case of message on 88 it is specialized
and has a type int the case of message
1:09 does not so if I said if I try to
see the values of the array that I am
declaring at the bottom they pattern on
0 it should be the one that doesn't have
the specialization which is one the
pattern on 88 it should be one sorry it
should be two because this has a message
ID type the case for 109 even though it
is a specialized the specialization
doesn't have a member type type so it's
gotta be one and 200 is just like zero
that is exactly what the assembler is
gonna show you if you run it on your own
one thing to take into account is
here I'm using defaulted template
arguments that is different to defaulted
overloads because they change the arity
the technique that I'm using X explained
in their slides we can see the code in
the github that is linked to in the
presentation to see the two stream week
message entry point for how they the
whole thing of printing the nested data
I just wanted to finish the presentation
with an example for this patcher it's a
very simple thing like I told you before
the messages are characterized by being
and specialization on an integrate on
the message template and the stroke
dispatcher defines a table to dispatch
so it's let people of functions if I
receive a message of type 55 let's say
then I'm gonna run whatever it is had
this lot 55 I don't put that code there
because there's no need it but the an
example would be like I have structured
something that'll be like my manager of
market messages whatever arbitrary and I
have a function that is going to consume
messages of the idat8 and they're going
to take a void pointer context to
convert it into their something but this
is what lets you work in a more
intelligent way so what I am writing in
these are slide is a very simple
subscription pattern and um the way to
use it I wrote an example which is just
to subscribe the use the call subscribe
which is a template function on the
function consume 88 so please observe
that I am NOT indicating explicitly what
is the idea of the message
that is going to be consuming why
because it is a taking by the overload
resolution so what we have seen at this
last example is that these preserves the
time safety there's no performance
penalty there are no complication that
is was done in user code well these are
the acknowledgments of Riga and if you
want to know more about subject covered
in this representation you can go to my
blog and that's it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>