<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>MongoDB Sharding Tutorial | What is Sharding | MongoDB Tutorial for Beginners | Simplilearn | Coder Coacher - Coaching Coders</title><meta content="MongoDB Sharding Tutorial | What is Sharding | MongoDB Tutorial for Beginners | Simplilearn - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Simplilearn/">Simplilearn</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>MongoDB Sharding Tutorial | What is Sharding | MongoDB Tutorial for Beginners | Simplilearn</b></h2><h5 class="post__date">2017-10-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/l1XRggQQ3NM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">sharding is the process of distributing
data across multiple servers for storage
MongoDB uses sharding to manage massive
data growth with an increase in data
size a single machine may not be able to
store data or provide an acceptable read
and write throughput sharding supports
horizontal scaling and thus is capable
of distributing data across multiple
machines sharding allows you to add more
servers to your database to support data
growth and automatically balances data
and load across various servers sharding
provides additional write capacity by
distributing the write load over a
number of Mongo d instances it splits
the data set and distributes them across
multiple databases or shards each shard
serves as an independent database and
together shards make a single logical
database sharding reduces the number of
operations each shard handles and as a
cluster grows each shard handles fewer
operations and stores lesser data as a
result a cluster can increase its
capacity and input horizontally for
example to insert data into a particular
record the application needs to access
only the shard that holds the record if
a database has a one terabyte data set
distributed amongst 4 shards then each
shard may hold only 256 gigabyte of data
if the database contains 40 shards then
each shard will hold only 25 gigabyte of
data in the next screen we will discuss
when charting should be used typically
sharded clusters require a proper
infrastructure setup this increases the
overall complexity of the deployment
therefore consider deploying sharded
clusters only when there is an
application
or operational requirement you must
consider deploying a sharted cluster
when your system shows the following
characteristics the dataset outgrows the
storage capacity of a single MongoDB
instance the size of the active working
set exceeds the capacity of the maximum
available Ram a single MongoDB instance
is unable to manage write operations in
the absence of these characteristics
sharding will not benefit your system
rather it will add complexity deploying
sharding consumes time and resources in
case your database system has already
surpassed its capacity deploying
sharding without impacting the
application is not possible therefore
deploy sharding if you expect that the
read and write operations are going to
be increased in future in the next
screen we will discuss what a shard is a
shard is a replica set or a single Mongo
d instance that holds the data subset
used in a sharded cluster shards hold
the entire data set for a cluster each
shard is a replica set that provides
redundancy and high availability for the
data it holds MongoDB shards data on a
per collection basis and lets you access
the sharted data through Mongo s
instances if you directly connect to a
shard you will be able to view only a
fraction of the data contained in a
cluster data is not organized in any
particular order in addition MongoDB
does not guarantee that any two
contiguous data chunks will reside on
any particular shard note that every
database contains a primary shard that
holds all the Uncharted collections in
that database in the next screen we will
discuss a shard key when deploying
sharding you need to choose a key from a
collection and split the data using the
keys value this key is called a shard
key that determines how to distribute
the documents of a collection of
the different shards in a cluster the
shard key is a field that exists in
every document in the collection and can
be an indexed or indexed compound field
MongoDB performs data partitions in a
collection using the different ranges or
chunks of shard key values each range or
chunk defines a non-overlapping range of
shard key values MongoDB distributes
chunks and their documents among the
shards in a cluster MongoDB also
distributes documents according to the
range of values in the shard key in the
next screen we will discuss how to
choose a shard key to enhance and
optimize the performance functioning and
capability of your database you need to
choose the correct shard key choosing
the appropriate shard key depends on two
factors the schema of your data and the
way applications in your database query
and perform write operations in the next
screen we will discuss the
characteristics of an ideal shard key an
ideal shard key must have the following
characteristics must be easily divisible
an easily divisible shard key enables
MongoDB to perform data distribution
among shards
if shard keys contain limited number of
possible values then the chunks in
shards cannot be split for example if a
chunk or a range represents a single
shard key value then the chunk cannot be
split even if it exceeds the recommended
size high degree of randomness a shard
key must possess a high degree of
randomness this ensures that a single
shard distributes write operations among
the cluster and does not become a
bottleneck target a single shard a shard
key must target a single shard to enable
the mungo s program to return most of
the query operations directly from a
single Mongo D instance in addition the
shard key should be the primary field
inquiry
various fields having a high degree of
randomness cannot target operations to
specific shards use a compound shard key
if an existing field in your collection
is not the ideal key compute a special
purpose shard key or use a compound
shard key here in the next screen we
will discuss range based charting in
range based charting MongoDB divides
data sets into different ranges based on
the values of shard keys
thus it provides range based
partitioning for example consider a
numeric shard key if an imaginary number
line goes from negative infinity to
positive infinity each shard key value
falls at some point on that line MongoDB
partitions this line into chunks where
each chunk can have a range of values in
range based sharding documents having
close shard key values reside in the
same chunk and shard range based
partitioning supports range queries
because for a given range query of a
shard key the query router can easily
find which shards contain those chunks
data distribution in range based
partitioning can be uneven which may
negate some benefits of sharding for
example if a shard key field size
increases linearly such as time then all
requests for a given time range will map
to the same chunk and shard in such
cases a small set of shards may receive
most of the requests and the system
would fail to scale in the next screen
we will discuss hash based charting for
hash based partitioning MongoDB first
calculates the hash of a fields value
then creates chunks using those hashes
unlike range based partitioning in hash
based partitioning documents with close
shard key values may not reside in the
same chunk this ensures that the
collection in a cluster is randomly
distributed in hash based partitioning
data is evenly distribute
hashed key values randomly distribute
data across chunks and shards the random
distribution of data across chunks using
hash based partitioning makes range
query on the shard key ineffective as
data will be distributed to many shards
rather than a few number of shards as in
the case of range based partitioning hi
there if you liked this video subscribe
to the simple learn YouTube channel and
click here to watch similar videos de
nerd up and get certified click here</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>