<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Battery Optimization | Android App Development Tutorial For Beginners | Coder Coacher - Coaching Coders</title><meta content="Battery Optimization | Android App Development Tutorial For Beginners - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Simplilearn/">Simplilearn</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Battery Optimization | Android App Development Tutorial For Beginners</b></h2><h5 class="post__date">2016-05-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ihtyTpOfbMc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello this is lesson 3 in this lesson we
will discuss about battery optimization
techniques while developing an
application in android by the end of
this lesson you'll be able to describe
battery optimization by understanding
the techniques to enhance battery life
while using the app in this screen we
will discuss some of the best practices
in developing network applications that
will optimize battery drain wireless
radio is one of the significant
components that consume device power
when a networking application is running
if you were aware of the patterns of how
wireless radio consumes battery you can
design an efficient application wireless
radio such as a 3G radio typically
operates in three states it will be in
the high-power state during data
transfer it consumes significant battery
power during this time after data
transfer if there is no more network
activity the radio transitions to the
low-power state however there is a tail
time of a few seconds during this
transition from the low-power States it
transitions to the standby state after a
few seconds of inactivity wireless radio
consumes the least battery power in the
standby mode there will be a start-up
latency to transition to full power mode
to begin data transfer activity this
latency may impact the user experience
we must notice that it takes a few
seconds of tailing time for wireless
radio to reach standby mode from high
power mode if our application fires
network activity spanning few seconds
very often then there is a possibility
that the radio will not switch to the
standby mode for a considerable amount
of time consuming the device battery
power prefetching sufficient data is a
way of reducing frequent downloading of
small amounts of data whenever possible
this means we download all the data that
our application is likely to need over
some time with one network activated by
doing so we are avoiding frequent radio
activations and wireless radio can be in
the standby state for a longer duration
this will also improve user experience
as a user will be downloading data ahead
of time and there is no latency in radio
activations but it is tricky to come up
how much data we should prefetch before
it is consumed by the application if we
prefetch all the data in one go we may
end up introducing a lag at the
application startup and the application
may close before all the data is used
the bandwidth consumed and downloading
the data will get wasted as a trade-off
we should optimize the application so as
to download enough data such that the
subsequent download will be required in
the next two to three minutes when we
implement a music or video player we
need not download the entire album all
songs or the entire video in one burst
instead we should download audio or
video progressively that is sufficient
for 2 to 3 minutes of playback we can
initiate the next download for a few
seconds ahead of time before the
previously downloaded data is consumed
when we implement a newsreader
application instead of downloading all
news articles of all sections we can
typically download headlines of those
sections chosen by the user new sites
provide XML feeds that typically contain
headlines and a snippet of description
for those headlines we can download the
XML feed and present the list of
articles along with short descriptions
to the user users can click an article
to get the complete news this saves
bandwidth as we do not download the news
articles that the user may not be
interested in if we are to implement a
chat application and our application has
to periodically ping to the web server
to indicate it is active we can bundle
sending messages checking for new
messages along with our periodic ping
operation this way we do not activate
the radio for multiple messages in case
of a news reading application we should
create some analytics about articles
that the user is interested in and get
the updates only for those news items in
this case we can bundle our regular news
updates operation with asynchronous
request when the user selects an article
to read the Android DDMS dalvik debug
monitor server includes a detailed
network usage tab that makes it possible
to track when our application is making
network requests using this tool we can
monitor how and when our app transfers
data and we can optimize the underlying
code appropriate
we should also ensure to check the
battery status and vary the frequency of
data updates if the battery is low
reducing the number of network
connections will help conserve battery
also we're using the HTTP connection
will help reduce the underlying TCP
handshake round trips to the server
thereby optimizing the wireless radio on
time for example use the same HTTP
connection to get all required news
articles or updates from the server
instead of multiple new connections now
we will discuss some key steps to
minimize the regular server updates to
optimize a battery drain if an
application needs to check the updates
available from the server it has to
activate the wireless radio create a new
connection and perform the check if the
user is idle it unnecessarily causes
battery drain however if there was a way
to understand device state network
connectivity and user behavior we can
optimize a periodic update checks using
Google Cloud messaging GCM the server
can notify the app instance whenever
there is new data available for download
rather than the app polling the server
periodically any other applications
which require periodic updates from a
remote server can be made to use Google
Cloud messaging in this manner Android
keeps a single GCM connection to get
updates and notify the application if
there is an update this reduces
unnecessary connections to check for
periodic updates and we create a new
connection only when the update is
available
GCM provides server components to
integrate notification framework for our
server when polling is required one way
to optimize is to set the frequency to
as low as possible
without adversely affecting the user
experience for example set the news
application refresh rate to one hour or
provide a preference screen where the
user can set the Refresh duration
allowing the user to make the best
balance between battery usage and data
updates when scheduling updates another
trick is to use inexact repeating alarms
if several alarms are set to go off
around the same time Android will
phase-shift the alarm firing time of
seven
applications such that all such
applications will receive the alarm at
the same time by this way all
applications can perform network updates
with a single activation of wireless
radio another way to reduce update
frequency is to monitor the app usage
and dynamically reduce the update
frequency if the app was not used since
the last update we can progressively
reduce the frequency this method is
called the exponential back-off method
if the app is used we can reset the
frequency to the default rate another
technique to avoid downloading duplicate
files our application can cache these
files for example full size images can
be stored in a case directory and need
not be downloaded every time HTTP URL
connection provides case expiry time
which is sent by the server application
can check this time to avoid displaying
stale data also care must be taken to
flush the case data we can enable HTTP
response cache and specify how much data
we want and ROI to store in the case
with caching enabled complete HTTP
requests can be served from case
depending on the case expiry time
without creating a new connection case
responses validate the freshness with a
server and avoid bandwidth cost
associated with a download
let us summarize the topics covered in
this lesson in this lesson we described
optimizing downloads in developing
Network applications that will optimize
battery drain we explained how to
minimize regular server updates this
concludes the lesson on battery
optimization in the next lesson we will
provide insight into synching with cloud
server hello and welcome to Lesson four
in this lesson we will talk about
syncing data to the cloud server in
Android by the end of this lesson you'll
learn to use backup API to backup user
data across multiple devices you will
also be able to transfer data using sync
adapters let's begin with understanding
the benefits of syncing users often
customize the applications using
available preference settings such as
font size background colors themes high
scores and games and many more
preserving such data for users when they
replace a broken device or upgrade to a
new one is an important part of ensuring
a great user experience Google provides
several api's to backup user data on
google cloud when the user installs the
application again on a new device or on
a factory reset device the application
can download the user data and express
the same look and feel and behavior
which the user had preferred there is a
significant difference in how user data
is backed up between Android marshmallow
and older versions of Android backup of
user files is automated in marshmallow
on older versions of Android we have to
write code to perform user data backups
with Google Cloud it is possible to
design the application to support data
backup such that it works seamlessly on
devices running Android 6.0 and older
versions user data backup is completely
automatic in Android 6.0 we don't have
to write a single line of code to backup
or restore the data however to protect
users privacy the user must have opted
in for Google services auto backup while
configuring the Google account on the
device the automatic backup feature
preserves the data our app creates on a
user device by uploading it to the
user's Google Drive account this data is
encrypted
and Google provides automatic security
for users data this data storage is free
each app can store up to 25 MB this
should be sufficient storage for each
application automatic backups occur when
the following conditions are met when
the device is idle when the device is
charging when the device is connected to
a Wi-Fi network lastly if the elapsed
time is at least 24 hours since the last
backup
however apps can perform asynchronous
backup on demand although Android 6.0
provides automatic backup and by default
certain data files are excluded
automatically excluded data files are
cache files in pass referred to by get
cached ur and get code cache der any
file access by the app from external
storage that is not in the path get
external files der and the files located
in the path where get no backup files
dirt is referred often all files need
not be backed up so we can specify the
files that are to be excluded from the
auto backup to customize a backup
behavior we should declare the backup
configuration XML file in the
application manifest file in the snippet
shown we are telling Android to look for
user data backup configuration file my
backup scheme dot XML in resource folder
named XML next snippet shows a typical
content of my backup scheme XML file
include specifies a set of resources to
backup instead of having the system
backup all data in your app by default
if you specify an include element the
system backs up only the resources
specified with this element data
specified in exclude are not backed up
which our file specifies the resource in
the directory returned by the get files
der method database specifies two
databases in the directory returned by
the get database path method shared pref
specifies shared preferences object that
the get shared preferences method
returns external specifies the resource
in the external storage directory
by the get external files derp method
route specifies the resource is in the
apps root directory path specifies a
file path to a resource that you want to
include in or exclude from backup you
can choose to prevent automatic backups
of any of your app data by setting the
Android : allow backup attribute to
false this will disable auto backup
completely in this section we will
discuss how to support user data backup
for Android OS 5.1 and lower while
supporting automatic backup on devices
running Android 6.0 most important is a
register for the Android backup service
in the Google backup service
registration portal link for which is
provided here we have to provide your
application package name for example
comm dot simply learn demo dot backup
demo then add metadata tag to
application manifest and include the key
returned by the backup service
registration portal metadata Android :
name equals com Google Android backup
API underscore key Android : value
equals reg key backslash note that this
registration key holds good for backing
up data belonging to this application
only declare the name of backup agent
class in the application manifest this
class is a subclass of backup agent
helper implement backup agent class add
backup helpers in oncreate open bracket
close bracket method file backup helper
and shared preference backup helper are
specialized classes for backing up files
and preferences data after we create the
helper and point it to the data we want
to backup we can just add it to the
backup agent helper using the add helper
open bracket close bracket method adding
a key which is used to retrieve the data
later note that we need to create one
type of helper for all files of the same
type for example one file backup helper
is sufficient to backup any number of
files we can pass multiple file names to
the file backup helper constructor
whenever we decide
back up user data we have to create an
instance of the backup manager and call
its data changed open bracket closed
bracket typically user data is restored
automatically when the app is installed
on a device however if there is a need
to trigger a manual update call backup
managers request restore method in this
section we will discuss Android sync
adapter framework that keeps data in our
application in sync with the data on the
server for example if you are
implementing a weather app you may want
to download the most current data to the
app from the server in case of an email
app you want to download newest messages
from the server in some cases users may
find it easier to enter and edit email
in a web interface and then have that
draft email available on their mobile
device it also helps the applications
start faster by loading the locally
available data rather than waiting for
new data to be downloaded every time the
activity is loaded although you can
create your own syncing code a sync
adapter optimizes network transfer by
coordinating the synchronization
operation across multiple applications
the sync adapter framework assumes that
our sync adapter transfers data between
storage device associated with an
account and server storage that requires
login access we should create an
Authenticator as part of sync adapter
this component plugs into the Android
accounts and authentication framework
and provides a standard interface for
handling the user credentials such as
the login information if we are to
implement a weather application in which
case the user account authentication may
not be required we are expected to
provide a stub Authenticator if we want
to implement a sync adapter framework
into our application we have to
implement following components account
authenticator content provider sync
adapter class account authenticator the
sync adapter Framework assumes that our
sync adapter transfers data between
device storage associated with an
account and server storage that requires
login access Authenticator component
plugs into the Android accounts and
authentication framework and provides a
standard interface for
user credentials such as login
information content provider the sync
adapter framework is designed to work
with device data managed by the flexible
and highly secure content provider
framework for this reason the sync
adapter framework expects that an app
that uses the framework has already
defined a content provider for its local
data sync adapter component the sync
adapter component encapsulate the code
for the tasks that transferred data
between the device and a server in the
following sections you will learn how to
implement these components in the
previous section we learned that the
sync adapter requires an Authenticator
even if our server does not need the
authentication sync adapter framework
expects us to provide one so we create a
stub Authenticator to do this create a
subclass that of abstract account
Authenticator and stub out the required
methods either by returning null or by
throwing an exception we will look at
how to stub out Authenticator methods in
the demo application the next step is to
bind the Authenticator to the framework
create a bound service and instantiate
the Authenticator in the oncreate open
bracket close bracket method return a
special binder object that allows a
framework to call your Authenticator and
pass the data between the Authenticator
and the framework from the on bind open
bracket close bracket method we will
have to create an Authenticator metadata
XML file and provide account information
that the sync adapter uses as shown
below
note that metadata includes a single
greater than account
- Authenticator less than element
account type the sync adapter framework
uses the account type as part of the
sync adapters internal identification if
server requires login the account type
along with a user account is sent to the
server as part of the login credentials
icon it is a drawable resource of the
icon small icon it is a drawable
resource of the small version of an icon
either the image specified by icon or
small icon is used depending on the
device screen size label it is the
localizable.strings that identifies the
account type next step
is to declare the service and the
Authenticator in the app manifest file
as shown below name specifies the name
of the service class intent filter sets
up the filter that is triggered by the
intent action Android that accounts that
account authenticator when the filter
Android that accounts that account
authenticator is triggered the system
starts Authenticator service the bound
service that wraps the Authenticator
metadata element declares XML file for
the Authenticator in this demo we will
go through the code to understand how to
implement a stub Authenticator a sync
adapter depends on an account
authenticator to provide a standard
interface for handling user credentials
on the device and the remote server one
must implement a dummy Authenticator
even if the app does not use accounts or
login credentials on the server if the
Authenticator is not available in the
application a runtime exception will be
raised for this demo we will implement a
stub Authenticator for this demo we will
only concentrate on the stub
Authenticator implementation the
subsequent demos cover other components
open stub Athina Kader Java file the
class stub Authenticator extends
abstract account authenticator class the
next step is to provide dummy definition
to abstract methods of abstract account
authenticator class we can either return
null or zero or throw an exception an
easy way to find out all abstract
methods and their definitions is to
browse the abstract account
authenticator class itself right-click
the abstract account authenticator
scroll to go to in the side menu choose
declaration scroll down until abstract
method definitions it is easier to copy
these abstract method declarations and
paste them into the stub Authenticator
class in sub Authenticator Java these
methods are edit properties
add account and firm credentials
get auth token
get off token label update credentials
and has features we have to ensure we
haven't missed any abstract methods
otherwise we'll get compiler error open
stub Authenticator Java edit properties
is expected to return a bundle we will
throw an unsupported operation exception
add account is also expected to return a
bundle we will return null it does not
matter as a null object is returned or
an exception is thrown sync adapter will
just ignore these as we are not going to
use any user accounts likewise we will
simply return null from confirm
credential z' get auth token get auth
token label update credentials and has
features methods the next step is to
implement a service that the sync
adapter uses to call Authenticator open
Authenticator service Java in the
oncreate method instantiate the stub
Authenticator and store the reference in
the member variable M Authenticator next
is the important method on bind where we
have to return a special binder object
from the stub Authenticator by calling M
Authenticator dot get binder now that we
have implemented stub Authenticator and
the service to instantiate the
Authenticator we have to create an XML
file with metadata about the
Authenticator Open Authenticator XML in
the XML resource folder the metadata
includes information about the account
type that the Authenticator will handle
even though we will not use user
accounts we have to provide a dummy
account type in the metadata we've
provided an account type an icon for the
account and a label that will show up
for the account let's open the
strings.xml to check the values used in
the Authenticator dot XML we have
declared simply learn comm as the
account type and the app underscore name
as the name of the app finally we have
to declare the Authenticator service in
the manifest file open Android manifest
that XML file the manifest
file has a whole lot of information
declared we will concentrate only on the
details pertaining to Authenticator an
Authenticator service other contents of
the manifest file will be explained in
subsequent demos we have added
permissions to access internet and check
network state by adding android
permission dot internet and android
permission dot access underscore network
underscore state scroll down to see the
Declaration of stub Authenticator
service name is the fully qualified name
of the class that implements the
Authenticator service the intent filter
element sets up the filter that will be
triggered by the intent action Android
that accounts that account authenticator
which will be sent by the sync adapter
framework to run the Authenticator when
this filter is triggered the system
starts the Authenticator service we have
also declared the metadata element that
links the metadata to the account
authenticator the Android colon resource
attribute links the Authenticator XML to
the metadata that completes the
implementation of stub Authenticator
component a sync adapter needs other
components to work we will understand
how to implement other components in
subsequent demos after all components
are implemented we will run the project
to see the sync adapter at work the sync
adapter framework is designed to work
with device data managed by the flexible
and highly secure content provider
framework for this reason the sync
adapter framework expects an app that
uses the framework has already defined a
content provider for its local data if
our application is not required to store
data in a content provider sync adapter
framework expects us to provide one in
this case we can create a stub content
provider
note that if our application has a
content provider we don't need a stub
version the next step is to create a
subclass of content provider stub out
methods by returning null or zero
declare the content provider in the
application manifest file as shown in
below name name of the content provider
subclass
authorities and uri authority that
identifies the stub content provider
exported determines whether our apps can
access the content provided sinkable
sets a flag that indicates that the
provider is sinkable in this demo we
will go through the code to understand
how to implement a stub content provider
a sync adapter is designed to work with
a content provider framework to access
device data
hence the sync adapter framework expects
the content provider interface to access
local data to be in the application when
the framework runs a sync adapter in the
app if the content provider is not
present it causes a runtime exception
and the application crashes it is also
recommended that the local data be
stored in a content provider
however if one decides not to use a
content provider to protect data a dummy
or stub content provider should be
implemented this demo is an extension of
the stub Authenticator demo we will
review the code pertaining to stub
content provider implementation for this
demo we will only concentrate on the
stub content provider implementation the
subsequent demos cover other components
let's open stub content provider Java
the stub content provider class extends
content provider just like we
implemented a stub Authenticator class
we have to provide dummy definitions for
abstract methods declared in the content
provider class this is done by either
returning 0 or null or throwing an
unsupported operation exception
right-click the content provider scroll
to go to in the side menu and choose
declaration this class is very large and
it is easier to search for abstract
method definitions searching through the
file for abstract definitions we find on
create query get type insert delete and
update methods as declared abstract in
fact these are the methods that one must
define to implement a content provider
copy the Declaration of abstract methods
into our stub content provider dot Java
file this way it is easier to maintain
the input parameters on create must
return true other methods get type query
and insert which are expected to return
an object our stubbed out by returning
null
delete and update methods which were
expected to return an integer return
zero
the next step is to declare the content
provider in the manifest file open
androidmanifest.xml scroll down to see
the Declaration of the provider element
name attribute specifies the fully
qualified name of a class that
implements the content provider next
attribute authorities specifies the
authority that identifies the content
provider as a convention the value of
this attribute is the applications
package name appended with dot provider
we can open strings dot XML and check
the authority string go back to the
manifest file exported attribute is set
to false as we do not intend to export
the content provider outside the
application the stub content provider is
internal only for the sync adapter
Framework sinkable attribute is set to
true
this flag enables the sync adapter
framework to make data transfers with
the content provider that completes the
implementation of stub content provider
component a sync adapter needs other
components to work we will understand
how to implement other components in
subsequent demos after all components
are implemented we will run the project
to see the sync adapter at work the sync
adapter component in our app encapsulate
the code that syncs the data between our
device and the server based on the
scheduling and triggers we provide in
our app the sync adapter framework runs
the code in the sync adapter component
following steps are involved in adding a
sync adapter component in our
application to create a sync adapter
class create a subclass of abstract
threaded sync adapter that wraps our
data transfer code in an interface
compatible with a sync adapter framework
next is to create a bound service sync
adapter Framework runs our data transfer
code via the service next step is to
create sync adapter xml metadata file
which is nothing but a file containing
information about our sync adapter the
framework reads this file to find out
how to load and schedule our data
transfer finally declare our sync
adapter and bound service in the
manifest file in the next section
we will see
details of each of these tasks first
step in implementing a sync adapter is
to create a sync adapter class that
interfaces with sync adapter framework
following our steps in implementing a
sync adapter class create a subclass of
abstract threaded sync adapter we need
to perform any initial ation in the
constructor for example if our
application interacts with a content
provider we need to create a Content
resolver
in the constructor the sync adapter
component does not automatically do the
data transfer
instead it encapsulates our data
transfer code so that the sync adapter
framework can run the data transfer in
the background when the framework is
ready to sink our applications data it
invokes your implementation of the
method on perform sync these are the
input parameters to the on perform sync
account an account object associated
with the event that triggered the sync
adapter if our server doesn't use
accounts we don't need to use the
information in this object extras this
is a bundle containing flags that
trigger the sync operation Authority the
authority of a content provider in the
system our app should have access to
this provider provider a content
provider client for the content provider
pointed to by the authority argument if
we are not using a content provider we
have to ignore it
sync result is the object that we use to
send information to the sync adapter
framework the sync adapter takes care of
our network connections and calling our
sync adapter code to sync data with our
server you have to provide
implementation for the following inside
on perform sync connecting to our server
if you are downloading some data you
have to provide the code that requests
the data from the server downloads it
and stores it in some place in our app
similarly if you want to upload data you
have to read it from a file or database
or a content provider and create update
requests and update the data you also
have to handle Network errors during
data transfer the sync adapter does not
automate checking if the data is new on
the server you have
to implement methods to determine if the
data on the server is newer than the
data on the device similarly you have to
implement what data to upload clean up
network connections and flush any
temporary files created during sync the
next step is to provide Android system
access to our sync adapter code we just
created create a bound service that
passes an Android binder object from the
sync adapter component to the framework
framework invokes the on perform sync
method using this binder object we will
have to create a singleton object of
sync adapter in the services on create
method remember to create the singleton
in a thread safe manner
return the special el binder object from
on bind method sync adapter framework
uses this binder object to invoke the on
perform sync method to plug our sync
adapter component into the framework we
need to provide the framework with
metadata that describes the component
and provides additional flags the
metadata tells Android that the sync
adapter syncs data owned by the
authority using the account type it also
specifies the account type we have
created for sync adapter and declares a
content provider authority associated
with our app store this metadata in a
special XML file stored in the backslash
res backslash XML backslash directory in
our app project it contains a single XML
element sync
- adapter let's now look at each fields
on the metadata XML file as you can see
in the code snippet content Authority it
is the URI authority for our content
provider if we have created a stub
content provider we have to use a value
that was specified for the attribute
authorities if we are syncing data from
a content provider to a server we have
to use this Authority's URI account type
it is nothing but the account type
required by the sync adapter framework
this value must be the same as the
account type value we provided when we
created the Authenticator metadata file
following are the additional flags that
can be set in the metadata file
user-visible controls the syncadapter
account information that is whether it
is visible in the accounts section of
system settings by default this is true
we can set this to false if we don't
want the syncadapter account to be
visible in the accounts section of
system settings support uploading we can
set this to true if we are uploading
data from device - server allow parallel
syncs it specifies if we support
multiple account syncs simultaneously is
always sinkable setting this to true
means a framework can run our sync
operation anytime if we want to
programmatically control the sync then
we have to set this flag to false and
calm request sync to run the sync
adapter declare sync adapter in manifest
we add all the necessary information in
the apps manifest file which are
required to run the sync adapter the
information includes adding appropriate
permissions declaring service element
and sync adapter metadata information
the application needs permission to the
internet to download or upload data from
the device to the server read sync for
settings enables the app to query for
sync settings such as get is sinkable
similarly write sync for settings allows
the app to modify sync adapter settings
authenticate counts enables sync adapter
to use account information to perform
authentication declare the service
information which includes the name of
the class that implements the service
and other related flags please note that
we have added some special flags to the
service declaration the intent - filter
element sets up a filter that's
triggered by the intent action Android
Account sync adapter sent by the system
to run the sync adapter process equals
sync tells Android to run the service in
the global shared process named sync if
you have multiple sync adapters they all
can share the same process to reduce
overhead metadata element specifies the
metadata file for the sync adapter sync
adapter 4.3 in earlier demos we
understood how to implement a stub
Authenticator and stub content provider
components to support the sync adapter
framework
in this demo we will understand
encapsulating data transfer code that
the syncadapter framework can execute we
have to implement a sync adapter class
to encapsulate data transfer code next
we have to implement a bound service
that runs the code in the sync adapter
class this service is similar to the
service that runs the Authenticator that
we went through in an earlier demo after
implementing this code we have to create
a metadata file with information about
the sync adapter declare the bound
service in the manifest file along with
the metadata let's review the code open
the sync adapter Java file the sync
adapter class extends the abstract
threaded sync adapter class abstract
threaded sync adapter provides
functionality to spawn a thread to
perform a sync operation this class also
ensures that when a sync operation is in
progress a new sync is not initiated we
have to implement constructors for the
sync adapter class inside the
constructor we initialize any member
variable as needed in this case we store
the app context for future use also call
the superclass constructor so that the
abstract threaded sync adapter
initializes its member variables as we
learnt earlier the sync adapter
framework does not automatically perform
the data transfer but provides a
framework to encapsulate the data
transfer code in other words the data
transfer code is written inside the on
performed sync method when the sync
adapter framework is ready it calls on
perform sync on the background thread to
perform actual data transfer the main
application does not directly call this
method in general the following
functions must be implemented in the on
perform sync method the code to
establish connection to the server in
case the sync adapter downloads the data
the code to download the data from the
server in case the sync adapter uploads
the data the code to upload the data to
the server the code to access data the
data may be stored in a content provider
or in any other storage
clean up such as closing connection with
the server setting flags in the sink
result object and so on let's review the
parameters passed to the on perform sink
method account is the account associated
with the event that triggered the data
transfer
it contains login credentials required
for remote server if the server does not
use login credentials the account is
ignored the next demo will show you how
to create an account and use it for sync
operation bundle is the bundle object
containing any extra parameters
associated with the event authority is
the authority of the content provider of
the system we declared authority of the
stub content provider in the manifest
file let's open the manifest file for a
quick look at the content provider
declaration and authority authority is
generally declared as a string with the
applications bundle ID appended with dot
provider in our example it is declared
as com dot simply learned dot sync
adapter demo dot provider we ignore the
provider parameter as we are not using a
content provider for the demo provider
is the content provider client for the
content provider identified by the
authority argument a content provider
client is a lightweight interface to a
content provider with all the interfaces
of a Content resolver if the sync
adapter uses a content provider to store
data this lightweight interface can be
used in our case we ignore this
parameter as we are not using a content
provider for the demo finally result is
the sync result parameter that can be
used to send information to the sync
adapter framework in the current demo we
use HTTP colon backslash backslash lorem
pixel comm website to download an image
as we saw in the earlier demos this
website provides a simple way to send a
network request and receive a response
image we specify the size of the image
required following the URL
next we scroll down in the same file we
call download image method and past the
URL along with the size of the image
which is 640 pixel in width and 480
pixels in height the download image
method creates a HTTP URL connection
object with the URL passed set timeout
parameters you can recall that we learnt
the parameters of the HTTP URL
connection object in earlier demos then
call the connect method the connect
method returns after either timeout or
with a network response the input stream
for the image is obtained from the URL
connection object using the
bitmapfactory class the input stream is
converted to the bitmap object the input
stream is closed after completing the
operation the bitmap returned by the
download image method is stored in the
static variable image store dot current
image we use a static class to store the
image this is where a content provider
or a database or any other storage can
be used to store the synced data we
create an intent with the action image
stored refresh and send broadcast using
the application context that was stored
in the constructor we have implemented
the broadcast receiver in the main
activity that receives this intent and
sets the newly downloaded bitmap into
the image view on the main activity that
completes the implementation of sync
adapter open the sync service Java file
the next step is to implement a bound
service to run the sync adapter code
this is similar to the service that
binds the stub content provider that we
learned in an earlier demo the bound
service provides the interface to the
sync adapter framework to run the data
transfer code the sync service class
extends the service class which provides
all the functions for the service to run
in the background in the oncreate method
of the service instantiate the sync
adapter this ensures that the sync
adapter instance is created when the
service starts note that we instantiate
the sync adapter instance in
thread-safe way using the synchronized
method and making sure that only one
instance of the sync adapter is created
in the on bind method returned the
special binder object obtained by
calling the sync adapters get sync
adapter binder method this completes the
implementation of the bound service next
to plug the sync adapter component to
the framework we have two metadata with
information about the component open
sync adapter XML file content authority
is the URI authority of the content
provider this is the same string that is
declared as the Authority for the
content provider in the manifest file
account type is declared as simply
learned comm this is the same account
type that the stub Authenticator uses we
will add this account type to the
Android system in the next demo user
visible is set to true the account
associated with the sync adapter is
shown in the Android accounts page
supports uploading is set to false as we
only download in the sync operation it
must be set to true if the sync
operation uploads data to cloud allow
parallel syncs is set to false as we
allow only sync operations for one user
account in the demo this can be set to
true if multiple sync operations
associated with different user accounts
are performed simultaneously is always
sinkable is set to true to indicate the
framework that the sync adapter can be
run any time when requested this flag
can be set to false if the sync
operation is programmatically controlled
the next step is to declare permissions
and sync service in the android manifest
file open the androidmanifest.xml file
android permission dot read underscore
sync underscore settings allows the
application to read sync adapter
settings such as get is sinkable android
a permission
write underscore sync underscore
settings allows the application to
modify the sync adapter settings if the
sync adapter should execute periodically
this permission is required
however if the sink happens via a user
event by calling request sink the right
underscore sink underscore settings
permission is not required scroll down
to review the declaration of the sync
service Android : name indicates the
fully qualified name of the class that
implements the sink service the exported
attribute is set to true this allows the
processes other than the application
itself to access the service the Android
system sends the intent action Android
content dot sync adapter to trigger the
sync adapter we have declared this
action in the intent filter thus
triggering the bound service metadata
provides the name of the XML that
contains a metadata about the sync
adapter the attribute Android : name is
set to Android dot content dot sync
adapter this tells the system that the
metadata is for the sync adapter thus we
have implemented major components of the
sync adapter in the next demo we will
create an account that is used by the
sync adapter and put the sync adapter in
action as we discussed earlier the sync
adapter framework requires each sync
adapter to have an account type even if
we don't need to authenticate on the
server we have to provide a stub
Authenticator one small task that is
pending is to instantiate the account
that you created earlier as part of
creating an Authenticator for sync
adapter and add it to the Android system
we can view the account information in
the accounts section of the system
settings app as shown in the snapshot a
good place to perform this action is in
the in the earlier demos while adding an
Authenticator and sync adapter we used a
user account to perform a sync operation
we must ensure that the account exists
in the handheld device when the main
activity starts in the oncreate method
we add the account to the system the
account is created and added to the
system if it does not exist already if
the account already exists in the system
it is ignored let's review the code open
main
activity Java the create account method
is called in the oncreate lifecycle
method we also enable automatic syncing
for the account this can be
programmatically controlled automatic
syncing can also be controlled from
system settings for the account scroll
down to review the create account method
we create an instance of the account
with named dummy and account type simply
learn comm obtain the account manager
service by calling get system service
and passing context dot account
underscore service account service
managers Add Account
explicitly adds the account to the
Android system if the account does not
exist and returns true if the account is
newly added we set periodic sync flag to
true with ten seconds periodicity this
is done for demo purpose the periodic
sync can be set based on the application
requirement if the account already
exists it returns false this ensures
that the account exists in the system
before the sync adapter tries to use it
let's open the Android emulator open
settings app scroll down and select
accounts there are no accounts other
than Google let's execute the project
when the app is loaded open the Settings
app and select accounts the sync adapter
demo account has been created
select the account it shows the last
sync time along with an option to turn
off sink in the next demo we will
complete the sync adapter application
so far we've created a sync adapter
class a service to run the sync adapter
a stub Authenticator and a service to
perform authentication now that the sync
adapter is ready we have to know when to
run the sync adapter possible options
are when server data changes run the
sync adapter when the server sends a
message indicating that server data has
changed we can implement Google Cloud
messaging service instead of polling the
server Google Cloud messaging GCM
provides server and device components
that makes efficient server
notifications implement a broadcast
receiver in the on received method if we
detect a server notification call
content resolver dot request sync
account authority no account and
authority are discussed while creating
account and stub content provider when
device data changes run the sync adapter
when the device data changes this is
straightforward if we implement content
provider it is even simpler to detect
data change if our application uses a
real content provider we can create a
Content observer and register it with
Content resolver when the system sends
out a network message run a sync adapter
when the Android system sends out a
network message this can be done by
calling content resolvers set sync
automatically parameters to this method
are explained in previous sections at
regular intervals run sync adapter at
some chosen regular intervals this can
be done by calling content resolvers and
periodic sync method parameters to this
method are discussed in previous
sections sync underscore interval is
time in seconds on demand run sync
adapter in response to user action for
example provide a refresh button to the
user call request sync method in
response to the users clicking the
refresh button so far we have
implemented a stub account authenticator
in service a stub content provider a
sync adapter and the bound service we
also created the account using a sync
adapter let's review the user interface
and other methods of main activity open
the activity underscore main XML file
this provides the layout and view for
the main activity we are using a
vertically oriented linear layout inside
the container linear layout to linear
layouts are added the first linear
layout contains an image view this image
view will display the downloaded image
the second layout contains the Refresh
image button on refresh image is the
event handler open mainactivity.java in
the oncreate method we add the account
that we learned in an earlier demo next
we obtain the image view reference to
update the image later a broadcast
receiver is added with the intent filter
image store dot refresh scroll down to
review the on refresh image method this
method is called when the user touches
the refresh image button in this method
we call refresh sync which causes the
Android system to send an intent with
action Android dot content dot sync
adapter this instantiates the sync
service which in turn creates the sync
adapter and executes on performance sync
scroll down to review the broadcast
receiver on receive is called when the
sync adapter sends the image store dot
refresh intent action in the on receive
method we update the image view with the
newly downloaded image let's execute the
project you can see in the log window
that the periodic sync is downloading
the image without any user action if an
immediate sync is required touch the
refresh image button and a new sync will
be performed this concludes the sync
adapter implementation which includes
implementing components a stub
Authenticator with its bound service a
content provider and a sync adapter with
its bound service
let us summarize the topics covered in
this lesson in this lesson we explain
the process of synching to the cloud we
described Auto Backup in Android 6.0
marshmallow we learned to support older
version of Android in syncing data we
defined syncadapters its components and
demonstrated how to create a stub
Authenticator we described stub content
provider we demonstrated how to create a
sync adapter and declare it to the
manifest and lastly we explained the
possible options to run the sync adapter
this concludes syncing with cloud server
hello and welcome to lesson 5 in this
lesson we will talk about using volley
for network data interaction by the end
of this lesson you'll learn to define
sending simple request describe setting
up request queue explain how to make a
standard request and demonstrate how to
implement a custom request in this
module we will discuss an open source
HTTP library called
volley volley is an HTTP library that
makes networking for Android apps easier
faster and efficient however volley is
not available in the standard Android
SDK it is developed as part of the
Android Open Source project one has to
download the source code build the
library and add it to their project some
of the benefits of volley are as follows
automatic scheduling of network request
which means the process of handling and
scheduling network requests can be
automated multiple concurrent network
connections we can have parallel network
connections which benefits the user and
the developer transparent disk and
memory response caching this allows for
quick reloading of data transparent
cache ensures that the caller is not
aware about the existence of the case as
the case is implemented automatically we
have the possibility of disabling the
cache support for request prioritization
this means that we can load the content
based on the priorities cancellation
request API by means of which we can
cancel a single request or can set
blocks or scopes of request to cancel
once cancelled we are assured that our
response listener is not called
and finally volley provides
out-of-the-box support for raw strings
images and JSON parsing so that way we
can concentrate on implementing core
logic remember that it is not suitable
for large downloads of streaming as
discussed earlier volley is not
available in the standard Android SDK we
need to download volley source code from
git repository if you don't have kit it
is recommended to install git
after downloading import into the
Android studio as a new Gradle module
add the compile time dependency to build
dot Gradle file inside the volley folder
this is required if we are building
volley using API 23 SDK in API 23 Google
removed support for Apache HTTP library
however an alternate is not yet
available so we have to use the legacy
Apache HTTP dependency add volley module
dependency to the application let me
show you quickly how to build the
library and add to the application the
first step is to clone the git
repository to our machine navigate to
Android studio select File then select
new module and click on import Gradle
project let's navigate to the folder
where we downloaded volley source code
select and then click finish
note that volley has been added to our
project as a module an important step is
to modify the Gradle build file inside
the volley module so let's open
build.gradle and add the used library
line
the next step is to add volley as a
dependency to the project go to Android
Studios select File select the project
structure and click on dependencies add
volley as a module dependency this tells
the compiler that our app depends on the
volley library that's it now we can use
volley HTTP library in our application
we will now see how to use the volley
library at the high level we need to
create a request queue and past request
to it volleys request queue manages
worker threads for running the network
operations reading from and writing to
the cache and parsing responses the
response listeners are registered at the
time of creation of the request volley
comes with standard request types like
string request image request JSON
request and a few more this means that
we don't have to parse the input stream
to extract the information from HTTP
response volley library handles parsing
for standard request types parsed
responses are delivered via listener
call method on the main thread this
makes updating the user interface very
convenient to cancel request call cancel
open bracket close bracket on the
request object volley guarantees that
our response handler will never be
called we can simply cancel all requests
in our activities on stop method and
need not even check if the activity is
not null in the response handlers we
will look at how to set up a request
queue and perform network requests we
will create an image request from the
URL HTTP colon backslash backslash lorem
pixel comm which gives random images of
the requested size we update the
activity's image view when the response
is received next open the
androidmanifest.xml file in the
application manifest file we have
declared permission to access android
permission internet the volley library
has been set up as shown in the previous
sections the image view is added to the
main activities layout let's open the
XML file and a reference to this view is
stored in the activity let's go back to
the Java file we create a requests queue
using volley dot new request queue by
passing the activity's context next we
scroll down in the same file image
request is created by passing the URL
and response listener an error response
listener as a name indicates response
listener passes the processed bitmap
image in the on response method we
update our image when called error
listener handles any Network
gaara's encountered finally the response
is added to the queue execute the
application and you can note that the
image is loaded on the activity now
let's understand how to set up a network
queue
in the previous section we learned the
convenience of using volley request if
we want the request queue to be
available throughout the application and
not just an activity then it is possible
to set up our own request queue a
request queue needs two things a network
to perform transport of the request and
a case to handle caching volley
libraries have built-in casing and basic
network implementations disk based cache
class provides standard caching storage
basic Network class provides required
Network stack instantiate the request
queue from the application context so
that the request lives to the end of the
application we need not worry about
requests when the activities change
create the request queue as a singleton
object so that it makes the network
operations efficient a singleton
instance of a request queue can be
implemented in many techniques the
recommended approach is to implement a
singleton class that encapsulates
request queue method and other volley
functionalities volley supports standard
requests off the shelf
along with convenience methods to help
manipulate the downloaded data let us
talk about each standard request string
request specifies a URL and receives a
raw string in response image request
specifies a URL and receives an image in
response also provides convenience
features like specifying a size to
resize its main benefit is it volleys
thread scheduling ensures inexpensive
image operations such as decoding and
resizing will happen automatically on a
worker thread json object request
specifies a URL and gets a JSON object
JSON array request specifies a URL and
gets a JSON array in response image
loader is a helper class that handles
loading and caching images from
responses it provides in-memory caching
which performs faster than disk based
iocation it performs response coalescing
which means it fuses several image
responses together and delivers them
simultaneously this improves performance
and prevents flicker
let's now understand how to implement a
custom request it is possible to create
custom request if parsed data is
different from an image JSON or plain
string off-the-shelf available requests
are sufficient for most of network
operations extend the request greater
than T less than class were greater than
T less than represents the type of
parsed response the request expects
implement the abstract methods parse
network response and deliver response in
the code snippets shown on the screen
parse network responds receives the
response from volley framework we can
convert the response to the needed
format deliver response calls listeners
on response method on the main thread
and passes the custom type response in
the next demo application we will show
how to create a custom request in this
demo we will go through a custom volley
request implementation the custom news
request overrides the request class in
the parse Network response method we
extract the XML string and pass it on to
simply XML parser to parse XML parser
returns a list of title and descriptions
which are returned to the activity note
that Java generic class type is used in
all interfaces we have to convert the
parsed and processed data into the
appropriate type this is an important
task in creating the custom request
simply XML parser converts the list into
the generic type
in the mainactivity the request object
is created and added to the queue in the
on response callback method we
categorize it back to correct type from
the generic type and update the view
with news details that's all about
implementing volley requests let's
execute the demo which is a result of
what we just learned
let us summarize the topics covered in
this lesson in this lesson we defined
the open source HTTP library called
volley we demonstrated to set up volley
library into the Android SDK studio we
described using volley we explained the
process of setting up a network queue we
defined standard request we demonstrated
implementing a custom request this
concludes the lesson on using volley for
network data interaction
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>