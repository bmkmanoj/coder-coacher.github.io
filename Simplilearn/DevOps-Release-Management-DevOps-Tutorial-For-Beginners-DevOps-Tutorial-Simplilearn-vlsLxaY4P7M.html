<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>DevOps Release Management | DevOps Tutorial For Beginners | DevOps Tutorial | Simplilearn | Coder Coacher - Coaching Coders</title><meta content="DevOps Release Management | DevOps Tutorial For Beginners | DevOps Tutorial | Simplilearn - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Simplilearn/">Simplilearn</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>DevOps Release Management | DevOps Tutorial For Beginners | DevOps Tutorial | Simplilearn</b></h2><h5 class="post__date">2017-10-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vlsLxaY4P7M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">devops release management in this video
we will define release management and
discuss what this means from a DevOps
point of view additionally we will
examine various tools that can be used
to set up a DevOps release management
workflow what is release management
release management is the process of
managing planning scheduling and
controlling a software build through
different stages and environments
including testing and deploying software
releases DevOps release management
DevOps as a culture emphasizes that the
collaboration and communication of
software development team members and IT
professionals is a dependency of the
release cycle and accordingly we see the
importance of release management as an
increasing discipline in this world in
the modern iterative world where
feedback and performance metrics are
incorporated directly into the
development cycle the process of
overseeing the development cycle
requires dedicated resources in
personnel what are the goals of DevOps
release management the DevOps release
cycle should deploy releases into
operation and establish effective use of
services in order to deliver value to
the customer release and deployment
management also ensures handover to
service operations takes place and that
suitable training and documentation
exists to ensure ongoing support of the
new service release management
strategies there are basically four main
release strategies used in DevOps the
first of these are slow cadence release
windows a release window is a period of
time when new software may be released
for example your organization may
determine that based on low server
demand that the period between 1 a.m.
and 5 a.m. on Saturday morning will be
the weekly release window within this
window there may be various subsets of
the release window
these are
known as release slots release slots can
serve as roll-up points within the
release window the period of slow
cadence release windows tends to be less
frequent occurring weekly monthly or
even longer however in terms of modern
high availability application services
this paradigm has all but disappeared
the advantages of this approach are a
consistent cadence to business
stakeholders and predictable release
date targets for delivery teams a major
disadvantage of the slow cadence release
window is that it tends to bottleneck a
release management process that must
support multiple teams there are only so
many slots available within the release
window and this may force some teams
releases to be delayed to the next
release window this problem may be
exacerbated further if the team is
attempting to adopt a continuous
delivery model
release train the idea of a release
train is that every team associated with
the train has the same release cadence
the train may release once a quarter
once a month or even once a week this
approach is commonly used on larger
programs where there are many teams
contributing features or subsystems to
the release the predictable schedule of
the Train is very attractive to business
stakeholders just as with a real-life
train if you missed the train the
release point your feature or update
must wait until the next train this
model also takes dependencies into
account if there are dependent modules
these must be coordinated on the same
train the major disadvantage of the
train model is because development teams
are constrained to a fix cadence lean or
continuous deployment paradigms are
difficult to implement the fixed cadence
can also introduce bottlenecks just as
in the slow cadence window release model
the quick cadence release model
addresses some of the requirements of
continuous deployment here there are
many release windows and many release
slots the increased slots allow for
finer control over dependencies and the
increased windows allow for more
frequent releases this makes the quick
cadence release window less prone to the
bottlenecks of the slow cadence and
train models
continuous release availability of the
strategies discussed here continuous
release availability is the only model
that allows an implementation of
continuous delivery with this model
teams may release solutions into
production whenever required in order to
support this paradigm several modern
DevOps practices must be implemented
some of these are fully automated
deployment fully automated regression
tests feature toggles and self
recovering components there are other
methodologies besides these that allow
continuous delivery in a release
management framework let's look at some
of these
DevOps techniques for release management
are use infrastructure as code destroy
all your servers all the time zero in on
zero downtime deployments let's drill
down on each of these components
infrastructure as code the days of
manual configuring of infrastructure are
long gone there are two main reasons for
this the first is that manual
configuration is error-prone humans make
mistakes for instance in a manually
maintained environment how many times
has it occurred that someone forgot to
properly reconfigure the environment
before a new payload was deployed this
was a common occurrence and often
resulted in countless wasted hours in
debugging the new configuration secondly
tracking a manual process through
documentation is cumbersome written
documents are also subject to emissions
misinterpretations and are frequently
out-of-date with respect to a dynamic
environment infrastructure as code is
the process of managing and provisioning
server infrastructure through machine
readable definition files just as the
software development team provides you
with the source code for your
application your infrastructure
development team provides you with the
machine definition scripts for your
infrastructure just like software source
code these can be maintained through a
version control system and become part
of the git repository and can also be
automatically propagated through a
continuous delivery system like any
other piece of software there are many
configuration management tools that
support this concept a few of these are
chef puppet ansible and salt box these
tools allow you to define in code
exactly what your environment looks like
this view is then automatically applied
to all servers infrastructure as code
has three main advantages it leads to
more reliable releases when you automate
the process of installing and
configuring software you reduce the room
for
it allows a more repeatable release
process you can run your scripts over
and over in your testing environment in
your UAT environment your staging and
production environments and know that
what you are getting is the same result
each time the release cycle becomes a
well tested and well rehearsed process
disaster recovery becomes simpler
because the requirements of the recovery
server are clearly documented and
reliably reproduced in the code the
recovery server and the original server
both share the same code set and since
the script files are preserved as living
documentation they improve audits the
script not only tells exactly how a
server is configured but since they are
version controlled you can see how it
has changed over time additionally with
a continuous delivery system you can see
when the scripts were applied and who
initiated the deployment so we can see
how infrastructure as code allows both
the development and the operation side
of teams to coordinate their releases
and deploy continuously to physical
cloud and virtual environments
destroy your servers what do we do when
our server crashes and we lose our
environment do we have the confidence
that we can recover from this scenario
in an accurate and timely manner if we
have a manually configured environment
then the answer is likely no we may be
putting our confidence in to the fact
that we do operating system backups
however is that path actually tested as
part of the backup and restore cycle
there is a common problem associated
with server administration known as
configuration drift this is where the
actual configuration of the server
evolves over time due to the compounding
effect of making changes on top of
changes this is a given with manual
configuration but it can even happen
when using an automation tool how can we
be confident that a single run of our
current configuration scripts will put
our server into a known state the only
way to eliminate configuration drift is
to destroy our servers on purpose as
part of our regular maintenance cycle we
should also deploy our services virtual
machines so that they are easy to
redeploy part of every deployment should
be the destruction and restoration of
the environment these are commonly
referred to as Phoenix servers this
process will force us to ensure that our
infrastructure code is an accurate
representation of our desired server
configuration since our normal
deployment process is to restore our
services from the point of destruction
disaster recovery becomes part of our
normal operating procedure
zero downtime in a modern DevOps
environment service outage announcements
for routine maintenance are an
embarrassment also scheduling downtime
at off-peak hours when our staff is not
likely to be at their best is an
accident waiting to happen we need to
find ways to deploy software without
affecting our user base this is
particularly important when we are using
phoenix service as their downtime can be
unacceptably long although there are a
few common strategies for managing
maintenance and downtime we will focus
here on Bluegreen deployment as an
example in this strategy we actually
have two identical server environments
set up routing using a load balancer
such as Hat proxy or enging x' so that
all of the traffic is routed to the
active server environment now you can
direct your configuration management to
update the passive server environment
when you are confident that the passive
environment is working as desired
you can simply use the load balancer to
redirect the network traffic to the new
environment with the latest changes this
way the user base will experience no
disruption in service
release management tools let's take a
look at some of the release management
tools that are in the marketplace
electric flow is a single DevOps
platform that supports the entire
end-to-end software development and
delivery process electric flow deployed
is built on top of this powerful
platform to automate deployments and
accelerate time to market reduce
delivery costs and increase quality
reliability and traceability BMC release
process management is a release
management tool that allows you to
deploy changes to your business critical
applications with lightweight web-based
test coordination and execution IBM
urbancode release formerly called you
release is a collaborative release
management tool that helps you handle
the growing number and complexity of
releases you can plan execute and track
a release through every stage of the
delivery cycle octopus deploy is an
automated deployment and release
management server it is designed to
simplify deployment of asp.net
applications windows services and
databases see a release automation is an
enterprise class continuous delivery
solution that automates complex
multi-tier release deployments through
orchestration and promotion of
applications from development through
production
hey once you become an expert in cloud
computing then subscribe to simpler
Channel and click here to watch more
such videos turn it up and get certified
in cloud computing click here</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>