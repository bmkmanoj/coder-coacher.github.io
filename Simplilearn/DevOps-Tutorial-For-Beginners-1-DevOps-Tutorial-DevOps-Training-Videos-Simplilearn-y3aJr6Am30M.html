<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>DevOps Tutorial For Beginners - 1 | DevOps Tutorial | DevOps Training Videos | Simplilearn | Coder Coacher - Coaching Coders</title><meta content="DevOps Tutorial For Beginners - 1 | DevOps Tutorial | DevOps Training Videos | Simplilearn - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Simplilearn/">Simplilearn</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>DevOps Tutorial For Beginners - 1 | DevOps Tutorial | DevOps Training Videos | Simplilearn</b></h2><h5 class="post__date">2017-03-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/y3aJr6Am30M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody my name is Colette woods
I'm the finger developer and a trainer
for a number of years now quite a lot of
experience and I've got a really strong
belief that software should be built the
highest possible quality and part of the
process of this particular course is
looking at that how can we improve the
quality of the software that we have in
in production so that we don't have any
serious problems I've done that the OMG
fundamental classification but I've
mainly of being say a senior developer
designer engineer does quite a lot of
roles over the earth my name's Randall
Gale the path to becoming an authorized
instructor is fairly straightforward
first you are certified I have over 40
years of experience in the IT industry
both on the technical side and the
management side my role was various
clients as as an architect designer
developer team mentor trainer and a
consultant I've have been involved with
several companies both training
companies and major software providers a
good degree in computer science I was
very fortunate also to be involved with
the early adoption of Java
hello and welcome to DevOps practitioner
lesson one DevOps overview in this
lesson we're going to be looking at what
DevOps is all about and why we need it
so what are we going to cover today well
first of all we've gotta get to an
understanding of DevOps
what is it very difficult to describe
get an idea of the technical challenges
of DevOps which quite a few and try to
choose the right tools to use because
there are plenty of them how to choose
when to deploy an application to the
cloud rather than on a local machine and
the very important understanding of
security issues we also need to
understand the difference between
requirements and architecture which are
often confused and we also need to read
out to write good acceptance tests ok so
what is DevOps refers further to find
out what this actual term means
now ops is short for development
operations it focuses on a collaboration
between developers and other roles
developers typically work in isolation
they can't do this anymore we need to
work in conjunction with the operations
people and the QA people we need to find
out how to develop an application from
start to end from the inception all the
way through to production and production
support it's about thinking about how
things are going to work in the future
when we're in the very beginning stages
of the operations and they all sort of
leave great importance is on automating
the process we don't want to do things
man do anymore we want everything to be
fast totally automated and reliable the
number of issues facing DevOps software
requirements are constantly changing we
also need to define a good path between
design development testing and release
we need to decide how to package the
software how to distribute it and how to
deploy it into production and we also
need to have ongoing operations and
running the system from the future from
what once it's deployed onwards through
a number of deployment issues these are
particularly true in the case of web
applications
traditionally developers write the code
and operations people manage the servers
when it comes to things like application
servers there's a gap because there's a
thing called a deployment descriptor
which is neither in the developers realm
nor the operations realm we need people
who can bridge that gap if we're going
to be successful so because developers
have very different knowledge of the
application server they only know about
the code and they're only interested
really in the code the actual workings
of the application server can be a bit
of a mystery the operations team are not
usually developers so they don't know
how to interface the software with the
application server so we need people who
are both developers and operations
people to resolve the issues this is
what DevOps is partly about now the
whole process of DevOps is to use
automation and use different tools to do
the operations the number of different
categories of tools each of the
categories has got its own range of
tools which each do something similar
but in a slightly different way so for
example with
towards the monitoring we've got tools
for releasing into production
configuration management packaging the
application all sorts of testing
integration and performance testing
building the application and initially
starting with the code development and
unit testing the whole range of tools
and we'll be looking at the whole range
of these tools from one end to the other
so what are the goals of DevOps it's
about thinking about the whole system
the whole process from start to end
this involves coordinating with the
teams and involves having feedback loops
from one position to another
it's also about continuous improvement
we need to improve the way we work by
working belt well together and using the
tools correctly so that we have fewer
incidents in production which have
costly repercussions we also want to
improve the process efficiency so that
the team learns and these better and
better each time so some important
improvements are these reducing testing
time that doesn't mean reducing testing
it means reducing the time that the
tests that she run try to reduce the
amount of changes required when we have
requirements the conflicting or
incomplete we need to resolve those
conflicts early on we need to find the
simplest solution to meet the
requirements is not necessarily the
optimal solution but a best solution
that works well we need to use standard
tools across the organization which
integrate well together we need to have
really robust production systems which
have very low maintenance costs and are
very very reliable we also need to
produce software to the highest possible
quality and to achieve this we need to
improve the performance of the
individuals and the teams and how they
work together now part of the process of
improvement is changing the way people
work we need to be strive for clarity we
want to challenge any uncertainties in
requirements we don't want to fill in
the gap which many people attempted to
do ask somebody who knows what the
answer is before making any assumptions
assumptions themselves are particularly
difficult to deal with we need to be
sure that they are valid assumptions and
that they haven't been put there for
some reason which hasn't been
justified we want simplicity and
reliability the optimal design is almost
impossible that the best design is what
we'd strive for we also want to reduce
risk we need to be able to meet the
requirements with the least risk passed
an important thing is to avoid gold
plating don't put extra code in there
just for the sake of it or for some
potential future change which may never
happen do the minimum to get the thing
to work and women's an issue find the
root cause of the issue don't just try
and fix the symptoms because the root
cause is going to come back and bite you
later on so the working practice should
be constantly evolving and very
iterative so you learn something some
new technology some no tool you try it
out work with it then you think about it
okay do not do a good job at this
critical better job assists how do I do
a better job of this and then you learn
some more to improve yourself and go
round and round the loop as you improve
as time goes on so that's the end of
that section and now we've got a
knowledge check
challenges of which there are many and
DevOps is really here to help solve
these technical challenges so what are
these challenges well first of all
technology is constantly evolving if we
look at the IT world in terms of
software itself very little has changed
over the last 3040 years we've just got
better at it but the technology has
changed dramatically no longer we got
large rooms full of very hot expensive
machines we have very small fast and
efficient machines these days and we
have to be able to use this technology
to its best our working environment is
changing as well we've learnt over the
time how to do things better and we've
got more interesting working practices
these days than we've ever had before
good practices five years ago are now
considered bad practices this constantly
evolving there are also external
influences over which we have no control
a new story can cause major economic
incidents there are legal effects some
industries particularly the finance
industry is very very tightly regulated
and there's also social influences as
well we need to be keep our customers
happy at all times
so give ups if the culture which we need
to build and maintain it needs to adapt
to continuous change by continually
changing and the organization's culture
needs to evolve around it the problem is
people are very resistant to change they
don't like to have to do something in a
different way to which they're used to
but also we need to get people to work
together and not in isolation some
people do not like this they'd like to
work in a box quietly sitting there with
their headphones on not interacting with
anybody just focusing on their work we
really can't do this anymore we have to
work together we need to talk together
and get together to get a good solution
as a team now software tools are very
important for the whole process of
DevOps now individuals and teams will
have their preferred tools in a large
organization which has been formed by
mergers and acquisitions the teams will
have come from different parts and they
will have their own different set of -
preferred tools we can really can't do
this we need to have a standard set of
tools across the organization
open-source tools are readily available
although some organizations don't like
to use open-source tools because of
support issues but it's also important
to have very standardized at a tool
across the organization for various
reasons so look at the reasons first for
licensing and compliance and many of the
software applications and tools require
licensing that can get incredibly
complex for a big organization with a
very wide range of tooling we also have
problems with versioning if people are
using different versions of the tools
that are going to be compatibility
issues which you need to address
there's also needs very important that
there are production support for the
tools you can't introduce a tool into a
production environment if the production
support team can't support it and we
also need to think about the future once
an application is in production it needs
to be maintained and supported and it
needs to be easier to do that so many
organizations have legacy systems and
any new tools that you introduce need to
be able to function with both the new
and the old systems we're getting to the
stage now where we're getting hybrid of
environments we have the existing
solutions we've got new cloud-based
solutions which is critically attractive
because of the decosta values and tools
must be cloud ready or cloud compatible
for future deployment the older new
systems need to work together and
complete with production support for
both old and new systems corporate
networks are very important and they're
getting increasingly complex we need to
have address issues such as internet
connectivity we need to think about the
addressing of various machines and
firewalls
we need to have virtual local area
networks across sites we need to connect
the cloud how about the data centers
where are the data centers and how do we
connect to them and also think about the
local area networks on the company sites
keeping teams isolated from each other
so that they don't have access to each
other's data if that might not be a good
idea for various reasons such as
security
so changing the network configuration is
very complex it's also very risky
because you're likely to break
connectivity cloud computing comes with
its own networking which is actually
very efficient it make
things less complex much more adaptable
and more audible it also needs to be
more secure but cloud platforms are very
secured by default everything is denied
by default which is always a good thing
you have to open up access to give
people permission to do things there's
also a cost impact changing corporate
culture is costly we need to buy new
hardware we need to buy new software
licenses we need to pay for cloud usage
which is usually by resources like CPU
and network we need to retrain our
employees so that they understand and
use the new equipment and tools very
well people are learning new skills we
do runs of reduced efficiency but we
have to live with that so there needs to
be a budget for ongoing change we need
to know it's going to cost there's going
to be an initial cost in terms of
efficiency and quality but that will
improve over the long term so DevOps is
not just about writing and deploying
code we need to improve existing code
new tools need to be new to support new
code new tools need to support new code
but they also need to be able to support
legacy code legacy code might need to be
changed or restarted over time to make
it more manageable to make it fit in
with a new process in tooling and we
need to taking on broad bug fixing
enhancements which need to work with the
new tools and learn procedures now so
let's have a look at some other software
tools we'll be looking at each of these
tools in more detail later on during the
course but let's have a look at what the
actual basic tools are
concept of a tool chain and one of the
challenges is to select the right tools
there are many tools that perform
similar functions and the tools also
need to work very well together
and there are a number of categories of
tools each for each stage of the
software development lifecycle phases
some tools straddles various phases some
are very specific to individual phases
so let's look at the first stage which
is requirements analysis it's all about
communication within the team and
talking across different roles so we
need to be able to that allow developers
managers customers business analysts or
to talk the same language and think
about the various tools that we want to
use so fairly obviously word processing
spreadsheets are those spreadsheets are
often very much abused and can cause a
lot of problems shared calendars so we
know when meetings are sprint management
tools although a lot of sprint
management tools are very low-tech
wiki's are incredibly useful for storing
information which is readily accessible
we need UML diagram tools to describe
our applications and we need issuing
task management tools to manage the
workflow we have the concept of artifact
creation an artifact is simply a
by-product or result of some operation
on some kind of code so very important
to source control systems they manage
the versioning of our code and make sure
that we're building the right thing from
the right versions of the software
we've got continuous integration tools
very important for detecting problems
early so that they can be fixed as if
they don't delay other developers work
we have build tools which assemble the
components of our software from source
code through the various artifacts to
the production executables we also need
to gather documentation information and
the raft tools that do that
the most complex stage of any software
development is through code development
stage and there are many tools that are
needed at this stage there's a variety
of different editors we need different
databases different types of databases
different tools for building the
software and you tools for code review
I'm very important Co quality tools
which can assess the quality of the code
and identify common problems very
quickly
we have various things like the rest API
design and that's very difficult thing
to do develop an API for communicating
across a network using the REST API is
very very difficult to coordinate user
interfaces are also incredibly difficult
to describe and get to work well we also
need to be able to map code to databases
we need unit testing and mocking
frameworks to make sure that our code is
fully custody some very important
integrated development environments they
save a lot of time developers
defectively have an operating system for
which they can develop code without
having to go outside of it and then of
course we've got the in compilers and
interpreters which tend to just work
behind the scenes turning our code from
source code into executable code
testing is vitally important we start
off with unit testing and mocking
frameworks for doing test-driven
development
we've got scripting for writing more
advanced tests such as integration tests
we've got test harnesses which test full
systems and partial systems and we've
got user interface playback tools for
testing web interfaces we've also got
packaging tools we have repositories
where software is stored which we can
fetch and integrate with our system at
any time build tools appear here again
we've got container management tools
which have grown increasingly important
people like the use of containers where
you have one application per unit of
deployment which could communicate with
each other and then we've got deployment
descriptor generation tools that you saw
also very important because these
loyalty Scriptures which describe how
software interacts the containers are
very difficult to write then we got
release management tools which are also
very important change management systems
we don't make change into production and
that it's been fully documented and
approved we approval systems to approve
releases we need to have important role
map mechanisms if we deploy a narrowness
system into production we need to get
back to the previous version as quickly
as possible
we need to automate the process of
release we also need to be able to
schedule tasks so that we can run
various components of the system at the
right time in the right sequence and the
important enterprise integration tools
which is allow us to deploy and change
applications dynamically automatically
very important continuation and
monitoring tools
such a configuration and management we
don't want to do it manually once it
automated we have the concept of
infrastructure as code basically
scripting which controls the
infrastructure request tracing tools
find out exactly what happens when a
request is made is it been executed and
put into production performance
monitoring is likely important make sure
our systems are doing what they're
supposed to be do in the timely fashion
also log file analysis tools many many
systems produce a lot of log files the
output is very very verbose we need to
look for the interesting things which
are usually things going wrong which are
very small parts of logging they will
need to go out of report issues as soon
as we could detect them and grab the
processing mechanism in place to deal
with them so now we're going to look at
cloud computing it's getting
increasingly important to deploy things
into the cloud as the cloud gives us
many benefits including cost and
performance
traditionally companies had data centers
but data centers are very expensive to
run and maintain for start off you could
have a building and the building needs
to be maintained and has to be purchased
we've also got to buy vast quantities of
computer hardware that's expensive
we also need considerable power supplies
large data centers consume vast amounts
of power and as anything that uses vast
amounts of power gets very hot so we
need a good cooling supplied to do that
we also need physical security we don't
want people getting into our data center
and causing problems we need to make
sure we can connect to the data center
from anywhere in the world that we need
to we also need to have maintenance
teams to support everything because
hardware fails fairly frequently and we
need to get it fixed as soon as possible
we also need to have security teams in
place to check that everybody's got the
right access that nobody has an ulcer
I'd axis that means we could have
policies and mechanism is in place to
secure our data centers so it's a very
expensive thing to do
to give an example of failures the
standard SATA hard drive has got a mean
time between failure of 1.2 million
hours that's a long time it's several
years if you think about it a datacenter
with a hundred thousand hard drives the
laws of statistic if we multiply those
numbers together says you can expect two
drives to fail every day on average
which is quite staggering really isn't
it most people don't expect hard drives
to fail but if you've got hundreds of
thousands of them they're going to fail
so what you're going to do well start
off you've got to have supply of
replacements to replace them quickly
need to be mirror it so that if it fails
to taken over by another one we need to
detect a fault and be able to find it if
you've got a data center with a hundred
thousand hard drives how do you find the
one that's failed will you maintain its
teams who can deal with these problems
locate the faulty drives and replace
them we also need to be able to destroy
the disks correctly so that data is not
gained by other parties for example
destroying the disks completely so that
all data is definitely lost so rather
than having a corporate data center we
move to the cloud which happens these
cloud platform providers have invested
very very heavily in infrastructure so
what they've got a very very large data
centers very highly saleable
environments very secure and very
reliable and they provide a number of
services so on the cost basis you can
choose how much disk storage you want
you can decide how many CPUs how much
computer power you want what services
you require what platforms you want
particular operating systems and also
what applications you require so one
thing that these cloud providers do is
focus on doing one thing very well they
provide a computing platform they're not
interesting anything else is the users
that provide the rest of it so a bit
more about data centers
cloud providers have varied
high-performance data centers they are
geographically distributed around the
world it is actually quite important
this some organizations are required by
law to have their data in certain places
geographically so data centers will be
distributed typically several per
continent
you need to have access points in many
locations we need to have high-speed
networks connecting from wherever your
lap happened to be to the data centers
within the data centers that needs to be
extremely high speed fiber cable
connection of pivot II between the
machines
and many cloud vendors owned their
entire infrastructure across a global
network they also have edge caching
where information is stored at the
boundary where the users interface to
the cloud rather than deep inside the
cloud where the actual data is stored so
there's a concept of infrastructure as a
service or IaaS this is the basic power
that is provided by the cloud providers
so you've got raw computing power choose
how many CPUs you've got and what power
CPUs you've got roll storage how much
disk space you'll require what kind of
networking you require do you require an
external IP address
and ability to build a computer or
network computer virtually you provide
the parameters in a webpage and the
system will just build you a computer
within a matter of minutes
so obviously the cloud providers want
payment and how is this work
we're typically payment is by resource
so when you use a component nobody else
can use it so you're tying up that
resource so basically it's fair to pay
for components when you're using them or
when your resource is held if you're not
using them nobody else can use them but
the one thing is it's very easy for the
virtual components to be returned to the
cloud vendor basically you choose to
have a component and then you release it
so a good example for cloud is an
external IP address these are very short
in demand you say you want an external
IP address for your computer it's
allocated when you start the computer
when you stop the computer the IP
address is returned to the pool for use
by somebody else it's so easy to read
configure for smaller or larger
computers so now we've got the concept
of platform as a surface or paas
and why she ceases pre-configured run
time environments typically operating
systems or operating systems plus
well-defined applications such as web
servers and these components are cloud
based and you choose which ones you want
the preclude provider is responsible for
updating the hardware and the software
act of certain versions so obviously
they will only support certain versions
of certain operating systems and certain
applications for the maintenance
purposes the customers provide the
business logic you provide the code that
uses the actual application the cloud
provider provides the rest and you just
pay for the resources that you're using
software as a service
this is where you get a full-blown
application such as a web based
application maintained by the service
provider and you pay for the usage you
pay for the networking traffic used
storage information and other things now
that you've understood the concepts of
IaaS paas and SaaS randy will help you
with the steps involved in setting up
and examine the cloud-based virtual
machine environment for the help 4 demo
welcome to DevOps lesson 1 lab exercise
one cloud setup we're going to show you
how to get a count set up with Google
cloud platform that's the platform we're
going to be using in this class and you
have a little time to get some things
sorted first you're going to need a
browser Microsoft Internet Explorer 11
or later Microsoft edge Firefox Chrome
or Safari after version 8 is just fine
however Safari private mode is not
supported and I'll be using Firefox and
I'll be using a private or incognito
window I'll explain why when we get to
that point so you're going to need a
credit card a debit card and that's for
identification Google doesn't want to
charge you anything in fact once you set
things up they'll turn around and give
you a $300 credit on your account that's
good for 60 days all right so let's
start up Firefox
and I find it really important to have a
private window so let's use that and the
reason is that eliminates all sorts of
historical cookies or any kind of state
that may indicate a previous connection
or relationship with Google and it can
get things confused so I do strongly
recommend that you use this approach
consult cloud.google.com
slash free trial
and that will bring up this screen it
says one account all of Google and it
does enter your email so if you've got
an email go ahead and put it in there
and I'm going to say create account
and that's going to go over here we'll
do a email address in here and get a new
gmail address so I'm going to put in my
information because it there's a lot of
private information here you're going to
see the next screen you're not going to
actually see this being filled out but I
will show you here you can say I would
like a new gmail address follow that
link if you want to otherwise put in
your existing gmail address okay so I'll
see you in a few minutes
I have entered that information and I
said next step and now you see a privacy
in terms to want to scroll down and then
click I agree
welcome
now we're going to continue on to the
developer console
and it says try the cloud platform for
free access to all the products $300
credit no auto charge after free trial
ends in fact what we're going to do is
accept this free trial but we're also
going to upgrade which does put us in
the situation where after the trial is
over you will get charged and the reason
we do that is we that gives us some
additional capabilities and increase
quote on the cloud which is important
for the class
they agree and continue
now it gets the point where you're going
to type in your credit card information
so I'm going to also have this blank
you'll just fill this out
and it's creating the project
and now it's complete so it says hi
welcome thanks for signing up for the 60
day free trial
we've given you a credit and if you run
out don't worry you won't be billed
until you give your permission so in the
standard setup you don't have to worry
at all you're not going to get charged
so we say yes I understand
now this is set up with a default
project called
my first project but we're not going to
use that we're going to create a
different project but before we do that
we need to do one other step on billing
so up here in the upper left hand corner
you see these three horizontal white
bars that will cause a trade to pop out
from the left-hand side and you want to
go down to billing and that will take
you to the main billing page where you
can see you're on a free trial here at
when it expires a mountain rain of
remaining and so on okay so what do we
do we have to this is kind of strange
but you need to manually refresh this
page so however you want to do that with
this little reload page or control law
or something like that and when you do
that
that something else appears this bar up
here where you can upgrade your account
this is where you change this is where
you give approval to Google to charge
your credit card or your debit card
after the trial is over so you do need
to do that it changes the nature of your
account it gives you more capabilities
so this is important to do so we'll say
upgrade
just upgrade your account read through
this be comfortable with that and then
click upgrade
congratulations you have successfully
upgraded your account
the next step is to create a project for
DevOps so the way you do that is you go
up to the blue bar and you'll see
there's my first project will go down
here and say create project and you'll
get a dialog you're going to use
actually you can use whatever name you
like but we suggest that for this work
you say DevOps the EB o-p-s and then
you'll notice the bottom you're given a
an identifier this is the project name
and this is the project ID it's
synthetic and if you don't like it you
can edit it and put something else in
there the one requirement is this ID has
to be unique across the cloud that seems
fine to us
DevOps type in 1 5 5 3 1 8 so I'm going
to say go ahead and create so it's going
to create a completely new project for
us and this will take a few moments
there's a lot of machinery that Google
has to set up billing quotas and that
sort of thing
we're done the next step is optional but
strongly recommended and that is to go
in and delete this first project and the
reason I recommend that is if you create
more than three projects you risk having
your account locked by Google you're
allowed f3 but I have found in some
cases their monitoring software is a
little aggressive so I suggest you have
absolutely the fewest number of projects
that you need so let's delete this first
one we're going to view the project's
let it come up and then go over here to
these three vertical dots click on that
go down to project settings and then go
down up at the top say delete project
you don't actually delete it you
schedule it for removal exactly one week
later the entire project will be
scheduled to be deleted after seven days
so you have to type in that unique
identifier so this is booming tooling
for this particular one yours will be
different because it's synthetic and
it's just generated and notice the
numbers are the same they tend to stick
on the numbers and change the words at
the beginning so it's matched it's
allowed the shutdown button so we click
on that it's a shutting down project and
it's pending deletion if you click on
this you'll see that you have this one
scheduled for deletion so we'll go back
we'll pick DevOps which is the project
we want to work in and let's just go
back to the home area
and this is a anchor location if you
have created resources you'll see them
listed here and there's going to be kind
of an API graph showing you how much
compute power you're using all right the
next step is to create a compute engine
instance that's going to be your lab
instance to create the lab instance
we're going to go over to the compute
engine area so we'll go down here say
compute engine and notice it says it's
getting ready this is going to take a
few minutes it's setting up networking
and setting a billing and setting of
quotas there's all sorts of background
setup that Google needs to make it
doesn't do this by default because it is
a lot of work and if a person creates a
project forward you may be doing big
data work or running bigquery they're
not going to need compute engine so they
just skip that step so we just have to
be patient while this gets set up
it's done
now we want to create our computer but
we need to take a couple steps before
that there's an image that has been
created for you and I'll show you how
you can get to it there a couple of
steps you have to take the first thing
you need to do is activate your cloud
shell okay there we have our cloud shell
the first thing we need to do is create
a bucket store in our own project and
the way you do that is you use this
gsutil program and say make bucket and
here you're going to have to come up
with a unique name I'm going to give you
some tips you start with GS colon slash
slash and then what follows must be
unique I'm going to suggest that you say
DevOps - your initials and I'll just
pick XYZ and then follow that by the
today's date 20 1701 11 as I'm recording
this and as long as it's unique you know
that's fine every bucket has to have a
unique name across the whole cloud so
we'll create that it'll come back and
say it's fine so great we're in good
shape so next what we want to do is copy
over an image that exists in another
project so what we're going to need to
do is say GS util
copy from GS : oh this you must get
exactly as I type it it is simply learn
and DevOps
an image and we want to copy everything
over to our bucket GS colon slash slash
DevOps - XYZ : 20 1701 11
you
a transfer actually took a
taken the liberty of editing the video
capture so that you didn't have to sit
through it so let's just do it clear
here and we can do some checking we can
say GS util LS show us the buckets we
have and then you say GS util LS the
bucket itself and it's just a good check
to see what we've got in there so again
X Y Z and today's date
and we see that we've got to tar.gz
files you're going to want to use the
one with the latest date stamp okay so
now we've done that we can exit out of
the cloud shell and now go back here and
go down to images and we want to create
an image so that we can then create a
computer and we'll call this student
image don't worry about family you don't
need a description and the source is not
a disc it's going to be a storage file
and we can browse our own storage
buckets so let's do that and then we
want to pick this latest one so we'll
pick that we'll select it and now we're
ready to go so we're going to take this
as a file in the cloud and we're going
to create a local image that we can then
use to create a computer let's do that
step
ok it's done and you'll see that your
image is now at the top of the lift the
other images that you see are standard
images that are supplied by Google so
this is a custom image that we created
and these are the rest they just happen
to list them all together all right
we're going to go back to the VM
instances area and now we finally get to
create our computer so this is going to
be your own computer in the cloud this
is going to be your lab computer so you
have some interesting decisions to make
the first one of course is the name and
I suggest you just call it lab and then
the second one is where it is going to
reside I'm in the United States and I
have a an affinity to US central one be
US - central one is the region notice
there's Asian North East one Asia East
one and so on the - B refers to a
particular zone so I'm just going to
pick that you can pick a different one
and notice that the charge is $25.95 a
month well we're not going to let it run
all month we're just going to look at
the hourly rate so we're playing paying
3.6 cents per hour and that's based on
the location and the size for example to
go to Asia it's going to be a little
more expensive okay we'll go back to US
central 1b but you want to pick a
computer zone that's near your location
because you're going to have a latency
between your computer and this one and
you want that to be as small as possible
the next choice you have is how big a
computer is it
you have lots of different choices and
the standard is one virtual CPU with
3.75 gigabytes of memory and that's not
a bad choice I'm going to choose this
customized option and actually dial in
slightly less memory I'm going to go
down to 2.75 and it drops the price just
a little bit so I'm just kind of doing a
little fine-tuning based on my
experience if you want you can go and
have two cores and have the thing run a
lot faster and it's 5.8 cents per hour
so again it's your choice and I'm going
to go back to one not a shared CPU but
one virtual CPU and 2.75 gigabytes of
RAM now your next choice is the kind of
disk that you're going to boot from all
right so we need to create it from a
custom image which is the student image
we're going to select that and then down
here you can say that you want to
solid-state drive or a standard Drive
now obviously the solid-state drive is
going to have better random access
seeking but it's going to be more
expensive and this one is your standard
magnetic media the curious thing here is
that the larger the disk that you
request the faster it's going to go and
if you want to set it at 200 gigabytes
and that's about the the smallest you
can pick and have it really have good
performance but let's see what the price
is so that's going to put the price up
to 4.4 cents per hour so I'm going to go
ahead and pick that as a matter of fact
I'm going to see what a solid-state
drive of that size is going to cost
so I'm going to select solid state of
200 gigabytes and that brings it up to
eight cents per hour okay that's fine
too so I want a nice fast machine
reasonable size here CPU and memory
that's going to be just fine
and then we're ready to create it so
let's say create some of these things
you can change later you can change the
you can't change the disk but you can
allocate more memory or more CPUs if you
find that your machine is just a little
bit sluggish so let's let this create
this takes about a minute or two minutes
you know I thought about this and I
actually want a bit more CPU power so
I'm going to select this and stop the
machine you have to stop it to make any
changes so we'll stop this
instance have stopped and now I'm going
to select it and choose edit
and I'm going to go in and change this
to and I'm going to use two CPUs in the
standard configuration so I'll pick an
n1 standard 2 and I'm going to say
that's the change I want to I'll save
that
now I'm going to start the computer
actually go back out I'll click on the
instance and I'm going to start it again
okay it started and now we're going to
establish
SSH connection to the computer and we
just have to click on this button it
will create a connection so the next
section is on information security which
is vitally important we need to be asked
to secure our resources and in fact it's
probably going to be a legal requirement
that you engage the information security
team at an early stage of your project
and certainly you'll need to engage them
towards the later stages security is a
vast and quite intensely complex subject
what are the security threats to the
system we'll think about things physical
access can people get control of your
systems physically social engineering
the impact of people external influences
such as crackers also external inputs
such as to East drop is among the middle
attacks the all familiar viruses and
Trojan horses buffer overflow attacks
are particularly nasty and have caused
many many problems over the years as of
denial of service attacks they've taken
down entire systems and entire
organizations human error is a very
common problem not necessarily malicious
but humans make mistakes also
configuration errors if you make a
configuration error it can have a vast
impact on the system and probably least
likely a malicious employees it can
happen but most human interventions that
cause problems are done by accident two
important aspects of security are AAA
and CIA the three acronyms so AAA we've
got authorization are you allowed to
access this system and in what access do
you have authentication are you who you
say you are auditing what happened and
when here three I others CIA
confidentiality who needs to see the
information and who shouldn't be able to
see the information integrity does a
debit always correspond to a credit
availability is your system available
all the time or sufficiently for the
requirements of your customers so
there's an important security principles
information security is absolutely vital
you need to engage the information
security teams in during development
they're often seen as people to be
avoided but actually they're very
to be talked to because they can solve
problems very quickly they know the
issues if you go and talk to them early
you can solve problems which will save
them headaches later on in in the
program and make their life easier so
they're very happy to talk to you early
on security always comes at a cost
whenever you secure a system you make it
hard to use this causes a few issues
that people like to bypass the security
systems to make the systems easier to
use and we can't really do this so there
are a number of security principles
which help Bru's use for the risks and
we're going to look at these over the
next few minutes the first one is called
defense-in-depth the idea of this is
you've got various layers of defense so
the idea is that if somebody compromises
the first layer the second layer and
subsequent layers are still holding so
an example here shown of a web server
you got the internet which is a place
where people are likely to have
malicious intent you have an initial
firewall which stops a certain number of
attackers you've got the demilitarized
zone with a web server which is also
hardened and then you got another
firewall to protect the internal network
so if the first firewall is compromised
then they've also got to get through the
hardening of the web server they've also
got to get through the second firewall
which gives you three layers of Defense
one aspect of defense-in-depth is
associated with cross-site scripting or
X SS it accounts for over 80% of
websites under abilities the idea of
this is quite simple you have a link on
a website the link points to a document
which has embedded HTML controls or Java
Script when you click on the link the
browser loads the page and executes via
code the code can have malicious effect
it can get the information from the
browser or even from the host computer
so the important thing is never store
raw user data if you have a form where
people can type in stuff which goes into
a web page it's possible for them to add
code into that form which can be
malicious so what you need to do is
sanitize the input of any user from a
web page form to remove any HTML
controls or JavaScript we're at very
least escaped it so it can't be executed
another important aspect of security is
to minimize attack services
the idea is that the fewer entry points
into the system there are the few of
Unruh Bilitis there are two so the
analogy here is the armadillo that wraps
itself up in its shell so the minimum
amount of places where a particular
tackett so in the taste of IT we've got
things like most organizations do not
permit the use of USB memory devices
because you can introduce viruses
through these things you can also take
confidential information out to the site
via these devices so these are things
that are including corporate security
policies to avoid some of the problems
of having multiple places where people
can either inject or extract information
we have the concept of fail secure this
is the complete opposite of failsafe if
you have a locked door in say a theater
if there's a fire the doors will
automatically unlock so that people can
escape
that's a fail-safe a fail secure door
would actually lock in the case of
emergency to prevent people getting in
so systems should fail secure that's the
important thing there think about what
happens if you've got a store which is
doing online transactions the connection
to the credit card citation system fails
what you do you stop the sales you don't
store a partial sale without having got
the money from the credit card valid
ation system this is actually very
important lease privilege and it's
surprising how few people actually do it
the idea is you give programs and users
the bare minimum amount of access they
need to could perform their job it
greatly in performs lease privilege is
very important the idea is to give
programs and users the minimum amount of
access they need to perform their job is
greatly improved security and stability
it requires less testing it makes
deployment easier so for example if
you've got a backup system it needs to
be able to read the data it's backing up
it needs to be able to write to the
place it's backing up - it doesn't need
to be able to write to the data it's
backing up so don't give it access to it
a common problem is security through
obscurity
trying to hide something on the
principle that nobody can find it a
typical example is a web server
listening on a strange port number like
five to 67 people think oh if I put the
web server on this port number we know
about it but nobody else will be able to
find it this is not true the software
out there called port scanners
it'll just scan all the ports on a
particular machine and when it finds
something interesting it will have a go
at attacking it it'll find your web
server cryptography is an interesting
one in the early days of cryptography
only government employees knew the
algorithms so they said the algorithms
were effectively secret nowadays all of
the cryptography algorithms are public
domain they're well published well
Danone and if buddy can look at them so
now the security is not about the secret
algorithm it's about making sure the
encryption keys themselves are very
secure not the algorithms in place the
use of modern languages we understand
the route course in many security
breaches and language design has changed
to make improvements modern languages
make it hard to make mistakes the rest
language aims to eliminate memory
allocation failures allow hacks easily
created we see in C++ C and C++ were
particularly bad for memory leaks the
clocking language aims to eliminate null
pointer errors that can crash systems
rest based systems the emphasized use
for any programming because it's all
very much decoupled this is probably one
of the most important ones keep it
simple
a simple solution has fewer
vulnerabilities once you have a complex
solution you get more complex failure
paths a good example is the Mail program
send mail in 1996 it runs about 80% of
all mail service but same mail has a
very very cryptic configuration file
it's highly symbolic it consists of lots
of dollar signs and brackets and it's
very hard to read unless you're an
expert too nowadays it doesn't run many
where near as many mail servers in 2015
it was down to 24% people have moved in
favor of simpler mail servers in which
are simpler to administer and configure
and send mail similarly in fact is
actually very good at what it does it's
just it's very very hard to configure
another important aspect of security is
segregation of duty if you've got a very
critical function make sure that one
person can't execute the complete
function from end to end what you need
to do is divide the function into
individual steps and give each step to a
separate person or entity so it requires
the collaboration of all of the
individuals to complete the operation a
good example of segregation of Duty are
the three fates of Greek mythology they
have the job of deciding how long summer
lips closed Oh spins the threads of life
the thesis measures the threads of life
atropos cuts the thread of life to show
the end of the life
trust in complete mediation it's
important to know the difference
Trust is basically where two people have
exchanged some information and they know
that each person is who they think they
are and so no further checking is
required complete mediation is where
credentials are checked on every access
of the system often on a time basis
typically what happens if the token is
generated on initial authentication the
token has to be re delivered at every
operation and the token only lasts for a
certain period of time single sign-on
systems is an accepted compromise the
problem with having many systems each we
separate passwords is that people have
to have many different passwords for
each system and they tend to forget them
this means that the system
administrators are constantly resetting
passwords so a single sign-on system is
an accepted compromise you sign on once
and the single sign-on system will all
CENTAC 8 you to any other system it's a
known security loophole as you like but
it's an accepted one because of the
system is are completely understood and
there are good solutions out there and
it's considered worthwhile to avoid the
complexities of password management
don't reinvent the wheel if as an
existing solution use it writing good
secure software is actually quite
difficult and rebuilding software from
scratch will almost certainly reinvent
previous discovered issues to give an
example the tcp/ip stack the UNIX stack
has been a long taken example the UNIX
tcp/ip stack it's been around for a very
long time
it's very stable and very reliable later
operating system vendors have actually
implemented the stack themselves and
they rediscovered many problems which
have been detected and solved many years
ago by the UNIX environment passwords
are always a problem many people have
very insecure passwords they tend to
choose things which they can easily
remember so memorable dates birthdays
people's names car registration numbers
favorite word's all sorts of things like
that which are very insecure because
they're fairly easily guessed
now also passwords are stored as a
one-way hash you take the plaintext
password apply an algorithm to it which
produces a fixed length number which is
statistically fairly unique for the text
so it's very unlikely that you'll be
able to find two pieces of text which
generate the exact same hash
unfortunately the software out there
which can find these things so the
software such as crack which would try a
whole bunch of different words based on
dictionaries and combinations of words
and numbers and they find most common
passwords very easily
there's also rainbow tables which is
where you have typically websites where
they pre calculated hashes of lots of
different passwords up to a certain
length all you need to do is paste the
hash into the website and it will tell
you what the password is if it finds a
match there are ways of securing
passwords a typical mechanism which is
used by UNIX and has been for a while is
assault what you do is you generate a
random number of six sites a 16 bits or
32 bits you add it to the password and
then create the hash you also store the
salt with the resulting hash so you know
what the salt is and you can reverse the
operation so having got the the salt
what you do is you take the password
people enter in to authenticate
themselves you add the salt to the end
of it and then you generate the hash and
compared the hashes this defends against
rainbow table attacks because
effectively every password needs to be
multiplied by the number of possible
values of the salt to generate a
complete rainbow table there are also
very good ways of making secure but
memorable passwords one quite easy one
if you take two short but unrelated
words and put between them numbers and
punctuation symbols so like bond 42
exclamation mark frogs is a an example
of such a password is quite hard to be
able to predict what it is or generate
Hearn software which can crack that
password secure ID is commonly used by
many organizations
is particularly useful for giving your
employees remote access to your internal
systems the idea is this the user is
issued with a device it's a small
electronic device which contains a clock
and a random number generator based on a
a seed so what happens is every minute
the device displays a new number the
number is actually predictable if you
know the algorithm and know the time the
server has a clock and the database for
the seeds for each of the devices so the
server is able to calculate what value
is being displayed on any particular
devices supports at any one time so what
happens is the user typically
authenticates themselves by entering
some kind of personal identification
number and the number that's currently
displayed on the device there is a
slight problem associated with this if
the clocks between the device and the
server get out of synchronization which
does happen there are ways of doing this
dealing with this the servers can store
a drift value so that they can calculate
the offset for between their clock and
the device clock and be able to
calculate the value correctly there's
also biometrics using some innate but
unique characteristic of individuals so
fingerprints have been commonly used
they're used in airports a lot these
days retinal scans have also been used
at airports although Heathrow Airport
used to have a retinal scan machine but
unfortunately they discontinued it now
face recognition is getting more common
and a lot of airports starting to use
that now the voice prints are also used
to identify people and also each
individual types in a different way the
speed of typing and the timing between
the keystrokes is unique to each
individual so any of these mechanisms
can be used to identify a person with
great with a great deal of reliability
information security many organizations
have information security teams their
role is to ensure we've got compliance
and to ensure that systems are safe and
secure you need to engage these teams
very early on in the project
they are very easily gauged they really
want to talk to you because they don't
want the consequences of you introducing
a security risk into the system view
engage them early they can detect
potential problems and fix them before
it becomes an issue now as a developer
you're on the frontline
when it comes to information security
you have to have more access to systems
than anybody else
your ass you are also writing the code
which needs to be secured if you code in
securely you're going to be the cause of
a vulnerability so you need to
understand the implications of security
and make sure that you think about it as
every stage during the development cycle
now we get onto the first stage of any
major project which is required to
analysis and the writing of user stories
and how we capture requirements so
what's the requirements well there are
various standards
it's basically what a system is supposed
to do capability or conditions needed by
users and solve a problem what is
required to satisfy the contract are the
standards and specifications or other
formal documents required and
documenting the conditions and
capability required to achieve an end
result so requirements gathering or
requirements definition is a difficult
process it's an iterative process first
of all we need to design what the
problem is
no problem definition is quite difficult
we then need to be able to turn the
problem into a series of requirements
and it's important to note that define
requirements is not the same as
designing the system design the system
is really how it works
the requirements is purely what it does
the main requirements of interest to
developers in particular are functional
requirements these are the ones that say
what the system actually does basically
the condition is this we have a process
which at the moment is a black box we
don't know what's inside the process and
we actually don't care at this stage
it'll have an initial state and we apply
some kind of input or inputs process
will happen and we'll get some outputs
and the system will be in a final state
that is basically the whole process
those four things initial state inputs
final state outputs be careful though at
this stage if you get it wrong or make
assumptions that are invalid
this is where problems get introduced
very early into the project definition
interface requirements define how inputs
and outputs relate to other processes so
if you need to communicate with another
process or other machines you need to be
able to communicate in the right
language these are often called
integration requirements because it's
integration
testing is where these are tested and
also interface requirements to users are
called user interface requirements which
are probably the most difficult ones to
get right user interface requirements
often appear in requirements documents
what they need to do is to find what
content is on each stream but without
defining what the screen actually looks
like defining what the screen looks like
is a design issue this does not happen
at this stage it happens later in the
process but what we need to do is give
the association between a functional
requirement and what the screen content
is going to be so quite commonly the UI
requirements will be in the form of some
form of wireframe diagram these are not
confused with the final appearance at
the screen there just simply show you
what information needs to be captured on
the user interface in order to execute
the functional requirement integration
requirements these identify all the
source of inputs and all the
destinations of outputs so every single
source of destination needs to have its
input and outputs defined we need to
know what type of data is flowing across
the connection
are there any protocols are there any
particular data transmission rates
what kind of volumes have been stored in
databases what kind of network access
unique wire what kind of network speed
you require if you're integrating with
third party requirements you need it to
be well documented to make sure that all
the interfaces are completely defined
unambiguously and it should be stated in
the architect specification not in the
requirements architecture is all about
how things fit together
which is where this information really
belongs performance requirements are
important for specifying the behavior of
the system so for example capacity how
many concurrent operations can happen at
once what is the data capacity of the
system database we've got availability
certain metrics are available for
availability we have the mean time
between failure what is the average time
between two things going wrong what's
the mean time to restore how quickly can
we get the system back and running and
availability is that fraction that
equation we also have response time so
what is the time difference between an
input arriving and the output being
delivered we've also got through
but we should measure how much data is
actually being passed through the system
in a given time interval it also must
occur without any errors without data
loss and within the time required any
system has assumptions so what's an
assumption it's something that's taken
for granted it's something that station
is true without any justification really
so assumptions are often not stated
which is always a bad thing because if
something is assumed and somebody
doesn't make the same assumption then
we're going to have problems so one
important thing is when we're looking at
requirements is to find the assumptions
even if they're not explicitly stated
state them and justify them assumptions
are absolutely everywhere
we must sure make sure they're all well
documented and justified jargon is an
interesting concept the idea of jargon
is it's a language or a subset of a
language which enables people within a
particular domain to communicate
accurate together natural languages such
as English are notoriously ambiguous if
you insert a comma into a sentence you
can completely change its meaning this
is why in the legal profession they do
not use commas within legal documents
and this placed comma can change the
meaning of the sentence completely with
dire consequences
the important thing is it's for people
within the same domain to be able to
talk unambiguously so a particular term
means something very specific to that
domain to give an example in the English
language there's two words which are
often confused by many people which are
jealousy and envy many people say if you
say I'm going on an exotic holiday oh
I'm jealous no they're not they're
envious envies somebody having something
you wish you had jealousy is when
something you have you likes you're
wishing jealousy is when you have
something which you are frightened of
losing people often get the terms wrong
now another issue is slang which is
quite the reverse of jargon slang is a
language between peers which enables
them to communicate with each other in
public without anybody else outside
their peer group understanding so it's
important that jargon is used correctly
developers must think in the domain to
communicate with others but only use the
jargon within the audience that
understands it and not people who don't
work within the same domain as you how
do you measure the quality of
requirements for the number of metrics
and it's getting the balance right so
importantly requirements are completely
separate from design design is a
separate phase requirements need to be
testable that's very important
requirements need to be complete with no
emissions requirements need to be clear
explicitly stating exactly what is
required for this system they need to be
consistent we don't want two
requirements which say something which
is completely different to each other
and they need to be traceable to make
sure that every requirement has actually
been implemented in the final system
almost by definition most requirement if
documents if not all requirement
documents have got inconsistencies or
have got emissions one important thing
is never try and resolve the issues
without consulting the customer or
business analyst is responsible for the
system a good way of resolving these
issues is to conduct an interview with
the subject matter expert involved it's
very important when you conduct an
interview you have a very good
understanding exactly what you need to
know and what information you need to
extract from the subject matter experts
you going to interview the several
different ways you can conduct an
interview you can have a structured
interview you can
you write the questions in advance and
maybe share it with the SME in advance
if you do that it's like a script you
need to stick to it it's good for
surveys not so good if you're not really
sure what you've tried to find out the
unstructured interview is for that
second scenario when you're not really
quite sure where we're trying to to be
or what information you need to have so
what you do is you start with various
questions which gets the interviewee
talking when they start to respond you
pick up on phrase they say and qualify
them with further questions it requires
more skill to achieve this but can be
much more productive in the long term
you can also have different types of
questions open questions there is no
right answer you're just probing really
to see what the SME comes back with
closed questions require a very specific
answer to a particular question so some
ideas or questions situation questions
why do you want this problem solved why
do you want this particular solution
what are you thinking about what are you
trying to achieve problem questions
you've got a problem what problems you
want to solve implication what's a good
pity impact of this solution what is the
business benefit of building this
solution and we also need to have the
payoff things what are the priorities
which piece of functionality are going
to be more business worthwhile than the
others which ones are going to generate
more revenue than others so now we're
going to talk about architecture which
is how things join together how do
systems communicate with each other
there are different definitions of
architecture
defined by different organizations in
UML the unified modeling language it's
the collection of connected units which
are organized to a comprehensive purpose
and what you need is some kind of model
which defines how these things
interconnect the I Triple E since a
system is a collection of components
which need to be organized to perform a
particular function or set of functions
and software architecture in practice
says the software architecture is a
program is the structure or the
structure the program which enable the
elements to be connected together and
the relationships between them so what's
the goals of architecture when it
involves various people various parties
the stakeholders the business goals as
well and also the IT infrastructure
which needs to support it as DevOps
the IT infrastructure is the most
important aspect of it but there are the
other two to take into account DevOps
will be concerned with building the
infrastructure to support the
architecture that's required so an IT
architecture what is it where its rules
and guidelines and patterns of system
development so going to manage the
problem as a series of discrete pieces
we need to define the communication
interfaces between the pieces we need to
think about the overall structure and
how data flows we need to integrate the
various systems and subsystems in the
environment together we need to develop
software modules on the best possible
design practices and design patterns
need to control delivery of software
into the system environment effectively
and efficiently and reliably so this
compares architecture and design
architecture is more strategic Rather's
design is tactical the important word in
architecture is how how do things fit
together
rather than what do we use to connect
things together we look at programming
paradigms and architectural patterns
high-level patterns rather than
algorithms and low-level patterns we're
looking at the non-functional
requirements architecture is a
non-functional requirement it's a
statement of these systems are going to
communicate in this way we're a design
is concerned with the function
requirements what does
system actually do and in UML the
diagramming language we have certain
diagrams which are more associated with
architecture than those that are you use
for design so let's look at some
architectural patterns the client-server
architecture pattern has been around for
some time the idea is we have a thick
client which communicates across a
network with some external data storage
the thick client has user interface to
business logic and the data access layer
all in the same unit of functionality so
the advantage of this is we basically
separate all of the code from the the
data it enables the server components to
be reused the server components are
managed to some central location and we
can optimize the use of infrastructure
it's also quite scalable so the
advantage of this is we basically
separate all of the code from the the
data it enables the server components to
be reused the server components and
manage to some central location and we
can optimize the use of infrastructure
it's also quite scalable the problem is
it doesn't work well with the
requirements changes there are security
issues as well
associated with it
to failure which means the whole system
becomes I'm available if the one
component fails we've also got the
presentation and business logic in the
same place which is not a good idea it's
also quite difficult to test and scale
in terms of the thick client another
pattern which is very popular is the
interior architecture where n is a
number which is usually three the great
advantage of this is it's completely
multi-threaded so the the middle layers
can be executed in parallel so multiple
clients can each have their own threads
executing it if the business logic
changes we don't need to change the user
interface client code typically the
client is a very thin client such as a
web browser we reduce the network
traffic domestically because most of the
network traffic is happening between the
layers and we can add additional layers
or tiers for various purposes to add
layers of abstraction and failover
disadvantage if requirements change we
need to change quite a bit it may be in
the middle tiers the security
implications are quite interesting as
well because they can be from is
associated with the access from the
external sources
we still got server availability and
reliability issues and we've still got
testability and scalability issues
service-oriented architectures are
becoming increasingly popular they have
a great number of advantages probably
the most important one is loose coupling
we have components which can be written
in different languages are pressing in
different environments which can
communicate with each other seamlessly
without having to worry about the
details we've got business services can
be spread across lots of different
platforms and you just use the service
you need as and when you need it we
don't need to know where anything is it
can be anywhere within the corporate
network or within the cloud and we don't
need to know what the exact location
because the infrastructure takes care of
it we can reuse services if you've got a
legacy application what you can do is
put a service-oriented front-end on it
and then it becomes part of a
service-oriented architecture it reduces
development costs and increases
development speed and it's easier to
integrate the business and the IT
environments there are some
disadvantages
quite difficult to migrate because
there's so many moving parts you need
vocal control you need very good
auditing and monitoring systems and
probably the hardest one is getting the
development and design correct how the
pieces fit together how they communicate
with each other
what series of operations is required to
achieve a particular business goal many
people and organizations these days are
going towards rest micro-services it's a
good foundation for many api designs
rest is actually not a new idea it's
been around since 1996 when the HTTP
protocol was first devised basically the
world wide web is a good example of a
restful service so the architecture has
evolved over time the web itself has
evolves massively over the 20 years
experience existence in focuses on
resources and information and NOC code
what you do when you talk to a rest
service is you ask for a representation
of information not for the actual data
itself so components can evolve
separately it's very highly scalable you
just add other services development
costs is greatly reduced
because each piece is a fairly small
unit of functionality and it makes data
important it exposes data as a resource
and requires a separate way of
representing data the data and the code
are not considered connected the data is
stored somewhere in some form the code
delivers the data in some
representational form the disadvantages
a lot of people are not familiar with
the approach and infrastructures are not
really geared up to deal with it other
than getting better it also requires a
very significant change in the way that
developers think about how things
interoperate another architectural model
is the 4 plus 1 view which is quite an
interesting concept the idea is that
different people and teams have
different views of systems so for
example you've got the logical view is
how the end-user sees a system which is
in terms of its actual functionality
you've got the development view which is
how developers seed what are the actual
software components and how they
interact
you've got the process
whew we should watch the actual
processes and how do they communicate
with each other and you've got the
physical view or deployment view which
is where the software actually resides
on what hardware and what location and
so each of those four views gives you a
slightly different picture of the system
the full force one architectural view
says okay we'll take these four views
and then generate the fifth view the
plus one which is the use cases which
take the solutions from the four views
and combine them together into a single
view same views cases user acceptance
tests are very important so having gone
through the requirements analysis to
decide what we're going to build we need
to decide have we built the right thing
so using acceptance tests are a formal
set of tests which are performed on the
end system to prove that we've actually
built the thing that the customer
actually asked for so have we actually
implemented all the functional
requirements correctly to read
acceptance criteria does it solve the
problem does it interact with all
existing systems so basically the
functional requirements drive the
acceptance tests for the functional
requirement you can design the test
cases and once you've designed the test
cases you can write the tests and
perform the user acceptance tests
functional requirements are written very
early in the development process of a
new system the user exceptions test
should be extracted directly from the
functional requirements at a very early
stage as well
they actually applied of course at the
end of the project once the system is
complete so how do we do user acceptance
testing well first of all we the testbed
ideally there should be a clone of the
production environment any change in the
production environment get mirrored in
the testbed this minimizes the risks of
compatibility issues if we have a system
which passes the acceptance tests and
then moves into a production environment
which has changed then it's not going to
work in production we may need to make
compromises to satisfy various
constraints we probably can't simulate
the large number of remote users our
system may have we might have any use at
all we need to concentrate on
functionality and information flow we're
not interested in performance at this
stage performance is only assessed once
the system is effectively in
pre-production we will probably have
to simulate external systems we almost
certainly will not be able to talk to
other systems particularly if they have
an impact on the real world we should
also have databases which are populated
with recent production data we almost
certainly will need to sanitize the
production data to remove sensitive
information such as telephone numbers
and email addresses so one example of
doing this is to replace all customer
names some name like John Doe which is
not going to have any impact very
important about telephone numbers email
addresses because you can inadvertently
cause you have to be very careful about
sensitive information of telephone
numbers and email addresses I've known
one organization where they
inadvertently released an offensive
email from the development environment
to five hundred real customers due to a
configuration error and using a
production database copy use cases are a
way of documenting requirements if you
have a structured use case it looks
rather like a test case if you think
about it a use case consists of the
steps of initial conditions or
preconditions inputs from users or other
systems the expected outputs and the
final conditions or post conditions
these are actually the same steps and
operations which you involve for testing
so effectively a use case can be
replaced by an acceptance test or rather
a use case can be converted into an
acceptance test if the use cases
customer selects a product code for
purchasing at the current market rate
the user exceptions test must specify
what the product code is and what the
current market rate is so that you can
perform the test correctly so the design
of the user tests must establish initial
values for all of the database elements
at the start of the UAT effectively the
database must be in a well-known state
before any tests are executed you also
need to know what the execution
sequences of use cases are each use case
performs a particular functional
requirement typically a use case cannot
be executed in isolation for example
many systems have a login use case none
of the other use cases can be used until
the login use case has been executed you
must specify the values of all inputs
in all steps the data values in the
outcomes was also recessive fired for
each use case step you also need to know
what the final state of the database
will be at the end of the user
acceptance test to know that the actual
system performed correctly you will also
have additional details in the design
you'll have screen layouts which will
include data formats you have
instructions for how you enter the
important in what form you also has to
have the users trained in in advance of
the UAT
the users must know how to execute the
UAT seamlessly and correctly so we have
a combined set of things the use case
scenario is the database and transaction
values that produce the user acceptance
test scenarios now an important thing is
that for every functional requirement we
have in our system the need to be a
corresponding user acceptance test how
to ensure this well a good way of doing
is using traceability matrices what you
do is you draw matrices where you have
the use case requirements on one axis
and you have the tests from the UAT on
the other axis and you put across where
the test actually tests the requirement
correctly then what you do is you look
for gaps if there is a row or a column
without an X it means there's either a
requirement without a test or a test
which is perfect because it doesn't test
the requirement if we're doing agile
software development we have user
stories rather than use cases so the
user stories need to be testable so how
do we have a testable user story well it
needs to describe an action of use to a
particular user so the story will say as
a customer I want to do this you specify
the exact target user or role so we need
to be very specific about what role is
going to be executing this story it
needs to have very clearly stated
acceptance criteria in other words it
needs to be very testable it needs to be
small typically a user story should be
implemented in a fraction of a day or at
most several days the longer a story is
the less control you have over it
needs to be short and precise very few
words that describe things completely so
here is an example from the case study
we introduced earlier question is is it
testable and can it be improved it is a
typical user story notation as a darker
administrator
it's specifying the role correctly I
need to be able to retain a list of all
containers that terminate in the last
hour a specific statement of what's
required the output web page needs to
contain the event type the container
name and the date and time of the event
source in Reverse time order that is
giving a chest that statement is giving
acceptance criteria it could be improved
but it has the basic ingredients so that
is less than one and here is a key
takeaways DevOps is a blend of
development and operations which
requires cultural change to improve
quality and reliability
there are many technical challenges
facing DevOps may need changing
technical environments so a large number
of categories of software tools each
with a large number of choices we need
to select wisely cloud computing
eliminates the need for expensive data
centers and the associated support
groups information security is vitally
important for protecting sensitive
assets it needs to be engaged very early
on architecture describes how systems
communicate and interact together it is
very important to ensure those
requirements are complete and consistent
don't fill in the gaps ask an expert
what is required if you find a missing
functionality or an inconsistency user
acceptance tests are essential to ensure
that all functional requirements have
been correctly implemented that's the
end of the session today thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>