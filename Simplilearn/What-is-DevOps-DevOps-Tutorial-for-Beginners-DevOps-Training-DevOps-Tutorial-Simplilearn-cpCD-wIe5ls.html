<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What is DevOps? | DevOps Tutorial for Beginners | DevOps Training | DevOps Tutorial | Simplilearn | Coder Coacher - Coaching Coders</title><meta content="What is DevOps? | DevOps Tutorial for Beginners | DevOps Training | DevOps Tutorial | Simplilearn - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Simplilearn/">Simplilearn</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What is DevOps? | DevOps Tutorial for Beginners | DevOps Training | DevOps Tutorial | Simplilearn</b></h2><h5 class="post__date">2017-09-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cpCD-wIe5ls" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">DevOps is short for development
operations it focuses on a collaboration
between developers and other roles
developers typically work in isolation
they can't do this anymore
we need to work in conjunction with the
operations people and the QA people we
need to find out how to develop an
application from start to end from me
inception all the way through to
production and production support it's
about thinking about how things are
going to work in the future when we're
in the very beginning stages of the
operations and they also the great
importance is are also mating the
process we don't want to do things man
who anymore we want everything to be
fast totally automated and reliable the
number of issues facing DevOps software
requirements are constantly changing we
also need to define a good path between
design development testing and release
we need to decide how to package the
software how to distribute it and how to
deploy it into production and we also
need to have ongoing operations and
running the system from the future from
work once it's deployed onwards through
a number of deployment issues these are
particularly true in the case of web
applications
traditionally developers write the code
and operations people manage the service
when it comes to things like application
servers there's a gap because there's a
thing called a deployment descriptor
which is neither in the developers realm
nor the operations realm we need people
who can bridge that gap if we're going
to be successful so because developers
have very little knowledge of the
application server they only know about
the code and they're only interested
really in the code the actual workings
of the application server can be a bit
for mystery the operations team are not
usually developers so they don't know
how to interface the software with the
application server so we need people who
are both developers and operations
people to resolve the issues this is
what DevOps is partly about now the
whole process of DevOps is to use
automation and use different tools to do
the operations
the number of different categories of
tools each of the categories has got its
own range of tools which each do
something similar but in a slightly
different way so for example we got
tools for monitoring we've got tools for
releasing into production configuration
management packaging the application all
sorts of testing integration and
performance testing building the
application and initially starting with
the code development and unit testing
the whole range of tools and we'll be
looking at the whole range of these
tools from one end to the other so what
are the goals of DevOps it's about
thinking about the whole system the
whole process from start to end
this involves coordinating with the
teams and involves having feedback loops
from one position to another it's also
about continuous improvement we need to
improve the way we work by working belt
well together and using the tools
correctly so that we have fewer
incidents in production which have
costly repercussions we also want to
improve the process efficiency so that
the team learns and is better and better
each time so some important improvements
are these reducing testing time that
doesn't mean reducing testing it means
reducing the time that the test that she
run try to reduce the amount of changes
required when the lab requirements are
conflicting or incomplete we need to
resolve those conflicts early on we need
to find the simplest solution to meet
the requirements is not necessarily the
optimal solution but a best solution
that works well we need to use standard
tools across the organization which
integrate well together we need to have
really robust production systems which
have very low maintenance costs and are
very very reliable we also need to
produce software to the highest possible
quality and B to achieve this we need to
improve the performance of the
individuals and the teams and how they
work together
now part of the process of improvement
is changing the way people work we need
to be strive for clarity we'd want to
challenge any uncertainties in
requirements we don't want to fill in
the gap which many people attempted to
do ask somebody who knows what the
answer is before making any assumptions
some shion's themselves are particularly
difficult to deal with we need to be
sure that they are valid assumptions and
that they haven't been put there for
some reason which hasn't been justified
we want simplicity and reliability the
optimal design is almost impossible but
the best design is what we'll strive for
we also want to reduce risk we need to
be able to meet the requirements with
the least risk path an important thing
is to avoid gold plating don't put extra
code in there just for the sake of it or
for some potential future change which
may never happen do the minimum to get
the thing to work and women's an issue
find the root cause of the issue don't
just try and fix the symptoms because
the root cause is going to come back and
bite you later on so the working
practice should be constantly evolving
and very iterative so you learn
something some new technology some no
tool you try it out work with it then
you think about it
ok do you not do a good job at this
critter a better job of this however I
do a better job of this and then you
learn some more to improve yourself and
go round around the loop as you improve
as time goes on
now we're going to look at the technical
challenges of which there are many and
DevOps is really here to help solve
these technical challenges so what are
these challenges well first of all
technology is constantly evolving if we
look at the IT world in terms of
software itself very little has changed
over the last 3040 years we've just got
better at it but the technology has
changed dramatically no longer we got
large rooms full of very hot expensive
machines we have very small fast and
efficient machines these days and we
have to be able to use this technology
to its best our working environment is
changing as well we've learnt over the
time how to do things better and we've
got more interesting working practices
these days than we've ever had before
good practices five years ago are now
considered bad practices this constantly
evolving there are also external
influences over which we have no control
a new story can cause major economic
incidents there are legal effects some
industries particularly the finance
industry is very very tightly regulated
and there's also social influences as
well we need to be keep our customers
happy at all times so DevOps is a
culture which we need to build and
maintain it needs to adapt to continuous
change by continually changing and the
organization's culture needs to evolve
around it the problem is people are very
resistant to change they don't like to
have to do something in a different way
to which they're used to but also we
need to get people to work together and
not in isolation some people do not like
this they'd like to work in a box
quietly sitting there with their
headphones on not interacting with
anybody just focusing on their work we
really can't do this anymore we have to
work together we need to talk together
and get together to get a good solution
as a team now software tools are very
important for the whole process of
DevOps now individuals and teams will
have their preferred tools in a large
organization which has been formed by
mergers and acquisitions the teams will
have come from different parts and they
will have their own different set of -
preferred tools we could really can't do
this we need to have a standard set of
tool
across the organization open-source
tools are readily available although
some organizations don't like to use
open-source tools because of support
issues but it's also important to have
very standardized set of tools across
the organization for various reasons so
look at the reasons first for licensing
and compliance and many of the software
applications and tools require licensing
that can get incredibly complex for a
big organization with a very wide range
of tooling we also have problems with
versioning if people are using different
versions of the tools are going to be
compatibility issues which you need to
address the zosyn it's very important
that there are production support for
the tools you can't introduce a tool
into a production environment if the
production support team can't support it
and we also need to think about the
future once an application is in
production it needs to be maintained and
supported and it needs to be easy to do
that so many organizations have legacy
systems and any new tools that you
introduce need to be able to function
with both the new and the old systems
we're getting to the stage now where
we're getting hybrid environments we
have the existing solutions we've got
new cloud-based solutions which are
increasingly attractive because of the
the cost of values and tools must be
cloud ready or cloud compatible for
future deployment the old and new
systems need to work together and
complete with production support for
both old and new systems corporate
networks are very important and they're
getting increasingly complex we need to
have address issues such as internet
connectivity we need to think about the
addressing of various machines and
firewalls we need to have virtual local
area networks across sites we need to
connect the cloud how about the data
centers where are the data centers at
how do we connect to them and also think
about the local area networks on the
company sites keeping teams isolated
from each other so that they don't have
access to each other's data if that
might not be a good idea for various
reasons such as security
so changing the network configuration is
very complex it's also very risky
because you're likely to break
connectivity
cloud computing comes with its own
networking which is at
very efficient it makes things less
complex much more adaptable and more
audible it's also needs to be more
secure but cloud platforms are very
secure by default everything is denied
by default which is always a good thing
you have to open up access to give
people permission to do things there's
also a cost impact changing corporate
culture is costly we need to buy new
hardware we need to buy new software
licenses we need to pay for cloud usage
which is usually by resources like CPU
and network we need to retrain our
employees so that they understand and
use the knuth equipment and tools very
well people are learning new skills we
do runs of reduced efficiency but we
have to live with that so the nice be a
budget for ongoing change we need to
know it's going to cost there's going to
be an initial cost in terms of
efficiency in quality but that will
improve over the long term so DevOps is
not just about writing and deploying
code we need to improve existing code
new tools need to be new to support new
code new tools need to support new code
but they also need to be able to support
legacy code legacy code might need to be
changed or restarted over time to make
it more manageable and to make it fit in
with the new process in tooling and we
need to taking on board bug fixing
enhancements which need to work with the
new tools and new procedures now so
let's have a look at some of the
software tools we'll be looking at each
of these tools in more detail later on
during the the course but let's have a
look at what the actual basic tools are
so we have the concept of a tool chain
and one of the challenges is to select
the right tools there are many tools
that perform similar functions and the
tools also need to work very well
together
and there are a number of categories of
tools each for each stage of the
software development lifecycle phases
some tools straddles there is phases
some are very specific to individual
phases so let's look at the first stage
which is requirements analysis and it's
all about communication within the team
and talking across different roles so we
need to be able to allow developers
managers customers business analysts or
to talk the same language and think
about that various tools that we want to
use so fairly obviously word processing
spreadsheets are those spreadsheets are
often very much abused and can cause a
lot of problems she had calendars so we
know when meetings are sprint management
tools although a lot of sprint
management tools are very low-tech wikis
are incredibly useful for storing
information which is readily accessible
we need UML diagram tools to describe
our applications and we need issue and
task management tools to manage the
workflow we have the concept of artifact
creation an artifact is simply a
by-product or result of some operation
on some kind of code so very important
to source control systems they manage
the versioning of our code and make sure
that we building the right thing from
the right versions of the software
we've got continuous integration tools
very important for detecting problems
early so that they can be fixed and so
they don't delay other developers work
we have build tools which assemble the
components of our software from source
code through the various artifacts to
the production executables we also need
to gather documentation information and
there are tools that do that
the most complex stage of any software
development is the code development
stage and there are many tools that are
needed at this stage as a variety of
different editors we need different
databases different types of databases
different tools for building the
software we need tools for code review
there's also them very important code
quality tools which can assess the
quality of the code and identify common
problems very quickly we have various
things like the REST API design and
that's very difficult thing to do
develop an API for communicating across
a network using the REST API is very
very difficult to coordinate user
interfaces are also incredibly difficult
to describe and get to work well we also
need to be out a map code to databases
we need unit testing and mocking
frameworks to make sure that our code is
fully custody then very important
integrated development environments they
save a lot of time developers
effectively have an operating system for
which they can develop code without
having to go outside of it and then of
course we've got the Inca pilots and
interpreters which tend to just work
behind the scenes turning our code from
source code into executable code
testing is vitally important we start
off with unit testing and mocking
frameworks for doing test-driven
development
we've got scripting for writing more
advanced tests such as integration tests
we've got test harnesses which test full
systems and partial systems and we've
got user interface playback tools for
testing web interfaces we've also got
packaging tools we have repositories
where software is stored which we can
fetch and integrate with our system at
any time build tools appear here again
we've got container management tools we
should grow increasingly important
people like the use of containers where
you have one application per unit of
deployments which could communicate with
each other and then we've got the
deployment descriptor generation tools
which is very also very important
because deployment a scriptures which
describe how software interacts with
containers are very difficult to write
then we got release management tools
which are also very important change
management systems we don't make change
into production unless it's been fully
documented and approved we need approval
systems to approve releases we need to
have important role map mechanisms if we
deploy an arrow Gnaeus system into
production we need to get back to the
previous version as quickly as possible
we need to automate the process of
release we also need to be able to
schedule tasks so that we can run
various components of the system at the
right time in the right sequence and the
important enterprise integration tools
which has allow us to deploy and change
applications dynamically automatically
very important configuration and
monitoring tools
infrastructure configuration and
management we don't want to do it
manually once it automated we have the
concept of infrastructure as code
basically scripting which controls the
infrastructure requests tracing tools
find out exactly what happens when a
request is made is it been executed and
put into production performance
monitoring is vitally important make
sure our systems are doing what they're
supposed to be do in a timely fashion
also log file analysis tools many many
systems produce a lot of log files the
output is very very verbose we need to
look for the interesting things which
are usually things going wrong which are
very small parts of logging they will
need to be out of report issues as soon
as we can detect them and gap the
processing mechanism in place to deal
with them so now we're going to look at
cloud computing it's getting
increasingly important to deploy things
into the cloud as the cloud gives us
many benefits including cost and
performance
traditionally companies had data centers
but data centers are very expensive to
run and maintain for start off you could
have a building and the building needs
to be maintained and has to be purchased
we've also got a bi vast quantities of
computer hardware that's expensive we
also need considerable power supplies
large data centers consume vast amounts
of power and anything that uses bath
server 2 power gets very hot so we need
a good cooling supply to do that we also
need a physical security we don't want
people getting into our data center and
causing problems we need to make sure we
can connect the data center from
anywhere in the world that we need to we
also need to have maintenance teams to
support everything because hardware
fails fairly frequently and we need to
get it fixed as soon as possible we also
need to have security teams in place to
check that everybody's got the right
access and nobody has an author ID axis
but that means we could have policies
and mechanism is in place to secure our
data centers so it's a very expensive
things to do to give an example of
failures the standard SATA hard drive
has got a mean time between failure of
1.2 million hours that's a long time
it's several years but if you think
about it a data center with a hundred
thousand hard drives the you the laws of
statistic if we multiply those numbers
together it says you can expect to drive
to fail every day on average which is
quite staggering really isn't it most
people don't expect hard drives to fail
but if you've got hundreds of thousands
of them they're going to fail so what
you got to do well for a start off
you've got to have a supply of
replacements to replace them quickly
every disk needs to be mirrored so that
if it fails it's taken over by another
one we need to detect a fault and be
able to find it if you've got a data
center with a hundred thousand hard
drives how do you find the one that's
failed will you maintain its teams who
can deal with these problems locate the
faulty drives and replace them we also
need to be able to destroy the disks
correctly so that data is not gained by
other parties for example destroying the
disks completely so that all data is
definitely lost so rather than having a
corporate data center we move to the
cloud what happens here's cloud platform
two providers have invested very very
heavily in infrastructure so what
they've got a very very large data
centers very highly saleable
environments very secure and very
reliable and they provide a number of
services so on a cost basis you can
choose how much disk storage you want
you can decide how many CPUs how much
computer power you want what services
you require what platforms you want
particular operating systems and also
what applications you acquire so one
thing that these cloud providers do is
focus on doing one thing very well they
provide a computing platform they're not
interesting anything else is the users
that provide the rest of it so a bit
more about data centers cloud providers
have varied high performance data
centers they are geographically
distributed around the world it is
actually quite important this some
organizations are required by law to
have their data in certain places
geographically so data centers will be
distributed typically several per
continent you need to have access points
in many locations we need to have high
speed networks connecting from wherever
you are that happened to be to the data
centers within the data centers that
needs to be extremely high speed fiber
cable connection of activity between the
machines
and many cloud vendors owned their
entire infrastructure across a global
network they also have edge caching
where information is stored at the
boundary where the users interface to
the cloud rather than deep inside the
cloud where the actual data is stored so
there's a concept of infrastructure as a
service or IaaS this is the basic power
that is provided by the cloud providers
so you've got raw computing power choose
how many CPUs you've got and what power
CPUs you've got raw storage how much
disk space she'll require what kind of
networking you require do you require an
external IP address
and then the ability to build a computer
or network computer virtually you
provide the parameters in a webpage and
the system will just build you a
computer within a matter of minutes
so obviously the cloud providers want
payment and how it does this work we're
typically payment is by resource so when
you use a component nobody else can use
it so you're tying up that resource so
basically it's fair to pay for
components when you're using them or
when your resource system is held
because if you're not using them nobody
else can use them but the one thing is
it's very easy for the virtual
components to be returned to the cloud
vendor basically you choose to have a
component and then you release it so a
good example for cloud is an external IP
address these are very short in demand
you say you want an external IP address
for your computer it's allocated when
you start the computer when you stop the
computer the IP address is returned to
the pool for use by somebody else it's
so easy to read configure for smaller or
larger computers so now we've got the
concept of platform as a surface or paas
and watch this is is preconfigured
runtime environments typically operating
systems or operating systems plus
well-defined applications such as web
servers and these components are
cloud-based and you choose which ones
you want the cloud provider is
responsible for updating the hardware
and the software to certain versions so
obviously they will only support certain
versions of certain operating systems
and certain applications for the
maintenance purposes the customers
provide the business logic you provide
the code that uses the app the actual
application the cloud provider provides
the rest and you just pay for the
resources that you're using software as
a service this is where you get a
full-blown application such as a web
based application maintained by the
service provider and you pay for the
usage you pay for the networking traffic
used storage information and other
things so now we're going to talk about
architecture which is how things join
together how do systems communicate with
each other there are different
definitions of architecture defined by
different organizations in UML the
unified modeling language it's the
collection of connected units which are
organized to accomplish a specific
purpose and what you need is some kind
of model which defines how these things
interconnect the I Triple E says a
system is a collection of components
which need to be organized to perform a
particular function or set of functions
and software architecture in practice
says the software architecture is the
program is the structure or the
structures of program which enable the
elements to be connected together and
the relationships between them so what
are the goals of architecture well it
involves various people various parties
the stakeholders the business goals as
well and also the IT infrastructure
which needs to support it as DevOps the
IT infrastructure is the most important
aspect of it but there are the other two
to take into account as DevOps will be
concerned with building the
infrastructure to support the
architecture that's required so an IT
architecture what is it where its rules
and guidelines
and patterns of system development so
going to manage the problem as a series
of discrete pieces we need to define the
communication interfaces between the
pieces we need to think about the
overall structure and how data flows we
need to integrate the various systems
and subsystems in the environment
together we need to develop software
modules on the best possible design
practices and design patterns we need to
control delivery of software into the
system environment effectively and
efficiently and reliably so this
compares architecture and design
architecture is more strategic Wireless
design is tactical the important word in
architecture is how how do things fit
together rather than what do we use to
connect things together we look at
programming paradigms and architectural
patterns high-level patterns rather than
algorithms and low-level patterns we're
looking at the non-functional
requirements architecture is a
non-functional requirement it's a
statement of these systems are going to
communicate in this way where a design
is concerned with the function
requirements what does the system
actually do and in UML the diagramming
language we have certain diagrams which
are more associated with architecture
than those that are used for design so
let's look at some architectural
patterns the client-server architecture
pattern has been around for some time
the idea is we have a thick client which
communicates across a network with some
external data storage the thick client
has the user interface the business
logic and the data access layer all in
the same unit of functionality so the
advantage of this is we basically
separate all of the code from the the
data it enables the server components to
be reused the server of component
management is some central location and
we can optimize the use of
infrastructure it's also quite scalable
so the advantage of this is we basically
separate all of the code from the the
data it enables the server components to
be reused the server of comparison
managing us on central location and we
can optimize the use of infrastructure
it's also quite scalable the problem is
it doesn't work well with requirement
Changez there are security issues as
well associated with it
the server is a single point of failure
which means the whole system becomes um
available if the one component fails
we've also got the presentation and
business logic in the same place which
is not a good idea it's also quite
difficult to test and scale in terms of
the thick client another pattern which
is very popular is the interior
architecture where n is a number which
is usually three the great advantage of
this is it's completely multi-threaded
so the the middle layers can be executed
in parallel so multiple clients can each
have their own threads executing it if
the business logic changes we don't need
to change the the user interface client
code typically the client is a feathery
thin client such as a web browser we
reduce the network traffic drastically
because most of the network traffic is
happening between the layers and we can
add additional layers or tiers for
various purposes to add layers of
abstraction and failover disadvantage if
requirements change we need to change
quite a bit it may be in the middle
tiers the security implications are
quite interesting as well because the
can be problems associated with the
access from the external sources
we still got server availability and
reliability issues and we've still got
testability and scalability issues
service our oriented architectures are
becoming increasingly popular they have
a great number of advantages probably
the most important one is loose coupling
we have components which can be written
in different languages operating in
different environments which can
communicate with each other seamlessly
without having to worry about the
details we've got business services can
be spread across lots of different
platforms and you just used the service
you need as and when you need it
we don't need to know where anything is
it can be anywhere within the corporate
network or within the cloud and we don't
need to know what the exact location
because the infrastructure takes care of
it we can reuse services if you've got a
legacy application what you can do is
put a service-oriented front-end on it
and then it becomes part of a
service-oriented architecture it reduces
development costs and increases
development speed and it's easier to
integrate the business and the IT
environments
there are some disadvantages it's quite
difficult to migrate because there's so
many moving parts you need very good
control you need very good auditing and
monitoring systems and probably the
hardest one is getting the development
and design correct how the pieces fit
together how do they communicate with
each other
what series of operations is required to
achieve a particular business goal many
people and organizations these days are
going towards rest micro services it's a
good foundation for many api designs
rest is actually not a new idea
it's been around since 1996 when the
HTTP protocol was first devised
basically the world wide web is a good
example of a restful service so the
architecture has evolved over time the
web itself has evolved massively over
the 20 years it's been in existence it
focuses on resources and information and
not code what you do when you talk to a
rest service if you ask for a
representation of information not for
the actual data itself so components can
evolve separately it's very highly
scalable you just add other services
development costs is greatly reduced
because each piece is a fairly small
unit of functionality and it makes data
imported it exposes data as a resource
and requires a separate way of
representing data the data and the code
are not considered connected the data is
stored somewhere in some form the code
delivers the data in some
representational form the disadvantages
a lot of people are not familiar with
the approach and infrastructures are not
really geared up to deal with it other
than getting better it also requires a
very significant change in the way that
developers think about how things
interoperate another architectural model
is the 4 + 1 view which is quite an
interesting concept the idea is that
different people and teams have
different views of systems so for
example you've got the logical view is
how the end-user sees a system which is
in terms of its actual functionality you
got the development view which is how
developers see it what are the actual
software components and heard of the
interact you got the process view which
is watch the actual processes and how'd
they communicate with each other and you
got the physical view or deployment view
which is where the software actually
resides on what hardware and what
location and so each of those four views
gives you a slightly different picture
of the system so the four posts one
architectural view says okay we'll take
these four views and then generate the
fifth view the plus one which are the
use cases which take these solutions
from the four views and combine them
together into a single view in terms of
use cases user acceptance tests are very
important so having gone through the
requirements analysis to decide what
we're going to build we need to decide
have we built the right thing so user
acceptance tests are a formal set of
tests which are performed on the end
system to prove that with actually built
the thing that the customer actually
asked for so have we actually
implemented all the functional
requirements correctly so we need
acceptance criteria does it solve the
problem does it interact with all
existing systems so basically the
functional requirements drive the
acceptance tests from a functional
requirement you can design the test
cases and once you've designed the test
cases you can write the tests and
perform the user acceptance tests
function requirements are written very
early in the development process of a
new system the user acceptance tests
should be extracted directly from the
functional requirements at a very early
stage as well they actually applied of
course at the end of the project once
the system is complete so how do we do
user acceptance to testing well first of
all we need a testbed
ideally this should be a clone of the
production environment any changes in
the production environment get mirrored
in the testbed this minimizes the risks
of compatibility issues if we have a
system which passes the acceptance tests
and then moves into production
environment which has changed then it's
not gone to work in production we may
need to make compromises to satisfy
there is constraints we probably can't
simulate the large number of remote
users our system may have we might have
any users at all we need to concentrate
on functionality and information flow
we're not interested in performance at
this stage performance is only assessed
once the system is effectively in pre
production we will probably have to
simulate external systems we almost
certainly will not be able to talk to
other systems particularly if they have
an impact on the real world we should
also have databases which are populated
with recent production data we almost
certainly will need to sanitize the
production data to remove sensitive
information such as telephone numbers
and email addresses so one example of
doing this is to replace all customer
names some name like John Doe which is
not going to have any impact very
important about telephone numbers email
addresses because you can inadvertently
cause you have to be very careful about
sensitive information such as telephone
numbers and email addresses I've known
one organization where they
inadvertently released an offensive
email from the development environment
to 500 real customers due to a
configuration error and using a
production database copy use cases are a
way of documenting requirements if you
have a structured use case it looks
further like a test case if you think
about it a use case consists of the
steps of initial conditions or
preconditions inputs from users or other
systems the expected outputs and the
final conditions or post conditions
these are actually the same steps and
operations which are involved for
testing so effectively a use case can be
replaced by an acceptance test or rather
a use case can be converted into an
acceptance test if the use cases
customer selects a product code for
purchasing at the current market rate
the user exceptions test must specify
what the product code is and what the
current market rate is so that you can
perform the test correctly so the
designer of the user tests must
establish initial values for all of the
database elements at the start of the
UAT effectively the database must be in
a well-known state before any tests are
executed you also need to know what the
execution sequences of use cases are
each use case performs a particular
functional requirement typically a use
case cannot be executing isolation for
example many systems have a login use
case none of the other use cases can be
used until the login use case has been
executed you must specify the values
all inputs in all steps the data values
in the outcomes was also be specified
for each use case step you also need to
know what the final state of the
database will be at the end of the user
acceptance test to know that the actual
system performed correctly you will also
have additional details in the design
you'll have screen layouts which will
include data formats you have
instructions for how you enter the
important in what form he also has to
have the users trained in in advance of
a UAT the users must know how to execute
the UAT seamlessly and correctly so we
have a combined set of things the use
case scenarios the database and
transaction values that produce the user
acceptance test scenarios now an
important thing is that for every
functional requirement that we have in
our system there needs to be a
corresponding user acceptance test how
to ensure this well a good way of doing
it is using traceability matrices what
you do is you draw matrices where you
have the use case requirements on one
axis and you have the tests from the u8
here on the other axis and you put a
cross where the test actually tests the
requirement correctly then what you do
is you look for gaps if there is a row
or a column without an X it means
there's either a requirement without a
test or a test which is perfil espresso
it doesn't test a requirement if we're
doing agile software development we have
user stories rather news cases so the
user stories need to be testable so how
do we have a testable user story well it
needs to describe an action of use to a
particular user so the story will say as
a customer I want to do this you specify
the exact target user or role so you
need be very specific about what role is
going to be executing this story it
needs to have very clearly stated
acceptance criteria in other words it
needs to be very testable it needs to be
small typically a user story should be
implemented in a fraction of a day or at
most several days the longer a story is
the less control you have over it it
needs to be short and precise very few
words that
describe things completely so here is an
example from the case study we
introduced earlier question is is it
testable and can it be improved this is
a typical user story notation as a
doctor administrator
it's specifying the role correctly I
need to be able to obtain a list of all
containers that terminate in the last
hour a specific statement of what's
required the output web page needs to
contain the event type the container
name and the date and time of the event
sourced in Reverse time order that is
giving a test that statement is giving
acceptance criteria it could be improved
but it has the basic ingredients hey
once become an expert in cloud computing
then subscribe to simpler channel and
click here to watch more such videos
turn it up and get certified in cloud
computing click here</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>