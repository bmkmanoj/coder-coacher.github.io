<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What is GraphQL | Coder Coacher - Coaching Coders</title><meta content="What is GraphQL - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Ben-Awad/">Ben Awad</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What is GraphQL</b></h2><h5 class="post__date">2018-03-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/G0flJz7Zbvc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey guys so this Friday I'm gonna be
giving a workshop for a reactive on and
at the beginning I need to do a little
presentation about what is graph QL so
I'm gonna be giving the practice demo or
practice of the presentation now yeah so
I can get used to it and then also see
you guys can see what it actually is so
yeah without further ado let's get
started
so why graph QL so before we get into
this a little about me my name is Ben
Awad and I'm a computer science student
at the University of Texas at Dallas so
I make youtube videos in my free time
about programming and recently have a
major focus on reacting graph QL as
those have really become my favorite
technologies and then I also work on a
product called saffron which is an
online cookbook and it's built with
react and graph QL so to dig into really
what graph QL is and the problems it
solves I want to take a look at rest and
what's wrong with rest or some of the
things that graph QL fixes and rest so
to help me out with this we're gonna
take an example so I want you to think
about a block so it could be for example
medium and right here we are looking at
Bloomberg's
profile now take a look at the data on
the page this could be coming from
several different endpoints or api's if
you're using a regular rest server so
here I broke it up into three different
parts they might be fetching data for so
up here in the top with the red they
might be fetching for example the user's
profile and maybe a description of that
user and then from different end point
they might be fetching the followers and
how many followers they have and then at
the bottom another end point they might
hit for the actual posts themselves or
the stories so three different end
points to get three different pieces of
data
so the request might look something like
this so it might be broken up into three
different parts and the first part will
go ahead and make a get request to get
the user now I want you to take a close
look at this JSON response that we're
getting back from the server notice it
has address and birthday which are not
really needed to display on the screen
so it's extra data that is pretty much
useless that's getting fetched and this
is what's known as over fetching and so
this is one of the problems with rest
and with endpoints now there is ways to
remedy this problem so one of the ways
is to try to specify the fields that you
need so in our last example for example
we didn't need the birthday or the
address so we could just query the
fields that we need so notice at the end
here I add a question mark and we could
add query parameters to specify hey what
fields do we want to select from this
end point but this slowly deteriorates
when you have nested relationships and
what do I mean by that take a look at
address so this is an object itself so
maybe an address there's a city so what
if I just wanted to select the city for
the user well then I would only want to
select address and then from address I'd
only want to select city so that might
look something like this
and you can see as you nest more and
more objects it can get a really messy
query to try to look at and also built
so this is not a great solution with
that so this might be your second
request so again you'll see we are over
fetching because we don't really need to
show the comments for the posts we just
saw showing like an image for example a
title and content of the put we're not
even showing the whole content right
another thing it's only showing a
snippet of the content so again fetching
too much data than what you really need
and again we hit a third endpoint
well to get our last data got the
followers now I under fair has one thing
or sorry over fetching is one thing but
we're also under fetching and what I
mean by that is on the first request
that we made to get the user we also
didn't just want the user himself but we
wanted the posts and the followers for
that user and we didn't get all the
information in the first request that's
why we had to make a second and third
request like this so let's let's known
as under fetching and that's really the
second problem now this can be kind of
solved by creating custom endpoints so
maybe for example we say user slash ID
slash all posts and then we get the
direct you know posts or the data that
we need for a screen and then maybe you
would make a route per screen and you
would basically have the exact fields
and stuff that you would need for a
single screen and this actually will
work pretty well for small applications
but as stuff starts to grow and if
you're at a large company with a lot of
different routes a lot of different
pages use across lots of different
things the custom endpoints can just get
disgusting and all over the place
so not really a good solution at all so
graph QL solves both of these problems
so you'll no longer over fetch or under
fetch and you'll get exactly the data
that you want and that's why graph QL is
kind of a way to do both of those things
or get rid of those problems which is
really nice so let's take a look at what
it would look like with graph QL so to
do that same query we were just looking
at with the three requests here is it in
one query with graph QL so instead of
making three round-trips will now only
make one roundtrip and notice here is
the query that we are writing this is
graph QL right here and we specify the
user we want and then on the user we
specify the fields
so I only care about the name I don't
want to get the birthday or the address
and then same thing for posts so I add
the posts and then I only want to see
the title for the post maybe right I
don't want to see the content or the
comments so you grab just what you want
and then notice also I'm able to add a
filter or argument on sub containers or
sub the fields right so for my followers
I just want the last three in this
example and then this is the JSON data
that you get back from the endpoint and
you'll notice the shape matches the
shape of the graph QL so it makes a lot
of sense going from the graph QL query
to the JSON data because it looks very
similar and you know exactly what you're
getting back so that's super nice so
next what I kind of want to look at is
now you know why you would want to use
graph QL and the problems it solves
let's learn a little bit more about it
so with graph QL you're gonna be
creating a schema so here is a very
basic schema for a type called person
now with this you actually specify the
data types or the type for each field so
for example name is a string ages an int
and now you'll notice on the string I
have a bang sign or an exclamation mark
that means it's a required field so I
have to have a name but age could be
null for example now with these when
you're setting up a schema and graph QL
you're these fields are the ones you
want to expose right so for example I
wouldn't have a type user and then show
the password or have a password field
these are really only the fields that
you'll want people to be able to select
but if I wanted to I could only select
the name if I wanted to or just select
the age when I was actually querying
this type so let's take a look at
another type called post and this is how
you can actually do relationships in
graph QL so here I have a type post and
it has an author which is of type person
so now post and person are related and
you can finish this relationship by
creating a
a field to our type person and saying
posts and you'll notice there are
brackets now around post datatype this
means that we want an array back and now
you'll notice how there's two bang signs
here so this is sometimes confuses
people what that means is on the have an
array of non null posts and then the
array itself cannot be null so this
field posts cannot be null it has to be
at least an empty array and inside of
that all posts you can't have any no
items in the area okay so you guys saw
what it looked like for a query I wanted
to show you also what's called a
mutation so queries are when you're
getting data but what if you want to
create or add data or update data or
delete data you'll do what's called a
mutation and so you'll have a name for
the mutation so for in this case we're
creating a person and in the fields and
those are just like the fields that are
gonna be added or created maybe in the
database or wherever to do this and then
you'll notice there's a selection again
so these are the fields that I want back
so I would like to know these fields
after I create this person and then
here's what the JSON response looks like
back and you'll notice how we have
create person I'll object and inside
that we have a name Bob and age 36 okay
very cool so there's one last thing we
haven't talked about yet and that is
subscriptions so there are query
mutations and subscriptions
subscriptions are for real-time data so
what's going to happen here is I said I
want a subscription for a new person and
so every time a person is created will
automatically get an update in our query
and update basically add every new
person we're gonna get that so on our
front-end we can subscribe to new people
or new to this new person and then
whenever a person is created with a
mutation the people that have subscribed
are going to be updated or alerted that
and here is the new person
and this is very similar and it uses
sockets under the hood so this is what a
whole schema looks like how this is very
bare-bones and simple schema but you can
see we have our three main types query
mutation subscription and then fields
inside of that so all persons would
select all the people so we have an
array of people returning back and then
we have any arguments to change that and
any way we might want to and then here
are our types below and then so what is
the point or the benefits of having this
schema and the types themselves well
first off its self documenting and what
I mean by that is you know exactly what
data you're getting back and what data
you need to send to this server and you
also know when things get changed so as
a front-end engineer you're looking at a
graph you will server you know exactly
what data to send and exactly the data
you're getting back which is really nice
because you might have to go over and
ask the backend guys hey what what how
does your end point work right so it
works very well if you have a split team
of front-end and back-end people because
it really helps communicate between them
and then whenever you make changes in
the backend the front-end guys know
right away because their queries will
automatically crash now because in
graphic uol it confirms and make sure
all the types match up so when you make
a query on the front end before it even
gets executed you know whether that
query is able to work on the server and
then because we set up types it's very
easy in a schema it's very easy to mock
the data so we can actually create we
take a look back at this dummy data for
person post this whole thing
automatically and so you're fronting
guys can build a whole front end while
the backend guys are working on the
backend and don't have to wait for the
backend guys to actually finish
developing create person we're all
persons it's just gonna be automatically
done and filled with dummy data and then
when the backing guys actually finish
something or finish developing out the
backend they can be like alright we no
longer need
mock data and now the real thing works
so it's really nice for that so next
what I want to look at is how to
actually architect this or what graph QL
looks like in a server and client
relationship so right here on the Left I
have maybe your your phone or your
laptop or desktop computer and makes a
request and what's gonna make a request
to is a graph QL server in this case its
first gonna hit graph QL and you can get
this set up with for example a database
and that's pretty much all you need so a
server graph QL and then a database
setup and what they'll do is you'll have
define your schema and you're going to
create something called resolvers and
resolvers is how you get data for your
schema or fulfill mutations and queries
so for all persons query we would create
a resolver that would fetch all the data
from our database for example but the
cool thing about graph QL is it doesn't
just work with a regular database it can
work on your existing setup so you might
have a REST API right now or some number
of Micra services or you might need to
interact with a third party API of some
sort so graph QL can be a central server
or the client queries from and then
graph QL server will go ahead and query
the legacy system the micro service or a
third party API get all the data send it
back to the client in one place so this
works really well really with no matter
how your back-end is set up you can
pretty much just put graph QL in the
middle and it will just help facilitate
request and you can also combine the two
together so in this case we have a graph
QL server which has a database and then
we can also mix and match this with
third party API s and any kind of micro
service or legacy system and now it
doesn't really matter where the data is
coming from because you resolve each
field by itself so each field in that
schema that we saw
you could get some one of the fields
from a legacy system another field from
a third party and the other one from the
database it doesn't matter you have full
control how each field gets its data and
that's super powerful and very nice so
that kind of gives you an idea of how
graph QL would work in your stack and I
want to just answer a few common
questions people have so the first is
scratch well a database it might sound
like a graph database but it is not a
database at all
it's a query language and in fact graph
QL it works with any database you want
you could use MongoDB you could do
Postgres sequel of my sequel whatever
you want and if you want to you could
use it with a graph database yourself
and then it's graph QL only for react or
JavaScript again the answer is no you
can pretty much use this with any
front-end you want so angular view or no
JavaScript or pretty much anything you
want because it just needs to send a
post request right so our server takes a
post request and then does stuff and
then the back inside it really doesn't
matter graph QL is just a spec and then
you can implement it in any language you
want so it's basically just a way to
solve the problems and do the things
that we saw so on the back end we could
do this with Django Ruby on Rails
Phoenix if you have any elixir fans and
any database or not database but
back-end language or server language you
can set this up for but I will say it
definitely is the most popular for react
and in JavaScript for like setting up
nodejs
on the backend there's definitely the
most libraries and the most support for
it right now
so if I was setting something up in
graph QL I would be one started with
JavaScript because they just have the
most support right now but other
languages are catching up really quickly
too so that's it and this woman asked
for any other questions but of course
you guys are in a live audience right
now but yes
this is the presentation I'll be giving
at the workshop those of you that made
it to the end let me know what you guys
thought if there's any feedback you have
or anything you'd recommend changing
before I give this alive so yeah thank
you guys for watching that's it for this
one
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>