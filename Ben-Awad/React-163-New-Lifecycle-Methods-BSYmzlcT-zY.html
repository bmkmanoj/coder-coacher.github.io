<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>React 16.3 New Lifecycle Methods | Coder Coacher - Coaching Coders</title><meta content="React 16.3 New Lifecycle Methods - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Ben-Awad/">Ben Awad</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>React 16.3 New Lifecycle Methods</b></h2><h5 class="post__date">2018-04-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BSYmzlcT-zY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey guys in react 16.3 they made some
changes to the lifecycle methods so
these are the ones that are special and
have special meaning in your components
so three of them that are going to be
getting depreciated our component will
mount and instead of using that one the
idea is to use component did mount and
then they're getting rid of component
will receive props and instead of using
that one they recommend a new one that
they've created called to get derived
state from props and then lastly
component will update personally I
haven't really used component we will
update a lot but it looks like they
added a new one called get snapshot
before update which I guess you can use
in favor of our over component will
update and not have to use that one but
it looks like if you're for example
scrolling and you rerender you can keep
the position of where the user was
scrolling with that but the really the
most interesting one to me is this get
drive state from props so that's what
we're gonna be looking at today because
that's the one I will be using the most
so I made a little example in code
sandbox to show you guys some of the use
cases of this new method that you can
use so let's explain the code real quick
of what's going on so here is my index I
guess where I'm rendering an app and and
I have a state for my app and in the
state I have basically just array of
names and I'm calling this function
called get random names to generate it
and it puts a hundred random names in an
array this is just to basically give us
some dummy data and I'm using the faker
library to do this so I have a bunch of
people's random people's names and then
down here I can push a button and it'll
generate two new random names so if I
click this notice how the names on the
right just change and then I'm passing
it to this component called sort array
one and so this takes the names that I
have
my state and it renders them over here
and you'll notice it sorts them so we
have a nice ascending order right now
and so what I want to show you guys is
basically an inefficiency that I'm using
in sorter a 1 right now and how we can
improve this using one of the new
methods so right now here is my sort
array and this is sort of a 1 and you'll
notice it in the render function and I'm
console logging every time the render
function is called we just call array
dot sort and then we're mapping over it
now this is not ideal because if this
component were to re-render but the
array doesn't change we're doing this
sort an extra time that we don't need to
so let me show you what I mean by that
so right here I have a button and that's
what the second button does here it's
called rerender and it basically just
updates the state even though there's no
state here basically all it does is
causes this component to re-render so if
i were to call this notice how a call
sort list so I don't have any names
changing over here
but because I'm calling rerender the
render function is going to be called
and we are sorting the array each time
because we're sorting it and this is
inefficient because we're basically
sorting something we've previously
sorted and there's no point in sorting
every time it renders so this is one use
case of the new method so let's look at
sort or a two so now instead of getting
and come back real quick getting the
array from the props we're now getting
the array from the state and you'll
notice I am saying array dot map and
just displaying it so I'm assuming
basically that this array is sorted in
the correct order now and the way I'm
doing that is to use the get derive
state from props
function so this is one of the new ones
and you'll notice I have two parameters
next props and previous state for this
one we don't really care what the
previous state was but what we want to
do is take the new props or the array
that we get from the props and we want
to sort it so here I'm calling the next
props dot array dot sort and then I'm
returning an object like this and now
what this does is it actually updates
your state so you've noticed I actually
don't even have state in here but I am
getting the array from the state and the
reason why we actually have array in the
state is because of this guy right here
because he's updating this state with
his return function so he's returning
these the sorted array that's going into
the state and then where you can access
that state in the render but the nice
thing about this is this only ever gets
called when the props change so if we
for example rerender it won't be called
more times so I added a console.log to
see how many times we are sorting this
and if I come over here and I say sort
array 2 we can take a look at how many
times this is sorted so I grab new names
and I see sort lists pop up here but now
if I rerender it does not resort it
because the props are not changing only
when the props changed like when I get
new random names does it sort again so
this is more efficient than sorting
every time in your render function so
think about some of the computations
that you're doing in your render
function and seeing if you can take them
out and put them either in drive state
from props like this or even pass sort
them before you even pass them down
through the props so those are good
that's one use case is to basically
handle any kind of derive state so
that's what it means by derive state if
you need to do anything before you store
it into your state so I want to show you
guys another example
and this is sort array three so he's a
little bit different and that I have
this button right here called descending
and I can click on it and it now sorts
the list in a descending order or I can
click it again and it's now ascending so
basically I just had a little flip flop
now I can switch so let's look at the
code that does this so I'm using the old
function called component will receive
props and the reason why I'm doing this
is I can't show you how you might
approach this before and now how you can
change this to use the new method
because this will get depreciated so
component will receive props it gets
called every time you get new props
after the component has first been
mounted or rendered the fat for the
first render I think so you'll notice
what I'm doing here is in my state I am
holding the data and the whether we're
ascending or descending and then I have
a function called the sort data and we
can look at what a sort data does so I
check whether ascending and if we're
ascending I say data sort and if we want
to be descending I sort it and then I
reverse it so we could have sorted the
other way but I just went ahead and
reverse it to make this simple so that's
what we're storing in our state and then
what we do is every time you receive a
new data we take you know the ascending
that we have in our states so if it's
descending for example and I get new
data you'll notice I don't go back to
ascending I stay in descending and I
just get new data so I sort the data
based on next props
so next props holds the new data that
we're getting we pass in our array we
sort it and you'll notice what I do is I
call this dot set state so I actually
call set state to update the array
then our render function I have
basically just rendering all the names
and then I have a button and then if
we're ascending I display the opposite I
just display the opposite of what we're
currently sorting by so you can flip it
and then if they click on the button I'm
updating this state switching it from
ascending to descending or what not and
then I'm also sorting the data in the
opposite way okay so that's kind of how
this function is working so now I want
to compare and contrast this with sort
array four and with sort of a for I did
the exact same thing except now I'm
using this derived state from props
instead of component will receive props
okay so with this there's an important
difference notice how there's actually a
couple important differences notice how
I had to actually have this constructor
where I initiate the initial value for
the array and I don't have to do that
over here right I just say ascending is
true and that's because this gets called
on the very first render and so I take
ascending is true this is the first
value and then these are the first props
ever passed in and then this will update
the state and notice how we don't say
this dot set state we just returned what
we want the new value of the state to be
and by the way this is again a shallow
merge so it I don't have to put
ascending is equal to crab state right
ascend game
I didn't spell that right but you get my
point you don't have to put that there
it's not necessary so it's pretty nice
too
it works just like how this dot set
state does at least how it merges these
so if you have nested objects you're
still gonna have to spread those but
anyway the other thing that's different
is I cannot access any kind of class
methods so in sorte array 3 I created
one called sort data that handled stuff
but I actually would not be able to
access that method and this function now
luckily I'm not doing anything special
in here that requires me to access the
class so I can just put a constant
function up here and use that but for
example I couldn't do this dot sort of
data and put sort data in my props here
it would actually crash because it can't
access it because it's stack so that was
if you didn't know what static means you
can't access any of it restricts you in
that sense you can access any class
methods but other than that I didn't
have to initiate like I said in the
constructor because this will call the
first time it's rendered and then down
here exact same code for that and this
is on code sandbox so if you guys want
to come check out this code you can but
I hope that gives you an idea of some of
the use cases and the differences
between it derives state from props and
component will receive props I don't
mind just switching over the code I
think it also made it a little bit
cleaner but I don't know if I'm gonna
run into situations I haven't used this
too much to know whether it being static
if that's gonna mess me up yet it might
but maybe it'll help me clean up my code
in a way that makes it better whereas
before I could have gone into trouble
needing to have that yeah but that's it
for this video guys
thanks for watching
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>