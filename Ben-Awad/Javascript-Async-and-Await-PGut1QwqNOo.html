<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Javascript: Async and Await | Coder Coacher - Coaching Coders</title><meta content="Javascript: Async and Await - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Ben-Awad/">Ben Awad</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Javascript: Async and Await</b></h2><h5 class="post__date">2018-01-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PGut1QwqNOo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey guys I want to show you a sink and a
weight it's a really cool concept in
JavaScript that helps a lot when you're
dealing with asynchronous code now right
here I have some code and I'm using coca
to print out the output right away so we
can see as we're typing the results I
also have the cocoa window up because
we're gonna be showing some objects and
it's a little bit easier to see the
objects right here so I imported fetch
and this is an asynchronous function
that we're gonna play with I'm first
gonna show you what it's like to use an
asynchronous function without a weight
and like the regular way to do it so
this guy returns a promise and I'm just
calling main which calls fetch and then
we can see the results so if you ever
use fetch before you know you can't just
return fetch like this you kind of get
some gibberish metadata you need to
actually call JSON on the response for
but fetch returns a promise so to get
the results of a promise you call dot
then and now you have this X which is
what we just saw and I can call X dot
JSON on it and grab that so now we can
see an actual object back the JSON
response from hitting the random user
API here and we can see we get results
and we get an array and we see the first
one is a female so this is well and good
this is how you would do it if you are
just doing it the regular way so what is
so wrong about doing this way or what is
what's you know what is there to improve
on so let's say we wanted to do multiple
async calls in a row for example X dot
JSON is an async function as well so if
we wanted to get access to the JSON
object right away we had to call dot bin
on it so I could say Y and I can return
Y dot results and the reason you may
want to just get the Ray and maybe I
want to get the gender of the first
person so I could say zero dot gender
and we could get the gender of the first
person which is a male
so if I had to do this again right let's
say I wanted to get the results of this
and then I want to make another API call
and another API call you can see with
this can get out of hand pretty quickly
where I'm just stacking dot vens here
and we just keep going again and again
so basically the problem is it just gets
really cluttered using dot then a lot of
times and the way you would handle
errors in this case so for example let's
say I forgot to do add a tea or
something so bad protocol there you can
see an errors being thrown night now so
if you wanted to catch this error you
would do dot catch and so we'd catch the
error associated to that promise and we
could just say an error has occurred or
well you know whatever you could return
the air if you wanted to and we see this
is the response an error has occurred so
how do we do this with a sink and a
weight to make this better because you
can already see how kind of ugly this
code has become so we can make this a
lot cleaner so the first thing is to use
a weight you need to use it inside an
asynchronous function and to denote
something as an asynchronous function
you take the function so here's our
function and right before the
parenthesis you say a sink this guy is
now an asynchronous function so we're
gonna just console or comment that out
you say costs response is equal to a
weight of fetch and then down here I'm
going to just return response but we're
gonna do some stuff with response so
this is equivalent to me saying dot then
sex so returning just the value so right
now we have the response we basically
have the result of promised a fetch so
what we can do now is we can say a cons
JSON stew the JSON response you can say
dot JSON now I remember when I called
dot JSON here I had to do dot then
because this was a promise as well so
now I can do a wait out in front and
let's just return JSON and let's fix our
error we can see we get the results back
and now you can see this is really nice
for doing a sync all after a sink call
so now I can do you know I don't even
have to I can I don't need this stuff
anymore I can just do dot results grab
the first one got gender and we see
female so this makes a lot of sense and
looks really nice compared to the other
one we can see we made our first call
then we got Jason from the response and
we need to do the gender so the reason I
like it is this cleans up the code a ton
and so what's the deal with this async
thing here so whenever we attach a sink
to a function like this that means the
function will now return our promise and
it is asynchronous so here is my async
this is another async function you don't
have to do async code inside of this but
you can so here is me just saying we can
take a parameter X return X plus 5 so
now I can return
and say Kant's answer is equal to my
async six so if I call it like this so I
want to concatenate these two and see
the results of both of them so by
default right this function if you if I
did not add a sync we just get the
result like we normally would
this is normal function you've seen this
before this looks fine and I need to
make sure to call or actually put the
right thing there you go answer so we
see male 11 fine
well what happens if I add a sink here
by the way if you don't have parenthesis
like this you just add a sink like right
there right in front of your first
parameter and that works just fine so
now you see how we're returning a
promise so when we had a sink in front
and makes this thing asynchronous so
we're now returning a promise
so you need to await it and then it
works as normal we get 11 so make sure
to await async functions or you can call
my async and if you prefer the other
syntax you can do dot then getting
treated as async function so how do we
handle errors BAM just exploded this guy
right he doesn't work so the way you can
do this is wrap it and try catch now
so if again air you can return there was
an air you could do whatever you want
with that right so we see there was an
air from this function from the
try-catch we could return the air if we
wanted to which we had right here but
yeah so you wrap each one and try
catches the weights so you just treat
these as like regular function calls now
which is really nice the last thing I
want to go over real quick is a pitfall
or not a pitfall but a something to be
worried of you can easily see yourself
doing this let's say I want to call the
API twice it responds well in response
to its cultures box one and I want to
see the gender of both of them so
response get JSON one and oops JSON two
responds to and we don't care about my
async function up there and here JSON
one JSON two dot results zero gender
okay so this is me getting the gender
the first gender of first random call on
the second random call so this is a this
is you know cool I'm doing this in my
async code like this I'm making two
calls I'm doing JSON twice but there's a
small problem with this code these calls
and these calls the all this is
happening asynchronously they're not
asynchronously synchronously so I'm
first finishing this call and I'm
calling this that I'm calling this that
I'm calling this so there's four calls
that are happening when you could
paralyze they're parallel allies these
could run in parallel these two right
here but because we use the await it's
not so it looks like we're you know
doing async code but we're actually
making it synchronous here so the way to
do this and this is the way I usually do
this so you say promise one promise to
then you say Const and I down the D
structure of the array so response one
response to is equal to a weight promise
all p1 p2 cool so it doesn't resolve so
now what happens is I'm fetching both of
these so we fire off both promises so
they're now both running at the same
time and then I'm awaiting right here
the response of both of them right so
these are running in parallel but before
I can call JSON one and JSON two on them
I need them to be resolved so that's why
I'm awaiting all of them so promise that
all you put in an array of all the
promises you want to wait for and you
need to make sure to await all the
promises because this is gonna return a
promise so p1 p2 and this matches up so
p1 the result of it is gonna be the
first item in their ray
so this this returns an array back and
not be structuring they're right here so
p2 is the response here now we can do
the same thing for JSON so this is gonna
be p3 p4 right and we need to make sure
you get the what's a call to D promises
from them not await them here so don't
don't be awaiting and then promise doing
the promise thing and then we have JSON
1 JSON to now you don't probably don't
even need to worry about running these
two in parallel because I'm pretty sure
it's pretty quick operation but there
you go so that's how you could peril or
run them parallel these two and these
two so now you're not just doing now
we're only awaiting twice so I'm gonna
have to synchronous calls here instead
of 4 which is better for performance now
a lot of times this won't make that big
of a deal because your calls are not
taking that much time but if you're
doing a lot of stuff in parallel or
making a lot a sync calls this will help
you out a bunch so keep this in mind
when you're using async and await and
doing
definitely give this a try I highly
recommend using a weight over dot then
personally I use it all the time now and
I really like it
let me know if you guys have any
questions in the comments below that's
all for this video and the code is up on
github if you want to play around with
this yourself
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>