<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Android battery and memory optimizations - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="Android battery and memory optimizations - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Android battery and memory optimizations - Google I/O 2016</b></h2><h5 class="post__date">2016-05-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VC2Hlb22mZM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome and thank you for coming and
first of all I want to thank every one
of you to wait to have waited patiently
outside and in the line I know it's
really hot so thank you for that my name
is Ashish Sharma and I'm the tech lead
of the Volta team inside Android and we
focus on making the battery lives of
Android devices great and I'm joined
with my colleague Megan everyone my name
is Megan Desai I'm a product manager on
the android framework team working on
battery life and memory optimizations so
today we're going to talk about two key
resources on any mobile device that when
running low can severely impact the way
users use their phones battery and
memory you're going to look at some
optimization techniques and some
platform features some api is and by pre
diagnostic tools to take away the pain
from diagnosing battery problems because
we know it's a non-trivial problem
battery life or extended battery life is
one of the top requested features on
mobile devices today the phones in our
pockets are more powerful and more
capable than any time before us and
there are hundreds and thousands of
applications that keep us informed and
entertained throughout the day but if
there is one thing that all of us wish
we had it's a phone whose battery
doesn't last or doesn't die at the end
of the day now how many here in the
audience are worried that their phones
will not last through the end of the day
all right almost everyone and to speak
for the same fact we've seen that on the
Play Store there are hundreds if not
more of battery apps that claim to help
extend battery life of mobile devices
and some with as many as 100 million
downloads or more so clearly it's a
problem that our users face we care
about and we in the volta team in
Android are very passionate about making
it awesome so let's start looking at
where is the power on our mobile phones
go
turns out when the screen is on it
dominates the power consumption on your
phone
more than anything else when you have
your screen on your either playing a
game or watching a video or maybe you're
surfing the internet and screen turns
out to be a very expensive component on
the device which is many orders of
magnitude more in terms of power
consumption than most components on the
device but our phones also spend a lot
of the time in our pockets when their
screens off like right now I hope it is
so when the screen is off and the user
is not actively English or interacting
with the device the power consumption
now starts getting dominated by the CPU
and the networking radios so it might be
an application holding a wakelock to do
some activity or there might be a
background job or a background sync
trying to access the internet to sync
some data in the background and all of
that costs power so when it comes to
optimizing for power when the screen is
off we want you to think about three
main design principles reduce differ and
coalesce any and all background activity
that you can now what do I mean by this
reducing the background activity for an
app when the user is not actively
engaged or is not actively using the
device is something that only
application developers that only you can
do you know the logic of your
applications best you know the
constraints that you're operating in and
you also know what your users want from
the application but it's really really
important that we try and stay away from
that urge from that temptation to push
data onto our devices and keep them
fresh even when the users not actively
using the app all of you raised your
hands when I asked you if you thought
battery was important and our users are
just like us so we really want you to
think about reducing any background
activity that is possible that you can
help for activity that you cannot
completely eliminate and there's going
to be some cases like that we want you
to really think hard about deferring it
until the time when the device is on
char
because moment the device is plugged in
any activity that you do essentially
becomes free and the user does not incur
any battery cost for it and finally we
realize and we know that there is going
to be cases where you cannot get rid of
them completely you cannot
defer them until the device gets on the
charger so for those we want you to
start using the jobscheduler api because
that is an API that lets Android batch
and coalesce a lot of the background
activity not just from your applications
but from other applications as well in
order to make the most efficient use of
the CPU and the background a networking
traffic now this is really important I
want to spend a minute here every time
your device wakes up from suspend or it
activates the mobile radio to do any
networking activity be it for a very
small amount of data packet there is a
fixed cost that needs to get incurred
your device goes into this high-power
state and there's going to be a fixed
overhead every time you wake up the
device there is an access cost now the
more applications can patch together any
of their background activity and
coalesce them the more efficient the
system becomes and power on the device
can be really really reduced now there
are some features in the platform in the
Android operating system that
automatically help you do a lot of this
differ and coalesce in your applications
yeah that's right Ashish let's start by
reviewing a couple of features we
launched with a marshmallow release doze
an app stamp I say you leave your phone
on the nightstand overnight without
plugging it in and you wake up in the
morning in your phone's dead you're
going to have a bad day right but what
those tries to do is coalesce a lot of
that power costly background activity
that I she's just talked about so that
when you do wake up in the morning and
you've left this device unused overnight
it's not draining your battery and you
have some juice left to go on with your
day so let's take a look at how doze
works let's suppose these orange bars
that you're seeing are some kind of
background activity and at some point as
I said you you put this device down at
stationary so it's sitting on your
nightstand
it's on battery it's not plugged in and
the screens off right and the way we
tell that it's stationaries we use a
significant motion detector on the
device so that's required for those and
at some point we realized up the device
actually has been stationary for quite
some time at that point we actually do a
finer motion detection just to make sure
the device is not in a steadily moving
vehicle right we want to make sure that
it's stationary with respect to earth as
the reference point okay if this happens
at that point the first sort of phase of
ghost kicks in and this this so stays
there for an order of tens of minutes at
this point applications lose way clocks
network access and there are no more GPS
or Wi-Fi scans and their jobs and sinks
and alarms get deferred until the next
maintenance window so maintenance window
is where all that background activity
gets coalesce - this is where all these
restrictions are lifted for a brief
period of time for applications - to be
able to perform any kind of pending
background activity to refresh the
content so we're really trying to do is
balance battery life with the
expectation of content freshness that
users have on their devices now the
device continues to be stationary on
battery with the screen off then we can
see this repeated pattern where the dos
windows are growing exponentially with
maintenance windows in between and this
will continue until the the DOS time the
green bars get to about a few hours and
so that's those in the marshmallow
release now we also wanted to improve
the power consumption of applications
that you haven't used or a period of
time and so to optimize that we launched
app standby let's keep going
apps that are unused after some period
of time get considered apps considered
to be on standby so usage in this case
means applications that have had a
foreground service some kind of an
activity or a process they have had a
notification on the lock screen that
you've seen or the app is explicitly
launched by the user and if this hasn't
happened over a period of time then the
application loses network access and
it's jobs and sinks are deferred while
the device is on battery right so
they're deferred - when you plug in the
device but once you plug in the device
if the application is still not used
then it will still be considered standby
and the next time you unplug the device
it will still
and lose network access and it's jobs
and sinks will be deferred to the next
time the device gets plugged in with
Megan so you're saying if I have an
instant messaging app and I don't
receive a message for a long time and it
goes in app standby then I might miss
the incoming instant messages or video
calls because the app is an app standby
no no your your instances are going to
make it through so for that use case we
as part of those an app standby we
launch something called a high priority
Google Cloud messaging message which now
is firebase cloud messaging if you saw
the announcements today so this high
priority message it's a push message
that grants the application temporary
wakelock and network access independent
of the devices go state or if the app
happens to be an app standby and this
allows the application to react to the
message and and put out whatever
immediate notification it needs to put
up to the user whether it's an instant
message or an incoming call normal
firebase Cloud messaging messages during
doze gets patched to the maintenance
windows so for devices that don't have
Google Play services this is where
Google Cloud messaging lives or firebase
Cloud messaging lives for devices that
don't have Google Play services we
actually ship doze and app standby
disabled by default in AOSP
and we instruct our device vendors in
markets where Google Play service is not
available to work with their ecosystems
to identify an alternate cloud push
messaging service so we we don't have
them enable those an app standby unless
they have Google Play services or some
alternate cloud-based push messaging
service so Megan that takes care of my
instant messaging and my video calling
apps but what about the other use case I
often listen to music on my device when
it's just lying at home and the music is
playing off of my Bluetooth speakers
does that mean that when the device goes
indoors my music stops playing no no we
got you covered there as well we're
going to make sure your music keeps
playing Ashish so for that use case we
actually exempt foreground services from
doze and app standby often when you're
playing music music applications rely on
what's called a foreground service this
is this is a service that has to have a
persistent notification and such a
service is going to be exempt from doze
and app standby so even though your
device will enter doze
this service will retain its network
access and wait block access so it can
still playing a shishas music all right
thanks I also said that alarms get
deferred now there are some use cases
where alarms are important part of the
part of what the application needs to do
on behalf of the user so for those kinds
of use cases we launched new alarm api's
that will trigger in a limited way
during doze and then finally for use
cases that cannot be accomplished by by
doze and app standby we have a whitelist
on the system that users can add
applications to that will cause the
application to be exempt from doze and
app standby
applications can also prompt users at
runtime to be added to this whitelist
but this is only for very specific
narrow acceptable use cases that you can
read about on our developer site and
doing so would trigger a Play Store
review before your application gets
published to the Play Store so all this
sounds great Megan the features make a
lot of intuitive sense doors and app
standby for cases when my device is not
being used or when I'm not using my
applications how did we do do we have
any number view I think we have some
numbers oh great so last year when we
announced marshmallow we saw that doze
and app standby combined together can
increase the standby battery life of a
Nexus 9 tablet almost twice and so the
battery life almost doubled there and we
also saw up to 30% average improvement
in the screen off battery life of Nexus
6 devices based on a control group
population of Googlers that we have so
clearly those an app standby are very
important features and and these
principles do seem to work but I'm still
thinking about one thing these cases
make sense when I'm not using my device
or the apps that I'm not using but what
I'm actually walking around with my
device like I am today and I'm actively
using all of the apps on my phone yeah
that's right it turns out that most of
the time our devices aren't stationary
right we we have them in our hands or in
our pockets and we're moving about the
world doing what we need to do so we
wanted to bring the power of those the
the the battery gains of doze to that
situation as well and that's why we're
extending doze in the Android and
release so let's take a look at how
that's going to work again think of
these orange bars as background activity
and at some point you turn the screen
off and you put the phone in your pocket
so it's not being charged right now
well shortly after that and this time on
the order of minutes so shortly after
that the first sir phase of dose kicks
in and now this is a a lighter gentler
doze and what you saw with marshmallow
in that it's only going to restrict the
applications network access and any of
this jobs and sinks will get deferred
when do they get deferred - you might
ask to the next maintenance window so
sort of the familiar maintenance window
and those repeated cycle will ensue
after that so long as the screen
continues to be off and again the idea
here is that we're balancing battery
life with freshness of content and in
the maintenance windows these
restrictions are lifted to allow any
pending activity to resume and all this
will end when the screen comes on or you
plug in the device as you would expect
okay so let's quickly review the dough's
that we just talked about in marshmallow
and figure out how this extended dough's
that I talked about will work with the
dough's that I talked about in
marshmallow so for that we're going to
zoom into this this red box on the
screen okay let's take a look at what
happens so as you would expect the
device is stationary it's on battery and
it's screen off but the amount of time
hasn't passed yet for dough's to trigger
only only a few minutes have passed at
this point this extended doze or this
lighter gentler version of doze will
kick in in the end release and you will
see that same pattern of doze and
maintenance window and at some point the
device realize oh hey the device
actually has been stationary for quite
some time and it's been stationary for
the amount of time required for doze to
kick in and at that point just like it
does in marshmallow the full set of
those restrictions will kick in so at
that point applications again will lose
weight clocks their alarms will get
deferred and there'll be no more GPS or
Wi-Fi scans because the device has been
stationary great so we're very excited
about the battery life gains of this
extended doze but the even better news
for all of you is if you've already
optimized your applications for doze and
app standby you don't need to do too
much more high priority firebase Cloud
messaging messages continue to provide
the application temporary very clock and
network access and foreground services
continue to be exempt from doze and app
standby so we make sure that officious
music keeps playing alright
cool so we've been talking a lot about
background services and their impact on
battery life we're going to switch gears
a little bit and talk about background
services and their impact on memory so
let's say you're trying to do something
on your phone and it's just really slow
and sluggish so you're trying to take a
picture of the camera and you miss that
moment because your phone was just too
slow and you know what I'm talking about
background services have an impact when
the screen is on as well and that's
that's what we're going to focus on next
so again let's say you have an
application you're trying to use that's
the top app here at any given time
there's there's a number of things
happening in the background
lots of lots of stuff happening in the
background services and that when the
device enters a low memory situation or
if it just happens to be a low memory
device what happens is there's not a lot
of enough memory to run all that stuff
in the background while you're the
device while you're trying to use the
device with that thing in the top well
at that point Android is too busy trying
to swap applications in and out of
memory to let them do what they need to
do in the background which applies
pressure on the application you're
actually trying to use and the net
result is that you get this frustrating
slow experience of the device so that's
the problem you're trying to tackle but
background work is pretty important so
let's figure out why background work is
happening
one such trigger for background service
is something called an implicit
broadcast a broadcast is just a signal
that gets sent out on the device
whenever something happens all right
remember something changes and the
implicit type of broadcast is the type
that gets sent to any app or any
application can listen to it versus the
explicit side which would be something
that gets sent to a specific application
what makes this particularly bad is that
often these broadcasts are listened to
the receivers for these broadcasts are
declared in a static way in the in the
applications manifest file what that
means is that the application doesn't
actually have to be running for it to
receive this broadcast and react to it
in fact a broadcast sent in this manner
would cause the applications that are
not even running but listening for it to
be woken up brought into memory and
react to it in some way and while
Android is too busy doing that the
application that you're actually trying
to use starts to be sluggish and slow
take a quick example of this a broadcast
called connectivity change this is a
broadcast that sends quite
get get sent quite frequently on your
device you know any time you switch from
Wi-Fi to cell or back or any kind of
connectivity change happens this
broadcast gets sent it turns out a lot
of applications listen to this broadcast
in a static way by declaring receivers
in the manifest file and so whenever
this broadcast gets sent lots and lots
of applications are woken up to perform
activity in the background and you get a
frustrating experience on your device so
this is the problem we're trying to
solve so what do we do well we could
just get rid of background services and
implicit broadcast in Android all right
it's not that simple because background
background activity is actually pretty
important
so what we're envisioning here is that
applications perform any background
activity using exclusively job scheduler
jobs right and they sort of reduce their
reliance on background services and
statically declared receivers for
implicit broadcasts let's take a quick
look at what I mean right
so what we envision here is that
applications statically declared
implicit broadcast receivers would no
longer get woken up at one time declared
receivers would continue to work
explicit broadcast receivers would
continue to work both declared
statically or at one time but the the
statically declared implicit broadcast
receivers would be the ones that are
specifically affected second for
background services we envision that
apps are no longer running background
services or dependent on that for any
kind of background execution now I set
background execution is important and
for that
we want developers to use job scheduler
jobs now foreground services will still
continue to work so as your music will
still continue to play well thank you
for that Megan but all this sounds
pretty scary these are pretty big
changes are they coming in n do we need
to change all of our apps in time for n
which is very soon it's not coming in n
but you need to change your app soon so
today we're just giving a preview of
what we envision to be the future of
Android where we think Android is going
with respect to background activity we
know that background activity plays a
huge factor in both battery life and the
OD overall performance of the system so
this is sort of where we are going and
and we're planning to launch these when
we think they're going to be ready in
some future release and they'll apply to
the apps that target that release
in the end release we want to give you
tools to start testing your applications
under those conditions and giving us
feedback on as you think about changing
your applications to use jobscheduler
where you can we're also removing a few
broadcasts that we think are
particularly harmful in the system today
and I'll talk about that in just a
second so we have some adb commands you
can use today in the preview and apply
them to your applications start testing
to see what happens how your
applications behave under these
conditions and send us feedback
let us know what implicit broadcasts
that you're currently dependent on in
your manifest files that you can't live
without what kind of background services
use cases you have that you can't move
over to job scheduler jobs ok actually
so think your specific question was
what's actually going to be changing in
the end release so let me talk a little
bit about that first I already talked
about connectivity change as being a
particularly harmful broadcast so that's
one that we're getting rid of so
applications that are targeting the end
release will no longer be woken up as a
result of this broadcast this means that
if you have declared a receiver for this
broadcast in your manifest file that's
no longer going to work if you declare
that runtime as I said runtime receivers
for broadcast will continue to work
because your application is already
running at that point and for other use
cases we want you to use job scheduler
and job scheduler already has Network
trigger semantics the other two are new
picture and new video these are two more
implicit broadcasts that are sent when
right when the user takes a picture and
they're sent by the camera and it'll and
that's sort of the worst time and you
want a lot of other background stuff to
be happening because you want to focus
on taking that next picture or whatever
it is you're doing with your with the
camera application so starting with the
end release all applications will no
longer be able to send or receive these
two broadcasts right so not just those
targeting in all applications and in
fact these broadcasts are actually
pretty important because they unleash
some pretty cool use cases right so one
of them is uploading photos as soon as
you take a photo you want that uploaded
but maybe you can wait right and so for
that we're actually expanding
jobscheduler to be able to be triggered
on content provider changes right so the
the media folder has a content provider
URI that could be the trigger whenever
something updates there
- to upload that photo and the cool
thing about this is that now because
you're using jobscheduler system can
optimize when that action takes place it
doesn't have to happen immediately when
you're trying to take that next picture
it can find the next opportune time to
do it depending on the memory conditions
cool so I've been talking a lot about
job scheduler and how awesome it is but
just a show of hands how many of you
actually heard of job scheduler well
that's a good number but I also see a
lot of the hands that are not up so
maybe it's a good time for us to review
what this really important job scheduler
API really looks like and what the
features are because you made it sound
like very important ok let's do a quick
review of the job scheduler API so that
everyone here is on the same page the
job scheduler API think of it like a
wrapper around any background activity
so any background sink any background
activity that you have job scheduler is
the way to think about scheduling doors
and this is slightly a paradigm shift
where what you're doing is you're
letting Android know that I have some
tasks that need to get done and you
specify certain triggers when Android
will schedule those jobs for you rather
than something that you try and take
care of yourself so let's take a couple
of examples these triggers when you
request Android 2 to schedule your job
could be based on a certain time window
so say you have a job that's important
not exactly urgent it doesn't need to
happen right away you can tell Android
that schedule this job anytime within
the next 1 hour and what Android would
do is once many applications are using
the job scheduler API it now has this
context about all the background
activity from the different apps that
needs to happen and it's going to do a
good job at scheduling your job at write
the write at just the right time so that
the the efficiency of the CPU and the
networking radios can be maximized now
what you can also do is specify triggers
based on network connectivity or the
type of network that becomes available
so say for example an application that's
uploading a whole bunch of photos or
videos
that you might have on your phone now
it's a really good idea for such an app
to schedule or to specify a trigger for
a Wi-Fi network because what that's
going to do is Wi-Fi typically has more
bandwidth and it's less expensive in
terms of money and it costs power also
less power than the cellular radio so
that it can be a constraint or a trigger
that you can specify and finally the
thing which which is my favorite which
comes back to the whole deferring until
the devices on charger you can specify
that control to so you can tell that
here's a job that I want to done want to
get done and trigger it when the device
is charging but not just that because
that you know every time you plug in the
device may not be the best time for all
of the background jobs to start firing
up say for example I saw some power
outlets outside you've been here since
morning your phones are running low and
you find that power outlet and you plug
in your device to get maybe five minutes
of charge and right then if all of the
photos and videos that you took today
start getting uploaded to the cloud
that's going to be a not so pleasant
experience for you because your device
might get slow but also you might not
get enough charge out of the outlet
because you're spending all of that
energy so what you can do is you can see
the device should be charging and should
be relatively unused now androids smart
enough to figure out when you're not
actively engaged or interacting with
your device so it'll wait a little while
make sure that this is a nice time to
schedule all of those background jobs
and it will trigger your job right then
so we've seen that the job scheduler API
is really important and it will help you
optimize differ and coalesce your
background activity not just based on
battery constraints or connectivity
conditions but also in terms of memory
so let's take a look at a quick example
of how the job scheduler API works and
how easy it is in a few lines of code to
get your jobs done I'm showing you a job
info object let's create an object using
a builder we can specify a required
network capability to be that of network
type unmetered now what that typically
it translates to is a network that
doesn't cost the user money and most
Wi-Fi networks fall into that category
so so anyway you're specifying the Wi-Fi
connectivity here what you're doing then
is say I want my job or my app to sync
up with my cloud back-end server every
24 hours it doesn't have to be by the
hour but once every day is fine for me
so what I'm going to do is set a
periodicity of 24 hours and here comes
the favorite part which is you do this
when the device is on charger so you
specify the set requires charging
constraint and those four lines you can
schedule a job and it's done now Meaghan
also talked about something very
interesting and an extension to the job
scheduler API that we're introducing in
N and that is to take into account the
memory conditions or the RAM conditions
on your device so now job scheduler also
supports triggers based on content
provider updates so the example that
Megan gave was if you're trying to take
a picture or that selfie or of your kid
and if that at that moment you've just
taken a picture and you want to click
another shot and if your phone gets
slowed then that may not be a good time
for you to start uploading your pictures
and what you can do is now you can tell
job scheduler that I'm listening for
this content provider update when a new
picture appears but there's a little bit
of wiggle room there it doesn't have to
start right at the very second when the
picture was taken and the jobscheduler
api is intelligent enough to prioritize
all of the jobs for the for the
processes or for the application that is
in the foreground or that is running
foreground service to account for the
fact that if you're interacting with an
app all of the jobs for that particular
app should get priority and automatic a
priority or all of the other jobs that
may not be as time critical and finally
job scheduler is aware of the available
RAM on your device so depending on how
much RAM is available it might choose to
schedule more than one jobs at the time
or if the memory conditions are not
ideal or if you're running low on
on memory then only a few jobs or the
top priority jobs will get scheduled
first before all of the other ones get
precedence so these changes are
interesting let's take a look at a quick
code sample of how you're going to use
the job scheduler API for something like
a new picture content provider update
you setup your jobs get you you get an
instance of your job scheduler service
you create a builder object and you
specify now instead of in the last
example where we had specified
constraints on the network type and the
periodicity what we add here is a
trigger for a Content URI update for a
new picture and you can schedule your
job and that's it you're done so this is
all good job scheduler API was
introduced in lollipop which was API 21
we also have and have had for awhile a
backward compatibility library which is
which lets you do almost all of those
same things that I talked about on
devices that may be running a previous
version of Android or an earlier version
of Android and that is Google GCM
network manager with this light doesn't
say GCM network manager oh my gosh right
it's actually firebase job dispatcher so
today as part of the firebase
announcements we're launching firebase
job dispatcher which was formerly known
as GCM network manager the cool thing
about firebase job dispatcher though is
that it's an open source sdk that is
effectively providing the same
capabilities that job scheduler does in
the platform but in a backwards
compatible way and it's a it's a wrapper
again for background activity it's
available not only on Android but coming
soon also on iOS in it on Android free
lollipop to Google Play services will
act that's as the central scheduling
driver on lollipop and onwards where job
schedule is available it will just use
job scheduler and then on iOS it will
use Grand Central Dispatch so that's
pretty cool let's take a quick example
of what job dispatcher looks like when
you're performing background activity so
this is a quick example of creating a
simple job service that encapsulates a
code you need to perform in the
background right this is the whatever it
is your application needs to do in the
background you put in that do
function and then again very simple
create a job using the the job builder
from the dispatcher give it the the
service that you just created that's
wrapping around all the activity and
then in this case I'm just giving it a
constraint that I wanted to happen on an
unneeded network and then that's it and
schedule so pretty simple very easy to
use to perform any kind of background
activity so so as we've been talking a
lot about very cool from platform
features a lot of API is that we have
introduced and they sound like they're
gonna have a huge impact but how can we
be sure that they're going to make any
difference that's right Megan it's not
an easy problem something that I've
personally suffered with or or struggled
with for a while and that is how do you
really make sure that your app is
behaving the way that you intend it to
be when it comes to all of these battery
optimizations or worse what if your app
is draining more battery than you think
it should how do you diagnose that so
let me take a quick poll how many of you
have tried diagnosing battery problems
on your applications okay but um now for
the others who did not raise their hands
was that because you find found it too
hard to diagnose battery problems
because I've been in that you know in
that same place well you can be honest
but so diagnosing of battery problems
can be really tricky and I've felt that
pain and good thing we have a tool and
we have some logs on the device that can
help us do that in an easier fashion and
not have to struggle through all of the
pain let's look at some of the logs or
the types of logs that are present on
the device now Android maintains our
data structure in memory on all devices
and these this log is called battery
stats
now what battery stats is is it is a set
of cumulative counters that go on
incrementing while your device is on
battery so since it's in memory and
these are cumulative counters that go on
increasing they need to get reset at
some point and that point is when you
fully charge your device and you just
unplugged it so say for example you
charge your device overnight
and you unplugged it at 7 a.m. in the
morning and maybe it's about 10 and a
half hours since then if you take a bug
report on your device now then it would
contain the whole ten and a half hours
worth of battery stats and counters
about various things happening on your
device that we think are relevant with
respect to battery life so things like
how long was the partial way clock held
on the device across all applications
and on an application basis or how much
data was transferred over the mobile
network or the Wi-Fi network and what
you can see here is there's also a start
clock time which tells you exactly when
the stats were reset so this is really
useful when you're trying to look at
what all happened on your device that
may have caused the battery to drain
faster than what you would expect the
other type of lock that is present on
the device is something that we call
battery history and what this is it is
an event log of all of the state
transitions for components on your
device or for actions like scheduling a
wakelock or an application scheduling a
job or the device going into suspend
coming out of suspend or maybe it's the
network radio that what turned on so
there's a lot of information here and
this would contain an event log of a
millisecond level granularity of
everything that happened on your device
since the stats what we said wait
millisecond level granularity you're
telling me that that I have to look at
this to figure out what's going on with
the battery life on my device it's going
to be hundreds of thousands of lines of
this well but it's very obvious you can
just make out what the problem is oh
yeah I know I'm just curious we have a
tool that helps us make sense of this
entire thing and that's called battery
historian many of you might be aware of
this and what this tool would do is it
would take all of those logs that are
present the two logs that I just
mentioned that are present in the bug
report and it would help you look at
them in a very intuitive and interactive
UI that makes clear what the problem is
on the device so Megan what that's
that's pretty cool I like this I like
this a lot so where do I see this oh is
this on my device and setting somewhere
now I know you have a very cool and
powerful device but going to
through these hundreds of thousands of
transitions on your small little screen
may not be a very pleasant experience
especially when you're trying to
diagnose battery problems with your apps
so what this is is let me walk you
through the workflow of how this Tool
Works it is an open source tool
available on github ready for you to
download and you can look at the source
code modify it any which way you want
what you do is you install it on your
computer now you have your development
device on which you for the stats to be
reset because you want to have a good
starting point you can either charge the
device up to 100% when the stats would
get reset or there is an ADB command to
actually manually reset the start so you
have a good initiation point you can run
your experiment which might last a few
minutes or maybe a couple of hours and
at the end of it you take a bug report
and then you upload that bug report on
your computer where you have the battery
storing tool to go back to this
interactive visual interpretation of all
the state transitions oh so now that you
are clear on how the workflow works for
battery installing I'd like you to come
with me on a slight tour of how what are
the features of this tool let's zoom in
to one of the rows or a few of these
rows what you're seeing is the top line
which is CPU running and what this
indicates is indicates is whether your
device was in suspend or was it out of
suspense so the solid black bars are
when your device was actually out of
suspend and doing some activity
similarly you can see things like when
was a user space wakelock health or when
the screen was the oil and the
information about any of your jobs or
sinks will also appear here and in this
UI you can zoom in to every little event
that you see no matter how long and if
you take your cursor over that it'll
show you a nice tooltip so say for
example we're at this point in the UI
we've zoomed in and it tells me exactly
what the current time was at this
instance and the red highlighted portion
now shows you the battery level drop
from 73 to 72 and how long it take it
took for the device to discharge from 73
to 72
giving you an indication of what the
average discharge rate was during that
time and you can see all of the events
lined up nicely so you can actually
figure out when your device was
discharging rather fast what were the
events that were happening on the device
let me take you through another example
so say you have adopted or migrated your
app to you start using jobscheduler now
how do you figure out whether when your
jobs are getting scheduled so in the
jobscheduler row you go on any one of
those events and if you're in a zoomed
out view it might collapse a bunch of
these little jobs that didn't last as
long but it will give you information
about how many jobs were run in that
particular small box and for how long
each of those jobs ran and you can zoom
in if you like so these it's a very
interactive and fun tool I have a lot of
fun playing with it and diagnosing all
the battery problems what I want you to
do is look at an example of doles in
action so we've been talking about the
doors mode in marshmallow that was
introduced and the more deeper the
lighter version of doors that was
introduced in the end release so what
I'm showing you here is a bug report
that I uploaded to the battery store in
tool and the black line that you see
going down that's not exactly horizontal
that's your instantaneous battery level
so typically it would start off with
something high if you've started with a
hundred percent in this case I manually
reset the stats so it starts somewhere
around fifty percent and then what you
can't see is let's zoom into this little
area when your screen was on you can see
that the frequency of your jobs and
things was fairly high all of the jobs
and and sinks were getting scheduled
fairly periodically but then after when
after the screen has been turned off for
a while what you see in the doors line
or the doors row in orange that's the
lighter version of doors kicking in so
some applications would lose network
access and you start to see that now
your jobs and your sinks are beginning
to get less and less
frequent and they're getting batched
together and fertile out after the
device has had its screen off for a
while and it has been stationary you see
the device entering this deeper doze
mode which is shown in the blue row here
and when that happens now we know that
the device is not being touched by the
user is not being used and that's an
opportunity for the jobscheduler api to
start throttling and and batching
together a lot of the activities so you
see that under the blue bar the job
scheduler and the sync manager frequency
is fairly infrequent and and they get
scheduled at you know during the
maintenance windows now what's really
interesting is and this slide will help
you get a perspective on what uses the
most power on your phones initially when
the screen was on my battery level was
discharging it really fast so you see
the slope of the line
that's my battery level going from 50 to
maybe 30 very quickly and after the
screen has been turned off and the doors
mode has kicked in that's when you start
to see that now my battery is not
declining as fast and it might have even
lasted me a couple of hours in that
state without discharging a whole lot of
battery and then towards the end as soon
as the screen is turned off or turned
back on we see that the device exited
the doors mode and you go back to that
steep discharge of when I'm actually
playing a game or watching a video
that's that's pretty cool issue so so
all that stuff we were talking about
coalescing and deferring background
activity during doze it actually works
that is living proof that's pretty cool
okay so the next thing I want to show
you is I talked about these accumulated
stats so the same tool what it would
help you do is once you've uploaded a
bug report it will now show you all of
this information that was collected on
the device so which jobs were run for
how long they were run which application
acquired wakelocks and for how long they
did and in general for the entire device
there's a whole bunch of information
here such as the mobile radio activity
which application used the most amount
of mobile traffic or Wi-Fi number of
Wi-Fi scans and it helps you get a good
overview in in a very quick fashion on
what
exactly happened with your eyes so hold
on so this is all been pretty cool but I
thought you said that this was going to
help me figure out issues with my
application yes
can I do that with this yes Megan that
leads me to my very next slide well
which is there is an app selection bar
there so you can actually search for
your app and pick your app and the
moment you've done that you get taken to
this app stats view which tells you all
of these same information just for your
app so you can look at all the jobs that
got fired what whole processes you were
running how much mobile data or Wi-Fi
data sensors all the good stuff just
there for your app and the very cool
thing that I don't have it here in the
slides is once you've picked your
application if you go back and look to
the UI of the time line of events you
will see that in the job the job row or
the job scheduler row or is the syncro
only the jobs and things for your
applications will appear and all else
will disappear so that can really get
you a visibility into how frequently
your application was scheduling all of
these tasks so we found this tool to be
very useful but there is one case that
has been especially painful for me and
that is when you are developing in the
app or see you made a change in your app
and suddenly your device is discharging
very fast now I write perfect code I
never make mistakes but then my device
is discharging fast what did I do and
and in this position more than I would
like to admit I'm sure a lot of us have
been in this situation for one or the
other time and so for that what we have
is an Eevee comparison mode in the same
tone so what you can do is you can
upload to bug reports and if you have a
good case and you have a bad case then
what the tool will let you do is it will
highlight all the biggest differences
that it sees between these two bug
reports so say for example it's
comparing now file one versus file two
and it's telling me that in file one it
has used 7.5 times more Wi-Fi data than
the other and the screen of discharge
rate on let's say the first one was less
than 2.5 times and a whole
lot of other good stuff I haven't shown
you all of the detail but if you upload
to bug reports it will automatically
normalize those two bug reports so see
if you have one bug report that was
taken for four hours and the other that
was at 2:00 it would automatically you
know normalize all of that and show you
a good comparison which can give you a
very good starting point as to what
actually changed on the device whether
it was really my app or some other app
started doing something that may have
accounted for this difference so that's
an interesting mode and to wrap up I'd
like you to look at one last feature on
this on this tool which is my personal
favorite and this is for the true geeks
out there so if you have a phone and if
you were able to modify your phone to
connect it to a power monitor and say
you were recording the instantaneous
current values when the device was
actually running what you can do is you
can upload a bug report and you can
applaud these power readings these
instantaneous current values to the
battery historian tool and it will show
you a nice overlay of what your
instantaneous current draw was and what
the device was actually doing at the
time so here you know this is where for
me at least all of it comes together
so you see when the CPU was running
indicated in the black bar in the top
row that's when your instantaneous
current draw was close to one hundred
eight hundred milli amperes but when the
device was in suspend it was hardly
anything you can't even see it there
because it's close to about four to five
milliamps so there's several orders of
magnitude you know difference in the
amount of power that's discharged from
your phone when you're actively doing
stuff and when you do this when you use
the jobscheduler api and start batching
together a lot of the activity well it's
not hard to see that your phone will now
lost will now last much longer and
really take away the pain from having a
device that doesn't last as long that is
that really cool Ashish I'd love to have
an ammeter to look at what's going on on
my phone yeah there are detailed
instructions of this on the github
website on how to actually hook it up so
try it out if you like cool so what's
next well you saw how these simple
design
suppose that if she's talked about
reduced different coalesce go a long way
in improving battery life and
performance of the device so here's what
we want you to do we want you to reduce
all the background activity in your
applications what you can't reduce defer
it to when the device is charging and
what you can't defer to when the device
is charging at least help us coalesce it
with other activity that's going on in
the background so go out there and
figure out how to use job scheduler and
job dispatcher instead of using
background services we actually have a
code lab up for you to walk you through
some key use cases around migrating from
services to job scheduler check out
battery historian as a huge mentioned we
also want you to start removing your
dependencies in your applications on
statically declared implicit broadcast
receivers as well as on any background
services again and send us any feedback
as you as you're doing that on where
you're unable to do that using job
scheduler or job dispatcher I would love
to hear from you we want to get there
together
so with that if you have any questions
you can join us at office hours right
after this at 6 o'clock in on stage 9 as
well as tomorrow and Friday thank you so
much for being here this late thank you
for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>