<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>2012-09-25 Android Developer Lab+ - NDK | Coder Coacher - Coaching Coders</title><meta content="2012-09-25 Android Developer Lab+ - NDK - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>2012-09-25 Android Developer Lab+ - NDK</b></h2><h5 class="post__date">2012-09-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JEv54Esnbhc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone welcome to another Android
developer lab plus we're in a different
day of the week today where it's
obviously not a Thursday unless of
course you're watching on YouTube in
which case it might be you might be in
the future anyway so welcome we are
actually coming to you today from
actually I'll let Tony introduce him
himself all right
hi everyone I'm Tony so enter an ID
today are very hong kong cool i'm have
joining from hyderabad and i'm the world
lonely what here I guess anyway so
thanks for joining us I'm Ankur Kotwal
normally here normally from the Sydney
office but I'm glad to be here with Tony
for once so today's topic of the week is
actually the native development kit and
we have our resident expert onion
who's going to present that twist so
take it away on your right thanks uncle
let me share my slides okay can you guys
see the slides yeah alright so so the
topic for today is and again we're gonna
I'm gonna introduce to you what is NDK
and I'm sorry to disturb you we are we
can see keynote we don't see the the
presentation itself you'll I think you
might have screen Ching at only keynote
you need to screen share your desktop in
order for the actual presentation to
sure okay I'm gonna do it another good
all right
so whilst Anya does that then DK is
obviously an alternative to using
eclipse in doing Java programming and
well I don't want to steal any thunder
so go ahead on your it
alright so everything's fine now yeah
all right thanks
so first what is indicates the native
development kit which basically means it
allows you to write native build and
publish native applications build and
deploy which I should say since add it's
actually a tool set collection of tools
which includes cross to change like the
compiler linker and build system for
native libraries which you use to write
your C C++ code putting them against the
libraries available as part of the
system ABI with finally interface as
well as your libraries and include them
as part of the Android build system so
that they get packaged into your apks
and we also have a build system which
uses android dot m'kay the Android make
files and this is what you use to build
your native libraries then like I
mentioned there are packaging tools
available so that when you actually add
a native library to your project which
also contains Java code and Android
manifest and other activities it allows
you to bundle your native libraries
along with your apk so that you can
deploy them to the Play Store and the
the part that I mentioned about ABI
which is the binary interface or the
headers these are basically the headers
available from the CC splash those
headers and average is available from
the android framework to you to code
against and there are a lot of things
about these libraries that you should
know and we're gonna look at some the
basic architecture of how all these
components are deployed so you better
understand what these libraries are and
why these are the only libraries you
should use so before we begin looking
into the libraries and architecture I
want to cover what NDK is not and this
is very important there are some people
the bosses question says ndk replacement
for SDK or can I can I just write my
code in C C++ because I'm better at it
so NDK is not a replacement for SDK SDK
is always and will be the primary choice
of development platform for Android and
it offers you tons of liabilities
through the dalvik and this this the SDK
is the primary platform for development
indicates only targeted for special
cases and we're going to discuss what
those cases are indica is not the
solution for performance issues so if
you have performance issues in your app
do not think that if I use C C++ code
with NDK my app is going to be faster
for most applications NDK will not make
a difference and dalvik is actually very
much very optimized and has and provides
you with all the memory card which
collection stuff which you will have to
do manually when writing native code so
it's not always a solution for
performance issues it's not meant for
typical applications so if you have a
regular UI ListView kind of application
where you're pulling data from internet
and storing them on datastore and
showing them on you I am letting user
interact these are your typical
applications and any case not meant for
those and it's also not an alternative
program programming language option
which means like you cannot choose NDK
just because they're comfortable it's C
C++ which you have to be comfortable if
you choose NDK for specific needs of
your project because all the code is
written in C and C++ and with gen I do
wrapper so now when to use NDK so if you
have a lot of libraries that you've
written as part of your projects or open
source libraries that you would like to
use we use these native libraries you
should use NDK so while you can still
write your application code in Java you
can actually include these libraries and
make those j'ni calls across from darwin
to the native to the native world and in
that sense use these libraries that you
already have also if you're writing
something that is computationally
intensive for example a lot of math is
involved you should use you can look at
the option of using NDK because with NDK
you can
leverage some of the CPU specific
extensions for performance like the
vector floating-point instructions and
jnanam instructions and these these
these are really fast routines that you
can access directly from NDK so this may
be a case where you can look to use
indicate if if you feel that's that last
bit of performance you need to squeeze
out from from the platform so we're
gonna look at some of the supported
platforms right now so we support the
our v5 instruction set I'll be seven
with the hardware floating-point unit
come to in your instructions then we
also support x86 architecture and MIPS
so what this means is basically you can
use MDK to build libraries for shared
objects for these platforms only so your
code has to run on one of these
platforms because the file is generated
and kept in a folder and all these
specific platforms are used are
available to you right now to generate
those five babies so let's let's look
and look at an architectural overview of
where what NDK and what will the
different components sit in the system
so if you're a Java developer or you've
you've actually used Java SDK before you
can see there is a Linux kernel there
and then we have a runtime the talvik vm
and then you have all these framework
classes and ap eyes and stuff available
to you that's print on top of the
runtime and these are the activity
managers the Empire and android
framework that's available in the SDK
and then you write your applications on
top of this so the runtime is talking to
the curl using j'ni which is Java native
interface so you can call c c + + native
code from Java Runtime but so what
happens is that - there are some system
that really sitting up on top of Linux
kernel and that's where and when I
mentioned about a certain set of headers
and library is available to you as an
NDK programmer the reason why that is so
because what a lot of the system
libraries that we have that are running
on top of the Kerner these are not very
stable and there's no reason for them to
be stable
he changed them across versions as we
see fit and we cannot really guarantee a
stable interface over top of this
because this is something that only
Android uses and it's meant for on the
android framework and runtime so while
we release different versions we can
make sure our runtime attached to these
changes in the system that released but
that's not something you'd like to tell
you with your absence then if you have a
new new release of the framework on you
API has tickety's your apps will start
breaking if you're using any of those
system liabilities that have changed
over the word so what we try to do is
provide your stable ABI the application
binary interface and this is a set of
headers and libraries that are available
to you to code again so we make sure
that these are stable these remain the
same over different versions of NDK so
you can always rely on kind of its kind
of guarantee that they will work across
and then the box that you see that says
library these are your libraries the
libraries that you write on top of these
stable api's and then again you can use
gri wrapper and your applications can
have java code that can directly talk to
these your libraries that are talking to
stable ABI is using j'ni so this is an
alternative code execution environment
but that basically is what NDK provides
so some of the headers that are
available to you and um I guess this is
pretty much all the headers available to
you and this is what you should be using
so the first one is Lipsy I think I have
a mistake they're saying lip it's a lip
see the standard c library and there's a
live map the lib compression every Lib
block is the android log system if you
want to interact with that the lib dl
dynamic linking library and then we have
graphics related libraries like OpenGL
ES 1.1 two points your spec libraries
and Gianna graphics that can talk
directly to your 2d rendering system
like bitmaps and stuff and also to the
opengl stuff so these are the libraries
available to you and recently with
Gingerbread
well not so recently which interbred we
added support for more libraries and
basically cater to the needs of Kym
developers and so there is OpenGL ES re
available to you Leslie GL available to
you and also
standard C++ libraries available T so
these these are the only headers or
libraries you should use in your program
from the system and not rely on any
other any other system libraries
available because they may not remain
the same so it's very important to note
that if you want to support your
application across versions just stick
to the set of libraries so oh how do you
write a simple app so in terms of
project structure is pretty much the
same when you create a project and you
can do that by using either Android
create project script is available or
use eclipse to create a project and you
have a folder called gni that's its
parallel to your source and to your lips
folder this J&amp;amp;I folder is actually where
you could all be NDK coffee or your
native code so you write your C C++
library source files and these may
actually be another like under project
that you know that you have and you can
displace that all that C C++ gone inside
this GRI folder and then you write a
build file and write dot mk5 and the
syntax is pretty easy and it's very
flexible so this is what you need to do
to bring your NDK code to strike the
Android MK file in this while you
basically describe when are your source
files for the source files you need to
build what are the libraries these
source files should link the case and
the output of the library so and this is
per module so if in your project you're
going to have more than a couple of
modules or native libraries that we are
building you will have an Android dot MK
file for each of those and and then on
top of that you'll have an application
dot M K which is basically error
something that is going to delegate the
module building to each of these Android
MK files so use the Android the the
application at MK f I have to build all
of these Android and K files
optionally you can use Java edge or
eclipse
tools ID tools to generate C headers
from Java files so if you are and with
Gingerbread we introduced something for
native activity and we get over there
but before that if you are writing code
for older platform
what we want to do is in your Java in
your new Java classes you may have in
your Java code your application code you
may have some methods implemented there
and some is some methods are something
that you want we use the native platform
for so you're gonna prefix the keyword
native in front of those methods in Java
and then you can use Java edge to
generate the headers for these java
files which which which actually
generates a j'ni group code and which
you can use to do interrupted Queen Java
and the dalvik at the native world so
once you do this step then this is
optional depending on your use case you
would run the NDK build script which is
available and this is the entire tool
general vailable to you so you would run
this ND kept
phil's to generate the native shared
object or library and in your java code
you can load this library by saying
system that load library native process
or whatever the name for your module is
and indicate build is part of the NDK or
the NBA at the entire NDK platform which
is available for you to download and
it's platform specific so this is
something you can go and download from
developers.google.com just along with
the sdk you can find the empty connects
today so once you've generated the
shared object libraries and system nor
no library you will make these libraries
available to you
you know dynamically against the the
running application so with with
Gingerbread we we introduced something
called native activity so that the
before Gingerbread you would always need
to have some java code in your
application and some specific methods
implemented in native code so you would
like I said you would put the native
prefix in front of those methods so you
would say try with native and you know
do this something and faster on others
so with Gingerbread
you can actually write Java LS classes
and you can stay my ant activity is a
native activity so you don't have to
write any application for and this is
some sort of useful for game developers
and something so if you are a game
developer and you have your all your
input and your UI and everything in
native code you really know
mien and Java interface to it so what
you do is write a native activity so
like I mentioned it implements a
complete activity in native code so
we'll just look at the manifest of how
you declare a native activity so if you
see in this in this slide there is
activity by the name of Android app dot
native activity and this is the activity
pack which has a element called metadata
which specifies the name of a library
and this is the native memory we are
going to be using and the value is the
activity name the native activity
available so this will actually make
sure that your activity this will tell
the the Android runtime that you have
activity that there is no Java cross for
this activity there is no the entire
activity is implemented natively and if
your application is completely Java Ness
you would see that in the application
path we have something called adroit or
hash code false which means that there
is no Java code and all the all the
components inside this apk are knitted
so the entry point for a native activity
if you're writing in native app activity
completely Java less the entry point is
Android main so in your CC dash first
for you should have this entry point and
this is where the this is where your
where the runtime starts interacting
with your application or passing you
this state and this is kind of similar
to the Android activity style this is
implemented as part of Android native
group library and this is something you
will have to link against when you are
building your native code so when I
mentioned Android entia files where you
define your dependencies in the
libraries you would have also have to
include this library there so ok before
we discuss tools and IDs there are some
important performance considerations
with the NDK so when you are actually if
the first thing is the threads that are
created in your app
gays are tied to the process so
sometimes your activity may stop or make
pause and but your thread and your
process is still alight that's actually
hosting these activities that's your
application which sponsored dalvik VM so
this this process may still be alive
so because the process may be alive if
you're using threads in your NDK code
your threads will also continue running
so it's something important you should
know when you're writing your
application although although the
activity may be out of the screen or may
have been passed because something some
dialog popped up in front but your
threads will still be done in so at
times you want to choose which threads
you should stop at that point of time or
which threads you should keep running so
if you're doing some kind of sound maybe
something you want to stop there right
there because once your activities stop
your past if you don't want to hear any
sounds on your application but there are
other things that you may need to keep
running so that's an important
consideration in writing NDK code native
code the the other thing is because the
process is only brought alive once there
may be some static initializers in your
code and they will only get in each
slice once so the activity stops and
then again resumes these static
initializers will not be loaded again so
you may want to avoid these static
instances and take care of initializing
these variables yourself
so as an indicate developer and also
there are other performance
considerations and tools and stuff
available for you because it can get
tricky and it's not easy to manage
memory when you're writing the memory
handling routines yourself so you need
to be extra careful so what we have is
as part of tools and IDs we have the ADT
20 release now suppose NDK building and
debugging directly from using the ADT
plugin and this is this actually uses a
multi-threaded
gdb so you gonna have to write all the
code inside main thread to be able to
keep out that there's a link to that
tools or android.com slash we send slash
using the NDK plugin and this is where
you can see notes about the support and
how to configure it there are also
plugins available exits plugins
available from Nvidia that
performance and memory analysis for your
application
we announce we also support the indicate
GDP which is the genie debugger that you
can use anything use any GDP so this
actually starts a GDP server on your
device and then uses the name right to
talk to your machine that you are
debugging it from so these are some of
the tools available the lot more
available from community there are there
are developers who have come up with
complete project generation kids and and
some of the companies like n media has
come up with advanced memory analysis
tools and stuff so this is some of this
things you can explore and you should
always use this you should always debug
your applications using Gingerbread
because you can debug a native activity
you find out new polls why not when we
need some fix them so yeah that brings
us to the end of the presentation we
will now move on to Q&amp;amp;A uncle do you
want to take that up yeah thanks honey
so we have an unholy live yeah
humor will yeah we can hear you do you
have any questions that you wanted to
ask us yeah actually
just hang out I'm attending to and I was
not aware of but in the key is actually
right now in one of my projects I'm so
the good question is you said that there
are some header files which provide to
indicate developers what about a speed
something related to more language I
would say are they stable or I know that
there are three alternatives no not
three but two is still poor and misstate
which we can use in our projects but are
they stable or not because it didn't
mention them in the list of the
available feathers the libraries that
are mentioned in the list of available
headers is avianna stable ones and kind
of guaranteed to work across which
releases so these are the ones whose
expected
as for the mandroid finger big concern
for the Android system I really set this
concern and you can always have your
third funny I'd release there but from
the system that perspective the ones in
the list arrived and then you can always
find the updated list on the developer
or food in fact on ending the ending
infection you have a list of libraries
there and you should always stick with
it but the further the know some if the
libraries are shipped with indicate but
they are not stable right and you're
just before you answer the next question
we can't see you actually it's your
screen shares to on there you go thank
you thanks
I'm sorry you said some librarians I
think I didn't capture which like this
some yeah yeah I mean that steel is the
part of in de la gente yeah and but but
but it is not listed in the stable
libraries so they ship together but they
are not still stable
right there are some chick subject to
change I think there's there's an issue
with the blue string that we had I can
check and get back to you whether we
want to call it stable and make it
available and you you want to call it
stable officially said anything go ahead
and use I know it's available as far out
the NDK
maybe I'll get back on this teach was
thread of this file and post care also
that okay and just a second question
regarding native activity it mentions
that I'm developing some application
where I'm going to have audio and video
streaming for example primary tablets
and for example in one part of the
screen I'm going to have for example
some video frame and all so far as I'm
going to have some chat and of course
all the conversation will native
activity benefit me somehow because as I
see it now I will tell I was planning to
use I would say a flat place in Java
activity with some you know framing with
video output and for example but my
audio video compression code already is
a part of intiki library which I'm
shipping with my application so do I
have any benefit and if I will stick to
native activity will it benefit me in
the performance of this house a video
showing video output can you comment
right so if you are using any of those
specific instructions
the neon instruction set etc for your
compression routines and stuff you may
have some Bennett's benefits in
performance there but otherwise largely
as far as a model as far as rendering
and stuff is concerned on the screen
there is we wouldn't say that there is
any benefit in using let me pay for that
stuff so yeah it's really up to the
compression and all that routines was
computationally extensible for intensive
routines and if you want to take some
benefit there using the instruction set
extensions to have fun okay thank you so
far I got no more questions
uncle retrack jr. well that's
embarrassing I was talking for a good 30
seconds then but in terms of moderator
we have one question on there which
basically says how do I send search
terms to the Google Search app built
into Android I mean the answer to this
is typically what you do is you just
call a URL like doing normal Google
search and you will actually not go
through the Google Search app it'll
it'll basically fire up your browser and
you'll get search results through
through the web page that the mobile
site so I guess my follow-up question to
this would be is there anything
particular that you that you were after
in in that built in Google Search app
because in general that Google Search
app is basically all the businesses a
user interface for doing searches on
generally being we've we added Google
now which actually handles some Google
searches there and presents some
slightly but if you do the same search
through your mobile browser you do get
the same knowledge cards and you know
the usual results and that they're kind
of formatted to match your screen size
and it goes through the browser so the
browser is there you don't go directly
into the Google Search app so in terms
of your results it should be the same
but I'll be interested to know what else
you might be after why specifically you
want the integration with the Google
Search app itself so JJ from Cambridge
if if you if you're able to respond back
in you know a future moderator that
would be great just let us know I mean
to see if there are anything if there's
anything else from the straightaway
we've got the hangout running and there
isn't so with that I guess the
nothing more for today thanks I need for
presentation NDK I'm sure you'll get
quite a few questions from developers
levy it's a fairly common and popular
topic about coding on using C++ on for
Android so thanks very much and yeah
we'll be back next week and next week
we'll be back to our regularly scheduled
about a time which is on Thursdays so
yeah thanks for joining us and we'll see
you next week yeah looking forward bye
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>