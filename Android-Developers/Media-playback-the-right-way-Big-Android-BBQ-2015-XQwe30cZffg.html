<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Media playback the right way (Big Android BBQ 2015) | Coder Coacher - Coaching Coders</title><meta content="Media playback the right way (Big Android BBQ 2015) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Media playback the right way (Big Android BBQ 2015)</b></h2><h5 class="post__date">2015-10-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XQwe30cZffg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we're here to talk about media playback
the right way so we're really gonna kind
of go through all of the different
components and district different system
things that you need to actually
integrate with if you really want a
top-of-the-line media playback so a
little bit about me I've been doing
Android development for just about five
years now
started kind of on my own in my spare
time got caught up in part of my
master's degree and then transitioned to
doing a full time first at a fun where
and then at Facebook I'm sorry I didn't
fix everything I wanted to and then
there's there's a lot more I wanted to
fix but this last year I've been working
as a developer advocate at Google so
talking to the community and kind of
bringing a lot of your feedback back to
the engineering teams as well I've been
working on two major projects since then
we did an advanced Android class for
Udacity so kind of online learning kind
of going a little bit deeper into a
parka texture and then as well then just
recently launched Android development
patterns a video series as well as pro
tips around kind of all of the things
that really are the best practices for
Android development and my focus has
generally been on the android framework
and the android support library which
both which play very nicely into this
now when we talk about media playback
there's actually like tons of levels and
many things we could talk about here and
we're really gonna talk about just one
part specifically audio playback now
it's important to note that if you're
doing video playback almost all this
still applies to you right the
interactions with the system and that
type of stuff still matter if you're
doing video but video is a little bit of
a head start on us the actual cast
companion library it's out something our
team actually supports and keeps up to
date but it in capsule
a lot of the best practices around video
and integrating with things like Google
cast as well so you kind of get that
full multi-room experience so let's
let's start at the beginning and the
beginning should always be with the user
right they're kind of the most important
part in actually making our apps useful
pieces of information and when we think
about that we really want to think about
what the user is expecting right when
they're going into your app what you
don't want them is to be surprised in a
negative way right but you want those
positive surprises though I didn't know
the app could do that right or like oh
wow it's actually doing everything I
expect and it's doing it great right and
that's where we want our media apps to
be not in meeting expectations but
really exceeding those expectations and
of course for an audio app you can't
really do that without background
playback right there's literally no
audio app you'll find out there that
forces you to keep the activity open the
entire time you're playing audio just
doesn't work very well on Android
especially when you consider phone calls
and other interruptions like that so we
really need to get the basics down
before we can exceed expectations now
when you think background playback that
should immediately ring bells boy oh
maybe a service makes a lot of sense
right they're specifically designed for
doing that kind of background work not
tied to any UI piece now when it comes
to media playback in a service what what
kind of things are we actually doing in
that service right so naturally every
service is created at some point right
that is what kind of kicks off the
process that's our one time feedback or
one time initialization kind of step and
then for most media apps you kind of
have to I would say top level states you
have playing which I'll use a shorthand
for audio is actually coming out of the
device and then you have paused
which is kind of all those other states
whether they're buffering or actually
paused where audio is not being played
but is in a state where the user may
want to transition back to playing
similarly stopped is kind of the final
state right when the user says I'm done
with your app I've moved on
maybe I've opened up another media app
etc and that of course services
hopefully eventually get destroyed and
this is where it will reclaim our final
memory and get back to kind of a steady
state of our app is not running so it
wouldn't be much about audio app if we
didn't actually play audio on Android we
have a media player which does exactly
that it's really good at playing audio
tracks but it's maybe not the most
customizable thing of all time
we do have exoplayer which is another
player that's sported on higher API
levels that you can use if you need more
control over here but for the whole rest
of this talk everything I talked about
would be player agnostic so whether
you're doing something that specifically
requires media player X the player
should all fit in the framework of
everything else we're going to talk
about so how do our events that we just
talked about map to say media player
right so it's actually really
straightforward right created we're
going to create a new media player and
then when we're playing we'll prepare
and then play the track pause pause stop
stop and then when we're finally
destroyed we'll release all of our
service right this super straightforward
creating and getting everything done and
we're done all right lots of time back
where we're playing audio right but the
problem is that just playing audio in
the background is probably a detriment
to users rather than a positive right
we've given them controls over it and
other apps are now trying to interact
with them and really were in kind of
negative kind of perspective well what
we actually want to do is go a lot
farther and that actually means that we
need to do a few more things to actually
get us play nicely with the rest of the
system be a good citizen on Android and
really be the best app we can be so the
first thing here is going to be audio
focus now audio focus is kind of this
key and Android of being that good
citizen right it's that concept that
your app is going to play audio right
and that is your consideration of being
the audio focus right but that doesn't
mean that you can ignore every other app
on the system right every notification
beep that comes in right players other
players starting Maps Navigation is a
really good example of this right we
really want to be considerate of those
other apps when you're doing audio
playback now this is slightly distinct
from actually playing audio right will
actually still want to use audio focus
when were paused or in that kind of
intermediate state because if another
player were to start playing while we're
buffering for example we still don't
want to talk over that other app when
we're actually ready to play
so some code actually registering our
audio focus and you can see here we'll
use audio manager for this it's kind of
the core for doing this core audio kind
of work and then we'll call request
audio focus in this case we'll pass in a
special on stream listener which is
where we'll get these callbacks back and
we'll talk about that momentarily and
then we'll want to say we're streaming
music or media and then we're gonna say
we're going to gain audio focus now in
almost all cases you'll get granted back
the system will say oh great you are
requesting audio focus you are a nice
app I like you and you get audio focus
now there are some examples where you
won't get audio focus for example if the
user is currently in a phone call
you won't get audiofocus in that sense
because they're actively talking in a
call and you'll want to wait until the
actual phone calls done and then do the
call from there or have the use of
repress the play button when they're
done with their phone call so what does
that focus change actually give us well
it's really kind of that key between our
app and all of the other apps on the
system right where we get all that
information so for example you may get
an audio focus loss symbol now this is
kind of that permanent loss of focus at
this point they've said well the user
has moved on another app has said I want
to gain focus forever and it's not
coming back
it's just not coming back so in this
case you probably just want to stop
playback you say all right I will
gracefully exit stage and allow the
other app which has requested focus to
continue on now one thing you might
consider here is if the user
accidentally hit the play button in
another app instead of immediately
stopping you may pause wait 30 seconds
and then stop right that's certainly a
active pattern if you want to prevent
some of those false negatives now
another one that they can use if someone
is using gain transient in this case the
other app is asking for you to stop
temporarily right so in this case you
probably just want to pause the playback
and wait for them to finish their 15
seconds or whatever so you may take this
as an example of someone saying
something out loud or say you're on a
running app and the running app is
saying you'll like your splits and pace
and maybe they don't want to talk over
your other app they just want you to
pause for a second and then you'll come
back now the last transient one is
actually called can duck and we talked
about ducking earlier this is a
different ducking this is actual can
ducking and that really just means
lowering the volume temporarily so in
this case this is what say no
vacations use right when you get a
notification in instead of the music
completely stopping it'll just lower in
volume you hear the chime and then it'll
come back up and it comes back up when
you get an audio focus gain so this is
when you've returned from any of those
transient losses now one thing to note
about the can duck is that it doesn't
mean you have to lower the volume if
you're doing say a podcast player or
something with spoken words where it's
really important you get every word or
else you know if you're talking for 10
seconds while there's another sound
going on that's not going to be very
intelligible so you can certainly pause
or do whatever you need to do in that
can duck scenario you don't have to just
lower the volume so our updated life
cycle we're playing or pausing we're
stopping we're ducking well lots of
things but you can see we've kind of
filled in a new row here where as soon
as we start playing for that first time
we're gonna long that request audio
focus and then start our playback once
we've received that granted playback and
then when we've actually stopped and
we're done playing audio entirely we'll
want to abandon audio focus and so that
already makes this a lot better part of
the overall system right we're no longer
to be talking over other apps it's great
but it's not all we can do actually one
of my favorite broadcasts of all time is
the becoming noisy or the noisy
broadcast so this is actually when say
you're listening on headphones and that
type of thing and then your speaker
comes out and all of a sudden you're
blaring to the whole audience and you
know we can't really control what our
tastes in music are for our users but we
can prevent them from some embarrassing
situations on that case by registering
just a simple broadcast receiver that
listens for that becoming noisy intent
and then pauses our music
so in this case we're gonna want to tie
this to the life cycle of actually
playing audio right there's no reason to
listen for being noisy if you are not
being noisy right so we'll register when
we actually start playback right right
after we get audio focus and then
actually unregister as soon as we pause
playback right so in this case it's
really more of that little bit of
connection in there just say like okay
well I really don't want the user to get
into this bad scenario so Adam register
unregistered easy done okay now at this
point we're actually fairly well off
from an audio perspective right we're
not going to be playing audio and we're
not supposed to be playing audio but
there's a lot more we can do to be an
amazing app another part of it is really
that sense of controlling audio playback
right that reaching for the next track
button or the pause button right these
are the kind of things that people are
going to use your app and do a lot right
and we don't want to make that really
tricky to use we actually want to make
it as easy as possible for users to get
and control your media playback and
thankfully there's a lot of ways to do
that in the android framework one of the
first ones you might think of our
headphone and bluetooth controls now for
me personally this is probably the most
frustrating one when you when apps don't
do it correctly if you're in your car
and you have integrated Bluetooth
controls those are the kind of scenarios
that users should not should not ever
have to go into your app to find a pause
button or hit the play button or
anything like that
instead you should be handling these in
your app now we generally call all these
headphone and Bluetooth controls
collectively media buttons so in fact
they're actually just like any other
keyboard event from androids point of
view you get a key down when someone
depresses the button and they key up
when they release the button now
by default the systems actually going to
send out a broadcast whenever it gets
one of these messages using the aptly
named media button intent and this
intent actually includes the key event
of the down or up and what action was
actually hit so in that sense we can
create our own but in the sport library
and then brand-new 23.1 release that
came out just a few days ago now we've
actually created a media button receiver
which does exactly this for you now one
of the problems with this kind of
broadcast receiver is because it's a
broadcast receiver in your manifest
somehow you need to get that information
into your actual service that we've been
talking about right you can't
necessarily play from the broadcast
receiver when it's service how do you do
all that communication and that's what
Media button receiver actually does for
you so how do you set up a media button
receiver you just register it in your
manifest right it's a simple receiver
you see our media button intent filter
here note that you're not you haven't
written any code at all but what it'll
do is when it finds a service which also
has the media button intent filter it'll
automatically pass any intents that are
received such as those media buttons on
to your service and now the service can
actually handle those play and pause and
toggle play controls in its on start
command no longer you have to write this
communication layer between your
broadcast receiver and your service to
get through everything there's one
problem though if you write this
it won't work at all so why is that why
we rewrote Media button receiver right
it should just work it turns out that
sending a broadcast to every media app
on your device not a good idea you don't
want to see what happens when you hit
play on 10 different media players all
at the same time it's not pretty
thankfully audiofocus handles most of it
but it will look funny so instead this
system has this concept of a preferred
Media button receiver
it's basically a last wins kind of a
model so the last one to register that
they want to be the preferred media
button wins very similar to kind of the
audiofocus model where you know as
you're the last one to say I want audio
focus you get it so if you've ever had
play music respond to a Bluetooth
control when you're in fact listening to
another app that's because something's
messed up in the preferred Media button
receiver so that is one of many things
that mediasessioncompat gives you now
mediasessioncompat does a lot it's
actually based on a lollipop Edition
called media session funnily enough and
it's our entry point between our media
app and all of the media framework api's
so all of the things that we're going to
talk about here shortly are all kind of
tied into this one object now the nice
part is is that this object even though
it was built in API 21 Auto translates
to older API so if you ever used remote
control receiver and other things we
won't mention those deprecated API s you
don't have to use them
mediasessioncompat will automatically do
the right thing for you now first we'll
want to create our media session we'll
create it in our service pretty much as
soon as our service is created just like
our media player that will create as
soon as possible
passing in a logging tag so anything
goes wrong it's very easy to actually
debug we're in the steps that actually
fell apart and then you'll want to set
two flags one that we actually want to
handle our media buttons and the second
one is transport controls these are play
and pause type of controls from within
your app you basically just always want
to set them I'm not sure why they're not
the defaults and then the last thing is
setting that callback
now the callbacks are actually really
important
that's where you get on play on pause on
stop it's basically that central entry
point between where all the media api's
are going to go and your actual media
player right so the on play method of
here would cause play on your media
player right so we haven't actually set
that we want to be the preferred media
button thankfully it's one method that
said active I bet you can guess what the
boolean does true means we want to
become the active Media button receiver
false means we're done and you can leave
so it actually does a lot behind the
backgrounds but one of the things that
does is the media button intent now once
we have this mediasessioncompat set up
we can actually image of the other part
of Media button receiver which is its
handle and 10th method handle and tenth
method which you can put in your on
start command automatically translates
all the key events extracts them from
the intent does all that work and just
hands them off to your callbacks so now
you don't need to do that translation of
all right well this is a key down of
toggle play and then that translates to
an on play command you just pass it on
through and keep using the callbacks
that you've defined as part of
mediasessioncompat now how does media
session know anything about what toggle
play should do we haven't actually told
it if we're playing or not
that's what media's state compact is for
so you can think of media state competi
is kind of all of the information about
what your app is currently doing right
so while you may know within your app
are we playing are we pausing or
rebuffering right the system knows
nothing right you haven't pulled it
anything so left to do exactly that
using set state now set state is kind of
the playing pause it's actually a what
looks like a Nino but is in fact not an
enum it's just in and we'll also want to
include our
position so how far along we are in the
track if that's applicable to you and
then we also have set actions so set
actions are things like do I support
play pause do I support stop do I
support next track right not every
player supports going to the previous
track you'll really want to make sure
that you actually put all of the things
you support because this is what's going
to show up on various surfaces such as
the lock screen later and it's also how
media buttons get filtered out if you
say you don't support pause and someone
clicks the button on their headphone you
won't get an on pause playback or
callback so really make sure that you're
actually also setting the actions now
you'll note that both of these are
combined into the same playback state
compat turns out that in most media apps
these are kind of tied together right
while you're buffering you probably
don't have a pause action when you're
buffering you probably don't have a skip
to next but you may still want to
support a stop command right to be able
to stop things if it's really buffering
on forever so they are kind of combined
together under the assumption that
you'll probably change both of them at
the same time so probably one of my
favorite features an Ice Cream Sandwich
R lock screen controls so kind of that
play pause pretty album art probably the
best feature besides the whole combining
phones and tablets and all that fine
lock screen controls definitely the best
now they're actually fairly easy to add
the only thing we've been missing so far
because we already set our actions is
actually just some metadata including a
picture right we can't really show
anything on the screen we're not showing
that type of thing so and that's where
media molta our media metadata compat
comes in again we'll just kind of set it
in you can kind of think of it as a
bundle of all of the information about
what's currently playing now note this
is actually used in more places than
just a lock screen so if you've ever
noticed on Android wear you get a little
notification of playing audio and stuff
it's actually using the metadata
you pass in that album arts all that
information is coming from the media
metadata you've set so what kind of
information goes in here yeah a lot of
the basics right title artist album all
kind of really important ones if you're
using fixed duration tracks you probably
want to add the duration that goes
really well with that position we
already set on the image size you have
can add bitmaps directly please do not
add any like 4000 by 4000 giant bitmaps
that's kind of the case where your eyes
come in where you can actually pass a
URI to just a larger image that then can
be downloaded later ideally they should
be content your eyes so that other apps
can read from them I have a storage talk
tomorrow that talks all about how you
can actually set up these URIs really
easy but these are just kind of some of
the most important languages actually
like 27 of them in total so read through
the documentation these are probably the
ones I'd recommend off the top so we've
added our mediasessioncompat just a few
more steps along the way we did are
created setting the flags playing we'll
want to set active to true set our
metadata set our state
similarly anytime we pause or buffer or
change anything really we want to make
sure our state stays in sync with our
app as well as then when we're actually
stopped
we'll set active to false and say hey
we're done and then release when Ron
destroyed to return all those resources
now talk about lock screen controls
they're really great but we kind of
removed them in 5.0 turns out that
notifications are the new hotness and
are kind of what the lock screen is all
about now as of lollipop now it turns
out we probably should have been using
notifications all along the fact of
having to lock your device just to use a
play/pause button probably a little
silly
so notifications kind of give you that
access anywhere anywhere any
you can pull down the notification tray
and play and pause in that type of thing
but building that custom notification
can be a lot more complicated than you
want so we built it all for you
we have notification compat media style
so this style kind of automatically
allows you to add media buttons without
having to create giant custom
notifications every time so on a
less-than api 14 in fact you couldn't
add any buttons to a notification like
there was a time when all the
notification was was just a single tap
target you know it's like years ago
right but we still support it here
you'll get just a basic notification
that allows someone to click into your
app starting an API 14 you can actually
have buttons so we support buttons in
that single line state you can have up
to three buttons right there in the
notification API 16 Android 4.1 added
expanded controls so here you'll get a
larger image for album art and you'll
get up to five controls and in lollipop
we actually switch over to the framework
media style so basically from there on
out you'll actually have the exact
styling across every device and it'll
look just like any system one now one
thing to note is that all of this
notification compat is in app compat not
necessarily in the support before or
just where all the rest of the
notification compat stuff is so just
keep aware of that now I like writing
boilerplate code once I never want you
to write weather plate code so I've come
up with kind of a media style helper
class which kind of does a lot of the
building picking in a media session and
then building out a notification compat
for you so we can actually extract a lot
of information if we've set our media
metadata in fact media metadata has a
very nice method called get description
which kind of extracts the most
important information those information
we pulled out that we called out earlier
such as title and artist and actually
allows us to
builds our whole notification directly
from that getting title get our
description doing all this work for you
so you don't have to do this boilerplate
work in fact we can actually pull out a
session activity if you've set it via
mediasessioncompat set session activity
to launch your activity automatically
now on 5.0 plus you can actually hide
notification contacts on the lock screen
but generally we actually do want to
show media controls on lock screen even
in those cases so we can set it as
public now you'll note here for the
delete intent which is when a
notification is swiped away we're
actually using a separate helper called
get action intent which you'll pass in a
key event and then it'll automatically
create the pending intent for you
thankfully that's another easy method
that I've created and both of these
methods are on it just on github which
means you don't have to write it ever
again it's fantastic so we can't
actually just stick with something very
simple in fact when you create it from
our notification and then we'll want to
set kind of the small icon right that
appears on the top and then set the
color now color works a little bit
different from media style notifications
if you ever seen a notification on 5.0
plus the small icon right the app icon
can be colorized in the background
you'll see a lot of Google apps do this
in media style notifications it actually
is the whole background of the entire
notification so if you're using bright
orange I want to stab your eyes out
don't use bright orange or any color
that you know really you want to test it
out and make sure that the color that
you're setting makes sense with your
actual color palette and doesn't look
ridiculous because it has a strong
chance of looking ridiculous now media
styles wouldn't really be much of
anything without actions so here I'm
adding a pause action using our get
action intent and then our style
actually just uses two methods one
called this set show actions in compact
view so this is what's that's what
actions appear in that single line view
by default none will so you probably
want to set some zero index array of
what buttons to have so if you want the
second button you've added you dad
button one if you want the second and
third one in two cetera and then the
last part which is super critical but if
you forget it people hate you is media
session so the set media session is
actually what allows you our
notification to work on Android wear if
you don't set this then you'll get a
beautiful notification on edit where and
then you hit the pause button and
nothing happens we're spilling in the
world oh wow that looks amazing and
nothing happens but what it's actually
doing is it's using a session token but
it's kind of a unique identifier for
session and passing that on to apps like
Android wear such that they can control
your audio and give you callbacks in
your callback so you've added our
notification we'll want to show it as
soon as we start playing I will want to
update it anytime the states changed and
then of course remove it when we've
stopped and are all done but talked
about notifications now turns out that
there's this concept called foreground
services which kind of raised our
background services priority to a higher
level such that it won't get killed now
foreground services require a
notification which thankfully we just
built so we can't actually take
advantage of this for our media service
now it's actually really important
because we really don't want our service
which is playing audio to die in the
middle of things just because someone
launches chrome and it takes up all the
resources on your Android device believe
me they're working on it
but what we want is we want our service
because it is actively playing music to
live just a little bit longer and
hopefully survive forever
there's one caveat though once you've
started a notification with start
foreground pre lollipop it was on going
forever could never swipe it away
which was actually super frustrating so
we fixed it but it actually effects
media notifications the most because if
you think about it you're going from a
foreground I'm playing audio to being
paused not foreground very often and you
don't like your notification being
completely remove removed and Reap it in
because it looks really janky so our
media style actually gives us two
methods which allow you to kind of work
around that setting a cancel intent and
basically this just adds a little X in
the corner of your media notification
which allows them even if they are on
going forever and you're annoying users
to no end they can just hit the X and
close out your notification in this case
we'll set the intent to just be a media
stop just like it got swiped away so it
always is a the same whether it's free
lollipop or post lollipop nicely enough
on lollipop these methods just don't do
anything because it doesn't apply on
those levels you'll be able to swipe it
away as soon as you say stop foreground
false
so stop foreground false means I don't
want to be a foreground service anymore
but keep my notification up there right
I'm still still alive right but I don't
necessarily have the requirement to be
at the top of the priority list right if
their music is paused forever right
users probably won't notice if it
actually gets destroyed or not and if
you're really under memory pressure it
is kind of important to be able to have
Android clean up your service so we've
actually done a lot right we're playing
we're pausing we're stopping not
stepping on other apps Bluetooth
controls work lock screens media
controls the notifications Android wear
and we're reliable under memory pressure
that's pretty good
now you just forgot one little thing
an app that has you why that has
controls and we haven't talked all about
how that service interacts with your
actual UI now you could be doing
something super simple and saying just
start service with custom actions but it
doesn't get you the two-way
communication you want you want so that
when the service switches to the next
song your UI stays in sync and ideally
we'd want actually reuse those callbacks
we were using so that when someone hits
play or pause in your UI your callbacks
you've already set up for media buttons
are automatically handling those things
sounds pretty amazing right so we built
a cosplay built a lot of classes media
controller compatible of that for you
once you've connected to it then you'll
actually get access to all of the
metadata you've set you can tell what
the current playing track is all of the
state so you can tell if you are playing
or paused and what position you are as
well as transport controls so these are
the methods of like play pause skip to
next right kind of useful things to have
and these pipe directly into your
callbacks right there's no extra layers
you need to build no callback craziness
it's just already built before you in
part of transport controls and because
no one likes pulling for media changes
you actually get a set of callbacks
so these callbacks are the things that
say like oh the media metadata has
changed we've switched to the next track
oh we went to buffering right instead of
having to pull your service or have your
service send notifications every time
whenever you call set state or set
metadata which we're already doing right
then our callback will instantly get a
callback saying like hey the metadata
has changed you should update the UI to
match the new metadata all of a sudden
our UI is now totally in sync with our
service without us having to write any
crazy communication code between our
service and our UI
we're using a media controller compan
there is one wrinkle though that token
that we need that media session token'
that we pass to our notification
actually also what's needed for media
controller compat but person who knows
about our token is our service we
somehow need to get that to our UI now
really matter how you get it to your UI
but we do have a second set of classes
called Media Browser service and Media
Browser
which are introduced in API 21 which do
all of this connecting and passing the
session for you nicely enough you don't
actually need a token to connect to a
Media Browser service and you'll get
access to actually new api's as well
such as being able to browse media items
entirely this allows you to actually
build your UI off of the information
that's already in the service for
example you could have a list of tracks
and that would match what's in your UI
and they wouldn't you wouldn't have to
create a separate data store for that
you can use the Media Browser service
and Media Browser to connect to it no
this is also how all the Android wear or
Android auto integration works so
Android auto is actually connecting to
your Media Browser service and then
building the whole UI all the controls
all the information from the data you
pass back to it you'll also note that
Android wear adds a browse action you'll
never find it on your watch but you're
playing audio and scroll all the way to
the right you'll find browse this allows
them to actually check the next track or
skip multiple tracks or change playlists
and stuff directly from the watch
actually pretty useful if you're one of
those kind of people who hates pulling
their giant Nexus 6 is out of their
pocket now moving to Media Browser
service has one thing you'll need to do
call set session token' and on create
and obviously move over from extending
service to extend
Media Browser service now it also gives
you those new methods on get root which
is kind of the verifying what the
calling app is so if you want Android
auto to display different data you can
pass it a different route from say your
own app right so if you have different
layouts for each one and then similar to
a file browser for example on the
children gives you a list of all of the
items some of them may be browsable
items right different folders and
subfolders other ones might be playable
ones
similarly unload item just gives you
details about a single item so you can
see how like you may be able to build a
UI out of these methods right you may be
able to say on those children and get a
list of all of the songs and all all of
the album's or all of the most recently
played tracks it doesn't really matter
what it is but that same list of tracks
can be really done with onload children
and then armload item can actually give
you the details about an individual item
now if you wanna learn more about this
we actually have a giant sample app
which does everything in the world based
on media browser service call universal
Android media player you amp like I said
currently Media Browser service is API
21 plus and so is universal Android
music player um
but I would like to say that we are
working on backporting both so we're
working on getting Media Browser service
to lower API levels as well as moving
over you amp over to support a wide
variety of devices so you can actually
use all these things much more even if
you're not quite ready for min SDK 21
anyone huh oh yeah all right great
perfect my nephew you can use it right
now that's great you don't have to
switch to any of this now if you're not
min SDK 21 then you should be but you
know they're they're really the best
users but I
I understand I understand maybe that
doesn't make sense for your app there
are a few other ways other than using
media controller to get the session to
your activity you could do it super
simply use say the eventbus app of your
choice or extra whatever or use a static
method in your service and a local
broadcast to say oh it's changed
super easy to build but maybe not
supporting kind of a multi-process
structure actually multi-process is a
lot more important for a media app
because you really want that background
service to be as low memory as low
impact as possible and have your UI not
impact the actual service so if your UI
crashes because something's gone
horribly wrong you don't necessarily
want that to kill your whole background
playback also another option is to kind
of fake what Media Browser service is
actually doing under the covers and bind
to your service build an API that just
returns a token for you no one really
wants to build this but we actually have
really good training on bound services
on developer.android.com if you're
interested in learning kind of some of
those approaches to do that the simple
matter is it doesn't matter how you get
a token to your UI just matters that it
gets there so whatever approach you want
to use now and then if you want to use
Media Browser service later it's totally
possible and it works great so
everything that we've done today can be
summed up in one slide probably should
have shown this at the beginning but
then you might have left but this is the
canonical slide of all of the things you
may want to do I did note once that the
stopped state right if you do want to
keep your service around for a little
bit longer you don't necessarily need to
remove everything as soon as they hit
the stop button you may keep it around a
little bit longer that's fine but we've
learned about kind of audio focus and
the noisy broadcast becoming noisy to
really play nicely
with other audio playing apps media
buttons lock screens and system
information with mediasessioncompat then
media style notifications Android wear
support via media style and then Media
Browser service for Android auto and
building your UI based on your
information so feel free to reach out to
me on Google+ or Twitter if you have any
questions otherwise I'll be right down
here for any questions in the room
thanks so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>