<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Android Build System (Android Dev Summit 2015) | Coder Coacher - Coaching Coders</title><meta content="The Android Build System (Android Dev Summit 2015) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Android Build System (Android Dev Summit 2015)</b></h2><h5 class="post__date">2015-11-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OOEDKf06WqA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello my name is Xavier Juke hi my name
is Nick haben dog Skiba
and I'm Jerome do--she and let us tell
you about the Android build system
especially a couple of features that you
might not know about so let me start
with the performance checklist that is
that is all the things that you should
make sure are in order when you're
trying to improve your build times so
first of all please make sure to use the
daemon that is already the case if
you're building from Studio but if for
some reason you're building from the
command line like for example when
you're trying to merge your build times
make sure use the Dodge dodge demon flag
or enable it permanently using the
Gradle properties secondly please make
sure to give the demon enough memory
that is especially important when using
the in process texting support the
desert machine tell you today you can
use the old Gradle JVM Arc's property to
set the heap size that the demo values
on the other hand if you find that your
builds are making that your computer
unresponsive you may want to limit the
total number of threads that you will
use and you can use the Android fred
pool size property to do that next make
sure you use the latest build tools
specifically 23:02 is the latest one
currently and it's very important to use
it because of the fixed text merger
that's also mentioned earlier get an SSD
the sad truth is that building can read
applications requires a lot of i/o
operations which means they actually run
a lot faster on a fast drive and lastly
make sure you don't use timestamps or
commit numbers in your build files or at
least not for your debug builds I'll
come back to it later in the
presentation
but it's really easy to make your builds
non-incremental if things are too
dynamic okay as mentioned please try the
decks in process flag Ethan it's not
enabled by default in 2.0 but it
actually makes a huge difference so
please try it and let us know if it
works for you also consider having a
dedicated development flavor with mini
ZK version 21 the API level 21
introduced some features that we try to
emulate at Build time for older devices
like multi decks but also vector
drawables if the me nezzie case
2:21 then we have to do less at bill
time which means the bills are faster
now as we mentioned earlier studio will
soon start to infer the min SDK number
based on the device you're targeting but
for now having such a flavor is probably
a good idea alright let's talk about
testing now I hope you already know that
we support unit tests that execute
locally on your development computer but
just to reiterate there is a dedicated
tests or set where you can put your unit
tests there is a matching test compile
configuration for all your test
dependencies and we support all the
usual testing frameworks although we
recommend you use Unit four and there's
a separate session purely about testing
right after this one so I recommend you
attend or watch the recording later let
me just say that what you currently aim
at supporting is to allow you to test
your business logic that is the part of
your app that is naturally specific to
Android any Android code that you end up
calling cool from exceptions so you'll
have to refactor your code to either
avoid it or mock those parts using a
library like mojito for example okay
when running unit tests from the command
line it's important to remember that the
test task you may know from Grado in
android projects is actually an uncle
task that triggers the real testing
tasks for each variant independently so
for example that will trigger test
release mean test and test the back unit
test unless your business logic does
something different depending on the
variant is probably enough for you to
just run Gradle test debug right if you
need to configure your test runs like
for example you may want to increase the
heap size of your for the test runner
you can use the test options unit tests
all block that will apply the given
configuration closure to all the variant
specific test tasks I mentioned earlier
and it's important to remember that
these settings are not picked up by
studio currently so this is only useful
if you're invoking test through Gradle
like for example in a continuous
integration server okay another testing
feature you may not know about our
separate dedicated test projects which
allow you to keep your main code and
your
test code separately which can be useful
if you need this additional flexibility
and also if your code is already
organized this way from the Eclipse days
the easiest way to get started with this
feature is probably to copy the template
from the Android testing templates
repository but let me give you a brief
overview of what's involved so the first
step is to set the publish no default
flag on the applica on your main
application project and then you create
a separate project that uses come
Android test plug-in you specify which
project you want to test and which
variant you want to test most likely you
also want to specify the testing test
instrumentation runner to be the one
from test support library then you put
your testing code in the main source set
of your test project that's something to
remember and currently you still have to
put an instrumentation tag in your test
project manifest to specify the the
package of the application to test
although we hope to get rid of this step
up soon and once all of this setup is
done you can run the usual connected
Android test task on your test project
ok another issue that shows up quite
often when people write testing code is
the dependency version conflict which
like shows up when you're using the same
library in your main and test code so
what exactly is the problem there the
problem is that at runtime your main apk
and your test apk share the same process
and the same class path which means they
have to use the same version of every
library even if some of those libraries
were pulled in as transitive
dependencies of other libraries like a
common example is support annotations in
your mind apk and an older version of
support annotations that is pulled in by
some of the test dependencies so in this
case we choose to be very explicit about
what's going on and we force you to make
a decision whether we want to change the
version of the library that's used by
your main apk or the or the version used
by the test apk which in theory may
cause some of the libraries in this
example runner to misbehave although in
practice we
usually they don't so the easiest way to
solve this problem when you actually
encounter it is to add another test
dependency to your build.gradle file
that explicitly depends on the same
version of your library as your
production code okay
and now stuff will tell about native
support okay so starting with the new
version of the plug-in that we just
released we have better than that if
support that we need before and i/o I
mentioned a new plug-in that we're
working on the model based plug-in which
is new API in the Gradle build system
and part of the API is the ability to
build natively native code so without
going through the make file that we have
right now in the indian DK so we met
some additional progress not a whole lot
but you know we're progressing so the
first thing that you think about if you
want to use it and try it is that we
have different plugins right normally
it's commented application and commented
library and now we have you know to
replace them to use the new plug-in API
you have to use common trade model
application library and then we have a
third plug-in which is a plug-in that
only generates an S so it doesn't
generate anything specific Android I
mean that SEO is meant to work on
Android but it just you know there's no
Android packaging around it in all three
cases we directly use the Gradle API to
build native code but we configure them
with the native tool chain coming from
the NDK so the arm to chain the x86 to
chain and all of that so if you're using
that plug-in the DSL a little bit
different right I think we mentioned
that I also and there's some
documentation here you should go to that
link and we carat but basically most the
biggest different is that everything is
under the model element and then here
you can see indicators with again the
dot wit is something we want to get rid
of at some point you just define the
module name and then it will create a
library with that name and it will just
take care of everything basically and
then under that any key element you can
also configure your C flag your linker
flag and all of that and something new
so some of that was already present in
an earlier version something that was
not present before was the ability to do
intermode
dependencies so we're not hooking up
with again the new dependency management
that this new Gradle plug-in API brings
so you'll be able to do dependencies
like that as you can see it's a very
different DSL from before where before
you had the dependencies block under as
a root element here it's under each
element each source element so it's
really different and there's some option
right you see that it's not compile or
debug compile or anything you just say
what you want to depend on but you can
have some options on that like if you
want to do a static linkage you would do
project library and then linkage static
things like that
I recommend evilly that you look at the
documentation for Gradle itself to see
all the things because it's an area that
moves a lot so you should definitely
look at that and then I want to talk
about extending the android plug-in we
know a lot of you do a lot of things in
there some of you even create plug-ins
for other people to use and we you know
every time we update the plug-in we see
people using third-party plug-in being
broken up because the new version of our
plug-in is not compatible with some
third-party plug-in and it's an area
that we know is becoming more and more
painful and we want to solve the problem
it's not something that we're going to
solve super quickly but you know there's
a few things to look at when you're
doing that so the first thing is we see
a lot of plug-in just trying to access
tasks by name you know the the plug-in
wants to hook up in some tasks and then
just do a get task by name and that's
just like a problem because we're not
guaranteeing that those names are not
going to change this is not part of our
official API even studio does not use
those names directly right part of the
information that's really exported by
Gradle through the tooling API part of
that information contains the name of
the task to call so that in case we
change it in the plug-in studio doesn't
need to be change it just reads the
information from the malaria so you
should do the same do not do that now if
you do that for your own build script
you know that's fine you're not going
you know it's your problem to fix when
we break you but if you're publishing
problem for other people to use then you
should be very aware of that another
thing to be aware of really is how the
after evaluate work we see a lot of
people who are very confused about that
and you know after evaluate is just
basically a callback that is called
after the main DSL is passed and and you
know executed and so we register one you
know as soon as you do apply plug in
Android we actually register one and
that's where we're going to create all
of your tasks and so if you try to
manipulate tasks before even though I
said you shouldn't but if you're doing
it then you should definitely do it in
after evaluate and because it's not
working but you can't actually
manipulate other things in after
evaluate than tasks if you want too many
change you know build types or you know
do some custom logic that's going to
change product flavor or it's kind of
too late
because you can only your own after
evaluate happens after hours and so you
know it's too late you already created
the balance we already created the task
and it's kind of late so the right way
really to you know access our tasks is
through the variant API so we have this
DSL where you can do application by on -
all and then you get a closure and that
gives you access to the bottom out its
tasks and all of that now the trick here
is you know I just said hey you need to
access test and after evaluate but
that's not enough to evaluate that code
the trick here is that all it's
something specific to grader on the
Gradle collection and that basically it
registered the closure you pass it and
it will apply that to your existing and
future item in the collection so by the
time you call that the collection will
be empty but every time we create a
valiant and it's task and we add it to
the collection then your closure gets
called okay so what can you do with that
object you can do some basic things like
you know creating the name for example
now that name is unique so it's very
useful if you want to create per valiant
task you should use that name as part
you know like foo plus you know get name
and then you know that it's going to be
unique for every bind the DNA M is one
or more segments of folders very useful
to you know again store your custom test
data you know do build D or slash
intermediate /foo slash get your name
and you know it's unique for all the
different types you can also get other
information like the application ID
that's computed you know it's a merger
of the product flavor and this
fixing the build type and things like
that you can also get access to the bill
types product flavor
those are read-only we've seen people
change them and so a few years ago we
actually now give you a read-only
version of them you should not change
them they are shared across all the
different variants so you know if you're
trying to change them you need to change
them before you access the valent API
you need to change that in the regular
DSL we also give you access to the test
name so that's where you know you want
to go and create the task rather than
doing it by name and we know that a lot
of you are trying to get those tasks in
order to do things like you know
inserting steps in between two different
tasks and things like that and you have
to be very careful about what you're
doing there all right I'll go back in a
little bit about the tasks API but you
know there's some things that you want
to do for example if you're trying to
generate what we consider to be source
code whether that's you know Java source
code or Android resources you know you
shouldn't try to go in and hook that
manually yourself we have some points
some entry point in the variant API call
register Java generating task there's
actually some parameter to that like
your tasks and you should basically have
your plug-in add a new source folder to
the regular Java source folder list
right it's like it's multiple source
folder not just one so you can add a new
one to that collection and then have
your test just write to that register
your task with that and then we'll call
it what it needs to be called studio
will know about it and then you know it
will work on to and rather than having
you kind of trying to find the test
manually and hooking things up together
that's you know do you definitely don't
want to go into the Java Sea task and
try to give it additional source folder
there all right just tell us what the
source folder is give us your tasks and
then we'll take care of things for you
now if you look at some of the tasks you
know we don't really have a proper API
so you may have looked at our source
code and seen something like that it's
like hey you know here's some public
stuff and here's some private stuff
don't use the products that fit will
break we will break you
that's why it's just private the public
stuff may break anyway because we have
we haven't been very good about you know
really considering that public API I
definitely
is something we want to do in the future
and you know we know that a lot of
people want to inject stuff between two
particular steps and as between Java C
and M DX right we know about that and so
we've been looking at ways of solving
that problem rather than having you go
and look at the source code and see hey
what does the DX test do and how do I
inject it additional jobs or whatever so
if you look at it here you know that's
the default project you create just go
straight from Java C to D X and that's
easy but in reality well you have
additional optional steps already you
know jacoco which could or could not run
then program which could opt to not run
and then we just added instant run so
imagine you trying to add you know a
couple of other you know bytecode
manipulation thing and trying to have to
all of that together you know hey what
if I plug in a and you know it's plug in
B so that can hook myself separately so
we just wanted to fix all of that time
so starting in 1/5 actually we
introduced a transform API that you know
the goal is to solve that problem so
it's just a pipeline of transforms it's
not a pipeline it's it's a very static
pipeline it's mostly helping us set up
those different optional steps you know
we want the API to be very simple in
terms of adding a new transform and so
it's not something that you can
manipulate after the after the fact the
API doesn't talk at all about tasks we
don't want you to think about
manipulating tasks you know handling you
know the dependencies between them all
you have to tell us is you know hey what
do you want to transform you know and
things like that we take care of the
rest for you we do support different
types so from now on the public API we
support you know Java bytecode classes
and non Android resources right things
that you would find in a jar and it's
important because for example Tahlia
manipulates those and we also support
dex file though it's not available
through the public API we might change
that a little bit in the future but for
now that's not the case we also like the
way we package and resource libraries is
actually also going through that
pipeline and then we support different
scopes so for example jacoco we only run
it on the project scope right only the
main app project module
instant run also right now on that
project but you add the sub-module to it
so you'd be able to say here when I run
on those two scopes ProGuard will run on
all of the scopes because it really want
to look at all the source code of all of
it so to implement a transform we have a
abstract class called transform you know
there's a few method to implement get
name it has to be unique we actually use
that to generate the test name get input
type is what you want to transform you
know classes or decks so content type is
actually an interface but there's a
separate Union default content type that
contains the type you can change because
we have a private a name for the
internal only types scope is an idiom
and get scope will give you the scope
you want to manipulate is incremental
whether your test can or cannot be
increment or if you can't really tell us
force and will optimize something so we
won't do some work when we call you and
then finally the transform method so you
get a context to get some information
about radar not the task but a few
things you get your inputs you get some
reference inputs right when we run
ProGuard if it's an a test app that's
testing something it needs to have
access to the tested code and so greater
the greater transform actually could ask
part of the scope that it asks it does a
get reference scope that's not an
abstract method but you can implement it
anyway and you can say that's a scope
that's called a tested code so you can
ask for that to get access to it you're
not supposed to touch it you're not
supposed to write it but you can get
access to it to read it and then
transform a good provider allows you to
create different type of outputs and
then whether that particular one is
incremented or not and there's some
additional features on it like secondary
file inputs secondary file output for
example program outputs it's mapping
file as a similarly output things like
that I encourage you to look at the Java
log so to use it you know just do a
dependency on the transform API artifact
you know either in your own plugins or
directly in your build script and then
you know there's a global for now
hundred point in the DSL register
transform and then give us the instance
if you give it an instance like that
it's a single instance that will be used
for all the variants so make it
stateless
but you know it's fairly easy to do so
all of those are using the transform
right now since 1.5 as I mentioned you
know jacoco Prague out the new shrinker
instant run decks and because Dex is now
transformed we kind of like remove the
regular Dex tasks so if you're currently
trying to use accessing the desktops
you're going to have problem and we want
to fix that it's not technically gone
but it will throw an exception so in
term of order this is the order in which
we will run the transform and there's no
way right now to change that it's really
interim of the third-party one you know
that could be more than one but it's
really first-come first-serve right it's
like as you apply custom plugins that
will drive the order of those transforms
so we have some limitations so as I
mentioned our global they're not pure
volumes but we do want to fix that
hopefully for to the dough for the final
version and you cannot change the order
through the API and it's something we
need to figure out because there's some
issues right like ProGuard will merge
all the scope together into a single jar
I talked about that in my other talk
about high generator now to a single jar
file the new shrinker doesn't the new
shrinker outputs one you know it five
every scope that it reads it outputs a
single output so if you have something
that needs to read just one scope and
something that merge all the scope
together then the other would fail so we
need to solve that somehow they appear
at some point okay so that's the
transform API again the doc is there the
Java lock go look at it give us feedback
you know the API is marked as beta right
now because we want to be able to change
it you know please use it and let us
know if you run into trouble okay I want
to go very quickly through inspecting
your builds we know that this is
something that some people have a lot of
issues they don't really understand
what's going on with their build and so
there's actually a few tasks in red or
that only do to do that the dependencies
one is it's not a task you know it's not
provided by our plugin it gives you your
actual dependencies so you can see all
the transitive dependencies and all of
that it has some interesting features
like showing you which one gets promoted
you know to a new version just because
you have two version of it in your graph
and one is higher than the other one
well in the path that lower
you would still see that you know even
though it says 2301 it's actually using
23 1 1 because somewhere else you do the
panel 23 1 1 and then you know if you
have multiple version of the same
dependency in your graph so it will show
that to you so for example here support
v4 is used twice and so the first time
it shows you its transitive dependency
the second time that the smallest error
is saying hey you know you've seen that
before and it won't show you the
transitive dependencies so that's what
that little Asterix mean now this will
show you for a configuration object and
if you build your debug violent for
example we actually take the compiled
configuration we take the debug compile
configuration and we kind of put them
together and resolve them at one right
so even though here it's the compile
configuration and we're resolving to you
know support annotation 23 1 1 if in
debug compile I'm using 24 then
ultimately it will use 24 so you really
want to look at it at the bank level
like globally and so we have this
Android dependencies task that does just
that it's at the global you know that
debug here is actually a full line so
you can use that we have one for sauce
set so I know that sometimes developers
are adding sauce set and not sure
whether or not it's actually adding the
sauce sets and not knowing which are the
folders just look at it and then for
each you know you see the saw set you
see the actual compiled configuration
associated with it you see the actual
sauce set object that you can manipulate
in your blood grade also it's very
convenient and then finally we have the
report signing task if you're
configuring you're signing through it
you can just do that report you have if
you provide with the password somehow
then we can show the fingerprint that
can be useful and and things like that
all right and with that thank you
alright so let's talk a little bit about
instant run I'm not going to give a very
deep technical description on how it
works but I think it's important that
you understand some of its concepts
because it may impact you during your
alternative development cycles so what
happened with instant run is that you
start with a class that you've loaded
inside your vehicle machine and that
class as many feel
and a couple of methods slow dude and as
your application is running most likely
you start having instances of that class
around and this has been created at that
point to your application is running but
you realize that it's not running the
way you want it so you go back to the
IDE and you start writing code to change
the behavior of that particular class
once you hit the button insert run we're
going to be compiling just this
particular class we're going to be
dexing just this particular class and
we're going to be delivering just these
particular classes to the runtime so
that's why it's super fast so at the
runtime level we're going to create a
new class loader and in that class
loader we're going to call what we're
going to load what we call the overwrite
class so first thing to realize is that
we never actually reload the full class
the full class has only been loaded once
it will be always loaded once never we
load it instead we will be loading as
many overwrite class as we want because
we use a new class loader
if you continue writing more code and
this foo class will just ditch the
previous version of the class loader
with this override version and we'll
have a new one coming in place replacing
the food so once we have set up this
class loader we loaded the override
inside it as you can see all the methods
of the original class have been moved to
static methods on the override and the
new code is actually implemented within
these methods now we just have to do one
more thing it's to redirect so we
redirect from the original foo class
every method implementation to the new
one okay so that's how it works at a
very high level very simplistic
demonstration but very things to
understand is this concept of this
original class which never changes and
the override class which we can't change
many times one of the thing which is
important again is that if you create
more instances of this foo class we're
going to be using the original class so
the instances will all be coming from
the exact same class and it's
particularly important if you store them
in a you know collection you want them
to be of the same type right so again
remember that the foo class will remain
and all of the instances that will ever
be created will be from the original
class what does that mean first of all
the override class will appear in stack
traces
if you generate a stack trace and let's
have a nullpointerexception which is my
own favorite burg you will see the
override class in your stack tracer so
you shouldn't be surprised to see these
clusters appearing we could potentially
remove them but we decided that it's
probably better to not try to mess too
much with the stack tracing and and
leave it so we but you must be aware
that it may appear the more subtle thing
that may happen is that new method calls
only generate the only the new code is
only invoked through new method calls
that means that if you are you know
running a particular method and you have
a while loop or a for loop inside it and
you change that class implementation
it's not going to change the thread
which is actually running the current
version of the code right only when
somebody else is going to call that
method will the new code kicking so
that's particularly tricky when you
think about recursive calls so a first
recursive call say is going to call it
self hundred times the first ten times
it call its himself it's the old version
of the class now suddenly you're going
to swap the class and it's going to
start calling the method that's again
and because it's a new call of a method
it's going to kick in into the new
implementation you just provided so it's
going to call itself 90 times with this
new code but then as it will come back
and unwind the tail of your recursive
calls it's going to come back to the
original method implementation so you
can see here this is getting into really
muddy territory and you should be aware
that you know you could have surprising
results when you start missing obviously
the implementations the best way when
you think this kind of stuff happening
is just to force a code with start which
is basically you stop the application
and you restart it I don't expect this
is going to happen very often because
there's not that many recursive calls or
stuff like that happening in Android
world but something you should be aware
of again I already touched it methods
are replaced not really
classes are reloaded right we do not
reload classes I know it sounds like we
are reloading classes but we really are
not we are replacing method
implementations so classes already wants
what does that mean that means the class
initializer is only
run once and if you change your class
initializer we will flag this as an
incompatible change as you know by now
the instant run technology is on is
reporting basically changing method
implementations but if you change a
field or if you add or remove a method
we will actually restart the application
for you same thing for the class
initializer if it changes we will
restart to the application because
because it's an incompatible change
static variables are not relational is
easier so if you have a class and you
have some static variables which are not
final and you started changing their
values through the code
suddenly you add swap that particular
class version to a new version even if
the code that was actually initializing
this these values in the run it's not
going to change the values of those
static fields all right so you should
not expect things to be reinitialized
again you know the class has already
been loaded it's just going to continue
living its life same thing for instances
you may have already created instances
of the class that you are going to
update and we are not like destroying
those instances or trying to extract
their fields values and putting them
into some new objects no those instances
stays around and the instances fields
remain at the same values that your
application that already said them
that's also very true of course for
singleton objects again that's kind of a
situation where you could expect or you
possibly would expect that because it's
a singleton object somehow we're going
to recreate it with the new version of
the class no we are not it's going to be
the same singleton object the only
difference is that all of its method
implementation would be redirected to
the new code so if you are initializing
the fields of your selection of your
singleton object a certain way don't
expect it to be reset just because you
change the constructor in the new
version of the class sure the
constructor would set the fields to the
new values if it was to be executive but
because it's a singleton it's not going
to be executed therefore you're going to
get the old fields values so it's
important to understand all of this at
the end of the day you should not worry
too much about it but it's possible that
sometimes your application does not
really behave that the way you think it
should go and that's most likely because
maybe the code you've just modify
does not work well with the state of the
application it's in you should just
restart in such cases all right we also
want to talk a little bit about recipes
so these are important things that we
would like to raise awareness about and
the first one is no way of generating
multi-apk switch IBI specifics so in the
past when you wanted to have to reduce
the size of your apks one of the trick
was to say I want to have an apk which
is specific to a particular ABI and I'm
only going to be supporting the 86 in
this particular case where I'm going to
be shipping only the daughter so far
that I'm running for this particular ABI
and in this example you can also specify
that you want to the full which would
have the ability to run on any possible
devices irrespective of its particular
ABI however it would be obviously a very
big apk so in the newer version you
should use product letters for that you
should use pull up forevers to define
your applications and not how we package
the resulting apk in the new way of
doing things is by using these new
splits declarations inside your your
model inside the DSL and the way to do
that is by either using ABI densities or
language depending on which type of apk
you'd like and what it's going to
generate in this particular case is for
apks 3d case will be specific to a
particular ABI 86 arm mips and one will
be the universal one again which
contains all the possible ABI XO files
this way you will get a much smaller apk
each time and you do not pollute your
project the Claridge the products flavor
declaration as you had to do before next
one is the rest of chancre so from many
years we've had the ability to shrink
the code using ProGuard and that's
particularly useful when you import a
library and you may be only using 5% of
the library facilities you don't want to
ship all the code associated with that
library so you use log out and you kind
of strip all the code that you're not
using however it was not stripping the
resources associated with that
particular code that is being stripped
so we now have the ability to have a
resource anchor
that you can get that can be key back on
the actual program pile to figure out
what are the classes that are really
necessary for the application and which
are not necessary and make educated
decisions about whether or not some
resources are necessary so when you use
ProGuard to release your your
application you should most likely
always think your resources and it's
going to result in a much smaller apk
size which is great for for for users
next one I think is back to Michael
thank you thank you oh yeah this one
most of you probably already figured out
but let me just talk about it real quick
if your project has multiple sub
projects it's a very good idea to share
the same versions of dependencies and
your SDK levels and tools version
between all those projects so the way we
recommend you do it is using the Gradle
extensions mechanism that is used the
ext block in your root top-level
Gradle file and then inside this block
you can create properties to call the
constants you want to share you may want
to use the groovy syntax for defining
Maps like I did here for depth and then
you can reference those values using the
root project prefix in the other you
know in all your other build files ok
another tricky part that sometimes
people are surprised about is the
scoping crawls in in build files so as
much as groovy scoping has its edge
cases the basics are the same as you
know from Java so the dependencies block
in the current plugins I've mentioned
the things are actually bit different in
the new plugin but in the current plugin
the dependencies block is a top-level
property of the overall project context
so the fact that you reference it from
some nested call deep within the hundred
block doesn't really change the meaning
of the call so that even if you would
expect this code on the screen to add a
dependency only to the given flavor the
free flavor it doesn't actually do that
why should what you should be doing
instead is put the dependencies block at
the very bottom at the top level to make
it clear what's going on and if you want
to add the dependency only to a given
flavor you should use the specific
configuration that we have for this
flavor okay let's talk about flavors in
general
I hope you already know that flavors are
a good way for you to create different
variants of your application other than
build types in the next talk cause I may
actually talk about how you can use
flavors for testing but how like what
should you do if you want to
differentiate your app in more than the
more way than one so let's imagine you
have a free version of your app and a
premium version but you also want to
sell it in blue and red flavors because
you believe that will actually increase
the sales so instead of creating all the
combinations manually what we suggest
you do is use the built-in support for
flavor dimensions that we have in the
android plug-in so you can define well
named dimensions like price and color in
this case then for every flavor you
specify which dimension this flavor
belongs to and the additional advantage
of doing it this way is that you get
dedicated source sets for for example
read-only
resources and blue only resources and
premium only code that is shared between
the premium rate and premium blue
variants so that's very convenient okay
but what happens if not if not all the
combinations of bill types and flavors
make sense at the start of the
presentation I mentioned a development
on the flavor it probably doesn't make
much sense to ever combine it with a
release build type because we never
really want to distribute the
development variant and so what we want
what we can do is use the variant filter
method on the Android block which allows
you to register a closure and the
closure will be called for every about
to be created variant and will be passed
a variant filter object you can use this
object to inspect the build types and
the flavors of the variant in question
and you can also set the ignore flock on
it
to indicate that this particular
combination should be skipped so I can
think of the variant filter object of an
instance such an interface when there's
one setter for the ignore flag and there
are Gators for Bill types flavors and
the shared settings from the default
config shared between all the variants
all right let's talk about vector
drawables which is a feature with
additive 1.5 so what vector drawable
support does at Build time is whenever
we find
an Android vectordrawable XML file in
your drawables directory we will rename
this file to be within the any dpi v21
directory and we will also generate a
number of PNG images one for each
density for all their devices to pick up
you can control the set of densities
that we generate so if you don't want to
package low dpi images in your apk you
can choose to do so this setting is
perforator
so you can have a default a set of
densities in default config and then
override it for a particular flavor and
you can also set the set of generator
densities to an empty list set which
will disable the whole the feature all
together ok lastly since we have some
more time left let's just mention real
quick buildconfig buildconfig is a class
that we generated build time for each
and every variant you can use it to
inspect which a build type and flavor
were used to actually compile your given
variant you can use it to at runtime
execute different code depending on a
given flavor so for example you you may
want to write an if statement that
checks if flavor is premium and you can
also add additional fields to the
buildconfig class by using a build
config field method on build types but
also flavors so in this case if I really
want to hard-code the build date into my
build config class I can do it at the
mention of the start I will only do it
for the release builds so for any in the
release builder I'll put a string field
called build date in my class the values
are put pasted as as is into the build
configure a source file which means you
have to make sure this the quotes are in
place here I assume there is a format
time function somewhere in the build
script so that will allow me to actually
reference the build date in my release
builds for debug builds I want to
hard-code a constant value so so that my
bills are actually up to date you can
imagine that if format time actually
changed every second my bills would
never be up to date because every time I
learn unruhe I run Gradle build config
source would be different which means I
would have to compile it which means I
would have to read that
entire application every time just
because this value changed which is why
we recommend to do this kind of stuff
only for release builds never debug
builds and if you need to you can also
define the res values which would do the
same thing but it would put the values
in the as a value resource to the string
resource okay yeah that's it that's all
we have for you today let's go into the
Q&amp;amp;A session there's two mics in the back
if you want to ask questions please go
there we have time probably for just a
handful of them yep I have a question
about shrink resources I see my PNG
files are not in the built apk but the
IDS are still in the art of Java file
and it's causing weight crisis on and
send some devices and I saw a solution
was to replace those PNG files alike one
pixel resources okay can you say
something about that about so the way
the shrinker works is that it looks for
code that uses those IDs right but it it
is not removing the DR class I would be
surprised why on some devices they
actually like if your code does not
reference that ID and we were trying to
be very conservative you know we just
you know some cases where we don't
remove stuff that could be removed
because we are not sure it's difficult
right we just look at the bytecode we
don't know the actual code we just say
hey thoughty2 okay maybe that's a
resource ID so when we assure that that
ID is not available anywhere we remove
it so I'm not sure why that would still
be called on some device simply either
but there's a bug report for that so
remember that Samsung was pre-caching
and the idea would find in the
application something like that yeah I
don't have a good solution for you in
that case I think the good solution for
now is shrink resources fools I mean we
could we could also rewrite the the
r-class to remove things the thing also
that you are doing is you are just
removing the assets right we are not
actually removing them from the resource
table so it
I thought it was a mirror I would put
the smallest possible PNG to replace the
actual one
so that Samson would be happy would find
it so but it still doesn't work I don't
believe that that thing is happening
right now so okay we should we should
talk about that because I thought it was
already a decision okay is there a is
there any development on native via
native dependencies that would actually
also bundle headers in the case of
native dependencies that would be
deployed to MPN repository for example
no I actually don't know a that probably
more question for greater right like if
you if you have a module that only
outputs a dot a so and I know you can
have you know headers because you the
the inter module dependencies you box
that at the greater level but I don't
know what happened if you try to publish
that to any sort of repository you would
have to check with Gradle itself I've
seen hands somewhere so is it possible
to debug why instant run decided not to
do an instant run on a particular
instance like if you change the feel
that can tell you like it's because you
changed this field
yes if you change to if you add a field
and the instant when I decided that he
needs to be stopped is that what you
asked
yeah but like I just wondering is there
some sort of logging that I'll tell you
I yes why IDE will tell you application
we started because you added a field or
because the static initializer a
stranger because we added a method it
will tell you is that the balloon eyes
it's a balloon when you when you run
there will be a balloon that tells you
we started because of their way when you
build a debug bill to make it have a
different package name as release film
yes in bill type there's something
called application ID suffix so if you
do any suffix that and it happens that
to your regular package name so if you
put debug then the debug build will
contain that new package name and you
can start it side by side with the
release okay you have like custom views
in
no files to those upgrade no then you
would have to make a copy of that
particular layout put it in the source
debug res folder so that you would have
a custom version of that we know that
it's something that people want to have
place order in those and to replace them
on the fly and something we will
probably do at some point okay thank you
I think we're running out of time we
will be at the office hours all
afternoon so feel free to come and talk
to us and five sachet also this
afternoon if you want to ask question
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>