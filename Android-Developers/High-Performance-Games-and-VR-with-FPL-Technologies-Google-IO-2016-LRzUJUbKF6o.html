<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>High Performance Games and VR with FPL Technologies - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="High Performance Games and VR with FPL Technologies - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>High Performance Games and VR with FPL Technologies - Google I/O 2016</b></h2><h5 class="post__date">2016-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LRzUJUbKF6o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today we're going to give you some
compelling reasons why you start
thinking about performance in your games
and VR experiences and we're going to
show you some of the texts that our team
has developed to help you create
high-performance games but first let me
introduce my good friend and colleague
walter van Orbison so water has a
background in game development he's
worked on Crytek Maxis and also a
gearbox so one of my personal favorite
games Borderlands water Tod game
programming at the guild hall and he's
created several open source game engines
and languages my favorite of which is
the deliciously named lobster water also
speaks six natural languages seven if he
include the one he invented when he was
a teenager and that only he and his
little sister understand overall he's a
lovely fellow and I recommend getting to
know him alright thank you Jason so let
me introduce Jason to you so Jason also
has a game development background
particularly in animation before he
joined Google he was working at
Electronic Arts where his locomotion
system was powering the Madden and FIFA
franchises so recently Jason led the our
team to create our most recent sample
games Uschi that's available on the Play
Store we'll see it later and most
importantly I think that Jason stated
life goal is that he is wants to acquire
all life's acquired tastes so I think
you should join him in that thanks water
Walter and I work on a team called fun
propulsion labs at Google our mission is
to support game developers just like you
by creating cross-platform open-source
technology that you can use in your
games and not just games that you're
making now we also want to ensure that
you're set up with the right technology
to help you make great games in the near
future too so today we're going to talk
about 3d games in virtual reality and
why we think they're going to be
increasingly large blips on your radar
why they're difficult
and finally we're going to present some
technology that we've created in our
team that we think will help you succeed
in 3d and VR along the way we'll show
you some of the small sample games that
our team has developed to demonstrate
our tech for example this year this is
pie noon it's a multiplayer standoff
game but with cherry pies it's pretty
serious stuff that we do but first thing
quickly why games serious developers
make serious apps don't they well games
are big business I mean look at the Play
Store the majority of revenue from the
Play Store comes from games yes and the
game market is expanding to new
demographics too as you can see here the
demographic that likes say men screaming
with their mouths open that's pretty
well served today but going forward new
game genres are becoming more and more
popular as well so entire new
demographics are going to come online
and become game consumers too but maybe
they just have their mouths open because
they like the candy in the adjacent
games that it is exactly the same face I
made this morning when I saw the donuts
alright so games make money today and
they're going to make even make even
more money tomorrow but why do we care
about performance games are pretty
simple no it's true that many of today's
games are technically simple here's some
of my recent favorite games does anybody
recognize these games just just call out
the names ridiculous fishing of course
anyone else how about the one in the
middle that's kind of obscure it's
called the guides very odd game worth
checking out and on the right is pop the
lock so all of these games have
wonderful visual aesthetics but
technically they don't really tax the
hardware so games like these should
probably still be optimized you know for
low-end devices or just to save battery
but for the most part you know
performance is not going to be on a
radar for these kind of games but there
are games that do text the hardware and
as game players get used to these kind
of visuals
you know they're gonna be expecting them
anyone know this game that's right the
wolf among us by Telltale Games so this
game was released in 2013 on the Xbox
the PlayStation Windows and Mac and then
soon after it was also released on
mobile so these screenshots are actually
from the Android version and I think
they look amazing so mobile hardware is
getting increasingly powerful but so
console game developers are increasingly
going to bring these kind of games to
mobile and that's exactly what they're
doing yeah
for example some of my friends that are
still have people soccer when they
released it steepest 16 this year they
they're using a lot of the code that I
wrote three years ago before I joined
Google and this is code that we really
struggled to make run on the consoles at
the time but they just poured it over to
mobile devices and it runs fine and in
fact this is something that a lot of
console developers really have to do
because the mobile game market is
growing much faster than the console on
the PC game market so they need to start
bringing over these console games to
mobile and then there's virtual reality
which is intrinsically a 3d experience
so we think that you're gonna see more
and more of these kind of experiences on
mobile pretty soon and less of the
examples that we gave previously of
course there's gonna be plenty of both
styles of games 2d 3d simple complex but
still cloud slow games on mobile it's
gonna raise consumer expectations just
like water says and this means if
performance is an on your radar today it
probably will be in the near future so
we're gonna have to start thinking about
performance but how much do we have to
start thinking about performance what
happens we get it wrong
good question so this game is ten gummy
it's it's a really beautiful smoothly
animated game the paper craft world and
it's kind of folds and unfolds like
origami as you go through the world it's
it's strangely calming and kind of Zen
like so for 3d games like tengami you
want to ideally hit a fixed frame rate
of 30 to 60 frames per second when you
get performance problems then you're
gonna drop frames and that's gonna
create stuttering now if your game is
mostly static without too much motion
you may be able to get away with like a
little bit of stuttering but if you have
smooth scrolling like you know tengami
has here or a lot of camera motion then
that's stunning is going to end up being
pretty jarring and drop frames are even
more of a problem in VR so for cardboard
you want to hit at least 60 frames per
second you might think well if I had 59
frames per second that's good enough
but in VR every drop frame is like
snagging your eyeball on a rusty nail so
you're saying that if I had 59 frames
per second that is like hitting my
eyeball on a rusty nail like once per
second effectively exactly how the math
works out so in less dramatic terms
dropping frames means user fatigue and
discomfort and potentially even nausea
so and let's not forget about the next
billion users there's like a billion of
them after all and they're gonna have
modern phones but they may not be the
fastest phones for example the Nexus 6p
and the Android one are both great
phones but just because your game runs
great on Nexus 6p is not gonna mean it's
gonna run great on the next billion
Android ones even if you hit 60 frames
per second it's still worthwhile
considering performance because wasted
CPU cycles mean wasted battery and
battery is pretty important to mobile
game players so when you're playing like
a simple 2d game and your phone heats up
like it's a pocket warmer that's a good
sign that the developer wasn't
prioritizing performance so you said
that mobile is going to become more like
a console experience what does that
imply well let's take a look at how
current mobile game development differs
from current console game development
and that might give us a sense for where
mobile development might go so first off
mobile development teams are quite small
console development teams on the other
hand
come in all sizes some of them quite
large with a small team you have to
limit your technology but with a big
team your technology stack is going to
be correspondingly large so to put in a
different way many of you may be
familiar with the idea of like a thin
client thick server model that's very
common in web apps and mobile apps so
what you get if you take mobile gaming
and you add console style technology if
you get more of a thick client thick
server model where you're doing you know
intensive rendering physics animation
all that on the client and you're still
going to have a rich server side
component so that gets pretty
complicated right ok then so when we're
working with these more technically
complicated clients what are some of the
performance problems that we're going to
run into so let's first talk about
memory
unlike consoles you don't really have
guaranteed amount of memory on a mobile
device and unlike pcs you don't really
have virtual memory either so what that
means is that it really depends in a
situation when Android is gonna tell you
that you've had too much memory so the
only way to make sure that your game
fits in memory and stays in memory is
used as little as possible of it and
there's not a good reason memory
bandwidth on mobile devices is very low
compared to equivalent PC or console
devices so you may see a mobile device
and you go like wow that thing has like
eight cores in it and stuff and until
you realize that if those eight cores
all start touching memory then things
grind to a halt pretty quickly
then there's the thermal consequences of
using a lot of resources your CPU is
going to get throttled so mobile
hardware was designed for apps which
means they're designed to wake up
serve the youever user and then idle for
a little bit and when it idling it gives
the CPU some time to dissipate heat but
games on the other hand are kind of
using the system evenly at all times so
this means that the heat can just kind
of build up and build up until the CPU
frequency
to be throttled back in order to
dissipate it and because you don't
control this throttling it kind of has
this ping-ponging effect on your
framerate which is exactly the kind of
thing that's gonna make your VR users
nauseous okay so we need to hit 60
frames per second with no drop frames
especially when targeting VR so that's
gonna be hard to do in C++ and frankly
it's almost impossible in Java now
there's probably some Java programmers
in here so it's probably worth diving
into this a little bit maybe you can
tell us a little bit what performance
challenges people see when they develop
games in Java well first of course Java
has garbage collection and garbage
collection does not help you keep a
stable framerate because the garbage
collector is going to hit at a
particular frame give you a very lengthy
frame and then another frame is going to
be shorter that's exactly what we don't
want but even besides that typically
Java code is going to be slightly slower
than equivalent C++ code for CPU tins
and stuff like you know physics
animation simulation that kind of thing
so even if you can make it work even you
can make it fit somehow then you're
gonna end up burning more battery and
generating more heat than equivalent C++
so it's a really tricky situation and
it's one that's worth considering very
carefully because choosing a language is
something you do at the beginning and
optimizing your program for performance
is unfortunately something you tend to
do at the end so if you get to the end
of your project and you have a lot of
trouble squeezing out performance
because of the intrinsic nature of your
language well that's a real sinking
feeling and of course with C++ you get
this cross-platform nature for free I
mean on mobile and desktop platforms and
cross-platform is increasingly important
as the games become more complicated so
writing your game twice for two
different platforms in two different
languages is a very high cost to that
okay we understand this is challenging
C++ is kind of like a double-barreled
shotgun but with a thousand barrels and
they're all pointed at your foot but
that's where our team comes in we're fun
propulsion labs and
here to help that's our logo by the way
so what do we do so we make C++ game
development libraries these libraries
are cross-platform so they work on
Android iOS Windows Mac Linux probably
on consoles but they're not part of our
test Suites in some cases they work on
the web - they're all open source
they're all on github right now you can
go download them if you like and we've
created them both for external
developers game developers and also for
its internal users at Google that's
right they're all independent libraries
as well so but let's stop for a second
here probably people have the question
is like why libraries most people will
have an existing engine right so from
what we've seen more than half of game
developers are actually using a custom
engine so there's a lot of game
developers that don't want to buy into
monolithic third-party technology so by
providing separate libraries we allow
game developers to adopt our technology
piecemeal they can just use whatever
they need and fit it with with what they
already have and even if they are using
a third-party engine if there's
something out there that they like they
can just grab that and drag it into
their engine as well great so let's talk
about these libraries and how they can
help you make more efficient games okay
excellent let's start at the bottom
water how do we store stuff well for
that we have flatbuffers which is our
civilization library it works for games
and it works for anything really as
you'll know civilization is about how we
load store and encode stuff and that is
very vital for a memory efficient game
now what a special about flatbuffers is
that it is a format that works equally
well on disk and in memory so you don't
actually have to unpack it Wow
nice one so this saves on parsing time
it means you don't have any object
allocation whatsoever it generally
reduces memory usage and it is more
cache efficient so what I'm going to say
is if your project game or not if it
uses JSON or protocol buffers or some
other sterilization solution you can
probably benefit from using buffers let
me interrupt there interesting fact that
JSON format is so amazing they named it
after me that it's not true it's not
true but it is a good idea
which is why flatbuffers has JSON
parsing built-in right yes languages so
we originally designed flatbuffers for
c++ and game development but we also
have support for your favorite
programming languages language assuming
your favorite programming language is
one of C C++ Java c-sharp
Go Python JavaScript PHP swift etc so
and that's just in case that your tools
or servers are written in something
other than C++ and sometimes that makes
a lot of sense sometimes so ok you know
what's also fundamental is all this math
that games use how do we deal with that
we have a library called math foo and it
implements a lot of common geometry
functions and it's designed to be simple
and fast so by geometry we mean the math
on vectors and matrices usually two
three four dimensions sometimes more
rendering physics animation AI they all
use this kind of math anything that
deals with physical space and
calculations within it of course there's
other open source math libraries out
there some of them very good like eigen
and GLM but we wanted one that was very
simple and focused on the math that was
required for games and not necessarily
say for scientific applications like
eigen is very good at
we also wanted to make a library that
was extremely fast because it's the
foundation for all of our other
libraries so we spent a lot of time
benchmarking math foo and optimizing it
where appropriate for example many of
the functions use Cindy instructions
especially the matrix operations so this
is like SSE instructions and neon
instructions these level these leverage
the vector processing unit on the chips
get I think you're losing the audience
Jason am I really
yeah anyways technical it's fast so we
have data and math water what do we need
next so fpou base is our lowest level
game library that we use for rendering
inputs loading resources things like you
know shaders meshes textures anything
that you need to get a game on screen
basically it also has useful
functionality for dealing with n or
input devices and VR it also started
resource loading FPL base was intended
as a way to go from like an empty
project to drawing something on screen
as fast as possible that little code as
possible
so it has all the minimal functionality
that you typically get particularly
don't get when you work on top of raw
OpenGL now it's on purpose not meant to
be an engine it's not dictating how your
game should be structure or anything
like that it's just meant to be simple
and easy and quick to get going so works
on all platforms mobile and desktop
right thanks to SD l SD L is the simple
directmedia layer and other FPL
libraries may be used on on top of it so
now that we can render things what's the
next thing to make our games come to
life so animation I think is a really
great way to bring your games to life
you would say that and motive is our
animation system it's a really great way
to bring character and charm to your
games animation is kind of intimidating
to a lot of developers there's just a
lot of ways to move something from point
A to point B and some of them have a lot
of feeling and intent but others just
kind of look robotic so the goal of
motive is to make it easy to animate
everything smooth and intensely so to do
this we made the runtime extremely fast
because often there's a lot in your
scene that needs to be animated it
computes values in bulk with assembly
instructions I was talking about the
memory format is also very compact and
this helps with the memory bandwidth
limitations that's intrinsic to mobile
devices with motive you can drive
animations with pre offered splines or
you can also drive it procedurally to
say naturally move matching follow a
moving target okay so now we're going to
show you one of our sample games high
noon to give you an idea of how simple
motion can help bring a game to life
okay so most of the animation in pionen
is actually procedural but in our next
game sushi we support fully rigged
character animation so the dapper
crocodile here will do a little jig when
you feed him a piece of sushi as you
would expect and the dig animation is
created using third-party animation
authoring tools like Maya or blender and
it's brought into our game via and
animation pipeline that we've written so
we'll show you videos you see in a bit
okay water so we've got this game
animated how do we communicate with the
user well for that we have flat UI so
flat UI is an immediate mode UI library
that's meant to make it simple easy and
efficient to add menus a 2ds and other
elements to your game so let's talk a
little bit about like what this
immediate mode saying means it means
that rather than constructing your UI
using objects and callbacks and things
like that
you actually construct UI by function
calls that you create your UI every
frame again now that has a whole bunch
of advantages for example first in all
this less code there's less set of work
to do and simple you eyes are pretty
simple to get going it's much you should
do a dynamic UI because if you don't
call a particular UI snippet it does not
appear on-screen so there's no adding
and removing of objects or anything like
that needs to happen it also means that
your UI is always consistent with your
game state because you don't you come
basically can't forget to set some state
on your UI event handling is all local
so it's right there in place when you're
constructing your UI and you have the
data right there so there's no callbacks
happening that might execute on like a
different context or something like that
and it's very easy to make custom UI
elements because you can just combine
multiple function calls into one
for example here's a contrived example
on the slide where we have two UI
elements like a label and a button and
as you can see they're just function
calls the event handling is just an
if-then statement and for the state that
we're managing we can just use any
variable that happens to be in scope
over here
making it pretty simple now flexi wire
has a couple of additional cool features
so first of all has very robust font
rendering that is unicode
internationalization aware it generally
uses amazingly little memory beyond any
textures and fonts that you load it
pretty much uses no memory that's kind
of a theme you're seeing here yeah yeah
exactly
importantly it can render things into 3d
if you're doing VR for example it does
automatically out of everything using
virtual sizes which means that you're
you eyes look great on any kind of
screen and it doesn't dictate a style if
you can render it it can be your style
basically so Jason you already spoke
about animation what else can you give
us that make games come alive one of our
first libraries and one of the more
popular is a liquid physics simulator
called liquid fun liquid fun is a
drop-in extension for the popular box 2d
physics engine it's a really simple way
to add to the liquid gas and particle
effects to your game
the runtime out aggro algorithm is is
kind of clever and it's extremely
efficient so you'd probably be surprised
at how much complicated motion it can
create one of our other sample games
we'll show you here is called liquid fun
paints we'll just show you the beginning
of this trailer so you get a sense for
what the library does
okay so that's the idea that's a really
fun app you can also find in the Play
Store a lot of kids love it all right
like welco our next library is thanks
Jason
so our next library is pin drop which is
our audio solution so pin what's special
about pin drop is that it goes beyond
just mere audio mixing for example it
handles prioritization and attenuation
that means that if you have a game scene
and suddenly there's a lot of events
triggered a lot of gameplay events
trigging a lot of sounds that the system
will automatically take care of making
it into a coherent audio picture for you
basically it also allows you to group
and selectively override relatively
importance of whole groups of sounds for
example if you wanted to make sure that
like voiceovers get heard and things
like that
none importantly it's very data-driven
which means that the people that author
the audio don't need to do any
programming sprinkle corgi is our entity
component system now entity component
systems have emerged as a popular
programming paradigm in games so they
allow you to associate component
behaviors with entities in the scene for
example suppose I wanted to I could add
an animation component to a dog entity
and this would allow the dog to roll
over or we can add an audio component to
the dog and that would allow the dog to
bark and instead of storing the roll
over embarking data with the dog entity
we instead group all the animation data
in one spot and all the audio data in
another spot and this allows you to have
significantly better memory performance
when you're operating on data in bulk as
you have to in games so note the
contrast here between object-oriented
programming and component oriented
programming so
the behaviors and the data are stored
with the entity in object-oriented
programming right so entity component
systems there's nothing new if you're
making a game you probably have your own
so what we've done with Corgi is simply
package and document well the one that
we wrote and put it up on github for you
to use if you like Corgi by the way
stands for component organized reusable
game interface but mostly we chose the
name because of this guy he's he's kind
of our unofficial project manager on FPL
I mean you can't say no to those eyes
right so scene lab is our scene editor
scene lap kind of takes all these
previous libraries together so it uses
Corgi for the object edit edits uses
flatbuffers for all of its data of
course and I use this flat UI the cool
thing about scene lab is that it's so
data-driven so configurable that if you
pass the different kinds of object
definitions you'll be it will
automatically allow you to edit
different things so it's very easy to
kind of swap into a different game and
have an editor specifically for that
game
our last library is called breadboard
it's an event system that allows you to
connect disparate systems using data so
every game has different systems like
audio AI and the UI and you want to keep
these systems separate so that they
don't have to make function calls into
each other otherwise you end up with
spaghetti code so breadboard lets you do
this for example you could take a
football event from the animation system
and route that over to the audio system
which would then play a stepping sound
and the two systems they don't need to
be connected with function calls
breadboard also supports some arbitrary
logic nodes so you can route events a
little bit more cleverly if you like Wow
look at all those animals so you knew
this was coming this is where we take a
look at sushi our latest game and in
sushi you float down a mystic river
feeding sushi to well-dressed animal
patrons it's a 3d game it runs in VR at
60 frames per second so that's pretty
high performance even though it's like
cue characters on the screen
the gameplay is very simple this is
actually technically a high-performance
game and everything the world is
animated
it has a UI audio level editor so even
though it's a very simple game the
technology stack has everything that you
would need to make your own
high-performance VR or 3d game and the
technology stack in Zushi is the
libraries that we just described to you
okay so go
you can do it there we go
okay so all the data in that game is
stored in flatbuffers it's edited in
scene lab and using scene lab we can
also add Corgi components until all the
entities and FPL base is used to render
everything and two for input and
resource loading motive animates all the
motion in the scene and flexure why
shows the menus pin-drop plays the music
and sound effects and finally breadboard
connects all the components together and
allows us to define a game flow in data
like Jason said okay it's worth noting
that all the sample games that we showed
you today are also open source so you
can go to github download them and use
them to prototype your own ideas in fact
the social good team here at Google has
done just that this is this is the team
that powers the donations through Google
org and they also drove the newly
launched donations card on YouTube
they're doing a lot of good stuff
so what they did with pine hoon is to
create a prototype of their new
donations API this is an API that lets
users make in-app donations and then
it'll automatically process the payments
and the billing there's no fees there's
no spam sent to the users and most
importantly it has the ability for you
the developer to support any us-based
nonprofits so basically you're
encouraging gamers to support real-world
causes from within the game I think it's
a pretty exciting API and you should
check out their work at this link here
and speaking of links alright so if you
want to play around with any of the
technologies that you've seen so far
this is our developer site yep
all these links and links to all the
libraries are in the space for this talk
as well so thanks for listening we hope
you're excited to create
high-performance games and we hope that
our technology can help you with that so
we're gonna have a Q&amp;amp;A now
and if you want to talk to me Jason
afterwards come come find us we're here
to help</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>