<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Best practices in media playback - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="Best practices in media playback - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Best practices in media playback - Google I/O 2016</b></h2><h5 class="post__date">2016-05-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iIKxyDRjecU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone let's get started I'm
there's like four more seats right here
in the front an on-stage I'm not gonna
bite anymore it's fine
hi my name is Ian Lake I'm a developer
advocate at Google I focused primarily
on the android framework and support
library but more specifically on the
Android media framework I'm here to talk
to you about best practices in media
playback so a very simple goal today and
that's basically just to tell you when
choose the right api's to build the best
audio or video playback app possible so
throughout this talk I'm gonna be
talking about a lot of these things in
terms of certain events in your media
playback lifecycle so you can imagine
you have any kind of media app is gonna
go through all of these phases at some
point so created it's obviously kind of
our one-time initialization step and
then we go into playing and for playing
what we're gonna talk about in playing
is actually outputting sound right
playing a video playing audio that's the
playing state and on the opposite side
is paused so pause is gonna be our
shorthand for basically any temporary
state where we're not actually
outputting any audio right or any video
and at some point in our life cycle sad
as it may be the user may actually exit
out of our app and at that point or
you're going to go into the stopped
States right that's kind of the
permanent state route the user has moved
on from your app to maybe a different
app or they've just stop playback
entirely and of course that triggers
then ondestroy
which would then clean up all of our
resources now I was talking about media
States right and those are slightly
different than our Android lifecycle
events I know but so there's two cases
one if you are a video
and how many people here are doing video
apps alright quite a few and audio apps
nice nighttime both who's the
overachievers yeah you guys nicely done
so for video you're gonna be sleek aynd
of tied to the activity lifecycle and in
this case of course when I'm create is a
great place to do our one-time
initialization destroy for our cleanup
that makes sense
things have changed slightly with the
introduction of multi window for Android
n here previously 2n actually the on
stop command might not be called
immediately after your activity ends so
some might hit the home button and you
might actually not get on stop for 5
seconds afterwards and if you're a video
playing app you may not want to be
playing audio and assuming to play video
for 5 seconds while your apps in the
background so in this case we probably
actually want to stop playback in on
pause right because this will be called
immediately when you become not visible
or at least in the background now on and
plus obviously that'd be a disastrous
idea because things running side by side
you'll be paused but not stopped
remember stopped is when you become not
visible so we've actually increased the
guarantee that on stop will be called
immediately so that makes it the perfect
place to actually stop playback is on on
stop now for audio apps or if you're
doing remote playback feel Google cast
you're going to be in a service but
that's kind of where we do background
work in Android and here we have kind of
on create or created on destroy run
destroy so in all these cases these are
Android lifecycle events that are going
to be triggering a change in your media
playback all right so you know we didn't
have anything in the play and paused
States for this that's because those
aren't actually tied to Android life
cycle things those are tied to user
interaction
that's where we were gonna spend the
vast majority of our time here today so
wouldn't be much of a media playing app
if it didn't actually play media so
everyone went to the exoplayer talk know
the lines was huge fine
I understand it's okay because
everything else in this talk is not
going to depend on you knowing exoplayer
actually everything is here is player
agnostic so from the Android media
framework perspective it actually
doesn't care if using exoplayer or media
player or some custom player that you're
forced to use it's fine they all work so
for example if we were using media
player mapping this on to kind of our
state for media playback it's very
simple right on create we're going to
then create a new media player playing
we're gonna prepare pause pause pause
stop stop destroy it release right so in
this case it's a very simple flow this
kind of gets us in the idea of what
these media events are actually meaning
so we'll it plays the pause we're done
right wouldn't you all go home well like
I said everything is player agnostic
right so this actually doesn't tell
anyone anything about what you're doing
right and really we're trying to do this
the right way right this isn't just
playing audio this is making a great
user experience for users right we want
all of our guys to be happy like that
guy right you don't want any sad
sunburned faces here but happy people
right so let's do a little bit better
and there's actually a whole bunch of
things that we're gonna cover today that
actually makes for a better user
experience now these first two audio
focus and action becoming noisy are
really important for local playback so
if you're playing a video or audio on
the device itself these things are the
type of things that are going to make
sure that you're only actually putting
out sound when you mean to now the other
two media session the notifications are
something you should always do whether
you're playing on a device or if you're
you
caste and these are the things they're
actually going to tell the system what's
going on in your world so it can tell
other apps and other apps can do the
type of controls that Android provides
by default so the first thing is audio
focus it's kind of the key to good
citizenship in Android when it comes to
media playback and it's really all about
having apps not talk over one another if
you could imagine it kind of the conch
shell that you pass from app to app
saying you shall now speak and now you
can speak right so this is very much a
last one wins kind of a model so the
last version of the request audio focus
should be the one that the user is
interacting with now this is slightly
different than actually playing audio
we're actually gonna want to hold on to
audio focus through both those playing
and paused state all the way until we're
actually stopped so it's really think of
it more of us and intent to play versus
actually play a slight difference here
so I'm gonna go through a lot of code I
hope you're okay with that
I like code it's nice and easy the
slides will be available afterwards so
don't worry about taking pictures it's
okay you know pictures are great I'm
okay with pictures but it'll all be
available online don't worry and all you
focus pretty straightforward you called
request audio focus when you want to
request audio focus and then you really
want to check to make sure it's actually
granted now in 98% of the times it will
just be granted and you're fine and you
can go play music play your videos but
there are a few special cases where it
actually isn't granted so for example if
you are in a phone call other apps won't
be able to get audio focus right when
you're in a phone call it's a very
specific case where there's generally a
two-way dialogue going on hopefully the
entire time no awkward pauses or
anything
like that so in that case you're
actually not going to be granted
audiofocus so make sure you actually
check the results at all times and then
of course when we're stopped we're gonna
call abandon audiofocus now there is an
audio focus change listener and like the
name should be fairly self-explanatory
but it's all of the events that happen
around audio focus so this is actually
how other apps tell you what's going on
so for example if another media app has
requested audio focus and said I want to
gain permanent audio focus you'll
actually get an audio focus loss
callback and this is like the hammer
that says you're done the user has moved
on they're in the new app they want to
play audio in that app so in this case
we're just gonna stop playback we're
done we want to respect the users wish
to say hey they've moved on to a
different app that has said they're
requesting audio focus now it's not
always a permanent loss right there's
more transient losses so in this case
transient loss means that another app
wants access to play audio and they want
you to pause they want you to not play
anymore media adjust during that time
you can imagine they had something
really important to say for a second or
the voice search and things like that
use lost transient so then you have kind
of a full dialogue with Google just
temporarily without having to have audio
being output at the same time as you're
trying to give a voice query into Google
now the one you're probably most
familiar with particularly from a user
perspective is transient can duck these
aren't the clack-clack ducks these are
the lowering volume ducks as in ducking
your volume so in this case you're
actually going to just lower your volume
but you can keep playing now if you're
an app that's really important that
you're not missing any words say
Podcast up you can't actually pause it's
okay to pause in these cases right it's
important you have spoken words this is
just a suggestion
that you can duck but in any case
whether it's lost transient or transient
can duck you'll get an audio focus gain
when the other app abandons audio focus
this kind of brings you back to where
you were where you can start playing
audio or video at full speed now for
video things are maybe slightly
different in that pausing video every
time you get a notification could be
weird so you might consider actually
just muting rather than pausing it kind
of depends on your use case if it's
really important that the words and
audio are in sync or if it's okay if it
cuts out for that loss transient so a
good way to test this is say like you're
okay Google to your device wall of
videos playing and try and decide what
makes more sense there in a lot of cases
it is pause but if you're doing
something I like Android TV maybe muting
temporarily makes more sense so the
other one is action audio becoming noisy
and it's probably one of my favorite
names from a like totally ridiculous
kind of a name that actually is exactly
what's happening these are lens like you
have headphones plugged in and they
become unplugged and it's becoming noisy
I like this actually makes sense when
you think about it right all of a sudden
we're switching from headphones to
basically the speaker on your device now
in this case you'd rather not surprise
your user right in almost all cases this
maybe isn't an intentional thing you can
imagine someone has it in their pocket
and it gets unplugged it's not
necessarily the best idea especially if
it's you know audio playback so in this
case we're just gonna pause and then
they can at the play button if they want
now in this case we're creating this
broadcast receiver programmatically it's
not in our manifest
and actually we can't use manifest ones
or these and that's okay because audio
the becoming noisy is actually tied to
when you're outputting sound right this
is only in the playing State it's you in
this case as soon as we pause right
we're not actually playing any audio or
video then it's okay to unregister over
here right like unplugging it when it's
not actually outputting anything it's
not something we actually care about so
now we can update our chart we have a
few more items in here so we can see how
the life cycle is slightly different
between audio focus which goes all the
way until we're stopped and becoming
noisy which is only when we're actually
outputting sound now at this point this
is everything we need well if we're
running on API 7 devices who has a 2.1
device nobody we're we have to do a
little bit more if you actually want to
take advantage of everything that
androids offered since 2.1 and a lot of
this is just because user expectations
have changed androids changed things
have changed a lot you can imagine now
with Android wear and Android auto and
Bluetooth headsets actually taking your
phone out of your pocket to pause might
actually not be the thing that users are
used to if they're out on a run it's not
something they're going to do alright
similarly if you have controls on the
android TV remote they want that play
pause button to actually work right
similarly like they may not actually
want to unlock their device right aren't
they expecting controls on their lock
screen similarly do they even need to
enter your app at all if you have
notifications there's actually little
reason to go into your app specifically
just to pause or play or skip to the
next track all right none of this is
even counting Google cast and remote
playback which wasn't even close to
being a thing
the 2.1 there so we have to go a little
bit front and in lollipop
despite like redoing the whole you lie
thing which whatever is so minor thing
also introduced this fancy class called
media session so media session is kind
of the one-stop shop between your app
and the rest of the Android media
framework so it was so useful to have
just a single point for both sending
commands to your app from say Bluetooth
headsets as well as giving information
to the system that we deprecated a whole
bunch of api's so no more remote control
client yeah all right all right no one's
excited about all right maybe it was
before your time it's okay it's great
but we still want to support older
devices free lollipop so we built media
session compact a backward compatible
back to API for before any of this stuff
actually existed you can still use media
session and it does nothing that's okay
because it also does all the
translations to a remote control client
which would be the Ice Cream Sandwich
through KitKat era of Android does all
of that translation for you so you get
one API to write across all Android
versions which is pretty sweet it's kind
of where we want all of our API eyes to
be so when you're actually creating a
mediasessioncompat it's actually doing a
lot more for you than you might think so
it's actually creating what's called a
token which is actually just a parcel
wrapper around the binder but allows
anyone whether it's the Android system
for Android wear or Android auto or even
your own app to build media controller
commands and these instances actually
allow them to send media buttons to you
to send controls to you as well as read
what kind of metadata or playback state
like are you actually playing something
right
now or are you buffering these are the
important things the system needs snow
about and things like Android wear you
need to know about to actually get your
media everywhere so this is also
something you can use in your own app
for building your UI and we'll get back
to that of them a little bit so when
someone's actually sending you a command
through this token it's actually going
through your mediasessioncompat and into
your callback class now you can imagine
with all these events coming in the
callback class is kind of a big deal
and it is it basically has all of the on
play on pause on skipped next on play
track from search it's got all of the
methods you'd expect for every one of
the actions that could be sent to your
app as well as even custom actions all
come in to your callback class so it's
actually a really great place in your
app to encapsulate all of the media
player calls right all of the exo player
calls all of the Google cast calls can
all be put into that one callback class
because you know when you get an on play
into your callback no matter where it
came from whether it was tapping on a
button on your device or hitting a
Bluetooth headset it all is going to go
to that one place this makes it really
powerful in a way to actually swap
between these things say you have to
support less than API 16 and you can't
live in the beautiful exoplayer world
you can't actually switch those
callbacks or choose at runtime
what callback you want to add it's that
way you can use media player or
something separate pre API 16 an EXO
player on 16 plus and not have to re are
koteki or whole app around just swapping
between these two and swapping out calls
so let's get started with
mediasessioncompat so we created and one
thing to keep in mind throughout all of
mediasessioncompat
is it's very cautious it assumes you
support nothing until you actually tell
it so we have to set a few flags you
have to say yes I actually do want media
buttons from Bluetooth headsets or heads
and wired headsets as well as transport
controls so used to be things like
Android wear and Android auto so we have
to actually tell it every time don't
forget these two lines or else things
will magically fail and you will not
know why it's these two lines and
similar to audio focus this is an intent
to play audio right so in this case
we're actually going to call set active
which says hey I actually do want to
receive media buttons now when we
receive audio focus and then once we
stopped we can actually say no I no
longer is he need any more events I'm
good I'm not going to playback anything
else so we haven't actually told the
system anything right again very
cautious so we actually do need to tell
the system what we're doing right and
this comes first across in playback
state now playback state is built off of
two separate pieces one is the actual
set state itself these are like I am
playing I am buffering I am paused and
this is what gives kind of the control
to say like oh by the way you should
display a play button rather than a
pause button right or you should display
a buffering circle if your buffering
right this all makes a lot of sense to
tell the system what's going on then the
other half of it is set actions now
here's where you actually declare yes I
do solemnly swear
I support play pause or I support skip
to next right not every app needs to
have a skip to next button okay so in
this case you need to call sentence for
each and every one of the actions you
want otherwise that callback or that
specific class won't actually ever be
called so you never say I support
there will be no pause button event sent
to you which is probably not actually
what you want but you have to just make
sure that these stay in sync now of
course these are kind of coupled
together which at first you're like okay
these are all coupled together for some
reason turns out that many times when
you're changing your state you're also
changing your actions I fast-forwarding
while you're buffering probably actually
doesn't make a whole lot of sense maybe
it does but at any point you can't just
create these things together this is the
Builder kind of pattern so you actually
curate a playback state to compact
builder so don't throw away the Builder
every time you can just reuse the same
builder and change just the one thing
you need to I can't just change that
state and not call set actions and then
just call build and call set state so
with this all of our media buttons work
well okay my line it works great on API
21 + turns out it fails completely on
pre API 21 with a nice handy error
message saying Media button receiver
component may not be null okay I'll take
your word on it but what is the media
button receiver component and why do I
need it well turns out that media button
receivers have a long history in Android
but it's something that's changed a lot
so it's just a broadcast receiver in
your manifest that receives the media
button action that's all it does but how
it was used changed before lollipop was
actually required for basically all of
the Android media framework api's so if
you didn't say I have a Media button
receiver with the component then all the
system wouldn't actually route to any
buttons to you you wouldn't show up on
the lockscreen
you basically weren't using any of the
system now technically you could have
used the pending intent on API 18 and
higher so like 18 am 19 and
it was all gone but we actually didn't
add any CTS tests so it fails on certain
manufacturers so for mediasessioncompat
sper spective
it will always need a component in your
manifest registered if you want to use
me to a shrink about prior to API 21 now
it's actually still kind of useful in
lollipop plus even though we have a
media session which on lollipop is going
to be sending you media buttons directly
to your callback in this case the actual
component in your manifest kind of as a
secondary optional aspect where it's
only used to restart playback so if
you've ever listened to Google Play
Music and then stopped playback and then
got into your car and hit the play
button you'll note that Google Play
Music was the one to start I didn't knew
that it would get a start command and
actually start playback that's because
it had registered a Media button
receiver so I really strongly suggest if
you're doing anything with background
playback or something that should
restart you should still register a
Media button receiver on lollipop and
higher because otherwise it will be
Google Play Music it starts up even
though it may have been your app that
the user was last listening to so just
keep that in mind so we want to make
this real easy so we go to class for
called Media button receiver fancy
enough again also in the support before
sport library and as kind of two main
purposes the first is kind of
specifically around that background case
where if you have a service that's
handling your media session which is of
course very common for audio apps it
will auto forward any Media button
intents onto your service where you can
like to actually do something with it
and it'll choose between two things one
if you have any
Media Browser service in your app it'll
choose that first and if you don't have
one of those you can actually add the
same media button intent filter to your
service and Media button receiver will
automatically route it to that now the
nice part about this is that you don't
actually have to write any Media button
receiver code you just add it to your
manifest and that's it you're done right
but that's pretty nice because who wants
to write code right no everyone okay but
the important part is once you get that
intent in your service or in your
activity if you're doing video playback
wherever your actual media session is
then we have a simple one-line command
to actually take in your
mediasessioncompat and the intent and
then go through all of the process of
extracting the key event figuring out
what event that is and then passing it
on to your callback for you so with just
adding it to your manifest and doing one
line of handle intent all of a sudden
you can now use your callback class
normally something that would be API 21
plus now for all API levels so whether
you're using Media button receiver on
older versions or the native media
session stuff on 21 plus now it's
actually more code to enable it on API
21 plus so the 23 versions of the
support library actually did this for
you but as of the 24 versions of the
spotlight the Android end versions
you'll have to do this manually if you
want to do it it's pretty
straightforward you create a pending
intent and to your action Media button
receiver so then you called Media button
receiver fancy enough
so now all of our commands work but
there's more to just commands right
there's another part of
mediasessioncompat and that's around
metadata now metadata comes in a lot of
different formats but it's basically the
what's playing aspect of telling the
system what's going on all right so this
is how like Android wear gets all of
your information on there advice right
or the lockscreen gets the background
art okay so at a bare minimum I'd
suggest a few fields first title artist
album if you have albums the duration if
it's a fixed length track having the
duration actually allows it to display
how far along you are and then of course
a bitmap for the art or the album art
and now this bitmap shouldn't
necessarily be too large
right this is being sent across
processes and to the Android system so
no 4000 by 4,000 pixels bitmaps please
but it is the only way to get lockscreen
backgrounds working so probably should
include a smaller size around the like
640 by 640 size somewhere in that kind
of range or lower just to get something
on there we are looking at future
versions of Android wear the lockscreen
stuff won't actually need a bitmap
itself but you'll be able to use the
other part which is a URI so these allow
you to give a content URI to the app so
that instead of having to keep that
bitmap and send it around through across
multiple processes you can just send a
simple URI and then this is what things
like Android auto already use to get
really high quality artwork onto those
devices
now while there's that's really nice for
lock screen background art we don't
actually lock screen controls on
lollipop anymore that all comes from
media notifications our notifications
are the new hotness guys right and it
turns out that you probably should have
had a notification all along because
they're kind of really useful now
they've come a long way since the very
beginning you could imagine like back in
the 2.1 era you couldn't actually have
buttons in your notification they would
take that so for granted now that you
have to actually have multiple actions
but that only was actually added in an
API 14 so there's a lot of kind of
compactness to this where you're like
alright which versions or what things
for media buttons and that type of thing
but you don't have to do any of that
because notification compat media style
does it all for you now it's still more
boilerplate than I'd like
so I've created a media helper class
that I personally like quite a bit which
takes a context and your media session
and then builds out all of the things
that you need from a notification I'm
gonna post this link in these spaces
after the talk here so keep an eye on
that if you want the link itself but it
actually is using the get description
from the media metadata and this is
actually the exact same thing that
Android wear uses to figure out what
text to display on your device there so
it's a really nice way of staying in
sync and keeps the 27 ish fields that
are in media metadata down to a much
more manageable number which you can
then use for your notification and then
of course the other part that's
sometimes really tricky for
notifications is actually getting the
pending intents for the play/pause
button or the next button and we still
want to reuse all of the things we've
already built right we don't want yet
another custom path
of pending intents to your callbacks so
in this case we can actually build these
intense pretty simply just by using this
get action intent method which is
actually going to reuse our Media button
receiver we include it in our app we're
gonna reuse that and kind of fake it so
that it's like a media button came in
but it's in fact a notification so this
way we actually get all the stuff
already there so we create our builder
using the media style helper and then we
you set a small icon it's kind of need
those four notifications and then we
need to call set color now much review
notice like the play music and stuff did
not actually use a bright orange for
their color because it turns out that on
the lollipop through marshmallow devices
this was the full background for your
notification so like the giant bright
pink that you use for your branding for
your app probably not the best color to
use here you'll note in Android n it's
actually much more aligned with all the
other styles where it's just used as an
accent color not actually as the giant
garish background for the notification
so baby steps but keep in mind for color
this might actually be something you
want to check your version API version
on and it wouldn't be a very useful
media notification that didn't have any
actions so in this case we're adding a
pause button to our notification and
using get action intent in this case
just passing in the play/pause key event
just to say like hey this is a play
pause button and now this will trigger
all of the same logic as if someone had
hit the play pause button on their
headset so they don't actually need to
build any more code to support these
actions and then of course we want to
add our actual media style itself so
media style has this great property
where it supports both an expanded style
write the two line style whereas larger
album art and up to five actions as well
as it compact
to view right where you've got only a
max of two actions on that compact view
but it still works and so you'll need to
actually tell which actions you want to
support in that compact view you can
imagine if you had you know next track
and then play pause and then previous
track right you wouldn't probably want
to support the play pause action as the
highest most action because that's
probably the one the users will want to
use the most it's a zero based based on
the order you called add action the
other thing we really really important
don't don't forget it again this is
another like this will break you if you
forget it is calling set media session
now this adds our session token that we
talked about before to the notification
so this is what things like Android wear
are actually using to get a reference to
your token so if you forget this all of
a sudden you'll get things like well the
notification shows up on where right
because we added the metadata and all
that but then you hit the button and it
doesn't actually play pause which is
probably the most frustrating thing in
the world so don't don't forget this
line again so at this point we actually
have what I would call the Minimum
Viable Product this is kind of what I
would consider something that I won't
yell yell at you for so you actually do
all these things I'll be reasonably
happy and I would say this applies to
all apps whether your video or audio
these are things that you're going to
need to do but of course we're much
farther along and we don't even know how
to build a pause button for our UI so we
have to build a UI it's kind of a big
deal for apps right and we mentioned
media controller compatible for this
because it has access to all of your
metadata and everything else so we can't
actually create a media controller
compat either from the token or from the
session itself and fragment activity
actually has some really nice methods
and make it easy to
and then get the media controller at
some point so here we can use just
transport controls and say pause and
we're using lambdas here so it looks a
little weird but it's lot shorter on
flights which is awesome but the
transport controls is basically the
one-to-one with your callbacks so you
can imagine there's a play/pause and a
skip to next which then triggers on play
on pause on skip to next alright want
one but of course just having a pause
button doesn't actually do a whole lot
for your UI you want to keep these
things in sync
right so you can imagine in the old days
where you had a service that was doing
things you had to create some custom
situation to actually pass information
back and forth now you don't need to do
that anymore because media control or
compat gives you all of the things you'd
need so get metadata to get the metadata
get playback state to get the playback
state but all of these things are
one-shot so you probably also want to
use a callback so here you get a on
metadata changed on playback state
changed and this actually allows you to
stay perfectly in sync even across
processes so you'll actually be sent the
information immediately when you call
set state or when you call set metadata
it comes across on the other side now
all what I've talked about has been
great for video and audio but if we're
doing background playback with a service
that adds some extra complexity because
we can't just we don't have our media
session token' in our UI so we need to
do a little bit more and we still need
that token oh ok so we built a class for
that to actually Media Browser service
compat does a lot of this stuff for you
besides the actual browsing part which
if you go to any of the Android auto
talks will be like the key for them we
can actually do this in our own app so
to actually build a Media Browser
service compact it's pretty
straightforward you have an intent
action to Media Browser service the
what calls you out as a video browser
and then you extend the class and then
there's one method which again if you
don't call it it breaks everything at
set session token' where again we kind
of gave the token to Media Browser
service and there's two other methods on
get root and onload children which are
required to be implemented these are
really important for Android auto but
for us we just need to know that you
need to return something not null and on
get root for any connections to succeed
so in this case I'm just saying am i
calling myself good all right great
here's a root that gives you no children
back and wrong with our life so if Media
Browser service compat was one side
Media Browser compat is the other side
this is what you'd actually use in your
UI to connect to your service so in this
case we pass in the component name and
we call connect and it's actually
binding to your service and doing all
that stuff for you but the important
part is when you get that connection
callback we call unconnected and we'll
be able to call get session token' and
go about our wonderful ways of hooking
our whole UI up and getting all our
information and setting up our callback
and on and on and on and on and like I
mentioned all of this works across
processes so you've not had to touch
Android IPC or a IDL's
or any of that fun stuff but it turns
out that you can actually support
multiple processes and if you're doing
audio playback in a service it's
actually probably a fairly good idea to
have a separate process so when you have
very different parts of your life cycle
it's really important to keep that long
term memory usage as low as possible
all right if someone's gonna be playing
audio for multiple hours you don't want
to be taking up extra resources and
Android only kills things at the process
level so if they ever open your UI that
UI piece is gonna stay in memory as long
as your services
so using a separate service is actually
a really good idea for many reasons
including things like the webview
process being updated if you're using
webview in your UI process that's gonna
be killed automatically and we don't
really want to pause our music just
because what have you updated it seems
kind of silly and actually we never
really want to pause our music if it's
actually playing we wanted to continue
on forever so to do this on Android
we're using a foreground service now
foreground services have one property
and that they require a notification but
that's okay because we just built our
notification so for media it actually
makes a lot of sense to use these things
together but there were some problems
the notification used for foreground
services are ongoing ie they can't be
swiped away so you can imagine how
frustrating is a user you're trying to
swipe away that notifications like I
just want to stop playback it's fine I'm
good but they can't if you're using a
foreground service and it turns out
there's been a bug for like six years
we're stopped foreground false didn't
actually make it dismissible even though
that was no longer foreground service
and the notification was still there it
would still be ongoing and you still
couldn't swipe it away so we fixed it as
part of media style basically by adding
a little X in the corner very very
low-tech solution but it allows users to
hit that X button and allows them to
actually delete the service in this case
we're just sending a stop command now on
lollipop and higher once you call stop
foreground false you can't actually
swipe to dismiss a notification so this
basically does nothing out a lollipop in
higher devices
now I also mentioned that Media Browser
service and Media Browser compact are
binding to the service which is great
because that means that your service and
your process is already up when someone
hits the play button so you can
instantaneously use start playback but
it also means as soon as your UI dies
your service is going to die with it
because they'll be unbound and there's
no one button to it and you're dead but
that's ok we'll just need to call start
service when we start playback and that
way we make sure our service will
continue even when our activity dies we
can see our updated life cycle of media
playback specifically for the service
case so in this case our notifications
have been updated slightly to start
foreground when we hit play stop
foreground when we hit pause because we
do want people to be able to swipe it
away when we're actually paused and then
on stop we're gonna remove our
notification and similarly for the
actual service itself we really want to
make sure we call sessiontoken we need
to call start service when we start
playback so we live as long as possible
but of course when the user hits a stop
button or exits out our notification we
actually do want to call stop self so
the system can clean up our service so
what's next
there is a great example app called um
our universal Android music player which
is up on github which uses basically all
of these technologies all in one
including many many more it's a great
app that kind of you can run on your
devices there's also a whole bunch of
other talks which I would suggest the
exoplayer talk which I believe is
already online if you know you're free
tonight after an after party the Android
auto talks there right out this way if
you want to get hands-on with Android
auto as well as Google cast the cast SDK
and Android wear for standalone
so thanks for coming I'll be out here
for questions afterwards thanks again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>