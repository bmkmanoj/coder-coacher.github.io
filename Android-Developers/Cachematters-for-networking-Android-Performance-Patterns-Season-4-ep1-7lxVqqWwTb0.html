<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>#Cachematters for networking (Android Performance Patterns Season 4 ep1) | Coder Coacher - Coaching Coders</title><meta content="#Cachematters for networking (Android Performance Patterns Season 4 ep1) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>#Cachematters for networking (Android Performance Patterns Season 4 ep1)</b></h2><h5 class="post__date">2015-10-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7lxVqqWwTb0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">you know what the fastest most efficient
way to download a piece of content is
not downloading it at all my name is
Colt McAnlis and when it comes to
networking performance properly caching
your network data is one of the most
fundamental performance wins that you
can create at its core reading data from
your device will always be faster than
reading the same data from your network
connection and if you consider that that
piece of data will be used multiple
times and makes a lot of sense to fetch
it from the network and then store it on
the device so that future requests don't
have to redownload the file but a slight
problem here you see by default caching
of HTTP responses is disabled for
Android applications pretty much
everything you're requesting in your app
right now is just dropped on the floor
after it's been fetched turning caching
on means using the HTTP response cache
class which allows you to define a
location on the devices physical file
storage as well as a max size for the
cache to be now once enabled all HTTP
responses for your application will be
cached on the file system and yes this
does apply to api's like a URL
connection and HTTP URL connections and
all the other fancy code snippets that
you copy/paste from
stack overflow examples and don't forget
that this also applies to any HTTP
requests made from libraries that you've
bundled into your application now it's
worth pointing out that with HTTP
response cache data is evicted from the
device in two ways number one if the
cache fills up then the system will
delete the oldest unused files to make
room for the new ones and number two
files will be removed according to their
cache control header information
included with the server responds see
for HTTP 1.1 standards the server will
pass a flag down with your requested
data that hints to the device how long
the information should be cached for so
if the server says something like cache
it for three days then the device will
keep the file around for three days
before evicting it or if the server says
don't cache well the file won't be
cached on the device at all basically
HTTP response cache puts all the control
of how to cache content in the hands of
the server assuming that it knows best
what types of data are requesting and
how the device should use it which is
completely fine for simple networking
such
or if you somehow control the server and
have the ability to set caching
explicitly for each data type but beyond
that you can get into some really big
trouble especially if you don't control
the server for instance what if the
server never sets caching duration and
nothing ever gets cached on your device
or what if the caching values are in
conflict with the physical resources of
the device like I miss estimating how
much free space there is to cache or
what if your client is trying to be
adaptive to the needs of high latency
environments and actually tries to
modify the way it's caching due to those
environments but the server won't let it
because it assumes you're on a 4G
network basically any of these advanced
situations requires you to punt on HTTP
response cache and instead brew-your-own
caching solution which includes two
things number one writing your own
manager to cache and fetch resources
from disk on demand and number two
creating your own caching policy based
on the type of data and the state of the
device itself now writing your own disk
cache can be a bit of a pain so unless
you need something custom it's probably
a better idea to steal the disk LRU
cache Java implementation from the
Android source and repurpose it for your
needs one of our sample code packages
has already done that for you if you're
willing to take a look now probably more
complex is defining a policy for what
types of caching to do for what types of
assets you're grabbing from the server
see thumbnails need to be cached less
often than high resolution images and
other things like server pings probably
shouldn't be cached at all and you might
want to keep around server responses
that describe UI data for a much longer
duration the truth is that this is all
exceptionally complex and thankfully
there's libraries out there to help make
it easier grabbing the volley or ok HTTP
libraries will put you on a good start
to a more stable networking
implementation although you have to
fiddle with the source code a little bit
to kind of get it to call your custom
caching logic and by the way the image
library Picasso comes built-in with
custom image cache management on your
behalf now if you're not sure how
caching or lack thereof is impacting
your application make sure you check out
the networking monitor tool inside of
Android studio it offers a nice visual
representation of the types of inbound
and outbound requests that are happening
if you're seeing some requests for
content occur
that should be cashed instead it might
be a good sign that you should be
digging deeper which is why I like to
use a TTA ro tool it basically lets you
do exactly that a dig deeper with each
network request even checking out what
types of network header data has been
sent to the device but caching your data
is just the start that's why you need to
check out the rest of the Android
performance patterns content and don't
forget to join our Google+ community for
tips from other developers so keep calm
profile your code and always remember
perf matters</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>