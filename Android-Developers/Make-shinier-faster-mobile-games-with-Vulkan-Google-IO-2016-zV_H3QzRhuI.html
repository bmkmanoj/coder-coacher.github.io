<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Make shinier, faster mobile games with Vulkan - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="Make shinier, faster mobile games with Vulkan - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Make shinier, faster mobile games with Vulkan - Google I/O 2016</b></h2><h5 class="post__date">2016-05-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zV_H3QzRhuI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for coming out to listen we talk
about Vulcan I know it's the first day
of Google i/o and hopefully all the
excitement of the first day hasn't died
down for you yet it's the last talks out
of the day so I'm sure people may be
anxious get out of here and start
partying but we are here to talk about
Vulcan and it's exciting all on its own
it's one of my favorite topics favorite
topic to talk about and I've recently
been asked to maybe tone down the whole
can talk a little bit so it's a it may
be good for you or bad for you let's
find out
so let's go and jump in so Vulcan lots
of rules and no mercy
I've used this line a little bit in all
my Vulcan socks because I feel like
captures the general spirit of how
people feel about Vulcan right now and
it's it's a bit of a joke because Vulcan
does does bring a lot of good things
with it but it does have a lot of
complications that hopefully this sock
will help address some of it so a little
bit of introduction before we continue
as you can probably see from the program
my name is hi I am a credit technology
lead on Google's are copying code team
and my role on that team is to explore
different technologies to find out how
we can leverage them for creative work
and some of the things that I explore
are things like Vulcan how do you
leverage new graphics api's for use in
applications and I started working with
Vulcan about last December a few months
before the couple months for the fig
where succeed launch I implemented
cinders Vulcan support on Android Linux
and Windows and then I subsequently
ported all the demos to Vulcan cinder is
a C++ creative coding framework it runs
on Android iOS Linux Windows OS X and
it's open source under the simplified
BSD license but currently the primary
render is OpenGL on the desktop and
OpenGL on sorry open till yes on mobile
and the that's what it is now it will it
change the future probably as welcome
becomes more popular with the exception
of iOS and OS X of course and sender
gets used in applications of all scales
anything from mobile to desktop to very
large scale installations that you might
see
Time Square recently cinder has also
been used in the clouds to generate
content Vulcan support became available
in cinder as I mentioned earlier on
Vulcans launch date since cinder is a
coding framework made to be used in very
many general cases the implementation is
very much ongoing so what this talk is
not about this is an advanced level talk
so it's not an introduction to Vulcan it
is not a tutorial on Vulcan and it's not
an in-depth examination in Vulcan if you
if you liked a really good read on the
quick read on Vulcan render dock has a
really nice like Vulcan in 30 minutes
document and if you need to see some
tutorials on Vulcan we have some tours
available on the github repo and if if
we sit here and do an in-depth
examination of volcano would probably
take about a month but feel free if you
have any questions specifically about
any of the topics and just taught me
afterwards or find me afterwards and I'd
love to talk about them so what the talk
is about let's talk the bulk of this
talk is how to get up and going in
Vulcan you know in a kind of large way
not just like writing sample code but
actually like getting something to
production and so it assumes that you
know about OpenGL ES and assumes that
you know a little bit about Vulcan or a
some other graphic explicit graphics API
like metal or DirectX 12 and there since
Vulcan is definitely new there are some
sharp edges in Vulcan and I try to point
out the gotchas and why it's important
to pay attention to things like device
limits and the differences between going
from the difference between mobile sorry
desktop and mobile Vulcan and there's a
short section on the things to consider
if you're if you're looking for
performance in Vulcan and again these
are kind of heavy topics so if you you
find some if you finally say something
that's weird and you it's confusing
please find me afterwards I'll be more
than happy to clarify them
alright so to establish a base line
between OpenGL ES and Vulcan so this
question gets asked more than any other
question when it comes to Vulcan that's
broken faster than OpenGL sachi OpenGL
ES
the short answer is yes but not from a
direct port Volken is new and if you
want to leverage all the benefits of all
all the benefits of Vulcan you have to
change some of your code if not a lot of
true code and definitely some of your
thinking both Vulcan on mobiles feature
set is competent to that of OpenGL ES
3.0 one however it does go to include
compute geometry and tessellation shader
support it is an explicit API the the
developer is directly responsible for
heads direct control of almost every
object in the rendering pipeline the
developer is also responsible for memory
management and there are some new
objects and concepts that do come with
API there are also things that have
similar names but function slightly
differently so one of the amazing
features that Vulcan supports is
validation layers and this is the first
time you've heard of validation layers
they're essentially an API level
debugging error checking tool that lets
you excuse me that lets you figure out
what's happening in the API it's a it's
a very dramatic departure from GL get
error and the general rule of thumb for
for validation layers is to turn them on
the beginning the project and leave them
on to your shift the validation layers
are cross-platform which means the same
validation code gets used on Android
Linux and Windows and one of the cool
aspects of the validation is this it's a
function callback that you could supply
to the validation layers that gets
triggered every time a validation
message gets triggered and this is what
the call signature looks like and this
is what a sample body looks like as you
can see you know since it is you can
break it down into whatever granularity
that you need based on the validation
criteria and if you're on a platform
where you can set breakpoints in the IDE
you can definitely set a breakpoint on
any of these and you can look in the
call stack to see where the validation
measures was triggered all right
so let's get a bit deeper with Vulcan
some friendly reminders before we start
and these are things that you if you
were getting a port from OpenGL es2
Vulcan it's good to keep these in mind
even though they seem very trivial the
first thing is the
coordinate systems volkens coordinate
system is upper-left origin and this
includes both rendering and texture
coordinates this one caught me off-guard
when I was first working with it
everything I render appeared upside down
and kind of backwards and I thought I
was doing something very wrong and so I
went and like you know Tara told me down
and asked him like why is it up or left
and there wasn't a clear answer but it
just says a memory from memory
management basics and in OpenGL you
didn't really have to handle a lot of
allocations yourself if any in Vulcan
you have to kind of handle the majority
of the allocations yourself buffers and
images definitely and pools command
pools are kind of handled for you but
descriptor pools are not you you still
have to point out to volcán what you
need all right so the first Vulcan topic
command buffers so the command buffer
one of those things in OpenGL that you
hear a lot about but you don't really
you don't really have explicit control
over in Vulcan that changes a lot they
are one of the primary things that you
use to get any pretty much anything done
in Vulcan and command buffers has to be
allocated for their use and command
buffers are allocated from command pools
they have to command pools themselves
must belong to a queue family and we'll
talk about queue families just a minute
and we're submitting command buffers
command from command buffers have to be
submitted to the same queue family as
the as the command pool and also what
you're submitting you want to minimize
the number of command buffers that
you're using per frame and when you hear
this don't try to use just one if you
try to do just one command for doing
everything you're gonna end up starving
the GPU I also know that one by through
experience it's it's actually it becomes
quite difficult to try to fit everything
into a single command buffer because you
end up having to do a lot of code
gymnastics so in order to get like the
most per portly to ensure the best
performance you you're gonna want to use
multiple command buffers but minimize
them as much as possible alright so some
sharp edges on command buffers one of
the terms that gets tossed around a lot
with Vulcan a lot is multi-threading and
while there is a portion of the API that
is implicitly thread safe there are
parts of the API that are
that are not implicitly thread-safe yet
you can't record to the same command
buffer from multiple threads but it's
perfectly fine for you to record to
multiple command buffers on multiple
threads and you can do something where
you can record multiple command buffers
on multiple threads and then take all
those command buffers and kick them over
to a single submission thread and submit
all the command motors from there that's
perfectly fine but if you're gonna if
you're gonna do recording from multiple
threads make sure that each one of the
threads has access to its own command
pool and directly related to command
buffers excuse queues is again one of
those things that you hear a lot about
in OpenGL but you don't quite have
control control of in volcán again it's
very different and it's important to
understand hues from pretty much their
moment of creation and hues implicitly
they have to belong to a hue family and
you you know which you family build up
they belong to through the hue family
index and there are a limited number of
cues and you can find out how many hues
a cue family supports by looking at vkq
family properties cue accounts and we'll
get to the hue brought that you found
many properties in just a second but if
you find yourself in a configuration
where you want to do both graphics and
compute you want to prefer the combined
cues over hues to support singular
operations so if you want to do so if
you're looking to do graphics and
compute look for a cue family that
supports both and the reason the primary
reason you wanna do this is at the
beginning or just at the initial point
of report it just makes things easier to
coordinate because you start using
multiple cues from mostly cues we will
have to do synchronization and that can
be a little bit of a headache
the when you're working with cues it's
it's important that if you need to if
you need to order the cube operations do
it through synchronization primitives
and avoid using the hue weight idle in
very in performance critical code there
are times when there are legitimate
cases to use BQ they kick you wait idle
but all the times are isn't and through
personal experience it's caused a lot of
weird bubbles in the pipeline and kind
of installs that I didn't expect
and some sharp edges in hues so not all
cues are universal the hue family
dictates what functionality each cue
supports an Android supposed to be notes
on cue is that on Android there is at
least one cue that supports both
graphics and compute and you can present
from any cue on Android on the desktop
you kind of have to go looking around to
see which cue supports presentation or
not and this this almost goes without
saying but it's worth saying you got to
keep you got to keep kind of precise
counts on cues the there are devices
that only support one cue so if the
device supports one cue it implicitly
only has one cue family so you want to
check these properties before you start
creating huge because you try to create
more than one cue one device that only
supports one cues you either get a hang
or a crash all right
pipelines or pipeline state objects as
some people like to call them
essentially these are data structures
that control property that has
properties that control pretty much
everything that happens in the rendering
process and they're fixed function so
that means that once you compile them
you can't really change any of their
properties there's a caveat to that
since they are what are called dynamic
properties and the dynamic properties
can be readjusted or it can be adjusted
via command line herbs or command buffer
operations and these include things like
viewports scissors or blend constants
how many pipelines can you have if you
find yourself having hundreds or
thousands of pipelines that's actually
perfectly fine a typical application may
have that many and the reason if you
think about it for a moment the the
different combinations of what you have
in your rendering pipeline and your
rendering States can easily create you
know hundreds of permutations but if
you're if you're getting to the point
where it's over ten thousand you might
want to figure out if you're if you're
having too many variations too many or
too much granularity in your variations
if you're you can also cache pipelines
and the caption achieves two things if
you cache about the driver level it
helps speed up the pipeline the pipeline
creation if you you can also
use a selection mechanism to where you
can use a premade pipeline and you can
do this by looking at your pipeline
properties and using a hashing function
to select the pipeline excuse me
alright so descriptor sets and
descriptor sets were one of my favorite
errors in bulk and not because I have a
fond affection for them but I had to
spend so much time with them descriptor
sets are basically how the C++ side
views gives you a perspective into how
the resource of the shader will need and
there's there's a few things that that
you know though may catch you off-guard
about descriptor sets and we'll go over
these things right now the descriptions
are binding numbers so you can sparsely
populated by name numbers on the
descriptor sets but keep the gap small
because it unused money numbers still
take up memory there also is a max
binding number it's not obvious but if
you you know if you try to assign a
binding number of like 32,000 most like
GPUs won't support it and the validation
will call it out and they'll tell you
that you your binary number is too big
there's also a limit on how many max how
many descriptor sets you can have bound
at one time the and this is this will be
reported to you by max bound descriptor
sets and right now if you try to bind
more descriptor sets then your device
supports you'll just get a crash and if
you're you the thing may prescribe such
is that you will need to update them
once they're created so the shader will
know what researchers trying to your
you're looking at so the general wisdom
behind this is that you want to group
descriptor sets by update frequency and
you only should update descriptor sets
that have changed updating a descriptor
set is fairly expensive alright some
sharp edges on the scripture says if you
once you bind the descriptor stats you
can't do any updates to it until the
next iteration of the command buffer and
then you should do that before binding
so here's here's the one really
confusing thing that caught me off guard
with my new descriptor says the this
function BKE
CMD bind descriptor sets there's a
parameter on there called first set and
it wasn't obvious from the spec what
this thing what this meant and so i
thought it meant that the index on to
the p descriptor sets which is a which
is another parameter and give you a
better perspective this is what it looks
like so at the bottom you see the
signature so this this this parameter
actually refers to this field in your
pipeline layout and it's a little
confusing because there's nothing that
that helps you figure this out somebody
had to point this out to me essentially
what this does is it aligns that what
the descriptors that layout that you
told the Python you're going to use what
the ones you're passing into the bind
descriptor sets so if you if you're
running a journey into a place where
you're binding and you're getting a
crash or binding like a freight line
expect behavior just make sure that
these two parameters align all right
frame buffers so frame buffers in in
Vulcan are slightly different than they
are in OpenGL ES you can think of frame
buffers to Vulcan as basically loosely
attachment pools essentially the whole
array of VK image views and the
relationship between frame buffers or
I'm sorry the relationship between frame
buffer summoner passes are fairly it's
it's fairly strict sub passes and render
passes refer to attachments by energy
index there's no ordering requirements
the and the attachments the attachments
in frameworks and frame buffers must
have the same width and height in the
general case you still had to resolve
any multi sample attachments to single
sample before you use them in textures
not much different from yes all right
so render passes as mentioned before sub
passes inside of render passes refer to
frame buffers attachments via energy
index sub passed dependencies so when
you start working with Vulcan there's
there's you'll see a data structure
called set pass dependencies and and
from a high level perspective what this
data structure does is that it builds a
dependency graph that you pass into
Vulcan to tell Vulcan the order in which
you want the sub passes to be processed
if you don't do this some GPUs will they
will process that the sub passes as they
see fit and this may not be the order
that you want them to be processed in so
make sure that you know when you're
working that you when you're working the
sub passes be really clear and explicit
about which order you want some passing
process in if you're going to use an
earlier sub pass in a the the start of
the results of an earlier step passed in
the next up pass
and additionally unsub passes if you
need to use a let's say you're on sub
pass three and you want to use something
from sub past zero you need to preserve
that attachment if you don't preserve
the attachments what will happen is
it'll get destroyed when the sub passed
completes and further on the sub bass is
if you have sub passes that have multi
sample output and you want them to get
automatically resolved to single sample
you can pass in images into the into the
sub pass data structure that does this
and they'll get resolved right as these
sub pass ends so here's the diagram that
just that describes a relationship
between sub passes and render and frame
buffers you can see on the right the you
know frame buffers were basically just a
list and the render passes composed of
multiple sub passes and there's actually
no need for you to share one depth pass
you can have as many DEP passes as you
want assuming medicine went within the
device limits all right okay so these
are the next few topics image layouts
and pipeline barriers I wish there was
more time to get in depth with these
they're actually really cop they're
pretty complicated topics so I'll try to
go over them as much as I can the
behavior of these behavior of image they
have to vary depending on GPU some be
GPUs require very specific image layout
transitions others won't the the one
thing that you should know is that all
volke invitations will accept VK image
layout general for pretty much all
operations you will take a performance
entity you do that though so if you want
to ensure best performance it's best
best to assume that all GPUs require
specific image layouts and and set your
code to handle it that in that way
transitions between image layouts are
both implicit and explicit the image
layouts can be attrition can be
transition explicitly using pipeline
barriers and imagery that's they can
also be transition plea by implicitly by
render passes and you basically and how
that happens is there's there's a field
inside the sub passes that that asks you
like what do you want this to be well
once you're done the you can also use a
validation layers to correct any to
correct any image layout errors that you
may have the validation layers are very
fond of screaming at you every time
there's an image Lian error so it's it's
a good tool to have around all right
pipeline barriers if you open GL they
they can be a little bit terse there's
there's two things I feel like you
should know the first one is that while
they do look complex they come like they
become kind of second nature with some
practice the other thing is there is a
restriction on the there's a restriction
on pipeline barriers within render
passes and if you if you need to issue a
render pass or sorry a pipeline barrier
it within a render pass the sub pass
that you're gonna issue the pipeline
barrier and need to have a dependency
within itself and you do that just by
you know your tolling so positive in see
the to the the energy index of the of
that sub pass and there's only two types
of pipeline barriers that you can't
issue within a render past and that's
became egde barrier I'm sorry became a
memory barrier and VK image memory
barrier all right so a little bit more
advanced from the memory management
since you're directly control you're
directly responsible for the allocation
and usage of memory just like regular
old C you need to do bounds checking
make sure all your rights the buffers
are bounds checked if you right out of
bounds some drivers let you get away
with that and it what it does is it
crazy incredibly difficult to track down
bugs if you create red herrings you can
create a situation where you overwrite
something inside the vertex buffer but
it actually crashes when you try to do
something with uniform buffer so you
know right build some build some code
around error checking to make sure that
you're all your rights are in bounds and
flushing is something that's you know
making its way back after you do after
you any host rights make sure to flush
after you if you you have command buffer
operations that do a read all the things
that that really depends on must be
flushed before that read operation takes
place there is a there is a slight
caveat to the flushing if you allocate a
memory with the became memory property
host coherent you don't need a flush
all right shaders so spear B is the
official shading language of Vulcan and
it is a lower level language so we're
still using geo cell for a while
it must be compiled either online or
offline to spare be using either shader
C or GL slang the same sheeter code can
be used on both desktop and mobile there
is a big change to uniforms
uniform obviously you have to use
uniform buffers but you can't have cm
long uniforms anymore uniforms have to
be within block variables and sorry they
have to be within interface blocks and
the layout of these interface blocks are
governed by the STD 140 rules and if you
ever worked with SB 148 can be a little
bit complicated in cinder we use spirit
to cross to actually extract to extract
the offsets and size information from
what from the spirit view directly and
if that's something that interests you
come talk to me afterwards because it
saves us a lot of headache the other
thing is that you should whoever is
working on your team on bindings or on
between the shaders and descriptor sets
you know spend some time and spend some
time understanding how they relate with
the descriptor sets and the shaders
they're there there's there's an app
there's all because a natural
relationship but it's really easy to
make an error in one and kind of ignore
that you know it may create an error in
the other because you you have to keep
on synchronize all right so performance
considerations so these are kind of
self-evident things that we all
hopefully all hold to be true when we're
talking about performance in graphics
obviously minimize hosted GP transfers
especially on mobile because that ends
up taking a lot of power reduce
round-trips on any any reads that
includes you know if using the press
textures to speed things up and in
Vulcans very specifically try not to
start the GPU because when you start the
GPU you can you know the next round of
you pushing data to the GPU to be you
can easily over saturate it um and with
respect to render loops the best thing
to you for you to do is to keep multiple
frames and fight with Vulcan I find this
in Vulcan to actually be a lot easier to
do than OpenGL it opens elder at times I
felt like I was at the mercy of the
driver of what I was doing
when you was trying to keep multiple
frames in flight what vulcan you can you
can very explicitly do this because of
how the nature of vulcan so if you have
more than one frame in flight
say you have two then you always needed
up to double buffer all your non-static
resources you have three then you need
to triple buffer your non static
resources and so on and so forth and
this also includes things like your
command buffer and the command buffers
are a good starting point if you need to
figure out like what resources are
backing that particular frame so you can
start building a good dependency graph
from the command buffer back to the to
the research that you need and so since
you have multiple frames in flight
you'll probably need to handle the frame
rate throttling yourself this will this
takes a little bit of work and it
requires both using the vulcan sync
primitives plus some CPU side logic and
this is definitely near here where you
do not want to use vicky vkq wait idle
I'm sorry somebody Vulcan function names
are really hard to say and I know I'm
screwing them up because there are
mouthful and they're really long so I
apologize for that
alright so here's here's something that
I didn't exist in OpenGL but I think I
may be coming OpenGL soon is push
constants so if you're if you're looking
to something really quick and there's
not a whole lot of data that you need to
pass between your code in the shader
code you can use push constants and push
constants they don't require any buffers
they don't display any scripture setups
you can only push one twenty bytes at a
time
it's and you and the limitation on them
is that the you can only have one push
conscience for all shader stages per
shader and a hundred twenty bytes you
can fit about two 4x4 matrices in there
so you kind of have to be a little bit
clever how you use them and this sharp
edge the size the offsets must be
multiple four it's not really a sharp
edge for is the default machine size for
pretty much any GPU so you if you your
if your size and offset is not for
something went wrong somewhere else
horribly but they are they are excuse me
they are really quick and fast and
cinder does have a sample of how to use
this and here's what they look like
it just looks like a uniform block
except what layout is it has push
constant excuse me
all right so most projects will probably
start on desktop and go to mobile it's
it's if she's not doing that then
they're really highly skilled but if you
for the rest of us pretty much
everything starts on desktop and then
migrates to mobile so Vulcan the API is
actually is crazy consistent cinder took
three hours to port from the desktop to
mobile and the only thing that required
changing was basically the WSI or
Windows systems integration and the swap
chain and it pretty much ran so I'm not
saying that your code will take that
short amount of time to support but it's
you can trust up the api's consistent
the only other area that's different is
the extensions so that's that's where
the API now the properties are a
different story so property the
properties where the features are very
different from GPU to GPU and those
includes things like whatever what image
formats or or buffer formats or host
visible and what depth depth sash
stencil formats are supported so don't
assume that two devices that may be
similar in capabilities that they're
Vulcan Vulcan applications are equal or
equal I made that assumption and I found
it to be completely not true so you know
right if you if you must them write a
little tool that queries the properties
of the devices and you so it solidifies
in your head what the devices are
capable of since you know there's
there's not a whole lot of book and
implications right now so you can kind
of keep track of it that way but it
really helps and the other thing that
when you're porting is that have a
strategy to find the best properties for
for that particular device an example is
in cinder is that we have a function
called VGA find best def stencil format
and the reasoning for that is that on
some of the devices the best the best
one was 32-bit float while others only
16 and 24 bit integers were supported or
at minimum you can use properties that
are known to work across all devices all
right the other thing that you should be
aware of is three channel format support
is very limited and this includes both
image and buffer formats so again
develop a tool that generates the device
report on which for
which formats are supported for the
devices and if you do if you are relying
on any data packing on your vertex for
images and you're using three channel
formats right now you may have to change
how change the format that you're using
which leads me to the next point is if
you're also staging if you're also
staging transfers between your source
your host data and your GPU data you may
have to transform the data in the in the
staging an example this is if you let's
say your host format is RGB on some 4 on
some on some devices are to be actually
isn't a visible RGB 8 isn't a visible
host format so you may have to transform
that's RGB a copy it to the copy to the
Vulcan to the Volcom memory as RGB a and
then do the conversion inside of polkan
the other way to work around this is to
do a direct copy from buffer to image
using BK c and b copy buffer to image
there's a caveat to that I'll get into a
second but this essentially does a bit
for bit copy from the buffer to the
image so you can basically just read
your image into the buffer and then dump
it into the image itself the depth
stencil copies are very specific in
their behavior and there's there's a
good portion of the spec that talks
about that compressed textures so you
should know I mean we kind of all know
mostly these days what formats are
supported the the thing not to do is
don't assume that if it's of support in
OpenGL ES for the device that the
support in Vulcan it may not be one nice
thing about Android in this regard is
that Vulcan if all Android world
competitions will support et Cie - and
some of them will support AAS atse as
well and just for completion the desktop
support is essentially just the bc
formats they may have slightly more
complicated names
excuse me one second
okay so what's the last part of this
going from desktop to mobile so again
not to harp on it Meow's too much but
some GPS will require very image layout
transitions and while others won't it's
just best to treat them as if they all
do and this this is a really important
point I encourage you give any questions
about this please come talk to me I
can't say certain things but onstage but
I can give you specific details if you
want to know more about this so so pay
attention to the device limits they this
is this is a this almost goes without
saying but it again it catches people
more often than not is that they're
there most of the most of the vendors
will go above and beyond in certain
areas of the device limits and not
others and some device vendors will just
kind of do the the minimum and it's not
because one vendors better than other is
just implementation right but but don't
assume that the same classes on devices
or the same class of devices have
similar functionality they may not and
if you run into any errors especially
with device limits you can't use a
validation layer to track them down all
right so that's about 41 slides of me
talking with us you shown you any
pictures and let me fix that right now
so these I know that the word games is
using the type of the talk and I'm not
gonna show you a game engine demos but I
would like to show you render demo so
that's okay
and the point of these demos is to give
more credence to the fact that Vulcan is
up and running and you can't do some
pretty amazing things that with it
already and so hopefully these are these
examples are really enticing enough so
go to the demos please
okay so this is this is a walking
simulation it runs almost entirely on
the GPU it's a it's a it's a
simulation of about I think about 4,000
fish and essentially the the fish
simulation is going on the GPU and
there's a shark that comes in every now
and then and it basically causes the
fish to disperse the the code for this
is actually open source it's a sample on
cinder if you want to get it and mess
with it it's it's totally free whoops
stay awake the original work was done by
my friend Robert Hodge and he was
gracious enough to donate it as part of
the Vulcan launching efforts and the
next demo I want to show you is it's
also another demo by Robert and
essentially this is if you're familiar
with how with NASA's capture of sunspots
this is what they this is what the the
images look like so Robert wanted to
create something that was a real-time
version of the sunspots so you know it's
usually to create pretty pictures but it
turns out to be very beautiful and the
the funny tidbit about this is that
somebody not somebody a few actually
more than a few people have mistakenly
thought this was the actual NASA capture
so this one unfortunately as an open
source but if you would like to the APK
to either one of these just come find me
afterwards I'll be more than happy to
you can go right to the slides
okay so to wrap things up if you want to
look at senator spoke invitation it's at
github slash cinder slash cinder one the
Vulcan branch if you want to connect
with us about Vulcan we really want to
work with you to make Vulcan successful
please bit this visit this URL cool
thank you guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>