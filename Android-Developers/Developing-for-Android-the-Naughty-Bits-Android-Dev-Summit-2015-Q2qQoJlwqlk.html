<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Developing for Android: the Naughty Bits (Android Dev Summit 2015) | Coder Coacher - Coaching Coders</title><meta content="Developing for Android: the Naughty Bits (Android Dev Summit 2015) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Developing for Android: the Naughty Bits (Android Dev Summit 2015)</b></h2><h5 class="post__date">2015-11-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Q2qQoJlwqlk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to we're going to talk about
let's talk about Android development
today I'm Chet Haase I'm on the Android
UI toolkit team and mo Maggie I work on
the Android team I'm working on the new
graphics and layout stuff that doesn't
mean announced how incredibly vague
so today we're gonna talk specifically
about the naughty bits I called it that
because I like us you have no idea I had
no idea at the time like I don't know
what we're gonna talk about but you know
what I like that title right there so
we're gonna keep that title and we're
going to make it mean today basically
talking about a series of articles that
came out on medium.com that was a
collaboration of basically a lot of
people on the platform team at android
where we tried to do a brain dump of all
the patterns and anti patterns that we'd
seen over the years app developers sort
of taking assumptions that they had
about other platforms that they worked
on or other implementations using the
java programming language and doing
things that are essentially wrong to do
an android and ended up with bad results
so we put all this information into an
incredibly long internal document and
then we split it up into ten very long
documents on and put them up on
medium.com
and so I would encourage everybody to
check those out I put up my name there
just for self-gratification but also
because you can then find it so please
check those out but specifically today's
talk is around some of the information
in those articles about four months ago
we were doing some user group and said
oh why don't we do a talk around this
thing we have about an hour let's put
all the information from you know 92
hundred pages of worth of information
into this talk and we went there we gave
the talk we got about a third of the way
through in an hour and a half was gone
so we're not going to talk about that
we've already talked about that let's
talk about some other stuff that we
haven't talked about yet and no I agree
how many of you have read those articles
already just out of Chrissy well okay
the rest of you you can stay go read
them now and we will wait
are they done I think so okay good job
everyone now let's repeat all that
information in presentation form so why
is mobile so difficult so we want to
talk about some of the sort of higher
level ideas I would say if you read
nothing else from that set of articles
then I would be very unhappy but point
two is I would say if you read nothing
else except the first one of those which
is called understanding the mobile
context that's sort of the bigger ideas
of not just what the rules are but why
they actually matter what's the context
of developing on on mobile that makes it
so very difficult and makes these rules
so very important to get a well
performing and nice user experience
application for your users so let's talk
about some of those things so memory
turns out it's limited it's very limited
so the phones that you have in your
pockets are probably I don't know two or
three gigs of RAM yeah two to three is
three three no yes four maybe possibly
as low as one in a lot of the world it's
you know 512 megs is actually quite
common and it's not just comment on the
older phones it's also common on newer
phones that are being sold into cheaper
markets right there's a weird thing
about Moore's Law where you assume that
everything's going to get faster and
better and in general it does right
Moore's laws you know does mean that
it's cheaper to make these things but it
doesn't mean that the other things go
away those same phones are still in
people's pockets out there being used
every day moreover it means that the low
ends to today's sort of reasonable
mid-range phone is possibly going to be
the low range phone for a long time to
come so don't assume that just because
you got a good deal on a phone that has
a reasonable amount of memory that all
of your users have the same good deal in
their location and something else that a
lot of developers do we tend to compare
the specifications of our phones to
computers that we know and use every day
so I still a lot of people who say you
know like you have three gigabytes of
RAM on my phone it's almost as much as
my laptop I forget about on my laptop
but turns out that you know some of our
phones to the idea as many or even more
pixels than a lot of computers out there
when even this morning I was
I was working at my workstation at
Google I have a Mac probe like a really
beefy machine with 64 gigs of RAM and my
30 inch display has just as many pixels
on screen as my phone that sits in my
pocket and actually looked at at the
Activity Monitor on my Mac and my Mac
Pro was using 20 gigabytes of RAM to
drive the same display as my phone does
so we don't have 20 gigabytes of RAM
just yet on Android we'll get there
someday but we be very careful when you
make those comparisons and it's
something we're going to get back to
like with CPUs and GPUs and storage the
numbers feel familiar but they don't
mean the same thing as they do on
desktop in laptops
another dynamic that's important about
memory on Android is everybody is
sharing this limited pool right so if
you are taking up a lot of space for
your activity when it launches the
system may have to go around and kill
other things to make it possible for
your activity to run and then when you
go in the background and the user goes
back to the launcher that may take a
while because maybe the launcher had to
be killed in order to allow your
activity to run and then your activity
may also be killed when those other
activities looking for a memory because
if you're taken up a lot of memory
you're gonna look really juicy to the
task manager when it needs more memory I
know and that's very important because I
know that your application is the most
important application it is to you you
know my applications on my most
important applications but I've seen
I've seen applications that basically
try to game the system and when they're
in the background they try to refresh
the caches or they do everything they
can to stay around in memory so that
when the user gets back to the
application they won't suffer through a
cold startup so the app is still there
but what they do in the process is they
kill all the other apps on the phone so
they make everybody else look bad so you
know you have to work with each other we
really want the whole experience on the
system to be good it's not just about
your apps not just about the standard
apps on Android so but the whole
experience throughout the day let's talk
about CPU it turns out that it's slower
than the CPUs you're used to on desktop
and server much much much slower and
another dynamic that people don't
necessarily realize is it's quite often
throttled so in order to get the maximum
battery
time that we can out of these devices we
end up running things as slowly as we
possibly can for as long as we can so we
have clever things on the system like
doze mode that hopefully you heard about
earlier today that allows us to just
slow down the entire system and not do
much when the system is not being used
but even when things are being actively
used the user is staring at the screen
reading information the CPU is probably
not at its highest operating mode
because we detect that there's no user
interaction there's nothing running that
may require that thing but that means in
general that some of the things that you
may expect out of a CPU with you know
even the speed that it has on common
mobile devices may not be true in all
situations that you're not going to get
the performance that you thought you
would have in these common situations
actually recently got a very interesting
question that email someone was asking
me who's telling me that is whatever
algorithm he was running it was running
slower than he was expecting
so I was telling you that it's probably
throttling because the device was not
busy enough so the CPU was running
probably attend or 300 600 900 megahertz
something pretty low and then he came
back to me saying but it's funny when I
shake my phone didn't algorithm runs
faster and it's true when you shake your
phone your party you know waking up all
a bunch of sensors which are in turns
waking up entrepreneurship processes so
we bump up the frequency of the CPU and
you are because faster so you could try
that if you want to send your email
faster whatever check your phone not
recommended to do it all day but the
reason why we throw out Chad says it's
it's better life but it's also our
thermal issues the the latest batch of
CPUs that we have you know the multiple
cores and the truth is if we were to
turn on all the cores at the same time
at the maximum frequency you'll device
will probably melt or hopefully reboot
before it would not but there's so much
energy that your phone can dissipate
that we cannot run the device at it's
it's for speed and be also very careful
with the numbers that you get by looking
at the back of the box when you when you
buy your phone so you see two gigahertz
CPU it is not because most of the time
we're gonna run throttled and you're
going to see it as eight cores it
doesn't it has four little cars and four
big cores and we're going to use some of
them at some point and some of them at
another point we're not going to
all of them at the same time the best
way to know what's going on is to use
systrace we covered that too extensively
at various conferences and you can
probably find the talks on YouTube but
systrace will show you how many cores
are active and at what speed they're
running and you might be really
surprised by what's going on I like the
idea of shaking maybe if you just play
the vibrate thing like constantly then
that would provide enough shaking to
wake the phone
it's just techniques just perform this
techniques alright let's talk about it
that doesn't mean you should run the
vibrator in your application when you
want you to go faster like this don't
give them ideas don't connect to it
maybe I should hold up my hand this is
not I'm not being serious now okay see
the previous slide so all the stuff that
we said about CPUs certainly applies to
the processor for the GPU as well
there's some other things that are
specific to the graphics side for one
thing texture uploads are very expensive
a lot of things trigger texture uploads
may or may not be obvious whenever we're
drawing a path whenever we're entering
new characters of text that you know
this is the first time we've seen them
we're gonna draw them into a bitmap
that's gonna get uploaded as texture
whatever doing you know vector drawables
or other things that end up being
software render it into paths those are
all texture uploads in addition to the
obvious stuff of bitmaps so those are
expensive as our general fillrate
operations well it's just really to do
bandwidth so just like texture uploads
you know we have a lot of pixels on our
devices and we need to a lot of
bandwidth to be able to fit the display
and you try to draw those pixels we need
to use intermediate buffers and all that
stuff and the the bandwidth on mobile is
not decoying at the same speed as the
rest of the system so the CPU the GP or
even the screen density so it's still
very much a prime - then we again cover
that extensively in previous talks when
we mentioned things that overdraw and
blend them in why you should avoid them
GPUs on mobile have other issues I mean
they're really good you're incredible
given they'll run on phones but you
can't really compare them to desktop
GPUs or your laptops or even your
consoles I mean just to give you an idea
like a fairly power efficient GP on a
desktop uses about 175 watts of power on
a phone if we can dissipate 4 watts of
power it's really good
so you know we can do what they can do
and even if you conserve the bandwidth
even if you're really careful with your
textures our GPUs are still very limited
in terms of how many computations they
can do on every pixel so you probably
don't care if you're not writing OpenGL
code for instance but you're writing a
game or pangey on your application
something you need to be very careful
about especially on older devices no
matter what don't test only on recent
devices when it comes to GPUs there's a
huge gap between a nexus 6p and devices
from two or three years ago there's also
an interesting dynamic that comes up
when you're looking at as we said fill
rates it's not necessarily keeping up
with a curve of everything else and
these devices that are coming out with
amazing density what was the that the
next full picture this 6p is like 550
dpi just huge numbers which is really
awesome for a screen resolution but if
you imagine that that's how many pixels
we have to actually fill on every single
frame then that's kind of problematic if
you don't have the bandwidth to actually
do that appropriately which is why we
have a lot of these recommendations
around but the good news is that we
thought you are pretty much done with
density because we have real so many
pixels days but vir just care just
arrived and for VR you need even more
pixels so where it's gonna get even
worse fortunately people only have two
eyes so it can only go too far so far
memory so in general a lot of the tips
that we have about performance boiled
down to tips about memory because on
Android and the runtimes are talking
about memory is so closely tied to
performance there's a lot of dynamics
around that let's talk about some of
those so when you require more and more
memory you're basically allocating a
larger and larger heap it takes more
processing power to actually allocate
that heap to increment the size over
time it also means that there's going to
be tasks thrashing we were talking about
this before if you take a lot of memory
someone else has to die to ensure that
you can live and vice versa when you go
in the background allocations are going
to take longer because there's simply
more information to wade through for the
garbage collector to actually figure out
where to put that thing we
where the free space is collections are
slower for the same exact reason and
there's just general more activity for
the garbage collector to run through
allocating collecting doing hopefully
not but probably full GCS to actually
get memory back in the system so we
thought it would be useful to sort of
walk through some of the ideas around
garbage allocation and collection in
general so you can understand the
context of why this stuff cost so very
much so this is how a garbage collector
works okay any questions okay so if we
go into the second goal description the
squiggly is on the left indicates I
actually don't I don't really know I
still I mean yeah I'm disturbed somebody
somebody in the squiggly dimension is
trying to allocate something and they
come up with a blue rectangle I don't
know why it's blue I don't know why it's
a rectangle but they want to allocate
space for it so it looks at the garbage
at the heap and it says okay I want to
allocate this thing we put it in there
then we enumerate all the things that
have references in the enumeration phase
we the mark phase says okay what are the
things that don't have references
because those are the things that we can
get rid of and then we collect that
right so we free up that little red
thing in the middle we freed up the
space for that that is now space that
can be used for a future allocation in
the heap it's important to note that on
dalvik there's two different pauses that
happen during this process there's a
pause during enumeration well they
actually want the heap and see where the
references are to all these objects and
then there's the mark phase that also
has a pause part of the mark phases is
okay it can do that concurrently with
other threads but part of it it needs to
pause everything else in the system at
the end of that mark phase to basically
do a post process and say okay are there
any changes since I ran through the
first time and in sponsor to remember
that a pause poses all your threads in
your application so it's not just the UI
thread it's going to be positive and
oppose your background threads that's
also means that the background thread
doing too much to see activity will
impact your UI thread so your animations
or layouts and you can see these in the
log these are g GC for alloc it's other
GC operations concurrent G sees there's
there's lots of information
about GCS in the log you can see some of
these things coming out and if you
wonder why they're there this is why so
on art there were improvements huge
improvements made to garbage collection
allocation in general one of the big
improvements was there's no longer a
pause during the enumeration phase and
there's a smaller pause during mark but
it is still a stop the world pause so at
the end of the mark phase they're going
to do a quick pause just to sort of
collect the information and move on from
there
so now let's look at a more problematic
situation this is the GC for alloc
situation you come in someone wants yet
again a blue rectangle allocated and it
comes in and says okay well I've got a
space for that how about a second blue
rectangle because I had such a good time
allocating for the first one and it
walked through the entire heap and it
cannot find a contiguous block of space
large enough for the second blue
rectangle so it needs to free up space
for that then it does a GC for alloc and
there's a huge pause right so this is
the really problematic thing about GC
not just that it's a huge pause but it
basically happens at exactly the time
you do not want it to you may be in your
inner loop and you're doing something
that triggers an allocation that
triggers the need to actually walk the
entire heap and free everything possible
just to get memory to allocate that
thing nothing can continue in your
program until that is freed up for you
so that it can be put on the heap so
you're basically going to pause right in
the middle of you know an animation and
rendering whatever something on the UI
thread and it is important to know that
GC for alloc does not make any guarantee
that you will be able to actually
allocate what you want to allocate
because if the heap is fragmented and
we'll get back to that because there's
been changes with art but with the when
the heap is fragmented there might not
be a single slot available that's big
enough to fit your object in which case
you will get a crashing or an out of
memory exception and the interesting
part is you could have you know dozens
of megabytes of free space in your heap
but because of fragmentation at any
location could fail and crash your
application just because when it
contiguous memory in the heap it's
actually fairly easy to do you can try
for yourself you have a Dalek device you
can allocate a bunch of objects in a
list and then you know every other
object in the list
you wait for GC you so you over
the heap try to allocate another big
object and you will run out of memory
even though you have a ton of memory
available and that happens a lot with
the bitmaps which is why in art they've
introduced the concept of the large heap
so it's a special heap for large objects
and bitmaps in particular are a good
candidate for that so not only does it
help with the heap fragmentation because
we know that we are likely to find large
contiguous space in the large heap but
it will also make every allocation and
garbage collection in the command heap
faster because there will be less memory
to look at another dynamic we've seen
what is the prevalence of low-end
devices in the world and generally
reference this before in the context of
memory but basically the device in your
pocket guaranteed it's faster than most
of your users and it has more memory so
we're talking about Moore's law it
doesn't always apply or at least it
doesn't apply in the way you expect
those low-end devices are going to be in
the world for a long time to come so
your application needs to deal with them
unless you simply don't like those users
a smooth frame rate so this is an
important one we talked about 16
milliseconds to lots I guess it's a
number that we like a lot basically you
have 60 frames a second that boils down
to sixteen point six seven milliseconds
that you have to do everything right so
you need to do need to process your
input you need to process your
animations for that frame you need to do
any measure and layout that hopefully
didn't happen in an animation but
sometimes it does and process all the
drawing commands for the things that
changed and then those get sent over to
the render thread all of that stuff goes
through everything has to happen in 16
milliseconds in addition to anything
else that was going on in the system
that may cause a pause there right so 16
milliseconds even if it doesn't happen
by then then you just missed a frame and
you just miss the opportunity for a
smooth frame rate for your users another
element of frame rate that's not as
obvious is that consistency is good I
would say in general it's better to hit
30 frames a second consistently than it
is to hit 60 frames a second most of the
time and then a
occasionally you're gonna pop out like
if you know you're gonna pop out and
there's nothing you can do about it then
go back to the drawing board and do
something about it anyway but it would
be it would be better to sort of back
off to a slower framerate at least one
that you could deliver consistently
otherwise what the user is going to see
is smooth smooth smooth pause skip right
it's very noticeable when you're gonna
drop framerate just occasionally it's a
noticeable blip on this it's actually
something that for those of you play
games it's something fairly common in
video games especially on consoles where
they will do the the video game
developers would rather target 30 frames
per second than have a free trading
frame rate which can be very distracting
when you need to plan missions or you
know have like reflexes in a multiplayer
game and the thing is on Android because
we are distinct and there are different
types of this thing but Android has
always been missing at least at the
compositor level when you miss your
frame it's not like we're gonna drop to
55 over 50 to 90 frames per second or 58
you're gonna go all the way down to 30
so if you miss every other frame you're
gonna go 60 frames 30 frames 60 frames
and it's extremely drying for the user
so like Chad said if you cannot hit 60
you should you know maybe hit 430
consistently instead or pop up a dialog
and tell him to shake their phone
or have a city let's talk about runtime
so dalvik versus art we talked about
some of the differences in the
collectors before there there's a really
important dynamic about about whether
they can defragment they keep so this
was sort of implied before but Dalva
basically once you allocate a thing if
it's gonna stay there it's gonna stay at
exactly the same place in the heap
there's no point at which delve it can
actually move things around so if you
allocate a bunch of stuff and then other
stuff goes away the stuff that's still
allocated and referenced somewhere is
not going to move which means it can
fragment over time and eventually you
can run out of room to allocate other
items not because you don't have the
space in the heap but because you don't
have the contiguous space art made a
change where it can actually defragment
that heap when the app goes into the
background and there's an appropriate
idle time so it will eventually
compensate for this although possibly
not in the time that you need it if it's
in the foreground and the interesting
side effect is that there are used to be
a lot of j'ni code out there that was
wrong because the objects were never
moving in dalvik heap if you're not
careful about how you get a pointer tool
it's a Java byte array you could will
work because we're never going to move
that all right then you move to art and
sorry that or I might move and your
pointer is pointing to who knows what
and so I think there's the the the j'ni
checks are stricter now with art so if
you write Jedi Code which you're going
to write Jayne I could be very careful
with that make sure you test on art and
dalvik and folding the Jedi conventions
in the documentation language does not
equal runtime and does not equal
hardware so I gave a different variation
of this talk at a conference a month ago
and someone asked a question afterwards
along the lines of so when there's a new
release with the JDK how do you keep up
with the changes in the runtime of
something I realized people didn't quite
understand the mental model they needed
to about what the language is versus the
runtime versus the devices that we're
running on so I thought it would be
worth sort of diagramming this for you
so these are all very separate things
right so we have this Java programming
language that we use in Android that has
absolutely nothing to do with the
runtime
on other platforms the runtime is a
separate thing the whether it's dalvik
whether it's art whether it's some other
runtime on some other system and then
there's the hardware that it's running
on and it's sort of important to
understand that this stack is going to
look quite different for servers so
traditional Java developers that are
writing Java on the back end for servers
writing web apps whatever they're going
to be in a very different environment
than we're in on Android so they are
running over there with some server
runtime it's moving and it's a
compacting collector it's got huge heaps
to deal with and it deals with them very
efficiently with a very different system
than we have in either dalvik or art and
then you're on the server and the CPU is
really quick and the memory is
essentially unlimited right just huge
gobs of memory that you can do whoodles
of things with meanwhile on Android
which you can tell because it's colored
green we have two different runtimes we
have dalvik up until KitKat I think art
was default in KitKat so what the
dynamics you're getting around the
runtime the performance of the runtime
the optimizations taken as well as some
of the garbage collectors so where's
hekima depends on which of those
runtimes are running on and then there's
the actual hardware that you're running
on so you in shape like a full it is
this it's very accurate I took that from
the tool it's a it's a snapshot from the
tool so we have no compaction as we were
talking about we do not compact the heap
we can't defragment it on dalvik we can
do idle time compaction when the app is
in the backgrounds with the artist so
that is very important because we do
compact the heat because it's an
expensive operation it happens like Judd
said when you're eye-pleasing in the
background so that means you can still
run out of memory with a ton of free
memory in your heap when you're in the
format so you still need to be very
careful with how you advocating you know
deallocate objects because you could run
into one of those we have crash reports
that you'll get from your favorite
analytics reporting tools and you will
not understand how it can run out of
memory and this is partly why and of
course do not send your application to
the background automatically to
defragment your heap that's a bad idea
you get any idea you might have based on
what we said I don't do it if we were to
quantify the CPU for this platform it
would be way slower and the memory is
you know in general between 512 and 2 or
more but it's really important to
remember the technical term is not
enough not enough never enough also on
the UI thread some dynamics here it's a
single threaded UI system for the most
part well it's a single threaded UI
system except there's a render thread
and you can have multiple single threads
ok so it's a single threaded
multi-threaded UI system in general you
are always doing things UI related which
means input processing animation
rendering on the UI thread in general
it's a single you I thought we all know
in fact you can have multiple your
threads in your process don't try to do
this it's only framework people who have
to worry about it you can but don't do
it we have to test for it but it's not
really a situation that comes up very
often yet when we are done with
processing all the rendering stuff then
we'll send it over the renderer thread
which will then send it to GL but you
can still think of it as being a single
threaded UI system where all the stuff
sort of has to happen serially and the
the trick here is to basically eliminate
everything that should not or does not
have to happen on the UI thread because
you really don't want to stall that
otherwise you're gonna cross that
magical 16 millisecond boundary and jank
the UI experience video so the best way
to make your app go faster is to stop
writing code so just go on vacation and
the best part is you can even justify it
so in storage performance varies so just
the raw performance of these storage
devices we've also seen situations where
the more that's been allocated into that
storage system the longer it takes to
deal with it usually interesting you
should look up how non-flash works it's
pretty interesting so the disk
controllers for flash memory are
extremely complicated and turns out that
flash memory basically as a garbage
collector
it's very interesting but the fact is
like the folder your storage is the
store it can get and things that
Corendon write multiple random writes on
the flash can really kill performance so
what happens that when you have a lot of
processes on the system on Android for
instance that are writing to memory to
storage memory at the same time things
will really slow down and we've had
pretty bad issues on past devices with
that it's mostly fixed these days but so
if your app stays in the background and
you're gonna do a lot of disk IO try to
be mindful of the other apps as well
because you know you're writing stuff to
the storage might impact the apps in the
foreground that dynamic of storage makes
sense if you just think about this week
Thanksgiving week in particular as
people eat more they get slower storage
size varies so you're not exactly sure
what your user is going to have is your
app going to be able to cope with that
flexibility and the apk apk size ends up
mattering because of these dynamics
right are you absolutely going to be
able to fit on the user's device and
will there be noticeable performance
problems because it was just too bloated
for that particular performance dynamic
on their system in the network again
this is just like the CPU and memory
issues turns out your network is
probably faster than your users networks
especially in some locales across the
world they're dealing with incredibly
slow networks or data networks that even
when they're not that slow they may cost
a lot so maybe those users are not on
those networks as much as possible a
good way to test so you can use the
emulator you've seen the presentations
before so there are ways to emulate
slower networks while should live in the
Bay Area they are yeah you could you
could just go take a hike on the heels
will buy the two to 80 Highway the
network is really bad there so that's a
good way to test and take some fresh air
and again you can justify it with your
bus cheaper too this is a huge dynamic
like are you trying to sell your
application in two places where they
really try to avoid using the data
network for whatever reason but are you
very dependent upon that for your
application experience maybe there are
ways
you can write your applications such
that you can deal with this situation
better you know allow them to wait until
they're on a Wi-Fi network to deal with
that or whatever and finally there's a
couple of these are like sort of
marketing ish slogans but they're really
important to keep in mind one is every
device is a village right this isn't
just a touchy-feely thing this is a
reality that all of these activities
need to live together and services need
to live together on the same system to
make a reasonable experience for the
user so if you look activity is
demanding a lot of memory you're gonna
kick a lot of other stuff out so that's
great for your activity when it's in the
foreground because they got the memory
that it wanted but you know what they
when the user leaves your activity and
goes back and it has to relaunch
launcher because it even kicked that out
because you asked for so much that's
probably not a great experience right
you're not contributing to happiness for
the user just because your application
was being greedy and then when you go in
the background when they run anything
else your activity is taking up so much
memory the you're probably going to be
killed as well so if if all of these
things are going to be as greedy as
possible in the shared space then it's
just not going to be a happy situation
and that many ways you can deal with it
fairly easily and fairly efficiently so
I'm not gonna name the application
because I think it's one of ours but I
have have a test device it's an exercise
and you know I haven't even set up a
Google account on it and every time I
boot that device there's a process
running that clearly shouldn't be there
because I don't even have an account for
that application so what you can't so
they have a service running so what you
can do in your application in your
manifest you can disable things like the
broadcast receivers the services and
until the user actually does something
in the application that you know informs
you that they want to use the
application the the design design then
they logged in or whatever then you can
programmatically enable your service or
your broadcast receiver and there the
system will remember that so even across
reboots your service will stay there and
it's really important because no that
way you will leave the rest of the
system free when the user is not that
much that interested in parts of your
app app standby tries to address some of
this dynamic where if we notice that an
application is not actually being used
by the user then this will not allow
that application to start using you know
your resources because obviously the
user has not requested that on the apps
behalf but there's only so much that we
can do systematically and automatically
in the system your application knows
better what it needs and what it can
disable and then finally the the first
item sort of leads to the second which
is tragedy Commons where if every
application on the device is acting
greedily in its own self-interest then
you just end up with a bad experience
overall for every one of those
applications maybe it made sense for you
because obviously the most important
thing the user could do on their phone
is to play your cat video application
but if everybody has the same attitude
then it's going to end up being bad
overall so let's go through some tips so
those that was the sort of these are the
higher-level concepts of why this stuff
matters now let's go through some of the
actual items about and hopefully you
have heard of those tips before so if
you feel like we're repeating ourselves
that's a good thing and we're going to
talk about it again until you stop
making those mistakes so no overdraw how
many of you know what overdraw is about
well it's gonna get better every year
everybody who didn't raise their hand
shame on you as usual oh it's because
they're busy reading the articles okay I
hope so if you want to know more I wrote
an extensive piece on the on the subject
just know Google like I don't know
Android overdraw you'll find it
basically your droids when you repaint
the same pixels over and over again we
have tools on your phone that help you
catch on the draw and we have multiple
articles that explain how to avoid it
since KitKat the rendering pipeline does
some automatic removal of overdraw it's
not perfect there are things that we
cannot guess for you and when you turn
on the overall detection tool on the
device it has the side effect of
disabling the optimization so you can
actually see where you are drawing and
the reasoning is if you are drawing
you're also party creating too many
views loading bitmaps you might not need
making allocations we don't need so it's
you know fixing overdraw will also help
other parts of your application like
memory pressure startup time no window
backgrounds may seem like a good idea at
the time they tend to it was a good idea
long time ago they tend to create
artifacts on the screen so if you've
ever seen something like when the
keyboard comes up you'll see either
garbage or black on the window in the
space where the keyboard is animating
over it's because someone decided to
assign a null window background this is
partly to address the overdrive shoe
they said well obviously I don't want a
background to my window that is then
covered with an opaque background of my
main container so I'm just gonna remove
one of them to get rid of that and it
kind of works in the main but then
there's these specific cases where it
causes artifacts keyboard animates up
and the window manager doesn't know what
to draw there because you told us null
right so how do you draw no you don't do
anything so we don't do anything and
then the GPU will just draw some default
there which is either black or garbage
so there's other situations that can
trigger that same artifact the real way
to handle this is to actually have a
window background and not have opaque on
that main container so you can still get
the benefit of having the background for
the window so the window manager always
knows what to draw when it needs to but
then actually use that background as
part of the background of your
application similarly there's artifacts
caused by disabling the starting window
let's see so the main reason there are a
few reasons thing about the starting
window one is that you want to give the
user immediate response that something
has happened they tap the icon they're
trying to launch your application which
unfortunately it's going to take seven
seconds to launch because there's
entirely too much happening when you're
creating an activity but in the meantime
we'd like to show them that something is
happening so that they don't go and tap
it again and wonder what's going on and
then uninstall your app so we quickly
launched the starting window this takes
a very small amount of time usually
along the lines of I don't know 200 to
400 milliseconds to bring up this window
we basically peek into the resources
into the theme of the activity and we
say okay here's what a window would
generally look like for this activity
and we'll we'll pull it up there and
then we'll crossfade it to the activity
as soon as it's ready to draw and this
includes for example the launch window
experience if you've seen any of the
stuff running on em we're doing the same
exact thing it's just a starting window
with a background that happens to have
an icon and it's very quick for us to
figure out what this is to load it in
and to launch that starting window and
then we're crossfading Z the activity
as soon as we can if you disable that
starting window then there's situations
where like the launch experience where
we really should be drawing something
for the user and we cannot because you
told us not to UI stalls so this this
relates to the single threaded
multi-threaded UI thread the situation
that we talked about it before there's
lots of things that can cause us to
stall in the middle of doing UI
processing so it's good to be wary of
these when you're inflating resources
that's always on the UI thread so if
you're doing a particularly expensive
inflation if you're launching a super
expensive activity from another activity
or if you have a deep hierarchy that
you're inflating along the way then that
may take enough time that you're gonna
Jack a frame because of that handling
events there are some places where
expensive operations won't be that
noticeable for instance when you click
on a button but then the places where
you want to really be careful so
handling events that we just talked
about so on touch event then there's the
on measurements that that's part of the
layout so you can keep going through the
slides there we go okay the on layout
the ondraw going and animations of
course are gonna trigger all those all
those callbacks
so does those are really do places where
you want to optimize your code where you
want to you know use this trace use the
profiler use the GPU profiler if you
have to use tracer for OpenGL ES and
it's okay thing to apply some micro
optimizations in the species of code
because they are so important that said
mentioned if you have 16 more seconds to
do everything you have to do and turns
out that in the land of mobile 16
milliseconds have a different direction
so depending on how fast your CPU is
going a millisecond might not be the
same as the frame before so 16
milliseconds some time will be really
hard to hit you might also run into
issues and that's an interesting one
where if you optimize your code too much
we're going to slow down the CPU so then
your code runs slower and then you're
not going to be able to go fast enough
we that happened to us before and so the
system tries to take that into account
but if you run into that well good luck
the scrappy avoid doing too much stuff
complex view hierarchies basically the
more views you have in there the more
containers the deeply deeper nested your
hierarchy the more stuff we're doing on
your behalf
traversing it to figure out in
validation to do measure and layout in
all us and one of the so one of the
worst things you can do and this is
partly why we make that the default when
you create a new activity in Android
studio is to user relates you layout at
the top of your tree so if you go your
file new layout in Android studio just
do select all delete and start from
scratch you know why we put it there
it's a test yes and you all failed it we
like to play out in a lot of cases not
all of them will measure the children
twice and so what happens when you
measure the children twice is that if
some of those children's are view groups
themselves like cleaner layouts or
relative layouts and those cause their
own children to be measured twice then
those children's have been measured four
times already so we have some
optimizations in the framework to
alleviate that issue and especially
starting with KitKat the optimizations
have gotten a lot better but you can
imagine that if you have you know 10 12
or 16 nested layouts and every one of
them measures the children twice you're
going to spend a lot of time doing your
measure on your layout so be careful be
careful with relative layout and linear
layout if used the weight attribute any
child with a weight will be measured
twice so just just be careful measure
profile and try to find a different way
of doing your layout if you can please
watch your activities fast present the
UI quickly so that's the certainly the
purpose of the starting window but it's
also nice if you can present the real
content as quickly as possible so the
users not sitting there waiting for your
amazing cat video application defer
extra work we see a lot of activities or
application code that's doing a lot at
startup you know it has a static block
where it's initializing a bunch of stuff
that it's going to need eventually they
allocated eventually right you don't
have to do that at startup and make the
user wait every time they launch this
thing instead you can wait and do it
incrementally as they actually need
things instead yeah I can give you an
example of the word ye launcher
application at least used to work I
don't know about the current launcher
but back in the old days loading all the
icons from from this from all the apk s
to present the grid of icons was
extremely expensive and it takes several
seconds
so what launcher was doing was loading
three icons at a time and after loading
three icons it will post a message in
the UI queue to ask itself to go to the
next three icons so if you are fast
enough and you open the grid of icons
you would see them being loaded by
batches of like three or six but that
was the idea so we could start the
application stuff really quickly under
half a second but then it would keep
building its own UI kind of under the
hood and if you do it right and all of
it will be off screen anyway and I'm
sure like most of you have never noticed
that we are doing that soon the water
situation you can try to do choose one
of those tricks measure cold starts so
there's you you want to figure out how
long it's taking for your application to
launch and then work on that optimize it
make sure that it's slow that it's
faster than seven seconds but then how
do you actually verify that your work
has been worth it if you launch the
application you know I'm that thing and
actually I posted something on my blog
recently a couple weeks ago about ways
to do that basically there's a really
helpful log now that will just tell you
how long this thing took and then some
of the details about that I put on my
blog recently anyway measure that like
on launch and see what that number is
and then if you put that in the
background and then you launch it from
the icon again that's not the same
number that's called a warm start right
that activity is already loaded we're
not actually doing much work to bring it
up when it's still in memory and still
sort of running in the background so
instead you want to swipe it out just
bring up recents and swipe it out and
they'll get you mostly to the situation
that you get on reboot which is running
for the first time because that's really
what you want to measure you want to
measure bringing in all your code doing
all your static initialization going
through everything that an activity does
every time it launches for the first
time after noon and once again one of
the best tools you can use is systrace i
remember what we we once identified an
issue in the standard time of an
application and the interesting thing
that was happening was the application
was using a background thread to offload
some of the work to
first of the work but at some point the
UI thread need the result from that
background thread so the u.s. thread was
synchronizing on the background thread
but by definition the background thread
has a lower priority so the UI thread
was mostly idle waiting for lower
priority background thread to be done so
be careful with that kind of that kind
of issue uses trace systrace will make
it very obvious when something like this
happens so some interaction points to go
over allow the user to actually get out
of immersive mode otherwise that's a
little frustrating immersive though mode
is there for a reason for you know
fullscreen video experiences or games
but it's also nice to actually let the
users out of the box occasionally so
we've seen this where the starting
window like when when applications don't
disable the starting window
they don't necessarily do the right
thing with it one of the one of the
worst launch experiences I've seen from
several applications is typically a game
will have like they want to do their own
splash screen that's like tuned to their
application things so they have their
splash screen and then they have their
game screen which is quite a bit
different from that you know you can
sort of see how they're related but the
best of all is they also have the
starting window which has nothing to do
with the other ones so you get a
starting window up with some default
theme that looks nothing like the rest
can usually in games the starting queen
dude you get is the ginger bright
starting window which is very sad so
don't don't go with the sad window so
they bring up this one then after three
seconds they'll bring up their home
splash screen then they bring up their
own much better to actually set the
information in the starting window to
actually look like the rest of your
application whether it's a status or in
the nav bars or just the the themes and
the style attributes overall just make
it look like it actually belongs or even
better if you want a splash screen
experience just tune the starting window
to be that splash screen experience
instead so essentially when you're on
create you find yourself changing
styling changing the channel the
background of the window you probably
want to do that from the theme instead
in your manifest there are sometimes
good reason to do it in oncreate because
you're computing data but every time you
can do it in XML instead and you'll get
the correct starting window cache your
data locally so don't make it necessary
to go back to the server and get that
information again we saw a demonstration
in this in Adam and Yeats talk from
yesterday so if you're gonna get that
information you went to a lot of trouble
to get it wouldn't it be nice if you
kept it locally so that if user goes
back to see that information again we
don't have to make another query across
it and also cache the input locally so
if the user is has input some
information into the system make sure
that you retain that so that if there's
something later that depends on that
information we haven't simply lost it
along the way we have exactly 20 seconds
to go and about 12 more slides each of
which is going to take five
so do fewer slides we are doing our
presentation is the longer we talk about
your slides so it extend we'll have one
slide I think we'll call it a day there
thanks very much we'll be outside if you
have any questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>