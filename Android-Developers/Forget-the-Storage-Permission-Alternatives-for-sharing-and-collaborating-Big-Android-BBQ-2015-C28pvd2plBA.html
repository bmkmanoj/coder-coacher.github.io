<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Forget the Storage Permission: Alternatives for sharing and collaborating (Big Android BBQ 2015) | Coder Coacher - Coaching Coders</title><meta content="Forget the Storage Permission: Alternatives for sharing and collaborating (Big Android BBQ 2015) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Forget the Storage Permission: Alternatives for sharing and collaborating (Big Android BBQ 2015)</b></h2><h5 class="post__date">2015-10-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/C28pvd2plBA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to forget the storage
permission it's not often we go to a
tech conference and get to go to a talk
where we're specifically gonna be
forgetting things but it's the end of
the barbecue so hopefully we'll actually
learn a few new techniques which will
just replace that knowledge rather than
totally void it out we'll save that one
for later but really trying to reduce
when we actually need the storage
permission so this would be write and
read external storage so a little bit
about myself
I've been doing Android development for
just about five years now I'm kind of
started on my own but then got a job
doing a full time at fun ware and then
joined Facebook sorry I didn't fix
everything I want there's a lot better
but for this last year I've been working
at Google as a developer advocate kind
of working both with the community and
with the internal engineering teams
primarily been focused on an advanced
Android Udacity course this is online
learning kind of taking her out to
really be production-ready all those
little things that really make an app
that much better and then of course just
recently launched Android development
patterns with Joanna Smith kind of best
practices in Android covering a lot of
the api's as well as kind of the reasons
why behind some of these things
my focus primarily has been kind of the
android framework in android support
library and will be kind of talking
about lot of those things today
so we're gonna be forgetting things
we're gonna forget the storage
permission but to really forget it we
need to know kind of what was it giving
us in the first place so let's start at
the beginning kind of where can we
actually store data so first there's
this concept of app specific storage
space so as you'd expect these are
directories which are specific to your
app and to each user now one important
thing about all of these directories
that will be covered here is that
they're all completely emptied and
destroyed when your app is uninstalled
so it's really easy to say okay well I
have now completely uninstalled the app
and now data associated with it isn't
left lingering on my device there's kind
of two main types of these directories
there's private directories stored on
internal storage so these are accessible
via get filed ER and get caster so as
you can imagine get filed or for kind of
actual real files user data well get
cached or is more for caching files say
if you were to download large images
from the internet this would be a good
place to store them because when you run
low on memory this space can be cleared
without actually harming users data now
the other side of things are these
concept of external directories and I'll
use air quotes because they're not
actually external on many devices like
Nexus devices they're actually on the
same flash drive as the internal storage
it's simply just a different partition
of the same space but in all cases it's
actually that those external directories
are the ones that are readable by all
apps that have these storage permissions
so no necessarily want to put sensitive
information in those folders because
they are world readable however for our
cases you can't actually do a little bit
more with them so these come in the face
of external files directory which is
very similar to our file directory for
user data on this external partition and
in KitKat
we actually introduced the ability to
have multiple external files directories
so in this case you could have one
external file on that internal slash
external storage and another on like
your SD card so this will be returned by
the pluralized form of the method
similarly for cache directories same
type of thing and that also in lollipop
we added external media directory
these are directories where you can
write files too that are then read by
the media scanner so this is what allows
other apps to get all of the images and
videos and pictures that are in that
folder and then make them available to
other apps via the media store API now
the best part about all of these
directories is that they don't actually
require permissions on newer devices so
the other directory which I really want
to mention also for game developers
especially far as the extension file
director OBB directory this is where
apps that are larger than the 50 or now
100 megabyte limit can store expansion
files these are actually shared across
all users so if you have a huge large
game on a tablet that's actually shared
across all the storage you're not
penalized for having the same huge app
installed multiple times so the other
part of this right those were app
specific directories the next part is
public storage so these are the
permanent files that survive your app
being uninstalled now for many users
this actually means that those files are
never going to be touched never going to
be deleted and may be orphaned forever
because the chances of many users
actually using a file manager or going
in or even plugging their Android phone
into a computer are actually fairly rare
many more users are just using the apps
on their phone and don't actually
realize that this public storage exists
now from that perspective again this is
stored I'm kind of that external but
maybe not external space it's called
external and the root of it can be get
by get external storage directory right
but you probably shouldn't actually
write files to that root directory right
it's like writing to C colon slash or
the beginning of their directory like
maybe not the best idea you can do it
but we'd much rather if you were writing
to this public external storage use one
of the directories that we've created so
there
one for pictures and notifications and
ringtones various other media types
which Auto sort into these public
directories now an important part about
this is if you have multiple users on
the same phone right which is now
possible or on tablets which has been
possible back a number of versions all
of the external storage is actually
sandbox for each user no way for your
app running as one user to ever see data
that's in another users public
directories even though it's called
public still sandbox to that user right
that's more of a SELinux thing than
anything else but is actually really
important for things like android for
work where that separate user is of
course totally self-contained and
separate from your private data so we
talked about kind of what all these
directories mean for the storage
permission so for those internal
directories that get filed or get cached
or those can always be read with no
permissions whatsoever they're always
going to be available to you can always
write to them they're great and of
course they're Auto cleaned up when your
apps installed so it's really nice for
users now the external app specific
external storage has changed in KitKat
we actually removed the need to use the
storage permissions to read and write
those directories so if you were
targeting pre KitKat you actually needed
those permissions even though they were
app specific directories and we've
lifted that restriction as of KitKat so
now you no longer need that awesome
now that external user storage that
public storage that always requires the
storage permission right we very much
want users to be aware that apps are
writing to this space that may
potentially be taking up a very large
percentage of their devices space but
are not actually attributed to that user
right if a user goes in and says clear
data or clear cache though those
external files are not deleted so unless
user is using
file manager those files are not ever
going to be cleaned up
and from a user's perspective they might
not know which files go to which app or
which ones they can delete now the
storage permission is even more
important in marshmallow because in
marshmallow with the runtime permissions
model the storage permission is
considered a dangerous permission that
means if you're targeting marshmallow
and running on a 6.0 device you'll
actually need to request access to the
storage permissions at runtime get this
nice mildly scary-looking dialogue that
says can they access all of your photos
and videos everything you've ever done
in an external storage right which yeah
that's true that's part of the users
public external storage but you have to
think really long and part of whether
that's actually the right choice now if
you're saying well I only write to those
app-specific directories you know I'm
good there's actually a super easy way
to remove storage permissions you have
you can use Mac's SDK version max SDK
version just says I want to use this
permission but as of KitKat I don't need
it anymore I can safely remove it from
my manifest users won't be bothered by
it at install time I don't need to worry
about it for runtime permissions you do
this just by setting the max SDK version
in your users permission in the manifest
and that's all you need to do to remove
the storage permission but still keep it
around for those cases where you're
running on an older device but you know
mini SDK
KitKat that's not totally unreasonable
ring
maybe maybe one day min SDK 21 that's
even better now this isn't actually make
your life more difficult but really to
just make it so that you can balance
your needs as a developer to save files
to users storage and their need for
privacy and control when really giving
them giving your app the storage
permission is asking for a lot of trust
right those are all of the pictures all
the videos that that person has ever
done on that device and sometimes those
are a little bit more sensitive and part
of that is that it's really all or
nothing right there's not necessarily
that requirement of saying oh well I
would really like access to this
specific directory because of this
all-encompassing nature of the storage
permission now part of this is just a
complexity kind of reason users don't
really understand what kinds of stories
there are like if you asked a typical
user all right out of these 10
directories which four of them would you
like the app to be able to read to
that's a little bit harder than just a
yes-or-no kind of an answer now the one
thing is is that you really want to
avoid this right that's the whole reason
we're here so let's talk through some of
the ways where we can really actually
get a lot of this functionality right a
lot of that communication between apps
without actually needing these
permissions so what what is this better
way is there a different thing to do and
it turns out that we have a whole
permissions model just for sharing
individual files via you our eyes now
URI you might think of it as kind of
like a file path but it's actually a
little bit different because you can
apply URI based permissions to it now it
really kind of started back in the
beginning of Android with our intent
system that's the way of sending
information or
between different apps right you may say
like a start activity and passing an
intent and that's how you would then
trigger another app to do things
these URI based permissions are attached
to that same infrastructure allowing one
app that does have the permission to
access some file or resource the ability
to then kind of forward grant a
permission to another app that doesn't
have permission by itself but via that
intent system they're able to then
suddenly get permission to just that
specific file so this sounds like
exactly what we need to do many of the
operations between files say sharing or
something else that we'd normally use
files for so there's actually two
different ways of using ura based
permissions one is just adding a simple
flag to your start activity or start
service intent and these flags just say
yeah any URI that's attached to this can
actually be read by the receiving app or
even written to by the receiving app so
this could be something for example like
you include a image your URI as well as
the read permission now all of a sudden
the other app can then read that image
without actually requiring access to
wherever that file is actually stored in
addition you can actually
programmatically grant and revoke these
permissions you can call grant URI
permission with a specific package and
say this package is always good to read
any URI that's included similarly you
can actually revoke a URI permission so
this would be useful if like you're
deleting an internal file and other apps
have a URI to it you may want to revoke
all your I permissions to that file just
so then it doesn't linger on so let's
look at kind of one of those common
examples right the share button you've
seen hopefully in many apps the actual
share button not some fake share button
and you know this is very common for
using say sharing an image from your
camera app to say a social media app now
if we were able to use external storage
right the sending app might write it to
someplace in a public directory and then
the reading app would then need to have
the read storage permission to then read
the app and of course this will never
work in android for work scenarios where
the actual receiving app and the sending
app are on two different users so maybe
we can use something else to actually
get this across and you'd think maybe oh
we just pass in our grant flag and we
pass in our file URI and we're golden
it's one problem follow your eyes don't
work with URI based permissions file
your eyes are always protected by the
underlying storage permissions you're
directly accessing a file and therefore
you're going through that filesystem
which is the storage permission so
instead we need to add just a little bit
of indirection between our files and the
other apps and we can do that via a
support v4 library class called
file provider well this is built on top
of content provider which you may have
heard of and dislike or like in some
cases you don't actually need to write
any content provider code which is great
there's actually very little code to
actually write in the file provider what
this allows you to do is actually give
apps access to files in your get files
directory your get cache directory or
any of the get external directories so
use there be places where you can write
without the storage permission right
especially on KitKat and above but
through file provider now other apps can
read those files that breaks the need
for any of the storage permission
because what we are sending is a URI and
not a direct file
and that allows us to use your I based
permissions now there is some setup for
file provider specifically every one of
those file provider URIs has kind of a
unique prefix which we'll call the
authority now you can just define it as
a static string somewhere but I like to
be a little bit more fancy this is the
limit of my Gradle knowledge and
actually define it in our Gradle file
based on our application ID so this
would be kind of the package name in
your app and we can actually define it
as a manifest placeholder so now we can
actually use it in our manifest file
without having to reference the actual
string and we can reference it in our
build config directories in any of our
Java classes and now it's always in sync
we only have one place to change it and
if we have multiple versions and build
configs it just works so our manifest
entry just defines our file provider
we're not writing any code so far it's
just a little bit of XML that you can
paste right in because all of the
configuration is actually done by the
file providers path metadata so this
metadata is just a really simple XML
file that you put in your resume that
just says what directories you're
actually providing through file provider
right what we don't want is we don't
want every app to be able to read every
file in get files directory and get
cache directory you may want to just
have one directory that you make or in
this case three directories you can have
it read from to get file directory using
the files path get cache directory via
cache path and any of the get external
directory via external path then the
path is kind of that unique substring or
subfolder within those directories so
that's all the one-time setup you only
need to do that once and then never
touch it again no matter how many share
buttons you have throughout your app now
we can actually share a file so just
like before we'll have a file that we
want to
and then we can just use one method from
fileprovider our debt uri for file
method and this takes in our build
config and the file and then spits out a
special content URI we construct our
share intent and then actually provide
read access by calling set data with our
content URI and then adding the read
flag now the important thing to note
here is that that add flag of grant read
only applies in this case to your eyes
we've set in set data so if we leave out
that line our grant flag won't actually
apply to any you our eyes so it's really
important that those things kind of go
together in almost all cases on the
receiving side we can extract the URI
and then getting out the actual data out
of that URI has a very simple method get
content resolver open input stream now
the nice part about open input stream is
it works for practically any URI you
pass it whether it's 1 of our file
provider your eyes a file URI or an
Android resource URI it's all the exact
same code from your receivers
perspective it shouldn't matter how the
sending app is sending that file across
because you can parse it all in the same
method
so I here we just use bitmap factory to
extract a bitmap from it now the other
thing that's nice about this is that
that you can actually daisy chain those
permissions along say this is a
receiving activity but it's actually a
service that needs to upload that file
across you can call the same set data
and add the grant flag URI to your start
service and that permission will
continue to daisy-chain
through different components or if you
want to send it to another app you can
continue to pass it along as long as you
continue to use the grant flag or I'm
now you may have noticed the file not
found exception so here's where things
go horribly wrong but it's also the most
important part
sharing and that's cooperation it's a
two-sided street there's a sending app
and there's a receiving app like I said
a lot of this relies on in this case the
sending app to store it in the right
place to use file provider so that the
receiving app doesn't need the storage
permission all right if the sending app
isn't doing a good job is writing it out
to a directory that assumes that
everyone has read storage there's not
actually a whole lot you can do here
except have read storage to read the
file
now many Google Apps employ a strategy
where if it fails then post the message
thing
hey I can't read that file like the
other app is trying to send me something
that I can't read now
that definitely pushes the requirement
back onto the sending app to do it
correctly so if you have a sending app
that's doing it wrong please fix it
because that's breaking everyone else
right now hopefully apps are testing
with things like Gmail and other apps
that are already installed on the system
to make sure that it works but same
point you can't actually do that where
we're setting the onus on the sending
app now you can take a different
approach right use that file not found
exception as actually a requirement to
say oh let me get the file permission
right say you're running on marshmallow
and using runtime permissions now that
works it would get the number of shares
up to a higher percentage because you
would be able to then say oh I don't
have access this let me see if adding
storage permission helps me work around
some of the bad apps that we're all
fixing like right now No ok we'll give
it a few more minutes so that's one way
to do it but unfortunately that means
that your app that appears is using
storage permission when you install the
app it says hey these guys are using
storage permission even in runtime model
you need to have a second dialog that
pops
the users may not know oh well I'm
sharing a file over right and this works
for other apps but this app is saying
now it wants to read all of my photos
and videos like I thought I was just
giving an access to that one photo right
so you kind of have to deal with that
different privacy model where maybe it
makes more sense to say I don't want the
storage permission I want to say well
there's probably a different app on your
phone that can give me that same
information or maybe there's some cases
where you can use different technique
which actually reverses the situation
and that's action get content I get
contents kind of the reverse where we're
asking for a file from a different app
and you do this simply by requesting it
by a mime type say image slash star to
get any kind of image just wanna
pictures anything you got and then you
want to immediately use that result in
your app say attach it to an email or
send it to a friend via messenger what
have you now much of the logic here is
actually exactly the same as action send
just in reverse manner he'll call action
good content passing in a request and
then the providing app the one who the
user has selected will use file provider
surprise like who would have guessed
they'll use file provider get URI for
file and then send that file back to the
the requesting app and then open input
stream to open the file right very
similar but just in the kind of reverse
model now note none of this code
requires the storage permission we're
still asking from one file to the other
but it still works right we're using
your I based permissions and because the
user is actively included in the
selection process there doesn't have to
be a blanket storage permission right
just by selecting I only want to share
these two pictures or something then the
user knows oh I'm giving this other app
access to these two pictures so we don't
need a separate set of permissions on
top of this now the nice part about get
content is you can actually do it with
multiple files so extra allow multiple
true and all of a sudden assuming the
providing app supports it you can't
actually select multiple files on the
providing side you'd actually add all of
these you are eyes to what's called clip
data so this was introduced in API 16
that allows you to have multiple you are
eyes covered by that same grant read
permission so before we had set data for
a single URI and now we have clip data
for multiple your eyes now you may be
thinking Oh API 16 I support Gingerbread
because I hate myself or I really love
my users right there are lots of
Gingerbread users out there we love them
too and it turns out that extra allow
multiple was added in API 18 so not a
problem for this case right in most
cases for earlier api's they didn't have
a concept of reading multiple your eyes
until after API 16 so in most cases
these set data is actually enough for
the cases where you're not on API 16 so
from our chart at the beginning KitKat
kind of changed a lot of things it
actually added a new action called
action OpenDocument
this is part of what we call this
storage access framework which is a
really big scary easy to Google name you
need more information about it but it
works very similar to action get content
via API still intent it actually covers
many of the allow multiple and category
openal that we saw for get content and
of course no storage permissions
attached to any of the storage access
framework I wouldn't really be talking
about it if it had storage permissions I
would defeat the whole purpose of my
talk but what it does allow you to get
is actually additional
api's on top of that get content open
input stream kind of API that we already
have through document contract so here
we have different api's of getting
additional metadata about files when it
was last modified lots of good
information you'd expect from a file but
we're not providing file paths for
providing access to documents and better
yet all of these your eyes actually had
the ability to be persisted so it's not
just a one-time oh I want to read this
one file and then I have to create a
copy of it and then keep a separate copy
for myself you can actually say I want
to persist these URI permissions from
anything included from the storage
access framework that allows you to
actually have a list of things that go
on forever or track what things you've
actually ever accessed so do are we
supposed to just always switch to open
document like everyone's running KitKat
so we're fine now pre KitKat you don't
really have a choice it is still get
content the open document won't work you
won't find any apps to do open it
doesn't exist but they really have
slightly different purposes so get
content is that temporary access to a
file to our URI
so consider the case of like an image
editing app get content could still be
used for importing clipart
or adding layers to an existing editing
session right in that case it doesn't
really matter that you have direct
access to the file forever it's more
that you want kind of that one time oh
I'm gonna paste this into the file but I
don't want the user to have to pick from
a predefined list I can use any file on
their device but for accessing the image
right for our image amping we may want
to use open document right because then
we would have persistent read and write
access to that edited file this allows
us to actually save the edits
directly to the file overriding it by
actually saving it where the user
expects to find the file at a later
point which is great because if you've
ever done an editing that has different
copies you'll somehow never find that
edited photo ever again if you actually
look for it but if you have open
document now you can actually save it
directly over the file you can also do
really cool things like say your editor
once a recently used list when you open
it up like let me shoot the last five
images that you edited well if you've
persisted access to those you arise now
you can have a list of all of the images
that you've had recently without having
to figure out okay well the user
selected this file from somewhere and
let me hope it's there I can just use
the URI that I already have now one
thing is is that if that file that they
selected something from was uninstalled
or say the image was removed from the
source app then when you call give me
the URI again it's not a returning thing
the file is gone right that's the whole
reason behind the URI thing but in many
cases that's exactly what you want right
you don't necessarily want from a user
perspective for them to say oh I've
deleted this from my gallery but there's
still that app that has a copy of it and
that out there's another copy of it and
then that second app doesn't even have a
delete button or anything so now I have
this data that I don't really want on my
device but in fact open document also
allows document providers to provide
delete access to other files you may not
even need to go back into the gallery
and delete the app if you're using open
document you may actually be able to
delete it directly from that app and say
oh well you know what like I don't think
we actually need this file now you will
probably want to check to make sure you
actually have delete access before
trying to just delete users files it may
not always be the case but there's one
thing to be sure open documents just
better so it provides all of the same
functionality as get content
in addition to this new functionality
we've talked about and frankly a lot
more functionality so when you call open
document you're only going to get apps
that's support action open document
right that have a document provider the
class that they would need on their side
now this means that you may get a more
limited number of apps but obviously
when you're using open document maybe
you're expecting that persistence or
those new api's however if you're on
KitKat and above and you call get
content you'll actually get both you get
all the apps that support get content as
well as all the apps that support open
document because anything you could do
with get content can also be done on a
document URI that you've retrieved yeah
open document the same opening the same
checking things on either one now this
does allow us to do some optionally cool
things there's actually a document
contract is document URI so you can
check to see if your return result is
actually a document URI and then you can
use those new api's and if they've
selected something from a Content app
then you can just use just the default
functionality now the nice part is is
that even though you're getting these
URIs you can use a document file class
which is part of the android support
library v4 which kind of gives you a
very similar API to a file for document
your eyes so you can check you know do I
have read access to I write access do I
have delete access all in a very simple
API and use it simultaneously for files
and simultaneously for these document
your eyes which is really nice very
handy now that does mean that if you're
an app that supports get content and you
support open document you need to
disable your get content on API 19 and
above otherwise users will see content
one in the list and your storage
provider in the same list so you disable
one and say well open document can do
things that content does so I'll just
have that appear in the list
you no longer need get content if you're
using open document so what is accessing
the storage access framework look like
from a user's perspective so from their
perspective they're in an app say our
photo editor and they hit the button
saying get me a file well I'm like get
content where they have to pick an app
and then go into that app and have some
custom UI where they select things and
then that app doesn't support multi
select and then they're clicking on one
and hitting load and click and a second
one hit load all of the UI for storage
access framework is done by the system
you don't need to write any UI to
support the storage access framework you
can just do just the data part of things
so this is really nice because then when
a new version Android comes out you get
even more functionality for free you
don't have to say oh I'm going to
support this new stuff as much because
what's happening is the system is the
one who's reading from the document
providers and giving new functionality
so for example in KitKat and above
coming with the system you get internal
storage a document provider provided by
the system as well as if you plugged in
an a removable hard drive or something
you'd actually get a document provider
for that removable hard drive
automatically as soon as you unplugged
it that document provider would
disappear that's great how people can
select those files in marshmallow we've
extended that so now when you have an SD
card you can do the same thing and the
storage probably will just simply appear
for the SD card so now all of a sudden
you can get right read and read
directory access to the SD card for
practically the first time ever so we
mentioned our action open document for
accessing a document now keep calling it
a document
it's not necessarily a file on your
local storage it could be piped directly
across from the internet it could be in
an encrypted blob on a specific hard
drive doesn't particularly matter
because from the readings app
perspective all you're getting is an
input stream or a file descriptor but
then you can stream the contents from
and all the metadata is handled
separately so you'll also get some other
new ones action create document it's
kind of like the Save button in an app
right where instead of you saying oh I'm
just gonna save it to this one directory
that the user knows no idea of where
that is they can instead save it to
Google Drive or save it to their
removable storage doesn't actually
matter where they save it because again
you'll have access to that URI you can
get back to that file at any point this
is very different from the you know I
want to save it always in this one
directory now users can use different
storage providers and switch between
them and then if they want to select a
file then maybe on a different device
they saved it to Google Drive you go on
to the other drive now they can open
document select Google Drive and
suddenly get access to that file without
you having to integrate with any SDKs or
do any extra work because storage access
framework kind of separates you from
where the files are actually stored now
my personal favorite was added in
lollipop and that's open document tree
so this instead of giving access to an
individual file now you get access to a
whole document tree or let's call it
just a folder because that's a nice name
you get access to the whole folder and
all of its children right so in this
case you can't actually say like oh well
where do you want me to save these
backups of your app and you can say well
I want a store than my Google Drive and
give them access to just one particular
folder or not your entire Google Drive
because that's maybe a little scary and
terabytes of data maybe but just one
directory
and then throughout the entire lifetime
of your app you can then read and write
to that directory without additionally
bothering the user of oh hey where did
you want me to put this file every time
you can have a default save location for
new edits that could go into this file
right the choices are really very
limitless when you're actually in that
kind of setting so implementing a
document provider kind of a few methods
not any content provider methods even
though it's actually a content provider
underneath the covers you'll notice we
do that a lot because contrib riders are
really great at providing your eyes to
other systems it's how we do
communication between devices or between
apps instead you'll implement four
methods query routes which is kind of
the top level like I am an app that
provides storage access framework
controls and this is my name right I
want to be called Google Drive that's a
good name for Google Drive now normally
you just have one route but you can't
actually return multiple routes say if
you're logged into multiple users at the
same time you could have different
accounts in here so that the user
without having to go into your app and
select an account and then select which
file they would just appear as top-level
directories in the storage access
framework UI now query child documents
and query documents are kind of what you
expect information about all the things
within a folder and information about a
particular document and then open
documents really kind of the main key is
the give me the bytes give me the
information about this file right and it
may just be loading the file itself or
maybe doing something totally different
like streaming across the internet and
opening up a socket that persists
forever and that's the thing from the
apps perspective it doesn't matter right
from someone who's reading it in again
it doesn't particularly matter what the
API is doing it's just that open
document exists and suddenly it works so
there's actually quite a few resources
about implementing it if you're one of
those things
so run Dropbox or box or Google Drive or
really anything you want there's
information on developer.android.com
I built a sample app called local
storage which gives you kind of both a
simple UI to test out all of these
actions that we've talked about as well
as give you a sample storage provider
which you can build upon and then Jeff
Sharkey the storage framework engineer
who's responsible for just about all of
this stuff wrote an example provider
called vault which actually encrypts all
of the files and then Auto decrypt it
when you use them in storage provider so
very nice example of kind of going a
little bit beyond just a simple open
document opens the file underneath the
covers so to recap what do we need the
storage version for accessing our
internal apps specific directories nope
nothing there
external App Store app specific
directories not above lollipop so we can
use max SDK 18 for sending files via
action sent know we got file provider
we're good for receiving files or
requesting files from other apps no not
if everyone's doing their job right but
you know if you really do want to have
that fallback of asking for the storage
permission really really consider at
most max SDK 22 don't specifically ask
for storage permissions on runtime
permissions model just because you want
access to one file in theory
hopefully marshmallow will kind of push
apps to be a little bit better in this
range because really we want everyone to
be playing nicely they don't need access
to every one of the photos and videos
that you guys have shot especially if
their videos from big Android BBQ don't
share any of those ones you know the
ones I'm talking about but really we
want to make the storage permission the
exception right if you've booted up a
marshmallow phone and you look at the
number of permissions you'll note that
storage crucians generally the highest
one in
and I'd rather it be the lowest one in
count because really that means that
those apps you know unless you're a
specific app like a file explorer or
something like that that needs access
all those files probably don't actually
need access to all of them so we've
actually done a lot of work on that even
internally in Google now like one-time
permissions are still a really big deal
inside of Google as well so for example
the next release of Google Maps Android
SDK is removing storage entirely no
longer need the storage permission to
run any of the NAP stuff which
previously they were using and even
right now in 8.1 you don't need the
storage permission on marshmallow
devices so there's actually a lot of
documentation on the Google map site
that tells you exactly when those things
are happening and will shortly be
updated when the next version of Google
Play services comes out so thank you all
for your time my name is ian lake you
can catch me on google+ or twitter happy
to help at all times I'll be down here
for questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>