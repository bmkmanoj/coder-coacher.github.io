<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Android Wear 2.0: Making Watch Apps more Standalone - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="Android Wear 2.0: Making Watch Apps more Standalone - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Android Wear 2.0: Making Watch Apps more Standalone - Google I/O 2016</b></h2><h5 class="post__date">2016-05-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Hw37dxW6q5g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey everybody really glad that you could
join us here today I'm Kenny Stoltz I'm
a product manager on we're and I lead
product for some of the standalone and
iOS features and I'm Griff Hazen I'm a
software engineer and tech lead for
'where's developer platform so both of
us have been working on Android wear
since before 1.0 and today we're gonna
take you through a couple of the things
that you'll want to consider when you're
designing and building sandal own apps
in wear 2.0 okay so first a question why
would you build a standalone app there
are three reasons and the first is the
most obvious sometimes you just don't
have your phone with you the running is
an obvious use case where you might want
not to have some phone strapped to your
wrist and a bunch of other fitness
scenarios are similar but standalone
offers the opportunity to free you from
your phone in a lot of other situations
that you might find yourself in
throughout the day so if you run to the
store and you forget your phone if
you're doing chores around the house you
don't want to have it in your pocket if
your phone dies etc standalone will let
you still use that small screen on your
watch between the times when you've got
your phone with you second is extend the
building standalone apps is a lot more
like building mobile apps it's
particularly faster and easier to build
them if you already have an existing
mobile app so you'll spend less time
rewriting the basic infrastructure for
your app which means that you can spend
more time making your app better on
wearables the last reason is that
standalone apps will work on watches
connected to both Android and iOS
devices so you want to make your app as
you want to offer your app to as many
people as possible and if you follow the
design patterns that we'll share with
you you can write one wearable app that
will work on watches connected to both
devices okay so now we'll go through a
couple of things that you'll want to
consider before you start coding
so first of all what should a standalone
app do the easiest way to start is to
think about what your phone app does and
then distill that down so think about
what the most important tasks that you
are asked allows the user to accomplish
and then what flows are absolutely
necessary for these or to go through in
order to accomplish those tasks now you
want to think a little bit about your
user and how they'll be using your app
they're likely to be on the go so you
don't want to hold their attention for
too long and you want to make sure that
you're making it fast and easy to
complete those tasks keep in mind that
you don't want to let the user get
halfway through a task and then ask them
to switch from the watch to the phone
first of all obviously that might not
have their phone with them and second of
all they might get frustrated or lose
their place so you want to try to
support every flow that you can from end
to end on just the wear of them that's
said your user often has two awesome
devices with them at the same time so
it's great to make the to work and
harmony and have appropriate and useful
content on each screen the data layer
API is that we really that we released
with Android wear 1.0 will continue to
work and you can use those to build
multi-screen experiences with Android
phones finally you want to consider both
types of phone that your user might have
while they're using your app so we're
2.0 Developer Preview will allow you to
pair with an iOS phone once you've
paired with the phone you can side load
your app onto the watch and then test it
there are performance differences
particularly the amount of bandwidth
that you'll have so you really should
test and it's a great way to make sure
that you've got a standalone app
if you're already familiar with how to
architect an Android phone app you'll be
glad to learn that we're apps can now be
written in a very similar way sure the
user interface may need to be scoped
down to the most important user flows
and delimited real estate but the
underlying coding services can be
written in the same way and even shared
between phone and wear apps you can
you'll practice the cloud in the same
way use similar authentication methods
in the same cloud to device messaging
let's dig in to a few areas where we are
providing additional help for standalone
apps will also go through some Android
API s you may be familiar with on the
phone and how they can be applicable and
useful and we're first off we'll take a
look at how standalone wear apps can
communicate with cloud services and
store data one of the most important
platform changes to enable standalone
apps is the expansion of direct network
access where apps will now be able to
communicate directly with cloud services
and can also schedule background work
that requires network access when the
phone is connected over Bluetooth
network traffic proxy through the
phone's connections when the watch is
outside of phone range Wi-Fi and
cellular networks are used depending on
hardware support the wear platform takes
care of the transitioning between
networks an existing wearable apps data
stored in the cloud was often relayed to
the wearable via an Android phone on an
Android app on the phone using data
items in the wearable data layer api's
the wearable data layer is still useful
when coordinating between watch and
phone but with standalone it may be
simpler to go directly to the cloud for
many use cases in addition to simplicity
it also works when the phone is not
available or when paired to an iOS
device when talking to the cloud you can
use protocols that you're already
familiar with like HTTP TCP or UDP once
your data is fetched you can store
locally on the device just like on
phones using shared preferences sequel
Lite or internal storage
if your and art phone app is well
maintained and tested you may be better
off starting from your existing code
base and cutting things out as opposed
to starting from scratch common coding
services like your networking data model
and business logic can be shared between
your phone app and where app using a
shared library form factors specific
code and resources can remain in
separate build flavors for phone and
wear this type of structure is already
supported natively in Android studio and
Gradle when fetching data from the cloud
it's important to fetch only the data
that your wearable app will need
otherwise you may introduce lazy memory
use or battery use unnecessarily in some
cases for example when over a Bluetooth
le connection your ad may have access to
just 10 kilobytes per second of
bandwidth we recommend auditing your
network traffic works both requests and
responses for extra data that perhaps is
only intended for phones
shrinking large images server-side
before sending them to the wearable is
another great way to reduce network
traffic in Android background services
are a powerful tool but should be used
wisely in order to preserve battery life
in Android 6.0 doze and half stand via
resulted in significant improvements to
battery life by allowing devices to
enter a deep sleep when idle or
stationary dose has been extended in
Android and an Android wear 2.0 to
enable some lighter optimizations
whenever the screen is in low-power
ambient mode or off here's an overview
of the new doze lifecycle after the
screen turns off or enters ambient mode
for long enough lightweight doze can
kick in during doze background tasks may
be deferred to execute during periodic
maintenance windows if the device later
becomes stationary for long enough a
deeper doze mode kicks in similar to
doze in Android 6.0 to ensure your
background tests are executed as desired
it's important to write them in a dose
safe manner the jobscheduler api allows
an app to
mr. Frodo saved code execution and is
recommended for background work various
constraints can be selected when
scheduling jobs for example the need for
connectivity device charging or periodic
execution it's important to be
conservative when scheduling jobs and to
avoid execution in ways that could
adversely impact battery life jobs
scheduled with the job scheduler API use
the job info builder object to provide
constraints and metadata we'll go over a
few useful constraints that are
available to request networking use the
set required network type method and
specify any or unmetered network type
unmetered is appropriate choice for
large data transfers while network type
in e is more appropriate for smaller
transfers note that in where 2.0 some
low bandwidth networks like Bluetooth le
are considered on meters sorry I'm
considered metered
to schedule a task that requires the
device to be on the charge of ER use the
set requires charging method or to be
currently idle by calling the set
requires device idle method using both
of these together can be useful for
lower priority background work or
synchronization here's an example of a
job being scheduled that requires
unmetered networking at the time the job
is run in addition to the device being
on the charger job schedule will
activate my job service when both of
these constraints are met the builder
method set extras can be used to provide
additional metadata this bundle will be
passed to the job when executed note
that my job ID value passed to the job
info builder constructor this is an
application specific identifier
subsequent calls to cancel jobs or
create a new job at the same job ID will
update the existing job here's an
implementation of a job service to
handle the job from the previous slide
when the job executes the on start job
method is called with the job parameters
object passed in the job parameter
object allows you to get the job ID and
also any extras bundle provided when
scheduling the job
the unsub method is called on the main
application thread so therefore if any
expensive logic needs to be run it
should be pushed to a separate thread in
this example an async task is used to
run code in the background once your
work is completed call the job finished
method to notify job scheduler that the
task is done okay so now we'll go over a
couple of different options that you
have for authentication the reason that
you need to start thinking about
authenticating is that now your app is
running entirely on the wearable so
whenever it makes your request to the
cloud on behalf of the user it's going
to need to have a valid auth token that
shows that web service that it has
access to that private data but before
you rush to ask the user to login please
consider what you can do with an
anonymous user you want to try to avoid
authentication where it's not necessary
and if you need to record data you
should try to record it locally instead
of writing it to the cloud by default
you have to remember that the user might
not have access to the network at the
time when your app is running finally
when you do need to authenticate the
user you want to focus on the fastest
and easiest methods from the users
perspective so the simplest way from a
developer perspective is the same as on
the phone you can create a login
activity and you can ask the user to
type in their username and password now
this activity is a normal activity and
if it has an input field with the input
type text password then we're 2.0 will
show a special password style keyboard
that will allow the user to type in
their password on the watch now this
keyboard is optimized for the watch but
it is still very small so you should try
to keep from having to show that
keyboard where you can a couple of ways
that you can do that which are better
and avoid that typing are to use our
sign-in technologies like Google sign-in
or smart lock for passwords so both of
those technologies use the existing
that user already has to Google and
exchange that for a token that's valid
for your web service smart lock for
passwords in particular is very simple
to add to your existing client app it
only requires client-side changes and it
works with existing users who have
already registered using whatever IDP
they are using so both of these options
will be available in some future
developer previews that we'll be
releasing throughout the summer so
please keep an eye on so if you're
familiar with writing where on the data
layer you might have already thought of
one way that you can get a token over to
the watch that's to request that token
on the phone and then pass it over to
the watch via the data layer so this
method has some benefits it's fast and
easy for the user but it may have some
problems if you're off provider doesn't
like the fact that you're requesting a
token for the watch on the phone so a
token that's destined for a different
device it also does require the user to
have their phone with them and have it
on and connected when they're running
your app and finally it doesn't work on
iOS so if you do choose to use this
method in your app make sure that you
have at least one backup method that
does work so one final method that we'll
also be bringing to a future developer
preview is the ability to open an OAuth
URL on a phone so this oath URL points
to an OAuth 2.0 authentication service
the user will then switch to their phone
follow through the OAuth login flow and
then when they complete the auth service
will return a token destined for the
wearable which is sent by a callback to
the same call that you used to open that
URL so this option will work on iOS but
it does require the user to have their
phone with them when they need to log in
so there are a lot of options here so
here's a quick table showing some of the
trade-offs as you can see Google sign-in
and smart lock for passwords both work
if the watch is connected or
disconnected from the phone and they
work on iOS and Android and they're fast
and easy for the user
the middle two options both require the
user to have their phone with them and
the final option is a good fallback
option if all else fails if you follow
along with the previews we'll be sharing
these methods throughout the preview
cycle and that'll help you to build apps
udders fast and easy to log onto as
possible a third area of focus for
standalone wear apps is how to retrieve
notification from the cloud either for
display to the user as date or as data
for your wearable app to use Google
Cloud messaging now known as firebase
Cloud messaging or fcm is now supported
by where FCM allows you to public to
push data and notifications directly to
where devices from the cloud example
uses include delivering sync tickles
small data payloads and user visible
notification it works well with those
and is cross-platform the same reasons
to use this service on phones apply to
standalone wear apps
it's the recommended way to push events
to watches to send messages using FCM
first collect a registration token when
your wearable app runs and include it as
a destination when posting messages to
the FCM rest endpoint from your server
those messages will then be delivered to
that device FCM messages can include two
types of payloads here's an example of
JSON format a message they will deliver
a user visible notification directly to
the stream when received by aware device
when the user taps this notification
your app is launched the second type of
payload is a data payload with a set of
custom key value pairs you can include
both of these types of payloads in the
same message as well where FCM is for
notifications from cloud to device will
now talk a little bit about Android
notifications one of the most useful
features of a wear device is the ability
to see your phone notifications bridge
to the wrist with standalone wear apps
both phone and watch may receive a
similar cloud event and decide
independently to display a notification
for that content this may result in
duplicate notifications showing in the
stream
one for the wear side notification and
one for the phone side notification you
can stop a notification from bridging
phone side using the set local only API
but that would also prevent it from
displaying on wear devices that don't
have your wearable app installed
therefore we're introducing a new API to
disable notification bridging only when
the wear app is installed on the device
by adding the notification bridge mode
metadata element to your wear apps
manifest and setting it to no bridging
phone notifications will be ignored and
not displayed in the watch when your app
is present another API were adding for
and notifications is the ability to link
a phone side and a wear side
notification together so they dismiss at
the same time even if they were posted
independently this is useful if the
content is for the same topic the new
API set dismissal ID allows you to tag
notifications on both watch and phone as
dismissing together this API is now
available in the wearable extender class
in Android ends preview support library
you can see how to add a dismissal ID
string to a notification here if your
app on watch and phone each post a
notification with the same dismissal ID
and the user dismisses either one of
them the other will dismiss
automatically a fourth area of focus for
standalone wear apps is how to get them
installed and distributed and we have
some exciting changes coming in where
2.0 and where 2.0 wear apps are
downloaded directly to devices from Play
Store you no longer need to bundle them
inside of your phone app we are
expanding the multi apk feature of
Google Play Developer console to support
wear multi apk allows you to publish
separate apks for your application for
different device configurations you'll
now be able to have one more one or more
phone tablet wear or other apks in your
Play Store listing at the same time this
change brings with it a number of
benefits including smaller phone apks a
decoupled release process where your
phone app and where app can be updated
independently
support for per application apks when
using the per architecture apks when
using native libraries and more to give
you a taste for how multi-apk support
will work for where here's an Android
manifest file for a typical wear block
it includes a uses feature element set
to hardware type watch because of this
feature istrict apks bolt from this
manifest will target only wear devices
in Google Play similarly apks built
without this restrict will not target
wear devices wear device targeting can
be combined with other criteria such as
SDK version screen resolution and CPU
architecture let's walk through an
example of how this may work in Google
Play Developer console say you've built
both a phone apk and a wearable apk for
your application in Android studio you
then go to the Google Play Developer
console to upload both of them one at a
time you'll need to select advanced mode
in order to have more than one apk in
your application at once after uploading
the Webley cave apk first we'd expect
the list of supported devices for this
application to be just watch devices and
by clicking the supported devices link
you'd be able to verify that only watch
devices are shown now you upload the
phone apk to developer console the setup
supported devices for this app has now
increased to over 2,000 and includes
phones
you'll also notice at the bottom of the
screen there are two apks listed one for
watch and one for found the watch entry
shows the features took being present
multi apk support requires you to use a
unique version code for each upload apk
in this example the wearable apk was set
to version code 2 while the phone apk
used version code one since we're 1.0
and our studio and Gradle have provided
a very simple way to automatically
bundle where apks inside of phone apks
as shown you can turn this bundling off
by removing the wear app to project
dependency from your phone apps Gradle
file
while testing stand-alone ops multi-apk
support for where 2.0 is coming soon and
we'll have more announcements on this
over the summer for now simply sideload
your application just send Landwehr app
directly to your device for testing now
I'll hand it over to Kennedy to show you
a couple examples ok
so let's put together a little
principles that we just talked about and
see what it'll be like to make
standalone apps and we're 2.0 will start
with a chat app and for this example
I'll assume a couple of things I'll
assume that you've already got an
existing Android phone app you are at
kind of production quality and you're
public and you have a fairly big user
base ok so going from the top key use
cases are pretty obvious the key use
cases are going to be send a chat
receive a chat basically so that's going
to require a bunch of different
activities log in list of friends chat
settings etc but because we're really
trying to streamline interactions you
want to make sure that every UI that you
build is in service of those key use
cases ok so now let's talk about how
we're gonna build it we've already got a
phone project in Android studio so we're
going to create a second flavor of our
build so this new flavor is going to be
our wearable build and it will start out
the same as the phone but we'll factor
out the shared code between the two
builds and we'll build a shared library
that both of those will use so the first
thing that we'll put into that will be
our entire rest client service that we
had built for the phone so that both our
wearable and phone are now able to talk
to the cloud so on top of that rest
client we're going to build some
activities now we're going to use
material design for wear and I'll just
hand way through that because the next
talk in this room at 3:00 is about
material design for wear so now we have
a wearable app that uses those material
design principles and can talk to a web
service on the watch so we're already
pretty far along in building an app but
this app is not always going to be in
the foreground messaging is really
driven by notifications so the next
thing that we're going to add to our app
is we're going to register it for FCM so
once we register for FCN we're gonna
start getting pings from FCM whenever we
need to show a notification because
we're now getting pings will disable
bridging so that we don't get bridge
notifications from the phone at the same
time when we show a notification
we'll use the new messaging style for a
notification which will show a really
nice presentation for that message on
the users watch now when the user taps
that reply button
we'll use a Content intent which will
allow us to start a reply activity
that's custom designed for our app and
it meets our exact needs okay so we're
gonna have to make this user sign-in
there is no not well we could make an
anonymous chat but we won't that means
we're going to start with a basic
sign-in activity so we're gonna have a
username and password as our two blank
boxes but then we're gonna add some fast
sign-in features so I'm going to assume
here that I already had an existing
ooofff web service and since I have that
smartlock is a really good option
because it integrates well with an
existing off service another option that
I can add is a auth URL which will allow
me to log in via a couple of changes
that all have to make to my web flow so
now let's start thinking about how to
make this app work really well when
you've got your phone we're gonna
coordinate dismissal by sending a
notification ID inside the FCM payload
for each of our messages from FCM and
then we'll add that dismissal ID sorry
we'll add the notification ID as a
dismissal ID to both the phone and the
watch notifications so then when I swipe
away a notification on one it will swipe
away on both so now we have a great
wearable chat app it works well with the
phone but we really need to test it on
all the watches we can get our hands on
connected to both types
device you really have to make sure that
your app is working well on both Android
and iOS connected watches then the next
thing that you really want to do when
you have an existing app is to profile
your rest services so probably in this
app what we're looking for is data
that's not being used on the wearable
and there are a couple of options we
have if we find big chunks of data that
aren't actually being shown to the user
one is that we can cut it out entirely
if it's not being used on the phone
either or we can make new requests and
responses that are specific to the
wearable app so sort of cutting out that
data and only showing the wearable what
it needs to know when we're ready to
distribute make an unbundled wearable
apk set up the manifest as Grif decided
that described and upload to play so now
we built a pretty easy chat app based on
our existing phone app and it works
great in where 2.0 okay go to another
example now a fitness app so everybody
has their favorite running and cycling
app and you know those are all pretty
horizontal so a new idea might be to go
vertical so I'm gonna make a rock
climbing app and this is a new idea so
we'll start from scratch with no
existing phone app no existing web
service so since we're starting from
scratch we'll really be thinking about
wearable first how people are going to
use a wearable detracked climbing what
kind of information they might want to
see on their watch so I'm gonna assume
here that there is some black box sensor
magic that somebody is going to build in
order to make this work
because I'm a p.m. and that means that I
don't have to code so say thank you
engineers but what we do want to make
sure is happening is that when were
processing when we're processing sensor
data that were as battery efficient as
we possibly can be because whenever
you're processing data the sent the
processor has to stay awake and that is
burnin battery so what we really don't
want to have is the user gets halfway up
that rock wall and then their watch dies
so once we process all the data we're
gonna store it locally in a sequel light
database in case a user isn't currently
connected to the network now we're gonna
build some new activities with material
design for where we're going to support
always-on which is something that we
released last year and allows apps to
keep running in the foreground when the
watch goes into ambient mode so if you
want to find out more about that you can
still check out last year's talk on
YouTube about always-on apps and those
principles will still work in Ware 2.0
so at this point we have a wearable app
that's storing data locally and it's a
cool app for climbers what we might want
to do next with the app is start storing
that data in fit now if it can give us a
lot of interesting stuff we can get
biometric data from the user like their
height and their weight and other data
that they've entered and we can also
write into the fit platform or rock
climbing sessions so that the user can
see all of their fitness data in one
place and I can verify that fit has an
activity type for rock climbing so we're
already halfway there easily so so far
our app is a generic anonymous app but
if you're not a generic lumberjack and
you're a climber Jane you want the user
to log in so that you'll be able to
identify that user in the future and
also bring that user online onto the
cloud so our app can offer a good amount
of value without a login so we're gonna
make login optional and defer it to when
the user wants to log in and when we do
ask the user to login we use fast
sign-in flows such as Google sign-in
which is easy because if I'm starting
out from scratch I don't have an office
I probably don't want to deal with all
the requirements of figuring out how to
do an office so I can just let Google do
that hard work okay so now we're logged
in that means that we can write data to
the cloud what you want to remember here
is that although watches can run
standalone apps not every watch has
cellular which means that not every
watch
going to be continuously connected to
the cloud so whenever you're writing
data to those two sources locally and
remotely you want to think about a sync
so you want to make sure that they're
eventually consistent on both the local
store and the cloud so this diagram is
getting pretty busy here but let's say
we want to throw the phone in and how do
we tie the phone into the party okay
now I think there's a pretty easy first
step this is again my PM speak I think
it's a pretty easy first step which is
basically just to do everything that we
just did on the wearable but now since
the wearables riding all this data to
the cloud we just need to write the same
thing on the left on the right and then
we're done right
we have a phone app that can now read
and see everything that happened on the
wearable so what would be even cooler is
if I could hand my phone to my belayer
while I'm on the wall and my phone could
stream real-time data from my watch down
to my phone and my Blaire could be
checking out how my progress is going so
if I wanted to do that I would use the
data layer api's and particularly here
probably the messaging API is a good
choice because it's very low latency
okay so as before test tests on iOS
tests on Android profile so there's
probably less to do on the web services
side here since we're sort of starting
from scratch there's probably not a lot
of preference sitting in the web
services but where you would want to
focus here is on how much processor that
you are using so make sure that you're
not going to leave them hanging oh wow
that's the first time I tried the joke
that blast will set up an unbundled apk
and upload it to the plate develop
developer console as before so those are
just two examples of how you'll now
start to build standalone apps and we're
2.0 so just to recap three easy things
to remember about why you want to build
standalone apps so first of all
standalone is phone independent it
allows you to free yourself in any
situation during the day from the phone
and still be able to use those apps on
your wrist
next up Santa little apps are built like
phone
so they use phone app architecture and
all of those skills that you've learned
and honed apply to the wearable apps
that you're gonna build and then finally
standalone apps work with both Android
and iOS phones if you're like if you
liked what you heard today and can't
wait to try it out you can just go to
geo / we're preview you can find out
about how to get the preview SDK device
images and more information about the
new API is we're launching in addition
to the Developer Preview we also have a
few other sessions that you should check
out the next session in this very room
is about how to build we're 2.0 apps
with material design you can also catch
up on YouTube if you've missed anything
one of the main reasons we are doing a
Developer Preview is to get your
feedback so you have any bugs or API
suggestions please go to Gao slash wear
preview bug we also have an Android wait
developers Google+ community where you
can discuss with your peers the URL is
GTO slash Android wear depth and with
that let's go to Q&amp;amp;A</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>