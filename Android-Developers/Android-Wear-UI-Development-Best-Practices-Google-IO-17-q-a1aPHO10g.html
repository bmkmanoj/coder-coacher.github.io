<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Android Wear UI Development Best Practices (Google I/O '17) | Coder Coacher - Coaching Coders</title><meta content="Android Wear UI Development Best Practices (Google I/O '17) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Android Wear UI Development Best Practices (Google I/O '17)</b></h2><h5 class="post__date">2017-05-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/q-a1aPHO10g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello my name is Hakka and I'm one of
the tails on the everywhere support
library and I'm a Leland I'm the lead
engineer for watch faces on Android wear
it's great to be here we're excited to
tell you about some new things to help
you build apps and watch faces on
Android wear I'm going to introduce some
tools to help you build watch faces with
support for complications but first egg
is going to tell you about some big
changes coming to the support libraries
for Android wear thank you so when
smartwatches first launched a lot of
developers struggled to build apps for
this new form factor there were issues
with small screens round screens for the
first time and also bridging information
from the phone to the watch we build the
wearable support library to help with
these issues and today I'm pleased to
announce that we are starting to open
source our code the wearable support
library will be moving to the Android
support library and will become the
so-called wear module this is similar to
other modules in the android support
library once that hopefully you already
know like the core UI or the recycler
view or design so we will just become
another module for you again open
sourcing the code this is launching with
Android support library 26 point OB de 1
so it launched actually two days ago so
you can start using it pretty much
immediately it's very easy to add to
your code you just your regular
dependency on a with a very similar
structure to other modules just make
sure to mention where there and beta1
so hopefully this change makes you happy
there's a few reasons to be happy first
and foremost as I said before the code
is now open source you can stop trying
to reverse engineer it now it's all
going to be out there and the API will
now be part of the support library and
they will be consistent
with the rest of Android and the rest of
the support library we will have more
frequent releases along the Android
support library that will be roughly
every two months and this means we will
be able to take in more of your feedback
and react to it a lot quicker than we
were before but we won't be moving all
of the code at once that would be a bit
of a shock to the ecosystem to move
everything so we'll start with the UI
components and I'm going to focus on
that for the rest of my talk so the
first package we will be open sourcing
is the view package or now it's going to
be called the widget package and there
we want to focus on enabling round
friendly eyes and space-efficient
interaction patterns so we're targeting
the two main issues that developers had
with with you eyes which is building
stuff for round screens for the first
time in Android and also building for
really really tiny screens very little
screen estate it's not trivial to build
good you eyes in such conditions so
that's why those are the things we're
focusing on first here's a good example
of how we've enhanced a typical Android
list you used to have on Android a very
straight list all the elements would
just go one by one start at the top what
we've done with we're here is we've
played to the round factor of the watch
we've adapted the list to follow a curve
and that means also it fits a lot more
information on the screen that it was
able to with just a straight list here
are some other examples of our best
round friendly wise we've got the
launcher we've got the date time picker
launched recently in the new pocket in
the new desk lock up and then we've got
live song which is a great example of a
third-party app that encompasses and
encompasses around from the UI so all of
these make use of the curvature of the
screen all of them fit
is to fit more information in the eyes
and are just generally more pleasant to
use so these are the kind of you eyes
that we want you to build in the future
and we want to help you build those you
eyes with with the support library so
when building the we're widget module so
the UI components we were thinking of
the UI generally until in terms of
components much like android framework
much like the android support library
so with this module we want to develop a
suite of building blocks that would make
it easier for developers to put together
y which is both intuitive and like feels
native on Android wear as well as build
it in a flexible manner and of that it
will kind of express the personality and
the character of your app so we're
exploring both tiny building blocks like
views so image views or tech fields
we're also exploring larger ones like
the wearable recycler view or swipe
dismiss frame Alliance and we call these
specifically components and these
components is this larger larger pieces
of data and you will come come together
to form UI so this is where you come in
as developers and you will reuse our
components and views to build your own
app ok some of these views and layouts
already exist on Android and some of
them need to be implemented specifically
for where those are the ones that we
would want to go to put in the wear
module and the in the widget UI library
so here's a visualization again of how
we think about UI is its reusable
building blocks rather than custom
tailored or a special case interfaces
like hopefully that's not big news to
you but I wanted to make it very plain
that this is for this is what we're
going for with this new library so again
with this in mind we hope we will enable
you to build good interfaces functional
interfaces very rich ones that feel
native to Android wear but also Express
the character of your app
so this is quite a long project the
complete construction of the word module
will take some time so I wanted now to
spend the rest of my my time to talk a
little bit about how we will make it
happen and what was the timeline for it
kind of step by step so we have divided
all the existing where UI elements
broadly speaking into three categories
we will migrate the components that are
already built for where and that are
where specific into the new moment where
module some components we will merge
those are the components that are useful
not only for wearable devices but also
for handheld devices so they can be
reused on phones there's no need for
them to live only in the wearable space
so we will kind of graduate or merge
them into the framework or into other
handhelds or generic support modules and
then the last group is the component
that we will deprecated those are the
ones that are mostly associated with all
the design patterns that have not proven
successful with our users and I'll talk
a little bit more about that in a second
so first I want to talk about the
components that will migrate I want to
kind of shine a spotlight on them those
are the most important bit they are the
ones that are launching with the support
library 26 beta 1 and that's the
wearable recyclerview which gives you
that nice curved list that we use also
to build the launcher and then we have
the box inside layer which enables you
to fit all of your you eyes on the
screen into the center middle square of
the screen so you can reuse basically
your device between a square and a round
watch and then we've got the swipe
dismiss frame layout which is quite an
interesting case because it calculates a
design pattern that we want you to use
so this pattern is replacing the back
button on
the handheld device on where we don't
use the button for for a back gesture we
we want you to swipe away your views
that was a specific request from the
developers during our developer preview
program so we're making this component
available to you and in the wearable
support module the next group oh sorry
so in terms of code should be really
simple short slide on the example of the
wearable recycler view this is how you
import it now into your code and this is
how you would use it in an on create
method in the activity for example so
when now with the migration to the new
module there are very few changes that
we would need from you in terms of code
hopefully very simple and you need to
implement so first we change the package
name to support wear widget to
distinguish this new UI wear module in
the support library and then the second
second thing is that we would introduce
minimal tweaks to the API so that it is
consistent with the existing android api
and and support library api's these are
better api's and hopefully will make
your code healthier in general so super
easy to update your app really not much
of a of an issue
clicker okay so then some classes the
ones that we're merging are not only
applicable to add to wear this we will
as I mentioned merge into the main
framework or different support library
modules so here we've got mostly kind of
what I call round things with an icon
inside sometimes there's a lot of them
all of them look the same there's no
point in having separate UI components
for it separate kind of pieces of
layouts that you would need to use and
also there already is a circle image
view in
and the in the support library for
handheld so we're going to take all of
those additional API that we've created
and merge them into that one component
so that there's only one kind of really
strong really flexible component for you
to use and then the third group here I
want to talk about it on the on this
exam on this example of a conversation
and hangouts is a group that of layers
that were duplicating so those are the
layers that are associated with user
patterns that didn't prove successful
didn't prove popular with our users so
here we are taking the two-dimensional
spatial model where you could move
either vertically or horizontally in an
app or in the system UI and we're
transforming it into a linear layout if
you like here just vertically which is
along like which is which is following
the material design principles so all of
the classes associated with that
two-dimensional spatial model will be
deprecated so that's the grid view pager
that's different action buttons action
layouts things like that so this will
hopefully slim down your dependencies as
well that pretty much encompasses
everything that that we're going to be
doing in 2017 and here's a rough
timeline of what I've just been speaking
about so today we're announcing and
launching the web module with the first
three core components just again to
remind you that's launching with the
Android support library 26-point OB de 1
when that program graduates out from
bida alongside the au launch we will
deprecated the old API and in the
current place and then we will really
encourage people to move over to the new
api's and we will subsequently have
regular bug fixing and update releases
of the wear module with the Android
support library and then sometimes say
mid 2018 mid next year we would be
starting to remove old api's so that we
slim down again dependencies to the ones
that we want people to use so that's all
from me and with that I'm going to hand
over to Ollie to talk about
complications Bank saga some important
changes there so I'm going to talk about
some new things we're adding for
watchface developers and as this is a
big win for anyone building a watch face
yes it's another reason to jump in the
air in front of a sunset more
personalised helpful watch faces are a
key part of where to point oh that's why
last year here at i/o we introduced the
complications API for Android wear on
wear just like in traditional watch
making a complication is a display of
data on the watch face so these are all
examples of complications apps using the
complications API it can be data
providers or they can be watch faces and
Android layer manages the flow of data
between the two so watch faces using the
API can be configured to show any of the
data providers that are installed this
lets users put the information they care
about
just a glance away and if you build a
data provider you can get your apps data
onto a whole range of watch faces all of
these are already include data providers
for complications
there's fitness apps like Strava there's
finance apps like Robin Hood and there's
weather apps like AccuWeather and lots
of others
so if you add complication support to a
watch face that you're building users
will be able to choose from any of these
apps if they're installed as well as
from built-in providers like the world
clock next event and battery life
it's like you're adding functionality
from all of these apps without having to
know a thing about them many watch faces
have already added complication support
including classic styles ones like
ultimate watch to more abstract styles
like venom and super customizable ones
like pew G black and there are ones that
are a bit different on move from the us
to moods collection the ring around the
outside is a complication
so here it's showing your battery life
but it could also show your fitness
progress mesh turbine HD shows the
complications on spokes coming out from
the center of the screen with a
scrolling text effect and fit cat it has
a cat but it also had complications
using the API in their own style so
there's a huge variety of styles of
watch face on Android wear and that's
why the API gives watch faces complete
control over how they draw the data to
ensure complications fit perfectly and
to allow new interesting ways of
representing the information but this
freedom can make it hard to add
complication support to a watch face
when you build a watch face you don't
have access to layouts or views you draw
directly onto the canvas and you have to
create the settings UI yourself today
we're introducing a few things to make
this easier there's text renderer which
helps draw all kinds of text onto a
canvas complication drawable is a
complete rendering solution for
complications a new setting sample shows
how to let users easily configure
complications and style and a test suite
provider lets you easily check if
complications will display correctly so
first up its text renderer and you might
have noticed this has been in wearable
support for a few months
take surrender a mix drawing text onto a
canvas easier and that's important
because many of the most useful
complication types include text such as
the short text type the long text type
and the ranged value type the strings in
the short text and range value types
will be short they should only be 7
characters maximum well as in long text
the strings can be any length and there
are challenges rendering the text in
both cases so here's a short text
example this string here is 7 characters
long and it fits nicely at this font
size but this string is also 7
characters long so to handle both of
these and make them fit you have to
measure the text before you draw and
adjust the font size accordingly here's
a long text example a short string looks
good centered vertically but the text
can be any length so it can easily flow
outside the box you can use something
like a static layout to help with this
but you need to be careful not to relay
out the text on every frame with text
renderer you tell it the bounds that you
want the text to fit in if 7 characters
don't fit it will shrink the font until
it does and longer text can be flowed
over multiple lines and a lip size at
the end so let's look at some code
so when you initialize your watch face
create a text render using this simple
constructor and you pass in the text
paint that you want to use the text
paint defines the font the text size the
color things like that now because text
surrender it caches things like the
layout you should create one for each
field so we have one for the type there
text here and we also have one for the
title don't share text renderers between
fields now when you want to draw you
need to set the text on the renderer so
you do that calling set text and the to
get the text you call get text now this
takes the current time and you need to
do this every time you draw and that's
whether you're using text renderer or
not and that's because some
complications are time dependent so
imagine a world clock complication the
text changes depending on the time once
you set the text draw into the bounds
that you specify now it's okay to pass
in the text and the bounds every time
like this because text renderer only
lays the text out again if something has
changed that does mean that sometimes
you need to tell text renderer that a
changes occurred such as if you change
the paint text size and that's because
the paint is a different object from the
text renderer so let's imagine that we
have code that makes the text bigger
when something happens in that case you
should call request update layout on the
text renderer so that it can adjust now
one other thing that text renderer can
do is adjust the rendering for the
always-on screen so for ambient mode
many watch faces are black and white in
this mode so you might not want things
like color emoji appearing so you need
to tell the text renderer that the
device is entered ambient mode so in on
ambient mode changed in your watch face
you just pass the in ambient mode
boolean into the text renderer like so
so that's a Texas renderer we strongly
suggest to use it whenever you're
rendering text directly onto a canvas
but what if you want not just text but
the entire complication drawn for you in
a standard way that's where the new
complication drawable comes in
complication drawable can render all of
the six main complication types and it
handles all of the layout and styling
for you as an example let's recover
you'd need to do to render a short text
complication like this now without
complication drawable when data arrives
you need to decode any of images which
are included and you also need to cache
those images because you certainly don't
want to decode them more than once now
every time you draw first you need to
check that the data is active and that's
because some complication data is only
relevant within a certain time frame for
example if it's for your next meeting
you don't want to show it after the
meeting is finished and then to draw
well we draw the background we draw the
image and we draw the text probably
using text renderer with complication
drawable it's much simpler when data
arrives you pass it to the drawable by
calling set complication data and then
on every frame you just called draw it
is a drawable now like text renderer and
like other drawables complication
drawable draws within bounds and the
layout adapts to the shape of the bounds
so here you can see within square bones
you get a circular complication whereas
the wider bounds give a pill shape and
you can also see that the position of
the icon is different in the two cases
if you don't set any style parameters
you'll get a default look but there's
many things you can set such as the
background color the corner radius if
you'd rather have something more like a
square than a circle you can change the
border or have no border at all you can
change the
and you can change the typeface you can
create a complication drawable
programmatically with a simple
constructor and then you can set styling
options for active mode and for ambient
mode but if you have lots of styling to
set you might find it easier to use XML
instead you will need to be using API
level 24 to do this but as long as
you're doing that now you can just
inflate the drawable in the standard way
now we do need the context to render so
you'll need to pass that into us as well
into the drawable and if you do that
then your XML might look something like
this so attributes at the top level
apply to both ambient and active modes
unless they're overridden in ambient
mode by the attributes in the ambient
section so there are a few things you
need to pass to the drawable as I
mentioned earlier you course have to
give it the complication data so in on
complication data update for your watch
face which is where you receive the data
you just pass that data to the drawable
you also need to tell the complication
drawable when the device goes in and out
of ambient mode and that's because the
drawable handles the change of styles
for you so all you need to do is put is
call set in ambient mode every time it
changes and you also need to tell the
drawable if there are any special
properties of the screen so if it uses
low bit ambient mode or if it has burnin
protection tell the drawable that and it
can adapt the rendering for those
properties
and then to draw now if it's the first
time or if something's changed then
you'll need to set the bounds so set the
bounds and you just call set bounds on
the complication drawable now the bounds
that you pass in here should be defined
in proportion to the watch face bounds
so you might say position if one quarter
of the screen width across don't use
fixed dimensions and that's because
watch is very hugely in their size so
you don't even use defining things in an
absolute way then you need you could
just call draw on the complication
drawable this method also takes the time
and that so it can get the correct
up-to-date value so that's it
complication drawable so that should
really make it a lot easier to add
complication support to your watched
races now complication drawable is the
biggest addition to wearable support but
the next two things are available as
samples so that you can adapt them to
meet the needs of your watch face the
first inter settings any watch faces
complications should include a way to
configure them and usually that's in
your watch face settings but if you bury
complications deep in your settings UI
it can be frustrating for users who want
to change things around for the LG watch
style and sport we worked with our
partners us two to design a new UI that
lets users have a visual interface for
setting up complications and also have
quick access to other settings so here's
how it's set up at the top we have an
image of the watch face with a
complication slots clearly shown this
lets users that get a good idea of where
the data is going to appear provider
icons show what's currently selected in
each slot below if you scroll down you
can see all of the other settings now a
background image here is a special case
technically it is a complication using
the large image type but in studies with
found users understand it better as a
separate item
so this is what it looks like on the
portions watchface and now let's see it
in action so you'll see the user can
just tap on one of those slots at the
top it opens the complication provider
chooser and they can quickly choose what
they want in each slot it's much easier
than having a list with left slot right
slot top slot etc if you'd like to try
this on a real watch face download the
US two looks or moods collections on any
watch running we're 2.0 all of those
watch faces use this UI now you'll find
this what a UI implemented in the
updated watch face sample so check out
analog complication watch face service
in the sample this has been updated for
the new stuff that we're introducing
today so it also uses complication
drawable now the config UI is in analog
complication config activity and the
items that are shown in the UI are
defined here in analog complication
config data let's take a quick look at
that class so in here you'll find this
method get data to populate adapter and
it returns a list of config items
so those define what the entry is in
that settings list are so the top entry
will probably be the preview and
complications config item that's the
view of the watch face with the slots
and then you know we might have a
background option we might have some
more options and then return the actual
sample has a few more details than this
so that settings
now let's say you've added complication
support to your watch face
how can you check that everything's
working for most complication types
there are several combinations of fields
that you must handle so for example if
your watch face supports short text
complications that might be in the form
of an icon with text or it might be a
text and another piece of text or just a
single piece of text the test suite
provider makes it easy to make sure that
every combination looks good on your
watch face so when you install the test
suite it'll appear in the list of data
providers and when you pick it you'll be
able to choose which complication type
you want to test so let's say we choose
short text here's how it might appear on
the watch face and then all you have to
do is tap the complication and it will
cycle through the different combinations
so all of these are short text
complications and if your watch face
supports short text it has to render all
of these correctly this is a long text
example and for long text there's even
more combination so it's really useful
to give it a go and check that
everything works properly you can have
icons with text and title tech just text
and title or images as well we're
releasing the test suite provider open
source on github so that you can see how
it works and so that you can add your
own test cases if you want if you're
building a data provider and not a watch
face
I suggest you also take a look at this
because it's a good example of a
provider for each of the different
complication types
so that's it so these four tools should
make it a lot simpler and easier to add
complication support to a watch face
please do give them a go there are code
labs to try out here at i/o or you can
check out the samples on the Dead site
or through Android studio or you can
start using the new version of wearable
support and try it out on your own watch
face right away and please do let us
know what you think
so this is just one last slide that sums
up our present androidwear presence at
Google i/o 2017 if you haven't seen the
talk of yesterday at 9:30 a.m. it is
recorded it was a general overview of
how the platform is doing and what's new
in the platform this year and today's
talk is also recorded so you can come
back to it after I also thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>