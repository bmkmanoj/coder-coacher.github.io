<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What's new in Android development tools - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="What's new in Android development tools - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What's new in Android development tools - Google I/O 2016</b></h2><h5 class="post__date">2016-05-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/csaXml4xtN8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning hello welcome everybody to
our talk today on what's new in Android
developer tools it is awesome to see so
many developers here from around the
world and in a concert venue I just want
you guys to know this is pretty cool for
us I'm Steph cut person I'm here today
with a wonderful tour norbi and the
wonderful Jamal Easton we're going to
give you an insider's tour of Android
studio and for those of you who are
already real insiders and noticed that
zob is not on the stage this year I'm
just filling in for him he's actually on
a beach in Hawaii so hello though when
we first started working on Android
studio you know we wanted a
purpose-built IDE which was tuned for
our languages that's why we picked
IntelliJ and native to the Android
platform now Android studio has built
tremendous momentum in a short period of
time one of the things we announced
yesterday is that now 92% of the top 125
apps and games use Android studio since
we announced it here at i/o three years
ago and you may remember it was tor who
did the demo we've released a hundred
and thirty-one times across our preview
beta and stable releases and what that
reflects is actually a big part of
what's driving our success we have an
incredibly engaged developer community
with trying all of our early builds and
giving us wonderful feedback that is
what's letting the team focus and
helping us go very quickly we've been
thinking a lot the past year about what
else we could do to help accelerate
productivity and make your lives better
so for those of you in the audience who
don't know Android studio quite as well
I'm going to give you a whirlwind tour
of 2016 and what we've done so far just
in about 60 seconds so bring everybody
up to the same level and then we'll go
on and
about 2.2 and the road ahead so already
this year we launched 2.0 that focused
on speed with the introduction of
instant run and the emulators we also
launched wonderful new emulator UI the
GPU debugger preview search deep linking
creation testing and much more that
shortly followed 2.1 which we built side
by side with N and that brings you
support for all ends features and api's
it brings you emulators so you can test
n the New Jack compiler so you can try
out Java eight support and in particular
in 2.1 we also accelerated instant run
the way we did that was by moving our
deck step to happen in process which
gave us wonderful speed advances now all
of this brings us now to 2.2 which
focuses on speed smarts and Android
platform support now one of the things
that's wonderful for us about i/o is
this is a developer audience so what
we're going to do is spend the first
twenty five minutes of today's talk
giving you a live demo of nearly every
single feature in the 2.2 preview which
you can also use now just a reminder
this is a preview build so expect
preview quality and then we'll do the
normal thing we always do over the next
several weeks we'll be stabilizing this
as we do as we move through beta and
stable after that Jamal and I will then
take it back and we'll walk you through
design develop build and test to give
you a nice structured overview with
screenshots and also take you behind the
scenes to talk more about how and why
features were built so with that to take
you on a lap around 2.2 would you guys
please give a very warm welcome to torn
or be thanked
all right can you see the screen demo
alright can we get the demo machine
thank you alright so I'm going to start
with something very small and simple but
I think you'll like it so we released a
lot of SDK components yesterday and once
you've installed android studio 2.2 and
you go to install them notice how we
have a background button now so so you
can keep coding while you're installing
the latest goodies so we spent the last
year focusing on making builds faster we
know that's a top concern for all of you
and so I'm going to show you where we
are with instant run right now so this
is the i/o app running on the right and
I can go ahead and comment out some code
here and run it and when I make that
change you can see that within about a
second it reflects that change on the
device that would take 15 seconds
without instant run I can also make some
incompatible changes for example
extracting this into a method and making
that change is another second or two to
deploy so after the demo Steph is going
to talk more about what it is we're
doing next
with instant run into two and two three
so one of the things we had to do when
we work on instant run was figuring out
figure out what's going on inside the
apk files so to do that we built this
new feature the apk analyzer so I can
open up any apk or the one in my project
and now I can drill into what's going on
in the file so I can see for example you
know what's inside the assets folder or
the rest folder or in this case instant
run the way we're repackaging
application into slices so let me drag
in a real production app the Chrome apk
the purpose of this tool there's a
couple of things first one is to be able
to look at the download size so in some
markets it's very important that you
make the download small and install size
small so this lets you look at what is
actually in your app and focus on
whether you can get rid of it so I can
drill into the assets folder and look at
the files I can look at the
a let's say layout folder we decompile
the binary XML back into source although
we need to be a better job at the
resource references so soon we will map
those back into resource names you can
also look at the strength or the value
table which is spin sort of an opaque
file to look at before now we have a
viewers you can go in and see just
what's inside and last but not least yes
and last but not least this lets you
look at the Dex files so you're probably
all aware of the 64k method limit it's
not actually a method limit it's method
plus reference limit so you can now
drill into this and see what is it that
you're declaring and what is it that
you're referencing to see how you can
get below that 64k or turn on multi
decks so if you've ever looked at a
manifest file in the build outputs you
might have noticed there's a lot of
stuff in the manifest file that you did
not write right where did it come from
well we have a new editor in 2.2 the
manifest editor so this is XML tab but
you can see on the bottom there's now a
merged manifest tab and when I click on
that you can see that we now give you
the full merge updated live whenever you
make edits there's a legend on the right
which helps you where stuff is coming
from so for example I could see now the
internet permission
it's coming from play services so you
know I can also go in here and navigate
to the the line that is the source for
the merge so hopefully that will help
demystify what's going on with a Gradle
manifest merging process
so speaking of Gradle we don't want you
to have to learn how to edit build files
in order to configure your project so
we're in the middle of a complete
rewrite of the project search or dialog
and I say middle because all we've done
so far is dependencies so arguably it's
probably the hardest part so my favorite
part in the new PSD is the messages pane
so what this shows me is suggestions the
ID is making so you can see here my
project happens to be using J Center for
dependencies and it's telling me hey
there's a newer version of this
dependency available and all I have to
do is click on this update link now I'm
using the latest version I can also
click on update all to take all
suggestions so notice this is not just
looking at local repositories which
Lindt used to view for you it goes out
and searches remote repositories as well
if I switch to the dependencies view I
can drill into the dependencies either
by module or I can look at the overall
dependencies for all modules across the
project and I can drill in and see for
example the transitive dependencies to
see basically how I'm reaching certain
dependencies in my project I can also go
and add dependencies so we have a nice
UI now where I can go in search again
just like with the updates with the
update suggestions this looks at remote
repositories
it also looks at local repositories it
shows all the available versions and it
even helps me tweak the scope string in
the dependency list so you can turn this
on today in the experimental settings if
you want to play with it and we're going
to try to finish that in the next couple
of releases
next let's talk about C++ so last year
we showed you that we have really great
editing support this is the sealion C++
functionality from jetbrains that we've
integrated and however it required to
use the experimental Gradle plugin and
the big news for 2.2 is that we've now
added support for external build systems
so you can actually use a C make to
build your native code you just declare
it like so with a stable plug-in and now
you can build C++ and for C++ we will
have a wizard in the next couple of
builds so you can very easily go in and
add C++ support to your project and when
you do that you end up with a sample
project that looks exactly like this one
so you have a main activity that loads a
native library and then you have a
sample HelloWorld native library string
so let's hook this up I'm going to set
first of all set a breakpoint here and
the C++ code this main activity is just
showing the default layout that has a
string in the middle so let me go back
and change that string to show the value
from C++ so we'll do text view text view
equals fine view by ID and then we'll
hook up that IB we've got to cast it and
then we will call set text on that text
with the call from C++ now let's also
set a breakpoint here so now I'm going
to launch the debugger
this runs Gradle which drawn C make
builds everything package packages it
and in the second this app should be
running on the emulator there it is so
we hit our breakpoint now we're in java
code and so you can obviously be looking
around at your manifest State I'm sorry
activity state and if I resume the
debugger now you can see now we're in
C++ and I can drill around
so that's the hybrid debugger and the
CMake support class the last thing I'll
show you in the build system area is
something on the command line so let's
say that you've gotten a project from a
co-worker or maybe you did a git pull
and someone changed you know the build
tools version or let's say the compiler
is the kit version your project and then
you build and then you hit a message
like this one you don't have built tools
2201 what do you do now you open is the
key manager you installed it right well
in 2010 2.2 alpha 1 we now have a
experimental flag you can set and when I
run the build if I've already agreed to
this license Gradle will just go and
download it for me on the fly as you can
see right here
so that should also make configuring
continuous integration servers a lot
easier alright let's go from the extreme
of command line to visual editors so
let's take a look at our new layout
editor actually I shouldn't call it a
layout editor because it does more than
layouts so first of all I can open up a
menu file here's a menu I can drag and
drop design menus now we can also open
up preference files and I can drag and
drop preference files and obviously this
components vector but of course layouts
are a big part of this so you can see we
have a new component inspector on the
right this one shows you the important
attributes for the selected component
text view in this case so for example
for textview we show you the text
appearance and notice how there's some
gray text here in the component
inspector even though I haven't set the
text appearance we're showing you what
it actually is going to be at runtime so
I can see the font will be 14 ESPYs for
example if I switch to something else
it'll compute what that should be now we
only have a subset of the properties
here to make it simple to find but if
you need anything else the full set of
properties is just a click away up here
so on the design surface we have a
blueprint mode so blueprint mode is
basically showing this structure it's
like an x-ray of what your app is doing
and I can have blueprint mode and design
mode on side by side and one new thing
we have that you've asked for is here
this is a scroll view and I can now
scroll the design surface directly
now blueprint mode is particularly
useful for the new constraint layout so
let's take a look at the constraint
layout so first of all I'm going to turn
off auto connect mode so let's drag in
some components so put a textview here
we'll put a edit text another textview
and another password field maybe and
then we'll add some buttons on the
bottom right so you can notice I'm being
kind of sloppy because after the fact
that can go in and I can make a
selection I can right click and say hey
I want to align these things on the
bottom I want to align all these things
on the left maybe I also want to pack
them vertically so here I have my design
now let's see what happens if I go to
landscape mode ah that's not good right
so I have buttons off screen so let's
try to fix that so there's this little
light bulb icon for infer constraints
notice what happens when I click it I
now have these constraints where it's
tried to guess what we probably mean
here and when I try to resize this now
you can see the buttons are moving
correctly
so normally you're actually in
auto-connect mode so if I want to drag
in a button here you can see that the
second I drop it it actually goes and
adds these constraints for me and if I
don't like them of course I can delete
the constraint by just clicking on them
I can also drag new constraints and we
sort of show you preview what it's going
to do when you commit to it and the
constraints can also have strength so as
I'm dragging you can see it auto snaps
to a quarter or specific percentage
someone asks yesterday if this also
works from XML editing if that's what
you prefer and why yes it does you can
see here we are in XML I can continue to
play with the constraints over here and
you can see the XML editing works just
fine as well so this is a very powerful
thank you so this is a very powerful
constraint solver and what that lets you
do is flatten your layout hierarchies
and that's very very very good for
performance so we've added a feature to
help jumpstart that so let me open this
other layout this one let me switch a
blueprint mode so you can sort of see
what's going on so here's the layout
that is actually a set of nested linear
layouts and if I now go and say convert
this linear layout to constraint layout
it offers to flatten the whole thing and
as you can see visually it looks the
same now except we have constraints and
on the left you can see a single flat
list
all right let's go look at editing so in
the editing area we've added a couple of
features so first of all there's the
firebase integration so if you're trying
to accomplish a task with firebase for
example you want to add cross reporting
you just open up the assistant window
and you pick the tasks you want to do so
for example crash reporting you drill
into this you can see you get this step
by set set of instructions that sits
next to your source editor and if you
for example see that you want to perform
these lines you can just drag it into
your source code to make that edit for
example if you are trying to figure out
how to use an API so let's say you prove
you should use the job scheduler and yes
you should use the job scheduler you can
right click on it and you can say find
me some sample code for this
since you can see it basically goes to
the server and finds recommended samples
so you can then drill into and you can
right click and say open this in a
browser and let me learn more about this
two-point-two is based on IntelliJ 16.1
so we have a number of new features for
that as well
so one thing we got is support for
editing bi-directional strings so this
is something our international audience
it's been asking for for a while so here
we have some Arabic texts and you can
see the source editors now more than
happy to handle this correctly I know
this has been a big pain point so
finally we've got it Thank You IntelliJ
so intelligence extend also comes with a
bunch of new inspections in the editors
and on top of that we've added into to a
number of new inspections that are
Android specific let's take a look at
those so first of all hopefully everyone
knows that it's really really bad
practice to solve the problem of passing
data from activities by making your
field static that's a no-no and now lint
will flag it for you not just because
it's a leak but also it makes instant
run very happy when you do this this is
also not as simple as just this case for
example we have if I make these other
fields here static AppData one is no
problem but AppData two turns out that
one
it has instant state that is a context
but now there's a static reference to it
which is bad
so let's look at some of the new support
annotations we released the support
library yesterday and there's some new
good ones so first of all you can now
finally say hey this method even though
it's inside of a worker thread class
this one is thread safe you can be
called you can call it from any thread
for a while we've had API check so
length will look at the platform API and
compare them to your Minister K and we
have a quick fix we can say well okay
insert that check for me however what
you can now do is you can say sorry you
can say I expect my method to require
this API so you're passing on the
responsibility to College of API so you
can now get API check for your libraries
to client so you can see now these other
calls even though they're calling your
API it's the API check is applied the
next thing I will do is show you the
dimension resource the dimension
annotation so this one lets you say this
integer represents a dimension and there
are various units you can apply now
turns that pixel is very very important
most API and SDK operate in the pixel
space so we have a new annotation to
just say pixels so that's @p X and when
I do that you can see we're now flagging
incorrect usages where you're passing a
dimension resource that should be a
dimension so hopefully that'll be useful
and the last annotation I want to
highlight is the keep annotation so you
can put keep on your methods and classes
and as of yes
so as of Gradle plug-in 2.2 we now
automatically make sure that if you use
ProGuard or the new incremental shrinker
that these methods will not be removed
at at release time so if you like the
support annotations we have a feature
that I think you know will make them
even more useful to you and that's the
new inference so IntelliJ has for a
while had this analysis action to infer
nullity well we have a new feature it's
behind a flag but you can try it if you
want to infer support annotations so
when I run this on the current file it
basically does a bunch of analysis to
figure out a lot of new annotations
based on usage in your project so if I
go back into my file here all the
differs you see here are four new
annotations that it figured out for
example there's permission requirement
here so that'll hopefully help
jump-start annotations and will help
lint find more bugs in your code we've
also been collaborating with a research
team at Oregon State University to work
on permissions so this is still a work
in progress but when this is done this
will let you migrate your app to Android
M permissions so here I can invoke this
action it'll help me perform the write
requests and handle callbacks for
Android M permissions
we also have a refactoring to remove
unused resources so if I add some
resources that aren't actually used I
can now discover their factor menu say
remove unused resources and the IDE will
find them and nuke them for you which
helps make your app leaner all right so
now a last thing I want to show you is
the espresso test recorder I'm hearing
ooh in the audience all right so to do
that
all I have to do is go into my project
and go to the run menu and say record
espresso test and note that it's
espresso not expresso and so when I do
that you can see that it actually it
actually builds the app and it starts
this event recorder on the left here and
on the right we have our app running so
now I can for example go and click on
this category over here and you can see
it record an event for that and I can
click on the back button and then I can
go down and let's say click on the music
tile notice as I'm clicking it's
recording the events over here and it
tries to make sense of what it is I'm
clicking so for example when I click on
the red button it's recording that I
click the fab quiz button and so another
cool thing I can do while I'm recording
I can add assertions so I'm going to
click on the add assertion button here
and it's now pulling down a screenshot
and view hierarchy of what's going on in
the app and I can now you can see I can
move around in the logical structure of
the app and if I click for example on
the question who was the youngest Beatle
it pulls that down into May it suggests
an assertion which is hey at this point
when the test is running we expect this
string to be who was the youngest meal
so net press save assertion and I keep
going so does anyone I'm gonna click
some wrong answers until you stop me
so alright still wrong still wrong
George is right okay and then I'm going
to finally click on the submit button
and you can see that that was the
correct correct answer and I think
that's probably good enough for the test
recording part now I'm going to say
complete recording when I do that it's
asking me what class I want to save this
test as I'm just going to accept the
default and here we have our espresso
test so notice that I clicked some wrong
stuff in the beginning I cannot edit
this test if I want so for example I can
take out the you know clicking the wrong
tile and going back and then I can run
the test so let's do that
so all I have to do is click on this Run
button right here and you can actually
use cloud testing as well I don't have
time to show it but you can sign up for
that and then it'll run your UI test
across a number of different Harvard
form factors which is pretty useful all
right so let's just run this on name on
the emulator again so it's going to
build a test deploy and let's look over
on the right here on the app starts
running because it actually can click
faster than I can
installing it okay here we go click
click click and we have our green pass
all right
thank you so with that I'm going to turn
it back over to Jamal just going to be
talking about the visual editors thanks
to our break demo so what shit what tour
showed you is what we're doing I'm going
to spend a little time talking about why
we're doing it and why you might want to
integrate it into your development
workflow so for design we're thinking
about two main topics XML and layouts so
for XML I know a few of you enjoy
designing your entire UI and XML that's
great I know for me and many others it's
great to have some sort of visualization
tool to allow you to see how your app is
going to render and our team set a goal
for ourselves thinking about is it
possible for us to create a tool or no
XML editing is required of course that
means you can always look into your code
afterwards but it shouldn't be in the
way to get your job done so that was the
reason behind the new layout editor and
as torez showed you we have a whole host
of new features including ways to drag
widgets onto the component tree onto the
design surface or the new blueprint mode
which allows you to appear behind your
application to see how all your widgets
connect together and lastly the new
properties panel in the past used to
show you all the different properties
that were available for a view
now we curated those and show you the
most impactful attributes to use for
your particular view layout the second
question I'm thinking about is around
layouts so for Android layouts have a
couple different options you have linear
layout of course horizontal and linear
but then you're thinking about perhaps I
need to use the frame layout or the
table layout wait that's not gonna work
actually let's think about using the
grid layout are the relative layout
weight so which one should easier that's
the problem we're kind of trying to
think about because many times for
thinking about should I use which
container should I use for my layouts so
the constraint layout is the solution
for this problem where you can think
less about the container and more about
the content and how do you layout your
your widgets on your layouts so let's
talk about why you might want to use the
constraint layout so number one it's
fast UI development
so you saw as you saw on the demo we can
actually add which it's pretty quickly
and connect all the different
constraints while it's also very
important to think about is that this
helps you have more responsive design so
instead of thinking about well how does
my screen fit on the nexus 4 or our
tablet are our Nexus 6 device we can now
create constraints that allows you to
respond your content based on the screen
size the third most important aspect is
performance so as you saw in the
demonstration we can now flatten your
hierarchy for you if you didn't know if
you put a relative layout underneath
another linear layout and another
relative layout that actually is slower
for the Android system to process so all
that nesting can be now fund with a new
constraint layout and lastly it's
backwards compatible which means you can
use it obviously for new projects when
it's a support library that allows you
to use it to existing projects as well
and so the third tool that we
demonstrated around design is a layout
inspector so sometimes you're loading an
application you're wondering well why is
my view overlapping or perhaps why is
one of my attributes not what I expected
to be so what you can do now with our
tools is you can right-click and take a
snapshot of your current layout and then
visually inspect all different
attributes and look at the entire view
hierarchy of your layout statute very
helpful in debugging so now on time
spend a little bit time talking about
develop and what tools we've been able
to help you with that
so as we showed in the demo we have and
now a new firebase plugin and this
supports the new firebase services that
we launched yesterday at Google i/o and
you can now add things like Google
Analytics adds climb messaging all in a
click of a button inside of Android
studio to point out the other cool thing
we talked about is the samples browser
and as demonstrated if you're looking
for an example or how to use something
now we provide the power about all the
Google samples at the click of a button
let's make it easier for you to now look
and have a good starting point for your
application development
and now with that I like to talk a
little bit about the build tools and all
I write stuff to talk about those new
changes thanks very much to Moe for
build I want to start by talking about
instant run now as a developer I think
one of the best feelings in the world is
being in the flow and one of our goals
for Android is to make Android
development feel as lightweight as web
development so you can make your code
changes and then see them essentially
refresh so that you can really stay in
the flow as you're coding that's why we
built instant run so I want to talk a
little bit first about how it works the
IDE swaps your changes in one of three
ways for incremental changes we do the
fastest swap which is called a hot swap
and here what we do is we instrument
your byte code on the first build and
then after that when you make changes we
just redirect the code path to pick up
the changed code the second type of swap
is a warm swap and that's when we need
to do an activity restart so that's what
you need whenever you're going to do for
instance resource changes cold swaps are
when we need to restart the app and
that's retired for sorry required when
you do structural changes so examples of
those would be changes to inheritance or
if you change your method signature so
what I'd like to do is back up and
unpack a little bit some of the
benchmarks that we talked about
yesterday in the keynote we benchmark
using a wide range of different
applications and different tools I won't
take you through all of it just one
example we benchmark with the Wikipedia
app it's an open source app you can get
it on github and I've posted here all of
our criteria in case it's interesting to
repeat them what you'll notice is that
we benchmark against 2.0 with instant
run disabled and you can see in 2.1 with
cold swap its 4.7 times faster and hot
swap is ten point seven times faster now
what that means if you think about it is
our build speeds are actually faster
than 10x because we're benchmarking
against 2.0 and 2.2 the
1.5 because of changes we made index and
we also made a DB push speeds 10 times
faster so we're under selling a little
bit but what we care about most is
really that you guys are getting super
fast builds and so that's what we
focused on and this gives us a nice
apples to apples comparison in our own
benchmarks let me talk about another
type of benchmarking we do so we look at
the user stats for users who opt in and
we instrument in a bunch of different
very cool ways so for all of you guys
who opted in thank you this is an
example of a stat we look at this is
average runtime average build time for
instant run on hot-swap and this is
showing across all users so this is
worldwide all operating systems all
countries all hardware and that includes
very old hardware with slow processors
and things of that nature what you can
see is that most users are seeing
hot-swap happen in four to five seconds
or less and our goal is always to push
that graph over we're trying to make as
many as possible happen in one second
so what we look for is we're trying to
figure out how do we drive full build
speeds down how do we make hot swaps
faster and how do we make as many swaps
as possible be hot swaps so we look at
things like this we look at the
distribution of hot swaps warm swaps and
cold swaps and full build times as well
as what's causing cold swaps to happen
and it was looking at that
instrumentation really all of your
wonderful data that gave us the clue for
one of the big changes you'll see in 2.2
so 2.2 includes change to a apt a lot of
you guys know when you change your
resource apt insert side ID in the
manifest now what you may not know and
what we didn't know is that if you
change a resource or add a new one a apt
was renumber
the sides-- so the impact is you make a
code change but you would get a cold
swap we identified this was driving
about they call it 16 the 19% of our
cold swaps so with 2.2 we've changed
AAPT so it holds all the resource IDs
constant so I'm kind of taking you guys
on an insider's view of what will just
occur to you in 2.2 as an acceleration
and instant run because you're going to
see a lot more hot swaps another change
we made is we're taking advantage of
split apk so now when you build will
break your app into about 11 to 12 Dex
files and when you do a full build will
actually only rebuild the changed code
we plan to keep driving build speeds
down in multiple successive releases not
2.2 so if any of you guys are seeing
still slow build speeds the engineering
team would really appreciate it if you
come find us let me talk next about
project structure now tor already gave a
wonderful demo so I'm just going to give
you guys the insider's look underneath
the project structure dialogue is some
very interesting changes to the Gradle
build model now Gradle has been
wonderful for us it's a very flexible
language very powerful for Android but
let's think about it an IDE expects
structured inputs and Gradle is a
programming language so that's pretty
complex one of the changes we made in
2.2 is we completely rewrote the Gradle
parser from the bottom up so what that
means is we're now much more accurate
when we read in Gradle files and we're
also much more accurate in the IDE when
we write them back out so an example of
what you'll see is for instance if you
write variables into your Gradle file we
will now read those correctly in the IDE
and in the future in the project
structure dialog you'll be able to
modify those in the UI as well the
Gradle reach
the Gradle rewrite of the model is done
already in 2.2 as tor mentioned the
project structure dialog is partially
complete in 2.2 and you'll be able to
try it under an experimental flag we
plan to complete it into three and at
that point it will become the default
this is just a nice screenshot of the
merge manifest viewer which tour also
showed for time I want to skip ahead and
talk a little bit about Jack now
the Jack compiler was integrated with
Gradle in 2.1 and in 2.2 we now include
annotation processing so you can now use
annotation processors on your class
patch so this would include such as a
compile dependency and they'll be
automatically applied
now detailed information about how to
use this as in our Docs one of the
things I wanted to call out here at i/o
is if you are someone who's writing
tools and doing pre or post processing
on class files one of the really nice
things about jack is that it has a
structured API for manipulations now we
are going to be looking to move more and
more to Jack and coming releases so
please do try this out and let us know
if there's anything that's missing for
you our last topic will be C++ support
and for this I'm going to give you guys
the whole arc of what we're doing is I
think it's a nice way to just understand
C++ from end to end
the reason we're investing so much is
because we know there's a lot of you who
are doing very graphics rich apps and
games and you've talked to us and told
us that C++ is critical we already
support C++ editing and debugging and
all of that is coming through IntelliJ
so one of the new things you're going to
get with 2016 dot 1 is also IntelliJ is
wonderful improved support for C++ but I
think the biggest change you'll see in
2.2 is C make and Gradle let me walk
through a C make example you can now
reference a C make project in your
Gradle file and this will build your
Esso files so they're packaged in the
apk and how it works is Gradle now
shells out to see make and we're getting
C make to emit
more metadata about the project itself
both how to build it and what files are
in the project so that's how as tor was
showing you you're able to see the dot
cpp files show up in the project
hierarchy and you'll also get your dot H
files as well if those are in the same
folder the files themselves will show up
in a node in the project hierarchy as
well under external build files so you
can edit those as well from the IDE and
just this tour showed you can then run
app set a breakpoint it will all work as
expected
setting up NDK build works the same way
so you can reference an Android MK file
from your build I'd also like to give
you guys a brief tour of the C++
debugger enhancements so first in 2.2 as
we mentioned you no longer have to
explicitly choose the C++ Java or hybrid
debugger you can just use auto and the
IDE will automatically select the right
divider for you if you're debugging an n
you can actually use one single debugger
for Java and C++ and then a final thing
we added is watchpoints
so you can add a variable and you can
freeze the process if those are read or
if they're modified watchpoints can be
used on x86 and Nexus 9 we're probably
planning to bring more devices online
for now a great way if you want to try
them is to try them out with our
emulators we also fix several
compatibility issues with Samsung s5 and
s6 devices so that covers C++ and 2.2
and you should expect to continue to see
enhancements in coming releases the last
area we'd like to talk about is testing
and so with that I would love to bring
Jamal back thank you guys very much
so for testing a core feature you need
is a local testing environment so we're
really excited that we launched the
Android emulator earlier this year if
you haven't tried it it's a great tool
what's great about it is that we
improved the CPU GPU and i/o speeds so
it's even faster than the device we've
also improved the ADB speeds believe it
or not many times the bottlenecks
between you pushing your assets in your
application is ADB so that's actually
now 10 times faster with the new Android
emulator and of course that's - we're
showing you we have the new UI you can
do things like rotating to extreme shots
but also there's a Stinnett UI as well
which allows you control sensors like
taking location doing a semester making
phone calls all tools allowing you to
test your application so in addition to
the local testing we also launched the
firebase tests lab inside of Android
studio so if you click on that clouds
have that tour show - should the demo
allows you to choose devices in the
cloud and now you can run the device
that you may not own and try and try and
seen your apk and test along with that
to nail help you test your application
and I showed earlier we have the
expresso test recorder and that's a very
cool demo they get - is very important
is that we found that me making tests
can be tedious and sometimes a lot of
novel people like to do it and so now
you can click on your device we can
capture all those tests and you can now
upload those to the test lab or run them
locally on your machine and lastly we
talked about the apk analyzer again why
this is very important is because
sometimes you think you're done you
built your application and the apk is
too big because at the end of the day
your users who download your application
on Google Play want the smallest apk as
possible so this tool allows you to dig
into your apk look into your text files
your assets and figure out what might be
the problem of why Maya apk is large we
now time to talk about every single
feature bubble you see we talked about
new lint analysis new intelligence 2016
features we've made a big investment to
accessibility so this is our all new
features that we've added inside of
Android studio to
- so just to recap we launched a whole
host of features around design a new
constraint layout manager and
corresponding designer new firebase
integration to help you code better
enhance C++ support and build support
and a test recorder to help you tests
and how to get started all we have to do
if you're using Android studio 2.2 today
just go to check for updates and we're
prompt to the download Android 2.2 and
the canary channel and if you're not
using Android studio anyone
this code is going here and download a
fresh copy and again change the channel
to the canary channel to download
Android studio 2.2 and that's it thank
you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>