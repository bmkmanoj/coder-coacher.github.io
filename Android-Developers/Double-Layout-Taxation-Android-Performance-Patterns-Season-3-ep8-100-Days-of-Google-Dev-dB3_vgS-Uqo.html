<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Double Layout Taxation [Android Performance Patterns Season 3 ep8] (100 Days of Google Dev) | Coder Coacher - Coaching Coders</title><meta content="Double Layout Taxation [Android Performance Patterns Season 3 ep8] (100 Days of Google Dev) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Double Layout Taxation [Android Performance Patterns Season 3 ep8] (100 Days of Google Dev)</b></h2><h5 class="post__date">2015-09-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dB3_vgS-Uqo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">layouts are at the core of how you
create a modern beautiful Android
application for your users but if you're
not careful you're amazing layouts can
create a monster performance drain my
name is Colt McAnlis and if you're using
some fancy features on your view layouts
you might be getting into trouble
remember that any time they position or
size of an object changes in the view
hierarchy there may be ramifications
with respect to other layouts in the
view for example if a button suddenly
doubles in size a neighboring view may
need to be moved and then of course the
parent view may need to be resized as a
result see there's a small set of
properties of a view that when changed
require the layout phase of the
rendering pipeline to occur before
updating the screen basically this stage
traverses through the view hierarchy to
calculate the correct positions and
sizes for all views impacted by the
change in general this is a reasonably
fast process but if you're not paying
attention you can trigger an expensive
cascade of layout operations which can
quickly chip away at your frame ton a
perfect example of this is the relative
layout container basically this layout
allows you to define the position of a
view with respect to the position of
some other view in the hierarchy for
example always stay to the right of the
text box or at the top of the current
container or stay at the top of the
topmost sibling but always to the right
of other siblings in my container yeah
weird stuff like that the issue here is
that in order to properly position views
in relation to one another container
must kick off a second layout passed
before it can finalize positions and
move on to rendering basically it works
like this the first pass will visit
views and calculate the positions and
sizes based upon their personal requests
the relative layout then uses this data
to figure out the proper positions of
correlated views or any weight sizes and
then makes boundary adjustments
accordingly at this point a second
layout pass is kicked off to determine
the final positions to use for rendering
the result to full layout operations
through the children the container just
to get things situated on the screen and
the trick is that this happens every
time a change happens in a relative
layout but be warned here it's not the
only container that can produce this
double layout behavior for example
linear layout generally only issues a
single layout requests until you add the
measure with largest child parameter in
which case it can end up needing a
coffee
second layout paths to resolve the
proper sizes a grid layout has a very
similar issue this container allows
relative positioning but avoid the
double taxation by pre-processing the
child view relationships which I mean is
great right I mean you get all the
functionality of a relative layout
container without any of the performance
you get all the functionality are
there's all gets thrown out the window
any time the layout uses Phil gravity or
in some cases if weights are used in the
wrong spots and then of course you're
back into the same performance problem
now by themselves multiple layouts from
these containers won't be much of a
performance burden but put them in the
wrong spot and you'll end up with some
big problems for example any time there
are the root elements in your view
hierarchy or when the container has a
deep view hierarchy beneath it or when
there's lots of them populating the
screen like yeah in a ListView basically
this problem can then compound
throughout the hierarchy imagine a
relative layout at the top of your view
hierarchy which will then do to layout
passes and then later on you've got some
ListView below that that has a cascade
of grid layouts inside of it basically
the leaf nodes in this configuration
could end up having to do a layout phase
run on them eight times each obviously
you've got better places that you could
be spending your frame time so looking
to avoid the plague of double layouts
here's a few helpful tips firstly you
can track down whether layouts are
eating into your frame rate by taking a
firm look at these systrace tool if you
see that the measure / layout portions
of a rendering frame are unusually high
then there's a good chance that it's
eating into frame rate in a bad way
secondly take a swing at minimizing the
depth of your hierarchy I see sometimes
double layouts are simply unavoidable so
reducing the amount of depth in your
view hierarchy will help reduce the
impact they have on your general frame
rate thirdly avoid calling layout
requests in any situations where it's
absolutely not critical to do so when a
view requests allowed it's going to
trigger a layout in all of its parents
now although there's extensive caching
in this part of the system to try to
make this as fast as possible it can
still be a very very expensive operation
fourthly watch the rest of the Android
performance patterns videos
fifthly join the Google+ community and
ask questions to other performance gurus
and 12th Lee keep calm profile your code
and always remember perf matters</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>