<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Image compression for Android developers - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="Image compression for Android developers - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Image compression for Android developers - Google I/O 2016</b></h2><h5 class="post__date">2016-05-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/r_LpCi6DQME" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yeah Google i/o 2016 right oh come on
there you two we're done clapping now is
that it all right we're done how did
that hello everyone how are you doing
today good staying out of the Sun yes
fantastic hey I want to thank everybody
for being here my name is Colt McAnlis
and I gotta tell you I love Google i/o I
love Google i/o because this is the one
time during the whole year that the
crazy Googlers get to talk to all of you
all about the weird stuff we do that we
can't talk about the rest of the year
and that is fantastic right and today
we're talking about something that's so
near and dear to my heart and that's
data compression it is it is by far one
of my favorite most obsessive things
that I ever get involved with and I'm so
happy that all of you who are here at
all the people standing outside I'm
sorry there's capacity issues we'll give
them a t-shirt or something later but
really quick before you begin I gotta
tell you we've only got 45 minutes today
and that is just not enough time to get
through all the awesome crazy image
compression content that we need to get
done so over the past couple weeks have
been trying to diffuse some of this
stuff to some other places first off is
my medium.com page has anyone been
reading these articles yep yeah round of
applause have you been reading the the
medium articles yeah we're live folks
you got to make them hear it yeah we if
you read these articles we get into a
lot more depth on how some of these
image formats work and how to make them
a lot smaller second off of course is
the Android performance patterns videos
anybody watch these thank you that's
fantastic now if you've ever been
interested in data compression if you've
ever tried to make an attempt to
understand the algorithms but found that
the math is really weird or it's too
gnarly of a concept or maybe it's not
presented in the right way then good
news for you because alex hockey and i
have actually got together and we've
actually written a data compression book
and we took a different approach to it
we threw out all the math all of that
crazy gnarly stuff that makes your brain
melt we got rid of it and we re
approached how we should be teaching
data compression to modern developers
and engineers so if you're interested in
the fundamental understanding of how to
make your apps smaller for users check
out this book deal deal alright business
is out of the way let's get started so
when we talk about reducing the data
sizes of your applications for your
users there's generally two buckets that
I like to think of on one side is your
apk size and this includes all of this
stuff like code sizes language
information resources image resources
we've got layout data config blah blah
blah blah blah blah blah blah blah all
of the information that's IFFT up into a
single APK file and downloaded when
users install your application now on
the other side of things is all of the
other stuff that your app downloads once
its installed from the internet right so
this could be many many many things but
it mostly boils down to images and
serialized data now I got to say that
the apk stuff making your apk smaller is
a whole deep and crazy domain that we're
not going to get into today however if
you stay in your seats the next session
will go very very deep into that subject
so make sure you stick around for that
one thing you notice here though is that
images actually show up in both of these
categories and that's why we're focusing
on our images today because quite
frankly images are awesome right round
of applause for images yeah
I promise you I will ask you to applaud
weirder and weirder stuff as the talk it
was time okay like who likes gummy bears
yeah there we go we have to have an
understanding as an audience in a
presenter that's how this works right
the images are fantastic we use them in
our applications we convey emotion and
power in information and all this other
great stuff but images also have a
problem is that they're easy to bloat
they're easy to get too big and too many
resolutions and too many pixels and that
causes problems for your users because
bigger images take longer to download
which means that there's more bits on
the wire
which cost your users more money to
download them because they're on metered
plans and their cellular radio is on
longer downloading the larger images
you're eating their battery more all of
these little things add up when you
start bringing these images down which
is why making sure that your images are
compressed as good and as small as
possible is super important to make sure
that your users are having the best
experience and in general there's a lot
of different things you could do with
images but as Android developers there's
really only four data formats we care
about PNG s
vector drawables JPEGs and WebP II now
the rest of the talk that we're going to
go into today is gonna be opening up
each one of these formats taking a look
at how it works internally and how you
can squeeze out every bit of data from
these things possible sound good
sound good don't worry you'll get the
hang of the applause cues they they took
down the sign that I asked for later
that's okay
all right so let's start at the top with
PNG files PNG s have to be one of the
most amazing formats in terms of Android
development they've been here as long as
anybody has seen they provide amazing
quality and actually pretty good data
compression so let's figure out what's
going on under the hood so let's say we
have an image the way PNG compression
works is that we take every row of
pixels in that image one at a time we
process each row individually and what
we do is we apply something called a
filter to it now the filter itself is
basically a modified Delta processor
right so basically it's going to try to
subtract the current pixel in the row
from the previous pixels of the one
and do all this weird math the point of
the filter is simple it wants to produce
the most number of zeros and duplicate
values possible that's it
that's all it wants to do the output of
that is then fed into a very common
super everywhere encoding system called
deflate anybody familiar with deflate
and get him a t-shirt that's right we'll
get to you later
deflate is actually comprised of two
main compression algorithms the first
one is called lz77 if you've watched my
compressor head video then you'll know
that lz77 is a dictionary algorithm that
tries to match runs of duplicate
characters multiple times in a stream of
data the output of that is in toss to a
Huffman encoder which is a statistical
encoder if you've ever been to cs101
you've probably dealt with Huffman in
some form now this is again it's done on
a single line and the output of deflate
is then picked out to disk now what
these two stages mean is very important
in areas of your image where there's
very similar pixels or there's very
there's a lot of duplicate pixels that
filtering stage is going to produce a
lot of zeros it's gonna produce a lot of
duplicate symbols which means the lz77
and the deflate stage is going to come
through and basically make that stuff
disappear so areas of similarity are
going to get great compression and we're
however areas of noise where there's not
a lot of similar pixels where there's
different colors that may not be a joint
to each other are actually gonna have
worse compression and that's what you
get with this trade-off of the filtering
stage with the deflate stage right now
with this in mind we can obviously see a
couple places that PNG s can be
optimized a little bit more right the
first of course is less input colors if
we've got less input colors coming into
the filtering stage that means that
we're gonna have less unique colors
coming out and we're gonna get better
compression the other thing is actually
smarter filtering I won't get into it
right now there's a different post on it
but there's like five different
filtering modes that the encoder can
choose on and all that other stuff and
there's a lot of math and accelerations
that go into finding that in a way
that's not going to take ten years to
compute it the other thing is a better
deflate algorithm I believe
deflate isn't the best version of
deflates there's actually more modern
deflates out there and applying those to
the algorithm actually produce smaller
files and finally removing chunks and
that's actually a tricky one that I'll
get to in a minute but I know what
you're saying like hey wait a minute all
of that stuff should be happening for me
right I mean there's this really cool
tool in the Android tool chain called a
apt anybody heard of that round of
applause yeah yeah I mean in reality
this should be doing all that for you
right it should be crunching your pngs
down as small as possible anyone
anyone's seen that happen nobody
some people someone's asleep already one
applause get that guy a t-shirts
t-shirts forever you clap so I want to
point out that while the AAP tool is
there to actually try to make your PNG
file smaller it doesn't do everything it
could a apt tool does three things
specifically no more no less
the first thing it does is analyze your
PNG files to see whether or not you're
only using grayscale colors so for
example if you're red green blue
channels are all the same color it will
actually make your entire image into
single 8-bit alpha Channel that's it
goes right down to grayscale the second
thing it will look for is whether or not
you're actually using your transparency
channel if you've got a fully opaque
image that's not using any transparency
bits it'll actually get rid of that
entire channel and save it out to be
smaller and the final thing and this is
this is the one that's pretty awesome
it'll actually scan your entire image
and determine whether or not you're
using 256 unique colors if you're using
256 unique colors it'll save your image
in a piloted format which all basically
decreases the size by some insane amount
right basically all of the 32 bit per
pixel data gets quantized into a little
table like that that we call a pallet
and it's replaced with an 8-bit pointer
into that pallet so instead of 32 bits
per pixel you're now down to 8 good
savings right so the question that I
have though is ok aapt is really good
but how good is it and to answer that I
had to open up an application and take a
look at how a apt was impacting and
affecting that application to see
whether or not it was doing a really
good job or if there's somewhat
improvement
to be made so being I oh I felt maybe we
should do a call back to last year's i/o
shed application and see how well a apt
was doing with that
so anyone looked through the source code
of the i/o scheduler application from
last year round of applause yeah did
anyone find the hidden easter egg in the
source code no then forget I said
anything so when we open up this file
there's a lot of assets now there's two
things to compare here of course first
is the source code files in github and
then there's the apk that you can
actually download from the Play Store
unzip and take a look at the assets
right so I wanted to look at between
these two because if a apt is doing a
great job I should see a big change
between those two file sizes right so I
opened up the file and it just picked
some random graphic this was the one I
happen to look at
that's a 144 by 144 pixel PNG file and
that's 6k that's huge right sorry this
is in the the source code repo right now
when I open up the apk and take a look
at it it's actually only 2k which is
better but still way too big for 144 by
144 pixels like that's that's massively
huge right and so I said well hold on
that something's missing here obviously
we've got some optimization let's figure
out what's going on so I opened up this
image in Photoshop and I saved it for
the web there's a difference between
file save and file save for web there's
a whole different process in there in
that process I actually quantized it to
only use 256 colors as you can see when
I did that we got about the same size as
was in the apk so we can see that hey
then apt did its job
it probably quantized this to an indexed
image right but here's the problem
take a look at that image does it look
like it's using 256 colors No so let's
crank it down a little bit here's what
64 colors looks like anybody see a
change let's go even more 32 over 16
colors still don't see a change 8 colors
still don't see a change or if you do
your eyes are better than mine the point
here is that we went from 256 unique
colors down to 8 unique colors and
didn't see a change in visual perception
the difference in file size though was
huge right
because we were able to find a smaller
color size so let's let's look at a
different a different example here so
this is one of the big banners big
banner images that you see inside of the
application that's a forty nine point
five k in the github repo and 32 k
inside of the APK so again there's some
some smaller modifications going on here
to the AAP tool but still let's see if
our trick works here - right so let's
actually down raise it to 32 colors this
one isn't that good right I mean you can
see some banding and the gradients there
you can see that some of the colors just
aren't looking as true as you can
so let's bump that up to exactly 256
colors here you can't actually see any
visual difference right but notice the
difference in the file size this is only
18 K instead of the 36 K right so this
image actually only needed 256 colors
but maybe the source image didn't have
that and this is the problem with the
AAP tree tool it does a great job of
those exact three things and no more
than that so in the first case we had an
image that obviously needed less colors
right and could have been optimized more
and in the second case we had an image
that had maybe just over 256 colors that
if we set it to 256 it's still what it
looked fine right AVT does neither of
these for you which means that it's your
job as a developer to step past that and
start doing additional methods to reduce
the size of your PNG files so let's take
a look as I said before how easy it is
to mess this up so you've actually just
take a 16 pixel by 16 pixel alread PNG
file file save as from Photoshop look at
2k that's 64 pixels that 2k the funny
thing right now is everyone in the room
is doing a gut check about whether or
not their designers are using file save
as from Photoshop to save their pngs
right right when you save it for web
though you end up at 121 bytes which is
better which is obviously better that's
the thing we want to see this is how
easy it is to mess up this problem now
the good news is though that you don't
have to go into crazy town
with trying to optimize all those things
we talked about before with the
different stages of PNG
PNG optimization is an old problem old
meaning the 90s right I mean some of you
were alive in the 90s right okay yeah
but who wasn't alive in the 90s okay all
right yeah old people nice I start
professional people yeah the truth is
that there is a plethora a plethora of
tools out there that have already been
solving this problem for almost two
decades you don't got to do the heavy
lifting just google it and pick any one
of these really they all do different
stuff and have different algorithms and
different needs and different settings
and whatnot but if you just add any one
of these to your existing asset chain
you're gonna get an immediate reduction
and an immediate improvement in file
size now that being said there are some
things that you can do to make it even
better in terms of file sizes and I only
mention these two things because I'm
seeing them a lot in applications that
I'm opening and taking a look at okay
here's the things you are all doing that
you need to stop so first off is if you
can in every single way try try try to
make your image 256 colors or less it's
a pretty simple quantization step you
just tested you take a look at it here
is one of our Google Doodles that we
actually put on our main page here you
can see it was a they came down as 24
bits per pixel it wasn't indexed and a
hundred and ninety-seven K when we
exported it the index mode is only 73 K
again visual difference here
imperceptible but the difference in file
size was huge just by trying to take
into account hitting that indexed mark
and you can see the pallet here is
actually pretty simple I mean there's
nothing crazy going on by the way that
diamonds down there on that white
actually represents the transparent
pixel color for that and you can
actually do a bunch of those but and
read the article there's more and stuff
on that there here's another one can
anybody tell me why one of these images
is 139 one of these is 214 alpha Channel
good what about the Alpha Channel wait
did you read the article oh wait
nevermind cheater okay
okay so it's absolutely right alpha
Channel so here's what's happening this
is this I've seen this quite a bit and a
lot of the the files I've opened so
visually you can see that the last frame
is what the user sees here but when you
open this thing up and you take a look
at the RGB channels in the a channel
separately you can see that the RGB
actually has a ton of data that gets
masked out by the alpha value the end
result is the same visual image to the
user but to the compressor we still have
to compress all of that RGB data the
filtering stage house still has to be
run on it the output of that sauce will
be run through a deflate algorithm and
because there's a lot of non-uniform
pixels there the result is going to be a
lot of bloat in your compressor right
however if we try to pre multiply this
stuff and mask out the pixels that we
know are never going to be seen we end
up with a much smaller file size I've
been seeing this in applications popping
up lately a lot more than I'd like to
say so take a look at this now one of
the final things I need to point out if
you're gonna go down this path and
you're gonna add in some of these
awesome pre-processing tools to your
chain and get it all working with Gradle
and you're gonna tell your designers to
not do that thing I just said and try to
make index files you may run into a
really weird issue so let's say we've
got this great image it's about 2 16 K
and we actually run it through Zoff PNG
horizontally PNG which is a fantastic
open source tool that it's a better
deflate algorithm compressor for PNG
files and we get it down to about 185 K
but when you build it it actually goes
through a apt and it bloats to 201 k the
reason for this is that the AAP tree
tool doesn't know that you've
pre-processed your image right again
it's only checking for those three
things and so it's gonna look at your
image and it's gonna try to make it into
a B or C format and then it's just gonna
save it right to disk the problem with
that though is that you've may have made
all modifications obviously your version
is smaller and their version may not be
to get around this in your application
you need to specify the commit the
option Gradle cruncher enabled equals
false this will disable a apt
optimization for all of your PNG files
that are coming through your pipe now
the problem though is that once you do
this it's kind of on you to make sure
that all of your images are awesome at
that point right what you're all gonna
do
all right now the back row let's try the
front row again that's good
that's good I'm sorry the front row is
winning back row you want to try again
oh oh
they added whistling come on front row
we'll try again later
all right so the livestreams getting
antsy alright so make sure that you
actually set this file or this
configuration inside of your Gradle file
so you don't end up actually bloating
images that you've already taken the
time to compress now probably one of the
biggest things that you can do though in
terms of file savings is actually
consider replacing your PNG s all
together with vector drawables instead
now for you those who don't know rap PNG
files are raster files they have a big
problem and that you need multiple of
them in a file to actually get your
images so you know we need one at this
resolution and one at this resolution
and one at this resolution which means
in our apk we're actually ending up at
55 K footprint to represent the same
visual image at different resolutions
and there's some tricks you can play
here with split apks and up sampling and
all this other stuff but this is the
gist of the problem there's another way
to approach this issue and it's the
concept of actually drawing your images
with code so that same picture what if
we took a stab at it saying this lets
emit a byte code that actually draws a
white background and then another code
that actually draws a red circle now if
we create our custom dsl language and
whatnot we could actually get this into
you know one byte per instruction and
actually end up at about 15 bytes to
represent the same thing the result of
this is that we can generate those same
three images at any of these three sizes
using only 15 bytes of our scheme
instead of the 55k that we were using
before this is the concept of vector
image formats right basically we take
some sort of stream that represents how
to draw primitives on a screen we
actually execute those rasterizing those
primitives to a bitmap and cpu memory we
upload that to the GPU and then we end
up actually drawing that to the screen
the benefit you get here is much smaller
file sizes the downside though is you
actually trade-off time it takes longer
to strass dries these images and get
them into memory then it does to
actually you know say use the hardware
decoder and decode a JPEG so there's a
little bit of a trade-off you have to
deal with there but this is the whole
idea behind Google or the androids
vectordrawable format it's a stream a
series of instructions that define how
to draw paths and colors and gradients
and all other sorts of stuff so you can
draw these images at the sizes you need
on demand but the question is okay this
is fine this is fancy I've already got a
pipeline of awesome pngs and my artists
know how to make pngs they don't know
how to do this vector drawable thing
come on bald guy what what oh yeah let's
get to the point here what's really
going on
don't worry so I decided to run a test
how much could vector drawables actually
save me as a developer to figure this
out though I needed to take the i/o shed
application actually convert all of my
images to vector drawables well there's
270 of those things totaling up to 926 K
and size I don't have the time to hand
customize all 270 Beals images
thankfully there's a tool to the rescue
there's a great tool in the internet
called Pio trace and this tool has been
around a long time
it'll take a bitmap image which is you
know literally a image with one bit per
pixel and actually turn it into a raster
vet or turn it into a vector format
raster image to vector format so I
decided to run this on every asset
inside the i/o shed application and the
results were actually a lot better than
I expected to be honest with you right
so you can see the top row here is the
source and the bottom row here is the
result of the Pio traced application
we're pretty close the first one looks
identical the second one you can see
some rounding the third one pretty good
the fourth one you can see that we're
only dealing with you know shape so we
lose some color there and the hexagon is
perfect the hexagon is actually a really
cool example here because that hexagon
actually absorbs 6k of our file size at
different resolutions however the vector
draw over or the vector version was only
961 bytes so even just running it
through here we saw some wins the
downside though is that this is an
automated tool right I mean this is only
a test we're just trying to figure out
how all this stuff works together and
obviously there were some failures uh we
missed some interspersion detail
obviously we're not getting the exact
representation and it just fell over and
died on the i/o algorithm right the
result though I think was a good test to
figure out what you could save so
running things through Pio Trace we
actually ended up with only a hundred
and fifty three files because we didn't
have to want to have one for each rep
resolution
and the result was actually 149 K that's
84 percent reduction in asset sizes by
just moving everything to be a vector
drawable which is a pretty good savings
yes this pot yes this man yes you
started the clap sir you are awesome yes
so 84 percent smaller that's a pretty
good deal
right now it's worth noting this was
just a test you can't just go run P Oh
trace and convert everything over I mean
it spits out the EPS files and that's
not the same as VG files and oh by the
way there's actually a chance that you
could optimize stuff further right
instead of just importing from SVG if
you did stuff by hand you may actually
be able to get stuff down even smaller
than that so but the main point is you
can get a lot of savings here by ruling
two vector drawables so make sure you
take a look at it alright now let's talk
about the big images the big big images
JPEGs who loves JPEGs yeah I didn't hear
anybody in the back I love the book
grudging pause right like ah fine
we're just here to stay out of the heat
pass me some water this is great
okay JPEG files I got to tell you JPEGs
are they're crazy one of the most
impressive algorithmic systems I've ever
encountered
it's impressive the math that goes into
this not just from an algorithm person
we could put them just the raw math of
the situation take a look at this so
when you encode a JPEG here's what's
going on you take your source RGB image
and the first thing that happens is we
actually convert it to a separate color
space the reason for this is that human
eye the psychovisual differences in the
human eye are less susceptible to the
ycbcr color space or the chroma lumens
color space right we're actually more
tuned the human eye is more tuned to see
differences in our GPS than we are ycbcr
so the first thing that JPEG does is
convert us to that space the next thing
is we actually reduce the size of the
Seabee the chroma channels see B and C
are channels again the human eye doesn't
notice as much changes in that spectrum
so it doesn't worry about it after that
we actually go through and block up our
image
apply the discrete cosine transform this
is magical if you get a chance to check
out the blog post on this basically the
idea of the discrete cosine transform is
that any signal can be represented by a
sum of cosines what it's a it's a thing
it's a thing like these mathematicians
sat down and work that out on paper
before computers were awesome like
discrete cosine transform is one of the
most amazing things I have ever seen
basically they can represent any 8 by 8
block of pixels by summing cosine
transforms across the 2d space that is
awesome right the output of that is then
rammed into a quantization phase the
quantization phase just basically takes
the output of the basis coefficients and
quantize them down to integers in a
subspace that we can actually encode
more they get spent out to the
statistical encoding phase which may be
Huffman or you know arithmetic or
whatever your particular flavor of the
month is and then finally of course we
go to the output JPEG file now here's
the weird thing
this is awesome this is totally crazy
right way harder than PNG then why won't
you export an image you're given like
one slider all of this chaos is hidden
behind one slider when you export an
image that's impressive on its own right
now the question is what should this
value B this is the JPEG quality when
you export a JPEG we asked you what
quality you wanted out pour that right
and so the question is what should this
be right so let's take a visual look at
what the Photoshop would actually output
us so here's a PS 12 so this is would be
a hundred percent JPEG quality right 263
K let's drop down to 11 10 go to 8 you
can start seeing some blocking here look
at look right right above the the red
parrots head you can start seeing some
ringing artifacts the gradients in the
background aren't as solid there let's
go down to 4 so this is quality 4 you
see a lot more ringing artifacts here
right a lot of you can see in the
quantization artifacts in each 8 by 8
block right and 0 obviously some color
bleeding going on we're seeing some big
stuff there so the question is though
what value should I choose right I mean
you can't open every single image and
take a look at it and choose
right value there's just no way we can
support that in any sort of real
pipeline the solution is to not to
automate the whole process and for that
I'll get to in another slide the the
real solution here is to automate this
process and figure it out but that's
actually not what most people are doing
when most people are actually doing here
is choosing some value and exporting all
of their images at that the image min
project which is an open-source project
on the internet started downloading a
bunch of images from all of these social
networks and figuring out what their
exported quality was and then put it
together in a table so you can actually
see what everyone is exporting things at
now the ones with ranges are actually
really impressive because it means that
they're trying to actually find the
right range of things the weird thing is
it's not as scalable as you think right
like if if something happens to be
brighter that's given these values if
it's dark roots these value it's a
little bit more quantized than dynamic
but the question for your project is how
do we figure this out algorithm plate
and for that I want to introduce booth
or Galilee this is an open-source
project made by the compression team in
Zurich
who loves naming things so that I can't
Google for them or spell them or
pronounce them so to make sure that you
all can pronounce it we're gonna say it
together here okay this is gonna be boo
tur OGG lis boot door ugly
okay now you all can google this later
in the native language it means a sweet
bread to eat with coffee but in the
github project it means a a way to
compare the psychovisual similarity of
two images this is basically a way for
us to say lemme compress take a source
image and compress it and see how the
human eye responds to the differences
between these two how much error can we
actually notice now you may have heard
some other terms in the past like psnr
anybody hear that one
yeah ssim yeah these are common some
simple these are very common things you
think of boudoir golly in the same
fashion of that the ability to measure
two different psychovisual changes as an
image changes now the real use of
boudoir golly the the intention that it
was made for was to actually figure out
how much we can compress an image before
the human eye notices anything right how
far can we go before even the smallest
perceived visual
change occurs and when you actually use
the booter gali library you'll notice
that that actually occurs at the 1.0
level so when you export at booter gali
1.0 that is where or when you test it
and you get 1.0 that is where the human
eye starts to notice artifacts anything
above 1.0 is chaos land anything below
1.0 the human eye can't decipher right
so your goal would be like hey you know
we have a lot of high-res images we want
high-res images and we want to find the
ideal export this will help you but
sometimes I don't want perfection right
sometimes I want a little bit of
compression artifacts in there sometimes
someone's loading something on a 2g
network or they're sitting on roaming or
they're in the middle of India and they
don't have the right connectivity I want
to give them a worse quality image so it
doesn't take them six hours to download
the thing right they don't have to pay
for it so maybe I'm okay going above 1.0
so how would we go about doing something
like this how would we find the right
level for some other statistic it's
actually pretty easy if we actually take
a little Python script here and run
image magic we can convert a PNG to a
jpg file at some quality right we
convert that jpg back to a PNG so we
know we're actually comparing apples to
apples here and then we run those to PNG
files through booter golly and if the
score is above some random metric that
we've decided based upon artificial
intelligence and machine learning for
this person in this area on this device
let's just say it's 2.0 randomly then we
return that quality value so does this
look like
so I ran this on the parrot images and
you can see really quickly we found that
about quality sixty we passed the 2.0
threshold right and then it actually was
able to dive in a little bit more and
get a you know single step quantization
actually found that at quality 62 we
broke the 2.0 threshold let's look at
this side-by-side this is the 1.0 score
in the 2.0 score the difference is 60 K
right
but the booter Gauley image metric is so
nice that you can see very small changes
in the 2.0 version of course this is
blown up on a screen on the live stream
and all this other stuff but the main
point that I'm trying to get to here is
that you don't have to choose one image
compression quality for everything you
can actually dynamically choose this and
move on
so beyond that though there's a couple
things that you can do by hand JPEG
unfortunately has the same problem that
PNG does right file save as from
Photoshop 11 K for that 16 by 16 pixel
block 11 K Oh are you sure your
designers aren't doing that are you
really sure think about it maybe send a
text real quick save as gets us to 1.1 K
still that's a 16 pixels by 16 pickle
image the funny thing is you want to
know what's going on here extra data
metadata JPEGs and PNG is have the
ability to add block data to your image
so when I'm standing on the Google
campus wandering around to this Google
i/o and I take a picture of the Gator
this is how my image sharing service
know that where I was standing
there's blocks that they can insert into
your JPEG files that have this
location-based information and that
bloats your image and if you're not
properly removing this stuff is an image
serving application that means every
other user who's downloading it is
grabbing this extra bloated data
obviously that's not a good idea so
let's talk about that's a that's
obviously block removal but there's a
bunch of other places that we can
optimize here right we can change how
we're down sampling we can improve the
way that the DC DCT coefficients are
handled we can improve the way we
quantize if we could just apply a better
statistical encoder right great news
folks you don't got to worry about any
of that everybody's already got it
solved googling for this brings you a
pretty good handful of algorithms and
tools that you can hand put right into
your tool chain the first two here JPEG
mini and Moz JPEG actually go to find
another lossy compression variant so
they'll degrade the image quality of
your image to get you just a little bit
farther and a little bit more savings
right on the other to see JPEG and PAC
jpg or lossless they're gonna try to
improve those quantization and
statistical encoding stages so that you
don't actually lose any bits the
interesting thing is that patch JPEG
actually works more as a post format
than anything it'll actually take your
JPEG and encode it in its own format so
we can get it even smaller than that and
of course you've got a lot of web
solutions that you can find to where you
know you upload your limits to some API
or some service that'll do everything on
the back end and send its you I don't
care what you use
pick one right and don't let your
designers hit save hats from Photoshop
right any of these will work pick one
test it out see how it works send me a
tweet let me know how it happened right
one thing though I got to say this one's
really cool to do by hand and I've only
got a couple minutes so I'm gonna try to
go through this fast two images here top
one 175 Colt modified 82 K on the bottom
what we're doing here remember that the
first thing that JPEG does is split your
image into a different color space right
because the human eye is more
perceptible to some loss than others
so what we do here is we actually in
Photoshop split this to lab color mode
right which is luminance and then a B
channels we select the areas of high
contrast inside of the AV channels and
we actually just go file blur what we're
doing here is we're actually reducing
the number of unique colors the number
of the amount of noise in these chroma
sampling these chroma channels so that
when the JPEG codec comes back through
there's less information there that it
has to find unique and you're actually
gonna get better compression as a result
so this simple technique going through
hand optimizing this some of this stuff
can actually save you what was this 2x
or 50% savings on a file that's that's
if you're still in serving a million
files a day that's huge right all right
let's get to the final one here wet pee
pants wet pee yeah
wet PE I gotta say is as much as
impressive as JPEG is web PE is is it's
in its own leak I've done compression
for a long time it's in its own league I
mean on one side you've got a whole
suite of algorithms that applies so we
can keep up with the lossy type of
compression that JPEG does on the other
side of it it's got this whole separate
filtering and prediction policy so it
can do lossless encoding just like PNG
it's even got some lz77 and dictionary
encoding in there so we can do that the
result is pretty simple across the board
all of these optimizations and
techniques make it competitive with both
PNG and JPEG everywhere and it supports
all of these features as well and in
most time it's actually winning if you
if you check out those so you get
smaller file sizes you get more features
in those file sizes and it's supported
natively on Android which is also round
of applause
right okay now let's get let's get real
for a minute I know we laughed the gummy
bears and had a clapping war but let's
get real can we get real round of
applause for getting real yeah weirdest
applause request ever if there's one
thing you remember if they you know some
bald guy got on stage at Google i/o I
was hiding in the tent trying to get out
of the Sun and he yelled at me for an
hour but I remembered one thing it's
this this is one thing this is all I'm
asking you to remember that's it nothing
else just this okay this diagram when
you're choosing what kind of image to
make the decision on the format is super
important the first thing you have to
ask yourself is can this image be of
vectordrawable
if yes make it a vectordrawable done
easy good lunch if no ask yourself do I
support web P if yes make it a web P go
to lunch you're done for the day good
job peer bonus sweet if you don't
support web P ask yourself does it need
transparency if yes obviously you gotta
use PNG for that if no you gotta ask
yourself is it simple or complex
remember PNG optimizes and compresses
better in areas of very self-similar
pixels so the more photorealistic and
image the worst PNG is going to compress
it the more simpler an image the better
PNG is going to compress it right if
it's complex we're gonna go to JPEG now
if we end up at PNG we want to make sure
that we're running a tool on it reducing
colors trying to make it indexed and
hand optimized again in places where we
need to for Hero assets same thing with
JPEG you use a tool correct the quality
and hand optimized where you can I love
that everyone's taking pictures this is
live streams you can get this later in
fact if you check out the spaces
application I'll put this up later put
your phones down you're good
I'm flattered if you're taking a picture
of me but you know I could pose anyone
want a picture the pose no up something
we're awesome where I need to be over
here okay now we got any back and
getting back to the a/v people getting
mad at me sorry okay
most importantly though this one simple
thing profile your code profile your
code profile your code before you make
any decisions before you make any
performance changes before you change
your format before you put bits on the
wire that your users are going to have
to pay to download profile it make a
decision based upon evidence and data
and the best thing for your users do not
go lazily into these decisions because
they have huge ramifications for the
people who love you and your
applications profile it in some cases
JPEG is gonna be better than PNG in some
cases WebP E is gonna be the best option
in some cases that's gonna load too slow
and you're gonna want to use a JPEG in
every single situation profile your code
find the sweet spot optimized for your
users in every case and thank you thank
you thank you so much for coming to this
session my name is Colt McAnlis
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>