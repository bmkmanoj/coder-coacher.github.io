<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Android Wear 2.0: Building Apps with Material Design - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="Android Wear 2.0: Building Apps with Material Design - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Android Wear 2.0: Building Apps with Material Design - Google I/O 2016</b></h2><h5 class="post__date">2016-05-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LtD7eJp2ILo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone I'm JP Gill and I'm a
designer on the Android wear team and I
led the design for bringing material
designs to wearables hi I'm Paul Sulis
I'm an engineer on the Android wear team
and I built some of the material design
library features material design is a
key aspect of wear 2.0 today we're gonna
talk about how you can design and build
apps for Android wear using Google's
design guidelines called material design
after we go through some design
principles I'm gonna show you how to
build an app using some of the new
components mature design is google's
visual language it's been designed to
work across multiple platforms devices
and screen sizes it provides a toolkit
for designers and developers along with
a comprehensive set of guidelines and
design principles this images on the
screen is an abstract representation of
different screen sizes going from the
big TV on the screen on the back to
desktops tablets phones and the white
little small dot there that's a watch
screen today we focus on the little
screen and we show you how we extend it
material designed to work on wearables
and how will you help with design apps
if you want to know more about material
design please visit design Google com
mature design for wearables can be
described in three key areas they focus
on vertical layouts to improve
simplicity and usability the use of dark
colors which are less interruptive and
can save battery on the OLED displays
and a set of new UI components and app
design patterns that help designers
create great-looking apps developers
build apps more quickly and users have a
more consistent app experience mature
designer and Android wear 2.0 isn't just
for apps and extends across the system
the principles using apps are observed
in other system components like
notifications the app launcher input
mechanisms on the device and other parts
of the system
here you can see a few administrations
designed with these principles layouts
are vertical they use darker colors and
also have some UI components and app
design patterns let's talk about
vertical layouts originally we left
things really open in Android wear we
saw the developers and users get
confused with the freedom to scroll left
right up down in all directions
basically in apps and the OS I felt that
restricting the primary access to just
the vertical axis just helps people
orient themselves and get things done
the notification stream on Android wear
2.0 is one of the core examples of this
vertical principle users navigate
vertically started from the watch face
to check their incoming notifications
once they open a notification as you see
on the right image the notification
expands vertically to reveal more
content and more actions sometimes your
app may need the horizontal container
and that's also okay for example if you
have an inline photo carousel in your
app what is really important in this
case that your users understand the
hierarchy of your app they need to
understand that this vertical this
horizontal container is contained within
a vertical container the parent
container and that's okay so it's
important for for users to understand
that the main axis of the app is
vertical dark colors are central part of
material design for wearables previous
UI is on Android where is the light
color scheme we found that brighter
colors use more battery and can be
interrupted
when the screen is active this app
example uses the light color scheme like
you typically see on phone apps using
material design the primary color chosen
here is purple 500 from the material
design color palette this color is used
to highlight content in actions in
different act sections of the app and
already give a distinctive look to the
app white collars have too many issues
however one is that light colors are
less energy efficient in all LED
displays because they need to light the
pixels with brighter intensity for
example white pixels need to light up
the RGB dials in your pixels at a
hundred percent so the more white and
light colors you have in your app the
last battery of fish in your app will be
the other issue is more of a social
nature imagine you're in a restaurant
and levying a pleasant candlelight
dinner probably this restaurant they run
out of candles is really dark and you
receive a message notification from a
friend because watches are visible on
your wrist at all times or most of the
times if you have long sleeves they're
not going to be visible your display may
disrupt the plasma atmosphere when you
get on this vacation the situation would
probably not happen with dark colors
here's the same map example using a dark
theme using the same primary color
purple 500 we arrived all that colors
that using it in this example
differently to light colors dark colors
make the screens less bright when
they're active and save battery in all
that displays we've also designed our
system notifications to automatically
adapt to your app color so they create a
unified experience for your app though
that I'll show here we derived these
colors using as a method that we
developed and they are derived from the
purple 500 manually and I'm going to
show how we did it so this is our
primary color purple 500 from the
material design palette this color can
be expressed in different color
notations like RGB red green blue here
we are showing the decimal values for
RGB another common way to show the
values of RGB with hexadecimal values
it's usually very common in web apps and
Android apps as well yet there's another
notation called
hue saturation and brightness and that's
the notation we use to
our color system if you look at the app
we have here which is expressed in
degrees brightness in percentage and
bright excuse me saturation in
percentage and brightness also in
percentage we went to manipulate that to
create the colors we manipulate the
brightness brightness values of this
color and we're gonna show you how we
did it so let's imagine our color would
just move from a color world to a black
and white world and that every sub color
could be expressed by just the
brightness value of the sub colors as
you see here in the image below purple
500 if your being this color back to the
happy colorful world that's how it's
soup color would look like we named five
different sub colors that we think can
cover most of your apps needs here they
are from light to dark accent so as I
mentioned before we just moved the
brightness values on the color so accent
we move the brightness up to a hundred
percent then you have lighter UI
elements where he moved down from 74
percent to 65 and you go down to forty
percent for two UI element then 30
percent for lighter backgrounds and
fifty percent for dark dark background
now let's see how these colors are
applied in our example we use the accent
color
apparently throughout the UI in this
example we are just like highlighting
the username and the timestamp we use
the lighter background color in most of
the UIs background and to section off
certain areas of the background we
decided to use the dark background color
active elements in the UI like elements
where you take action like the action
drawer or the primary action button they
use the lot of UI element and to
separate the primary action button on
the Left screen we use the UI element
it's almost like a intermediate
intermediary background luckily this
call
purple 500 isn't alone in his happy
collar world they have a lot of friends
we also update a complete material the
complete material design color palettes
to help you choose darker colors for
your applications we needed to however
to make a few adjustments to make the
palette more readable and more
accessible so we optimized the
saturation for some of the sub colors in
the blue range as you see here on the
image and the yellow range if you want
to know more about colors please visit
our materials backside and the URL here
is on the bottom corner ok we talked
about vertical layouts and darker colors
two of the key areas of material design
for wearables let's talk now about the
last one UI components and patterns we
walk you through the basic anatomy of a
material design app for web 2.0 imagine
this circle in isometric perspective is
the screen of your watch the app will
have a vertical container with a
vertical layout and this layout we use a
dark color palette and here is two
components that Paul will show it you to
you how to build your own apps near
after day wearable action drawer and
wearable navigation drawer let's see how
they work and navigation drawer helps
users navigate between sections of your
apps
it sits vertically on the top of the
content containers outside of the
viewport so if you look at this image
here of a fake mail app that we call
Mayo box you see the vert the containers
for the main containers of the app
they're all vertical and the navigation
door sits on top of it the navigation in
the drawer is actually horizontal and
it's on purpose because the only way to
move between different orders of the
containers vertical containers is
horizontally because I know someone's
gonna ask that question later
this horizontal motion helps us enter
different vertical views in the in your
application for example if you want to
switch between mailbox - settings -
contacts page to your drafts this how
the navigation drawer works in action
the users proof from the top navigate
between left and right to arrive at the
view it's pretty simple
we've also implemented a peak behavior
to remind users that the drawer actually
exists outside of the viewport sometimes
users may forget there's something there
the drawer picks as soon as the user
Scrolls back to the top of the current
view as you see on the animation and the
drawer just speaks in users don't have
actually to scroll all the way to the
top to get to the drawer the drawer is
available available at all times you can
just have to pull from the top edge of
the screen and the draw will be there an
action drawer it's the one that sits on
the bottom of the screen an action
Darla's uses access actions for specific
usage context let's look at the example
of the conversation in a messaging app
there are a few possible actions here
could be more but I'm just doing a few
replying to the message adding a photo
sharing a location adding more people to
the conversation
so to access the actions user just have
to pull up the drawer and tap in the
overflow icon and as we did with a
navigation drawer users can open that
drawer at any time by pulling from the
bottom edge of the screen in fact we
found that usability studies that once
users discovered that behavior they
don't even wait for the pick stage they
know the drawer is there they just open
the drawer and perform the actions so
what happens if you have only one action
in your drawer so if you have only one
action you don't need an overflow icon
so the overflow icon does help to helps
you figure out there's more actions
there but we only have one we debated
whether we should have like a drawer and
just the peak state with a tact icon in
it and we found out that sometimes if
you use an icon that users have never
seen before it's useful to have a drawer
with just one action so they I can
actually associate that associate the
action with the icon so tapping on the
action as you're gonna see an animation
now instead of opening the drawer will
perform the action directly so in this
case when the user taps on that the
action you will just reply he would just
reply to the conversation to prevent
unnecessary screen obstruction the
drawer also has a peek in hide behavior
in this animation you see how the drawer
disappears and reappears when the user's
trying to go back to the bottom of the
conversation that means let's say you
received a message from a friend and
they ask you a question you want to go
back into the conversation history you
find out what you want as you go back
down we assume that you're trying to
actually reply to the action so we pick
the drawer in for you as a convenience
in this case maybe you just want to hope
from the bottom as well now we'll have
the robot appalled who show you how to
build these components thanks JP now you
learn about the design behind drawers
I'm going to show you how to implement
them the drawers are a new feature in
the world will support library and if
you're familiar to implementing
on a phone then you pretty much already
know how to implement them on a wearable
as well so first we're going to go
through some more generic easy to
implement use cases the wearable action
drawn wearable navigation drawer and
afterwards we'll take a little deeper
dive and show you how to build some
custom drawers if your application
should be a little more tailored to the
user experience so wearable drawer
layout is the container that everything
goes within here you're going to define
your content this is going to be the
vertically scrolling thing that JP spoke
about and within it you're also going to
define an action drawer and a wearable
navigation drawer to get the peaking
behavior you need to enable nested
scrolling what this does is it allows
the wearable drawer layout to understand
the movement that's occurring deeper
within the view hierarchy so that it
knows when to peek for instance when you
scroll to the top the wearable drawer
layout needs to peek the navigation
drawer so you can do this by enabling
nested scrolling enabled on standard
Android views such as ListView some of
the Android support views like recycler
view and nested scroll view implement
this by default on the left is a
navigation drawer on a phone it's
generally pulled from the left side of
the screen or you tap the hamburger menu
and allows the user to navigate the
application on the right you can see the
same thing
the wearable navigation drawer for use
on watches its pulled down for the top
of the screen and it allows the users to
navigate between different columns of
vertical content navigation drawers are
populated through the same adapter
construct that you're already familiar
with on Android there's only a few
message invested through the methods to
implement it's really easy let's go
through building one so you pull down
the navigation drawer from the top of
the screen and you see that you're in
the mailbox section the user knows that
there is one section to the left and two
to the right from the indicators at the
bottom of the screen you define this by
filling in the get count method from the
adapter and in in particular the section
that the user is currently on is
highlighted by a larger circle to set
the label get item text is called and
that's what sets the label for it and
then there's also get item drawable
which sets the icon and that's all
that's needed to populate the view for a
navigation drawer it's really simple and
quick
there are two other methods to discuss
on item selected and notify data set
change on item selected is called when
the user navigates left or right within
the drawer and this gives you the
opportunity to change the underlying
view for instance if the user goes from
the mailbox section to the settings
section that gives you an opportunity to
change the underlying content to reflect
the new settings screen notify data set
changed is called when the data backing
the adapter changes after the adapter
was set this notifies the navigation
drawer that the data behind it is no
longer valid and it needs to redraw the
view so that it can get the new icons
and labels action droids were a great
complement to wearable navigation
drawers and they allow the user to
quickly perform actions on the content
and the screen on the left you can see
an action menu as it is implemented on a
phone generally open by clicking the
overflow menu and on the right is a
wearable action drawer open by pulling
down up from the bottom of the screen
actions on phones and wearables are both
implemented using the Android menu API
if your action menu is static and it
does not change the easiest way to fill
it in is to specify a menu resource in
your XML here you can see that we
created an action menu attribute and
we're just pointing it to a menu
resource file alternatively your actions
may need to be a little more dynamic and
you can populate them in code as well
here we're using a menu inflator to put
a menu resource file into the menu that
we retrieved from the action drawer this
is exactly what happens behind the
scenes when you specify an attribute
with XML so if that's what you're
planning on doing then it's a little
easier to point it in XML so here we're
gonna clear the action menu and go
through building one in code without
using a resource file so you can call on
the menu object the add method where
you're gonna pass in the item ID as well
as the text to use and once that menu
item has been created you can set an
icon on it later on if you no longer
need the menu item and want to remove it
from the action drawer you just call
remove item on the menu and pass in the
item ID
there are two ways to interact and
retrieve events that are occurring
within an action drawer first you can
set a click listener on the entire menu
when you do this and whenever anything
in the action drawer is clicked this
method will be called and then from
within here you can get the item ID and
then act accordingly once you know what
was clicked alternatively you can set an
individual click listener on a specific
menu item this will intercept the click
event so if the user clicks on something
that had if a general menu has a defined
click listener and a specific item has
one as well the specific one will be
called first and you can respond
accordingly and if you return true the
event will be considered consumed and
will never propagate to the general
click listener one thing in particular
to note is that there are two instances
of on menu item click listener the first
comes from the wearable action drawer
class and this is the one that you're
going to set on the entire menu and the
second one comes from the menu item
class this is what you're gonna use for
setting a click listener on a specific
menu item the standard navigation in
action drawers if they don't see your
application you don't need to use them
you can create a custom one and that
gives you the peaking and drag behavior
that users have come to expect on the
operating system but it allows you to
put in some peak and drawer content
that's more specified for your
application let's take a look at how
Spotify uses them in the first example
you can see that they've replaced the
Peacock overflow icon with a play and
pause button and this means whatever the
user is using an application they can
change the state of the music right
there without having to open the drawer
and if they decide to pull the drawer up
you can see the custom drawer contents
on the right the custom drawer shows a
full set of media controls and some song
information such as the title the artist
as well as the duration and time left
going around the edges of the screen now
Spotify could have used a regular action
drawer and had all of these controls and
information listed vertically but we've
come to associate moving to the next
song to the right of the pause button so
in this case it really made sense for
them to create their own custom drawer
and use the UI that people are already
familiar with
wearable action drawer and wearable
navigation drawer both extend from the
wearable drawer view class so when you
create a custom drawer that you're gonna
want to use that base class and place
your content within it you need to set
layout gravity on the drawer view too so
it knows whether it exists on the top or
bottom of the screen in this example
we're using a drawer on the top if the
content within your drawer also Scrolls
you'll need to enable nested scrolling
again this just helps wearable drawer
layout understand the movement that's
occurring beneath so that it can make
everything fluid in your code there are
two methods in wearable drawer view
there's set peek content and set drawer
content and both of these methods take
Android view arguments and they follow
all the standard view conventions so you
can set a click listener on on it on a
peak State if you want to respond
differently in some cases your app may
need to respond depending on the drawer
state so you can use a drawer state
callback which lets you know when a
drawer has been opened closed or the
state changes we've also defined a few
states such as dragging when the user
drags the drawer up and if they let go a
little early before they finish dragging
and it has a little bit more to move
before it settles in place it'll be
using the settling State and once it's
finally stopped moving either in an open
and closed State the state will switch
to idle here are a few of our partners
using the drawers on the left is life
some they track your food intake and
they use an action drawer that you can
open up to add an extra meal whether you
it's breakfast lunch dinner or a snack
they also implement a navigation drawer
to help you move between food water and
exercise on the right is todoist and
they're using an action drawer to let
you take actions and add new to-do items
in your list wearable drawers are but a
few of the components available in
Android wear to dotto the drawers don't
suit your app and they're a little too
too much UI for what you need to get
done feel free to use some other
principles here is primary action button
and this allows the user to take an
action immediately upon entering a
viewer activity this is similar to a
floating action button on a phone so in
case of an email app besides reading
emails users may wanna
frequently compose a new one so here
we're using a primary action button to
define that right at the top of the
screen and help them build that
immediately in light action buttons
should be used when it's important that
the user gets the bottom of the content
before taking an action so in this
example we put the share button at the
bottom of the content because it's
really important that people read what
they're sharing before they share it
right
confirmation overlays display a
temporary message to express a state
change so in this case the user has
successfully sent a message so you're
going to use the you pass in a success
confirmation overlay and that will use
the green arrow and if you look at the
API there are a few other states to find
to use different icons there and finally
there are progress indicators which let
the user know that something is
happening behind the scenes it's
important to use these if anything is
not going to be instant so that the user
doesn't think your app stalled and they
know that something is coming they just
have to wait another second all of these
pieces can be combined to create a rich
and tailored experience for your
application on where Android wear 2.0
has a new wearable support library that
includes all the components we've
discussed today and more to get this
support library you need to add a
dependency to the wearable support
library in your Gradle build file this
Gradle file is depending on the
developer preview version so it uses the
suffix alpha 1 the exact dependency will
change throughout the preview period and
will finally settle on 2.0 to find the
exact dependency please visit the wear
developer site where you can also find
guides tutorials and reference we put a
lot of thought into material design on
where we're only able to touch on a
small portion of it during this session
the guidelines we've spoken about today
as well as others are available on the
material design for where spec site and
with that I'll hand it over to JP to
discuss some best practices thanks Paul
now that you learn how to design apps
with material design on wire 2.0 and how
to build some of our components let's
briefly talk about some general best
practices for creating SmartWatch app
experiences smartwatches have unique
limitations and capabilities and many of
the design patterns and principles
developed for SmartWatch for smartphones
should not be directly applied to
watches the first thing is you
understand use cases when designing apps
for smart watches focus on use cases
that make sense for the watch
environments watches allow users to take
get information at a glance such as the
arrive of the neck next bus and to take
actions quickly like responding to a
message about complex applications that
require a lot of input and have too much
information density the best wearable
apps are glanceable that means when you
look at your watch and your wrist you
know what they're trying to tell you
they're easy to tap you don't want you
to fumble on the UI to try to take
action and help users complex complete
tasks quickly so help your users go from
A to B quickly don't add unnecessary
steps in between they keep you connected
to both the real and the virtual worlds
and we look forward to see what you come
up with where app where apps should be
designed to support your abs core
functionality don't include unnecessary
features actions or content in your apps
UI so if you look at an example of the
email app the mailbox fake app you
probably want to include the ability to
reply to messages or to compose new
messages and maybe on a watch you don't
want to print or email I mean who does
print email anyway but like you don't
want to print email from your watch
right or you know add a label or show
original HTML content probably that's
not the kind of functionality one I have
on a watch app the last thing is like
wine and design for watches designed for
round design devices first
unlike phones that have rectangular
screens the majority of Android wear
devices in the market have a round
screen a circle fits within a square and
has a 22% smaller surface area with that
you make sure that your layouts work
both on round and square devices run
screens have a sip alike a smaller
usable surface so remember a circle fits
inside of a square and if you put
another square inside of that circle I
know this would be crazy but the square
inside that circle that's your safe area
so don't put anything like import
information outside of that square
inside the circle so the edges around
that circle those are probably the parts
of the UI that are you want to put your
secondary information they're also
pretty small so you don't want to for
example in that top edge of the circle
if you put it squeeze a title there it's
gonna be very small so for primary
information use that center of the
circle the same is for text for laying
out text in a circular device you also
have to observe the same margins and
margins for circular device have to be a
little bit wider to have a more pleasing
pleasant experience
so how do you build for both round and
square devices well we added some new
resource qualifiers to help you do this
on the top we have an under our
resources of values - not round so here
we're going to define things that we
want to use for our square screens so in
the dimensions file we have a left
padding defined with 12 DP so this just
moves the the content in a little bit
from the bezel and gives a little white
space to make a better user experience
as JP dust discussed on round screens
you're gonna want to move content in a
little more so on the bottom we're
defining a values - round folder and
within that we're creating another
dimensions file here we're overriding
the left padding to use 36 DP so here
with you're using a round device at
runtime the application will choose
which to use so in this case it'll use
36 and push the content in a little
further away from the edge
this doesn't just apply to the values
folder but anything in the resource
directory for instance you can have
layout - round if you want a completely
different layout for a round device it's
important to use your apps as a user
would you may develop docked at your
desk or on an emulator but watches are
worn on a wrist for this new form factor
it's very important that this you do
some real Auto testing which you may not
be as used to with a phone a great way
to test is to get up put your watch on
go outside and maybe take a run
imagine you're building a fitness
application and everything works great
at your desk you followed them and
design material design principles
everything's really fluid and snappy
it's great but before you ship it to
users you put it on and go for a run
once you're exercising and breathing
heavily you may notice that the buttons
that were really easy to click at your
desk are a little bit more difficult
when your wrist is moving around and
creates a moving target because you're
breathing heavily so now you go back to
your desk create the buttons a little
larger and by the time you ship it the
users are going to have a great
experience thank you for attending this
session JP and I really hope you enjoyed
it we want to teach you not only how to
design and build wearable apps but also
why the design decisions we made are
practical for small and various form
factors you can start building apps
today by going to G dot Co slash we're
preview the next session in this room is
on watch faces and complications and if
you missed any of the sessions today
they'll all be available on YouTube
shortly one of the reasons we're doing
this preview is to get your feedback so
please use the wearable preview and if
you have any API suggestions or find any
bugs you can let us know it gqo slash
we're preview bug thank you very much
thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>