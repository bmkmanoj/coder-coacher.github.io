<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>RecyclerView Animations and Behind the Scenes (Android Dev Summit 2015) | Coder Coacher - Coaching Coders</title><meta content="RecyclerView Animations and Behind the Scenes (Android Dev Summit 2015) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>RecyclerView Animations and Behind the Scenes (Android Dev Summit 2015)</b></h2><h5 class="post__date">2015-11-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/imsr8NrIAMs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome to recycler view
animations layout and more I am Chet
Haase from the Android UI toolkit team
I mean fire also from the eye toolkit
team I would like to point out that
that's yet not yet or yet which we've
heard a lot if you spelled jiff with
that kind of gee it would actually be if
unconditionally all of these this one so
I wanted to point out that first of all
we created a talk to do in 45 minutes
and we figure the amount of material
we're covering is about two hours worth
so if people are actually watching this
as a video instead if you could just run
it at like two or two-and-a-half X then
maybe we can cram it all in in time
otherwise we'll see how we do what I'll
fix that's too complicated so I also
wanted to point out that we intend today
to talk a little bit about architectural
recyclerview how the different classes
work together to produce animations and
to create everything that recyclerview
is but the thing that we're aiming for
with recyclerview overall especially
when compared to ListView is to give you
a lot of this stuff for free right so
it's flexible it's pluggable its
customizable but ideally you will not
have to understand the details some of
the details that we're going to go over
today in order to get the kind of
animated behavior you want to but if you
would like to customize that behavior
then hopefully information we're talking
about today will help okay so let's
start with the component so this is
recycler view and many of you use the
adapter the layout manager and item
animator and some advise users use the
item decorations or even the pool but
actually all the recycle view
architecture is all based on components
there's like more couples that you don't
see inside there's a child help ler
which handles all these views coming in
and out died adapter helper which
handles your adapter updates and the
recyclers so let's quickly go through
these components and know what they are
doing layout major simple is this may be
the main component that positions your
items it can be a simple list it can be
a good
or it can be like cigarette grade of
items it depends on the layout major
recycle if does not know about it or
doesn't care about it
scrolling is lay out measures
responsibility again focus so part of
the focus is handled by the recycle view
as you move it a keypad in knows how to
move but if the user reach the end of
the list or if damaged you must handle
separately and user pushes down now this
is layout majors responsible to move the
other items up and bring any wheel and
not focus into it another example
accessibility so let me just provide
basic accessibility to information to
securitize I get this wrote this column
or this or this column but if you have
more information about those videos like
the section one cannot be accessible to
focus you had an accessible to delegate
your recyclerview to add this additional
information let's correct an adapter so
adapter is on that crazy or wheels binds
three holders and tells the cycle of
event the data changes it's also the
place if you want the handle like click
listeners your multiple wheel types or
there's some recycle recovery voltage
later on and the granular data change us
like not try this item has changed not
that the whole list change and the
important part of our adapter is
understanding the wheel holder like this
is this is the main composer I want to
go through how we create a view holders
let me get the part of while we're on
the layout says okay give me this wheel
for position X it's like we check the
cache do we have the wheel yes we have
the wheel give it back to the layout
measure we don't even touch that after
the first time of course the case says I
don't have this video recycle goes and
asks okay what type is this view at this
position tells the position checks the
pool do I have a type of dispute so I
can reuse if the pool says no now it
goes to the adapter says create me a new
one of this type it's not created per
position like a new issue is created for
this type and I adapter crease that view
if the pool already has it or adapter
create a new one just binds it back and
return
- the layout managers and then the loud
major will eventually add that view to
the UI that's when you get this over you
attach the window call back in your
adapter so if you're anything about life
cycle that's where you're looking for so
how do you reserve a view holder is
freedom a check we don't need this
anymore what we might need it in the
future so let me just say this okay
removing recycle this view that tiles
adapter okay this view has been detach
and then checks if this view is valid
this is important the well it means the
Reeves - represents that item in that
position the contents are up to date
but layout measure doesn't want this
view anyway it's like simple example
scrolling if it is valid you like to
move it to the cache from where we can
bring it back without doing any
operation and the cache will invalidate
the oldest one is going to tell the
adapter okay this we will the holder is
not recycled if it is not invalid and it
will likely go to the pool an adapter
will receive only recycled codec it's
very important because this is run like
you don't receive e recycle people get
confused cache is important in terms of
performance another better way to go to
reserves is recycle is doing a layout
tells the layout measure to lay out all
the children and after the layout is
completely cycle checks okay which are
the children that are laid out before
and they don't exist anymore
for if this child recycle us them back
to the view group this is the
distinction between a wheel being a
child of layout measure versus a child
of recycler view and now hide them from
the leverage this means these views
which layout major didn't want anymore
they are still a child of the vehicle
but layout major doesn't see them and
the psycho gives abstraction handles
this distinguishing so comes back to
recycle recycle tells item innovator
okay I hear this view can you get rid of
this item animator how's the animation
it comes back in three hundred
milliseconds later Towser cycle I am
done with this view during that
animation this view is not visible to
the lay up measures API recycle tells
our volcano detaching the view caches or
sends it to the pool okay
import about how do we lose a view
holder so layout major calls remove
recycle view of Rosario checks if it is
valid is not valid we try to send it to
the pool but we check if it is a
transient state transient state means is
being animated like some some view
properties are being innovated then the
pools as the adapter okay I cannot
recycle this view because it's a
transient state your adapter you should
be uploading this callback and handle it
properly which means get rid of the
animation but maybe you get to a fitting
your own bind call in that case you can
just say it's fine like just recycle it
I know how to handle it we don't do
anything and if the view is in this case
actually the default implementations are
no I'll handle it and is going to be
thrown out would lose that view but the
moral of the story is you should use
item animator to animate which chat will
explain you soon right betcha sure
Oh see if you have time ok so another
case is the cyclone says add view to the
pool the pool says ok I have too many of
these views at type X and when this the
case it says no I don't want to recycle
it because I are there five of it now we
kill the V of you don't want this to
happen so why would this happen is
basically you just have to many of you
olders at the same time you already have
it why would we and why would we create
too many of them like why did it create
instead of using the existing map well a
common case this happens where you're
animating too many of your waves through
Christ rate which is like change
animations and I want to show this in
because I have seen this online don't do
this don't tell that to light all of
your items from zero to a thousand has
been change it's likely we won't be able
to reuse any of those views will get
like many of them and get instead of so
how do we fix this proper way to fix
this tile recycle which item has changed
or if you really really need those we
types
change the default cache size so that
the cycle will pull more of them item
locations are your just regular drawing
LS throughout the can
us and they can actually add margins or
offsets to view bonds so let's look at
an example this can be like simple
lighting the creation where we draw a
round rink and the view let's see the AP
a little bit in detail so this is my
view and those that's the boundaries of
the view by default and recycle you'll
ask the item animator okay like do you
have any offsets for this item which
means like do you want to draw around
this item where you can say yes just
extend it because I need some more space
and then when the drawing starts let's
this is an empty recycler we've canvas
so secondly what first collocate draw
whatever you want to draw before the
layout measure the children draws
cilantro's square backgrounds and then
the recyclerview straw will happen the
children will draw and after that we'll
call draw over where you can draw over
the children whatever you want there are
some important things that you should
know about item decorations first of all
do not try to access your adapter
because we might call it in the middle
of a layout you can still get the items
adapter position but it's tricky instead
go with the information the view holder
your wave holder should keep whatever
information that item decorator has
needs and the ondraw rules apply don't
allocate because you are being called
many times during the drawing cycle and
when you need to get the view holder you
can use this methods okay this is the
pulleys where we keep all the remaining
wheels so this is a recycler view and
every single item is another recycler
view so wouldn't be cool if all of them
came from the pool this is where you can
use a pupil alright let's go back to
animations yay so animate some stuff so
we thought when we were constructing
this talk we talk more generally about
how animations work on Android first and
then we get into the specifics on
recyclerview
and then we created a talk that would
take two days to deliver so we're just
going to assume that everybody knows how
animations work and we're just going to
go on and talk about the recyclerview
animations in particular so first of all
let's take a look at the different kinds
of things that can
happen in a recyclerview so here's a
really interesting recyclerview over
there I want everybody to know that I
did this art myself okay so we have an
ADD operation so we're going to tap on
this or whatever we're going to add an
item in between the h and the i' and
we're going to create this other
representation where you see that p
element there the I and the J got
shifted down and the K is no longer in
the list we have a delete operation so
we're going to delete the H element
there and that's going to create this
other list okay H is gone I J and K got
shifted up and then we have this new LM
L down at the bottom or we may have a
change animation where we're going to
change the content inside that J item
and it's going to become this other
content over there on the right so all
very good and also all very beautiful
right okay so let's talk about
animations in particular so those were
the different states like the before and
after but then how do you animate these
things so in the add operation say well
we're going to add an item here how do
we actually transition to this new state
of the list what are the animations that
need to take place well clearly there's
a new item there so we have some sort of
animation that's going to fade that in
or otherwise make it appear in the list
and then we have I and J that's shifted
so we could do maybe some simple
translation and move those things around
in the list and then we have the item K
that no longer exists so maybe we can do
some sort of fade or disappearing
animation to make that go away over time
so for the remove operation similarly
what animations do we run here well
first of all we're going to need to
remove that H element that went away
we're going to shift some things around
because they moved within the list in
the before in the after state and then
we have this new item there that's
potentially going to fade in or
otherwise transition to be in the list
there and then finally we have the
change animation where we're going to
run some sort of animation to indicate
that the contents of that item have
changed over time so it's important to
point out that a lot of the stuff just
comes baked into recyclerview an item
animator and the default layout managers
already and in fact even if you start to
customize there's still a lot that just
comes for free out of the box so if an
item gets removed we're automatically
going to fade it out if an item gets
added we're automatically going to fade
it in if it's moving around in the
before and after State
then we're going to translate and if
it's changing we're going to crossfade
it right we're going to provide the two
different views that we then crossfade
between and then the question is can we
actually do better than that and it
turns out we can so first of all let's
take a look at what an actual list looks
like under the covers so that's what it
looks like on the screen to the user but
really that's a viewport into the
overall list of information that exists
on and off the screen right so you have
this virtual list there scrolling
through and you can see the items here
that are represented there actually
exist in some virtual state off screen
so now let's take another look at how
these animations might work given the
information that we have about the
off-screen items there so here we said
OK for an addition we're going to remove
that K element we're going to shift
stuff around and add it if it's in the
after state over there but in actual
fact in the virtual list that K didn't
go away it got shifted off the screen so
that animation a richer animation of
that K element is to simply shift it or
move it off-screen to where it would be
if we could see whatever parts of the
list that are currently off screen item
removal
similarly we said okay well we need to
fade this thing out and we're going to
move some stuff over there and then this
this el item is going to appear on the
screen because it came from somewhere
well we potentially know where it came
from right this is the virtual list
where that l didn't just magically
appear instead it shifted on-screen from
where it used to be in the virtual list
and then changes so these are the
different these are the different kinds
of animations it's interesting to sort
of break it down and say what are all
the possible changes that can happen in
this list before and after and then how
do we animate all of them so persistence
is when items are there before and after
whether or not they move if they don't
move at all nothing to do if they move
around in the list then you need to move
them things get added to the list things
get removed from the list and things get
changed but it gets interesting when you
talk about appearance and disappearance
because here these are the things where
yeah it got added to the list but it
only got added to the list because it
moved on screen from where it actually
persisted before the layout change these
are the two types of animations that we
call predictive animations and there's
some parts of the API that around this
so if you see the word predictive this
is what it's about it's about telling
that's the information that we need to
know where things came from or where
they're going to when they appear
disappear from the list so there are two
main things you want to think about when
you're trying to customize animations
one is the layout manager the layout
manager is responsible for figuring out
where things go in the context of
animations it's not just where they are
but it's where they came from and where
they're going to be after the layout
change and on the other side is the item
animator and that's responsible for
actually running the animations so on
one side we have the layout manager that
figure out where things were and where
they're going to be and then it it
tabulates all that information hands it
over the item animator that then takes
that information says now how do we
animate these things and we have
built-in animations in the system but
then you can customize given that same
information from the layout manager in
your own system so in the layout manager
side you have basically three options
option one is you can use a standard
layout manager we give you a few we've
got linear layout manager we've got grid
layout manager and staggered grid layout
manager and all of these come with the
capabilities we're talking about now not
just simple item animations but also
predictive item animations so if you run
we'll see a demo a little bit later but
it actually moves things off off-screen
smoothly or on-screen smoothly because
it can tell where these things are
coming from or going to option two is if
you want a custom layout manager that's
fine knock yourself out you know how you
want to structure your information on
the screen you're going to have a little
bit of work to do if you want to go
beyond the basics but basic item
animation is handled for you we know how
to fade things in and out and to
crossfade them and to translate on the
screen we can calculate all that stuff
automatically but it's not predictive
because we don't know your layout
manager so we can't tell for your
staggered grid stacks cue syncro you
have on the screen where should that
item have been before we made it appear
on the screen in your strange layout
manager we don't know so all we can do
is fade it in and then option three is
to go full-bore custom and say i've got
a custom layout manager and I want
predictive animation so you're going to
need to enable those and then you're
going to need to tell us what we need to
know for the items that go away that
disappeared off the screen where would
they have gone if we could still see
them or if they appear on the screen
from off-screen where did they come from
so let's take a look at some of this
information how do we get this so it's
the two sides it's it's the it's the pre
layout where we're trying to figure out
like where they were before they then
disappeared and the post layout like
well where did they go once they
disappeared from the list for everything
that's in that list virtual or non and
so an important element here is that
there's potentially two calls two on
layout children specifically if you opt
into predictive animations then you're
going to see two calls into your on
layout children method the first one is
going to be pre layout where we need to
know the information before the layout
change happens including for the items
that are going to go away and then
there's the regular layout where we
figure out where everything is once
layout is actually already run all right
so let's take a look at a little bit of
code so we have support predictive item
animations this is what you need to
override and return true if you actually
want predictive animations then we're
going to call you twice for on layout
children and in on layout children this
code is taken mostly stolen mostly from
linear layout manager which ki wrote
which I would suggest you look at to
understand the basics of how this works
but at a very high level there's sort of
three important elements here one is
first you detach and scrap the view so
you basically say okay take everything
off and then I'm going to tell you how
to repopulate it into the end of the
view and then we're going to go through
all the items that need to be in the
list and we're going to add them in and
then we're going to account for
information if it's if it's removed and
we're going to adjust the layout
parameters appropriately and there's a
couple of important things to note here
is the item count accounts for not just
the real items that are in the list but
if you're being called on pre layout it
also accounts for the items that are in
the list pre prior to layout running
right so we want to know where all of
the items were before a layout run
including those items that are going to
go away because of layout so you iterate
through those you put them in place you
add all the views to recyclerview and
then finally you do this step
and say well if I'm not running
pre-layout then I also need to figure
out where the items are going to be in
the virtual recyclerview and the virtual
list after layout runs
so once you've provided all that
information then recyclerview
has the information that it needs to
then provide it to the item animator to
run the animations so in item animator
let's have some gratuitous animations so
a couple item options with item animator
one is go ahead and use the default item
animator that's why we wrote it it does
a lot of the basics for you if you just
want simple animations recyclerview
basically enables default item animator
by default that's why we called it that
this clever naming we believe a lot
about api's and the Android team then go
ahead and use it and you could at least
start from there and then start
customizing as you as you see fit for
some specialized animations so it does
fade out and translate and it fades in
and it crossfades changes option two is
you can get a little more customized and
you can implement item animator directly
or implement simple item animator or you
can subclass so what we did in the demo
you're about to see is we subclass off
of default item animator and then just
overrode the specific capabilities that
we wanted so there's a lot of things
that you can lean on there so that you
don't have to actually do everything so
there's an important step about
recording the pre and post layout
information chances are if you're doing
custom animations you may want more
information than the system records by
default by default that says what was
the view that was changing here and what
was the bout what were the bounds of
that view so then it knows basically how
big it was and where it came from before
and after and it can create some simple
animations based on that information but
if you're animating custom content in
your view holder then maybe you want
more information recorded before and
after it's worth pointing out that if
anybody's taken a look at the
transitions or the activity transitions
api's this is very similar to that it's
the idea that I need to record a bunch
of information then layout is going to
run then I'm going to record information
for the same input
different views and then we're going to
compare them and run appropriate
animations so we record that stuff
before and after and then you're going
to override you're going to choose which
methods to override so you can animate
the appearance or disappearance for
things that are appearing or going away
whether they're moving or not you're
going to animate persistence which is
the things that don't move as well as
the things that move on the screen but
basically are their before and after
layout runs and then you're going to
animate change when the actual contents
in items change and all of these as I
said these have standards
implementations in default item animator
but then you can choose to override and
do something custom if you want and then
an important point is that when you're
done with your animation on any
particular view holder you have to call
dispatch animation finished there's a
little bit of state that's being tracked
in some situations that we need to know
when to get rid of so a good example you
alluded to this before is if you remove
a view and then we're going to animate
it we're going to fade that view out we
actually take that view when we add it
into the view group so that it can exist
so that we can actually fade it out
right you're removed it from the
recycler view but we added it in is kind
of a hidden view in the view group just
for the purposes of running the
animation well we need to know when the
animation is done so that we can remove
it then there's actually like one common
bug we people see where they play with
this recycle we can't which is probably
unfortunately and then they see these
shallow views on the UI because layout
major doesn't see them so that measure
lays out everything works fine but
there's one of those views that was
animating and got stuck - this is when
the proper API is are not called back or
you are mocking up with in terms of
recycler view so keep that in mind
and finally there's there's an item if
you want to customize the change
animation in particular there's new
api's that came out in movies at twenty
three point one twenty three point one
point one swimming three one zero okay
one zero support labor release a few
weeks ago with new change animation
api's and it gives us the ability to not
recycle or create a new view holder
sorry to recycle and not create a new
view holder and we can pass it back to
you this avoids expensive potentially
pensive things like layout or just
creating all these objects on your
behalf
so now instead of simply cross-fading
views for different view holders we can
actually hand you back the same thing
and then you can do a totally custom
animation potentially with lower
overhead okay so let's take a look at a
demo fantastic demo I bet I wrote this
isn't this beautiful
okay so we have a simple recycler view
here you see me flinging you see me
flinging back there's a linear layout
with a background color on it there's a
textview in the middle the background
color determines the value of the
textview is really complicated okay so
some of the elements here is standard
recycler view standard default item
animator you haven't seen the animations
yet so that doesn't mean anything
standard linear layout manager with one
caveat that I wanted to disable
predictive animations so that we could
talk about some of the artifacts that
you'll see if you do not have predictive
animations enabled but linear layout
manager actually has them enabled by
default so yay all right so there's a
simple view holder here it's just
retaining information about the text
view and they linear layout so that even
get those later and set the color and
the text appropriately or even animate
those values a simple adapter so we have
this adapter we're going to be called to
bind the view holder with the
appropriate information we have this you
know database very complicated
architecture here we have a list of
colors here and we're to bind the
background color of the container and
the text in the text view appropriately
and then we're going to be called to
create a view holder we inflate this
resource we're going to set a click
listener because that's how I determine
like where these things are going to be
added and deleted in this awesome demo
that we're working through right now and
that's really about it in the basic
recycler view and then we're just going
to get some default behavior for the
delete in the add animations so we can
see the delete here you can see the the
touch point the little white circle
we're clicking on items there and we're
deleting those and we fade the thing out
that got deleted we shift stuff up that
got moved in the recycler view before
and after and then we fade in a new item
at the bottom the delete operation is
very simpler simple we remove it from
the list that we had
the appropriate position there and then
we do a notify item removed it's
important to tell recyclerview the thing
that happened don't you say well
something changed the more information
you give us about the specific range the
specific item the specific action the
better able we are going to be to
actually take advantage of that and give
you a richer experience if you just say
something changed and we don't have
stable IDs and can't determine what
those things are that changed you're
probably not going to get the rich
animations and interaction that you want
okay so let's take a look at add
animations once again we're going to
click an item there and then we're going
to add one into the middle of the list
we're going to fade the thing out at the
bottom that's going away we're going to
shift some sting things on the screen
then we're going to fade in the new item
they're decent animations but I think we
can do better this is very similar to
the delete thing where instead of
calling notify delete we do a notify
item inserted after we've added the
color into the list all right so here
are the artifacts that I was talking
about so you can sort of see these
delete and add operations again and you
can see that instead of like this is
supposed to be a contiguous list right
you're basically breaking the user's
mental model they think there's a list
but then why is this thing why is that
they're that weird janky thing at the
bottom where things are fading in and
out now it doesn't look like a list it
just looks like a jumble of items there
right so that's the thing that we want
to get around with predictive animations
so if we take a look at predictive
animations for the fade case you can see
that now when items go away they move
off the screen very logically into the
position that they're still occupying
within the virtual list
same thing with delete when items come
in from off screen they're moving in in
a very predictable manner that matches
what the user thinks about this list
structure so some code to enable this
first of all here's my awesome linear
layout manager custom class where it
basically just enables or disables
predictive animations just for the
purposes of running the show demo boosts
or suit yeah we're going to open source
just that one snippet of code
that's really the most interesting bit
in the entire demo we're looking into
open sourcing the rest of it but that's
the one that I really want to get out
there maybe we can write an article on
my blog about that medium.com will write
an article about that snippet check
there
okay so default change animations you
can see as we click it you get a
crossfade right the we're doing a
crossfade of the background color as
well as the text everything all at the
same time basically we have the old view
we have the new view and we simply do an
alpha crossfade between them it's decent
but maybe we can make that a little more
interesting and that's with the standard
item default item animator so with a
custom item animator we've got a little
bit something more interesting going on
so instead of cross fading between these
two views we're actually treating the
entire view hierarchy in there the
linear layout and the textview
separately and doing different things
with them
so the background color is fading to
black and then back up to the new color
and the text is rotating out of place
and then with the new value rotating
into place so how do we do that first of
all we say that we can reuse the view
holder because I don't want to create a
new one I simply want to animate the
items that are in the existing view
holder that we already have and then we
we extend default item animator
specifically to customize the change
animation so here we've got the get item
holder info this is a data structure
where we cache the information that
we're going to retain before and after
so that we know the values that we
actually need to animate before and
after and then this is going to be
called by both the pre layout record
operation as well as the post layout
record so basically when you when you
customize this stuff we're going to call
your code and say okay record whatever
you want before and now layout is run
record whatever you want after and then
your animation calls are going to be
called with those data structures so
that you can then take that information
that you recorded earlier and do
something with it so here we override
the animate change method and you can
see in the the method parameters we've
got the holder the old holder in the new
holder which in this case is actually
going to be the same view holder
information and we have the pre info in
the post info so that's the data
structures that we filled in ourselves
when we were called
for and after and then let's see how
this works so we create some animations
here we have one animation that does
have fade to black from the old color
and then fade from black into the new
color and we structure that inside an
animator set and sequence those to run
one after the other and then the text
rotation is on the textview itself so
we're going to do a rotation of zero to
90 to rotate it so that it's
perpendicular to the viewer and then we
swap the text out we'll see on the next
slide and then we animate the text back
into place with the new value of it and
again we run those sequentially animator
set run one run the other and we're done
I'm cutting out a little bit of code
there's some interpolators in there but
I just wanted to get the the high-level
view what's going on there and then we
add a listener on the animation so that
we swap the text appropriately so we're
going to use the old text so we've
already run layout right and our reused
view holder has the new text in it well
that's not going to make any sense if
we're trying to rotate the old text out
so when the animation starts we
substitute that with the old text and
then we run that half an animation to
rotate it out of view so the viewer
can't see it anymore then we swap in the
value of the new text and we rotate it
into place change animations and now we
put all the stuff together we create an
animator sets and we add them all
together and then most important we call
we call dispatch animation finished so
that the recycler view can get rid of
any state that it retained for these
things along the way and then we're off
and running okay so on the previous one
if you actually clicked on an item that
was animating you'd get some kind of
janky effects because you'd be in the
middle of an animation and then a new
animation would start and they both be
running at the same time or maybe you
could cancel one but you would get some
discontinuous behavior so what I really
wanted was if the user just continuously
clicks on these things you make that
transition to the new animation as
smooth as possible so you can see we're
doing that on the right there we're
clicking on this thing and it looks
mostly good if if they click during the
second half well there's I mean there's
a little too much information so we are
swapping the text along the way but
we're making the color transition as
smooth as possible so how do we do that
first of all we need to cache the
running animations we're going to need
to retain information about what's
actually running on
each item so we can get that information
later so we're going to cast this in
this little data structure and then
we're going to check it when we're told
to animate a change we're going to say
well are there any animations currently
running on this thing if there are let's
record some information about that are
we in the first half the animation or
the second half the animation and how
far are we in those animations and then
we're going to seek the new animation so
we're going to take all that information
from what used to be running and then
seek in the new animations that we
created from the previous code that we
saw before so that if you're halfway
through or quarter the way through that
first half an animation we're going to
seek a quarter of the way through the
new animation so it's going to start at
exactly the same place that the old one
left off and then we're going to cast
the new animators when we're done
because we need to provide that
information for the next interruption
that occurs and that was it thanks yet
to us they were lovely meet I wish I saw
them before I think that but that we
have okay so we wanted to touch base on
like some important things about
recycling we that we think you should
know about so no update means no on mind
this is one problem and people
transition from this view and commit the
same expectations this psycho view is
different so if you don't tell that an
item has been updated we are not going
to rebind it how the update and item use
so for example if you say item move the
item only move like I have no idea you
are displaying a roll number there
because you didn't tell me item exchange
so we will just move it we are not going
to tell to the adapter why do we do this
because not calling on mind means we are
not relating anything if we don't
invalidate anything Cash's are valid and
kittens are happy it's important so
another another mistake I always see is
that making this you cannot make
position final in own mind cause this is
this goes back to the same example in
the previous slide because just because
an item move doesn't mean we are going
to rebind it so if you use that position
in an example like this like in a click
listener you are doing it wrong
so for we can easily crash this code by
something like this you bind it tight
and position five you move it then call
unclick now you remove the wrong item
from that up there so how do we solve
this oops let's all come here come here
come here
one more time okay yes this is how we
solve it there's a gate adapter position
in the holder which will always give you
the up-to-date adapter position for a
holder so if you cannot use that
position is better to create that click
listener when you create a VM holder so
it's much better to use the crate view
holder to add your callback so that you
don't keep creating any object every
time the wave is rebounds and this know
position check is also important because
in a case where an item is deleted but
uses quick enough to click on that item
before it is removed from the UI you may
you also receive the callback because
the real view so you should always check
for no position another error about the
new API as we introduced is this item
payload so when you change an item you
could say white change for example I can
say this item this position change
because the like maybe you liked it or
your stop liking it the cool part about
this a pay is there's another on byte
method which receives a list of payloads
and such the payload is empty you just
run the regular on by but if the
payloads is not empty this means we are
reusing the same beholder so you know
that that we older was representing the
same item before a change came for this
particular reason so the only thing so
say it's the like update the only thing
you have to do is change that button
because you know the rest of the view
older is valid and the same payload
deformations also pass to your item
animator where you can use to decide all
the like change I'm going to animate the
heart so this is another confusion
recyclerview where what doesn't adapter
position means a layout position like I
can be that's only one position and we
did it it was wrong so
see this example where we want your
items the AP stands for adapter position
LP layout position they're all the same
it matches then the adapter says I move
the item and position to item at
position 5 so now if you look at it the
items their adapter position doesn't
match their layout positions recycle we
mostly say if you try to call the
adapter try to get the adapter position
on that field it will tell you that 5 so
you can safely access your adapter it's
just we did run a layout yet so when the
layout runs items go to their correct
positions and these are sync again so
it's right so if you for example in any
event you try to get the wheel a ball
the other one then you would like to use
layout position because that's what the
user is see at that moment but if you
want to access the adapter remove or
modify use the adapter position so how
do we think we have seen a lot is what
we call my recycle calls on create that
means it needs a new view holder so it's
a common mistake oh I have a header view
holder if recycle asks for it let me
just cache and return it it told you to
create not to return the existing one it
will use it if it goes right so you
cannot do this you need to be creating
any view holders or get it from some
other pool that recycle if doesn't know
about so example so recycle pulls
upgrade we can reuse the views among
different recycle views even in your own
components so let me create this one
giant pool for all of my application so
I don't create leaves again yeah
performance no you cannot do this either
because if you do this
first you are going to leak the context
these views are inflated per their
context they get the styles they inherit
a bunch of stuff
so again if you leave the activity the
we will keep reference to the context
that will to the activity everything
will leak your app will crash the second
problem is the ecosystems because the
context may change between activities
they may be loaded with different styles
with different team so you cannot do
this you need to create a pool per
activity contacts okay so okay this is
another problem we've been seeing where
people adapt recycle view if it receives
a change animation or background try be
generally you cannot do this you need to
update your adapter on the main thread
but people are clever what they do is
they updated contacts on a background
thread that notify the recycle view on I
on the main thread you cannot fool
recycling if there's a I mean if that
was the if that was the proper solution
we would do it right like so just
reiterate that so it's not the problem
the problem is while recycle is
calculating a layout you cannot suddenly
say ah I just moved item three oh wait I
was binding it like what APIs you cannot
do this you have to update the adapter
or main threat and tell recycling in
soliciting you updated tell right those
metal singer adapter well every time its
contents are updated it tells a recycler
we've yeah oh my god
we actually we actually finished in time
so I did want to point out we will open
source the real demo we just have to
figure out how so check our feeds here
if you want to those are the wrong links
for the dev summit at the bottom my
folks don't ignore the ones on the lower
right they're wrong
but check our Twitter G+ feeds and we'll
post something when we open source the
demo we have two minutes and 50 seconds
for questions yes
oh oh there's a Mike diamond too sweet
for Mike right and we're out of time
sorry so just want to know compare with
the list of year is there any
performance impact on the recyclerview
compared to list view is there any
performance impact I would say hopefully
it's all positive some of the stuff that
you alluded to like not calling on bind
because we have more information about
this stuff
we also because we know the specific
items and actions and ranges that are
being changed we can do things more
optimally our caches more intelligent I
think you have the biggest UI
performance improvement comes from not
calling your mind so if you dispatch
propria doctor updates you'll probably
gain performance of course the psycho
who runs more animations handles more
cases so there's a cost of them as well
but I mean you want those animations
probably so you you better use
recyclerview
important parties dispatch proper
adapter updates so thank you thanks
another yes oh like no yes whoo ah he
was waiting I'll gonna be first okay
in your demo use um just show the second
click listener for every item on never
view with multi-touch screens right now
every item will be clicked
simultaneously if you click like
multiple items any of your suggestions
to prevent multi clicks on recyclerview
so actually the multi click wouldn't be
an issue in general like it's pretty
robust it's just going to execute all of
them independently I don't know what why
multi-touch would have an impact on that
yeah I'm a shoe for Anderson Zoo it's
just separate click events yes in terms
on the ListView we had like on item
selected so as long as one item will be
notified that it's selected other one is
not going to be a lock clicked at this
moment of time these were this is
totally different these were just click
listeners there was nothing about
selection or act
items or anything these were I mean
maybe you're asking a question that I'm
not answering and that's very convenient
of me but you got that through all the
time but I think of course there was one
other person that a question then that's
all we got time for hi I'm in developer
I'm in professor Cho I not I don't know
it's exactly a feedback or a question to
me in cycling it very reject compared to
an iOS table view and etc we have to
write a lot of code to me it happens and
I teach coding to to my students and
it's a hard job to them to make a simple
recyclerview
and now you have the data biting so you
you have some things to write less code
to make a recyclerview something like it
and feature to make our happen all work
building recyclerview better or more per
noi the people that wrote recyclerview
had anything to do with the people that
wrote data binding cohesiveness okay so
what I so we're trying to solve a
problem with recycle which was mainly
animations and the ListView kind of
reaches limits on how much we can flex
it start to break down so the main focus
on recycle is to enable you to do weird
stuff and it right now it requires more
code because we are not focusing on
making it easy they are trying to enable
it after a while the API like we just
change the animation API to enable a
bunch of stuff once the API is become
more stable we are going to provide more
components on top of recyclable but they
stopped our focus today first get the
architecture right and get everything
simpler and not get us into the ListView
situation where it works but it's
terribly fragile the architecture is not
very flexible that was the whole point
with recyclerview I think that's more
than the time that we had thank you
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>