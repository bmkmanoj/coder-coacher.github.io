<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>DevBytes: Play Games on iOS Lesson 1.3 | Coder Coacher - Coaching Coders</title><meta content="DevBytes: Play Games on iOS Lesson 1.3 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>DevBytes: Play Games on iOS Lesson 1.3</b></h2><h5 class="post__date">2013-09-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LpffXEr4GJw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now before we add any kind of sign in
button to our application let's take a
moment to understand what's going on
underneath the hood when the user signs
in and that means it's time for dented
Anna our introduction to OAuth 2 point 0
now if you feel like you're already an
expert in this stuff you know it like
the back your hand feel free to skip the
rest of this video but you must be some
kind of crazy genius because frankly I
think this whole topic is kind of
complicated you could write a whole book
on it come to think of it this guy did
and you should read it if you want a
more thorough understanding of Watts 2
point 0 and that does mean for the
purposes of fitting this entire topic
into a 10 to 15-minute YouTube video I'm
going to be oversimplifying this thing
in places in fact probably to the point
where some bits maybe aren't entirely
accurate also I should probably make
this clear I'm no expert here I just
happen to be able to talk to people who
really are experts and then hopefully I
can pass that information on to you but
that said this should be enough for you
to have a general understanding of
what's going on underneath the hood
while all the nitty-gritty details of
OAuth 2 point 0 are going to be hidden
from you by the libraries we provide I
always think it's just kind of good
practice to have a general understanding
of what some libraries doing for you
behind the scenes when you're calling
any of these you know mysterious
functions but if you do notice anything
that just seems outright wrong please
let me know in the comments I do read
them I might even respond so with that
disclaimer out of the way let's get into
our presentation so the analogy I
frequently here with OAuth 2 point 0 and
it's one that I really like is that it's
kind of like dealing with the system of
valet keys if I have a valet key for a
car it probably lets the valet say
unlock the doors and start the engine
but maybe it doesn't let them open the
trunk so you can still keep your
valuables or your bodies or what have
you in there if you happen to have a
very fancy car which I do not these
valet keys might also prevent you from
say driving over a certain speed or
taking it off any sweet jumps I mean
think about how different Ferris
Bueller's Day Off might have been if
Cameron had just had a valet key that he
could have given to the parking
attendants right totally different movie
in
dently in the world of OAuth 2 point 0
these valley keys also have the special
ability to self-destruct in a certain
amount of time so this ballet better
parked my car in the next 60 minutes or
he's not going to be able to do anything
with it the bright side is that if my
valet happens to lose the key in the
parking lot somewhere there's only a
limited window in which someone could
find it and steal my car with it by the
way these cues are generally referred to
as access tokens they're also sometimes
called bearer tokens meaning that the
all the powers of this key are granted
to the owner or bearer of the key
technically speaking I guess not all
bearer tokens are access tokens but in
the world of OAuth 2 point 0 they
usually are so for the purposes of our
oversimplified tutorial I'm going to use
these two phrases interchangeably
throughout these lessons so one of these
keys look like an application context
well you might have a valet key that
lets an application say view the
contents of a Google Drive folder but
maybe not delete files there in the case
of play games our valet key gives an
application access to achievements
leaderboards and lets them view some
basic user info but when for instance
let that application view the users
Google Drive folder or say send gmail on
their behalf or use any other Google
services by the way these specific
abilities that these valet keys have are
referred to as scopes and you'll hear
that term used throughout the rest of
this video so what does it look like if
you're trying to sign into an
application using one of these valet
keys well maybe you can think of it a
little something like this let's say I
want to get into a club but the bouncer
won't let me in until we see some ID
well I might say to the bouncer tell you
what mr. bouncer i'm going to give you
this special valet key this key will let
you open the doors and the glove
compartment of my car it won't let you
drive my car won't let you open the
trunk but you can get into the glove
compartment and there you can find say
my registration which will tell you my
name and my date of birth and maybe then
you'll let me in so let's look at this
again in a non nightclub setting let's
say I've got my fantastic new angry
fruit game that I've just added a
sign-in button to when the user clicks
that sign-in button my application is
going to say hi google
this is angry fruit the game please give
me a valet key or an access key that
lets me see basic user info submit high
scores and set achievement progress the
first thing Google will do is present a
dialogue box to the user saying hey user
this is the information that this angry
fruit app is asking for are you cool
with this let's assume the user says yes
at this point Google will then give our
application of al a key and say here you
go have fun at this point by the way our
application still doesn't know who this
user is we just have a valet key that we
know belongs to this user but what we
can then do is pin Google services and
say hi I have this user's valet key can
you please send me the user ID that's
associated with it the first thing
Google will do is verify that the valet
key is valid that it has the proper
scope that allows my application to see
the users ID and that it hasn't expired
assuming that's all cool it'll say sure
thing here's the users ID number at that
point I have an ID number from an
authoritative service that I trust in
this case Google and I can proceed
without ever having to ask my user to
set up yet another username and password
that I need to hire a security team to
watch over so let's take a look at this
request again maybe a little closer to
the code here's our request hi google
this is angry fruit please give me a key
with these scopes and you'll notice I've
added another bit of information which
is when you're all done please send this
info to this URL that I'm providing to
you now what does this call actually
look like well this part here hi google
or perhaps more accurately hi Google
OAuth 2 point 0 servers is equivalent to
redirecting the user to a URL that
points here to accounts google com now
this part where we say this is angry
fruit is equivalent to adding a client
ID to this request this is a unique ID
that identifies our application I want a
key that lets me get basic user info set
leaderboards and achievements is
equivalent to adding this particular
scope to our request you'll notice that
our scope looks like URL right it looks
like a web page I could access there's
actually nothing special about scopes
that requires it takes the form of a URL
in fact if you've done any work on
facebook I've
their scopes look like just plain old
text strings that say things like email
or user underscore info I think Google
decided to make their scopes look more
like URLs partly because it makes it
easier to break things up hierarchically
you know different products can have
different directories and I suppose at
some point in the future we could set up
a web page for each of these scopes that
say gives you additional information
about them but again there's no rule
that says these have to look like URLs
it's just something we chose to do
anyway the final part of this request
which is to send the info back to a
particular page is equivalent to adding
a redirect URI to the end of our request
so this big URL here at the bottom this
is actually the URL that we would send
this user to and it looks a little
something like this it's the OAuth 2
point 0 dialogue now assuming at this
point the user clicks accept this page
would take a look at this redirect URI
and it would redirect the user back to a
page beginning with that URI but then
we'd also need to send across the access
token and so we can send that along as a
get parameter this uri by the way will
correspond or hopefully should
correspond to a page that i've created
on my angry fruit website it can grab
this access token information either
through JavaScript or maybe it's a
dynamic server page and then I can start
making calls to google services using
this access token and we're all done
right wrong turns out I just lied to you
and why did I do that why did I break
this bond of trust we've been forming
over the last seven minutes well because
I want to demonstrate a security issue
to you now imagine that this is my
redirect URI it's redirecting to a page
that's not using SSL and our user
assigning in from you know Joe's
internet cafe in laundromat on some
opening wireless access point somewhere
but it also turns out that inside Joe's
internet cafe is our hacker man I don't
know why he's wearing a ski mask and
gloves it seems like that might make him
kind of conspicuous but I guess that's
how he rolls now this redirect itself is
still being sent securely all
communication with google is being done
over SSL but since our users browser
needs to access example.com it might do
that over a plain old in secure
connection and our conspicuously dress
tacker man along with say anybody else
that decides to view our servers web
blogs
see this access token right there in the
open and suddenly they can start
masquerading as our player because they
now have a bearer token belonging to
that user and they can wreak all sorts
of havoc so there are a couple of
alternative methods that we can look at
instead the first way and probably the
most common is to send a single use code
instead of an access code token now this
code can be sent down to our server at
example calm and then our server makes a
separate call to Google to exchange this
code for a real access token and it does
this by sending along the code along
with the client ID and a client secret
that exists only on our server now
assuming all this information checks out
google servers can then send back an
access token to our servers at
example.com our server can then make its
own request to the Google Play service
like getting the users ID and then it
can send that information back to the
client which also gives us a nice little
benefit of not needing to keep the
access token which is a sensitive bit of
information over on the client it's just
one less place where our access token
needs to live but more importantly even
if a hacker dude is able to intercept
the code he can't do anything with it
because a he doesn't have our client
secret remember that exists only on our
server and be these codes are only valid
once after the redeemed they can't be
used again so he's pretty much out of
luck sorry mr. hacker but Todd you're
saying what if I'm a JavaScript engineer
I don't want to spend a lot of time
doing server-side code can I just do
this whole exchange of code for an
access token thing directly on the
client well the answer is no and it's
because remember in order to exchange a
code for an access token we need to pass
along that client secret and that client
secret is supposed to remain well secret
and if you were to keep a copy of it
stored as a JavaScript variable
somewhere just about anybody with a copy
of chrome developer tools could dig it
out luckily it turns out there's another
way to send off access tokens to a
client if you don't want to do a lot of
server-side logic and that's sending it
as a URL fragment see how our ? has been
replaced with a little hash tag you're
probably used to seeing these to you
know jump to a particular section of a
web page but it turns out they're also
useful in situations
like this you see URL fragments don't
get sent across in web requests so when
our users browser goes out to
example.com the request doesn't include
any type of access token information but
in the page that we get back we can run
some JavaScript that analyzes the full
URL including that fragment and can
extract the access token information
from there again leaving our
conspicuously dressed hacker man out in
the cold that said if you are going to
be using this approach you should do
this using HTTPS otherwise a very
sophisticated hacker probably one not
wearing a ski mask might be able to do
something malicious like serve up your
page with some modified JavaScript that
could read the access token and do bad
things with it or send it somewhere and
that's probably not a good thing so in a
situation like this you should always
use SSL in fact use it wherever you can
it's just a good idea as long as we're
talking about security by the way let's
bring up one other situation let's say
that my game is incredibly successful
and my competitors over its candy games
are so jealous that they want to
sabotage my game and so they create
their own game and have their own
sign-in button and their sign-in button
creates a URL that looks a little
something like this this looks like a
pretty normal Oh auth dialogue request
accept that you'll notice that it's
using angry fruits client ID but asking
the redirect URI to go to scam me games
now if Google were to blindly trust that
information it would bring up an oauth2
dialog box the user would probably click
accept and then it would send that
information on to scam me gamescom and
if we're using our send the access token
as a URL fragment approach scammy games
would be able to grab the users access
token at that point it could trick my
angry fruit game into pretending they
were my unsuspecting player and recall
sorts of havoc with their game because
it now has a valid angry fruit bearer
token belonging to our poor unsuspecting
player and we don't want that to happen
so instead what we do is google keeps a
database of all client IDs along with
all redirect URIs that are allowed to be
associated with this client ID so in
this case my angry fruit game has a
client ID and we've set up a redirect
URI that point
to example.com / o auth to call back so
now when scammy games makes this request
Google will notice that it's got a
client ID that matches something in our
database but it will also notice that
the redirect URI does not match and it
will deny this request and scammy games
will not be able to grab a valid angry
fruit access token so at this point I
know we've been talking a lot about web
games but I know that we're making an
iOS game so what does this look like in
the mobile world it's pretty similar
except that instead of a request that
looks like this we're going to be on a
mobile device and we're going to ask the
redirect URI 2.2 calm example AF colon
slash 0 f to call back now you'll notice
this no longer looks like a web page but
this is still a valid address that is
pointing to my angry fruit game on the
iphone and that's because this comm
example dot if' is associated with my
bundle identifier in my application and
I'll be registering with the system that
if you open up a URI that starts with
com example AF instead of say HTTP or
male 2 or ftp that should go to my
application google is still going to
keep a database of client IDs and
authorize redirects and this authorized
redirect is going to begin with a bundle
identifier instead of looking like a web
address beginning with HTTP the other
difference and one that might surprise
you is that you might expect that since
we're on a client only application we'd
be doing the past the access token as a
URL fragment trick and indeed in many
situations on mobile devices this is
what happens but in our case we don't do
that we're actually going to pass in a
single use code but wait you're saying
we don't want to pass a single use code
right because in order to exchange that
we need to pass along our client secret
and you told us that it's a really bad
idea to store a client secret on a
client device what's up with that well
it turns out that when we exchange a
code for a token using a client ID that
we know is associated with a mobile
device we actually don't need to use the
client secret this might seem like we're
losing a little bit of security right
since anybody that intercepts our code
might be able to
use it but you have to remember that now
we're redirecting to another local
application on the device instead of say
another web page out there in the world
and that's considerably more secure so
this all generally works out in our
favor and we're able to get an access
token back from our servers so now that
we hopefully understand a little more
about the OAuth 2 point 0 process and
this tutorial hasn't confused you more
than it's helped let's get started by
creating our very own client ID and
we'll be doing that in the next lesson
haha</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>