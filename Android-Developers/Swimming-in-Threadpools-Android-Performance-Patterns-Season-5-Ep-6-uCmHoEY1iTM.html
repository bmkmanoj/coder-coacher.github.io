<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Swimming in Threadpools. (Android Performance Patterns Season 5, Ep. 6) | Coder Coacher - Coaching Coders</title><meta content="Swimming in Threadpools. (Android Performance Patterns Season 5, Ep. 6) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Swimming in Threadpools. (Android Performance Patterns Season 5, Ep. 6)</b></h2><h5 class="post__date">2016-03-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uCmHoEY1iTM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's be honest you're an awesome
engineer with an awesome app and you are
using threading to the max sadly though
managing all those individual threads
and assigning work between them is
causing you to lose your hair my name is
Colt McAnlis and please don't join the
bald Club instead use the thread pools
class which is an ideal primitive for
breaking up lots of work into little
buckets see historically it was
commonplace that applications would use
a dedicated thread model that is one
thread that only deals with database
rights while a separate thread only
handles streaming of music and a third
one only handles networking these setups
are okay because the amount of work per
thread isn't that large and it's okay to
handle this work in sequential order but
there reaches a point where this model
starts to fall over say for example
you've got 40 bitmaps to decode and each
decode takes like four milliseconds or
something and putting all of this work
on a single dedicated thread is a bad
idea since it'll take 80 milliseconds
total to get all that work done in a
sequential fashion on the other hand if
you created 10 threads and let each one
decode four bitmaps then you'd end up
only taking 16 milliseconds total but
then of course you run into the problem
of how to properly pass the workaround
between those threads schedule that work
and then managing of those threads and
before you start stressing out about
writing all that code don't worry this
is exactly what thread pool executors
primitive is for basically this class
will just let you spin up a number of
threads and toss blocks of work to
execute on it thread pool executor
handles all of the heavy lifting of
spinning up the threads load balancing
work across those threads and even
killing those threads when they have
been idle for a while basically it
handles all the heavy lifting of super
parallel processing on your behalf all
you have to do is split up the work but
there's a small caveat here how many
threads should your thread pool have I
mean technically speaking you have the
ability to create as many threads as you
want but that's not ideal see CPUs can
only execute a certain number of threads
in parallel once you get above that
number then the CPU has to start
deciding which threads get the next free
block of processor time based on how
important they are which means that if
you keep eventually adding threads
you'll hit a break-even point where your
computation isn't getting any faster
even though the number of threads that
you have
has increased significantly and it's
also important to note that each of
these threads aren't free each thread
cost you about 64k of memory and minimum
and that adds up quickly especially in
situations where the call stacks can
start growing pretty large as such your
app needs to find a sweet spot between
the number of cores and the point of
diminishing return with the number of
threads thankfully once again the thread
pool executors class has got you covered
when creating your thread pool you can
specify the number of initial threads
and the number of maximum threads as the
workload in the thread pool changes
it'll scale the number of alive threads
to match oh and a quick note the value
returned from get available processors
may not reflect the number of physical
cores in the device see some devices
have CPUs that will deactivate one or
more cores depending on the system load
to save battery so if your device has
two CPUs but one of them is asleep this
value could return one and of course
thread pools won't solve all of your
threading problems as mentioned earlier
unless you're dealing with lots and lots
of work packets all the time this
thing's kind of overkill it's best use
things like handler threads or async
task loader for specific types of work
blocks and only throw the massive
computing problems at the thread pool
and for you power users out there
remember that renderscript might be a
better alternative to large-scale
parallel work on android devices but
that's a whole separate set of videos
that we haven't gotten into yet and
don't forget that systrace is an
amazingly powerful tool that lets you
visualize how work is flowing through
the threads in your application it's a
great way to validate that things are
working as intended and also see all the
other crazy threads that are being
worked on by other parts of your app and
that's the trick with performance isn't
it I mean you can make assumptions but
things don't always work the way you
think which is why you need to check out
the rest of the Android performance
patterns videos and don't forget to join
our Google+ community to ask a lot of
hard threading questions as well so keep
calm profile your code and always
remember perf matters</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>