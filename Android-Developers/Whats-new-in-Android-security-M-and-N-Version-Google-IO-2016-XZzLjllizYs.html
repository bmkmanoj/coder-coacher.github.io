<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What's new in Android security (M and N Version) - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="What's new in Android security (M and N Version) - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What's new in Android security (M and N Version) - Google I/O 2016</b></h2><h5 class="post__date">2016-05-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XZzLjllizYs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">they pointed at me and the clock started
moving we have 44 minutes and 56 seconds
to talk about security good morning it's
9:00 a.m. I caught the bus down from San
Francisco at 6:00 a.m. this morning to
clean up some last little details and my
slides on the bus does everybody find
coffee and breakfasts if not go find it
come back we'll be here for a little bit
my name is Adrian Ludwig I head up the
Android security team here at Google or
at least you know three blocks over that
way at Google we're responsible for the
security the Android platform the
platform is a broad diverse growing kind
of incredible thing as many of you know
so the scope of what we do is also broad
diverse and growing you saw a couple
things that were mentioned yesterday in
the keynote that are new features that
were introduced in Android n that we've
been working with the rest of the
Android team to enable things like file
based encryption media server hardening
and automatic updates these are some of
the core changes that have been
introduced in Android in those of course
build on a security model that extends
deep into the platform right it's not
just a feature here a feature there it's
about how we have segmented applications
how we have isolated capabilities in the
platform and the underlying technologies
that we're using to deliver those
security features it's not limited just
to Android itself though the work that
we do in securing the Android operating
system the Android platform and the
Android ecosystem extends to a broad
range of applications that we deliver
that we talk about as the Google
security services those also got a very
brief mention yesterday in the in the
keynote that I wanted to flag which is
that at present we're doing over a
billion scans per day we say checks
because non security people are more
comfortable to the idea of doing a
check-up than doing a scan but what
we're doing is looking at security
characteristics on the devices that are
out there in the world to make sure that
we're keeping them safe one of the
things that we look at is the number the
broad range of applications that have
been installed under these devices
so we checked over eight billion
applications every single day right to
give you a sense of the overall scope
one of the things that Dave wasn't able
to get into was what exactly these
things mean about three or four weeks
ago we published something called the
annual security year in review where we
went into a lot of the work that we've
been doing investing in these security
services making them more capable using
the technology that Google has in our
backend to deliver more and more
sophisticated analysis of applications
more and more sophisticated
understanding of what it is that's going
on in the Android ecosystem so we can
better protect users that 50 page
document included this diagram I'm not
going to go into a lot of detail here
but I wanted to emphasize that the vast
majority of our focus is on everything
that we can do to protect users so that
ranges from hardware updates and
hardware security to platform updates
and platform security features to
services as well and we're investing at
every layer in the stack to try to
protect users as best we can now for
today I'm gonna hone in on a handful of
specific new capabilities that were
introduced in Android em and Android n M
because let's be up you know realistic
it hasn't gotten to a point where has
broad-based adoption so it's not
terribly surprising if you haven't been
spending a lot of time thinking about
how to take advantage of the features
that were introduced in M I'm an Android
n because that's the new hotness or at
least it will be as soon as it begins to
roll out a couple of months from now so
I wanted to emphasize though that this
is just part of the overall sort of set
of capabilities that we have right we
want to build things for application
developers want to build things for
users and we want to build things for
device makers I think on the main stage
the focus was on users elsewhere in the
world we spend a lot of time talking
about device makers but today we're
gonna talk about what are the new things
that we're doing to make your life as an
application developer better on Android
M&amp;amp;M so these are some of the key
features I'm gonna talk about there are
seven of them up here I'm just gonna
walk through them one by one we'll talk
about what it is that was introduced
take a look at some source code so you
can understand how you might in court
printed into your application or your
development experience and then talk
about some of the best practices that
we've been thinking about for how we
think it is that you'd want to be
incorporating these technologies into
your application development right
pretty straightforward boom-boom-boom
move to the next one boom boom boom
right no fancy diagrams just a little
bit of code here and there so
permissions is the first thing we're
going to talk about you may remember or
you may know if you're running on
android m right now on Nexus device or
one of the other devices that started to
receive it that one of the major changes
in the user experience that was
introduced with marshmallow was runtime
permissions right
the idea that an application can defer
requesting the use of permissions until
it really needs them and that the user
has the ability to decide whether the
application gets that specific
permission or not right really
very fundamental change in the way that
applications are going to request access
to more sensitive capabilities on the
device introduced with marshmallow from
an application developer standpoint it's
a really powerful thing for you to think
about right it gives you the ability to
simplify the installation process for
your application because you don't have
to request all those permissions up
front it gives you the ability to
upgrade without having the user have to
confirm that that upgrade is necessary
for DAP locations being delivered
through for example through Google Play
because there's no increase in the
capabilities of the application in the
security model and so there's no need
for the user to affirm them right so
this can really accelerate the rate at
which your applications are being
upgraded if you take advantage of
runtime permissions on these newer
platforms and from my perspective when I
think about security one of the things I
worry about is making sure that users
understand what it is that's going on
and we found that runtime permissions
are fundamentally more understandable
for users right they give the
application developer the ability to
provide context and the user to
understand how that capability is going
to be associated with the application
that they're employing so what does it
look like it's pretty straightforward
the first thing that you want to do in
the context of your application is
invoke the local environment and check
self permission right do I already have
this permission if you don't then you
want to explain probably provide some
context to the user about
why it is that you're gonna request that
permission in this particular instance
it's a use of read contact so you might
say I want to send an email and it'll be
really nice if I could see who you're
already friends with inside your contact
environment or make a call or any number
of other types of functionality you
might want to expose if you do not have
the capability already then you're gonna
need to request it and there's a simple
API request permissions and you can go
ahead and make that request and at that
point you now have that permission or
not let's talk a little bit about some
of the best practices to make sure that
you actually get that permission because
that's one of the things that people are
concerned about with runtime permissions
is that they maybe don't always say yes
right so you're gonna need to consider
in the context of your application that
these are might say no and you're gonna
want to think about how it is that you
can increase the likelihood that the
user will say yes so one of the things
that we did is provide some design
guidelines those have been published you
can find them up on source or on
developer.android.com that describe some
of the best practices one of the most
important ones is to provide some
context for why it is that you're going
to do it so for example in the case of
SMS in the case of the hangouts
application explaining hey if you want
to receive SMS in the context of this
application we're gonna need to have
access to it and I'm going to request it
now then makes it possible for you to
request it and really increase the rate
at which users say ok make sense to me
go ahead and grant it within the context
of Google applications we found that
about 85% of the time users do say yes
that's better than the average that
we've seen for other applications that
are sort of broadly distribute on the
Android platform just to give you some
examples of how much better it is about
15 point eight percent of the time when
we prompt a user they say no that's
about 40 percent lower so for other
applications the failure rate on that
request is gonna be about 20 to 25
percent it's about 40 percent difference
between those if you ask too many times
and the user says no repeatedly
eventually after I think three times the
user has the option to say stop asking
me and so we found that the stop asking
me don't ever ask me again rate for
google applications about three percent
so effectively we prompt a couple of
times in order to
to the point where the users comfortable
with the application and we find about
97% of the time users accept the
permission asks that we're making so
those are some of the best practices
that you'll want to think about there's
another capability that we've been
expanding dramatically which is a
protection of key material cryptographic
keys specifically on Android so we'll
talk about the Android key store the key
store leverages hardware that exists on
the vast majority of Android devices as
a security practitioner it's always been
really interesting to me that most
devices literally about 80 to 90% of
devices have something called trust zone
on them they have a te that's been put
in place it was there to enable access
to DRM protected content but we've been
doing over the last several years is
making that available to you as an
application developer as a means for you
to protect the most sensitive
capabilities and keys in your device so
starting in in JVM r2 so almost four
years ago we began implementing API
after API up to the API as of Android L
the ability to use RSA elliptic elliptic
curve DSA so ECDSA symmetric algorithms
like AES and then also H max where those
keys are held inside of trust zone and
cannot be exposed to the kernel or to
anybody else on the device is one of the
core capabilities that we've been
enabled one of the really important
things to do is to transition from it
being on most devices to being on all
devices and so this became required as
of the Android end release so we'll be
gonna see from here on out all new
devices are going to definitely have it
onboard as it is right now the vast
majority of higher-end and mid-range
devices already have to store in place
so one of the new features that was
introduced with Android n is what we
call access station what we do with
that's a station is bake a key into the
firmware inside a trust soon so it's
possible for you to validate that this
is a legitimate piece of hardware you
can check that by creating a key and
then checking the cert chain to tie it
back to a piece of hardware that's gone
through cts testing and I'll sort of
talk through how it is that you can do
that in just a second
so here's an example of what that looks
like from a source code standpoint what
do you need to do well you need to start
off by creating a key pair so you create
an instance of Android key store in this
instance we're using a lipstick curve so
you specify that to your algorithm one
of the more interesting new capabilities
that was introduced actually in Android
M was the ability to say this key can
only be used if the user is recently
authenticated I'll talk more about that
in just a second but that's a really
powerful statement that you can make so
that you know that there's a real user
that's been interacting with the device
right now and that's been validated
inside a trust zone
so you can protect your your keys and
then the last thing that you can do is
you can actually get the certificate
chain associated with that key so that
key is one that has been bound to a
particular device and they can't move to
some other device and you can actually
confirm by looking at the certificate
chain that it's a device that
legitimately went through CTS testing
it's gone through that kind of
validation so we think this type of
capability is really important for
enhancing the trust in those devices
that have gone through the Google
validation process and our our valid
Android tested devices so some best
practices think for a moment whether
there's a case for you to be using
encryption in the context of your
application and if so then keystore is a
great place for you to be storing those
keys it's available it's very
straightforward and it has the advantage
of the key not being exposed in the
event of compromised of other things on
the device you can also use the key
starting with Android n as a mechanism
to validate that this is a legitimate
Android device and not one that's been
sort of created outside the
compatibility and so that gives you the
ability to do further validation of the
device I hinted at authentication so
let's talk a little bit about some of
the changes that have gone into
authentication recently so there's two
different goals that we're striving for
is we're enhancing authentication the
first one is well
let's be frank users don't like
authenticating right it's annoying right
I want to take out my device I want to
use it immediately and I want to have
access to my information and so when we
began looking into why it is that users
didn't have lock screens on the device
and why they didn't use what seems to be
sort of the most fundamental security
protection the answer is it just comes
up too often and almost half of Android
users have decided that they don't want
a secure lock screen so one of the
things that we're trying to do is find
ways to encourage that because if we get
to a point where the logging-in
mechanism is trustworthy where
authentication of the user at the time
they start interacting with the device
and you can do a lot more be a lot more
flexible in a set of applications that
you can provide so Android pay is a good
example where because users are
authenticated they can have access to up
to Android pay so we actually bind those
two ideas together so to make things
easier we introduce fingerprints that
was one of the things that was
introduced with Android am on Nexus
phones and an API for you to interact
with it as an application developer on
Nexus devices we've seen adoption of
secure lock screen go from about 50% to
over 90% on devices where fingerprint is
available because it's just so much
easier we've also made changes for those
devices that don't have access to
fingerprint for one reason or another
through things like smart lock right one
of the capabilities that smart lock
provides is what we call on-body
detection where we monitor how the
device is interacting with the
environment around them is it in their
pocket do we think it's still in control
of the individual who first unlocked it
the use of that alone can reduce the
frequency with which users need to
authenticate by over 50% we've seen that
you know in our experience so we've got
good progress on making authentication
easier for users so that's one of the
things that we're striving for the other
thing that we're trying to do is make
authentication stronger so there's some
changes there as well one of them was to
move to allow applications to tie their
secrets to authentication right so you
can make sure that your application will
only function if the user has a secure
lock screen and they have been recently
authenticated so that's an important
change that you can make
one of the types of things that an
application that worries about safe
financial systems or access to sensitive
data would want to do another thing that
we've done is to move the authentication
actually into trust soon so that even if
the overall operating system has been
compromised
there's no mechanism available for the
device to leak the credential the
fingerprint for example or the users
lock screen password into a place that
it could do an exhaust over the strength
of that credential so you want to think
about how to use authentication we've
provided some API so that it's possible
for you to directly invoke the
fingerprint api's and we've also
provided api's that allow you to sort of
control the user experience around them
right so you're not constrained and how
you would represent what it means to
authenticate this is again you get to
offer context for why it is that you're
requesting authentication we think
that's a really important part of the
application experience that you are
effectively in control over how it is
that you represent the user what you're
going to do so in this instance that UI
describing how fingerprint is taking
place is being drawn entirely by Google
Play they get to describe we're gonna do
this and here's how we're gonna use it
if they want to do that then you can do
that in your application as well just to
give a quick example very very
straightforward how you create a key in
this instance and then bind that to bind
that to a fingerprint in this instance
the thing that I wanted to highlight is
you're actually creating a callback a
wrap based on the key and you're only
going to do the decryption if the user
is successfully authenticated right so
you now know that the data associated
with your application that's been
wrapped in that key simply doesn't exist
and is not accessible until after the
user is authenticated I'll talk in a
couple of minutes about how we're doing
direct boot and it has a similar model
right where application data is not
available until the user has already
been authenticated so a couple of best
practices I think that there's a real
opportunity to use off bound keys to
drive both adoption of the use of
authentication on the lockscreen and a
secure lock screen and also to simplify
the way that the user is going to be
interacting with your application right
then you don't need to have a check for
PIN or password when a user comes into
your application no matter how sensitive
is because you know that they very
recently blown through that
authentication already at the lock
screen so I would definitely encourage
using that mechanism you can time-bound
it and say if they've logged in in the
last minute the last five minutes the
last ten minutes whatever is appropriate
for your application
to drive good security practices
consistent with your application the
other thing that I would encourage you
to do is certainly favor fingerprint you
know the evidence seems to be that a
fingerprint readers exist on a device
that's going to be the mechanism that
users are going to want to use so I
would encourage you to use that as your
mechanism to do binding of
authentication credentials to key
material inside of key store if that's
not available then falling back to doing
something like create confirm device
credential intent as a mean to bind to
whatever other secure lock screen they
have on the devices is a perfectly
reasonable fallback for those devices
where fingerprint isn't available so
we've covered a couple of features so
far we're gonna get now in sort of the
crypto section talk first about secure
networking and then get into secure
storage
it's amazing to me how often simple
changes can make a huge difference in
security right
we spent a minute thinking about users
and how many of them choose not to have
a lock screen because it's complicated
because it's difficult in the same way
we find that application developers
often choose not to use secure
networking because it's a little bit too
difficult so what we've been doing over
the last couple of releases is trying to
make that simpler one of the
complexities that we found is that
application developers just don't know
whether they're using secure traffic or
not a good example might be they've
incorporated an advertising library into
their application does that advertising
library use HTTP to request assets when
it sends up device identifiers or user
identifier x' in order to request those
advertisements that have been
personalized for that application do you
know so one of the features that was
introduced in android marshmallow was
the ability for an application to say
you know what I want to use clear text
traffic and conversely I don't think
that I need to use clear text traffic
right if you're an application like
Gmail you can say I know that all my
connections are going up to a Google
server and that's the one that's been
predicted and I can say oh I'm gonna not
use any clear text traffic if you're a
different application you need to go
through the process of evaluating
whether it's there so this is a feature
that was put in place to simplify
understanding whether your application
actually uses clear check traffic and to
give users visibility into whether you
think you use Kotex traffic so it's
really straightforward very easy to use
inside your manifests it's very simple
do you use clear text traffic no and
then API such as URL Kurt yeah HTTP URL
Connect where it's not using HTTP will
simply not work
so those api's that are known to be
insecure and transmitting user data
across the network simply no longer
function they'll return a security error
and you can bail out so that's great
except that it turns out most
applications do some stuff secure in
some stuff not secure so we knew that we
needed to provide more flexibility and
so that's one of the things that we
began
focusing on an Android n is how do we
have more granular controls while
recognizing that the granularity that's
existed in SSL and TLS stacks and the
SSL api's has been a source of
incredible complexity an incredible
difficulty in deployment and so what we
want to do with network security config
is make it really easy for you as an
application developer to know where
you're using secure transports and then
to control those transports in a way
that doesn't make your coding really
difficult so it's entirely decorative
and it's all in the manifest so let's
talk about some of the basic
capabilities well here's a really simple
one it turns out I don't use secure
traffic everywhere but I know that I use
it on secure example.com
and so I can use a domain config I set
it up where this domain is one that uses
secure traffic okay so it does use use
clear text traffic specifies it as false
and I don't make any claims about any
other domains that my application might
be interacting with so you can keep that
advertising library that otherwise would
have prevented you from being it
confident about the rest of the
functionality of your application so
that's the start of the types of things
that you'd want to be able to do another
thing that we found is that it's very
difficult to do debugging right we see
that in the context of Google on a
regular basis the way that we interact
with our debug infrastructure is
different from the way that we do we
interact with our release infrastructure
we have different key material on them
we might not come from a certificate
authority that's a well-known
certificate authority that's on all the
Android devices because it's just a test
infrastructure and you don't want to
have to pay for and maintain that sort
of complex or cost the SSL
infrastructure not that it's that costly
but you know that's the mindset of a lot
of developers and so one of the things
that we want to do is make it really
simple right because in the past the way
that developers have done this is
they've had to go through a lot of
custom code to change how SSL handling
took place inside the context of their
application so we're gonna do that all
in the manifest now with network
security config so that should make it
really really simple for you to test in
a way that's distinct from entirely
independent from your release
infrastructure but also not have to
write any custom code to do that so what
does it look like
here's a pretty simple way to do it
network security config you declare
debug overrides and you set a different
set of trust anchors when your
application is running in a debug
environment did you specify what those
trust anchors are you can include them
in your applications as is being done
here this is actually specifying they're
gonna be in your application and you now
know that when your application is no
longer in a debug build no change to
your code at all
you release it in release mode you ship
it and all of the code related to this
debug overrides is no longer gonna be
present inside the application really
straightforward you may want to do
things that are more sophisticated than
just domain level restrictions using the
built-in certificate authorities or
differentiating your debug hardware
debug infrastructure from your release
infrastructure so let's talk about that
for just a second here's a couple of
different ways that you can actually
limit the set of certificates that you
interact with without needing to write
your own SSL error handlers and SSL
certificate validation routines really
simple one these are domains for which
we are going to include the certificates
that are tied to those domains in our
application so we specify secured on
example.com CDN dot example.com and
these are apps these are search that are
actually gonna be directly in my app
right so don't rely on the system
certificates I don't need to go by a
certificate or validate with somebody
else my applications trust is contained
entirely inside of that application and
then I can connect out to that server
another thing that we often get asked
about is how do i do certificate pinning
certificate pinning in case you're not
familiar with the term is to identify a
specific certificate not a CA not a
certificate chain but a specific
certificate that you expect to be
associated with a particular web service
so one of the capabilities that we
introduced here is the ability to
specify a pin again directly in the
manifest right so you don't have to
manipulate the SSL code or do your own
certificate validation and you can very
quickly make a change to that if you'd
like to do so I would caution that
pinning
managing your own trusts can be a little
bit tricky and so we definitely
encourage you to use the built-ins but
we also want to make sure that you have
the flexibility to do things if you
really want to cause yourself a little
more grief than you otherwise had to do
so here's how I would describe that sort
of in bullet points on a slide there's a
bunch of changes that we made with
network security config and some best
practices that we think are appropriate
for nearly everyone a good example of
that is identifying what are the domains
that you expect all of the traffic on
those domains to be secure and actually
specify that say users clear text
traffic and set it to false so you can
make sure that you don't accidentally
send any insecure data over those
neighbors ideally we would like you to
do it for everything but we're not there
quite yet we realized that so this is
incremental and eventually we'll get to
a point where it can be done for
everything across the entire Android
ecosystem as we are pushing to do the
same across the broader web another
important change that was made was that
user installed certificates are no
longer trusted by default right the user
on the device has the ability to go in
add a certificate and previously have
the ability to then man-in-the-middle
traffic between your application and
your server infrastructure there's a lot
of reasons why they might want to do
that and there's a lot of reasons that
you might want to enable it in your
application as well on the other hand
we've thought and we found in
conversation with developers if the vast
majority of developers don't anticipate
that and if they're connecting to their
own infrastructure and to nowhere else
they don't see a particular reason to
enable that and so there was a risk of
users unintentionally installing
certificates that could allow for a
man-in-the-middle and so we've changed
the default to no longer have user
certificates be by default able to
intercept traffic between your
application and your endpoints you can
change that if you want to there may be
situations where it's appropriate to do
that in the context of your application
there may not something for you to take
take a look at and make a determination
for the other thing that we've tried to
do is simplify debugging so I would
encourage you to go look at your
application if you have any SSL you know
handling that you've implemented that's
custom handling custom cert verification
custom SSL handlers
you probably can replace that with
network security config and make it much
easier to make sure that you don't make
a mistake on that if you want to do
something and you feel confident in your
ability to manage your own certificates
we've provided that and tried to make
that a little bit simpler for you as
well but as I mentioned this is a little
bit more difficult and a little bit more
error-prone so it's something that you'd
want to think through right so we talked
about networking now let's get into the
thing that we so often just referred to
as encryption right the big encryption
debates of 2016 I've been spending a lot
of my time talking about why it is that
storage encryption is so important for
protecting user data the benefits that
it has accrued on the ecosystem where
we're now able to deliver applications
like Android pay where it's possible for
a developer to rely on the integrity and
the confidentiality of information
that's critical to their application on
the device that's one of the reasons
among many that we've moved towards
requiring encryption on all capable
devices starting with marshmallow we
made that mandatory and we've been
making that more and more robust because
we think direct physical threats to the
user's device are one of the things that
we need to be concerned about right
these are devices that we move around in
the world with you know they're
sometimes attached to your wrist there's
sometimes in your car there's a lot of
different ways that having strong
storage encryption is really fundamental
to Android security but that doesn't
mean we can't make it better it doesn't
mean we can't improve it from a user
experience standpoint so one of the big
changes with the Android n is what we
refer to as direct boot I'll talk about
it both from a user perspective and then
I'll get into it a little bit from a
developer's perspective from the user
perspective direct boot basically means
I don't go through two times putting in
my users password right I don't have to
double enter that right because it's
currently the first time the device
comes up you have to enter it the device
is then decrypted and then you get it
again as you're interacting with it but
also means that all of the data is
decrypted after you've entered it the
first time so we'll talk about that more
in just a sec
another challenge that exists with full
disk encryption is it means that yes all
the data is protected all the time but
until the user has entered their
password you're sort of stuck no
application has the ability to access
data and so one of the important changes
is the device will now come up and
things that are running in the
background things like inbound calls
inbound SMS your alarm clock in the
morning for those of you who had to get
up earlier than the six o'clock shuttle
coming down from San Francisco who
didn't have the fortune I did of having
a two-year-old wake you up at 3:00 so
you were already awake you rely on your
alarm clock I don't have to do that for
another six or so months and so we move
towards making that work even if the
user hasn't put in their credential so
that's what it looks like from a user
standpoint what's it look like from a
developer standpoint we introduced two
different concepts in terms of storage
encryption the first is the one that's
most familiar to you right now right
credential encryption that means this
data is only available after the user
has entered their credential we also
have what refer to as device encrypted
data this is data that's available with
a key that's stored in trustzone so it's
protected in a variety of different
mechanisms against extraction so the
data is still encrypted but it's
encrypted with a key that's only tied to
the device applications by default are
gonna run in credential encrypted
environment so you don't change anything
the behavior you have is gonna be
exactly the way your application works
now which is once the user logs in you
could access the data and you can kind
of proceed along your way but if you
have an application that requires access
to information potentially before the
user has entered their credentials you
can declare yourself to be direct route
aware and then you have access to the
data in the context of the activity
that's been declared to be directly to
where and you can actually interact with
it right so that's how talkbacks works
that's how sms's works that's how alarms
store this is an alarm and immediately
upon reboot I want to be
execute on that one what does it mean to
declare yourself to be direct true to
we're pretty straightforward the top
half of this is in the manifest you just
say I'm direct futa we're okay and then
that receiver can be triggered in the
event that you know a particular intent
is fired like I don't know buuut
complete then your application will
start running into the context of that
particular receiver to use storage which
presumably is one of the things that
you'd want to do you're going to need to
create storage that's in the context of
device protecting storage and so there's
a little snippet of code down there at
the bottom you create your app context
to use your app context and then you
create a device a particular storage
context and then you just open it right
you interact with it exactly like you
would any other way um when you are
running in what I refer to as the device
context as opposed to the credential
protected context you can still create
files that are credential protected you
just can't read them but there are lots
of ways that that could be useful right
you can append so if you receive an
inbound mail message and you've got a
really horrible mail storage format
where you just append you could just
grab the headers and display that on the
lock screen and then take the actual
content and push it into credential
protected storage right you probably
want to do that just for the cache not
for all of your meal but you could do
those kinds of things or you have a
sophisticated user experience while
maintaining sort of optimal security so
let's talk about some of those best
practices the first thing I want to do
is point out just use the defaults right
the vast majority of applications you're
not expecting your application to do
much if anything prior to the user
logging in and so it's perfectly
appropriate to use the defaults and
that's sort of optimal from a security
standpoint it also makes your life a
little bit simpler because you don't
have to think is this available to me
now in the device context am i able to
access print just it's there if you're
running right if you don't do like if
you aren't directly to where
everything's there if you're running if
you are a direct Buddha where then you
have to be direct route aware of which
things are going to be available at that
time the other best practice is think
very carefully about if you are direct
route aware which things you want to put
into the device encrypt that our device
protected storage
please don't put long live credentials
directly into that area so you don't
want to have auth tokens that are
sitting there that could be used to
connect to a service even though the
user hasn't sort of authorized that by
entering their credential one of the
things that we want to think about is
can you limit the scope of tokens right
so if you have something like a male
receiver maybe you just want to read
mail but that doesn't necessarily mean
that you're gonna send it right if you
don't expect the user ever to be able to
send mail when they haven't actually
logged on to the device you certainly
don't expect them to be able to like I
don't know delete their account delete
all of their messages like these are not
tasks that you would expect to happen
before the user has logged in and so you
would want to limit the scope of the
ability of the application to perform
those behaviors by limiting the
authentication tokens that it has
available inside that scope and then the
other one that I hinted at there which
is if you receive some data that you
think is sensitive receive it put it
somewhere that's encrypted you could
either encrypt it locally using
asymmetric cryptography like public key
where you just have a key that you have
the public key in device protected
storage and the private key to be able
to decrypt it inside of the credential
protected storage so you know that that
key and the ability to read the mail
requires the user to enter their
password there's a variety of things
that you can do there as well okay we're
making good progress we've got about 10
minutes left we're gonna barrel through
verified boot and sandboxing and I think
we'll have two or three minutes to talk
questions there at the end and I'll hang
out for a while enjoy the this sunshine
which we don't have up in San Francisco
the verified boot was introduced sort of
over a couple of releases and then
became required on em for devices that
had hardware capable of providing
verified boot which basically amounts to
devices that met a performance threshold
of about 50 megabits per second AES
inline encryption it's the vast majority
of devices by the way in N we moved from
what we called enforcing mode to
strictly enforcing mode with em it was
acceptable for a device to warn the user
and then proceeded to boot as the
mechanism for us to begin to validate
how frequently were we seeing
in the field what kinds of problems were
we seeing and making sure that there
wasn't going to be disruption one of I
think the more intriguing features that
was introduced in verified boot was
error correction was introduced with
Android n this gives us the ability to
detect bit level errors and actually
lots of bit level errors and they
actually get corrected at the time those
blocks are being read at the kernel
level and so when you're dealing with
very low end Hardware bit level errors
were you know a problem that we might
run into we've also seen at least one
instance of testing where there were
actually changes made that were after
device had been routed there were
changes made to allow it to continue to
be routed right adding su and a couple
other things an error correction
actually erased those changes so they
were still there but you couldn't
actually get them to execute which is
amazing totally an accident but pretty
exciting that we're beginning to see how
those kinds of checks could actually
improve security in more than the
expected ways verified boot is part of
making it easier for you as a developer
to understand that you're running in an
environment that is a strong secure
environment and so there's one other
thing that we want to talk about in this
context which is the safety net API and
patch level strings which are both
mechanisms designed to make it easier
for you as an application developer to
understand you know what is the security
context of this device that I'm running
on so the safety native API I'll give
you an example code in just a second
basically looks at the device
characteristics and this goes back all
the way to jelly bean and tries to
understand whether this is a real device
it looks at a bunch of hardware
characteristics including like how does
the GPU work not what is the GPU serial
number not what is but like performs
operations on the GPU to make sure that
it's executing an imino that we would
expect to be consistent with a piece of
hardware that matches the specification
that's being provided by the operating
system that's running on top of it all
right so we aggregate a whole bunch of
that analyze that and make a statement
back to you that yes this looks like a
real piece of hardware that's running a
version of Android that is a CTS
compatible very you know tested by om
and then submitted to Google so we can
confirm that it's a real piece of
hardware so that's one of the goals of
safety API is to make it possible
for you to have that kind of confidence
and then another thing that we
introduced was was called the Android
patch level string the patch level
string is really really simple you can
check it and you can see when is the
last time this device got a security
update if history is any guide we've
released now 10 monthly security updates
if that string is more than a month out
of date there are publicly known
security issues that affect that device
so we're working with OEMs and carriers
to make sure that they're able to
deliver updates very very quickly but
you as an application developer might
want to look at that and evaluate how
much trust you have in that particular
device right especially in an enterprise
context we're seeing more and more
enterprises set policies that say things
like if this device is out of date more
than 60 days it's not appropriate for my
enterprise environment and we wanted to
make that a really simple thing for you
have to do so you don't have a table of
hot fixes and service packs to figure
out whether the device is secure if it's
on KitKat or above and it has a recent
security patch level you know it's up to
date it's pretty simple right
regular expression submit to make that
determination let's talk about safety
net for just a second this is an API
that's not provided at the platform
level it's provided by Google Play
services relatively straightforward you
create a callback you invoke that and
you get back the result this is a result
that's gonna be signed you want to go to
look at the safety net documentation to
see what the key is that it's been
signed with we encourage you to do
offline verification of this right so
you receive it in the context of your
application but then you send it up to
your server and your server makes a
determination about whether this is a
legitimate signed statement that came
back from Google what are the things
that you're looking for in that signed
statement the first is that there's a
nonce that was created on your server
sent down to your client comes back to
your server and it's the same as the
nonce that you submitted right so you
want to make sure that it actually went
through that same process and was signed
by Google and then it tells you is this
something that matches CTS so CTS
profile match true or false that'll give
you a sense for is this a device a real
Hardware device that has gone through
the full CTS validation process and is
continuing to operate in the manner that
was originally submitted there's a bunch
of other context that's provided so you
can validate that these are you know
what you're expecting was it your app
that sent it up to the server things
like that last thing that I want to talk
about is sandboxing sandbox ting is an
area that we've been investing in in
Android with every release we introduced
new capabilities these are some of the
things that have changed pretty
significantly in android m and n
significant improvements to SELinux
especially in the way that it interacts
with drivers were very concerned about
kernel security right now so we've made
changes to way I octaves are filtered
with SELinux SEC comp which also allows
for filtering of interactions with the
kernel SEC comp I'm going to talk about
more in just a moment because you as an
application developer can actually use
it yourself which is a little bit
different from selinux where we've done
all the configuration for you directly
we've used those two tools to do a lot
of media server hardening and then in
Android N and then we've made a number
of other changes that we think increase
the strength of sandboxing we just put
out a blog post I know this is tiny I
don't actually think you can read it is
it it is actually readable all right I
wasn't sure if it was even gonna have
enough pixels on their projector to be
able to read it the blog post that we
just put out that describes how it is
that we use some of these capabilities
to strengthen and really break down the
capabilities inside of media server and
isolate them using SEC comp and selinux
so that a compromise in one area eg in
the codec doesn't lead to a compromise
in other areas in the context of media
server but you can do the same thing
inside your application right if you
have a complex financial transaction
that's based on image processing you
might want to separate those two things
apart
I don't know why you would do that but
at the same time there are lots of apps
that take pictures of credit cards and
then try to process that information and
then use that as the payment so it's
like it's actually a thing that
applications do do we've also been using
this pretty extensively to harden Chrome
because that is something that stores
your most sensitive credentials and does
a lot of processing of data that comes
from the internet right it's ironic how
close those two things are in the
takes of a web-browser so it's really
important that these kinds of
capabilities exist at the platform level
to make it easy for that application to
harden itself here's a sample of what it
looks like to use set comp we actually
created a library in the context of
media server so if you go dig around in
AOSP
you'll be able to find something that's
called mini jail and it describes how we
set specific filters to limit the set of
capabilities that each of the different
elements inside of set comp or inside of
media server have access to from a
hardware standpoint there are a bunch of
other changes that we've made as well
that make it more difficult for a device
to be compromised you know things that
we think about when we're talking about
hardening of sandbox they may have
effects on your application so I would
encourage you to take a look at those
and be conscious that these changes are
coming so there are a couple of these
changes here there are two other api's
that we've also been very actively
looking at to restrain the capabilities
because they've been associated with
abuse basically right we gave a lot of
powers to device administrators and it
happens that that same power to manage
the way that the user is interacting
with their device can be used to harm
them in the context of ransomware right
you change the users password and then
you say I'm not gonna get us you log
back into your device until you pay me
is sort of the most fundamental way that
ransomware can work and so we're making
changes to make it more difficult for
applications to access those api's and
then we've also limited the way that
applications can overlay content on to
another application through a system
alert window so that's an area that
we've been hardening as well I lied when
I said I would have two minutes for
questions the clock now says five
seconds but we managed to cover all of
these key elements I did want to leave
you with a couple of pointers to some
additional information that you can look
at to try to get into some more the
details here and I will hang out outside
and happy to answer any questions that
you might have thank you very much enjoy
the rest errday</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>