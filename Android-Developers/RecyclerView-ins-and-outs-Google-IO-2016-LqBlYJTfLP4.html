<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>RecyclerView ins and outs - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="RecyclerView ins and outs - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>RecyclerView ins and outs - Google I/O 2016</b></h2><h5 class="post__date">2016-05-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LqBlYJTfLP4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">listview has been around since android
one oh and it's meant to handle repeated
structure inconsistent content and more
specifically it was made to handle this
sort of repeated structure in some very
simple settings so as you can see here
we've got our old settings screen from
Gingerbread and this was already kind of
after a lot of extensions to what
ListView was was meant to do
and sometimes the content isn't so
consistent so you've got different view
types floating around so on and so forth
and we just kind of kept adding features
but the core problem that ListView meant
to solve is how do you make it fast when
there's a ton of items hundreds
thousands possibly more creating views
themselves can be really expensive
especially on old devices back in
androids early days and memory is
limited so you can't just necessarily
create tens of thousands of views and
deal with that all at one time and the
answer is we cheat
so with ListView we do a trick with some
smoke and mirrors and really anyone who
works on UI development has a lot in
common with stage magicians stage
magicians use misdirection and other
sorts of tricks on stage to make you
think that you're seeing something that
you're really not and if it looks right
it is right so I mean what what they're
seeing is the UI in terms of what the
user believes so the trick that we use
is that we only create and layout the
views that the user can see right now
and as the user Scrolls we continue to
layout more items the image you should
have in your heads right now is that bit
from wallace and gromit where you're
quickly laying the track in front of the
moving train so that's basically how
ListView works and in order to enable
this ListView uses adapter components
now this is a component that's provided
by the application itself and it's used
to create and populate the item views on
demand you've got this getview method in
the adapter that is used to query the
adapter for a particular view to show a
data item that corresponds to a
ocular position in the list and the
extra trick that we do there is we also
pass in a special convertview that's
guaranteed to be of the same item types
if the adapter believes that new
position to be so that you can reuse the
same view and you don't have to pay the
cost of inflation again and over time we
continued adding more and more features
to list view because they were things
that people needed in their apps and
this question kind of came up a lot so
ListView grew feature after feature
after feature and you can go back and
watch this talk from i/o 2010 if you
want to see a few of them what's the
real this is really nice you should vote
you I enjoyed it if you want to see a
some of our classic classic UIs and some
of that talk as well yeah it's nice but
really as we kept adding features to
ListView we kind of hit this complexity
overdraft point we had so many features
that kind of sort of interacted with
each other but not really all of them a
little bit one-off and it was just all
of these long tail features that led to
a lot of very strange interactions and
what that meant in practice is that
everybody wrote their apps such that
things worked how they wanted it to but
a lot of times those things were really
just kind of the result of undefined
behavior and listviews implementation
itself and once enough apps start doing
that then that's de facto API that we
have to support any small change that we
make to listviews behavior that might
improve it for some of these core use
cases ends up breaking some apps really
hero use case that they want to use
someplace else we also had a lot of
duplicated functionality in the ListView
like ListView selections or view focus
which ones do we use I mean the view
hierarchy already knows how to handle
things like keyboard focus as you
navigate around but ListView had its own
completely separate idea of this in
terms of the current selection a
selector drawable that's drawn either
behind or over the views depending on
what configurations that you set up and
this led to a lot of overlap and not
only that but it meant that when you
start using more complex views in your
ListView items
you kind of have to switch over to this
set items can focus option that disables
lists use internal selection handling
and lets you use the view hierarchies
focus handling instead similarly we had
the same issue around item click
listeners versus view click listeners
and other sorts of general touch
handling so ListView provided this very
nice convenience where you could set an
item click listener on the ListView
itself and get clicks for anything that
happens in that list now this makes a
whole lot of sense
for lists that are really uniform where
you have a list of items and you just
want to pick something from it kind of
like the pop-up menus that we have from
the overflow menu up in the upper corner
of your apps today but alternatively you
can also just go ahead and attach click
listeners to these views themselves and
which one was going to handle the events
was sometimes not always clear or
intuitive so people would ask us a lot
of times you know which one do I use and
the answer always always ended up being
it depends it was like okay well how
complex are your list items so on and so
forth and any time that you have to
answer a lot of those types of
clarifying questions about like okay
well what are you trying to do then that
really kind of complicates the developer
story but really the big thing that kind
of kicked off the whole recyclerview
effort was that ListView animations are
really really difficult and the core
problem is that adapters don't tell us
enough to do them smart so when you
change an adapter you you say notify
data set change and the assumption is
anything could have changed we're not
entirely sure what and we're just going
to go ahead and rebind all the items
that are currently visible and go from
there
and over time we had a few prototypes
some of them were done by members of the
team some of them were done by members
of the community all to try to show
items animating in and out as the data
set changes and do so in a way that's
kind of intuitive but all of these had
some really major limitations
most of these had to do with again the
internal implementation details of
ListView that apps had really come to
rely on so we couldn't fix these things
to make
these animations possible so eventually
you just end up making this face at
ListView yeah look at these the regret
in his face like I'm doing this way they
bite but I'm not really sure if I should
do this like I'm going to get this I
have to do oh my god
Chet where's this face a lot comes
with the framework right and again
another one of these problems that we
had with ListView was just this
duplicated functionality what isn't
perfect hit this like yeah I guess we
did didn't we okay so as we moved on
people started using much much more
complex layouts in their ListView items
we went from something like that very
simple settings screen in Gingerbread to
suddenly people are showing items from a
full social stream items with many
different components to them with many
different points of interaction so these
simple grids and lists that we provided
with listview and gridview in the
framework really weren't enough to
handle these use cases appropriately
people started wanting to create these
sorts of staggered grids responsive
layouts so on and so forth and really if
you wanted to change these types of
layouts you are rewriting a whole lot of
core code that ListView used to do this
adapter based recycling so if we had to
do over what would we change well one of
the things that we wanted to do was to
elevate the best practices of working
with ListView to first-class API we had
this view holder pattern that Ramon and
I went over in the world of ListView
talk linked earlier in the talk here and
the nice thing about the view holder
pattern is it existed for ListView is it
gave one point where you could sort of
collect a bunch of attributes about a
recycled view that you were going to
work with and have that single point of
access you could kind of cache a lot of
these fine view by ID calls that you
would make to an inflated view sub
hierarchy and especially on older
devices that made a big difference
because you were doing fewer traversals
and as you were creating more and more
complex item layouts it mattered even
more so we thought okay well let's go
ahead and just make that part of the
core API like
go ahead and instead of having this just
be a best practice that everybody has to
read some blog posts to figure out about
let's go ahead and make sure that this
is something that you see as soon as you
read the documentation for working with
recyclerview
we wanted to separate view creation and
binding now this was something that
happened in the cursor adapters that
many of you have probably used if you
worked with sequel Lite databases or
content providers as you're backing data
source for your ListView adapters we
separated out and uncreate verses on
bind step in those but if you're just
writing a raw ListView adapter yourself
then this was essentially a question of
the very first couple of lines of code
in your getview method where if
convertview equals no create a new thing
and then sort of fall through and do the
binding there and this was one of those
things that was fairly easy to forget to
do and if you forget to do it then that
means that you entirely lose out on this
recycling mechanic that ListView gave
you to really kind of boost your
performance sometimes it wasn't really
clear why this was happening from the
outset and next we really kind of wanted
to throw out a bunch of this selection
handling that really only made sense for
the these very simplified lists and just
rely on the frameworks normal focus and
input handling because this was this
again just kind of comes down to
simplicity of working with the rest of
the framework and kind of reinforcing
the consistency of working with the rest
of the view hierarchy and then selfishly
we also wanted a little bit more easier
maintenance on our end because I don't
know if any of you have taken a look at
the internals of ListView in AOSP
I'm pretty sure that it could be used to
scare small children so we wanted to
keep the core universal so all of those
things that were a total pain to rewrite
yourself if you tried to write your own
recycling container we wanted to have a
way to give that to developers more or
less for free in a canned form so that
they didn't have to sort of rediscover
all the things that we had to do the
hard way and we wanted to make sure that
you could still implement all of these
other longtail features that ListView
just kind of provided as API on ListView
itself
as other plugins that we could sort of
share and mix-and-match to get the
experience that you wanted we needed
smarter adapters to again the problem
with ListView adapters is that you could
say notify data set changed okay what
changed ah
and that was about all you knew and this
makes animations really difficult we'll
get to that a little bit further on down
the line
so recyclerview adapters tell us what
changed not just that something changed
now if you're working with a data source
that doesn't provide that sort of
fine-grained messaging then you can
still use the old ListView style hey
something changed go figure it out we'll
make some best effort attempts at
dealing with it but really if you have
any knowledge of what the specific
changes in your data set are you can get
a lot better results so this also means
that we can do more efficient recycling
not just animations if we know that only
a particular item and the adapter
changed then we don't have to rebind
everything that's on the screen we only
have to rebind that one view and this
can save a lot of time in the
measurement and layout phases of
applying those updates all right so that
was born recycler view so made mistakes
we learned from this vo now like okay
how do you write recycler view not to
repeat the same mistakes and the major
thing in recycler view is we try to make
it a component based architecture this
architecture of recycle aveer and we
will go through the details of it I
think it's very important I believe most
of you already use it it's good to know
who does what and which one you should
use or which one you should customize
depending on use case so we have the
recycle of if that's the main view group
there's major three three major
components there's a layout manager an
item animator and then adapter so
adapter is provided by you layout
managers most of you provide you can
write yourself an item anyway the same
there's a good default one but you can
write yourself so layout major positions
the wheels item animator animator and
the adapter provides the wheels
and the recycle is the boss so is the
central location that communicates with
all these components to make them work
together so we believe look at the
layout manager it can be a linear list
it can be agreed or it can be a
staggered grid get me anything
recyclable doesn't know or doesn't care
about how the items are laid out is the
layout majors responsibility Oh
scrolling recycling handles the like the
interactions with the finger but tells
the layout major to scroll because on
the layout major knows where the weaves
are so it stores the content or if you
do focus traversal recyclerview handles
the basic forecast reversal because the
actual devii frame or candles it but if
you are focusing and you need one more
item then it's the layout measure that
brings the new item to the focus area
because they did not exist before or the
accessibility yet recycle we provides
basic information about those items but
layout majors you know is the one that
knows okay this is section title or you
could attach your custom delegate let's
say say like do not focus on this or
additional information that only you can
provide I mean recycle be accessible to
delegate API for this alright
so similar to ListView recycler view
still relies on adapters you know a
recycler view adapters responsibilities
are again to create the view but also to
create the view holder and the view
holder is what we really use as the
tracking element for recycling so when
you're binding an item you don't just
bind it to the view you bind it to the
whole view holder and this is something
that you can use as a place to stash
other information as well and of course
it's the adapters responsibility to
notify the recycler view about changes
that happen to the data set or if the
data is out of sync
so in contrast to ListView where you
could use this item click listener type
of model for things the adapter is now
responsible for configuring the item
interaction handling so these are all of
your click listeners touch listeners so
on and so forth
adapters also deal with your multiple
view types sort of being able to keep
track of the different view holders that
you may be tracking like one tip about
the weave types in the ListView world
you need to give us how many view types
you have versus you recycle if they're
unlimited so I suggest just use our dot
layouts whatever is the wave type and
then your path right so your view type
IDs no longer need to be contiguous the
way that they did with ListView so if as
long as you have any sort of unique
identifier that you can use to identify
a view type then go ahead and use it in
recycler view isn't going to care so
that means that you can use this handy
trick of using the layout resource ID
itself and since AAPT already guarantees
that that ID is going to be unique it
makes a pretty good stand-in for that
identifier Oh went a little too fast so
the adapter also deals with things like
recycler recovery so we have this on
failed to recycle view concept and so
why why could something fail to recycle
of view well again we're trying to keep
we're trying to keep in mind that people
are doing more and more complex things
with their UIs and in those cases you
might start making a lot of changes to
your views that are very difficult to
reverse so in those cases where we know
that a view has been left in kind of an
inconsistent state then we can
communicate that back and forth to the
adapter so the adapter is able to sort
of recover from a case where a view it
has been messed with kind of beyond the
normal bounds of expectation and again
we have the granular data change events
as added to sort of handle efficiency
and probably link performance that's
efficient animations yes that way all
right so let's deep dive into the V
Boulder because most of
everybody needs to write a view holder
to use recycle vo and you spend most of
your time there it's important to know
the lifecycle of a view holder so we'll
go through it what happens when they
were created what are the stages so
while the layout measure is calculating
the layout it tells the recycle a via
okay give me the v4 position 5 so he
wants to get the v4 that position
recycle we've checks the cache because
we cache the bees now if you already
have it in the cache we will return it
to the layout manager if not so we have
it needed alternate if we didn't have it
the case said no it's like we will tell
the ask the adapter ok what is the type
of this field and after returns it then
we go check the pool this might be a
shared pool is rather like the on the
Palouse by the cycle view
do we have a beam holder for this video
type if it says no we tell the adapter
to create one so this is when we
actually create a view holder or maybe
the pool returned an item that already
exists then we tell the adapter ok bind
this position to this view holder it
returns it and we give it back to the
layout manager eventually layout manager
will edit back to the recycler is a real
child and I will tell that after hey
this view has been added to the layout
this is a very good hint for your
adapter to know that ok users about to
see this view Southwark a swirl layout
made you and say ok I'm done with this
video remove and recycle it recycler
will tell the adapter ok I revealed this
will let you know so let me know if you
have expensive things inside that view
you can catch them you can remove them
from memory and then we will check ok is
this video well it for this position if
it is valid for this position we will
catch it the idea is that if the lamp
measure asks back for that position
again we can give it without talking to
the adapter this is again for
performance reasons and that the cache
will evict all this one and I will tell
that after hey we got
of this video now you know that it will
not be reused for that position so you
could do even further
you know memory cleanup great this is
kind of an important step that was a
lesson learned from list view where list
view eventually added this recycled view
listener that you could use to track one
of you was really no longer in use and
again because people create much much
more complex UIs in these sorts of
recycling containers these days this
allows you to take a step and say okay
well instead of leaving these giant
expensive bitmaps attached to these
views that are just being held in a
cache off screen let's go ahead and
clean those things up but still retain
the core view structure that we had
before so that we can rebind it later so
if the wave is not valid let's say say
it might be maybe the item has been
removed because the adapter told us or
item was change and the contents of the
weave does not represent that position
anymore if this is not be valid anymore
we just send it to the pool and we tell
that after our audits there's another
use case where layout major recalculate
the layout after someone up there
changes and then doesn't use some of the
wheels so it had all the views from one
to five let's say and that makes one it
only used eight of them and the other
two are missing
so what recyclerview does is okay we
understand that the layout major doesn't
want these views anymore
so but item animator may want them right
you may want to fade them out instead of
disappearing them instantly
so what recycler will do is for each
disappearing children it's going to make
them children again
and I'll hide them from the layout major
we will go into details of this later
but basically the list of children from
the layout majors perspective are not
the same that as the children of the
wave group when the item animator says
okay well tell litem animator and make
these children and when the item
animator says okay I'm done with these
fields you can do whatever we want that
recyclerview will remove them it'll tell
them that they are going away and novel
so how do we lose a beholder this is
very important because if you're losing
me you holder you will hit performance
problems so six same thing happen
recycling out May just said okay when I
get it off this view recycle check is
this via valid I was like no okay wanna
put this into the pool and the pool
shakes does this view has transy state
is what Adam mentioned earlier a we're
having transient state means it's like
is animating the contents are you know
we have a button is doing some animation
that is if a beam is innovating we
cannot reuse it for other view holder
because imaginate it was fading out and
I we bind it to something else it comes
to the UI as faded out it's like this
not what you want you want fresh views
there are a few other cases that can
cause views to have a transient state as
well this is a concept that's part of
the framework not just the recyclerview
itself so for example if you have an
edit text widget with a piece of text
that the users entered and they've gone
ahead and created a selection across
several words but maybe not others then
that's kind of this complex interaction
that the user has created that we really
didn't want to make it the developer's
responsibility to sort of track and
restore that if that particular item is
rebound across other contexts so what
will happen is that now we cannot reuse
this view and we are removing from the
recycling like the last reference we
have diabeetus going away so we give
adapter one last chance hey I could not
recycle this view can I recycle because
most of the time is because of
innovations with selection you can
actually recover from that state the
only problem is that we cannot do it
automatically because we don't know
what's going on so adapter can say
either we call fail to recycle you can
you know you can add those innovations
or clear the selected state or you can
even say do not I take like I know I fix
these when on buying this cold like
recycle it I will use it well if the
adapter does not implement this method
by default it turns false so we will
have to destroy the beholder so it goes
through that poof you don't want this
the moral of the story is if you're
innovating items don't go ahead and
create animations on mine we have the
item animator API to do these things
properly so use the item animator if you
want to innovate at the item animated
receives the correct lifecycle events so
that we can recycle we can take care of
recycling those videos meant they're
done animating right essentially you can
forget about everything that just
happened on that slide before you as
long as you implement the item animator
interface yes if you're doing it
yourself you're on your own and you're
gonna have to handle all of these
problems yourself yeah and what it's
like the major thing where you start
using recycle you really need to forget
everything you learned in this field
most of them are valid but did some bits
that are not valid will actually hurt
you here so is another use case where we
will lose videos is cycle is like okay
I'm done with this view we try to put it
into the pool but pool is limited per
size per item type so if you have way
too many of those reef types in the pool
already like you know what we have no
space for it throw it out so why would
this happen why would we create views
that we already had a lot many of them
that are unused in the pool well this
usually happens if alright so if you
have too many older types and why would
it happen is mostly because of
animations like you told us I see this
in Stack Overflow maybe really set well
like to make it anyway it is all
collected by dataset change called
modify items change from 0 to all of
that so if you say something like this
recycles like over okay for every single
visible child is by the default behavior
I have to create another view holder
trip isn't the child so I can cross wait
that because the default behavior is
crossfade that means you duplicate the
number of view holders of course when
those innovations are finished we try to
put all of them back to the pool
opposed again I don't need this many
items you know just throw them out so
don't do that but an item has changed
tell us what actually changes really
important I know are the correct
innovation or if you have some other
cases by your vote east views are being
lost you could change the type the size
per type in the pool so this comes up
when you have cases where again social
streams are a really big use case for
this as well
you might have some posts that are very
long that fill an entire screen all by
themselves or you might have several
posts that are very very short and if
you have items that are of drastically
different sizes like that then the
number of items that can be attached at
one time is going to vary pretty greatly
so those are cases where you really want
to sort of measure what your apps own
behavior is under some of these use
cases and tune the size of the you
recycled you pool accordingly all right
there so item animators items common
items go over time and again we want to
use a smarter way of figuring out
exactly what it was that changed so
let's say that we add a new item in
between H and I in this diagram here so
now we have P in the middle so no longer
sorted ignore that what happens if
something disappears well now we have
another image of a list now the
interesting thing here
oh and then of course we have the case
where an item simply changes and its
contents change in place so the
interesting thing in these cases is that
there's always kind of some side effects
when you add and remove views so we
added view P here I and J got moved down
and K is completely gone when we remove
something really similar happens so we
remove item H ijk move but L is new on
screen we had to get a new view in order
to show it in that case so without extra
information oh sorry
change first and of course this is one
of the easy cases we can just go ahead
and crossfade between these
so if we're handling things this way if
an item is removed we can fade it out
and items added we fade it in the film
is just sort of moving around on screen
we can translate it and our default item
animation handlers can handle this no
problem changing we just do a simple
crossfade in place and as long as we
don't have cases where that item has
changed size we're in a super easy case
but otherwise it just means other items
around it are moving and we get into
exactly the same cases as before but can
we do better than this there's kind of a
key problem in these cases which is that
if all we know is that something changed
in the adapter and here's the new state
like with ListView then how do we really
tell the difference between an item that
was removed from the adapter after this
versus an item that just was knocked off
screen and is no longer there when we're
putting together these sorts of
animations this is suddenly really
important similarly how do we know if
something came on screen because other
things moved around it or if it's
actually a new item in the adapter
itself again without there being a
representation of those views attached
to the parent from the outset we don't
necessarily know so we can do better
because now we know this we know that
conceptually again coming back to the
smoke-and-mirrors analogy from before
even though we only have a certain
number of items attached to the view
group at a time conceptually we have a
lot of items that come before and after
what's being shown on screen so we can
get a little bit predictive about this
if we're willing to ask the adapter some
additional questions and specifically in
conjunction with the layout manager so
as we add this item here and we have to
delete kay in this case we know that K
is still present if the adapter hasn't
told us that it's now gone so we know
that it's just sliding off screen
instead
similarly with removal we can use the
same trick we can ask the layout manager
hey show some stuff around what I'm
doing so that I have the added context
to be able to take the diff of the
before
or in after states and animate it
correctly yes so the way this works
about the item animator the predictive
animations is that recycle of you can
show a view of the adapter in the past
so how I can do is like you know if you
have added new items to the adapter we
tell we don't tell about them to the
layout manager because the cycle always
sits in between what we do is we show a
different view for example before we
implemented that there was a layout
major and item animator and there's a
wheel and they will always find out this
view is mine no no this review is one
like I want to animate it but wait wait
I want to remove and recycle it so
always get into this conflicting cases
the way we solve this is was the child
child helpers so one layout manager says
hey like I want to get a child at the
position or remove it or do whatever I
want
recycling wheel doesn't call the wheel
group like we don't change the children
decently
we start with child a child helper which
is the component that's responsible to
create this fate list about the contents
and then the child helper decides okay
layout major told me to remove it but
item animator tornado animated so I will
keep it until the item animator is done
but we don't want layout majors to get
more complex trying to understand about
animations so for the layout manager
they look like they disappeared but they
are actually real children in the way
group so child ARB is responsible to
provide a virtual list to the layout
manager so for example let's assume this
view has been swiped is being removed so
while you run the remove animations at
the 200 milliseconds if that layout
measure tries to get the child at the
third position is going to return
Barcelona and if the recyclerview if you
try to get the recycler with their child
is New York so the abstraction between
these components helps us with these
kind of things without making these
components
and one derivation is complete they will
start returning the same value adapter
adapter helper is the same thing but
doing the same attraction towards the
adapter so when you like have that
updates and all these notify change us a
bunch of things happening in the list
and recycle is our suck what's going on
I avoid it what's happening there it's
very hard for layout measure to track
these things because already busy taking
the UI so adapter helper is to the risk
if so when you say notify item insert
the adapter we record it and we request
a layout we know something happen we
need to redraw that's it the only thing
we do is we keep the information about
it and then you as you add more notify
events we just keep them in a list let's
say during this moment before we
recalculate the layout but we know that
adapter contacts I've changed user
clicked on a button and you wanted to
get the item you co get adapter position
for the item at 59 which was clicked but
we know there's a new item added at
index 55 so we know that in the adapter
there's actual at position 6 so we
return you 60 so even if the weave is
not recalculated if you need to adapter
position to go access your adapter items
we can provide you the right position so
this this simply happens by checking
what you told us before and let's say
you send more updates and I will go
through them the request layout will be
honored by the system will start
preparing the new layout and this time
the adapter is going to provide the
layout manager the fake positions so how
does it work what we do is when I talk
about like faking the adapter contents
is we reorder your updates first so the
idea is that everything we have to tell
to the layout manager first we tell
about them relate it to the predictive
layout
and now everything else we tell about
them later so if you look at you removed
whiteness from 61 we know that was 65 we
reordered and we look at this okay I
actually have the item 416 so even
though it is removed when the layout
page is recalculating the previous state
which is part of predictive animations
if it asks for item 60 I could provide
it so I don't need to tell the layout
major that that item has been deleted
from the adapter but item 61 I don't
have it so what I do is I divide that
remove operation into two I tell the
layout major hey like before you
calculate the layout the item 61 is gone
just let you know it does the pre layout
goes to the post layout phase that we
tell about these things like this
fine-grained adapter updates tells like
enables us to fake that up the content
stores layout major so that all it has
to do is we ask it to lay out twice and
that we predict all the rest of the
animations so a major almost doesn't
need to know anything about that okay
all right we'll try to move some of the
through some of the other features here
a little bit more quickly so item
decorations ListView has the ability
like many other one-off features in
ListView to draw dividers between items
and so we need to make sure that this
sort of functionality was still
preserved so item decorations allow you
to do custom drawing on the recycler
views canvas itself so this is in the
context of the recycler view the parent
of all your child items not necessarily
just individual items within it we can
also go ahead and add offsets to view
bounds again using the simple test case
of the divider you need to make sure
that you have that couple pixels of
space that the divider consumes itself
rather than drawing necessarily over
under the item views and you can also
have multiple item decorations they
stack so these item decorations can
affect views again in sort of a stack
like manner item decorations so we can
draw items over
over our list items here let's come on
all right so another kind of important
thing here is the getitem offsets this
is really what lets us add space around
particular items so this can be nice if
you're doing some sort of card
background around several items at once
so like a grouping of some sort but you
can also do it just on single items too
so we can expand the space around a
particular item because maybe that's an
area that we're going to draw in
so we get on draw which will draw
underneath the itemviews before we
actually draw the atom views themselves
which is then followed by the items
themselves and then we get on draw over
which allows us a chance to draw on top
of the item views in case that becomes
relevant in your particular situation so
in this case we're doing we're just
otherwise decorating these things so you
need to be kind of careful about item
decorations though because this drawing
phase here might be in the middle of
several other operations that
recyclerview is doing and as you just
detailed there are a lot of things that
recyclerview does to sort of try and
present a consistent view of the world
to adapters versus the layout managers
we're doing animations and so on and so
forth so the adapters view of the world
may not be what you're seeing on screen
right then so you want to make sure that
you don't use the item decorations to
access the adapter keep the necessary
information about things that you need
to draw in the view holder itself the
item decoration can access the view
holder it will because the view holder
is data about what's being displayed on
screen right now and again the general
rules around drawing apply this is a
pretty hot code path ideally this is
being called 60 frames per second if
everything's going right so try not to
allocate memory do anything too too
expensive so on and so forth you can
always go ahead and use the recycler
view get child view holder method to get
the view holder for a particular child
view that's attached to the recycler
view at the time so the recycled view
pool is another component that's kind of
important to know about if only because
it allows you to pull some pretty neat
tricks depending on the type of UI that
you're creating so the recycled view
pool would normally be just be an
internal implementation detail where
we're holding extra view holders of the
different types like we mentioned
earlier but the cool thing about the
recycled view pool is that you can share
it between multiple recycler views or
even just other custom view groups that
you've written that need to do some
similar operations that need uniform
views of this type again always make
sure that you keep these scoped to a
single activity these things are holding
views views hold on to a context
contexts were inflated with your
activity
and you can get yourself into trouble if
you end up leaking those activity
contacts by accident so keep make sure
that these are scoped to a single
activity at most but you see you eyes
like this in terms of the Android
Leanback library for Android TV you have
multiple rows that are actually recycler
views held within recycler views but the
innermost child items are all of a
uniform type so what we do there is we
can share the recycled view pool across
all of these in individual rows and this
allows us to be much much more efficient
in terms of how we allocate those and
manage those pools okay so as we start
adding more function to recycle we try
to implant them as components so things
drag-and-drop if you look at this view
there's like a bunch of libraries you
need to look at the examples and only
some of them work for yours case so we
wanted to learn over from from our
mistakes when we design item touch
chapter we wanted it to be independent
of the layout so want to use item touch
upper it can do drag-and-drop it can do
swipe to dismiss and all you do is you
provide this Kovach class in the culvert
class you probably might get movement
flags this is idea I haven't beholder
how can I move this view all der because
I up on down or left and right and you
could save us what should I do when the
item is moved so let's say the user
moved it to somewhere else and then now
you need to change the adapter similar
swipe the user is swipe with to the
right when tis done we'll let you know
so all you have to do is tell us how a
revolver can be moved to actually do
what you need to change in your adapter
when it is moved or swiped so you can
actually run drag and drop and swipe at
the same time in the same layout manager
it just works
so this is the gay movement flags we
provide and make multiplied so in this
example I say each item can be move
dragged up and down and you can survive
it towards the end so it also supports
RTL C if you say and your Co legs will
receive the same things like an are tell
parameters if you use left and right
your codex will receive left and right
so you can also customize how it is
drawn in the support seven demos we have
this sample like you can make it fade
away as you swipe you just override
enter method in the callback and you
also start the drag and drop or swipe
yourself maybe you have a custom button
there try to go a little bit faster okay
we'll go through some tips and tricks
yeah really quick here and so again as
we talked about before we want to be
more efficient with recyclerview
adapters than we were ListView adapters
so if you don't update a particular item
you don't get on bind for that item
anymore we're able to just reuse that
view in place so even move operations we
don't have to go back to the adapter to
ask for that data again because hey it
hasn't changed why should we do the
extra work so we don't get it invalidate
on that view we make sure that cache
works we have happy kittens and then
what that means though as a side effect
is that since items can be added or
removed around it and items can move
when you bind your views don't make
assumptions that the position that you
were initially bound for is always going
to be the position corresponding to that
data item again this is this is a
perfect example of what can end up going
wrong you want to make sure that you
access the position live from the view
holder itself the view holder knows
knows what's going on there in this case
yeah there we go the view holder knows
what the adapter position is right now
so we make sure and keep that updated
for you so you don't have to track it
yourself but make sure that you don't
accidentally close over the value of the
adapter position by accident by you and
the studio has a lead rule now so
will not let you do that but so use item
change with payload so when you man item
changes like the time change our user
liked it use it with the payload it will
make your online a lot more efficient
you can run better animations so in the
online method you can just check if you
have been passed payloads so if there's
no palos fully binders any beholder if
there is payloads we guarantee that that
we holder is being reused for that
position so you don't have to set
everything you only set what has changed
and you know that information from the
payload it's very efficient is great for
animations another mistake we see
commonly like you have a header field
when we ask for the header will you
return the same one don't do it if we
called on crate that means creating a
wheel holder don't try to return us the
same if you have because you will have
bugs we wouldn't call that method if we
didn't need it the idea never do like
something like this if we ask for you to
create create any one adapter versus
layout positions is something we
previously mentioned but say real let's
say you moved an item at this point you
can see the adapter positions and layout
positions or some items are different
until the next layout is calculated
because they are so calculated as
synchronously so once the view system
tells us or canonical refreshers are we
refresh it now all of the items have the
same layout position and adapter
position so adapters position is very
good if you need to access your data
layout positions very good if you want
to know what is above and below at the
point that user click something right
and I thank you yes</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>