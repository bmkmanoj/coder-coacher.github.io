<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building battery efficient apps (Big Android BBQ 2015) | Coder Coacher - Coaching Coders</title><meta content="Building battery efficient apps (Big Android BBQ 2015) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building battery efficient apps (Big Android BBQ 2015)</b></h2><h5 class="post__date">2015-10-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LO_Swql0zVg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody
my name is Ron I'm from actually I'm
from Israel and I lead the develop
relation art in Google Tel Aviv and
today I'm going to talk to you about
battery and how we can be more efficient
in their matter but first I would like
to make a quick poll looks familiar
anybody use this raise your hand okay
what about this code snippet anybody
wrote something similar to this opening
HTTP connection fetching some website
raise your hand guys okay let's do this
anybody didn't write something like that
get out anyway okay so you must be
asking yourself hey everybody's doing it
what's the big deal here why we've got
this weird guy I'm talking now accessing
the network fetching some data over the
Internet is commodity everybody's doing
it what's what's the big story here well
turns out that accessing the network
like opening HTTP connection or
especially on them on seller networks it
has a significant impact on battery life
in fact that's the number one battery
killer today if you would check and see
what apps are doing what's killing your
battery what apps are actually doing on
your phone that kills your battery it
won't be GPS it won't be the screen it
will be network okay it's true GPS is a
pretty good battery hugger but most of
the time it's off while accessing
network apps are always accessed in the
network and today we're gonna fix it and
if you still ask yourself why we should
care about battery life I can share with
you a research that we've done in Google
it took us years to conduct this
research and we learned that when the
phone is dead
there's no battery the phone is dead the
user is less likely to use any up
yours as well okay so you way may want
to keep the phone running a little
longer so the first thing that we'll do
we will try to understand how things are
working under the same under the behind
the scene under the hood how solar
networks are actually working so turns
out that wireless phone like this one
are actually wireless there's no cable
here right we rely on radio transmission
radio communication back and forth from
the from my cell phone to a cell tower
to a base station which is located out
there it means that inside the phone
there is a little chipset with radio
transmitter and receiver that transmits
radio frequency radio communication to
the base station which received it
communication process it and send some
stuff back now every communication every
time we want to send something we need
frequency we use frequency and frequency
is expensive because frequency is
limited it's a physical resource it's
not like IP we're running out of IP
addresses let's make ipv6 and suddenly
we have more it's a physical thing it's
a physical limitation think of this room
there is only so much space inside this
room I cannot put 1 billion people
inside this room just not enough space
same thing with frequency we don't have
enough frequency and actually the cell
tower cannot speak and communicate and
talk and allocate frequency to all 200
percent of its clients 100% of the time
simply doesn't make it so instead the
cell tower at any given moment decides
which clients which customers which cell
phones will get frequency he allocates
frequency dynamically over time to
different clients to different
subscribers and this way they
communicate just to give you a rough
idea we're all here in this convention
we're probably all registered with the
cell tower which I don't know about half
a mile away and typical cell here in
this area
will serve I don't know about 2,000
people to thousands cellphones but it
can only talk to eight or twelve depends
on the on the technology in modern
country actually it's 16 but in United
State this kind of falling behind when
it comes to cell networks so over the
years different technologies have
emerged to optimize specifically that to
make the allocation process much faster
more efficient basically to get more
bits per Hertz we're talking about HSDPA
G's UPA what you guys probably know is 3
point 5 to point 7 5 generation or or if
the amino FDMA which is LT or 4G this is
how the radio state machine inside any
cell phone in this room looks like this
is what happens when we want to make a
transition transmission when we want to
send a bit over the Internet now it's
it's a pretty self-explanatory diagram
ok so we can move forward I see this guy
here with a question mark above is it oh
no ok I made a simplified version ok
let's think that we have three states
the first one is idle in idle our radio
has zero throughput no frequencies
allocated to it we can transmit even one
single bit but we're hardly using the
battery we're hardly using any power
only two milliamps which is practically
nothing now if the user opens an app and
that app wants to send something to the
internet and receive something we need
to move from idle to this age this age
stands for dedicated channel in this
mode the base station actually allocates
frequency to decline to this to the cell
phone in a constant manner and a
periodic interval like clockwork
allocates frequency in that mode again
to make things easier to digest we have
high throughput but we actually consume
a lot of power now let's say we're
getting those that frequency and we
transmitted whatever we needed to admit
an out the cell the cell phone doesn't
need that much bandwidth the network
understands that and the base station
tells the cell phone hey moved from this
CH 2 F ACH FEC H stands for forward
access channel frequency is still being
allocated to the cell phone but not like
before not like clockwork but every once
in a while we get frequency we will be
able to transmit and receive in other
words again just to make it schematics
that say that we've got half of the
bandwidth and we're using half of the
power running in this mode until we
don't need we were done with the network
we don't need the network anymore and
then the cell tower tell us hey move
back to idle were you actually you're
not you're not consuming any frequency
and that frequency can be allocated
elsewhere
now those transitions actually they
don't happen right away they take time
it takes about two seconds to move from
idle to dch think about it user opens
your app your app wants to fetch
something from the internet the user
actually waits about two seconds before
you are able to send the very first bit
and it happens a lot
furthermore in DC age it takes the
network some time to understand that
this specific line that were allocated
free allocating frequency to it doesn't
need that bandwidth is not using it okay
about eight to ten seconds depends on
the configuration of the network and
same goes with FEC age now those tail
times that's basically frequency that
has been allocated and nobody needs it
nobody's actually using it that's waste
of frequency which is a huge problem to
the AT&amp;amp;T Verizon's of the world but we
need to remember another thing in
cellular network there is no such thing
as being quiet which means that if a
frequency has been allocated you must
transmit something I got a cell phone
move to this eh did whatever trans
transaction it means needed to do get
the frequency now that the cell phone
doesn't have the app doesn't have
nothing to
but the base station still allocates
frequency to that phone that phone has
to transmit something what do we
transmit random bits zeros and ones we
have to transmit something there are a
lot of reasons why to do that I'm not
not going to go into it right now this
one you can ask me afterwards but a
black bottom line that we understand now
that those tail times from this age to
officiating from F is FSH to Idol this
is pure energy that goes to slash def /
now okay that's energy that we just
throw away with transmitting something
transmission transmitting something is
very expensive battery wise when it just
goes away so now that we understand how
those networks operate we can ask
ourself what does it mean to us as
developers and at the end it all boils
down to two main things that we as
developers need to focus on less radio
less data that's what we're gonna talk
about today first thing I want to go
over some common mistakes that we've
seen lots of people in lots of apps
doing and it's time to put that to an
end
first thing periodic traffic now we're
used to do periodic traffic let's say we
want to upload analytics or do location
updates or just you know keep alive
okay sent sending a heartbeat messages
back and forth to notify the server that
were still alive
here's a use case from a music streaming
app that we've looked at this is a
screenshot from a tool called arrow that
was developed in AT&amp;amp;T when I was there
I'm gonna show that to later and
elaborate on it a bit more and as you
can see basically what this tool does it
looks at the network request and it
analyzes what the ready state was and as
you can see the music file in that music
streaming app was downloaded as one big
chunk at the beginning okay it were in
DC age and we're good but then every 62
seconds the app actually sent about a
payload which is about two kilobytes
of data to the server analytics what is
the song the volume what the user did
were foreground were background stuff
that they wanted to know and every peak
here every 62 seconds we actually moved
the radio from idle to DC h FS age and
back to idle that's a lot of energy that
was wasted how much is a lot turns out
that 0.2 percent of the data actually
consumed 46 percent of energy we talked
with them back then that is three years
ago I think they batched
the analytics to piggyback that on there
when the file is being downloaded and
they actually reduced battery
consumption by half which is amazing
second anti-pattern is multiple
connections everybody is doing it
including myself ok we need to download
several images from the website we will
open several HTTP connection and we'll
do multiple gets from that website but
here's another thing that I didn't tell
you about till now in cellular network
every TCP connection introduced some
overhead because it needs to be
encapsulated so we're adding bits at the
beginning at the end of the packets
which mean that every TCP connection
reduces the overall throughput that we
have if I have a radio channel a
cellular channel here that can give me
one megabit per second and I open for
TCP connection at the same time I'm not
gonna get 250k each I will get less
around 220 20 KH that means that we have
lower throughput the user needs to wait
longer for the data and it also means
that we're spending more time in this
age or FSH mode means meaning draining
the battery third anti-pattern is
duplicate content basically downloading
things that we are already know okay
first problem is when the app download
something from the server and that
something doesn't have any caching
information so the app can't cash it
let's say the app downloaded me an image
the image doesn't have caching
information the user
since that exit the app in two seconds
seconds two seconds later he goes back
to the app we go down we go back and
download the same very image that we
download two seconds ago waste of time
waste of money waste of battery the
solution is to use headers the right
headers like Max age or expires when you
send something to your client and then
the client can can can use it second
problem is that content with caching
information the cache hasn't expired but
it is being downloaded anyway by the
client we've seen there happens a lot so
when we write some code that goes and
fetches an image of Elena we don't
actually check if if that content has
expired or not so the solution is simple
don't do it okay
I don't believe it you're leaving me
okay friends anyway third problem
content that has been downloaded cached
by the client the cache expired okay but
the actual file hasn't been changed on
the server side it's the same fine so
usually what the client will do it will
go in say hey my local cache is expired
let's download that content again but
instead the client can use an if
modified since header and then if the
content hasn't changed on the server
side the server instead of sending that
image back we'll send a 304 not modified
and then the client knows that hey my
local copy is still valid I can use it
instead of downloading a big chunk of
image or whatever we're downloading very
small only headers only the HTTP header
last anti-pattern connection management
so I know that most of us are using HTTP
URL connection or okay HTTP or whatever
a library that gives us transport layer
but in some cases we need to actually
take care of connections ourselves to
deal to do some low-level operation and
the socket level if we're doing voice
over IP or sip or whatever
and we've seen several mistake mistakes
there the common one is that we open a
connection we use it and then we don't
close it we don't call socket close
because we think that hey the TCP will
timeout and that this TCP stack will
close the connection for us and actually
it does but what happens is that in
order to close the connection we need to
send TCP reset to the other side and in
order to send that TCP reset we fire up
the radio from idle to DCH to FSH and
back to either let's waste of energy
okay
another common name problem is that when
we open the connection just to have one
ready for when we need it in the future
and then we fire up the radio just for
the three-way handshake since in our
Kanak so if you do need to learn to
manage your connections yourself open
connections only when you need them you
use them as much as you want you're done
with them please close them so now that
we've covered the common mistakes that a
lot of people are doing I want to talk
about some advanced techniques that will
help you to become better a new member
our goals are less radio time and less
data now it's easy to say it's a little
bit harder to implement because when you
think about it in our app we're dealing
with many many many transactions there
are so many code passes that will lead
to a transaction to a thread that will
fire up a network a transaction it's
very hard for us as developers to say
which transaction happens when and how
to do with it
so in order to make things a little bit
easier I decided let's what we're gonna
do we're gonna categorize network
requests to three different buckets
first there is the stuff that the user
asks us now the user clicks on the
article and wants to read that article
he wants to get into that specific post
or whatever we need data right now for
the user we need to go now and bring the
data in order
display that to the user second type is
those small data updates that we need to
send to our servers when or while the
application is running again like
analytics or location updates and
whatnot
these are usually will be small payloads
and there will care about them only when
the app is actually running the third
type is there is when we want to send a
relatively big chunks of data to the
server in order to sync let's say
uploading a bunch of photos or doing
email sync like Gmail does or contact
address booking contact list things like
what up does okay we don't really care
about exactly when that transaction will
happen it's big chunks and it usually
happens in the background now
the second and third types we can
optimize by batching and the first one
can be optimized by prefetching and
we're going to talk about these two
techniques now so let's start with
batching batching basically would take a
bunch of transactions that happens over
time and for every transaction we
actually pay a Radio transition stage
okay those transitions from this age to
FECA to I they're not gonna say that
alot today and we batch them together so
we pay the overhead only once now this
is the way to do that is by simply when
you have a network request don't execute
it immediately simply send it to a queue
okay it can be a very simple queue or
something more complex like I don't know
content provider I can even see realize
that transaction to the persistent
storage so you won't lose it if the app
gets terminated now you would ask
yourself when do I put my queue when do
I actually go and send that so an easy
answer let's say when we reach treasure
let's say I don't know ten transaction
in the queue let's bash them together
and send them out there works but when
we think about it actually our phone is
doing a lot of stuff in the system and
there is very good chance
that another app will use the radio
before the threshold is reached so we
would really like to get notified when
somebody else is using the radio the
radio is always already hot it's in this
edge mode why don't we piggyback on that
why don't why it's it will be very good
idea for us to piggyback on that and
transmit and that's exactly why we
introduced job scheduler in lollipop how
many people here use job scheduler okay
you're in the right room okay so how do
we do that basically we specify job ID
the job that needs to be done and some
constraints like what network type way
do we want and time and actually we can
say hey some extra content constraints I
want that transaction to happen only
while we are charging but job scheduler
was introduced only in lollipop what
happens if you're running on 3m devices
so first thing first thing you can do is
use sync manager and sync adapters sync
adapters are great for those third type
network requests for those cases when
you need to upload a bunch of stuff to
the server or to sync data from your
phone to the servers now things that are
not time critical and usually huge loads
of their big chunks of data okay this is
what Gmail is using to sync Gmail this
is what the address book is using this
what whatsapp is do using basically how
do I can't think of an application that
actually sync something they're not
using single app turfs so since sync
adapters are great for the third type
but what happens with the second type
those small data updates that occur
while the app is running sync adapter is
just wasn't built for it and it
introduced a way too much overhead for
those we have GCM network manager which
is very similar to job scheduler
basically let's say we want to schedule
a task that will run from I know what
from five minutes four
now to 15 minutes from now you specify
the task and you just need to override
the single method and when you inherit
from from GCM task service and you need
to return is a result successful result
failure or result reschedule if you want
to debug when you're running with the
GCM network manager you need to somehow
create that trigger to tell GCM in
network manager here I want you to
trigger that task I want to run it and
there is an ADP command for that there
are some caveats and limitations so you
better go to the documentation to read
about it a little bit but basically it
works and it's great now let's talk
about prefetching if in batching we
wanted to grab fuel transaction together
and wait until we have enough and set
them together prefetching is all the
other way around basically what happens
user opens the app we fetch some data
from the internet the user looks at the
data he will do it in the meantime the
radio goes back to either and then it
clicks on something and we go and we
fetch some more data use a seed and then
it clicks on something we go and fetch
some more data and so on and so forth
prefetching is all about predicting the
future predicting what data we will need
during this session what data the user
was likely to ask us to download for him
and actually download it now before he
even asks for it think about it well not
only were improving battery life
dramatically
we actually improving user experience
because when the user actually clicks on
something the data is already there he
doesn't have to wait for it to be
downloaded first question how much data
do we prefetch it's a tough one so a
quality prefetch will fare on a 3G
network will be I don't know around
between one to two megabits per second
on faster networks like 3.5 or 4G we
could go up to 5 megabits of data but
there is another way to look at it since
it doesn't make any sense to prefetch
data that the user doesn't
or did the user won't see actually we
can think of it from a different angle
and say hey let's fetch enough data for
the next minute or two minutes okay
that's usually the average session
length in application depends on the
application category so actually I
really encourage you to go to analytics
and look how much time users spends in
every in in session in your apps and
then you can optimize specifically for
that time so that's a good that's a good
approach and algorithm but we can
improve it a little bit and be adaptive
let's say we want to look at what the
user is doing and what the device is
doing for example do we fetch more of a
Wi-Fi hell yes do we fetch more while
charging
of course we download the Internet while
charging I don't care
fetch less while the user is walking for
sure because users when they walk their
attention span to our app is lower every
session type when walking is around 20
25 seconds which is a good thing because
if it was 2 minutes like when we're
standing people will you know get into
parking cars or fall from Cliffs or I
don't know what will happen to them okay
fetch more when the user is driving
depends if your app is all about
I don't know road blocks and the hero
moment of the app is what the user is
driving yes if the user is driving fetch
more and you can actually tell what the
user is doing if it's driving if it's
walking if he's cycling by using
activity recognition API which is in
Google Play services do we fetch more
for fast Network if we're in 2g let's
fetch less if are in 4G let's fetch more
let's say 2 etcetera but we talked about
the TV itand and how and how much to
prefetch and how to change the amount of
data that we prefetch now I want to ask
you another question and take it and not
chop when to prefetch what do you think
when to prefetch when is the right time
to profit that's actually a question you
cannot when we're downloading data
anyway that's that's a good place to
batch actually prefetch is predicting
the future
what logging when the user opens the app
user logs in or user opens the app
that's a good place to prefetch yeah hmm
at night at night it's not a really good
good idea because if the user opens the
app at noon publish the data from the
night is you know already obsolete but
we're going to talk about BG updates in
a second so actually the right answer
the optimum point in time to prefetch is
right before the user opens or up think
about it we save the user those two
seconds from idle to this eh
he opens the app and the data is already
there no need to download anything no
need to refresh the app is fresh to up
the data is you know right where it
needs to be the only problem with this
approach is that our crystal ball API is
still in beta and we haven't released it
yet
so but you can get to the early access
I'm just kidding so instead we need to
take a different approach and that's to
do background updates similar to what
you said let's update at night or when
the user is not using the app so when he
will use the app the data will be there
now background updates I the check to
can be very very tricky and we need to
ask ourself what we update and how in
order to make that process efficient and
effective efficient means that we don't
want to pull the server and say hey is
this something new there's something new
and actually drain the battery really
really quick and effective we don't want
to fetch data that the user won't see
okay the whole turkey
the whole thing here is to fetch data
that the user will want to see predict
the future so in order to understand
what to update I again segment the
content to three different buckets the
first thing is the what's hot okay this
is the data the information that users
are most interested in this is why they
have download your app at the first
place if we're talking about the news
app there will be the top headline if
we're talking about sports app that will
be the current scores or you know live
updates from the game okay this is the
data that users care most if you don't
know what they what the data D is what
most in your app a it's a shame B go to
analytics and take a look what users are
doing and then you will find out the
second bucket is that interesting stuff
this is stuff it's not in the hot what's
hot but it's stuff that the user told us
that he's interested in for example if
it's a if you're talking about a news
app maybe we have a user that is very
interested in the final section and
another user who's very interested in
the I don't know science section ok or
political section so these are actually
told us hey I'm interested in that
information it's not common it's not for
all the users but specific users told
that hey this is interesting for me and
then there is all the rest of this stuff
now when I look at background updates
I'm thinking of alright let's take a
look how we update every each piece of
content so for what's hot my server
knows that something changed there is no
new headline new results form from the
game something new happened the server
can actually send us a GCM message with
the data embedded in it we can carry a
payload of up to 4k if I'm not mistaken
in every GCM message and actually our
client the app can get this GCM message
we don't show anything to the user we
don't pop up notification nothing we
take the data and we store it in our
internal database when the user will
open the app all the words up is up to
date
it doesn't need to wait if we
one single millisecond to see that when
it comes to interesting stuff we can't
use the same approach because we can't
send everything to everyone all the time
we take a different approach basically
the server will tell the users via GCM
that something has changed okay let's
say something has changed in the final
section all the users that said let's
start that said final section dates in
their favoritest will get a message
saying hey the app will get a message
saying hey something there is new data
in the final section and then the app
will use back off to pull that data and
it will look let's say and now could be
it could it can go in two different ways
option a we get this GCM message
something has changed we wait a little
we go we fetch the data and then the
user opens the app perfect we predict
the future another way that this could
end can go it's in the other other other
way around okay
so we get the GCM hey something new we
fetch the data and use it doesn't open
the app and then we get another GCM
something new happened and we fetch the
data and then the user opens the app
means that we have we've had redundant
updates we've wasted bandwidth requested
energy in that case when we identified
and it's very easy to identify in those
cases we basically increase our back of
exponentially until we reach to the
right amount so there are users that
will open our up four times data will be
used as that opens our up two times a
day
we will pretty easy we'll find the right
frequency to those background updates
and all the other stuff we simply update
that when the user opens the app it's
not really it doesn't really matter we
can't really predict that the user will
want that data okay third technique we
talked a lot about reducing radio time
now let's talk about
reducing payload size here's a test
there are two images on the screen who
thinks the image on the right is higher
quality to people who think the image on
the left is higher quality three people
who thinks I'm fooling you and it's the
same image most of the people okay
thanks for the trust guys okay actually
one is 45 K and the other one is 160 K a
third and no one here in this room could
actually tell hey this one is better
than a one we can save a lot by
compressing our images correctly we
don't need to go with 100% quality in
JPEG actually if you look at check the
quality for the leading sites Google
Facebook Yahoo etcetera etcetera this is
how the big guys are doing why don't you
do the same and since it is big Android
BBQ and Colt is what's supposed to be
here it's not here right called
good so we can skip this slide you don't
need to go to see all right let's talk
about application resource optimizer or
arrow arrow it's a tool that was
developed in ATT and several years back
when I worked there and I think about
two years ago we've open sourced it
what is tool does it basically it
monitors all the network transactions
and activity that we have that happens
in our app and it analyzes what the
radio state would be for those
transactions it also runs a lot of tests
against those empty patterns that have
just show you earlier today and gives
you an easy to digest report how are you
doing okay so give me one moment to
arrange my screens here and we'll be
able to actually see it okay
so another second and this is gonna be
challenging because half blind
it's alright okay so I took an Israeli
application so no one will understand
anything because the content doesn't
really matter and here we can see on the
screen and the report and there are a
bunch of tests that it will did and
obviously green means good red not that
good and you know that you need to fix
those those items whether it's duplicate
content or connection management or
content not being zipped stuff like that
but we can do some more with with with
the tool it's extremely hard to see from
here we have an overview tab which
basically tells us how much energy we
consumed how much energy was wasted on
on Radio transitions on signaling etc
etc but the most interesting part at
least for me is this screen basically
what we see these are the screen shot
that I showed you earlier we can see
here the transactions we can see the
transactions and actually the packets
that were sent and if we look into any
single point of time we will see on the
right side the the actual screen and
what happened during that time so during
this splash screen we can see here what
packets have been we've downloaded what
we sent and we can immediately take a
look and see that we were on DCH went
down to officiate back to this e8 down
all that transaction all those small
transactions would have been backed into
one single big one and save a lot of
data and a lot of battery let's take a
look at this area so the user clicked
here on something and he actually
entered these article this is a news
application in Israel okay again you
don't need to read what's happening
there
now I can see some transactions here
okay and if we'll go down and look we'll
see that we actually downloaded the
article and the images but over there
there is another transaction I don't see
my pointer I've got a point anyway
already there is another transaction and
I don't understand why it's there okay
and obviously that I think it should
have been patched so let's click on it
what changed use it did user season is
to anything different they add exactly
so the user action was actually reading
the article the ready went already to
idle state and just to change the add at
the bottom we fired the the radio from
idle to this CHF ACH and so on so forth
we wasted a lot of energy a better
approach will say hey give me five ads
and then the client will rotate them
without going to network every time so
there's a lot in this tool it's very
hard to be set up to actually go through
over it but I really encourage you to
try it it's called application resource
optimizer
arrow you can find it on github you can
compile it the zip file apk is
everything you will discover wonders on
your app if you will use it
yeah this is the this is your best
friend
start here see what your greens do what
you read in all the words actually if
you click on them you get some nice
explanation here you're doing this
you're doing that and even with in some
cases not all of them pointer to the
actual packets that you know misbehaved
all right and then you can actually and
in fact if you only fix very few things
in your code you will see a tremendous
improvement just like get rid of all
these periodic bursty traffic and
probably have one process or maybe two
that are doing that okay or improve
prefetch or let's do some batching let's
do a transport layer that will batch
some background requests etc etc and
you're there okay alright so we do have
some time left for Q&amp;amp;A so feel free to
ask whatever you want
actually yes yeah the question was can I
see when the radio is hot or what's the
state of the radio actually the question
is yes and no you can see that in
Android you can see it in your code
there is an ADB command if I remember
correctly it's ADB - B and then space
and radio check the documentation you
can tell adb you can take the log cut
from which buffer to present the log and
there is a buffer for radio and when
while you're running and your phone is
connected to your computer you can
actually see in the log file of the
radio when the radio what's the state
etc etc so if you want that during debug
to take a look perfect but while running
and checking in your code what's the
status of the radio you don't have
access to it that's why you have GCM
network manager and the job scheduler
that will do that for you
the question was can I run this tool
arrow in continuous integration and
automated testing environment actually I
haven't tried that so I don't really
have an answer on that there shouldn't
be reason why not - the only problem
that it's well actually when I think
about it okay
so arrow the way it works you have data
collector first to collect the data and
then you feed that data into the tool
that I just show you which is basically
the analyzer now the data can be
collected by using a specific apk or you
can actually feel it
Wireshark dumps TCP dump okay so in your
automatic testing environment all you
need to do is run TCP dump and dump
those pickup files and then in the
morning feed them to the analyzer and
you immediately immediately will say if
there is a regression or not another one
yeah
mm-hmm
okay so in seller Network every TCP
connection is actually encapsulated
which means that the seller read you
here and in the base station they add
bits at the beginning at the end of that
of that payload so we actually add more
bits that we need to transmit back and
forth therefore we reduce we reduce the
overall throughput the reason for that
is that seller network we often I don't
know what the political will to do that
to say that we often fake the TCP state
alright so think of it think of it this
way my phone opens HTTP GET request - I
don't know - a server or TCP connection
to a server and I want to keep that TCP
connection alive that means that the
phone is to send TCP ack messages back
and forth now the cell network doesn't
want those TCP acts they don't add any
value to the user there are not actual
payload they just waste off frequency as
as I told you frequency is extremely
important to network operators so what
they do actually behind the base station
some are at the base of the cell tower
there is a big machine that looks at all
the TCP connections and when that
happens when we open the connection that
machine will start talking with the
server and it will send those TPA
TCP acts on our behalf so we can shut
down the radio we can stop allocating
frequency that's cellular phone but the
TCP connection is still alive and what
that server will want to send something
to the to the phone you actually send
something to that big box that sitter
it's called a SM gateway and that box
will then tell the base station hey we
have data to that phone give him
frequency and transmit that data so
basically because we needed to do that
there is encapsulation for every TCP
connection
thus we reduce the overall throughput
when we were adding connections
it's yeah the best practice is actually
moving from it HTTP 1.0 to HTTP 1.1
which is persistent connection so you
open one connection and you run multiple
get requests on top of it so I don't
know what retrofit is using me under the
hood I can tell you that ok HTTP is
perfect so I'll catch TP actually use
persistent connection by default unless
the server doesn't support it which is
great the only thing that you need to
make sure is that you don't open several
or that you minimize the amount of HTTP
connection simultaneous connection that
you open ok any more questions
all right so I guess we're done here
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>