<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Android for Java Developers (Big Android BBQ 2015) | Coder Coacher - Coaching Coders</title><meta content="Android for Java Developers (Big Android BBQ 2015) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Android for Java Developers (Big Android BBQ 2015)</b></h2><h5 class="post__date">2015-10-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3R45xnCITFs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning and welcome to Android for
Java developers this talk is a wrap
around a series of very long articles
that I hope everyone will read
eventually called developing for Android
so if you go to medium.com and search
for that phrase or if you just go to the
internet and search for that phrase
you'll wind up on the series of 10
articles these came out of an incredibly
long dock that we wrote internally at
Google when we were faced with a bunch
of app developers we would meet with on
a regular basis and someone said so
every time we talked to the framework
team and we say we're doing this thing
and then the framework team says no no
no don't do it that way do it this other
way instead and then they'd go away and
they do that and they come back with
another question and we would say no no
that you shouldn't do that what you
should actually do is this other thing
instead and they said ok so where do we
go for the information that sort of
collects all these tips and tricks and
techniques so that we can stop getting
slapped by the platform team for the way
that we're approaching this stuff so
that was the genesis of the article we
decided to actually take a step back and
say ok what are all the things that we
think are obvious but typical Java
developers do not and the problem is
that a lot of developers most developers
writing Java code at Google come from
the server world or even you know the
desktop world sort of traditional Java
platform and then they say ok well this
is the same language so I'll carry over
all my patterns and practices from that
other world into this little tiny mobile
device with a constrained CPU GPU memory
limited memory a limited bandwidth like
very very different programming
environment really the only thing that
is the same is the programming language
itself so the way that you use that
programming language is very important
in terms of the performance and the
experience you're going to get in the
end result of your application so we
wrote this huge article we put it out
internally and then for the short
attention span public we broke it into
ten still very long articles on medium
so please check those out in the
meantime I wanted to walk through some
of those today if if I tried to go
through everything this would be about a
three hour talk we tried
once we gave a talk at a user group in
the Bay Area and we put together this a
version of this talk and we made it
about a quarter of the way through in an
hour and 20 minutes so yeah actually
three hours is an underestimate as well
because each of the topics like their
little tiny bullets but they're kind of
deep crevices that you can go on at
length about so I thought instead today
instead of trying and failing to cover
everything that those articles cover I
wanted to talk about the memory
situation because a lot of the
performance concerns and a lot of the
problems that people hit are in the
specific area of memory that's really
where a lot of the performance problems
and bottlenecks come from partly because
the runtime and the garbage collector
are vastly different than what you might
expect so I wanted to start out first by
talking a little bit about how garbage
collection now occasion actually works
on Android and then we'll talk about
some of the tips and tricks about memory
in particular and then maybe we'll talk
about some other stuff as well we'll see
how far we get so first of all I want to
mention that's one of the important
things that we see in terms of device
usefulness or application niceness is
what we call the tragedy of Commons and
this is an effect where every
application will work in its best
interests it will be necessarily greedy
because obviously if someone has
installed my video playing application
it's really important to them for them
for the the user to actually watch the
videos in my application so I'm going to
sync all the time and I'm going to make
sure they get the most up-to-date data
and I'm gonna allocate tons and tons of
memory so that I have all the stuff
cache and it's just ready to go all the
time the fact is the user has many many
applications installed yours is one of
them and if it's too greedy yours will
not be one of them for long right if
every application acts in this way and
they do tend to by default then it makes
the overall device experience suck right
if every application is allocating too
much memory if it takes up too much heap
if every process is huge
then the task manager will continually
be killing all of the background
applications in order to make the
foreground application have enough
memory to run itself and then when your
rather greedy and bloated application
goes into the background and the task
manager says well I'm running out of
memory
I better go look for some large memory
users it's gonna find yours and it's
gonna kill it and the next time the user
goes back to it it's gonna have to
relaunch and do a cold start because it
was killed right wouldn't it be nicer if
all the applications were more slim and
trim so that whenever the applica the
user switches between them they can do
so easily because they just have to page
them in instead of actually reloading
and relaunching everything from storage
so there's there's sort of two effects
that we see there's the tragedy of the
Commons where every thing is greedy and
then there is the every device as a
village so not only are all the
applications greedy and they are
suffering for it but then the overall
device is suffering for it you know now
the user experience from all these
greedy applications on the device is
that they're constantly relaunching all
of the activities there or some service
running in the background is sinking
causing performance problems and the CPU
to be doing things for absolutely no
reason whatsoever I'm not using that
service right now I haven't used that
eReader for a month why is it actually
sinking in the background when I'm
trying to use another application in the
foreground so these two effects are very
interrelated and contribute to the
overall user experience of Android so
that the goal of this article and of
these tips and practices in general is
to help application developers write
better applications so that we can make
the overall platform better so let's go
talk about memory 3 dynamics to be aware
of is that memory is limited and this is
far more limited than you might realize
living here with our less constrained
financial resources and more available
technology we tend to think of like one
gig as being the low ends you know there
are devices with two gig or more readily
available so surely this is what people
have in the real world in the real world
low-end devices are a still being used
because they were sold several years ago
and people don't just ditch devices for
new ones unless they're like the people
in this room maybe they don't actually
you know have enough money to go buy a
new phone whenever they're excited by it
so they may keep that device around a
lot longer than you the developer want
them to so they're running with a low
memory device because they bought it a
while
but that the more insidious dynamic is
that there are still devices being sold
with low memory in markets where money
or technology is not as readily
available they may be selling these
phones to people that you know are
really excited about getting this new
device that only has 512 on it right not
much memory it's a new phone what are
they doing coming out with that amount
of memory well this is the configuration
that made sense in that market and there
are a lot of these phones still being
sold out there so even though you are
running a device that you don't consider
high-end and you think the memory
problems have gone away they actually
haven't and they're gonna be here for a
while because of those two dynamics so
it's very important for you the
developer to realize there are these low
memory situations and to make sure that
your application behaves reasonably well
when one of those situations occurs for
the user the other issue is I alluded to
before is that that memory is shared
everybody is swimming in the same pool I
don't really like that metaphor so
everybody has to behave if you want the
overall experience to be good if your
application is greedy and every other
application is greedy the entire
experience of the device will be
horrible right because everybody is
constantly going to be shoving everybody
out of you know CPU cycles as well as
memory and then finally memory equals
performance and this is the one that I
want to spend a little bit of quality
time on today and explain what we mean
by that so first of all let's talk about
memory let's talk about the garbage
collector and how it actually works and
why we see some of the performance
issues that we do so there are three
things that cause memory to be expensive
in terms of performance on Android one
is the allocation the process of
actually creating memory for the new
objects that are being allocated the
next is concurrent collection or just
collection in general and we actually
need to clear things out so that we can
make room for other allocations that
need to happen and then the third tends
to be the most painful one which is
collection for allocation if anybody has
taken a look at log and looked at the GC
information in there this is commonly
referred to as GC for alloc it's a
situation where you go to allocate
something there is not a free space
in the heap and then the garbage
collector needs to run synchronously
right then to free up enough memory to
store your object there so let's go into
some of the details there we can see the
four phases of normal allocations and
collections here you have this new
object on the left next to the squiggles
and we need to find space for that Oh
fortunately there's a space right there
well we'll pop it in at the top this is
an unusual situation where it was really
easy to do that so once that's there
then we enumerate all the objects to
figure out what's still referred to in
the heap you can see the red one doesn't
have a reference there we mark all of
those to make sure that we know what
things are still referred to and what
things can actually be collected and
then we collect and you see the red
object goes away there because there was
no reference to it so we can collect
that now and free up space in the heap
okay so on dalvik there's actually two
pause times that occur in the normal
process of simply allocating and
collecting there's a pause time to
enumerate so we basically stopped the
world the GC thread runs alone in the
process everything else is paused while
it figures out what the things are in
the heap during the enumeration phase
and then there's the mark phase where at
the end of that so it'll mark all the
things to figure out what doesn't have a
reference there and then it needs to run
one smaller mark phase at the end of
that in case there were allocations
while that concurrent marking was going
on and there's another pause there so
there's a large pause potentially in the
enumeration phase and then there's a
smaller pause at the end of the mark
phase and then it can collect everything
and it does that concurrently in art
it's a little bit different we
eliminated the first pause that there's
no synchronous pause during the
enumeration phase it can do that
concurrently there is still a small
pause at the end of the mark phase is a
little bit smaller because there's been
a lot of optimization work going into
the collector in art so it's better in
art but we still have a pause there and
I should point out too that like even
when there's not a pause here there's
still stuff happening right so all of
this is causing CPU to do things in the
background whether it's I just turn down
the audio on my screen so look out even
even if it can happen concurrently it
still means it's happening
you're still taking up cycles to do
these things and in general it's it's
good to not spend the cycles if you
don't have to okay so now let's talk
about the one that's more problematic
this is the GC for alloc situation where
a new object comes in and we pop that
onto the heap and another one comes in
and we walk down the heap and we look
for space in there and there is no space
right and then we have to actually run a
GC synchronously we stop the world so we
got a huge pause in the middle while we
actually go and free up the stuff that
we need to in order to fit this into the
heap and then we can put it in there and
go on about our business and the GC for
alloc tends to be painful both in terms
of time on dalvik this can take 10 to 20
milliseconds which is easily more than a
frame so you're gonna skip potentially
skip an animation frame in the middle
and cause a hiccup and then they're
totally lost my train of thought yeah I
just gone come on it turns out you
should sleep at night so it also means
that none of your other stuff is running
right so it's just gonna pause in the
middle it's gonna do all this work and
nothing else can happen at the same time
so in general that's a good thing to try
to avoid art makes this a little bit
better no a lot better because it has a
separate heap for large objects one of
the causes of of having to do too many
collections was that all of the all of
the objects were stored together so
you'd have these little tiny temporary
objects you know knew of you know object
or float or integer or whatever and then
you'd have this bitmap taking up a
massive amount of space in the middle
and it would just it would cause the
heap to get really large the amount of
space that would have to be walked to be
really big and the fragmentation issues
to be much greater in the heap and now
art takes all the large objects all the
bitmaps and they live in a separate
piece of memory over there so all the
big ones go out there all the little
more temporary objects go in the main
heap and it means that there are far
less pauses it means that also that the
pauses are much smaller so whereas the
previous doll that causes may have been
on the order of 10 to 20 milliseconds
now we see pauses of like 3 to 5
milliseconds which is much better it's
way under the frame boundary limit which
is great but it's still significant
enough they
push you over the frame boundary limit
anyway so it's still a good thing to
avoid meanwhile you know while all this
churning is going on of actually
allocating objects and needing to
collect them to free up the space for
them you're also growing your heap so
the more allocations you're asking for
the more you're causing the heap to grow
over time so if you just allocate more
and more objects eventually the heap is
going to say well I'm out of room but
you're not up to your process limit yet
so I'll grow the heap there so it'll go
through a the work to do that on B it'll
take up more memory on the device to
allocate that larger heap and larger
heap means now your task your process is
taking up more memory there's less
available for the rest of the system and
you're also causing your app to be
killed because you're gonna be taking up
more space when the task manager is
looking for background apps to kill it's
going to look for large ones because
that's a lot of memory that it could
take back there's an important point to
note about this is that under dalvik
there was no compaction right which
means that when this causes big problems
with fragmentation of the heap where you
would allocate these temporary things
over time and then you would remove the
things that weren't there anymore but
the things that were permanent or
long-lived would still be in the heap
somewhere and we could never actually
get back that memory there is a certain
amount of trimming that happens under
dalvik where if we if we get rid of
enough of the objects that occupy an
entire page eventually we can hand that
page back to memory but in general
you're stuck in this situation where you
basically grow without bound the heap
gets larger and we can never really get
back all of that space even if you only
grew it to a large size very temporarily
under art this improves because we do
actually compact the heap eventually
when your app goes into the background
when it senses that it's an idle time
that it can do this operation then it'll
take a look at the heap and realize well
there's a lot of objects that went away
in the mean time and we can compact the
heap so it gets better under art but
it's still a problem right especially if
you are just the foreground a
application we're not going to
compact the heap at that time all right
so there's a few points that come out of
this there are so when you have fewer
allocations you get a smaller heat you
also get faster allocation times because
there's simply less work to do to figure
out where the free space is you get
faster collection times because again
smaller heap less things to keep track
of you get fewer pauses because there's
less to do over time and there's less
CPU usage because you're not causing the
CPU to actually continually do this you
know mark-and-sweep and collect in the
background and then overall you get west
jank especially for the GC for alloc if
you're constantly allocating things and
then you run into a situation where
there's not enough free space for a new
object then you're gonna cause a GC for
alloc which in general will cause jank
it'll cause you to miss a frame
particularly on dalvik but also on art
because you're basically causing a whole
lot of work to happen that are super
inconvenient time and then all of this
in general I would posit leads to
happier users and world peace I leave
the last item is an exercise for the
reader okay so let's talk about some of
the tips and tricks about using memory
more effectively we we meaning me and
Romo he gave a talk years ago at devoxx
and it's up on prozis.com
that goes over a lot of the details here
like some of the the sizes and
quantities involved so I would encourage
you to check out the video it has a lot
of the details behind some of these
items first of all avoid allocations
when possible one of the things that
we've seen and there's actually a lint
check for this now is don't allocate in
the middle of your inner loop in
particular if you're in like on draw and
you realize well I need to draw to this
canvas and I need a paint object let's
get a paint object so we'll create a new
paint object and we'll do this
incredibly common so there's like a lint
check for that specific pattern just
because so many people are doing this
it seems dumb you're like how how big
can it be there's only five letters in
the word paint right it turns out it's a
problem it's a it's a problem for two
reasons one
not as obvious is that the the Java
level object that we're allocating the
paint object is kind of the tip of the
iceberg we're also allocating stuff at
the native level which then needs to be
finalized and collected later which is
kind of an arduous process to go through
as well
I'll talk about finalizar later so
there's a lot of stuff that's happening
underneath paint that you're causing to
happen just by allocating a temporary
paint object the other one is the churn
that I was talking about if you are in
ondraw and if you're on draw is being
called on every frame of an animation
and on every frame you're allocating a
paint object well at some point that
means that your heap will fill up maybe
not in that animation but maybe in a
future animation at some point you're
gonna go to allocate that paint object
and it won't find enough space and then
it's gonna have to make the space so
you're in the middle of an animation
you're in your draw loop you're on the
UI thread
and GC says you know what I'm gonna have
to collect right now would you please
hang on for a few milliseconds and
that's what causes jank for the user so
don't do that when you don't need to one
of the strategies that we use internally
on the framework that I would encourage
people to look into in specific inner
loop situations like this is caching
objects so one of the one of the tricks
if you ever look at the source code or
the framework like you know view job or
any of the core classes there we will
keep around either instance classes or
in some limited cases static objects
that only get allocated lazily so when
we see the first time that okay we're
going to need a paint object or a rect
object or a point object for this
particular call if it's null we'll go
ahead and allocate it then and then
thereafter we'll just use that shared
object in a lot of cases so in the
ondraw situation chances are you don't
need that paint object for anything else
in that class so you could have an
instance variable or a static if you
want to manage it that way that only
gets used when you're actually in that
on draw method so it seems a little
silly you might as well have a local
field but because the memory concerns
you really want a cached object instead
so allocate it lazily and then use it
whenever you need to in that specific
method you have to be careful with this
obviously if you're actually accessing
that shared variable either instance or
static from multiple places that can
a little tricky so it's not a blanket
pattern just like all of these tips
these are not like hard and fast rules
but in general it's an approach that can
avoid the kind of expensive insidiously
expensive allocations that we see in
inner loops pools so object pools are
something that's traditional Java
certainly server developers kind of
walked away from years ago you know what
what the memory manager managed your
objects for you you don't need to but
because the allocation concerns that we
have on Android sometimes it's a good
idea to actually do this if these are
expensive objects to allocate maybe it's
better to actually have a small pool
with these things and keep them around
instead of having to reallocate one
every time you need it this also can be
tricky if they're being accessed from
different places in the code then
there's a bit of management overhead to
go with this this is not as easy thing
as the cached approach I was talking
about easier that's easy there's just a
single field to manage object pools
there's a bit more to it there's things
like LRU cache is that you can use to
make this easier but you know figure out
the right trade-off for your code arrays
ArrayList is pretty good I tend to use
it a lot it's it's one of the nicer and
more streamlined collections for storing
stuff there you keep adding to it it'll
reallocate when necessary but if you
just have a statically determined size
collection that you need array itself
tends to be more optimal than ArrayList
right
it doesn't need to allocate things in
there it's just got the the array itself
and then the objects that you put in it
so consider using arrays they're just a
bit more streamlined and optimal and
don't do as much turn for you no
reallocation that collections would do
automatically speaking of collections I
would encourage you to check out the
Android collections so their traditional
Java programming language collections
they're all very powerful and useful and
there's probably still the right thing
to use for large collections like
hashmap awesome if you have a really
large amount of data that you need to
store but check out a ray map instead if
you actually just have a smaller
collection it avoids a lot of the
of the boxing as well as the allocations
that are inherent in hashmap itself so
there's there's a bunch of collections
in Android there's a ray map in the
support library there's simpler a map
then there's a sparse array there's
actually a bunch of sparse things long
sparse long in sparse long in lots of
different combinations but they
basically use primitives as keys instead
of the auto boxed Java language versions
of those like you know not capital L
long but instead a primitive long
wouldn't it be nice methods that mutate
this is another pattern that I think
traditional Java programmers walked away
from years ago maybe holding their nose
in general so so let's say you want to
pass in an X Y and you want to get a
point return because you need that point
data structure to pass into some other
method right so you have this utility
function I'm gonna pass in X Y I'm gonna
get point back really stupid example you
could create your point on your own but
to illustrate the point so traditionally
you would pass in X Y and it would
allocate a point it would pass it back
to you not a big deal it's just
temporary object right again if you're
in your inner loop allocating is in
general bad wouldn't it be nice if you
didn't have to reallocate that thing all
the time that's just a temporary object
so instead what you can do is keep a
cached object in the caller and then
call a mutate a mutating version of that
method instead so instead of passing in
X Y maybe you pass in X Y and a point
data structure and then it fills in the
data structure and then that gives you
the option to you know allocate it on
the fly if you really want to or to keep
it and use and reuse a cached object
instead so if you look through the
Android source code especially in the
framework you'll see a lot of instances
of this internally where we'll pass an
erect that gets filled in during you
know layouts or whatever and this is
specifically to avoid the temporary
allocations that are necessary to pass
back richer data than simply a single
primitive to return value
and speaking of primitives we have
primitive types we really like them in
Android in general if you use primitive
types you're going to avoid all the
boxing that's inherent in using the
object equivalents so if you write a
method that takes a capital F float and
you're you know running an animation or
doing calculation that has a primitive
float when you call that method it's
automatically going to box it's gonna
create a capital F float out of it
there's slightly more overhead in
getting the value of that I'm not as
concerned about that I am concerned
about creating garbage creating the
small temporary object when you really
didn't need to so as much as you can
stick to the primitives the the
collection classes obviously use the
object types instead so you can't really
get around it there but for all of your
internal methods that aren't using
collections there's no reason to not use
the parameters instead they just tend to
be a lot more streamlined and avoid the
memory situations that we're talking
about there are a lot of language things
that you can trip over without really
realizing why iterators is one of my
favorite examples so I love the for each
syntax I don't know why it's called the
for each syntax since there's no each in
the language somehow we adopted that
that way of referring to it and then you
go looking for the primitive and it's
not there
they should just maybe call it a four so
it's very it's very convenient came out
in JDK one five and you say you know for
object Oh in this thing and then it in
rates through that collection very
convenient what's going on under the
hood though this is syntactic sugar it
is creating an iterator for you right so
it's allocating that object then it's
doing the normal iteration using that
iterator object the iterator approach
was kind of ugly and obtuse I don't
think people enjoy using that the for
each works around that it makes a nice
streamlined thing but it's still doing
the same thing under under the hood in
particular if your collection is empty
it's gonna create an iterator anyway
right it does not know that it's empty
until it creates the iterator and then
tries to get the first item and then
says oh you're empty you don't need to
do this so one of the optimization
optimizations that we did along the way
to creating the new animation system in
honeycomb was to eliminate all the
allocations that were going on
every frame so we have this new
animation system we use this tool
internally called allocation tracker I
would encourage everybody to use this to
make sure that you're actually using
memory correct correctly so I would
start the animation I would start
allocation tracking I would collect the
allocations and then the animation would
finish right I don't care if we're
allocating at the beginning in the end
to some extent that's unavoidable right
this is Java it's a memory garbage
collecting language you're going to
allocate objects what you don't want to
do is allocate during the animation like
during the actual frames and then I saw
that on every single frame we were
allocating objects for listeners what
was going on was we have this view tree
observer where you can listen to various
events going on layouts pre draw draw
the things that are happening in the
interview hierarchy down on every frame
we would say for you know view tree
observer listener whatever in this
collection then we would iterate through
and we would do something in general
nobody actually added a listener it's
not typical to have a listener there but
we would create an iterator on every
single frame anyway because that's what
4-h did for us so there's one specific
case where it doesn't do that which is
if it's a primitive array it actually
does the right thing and will not create
a iterator for you so yeh but otherwise
it's it's kind of a good thing to maybe
avoid if you're not really sure whether
it's going to create things or you can
certainly go back to to the old approach
of doing an actual for loop instead and
just get the items in the array and then
it doesn't advance to the first one if
it didn't need it or if you use it just
be aware of when it's actually going to
cause an allocation when you don't want
it to wait let's go back yeah this one
so let's talk about a news
no more I'm really tired of this topic
at this conference go to the article and
reads there's nuances to using them
please understand the overhead inherent
in a news and make the right decision
for your code moving on finalizar z' so
one of the things is not obvious about
finalized errs is nuances in the
language spec means that to finalize any
object we actually need to do a GC twice
so whenever you have a finalized are
declared on your class you're basically
forcing
a future G C twice and you kind of want
to avoid every single one so why are you
forcing two on the system there are
particular situations that really
require finalized errs we do use them
internally specifically when we have
NATO native objects that need to be
cleared so we need to know when that
thing went away so that on the native
side we can go ahead and free the native
memory associated with it so that's a
valid use case for it but I would say
try to limit the number of valid use
cases and definitely eliminate finalized
errs when you don't need them in other
cases they may be convenient but there
are better ways certainly from the
memory standpoint to do what you want to
do static leaks this is one of my
favorites I may or may not have caused
leaks and activities in some of my coat
I should I should do a deep dive into
the way that that hash map or weak hash
map works so there's there's a situation
where I needed to store information
about listeners associated with views
and I said well I know that weak hash
map uses a weak reference so when that
view goes away which is what I was using
for Mikey then I know this you know
everything will be collect it turns out
that's not true the way that we cache
map works it actually had a hard
reference to the key it had a weak
reference to the value which kind of
turns my head in knots but the the end
result was that I would the activity
would undergo a configuration change so
the phone would rotate and it would tear
down the activity it would come up with
a new activity and all that old stuff
went away except that I had a static
week hash map which had a reference to
the view which implicitly has a
reference to its activity bad thing in
general so beware of static leaks in
general the real problem here besides my
ineptitude and misunderstanding of how
weak hash map worked at the time was
that the lifetime of the process is
different than the lifetime of your
activity this is something I've hit
again and again an Android I tend to
think of you know when a window comes up
when that you know that basically that
application object that I'm working with
which is you know the activity in my
mind is sort of synonymous with
application
that's the first problem when that comes
up you know surely that is you know
that's where all my static objects live
they don't they live in the process
itself and the process is long-lived so
when you undergo a configuration change
we rip down the activity and we pop up
another one and it's in the same process
so if you have a static object there
whether it's a weak hashmap or something
else that's holding onto something it
shouldn't in the old activity it will
continue to hold on to it so static can
be the right thing to use in some
situations but is really dangerous
because just know that it's gonna live a
lot longer than the activity that you
think you're storing things associated
with static initialization is a good
thing to avoid in general especially for
expensive allocations or expensive
operations the problem that we see is
that when a class gets loaded and then
does a bunch of static work it's gonna
do all that stuff right now this causes
a problem for instance when you launch
your activity right so we're gonna go
we're gonna launch we're gonna try to
launch as fast as possible and then it
loads this class which does a whole lot
of work that it really didn't need to
why not do some of that stuff lazily if
you didn't actually need to you know
initialize the database whatever at that
point why don't you wait until a better
time instead of forcing that to happen
immediately
okay so third party code we've seen this
one a lot where again something that
traditional Java developers will do is
bring over their libraries and their
approaches from the old world oh I
really like this dependency injection
library so a common one that we've seen
is juice really powerful very flexible
people love to use this and then they'll
start using that it was not written for
mobile right it does a whole lot of
reflection and I haven't really talked
about reflection yet big secret
reflection sucks okay it has a lot of
overhead associated with it a lot of
allocations as well as just performance
overhead
so in general we tend to avoid it
everybody kind of knows that right you
don't really do reflection unless you
need to but a lot of these libraries
that you're dragging and are doing it on
your behalf so the general tip here is
to not use a library or third-party code
in general unless you know that it was
actually written for mobile because if
it wasn't written for mobile it's
probably using a lot of the patterns
that
we're telling you not to in your code so
why are you using it indirectly in
someone else's code if for a dependency
injection there have been a couple of
libraries written since that are more
tuned to Android there was the dagger
library and more recently there's the
dagger 2 library I would suggest you
check those out if you really want that
functionality and in general just look
for a libraries that I wish we had like
a logo saying mobile-friendly but you
can look for that logo it doesn't exist
but look for the logo otherwise just
make sure that you actually know what
that library is doing the other problem
that we've seen with third-party code is
if you're using a really large library
chances are there's a dependency graph
in there where you're dragging a lot of
stuff that you don't necessarily need
like if you are using you know library
foo because you really like that you
know collection class for managing this
particular thing and then all of a
sudden it added you know 20,000 methods
to your method count and a whole lot of
AP apk size just so that you could use
that one collection probably not what
you want in your application so just be
as concerned about your library code as
you are about your own code so there are
mechanisms that Android provides to help
you with memory concerns one of them is
trimming memory so the system will tell
you when it's getting low on memory and
you should really respond to that
because it's not just telling you you
know like oh by the way I'd really love
some memory it's it's not a casual
conversation it's saying I need memory
now could you please free some because
otherwise bad stuff is going to happen
right so when it goes out it reaches out
to the activities running on the system
the processes and says we're running low
on memory can you do something about
this and there's various levels of it so
you can sort of you know set your your
warning and panic appropriately but if
you're keeping thick cached thumbnails
around just in case you know the user
wanted to do a fling but right now
you're running in the background you
don't need those anymore maybe you'd be
a good time to jettison those because if
you can make yourself smaller then maybe
the system can get back the memory that
it needs so that it doesn't have to go
killing activities like yours right so
pay attention to the trim callbacks and
do something about them is load ram
device is a method on I think
activity activity manager that tells you
whether the system at the moment it
means this has 512 memory in it so if
you really need more memory to you know
have the best user experience but you
also want to work adequately on 512 Meg
devices then you might call this method
and set the way that your application
behaves accordingly avoid large heaps
there is a way to ask the system for
more memory and sometimes this is
necessary you know you're a video
playing application where the videos
simply won't fit into the standard heap
or you know you're doing image
manipulation with massive images
whatever it is there are some corner
case situations for which this was
introduced but it also tends to be a
backdoor for lazy developers like well I
just up but I want more memory it's
easier yes it is easier and it makes a
horrible experience because the more you
allocate for your process the less
everybody else gets and then it goes
back to the original point so don't use
it unless you actually really need it
please don't keep your services running
they can continue to run in the
background but if they exist just for a
particular reason
then finish that purpose and then get
out of them right otherwise they're just
sitting there doing stuff
if nothing else they're taking up memory
in the background meaning that there's
less available for everybody else on the
system and then finally optimized for
code size so this comes in in a lot of
ways but it's it makes your your apk
download better certainly but it also
decreases the amount of stuff they are
loading into memory for your system so
just be smart about how much memory
you're taking up so I want to go over
some of the tips that we have in user
interface this is sort of a grab bag of
things don't overdraw there are there's
a tool on the device called profile
overdraw I don't know what it is cult
profile what
profile GPU overdraw so you can see what
the overdraw is on the device it paints
in a lovely palette of pastel colors it
will indicate to you how many times each
of the pixels is being drawn on the
screen the problem is so Android uses a
common rendering technique called
painters fill algorithm
I guess because painters used a lot of
rectangles or something where basically
we will paint all the stuff that you
tell us to in the order of back-to-front
right because that's going to result in
the correct display for the user so you
got a window background great will paint
the window background you have a
container covering the window great will
paint the container with its opaque
background oh you have another container
covering now that's great we'll paint
that one too you have a ListView which
has a background we're gonna paint the
background oh all of your items have
background and all of a sudden when you
finally get to like the text in a
ListView you've painted each of the
pixels in those characters five or six
times that's something that the GPU
doesn't really like to do right that was
a lot of wasted effort in there so what
you really need to do is actually figure
out what opaque objects are completely
covering what other opaque objects and
maybe eliminate some of that overhead
there so you've got the window
background great use it set it to the
background color that you want and then
don't have an opaque background on the
containers that are sitting on top of it
so take a look at your nested hierarchy
there see what the see what the
organization is of containers as well as
the the opacity the backgrounds that
they're using and then do the right
thing there to make sure that we're
drawing as few times as possible on
every pixel so use the tools see what
your overdraw is like red is bad I'll
give you a little tip red is bad and
then do something about it
avoiding null window backgrounds so one
of the tricks to avoid overdraw ends up
in some artifacts that you should be
aware of so people will eliminate the
window background because they're like
great then then I don't have the
overdraw of like painting the window and
then also painting the first container
on top of it it'll just paint the
container that's true on the other hand
sometimes then you have an artifact
where all we have to paint is the window
itself so like we're animating in you
know the keyboard the IME is animating
in and the window manager is going to
handle painting the window or when we're
launching the window itself the activity
is not running yet we're gonna be
animating in the starting window and
it's empty there's like no the window
manager has nothing to pain you're gonna
end up with an artifact on the screen
either it's gonna draw black or on some
GPUs it may draw a garbage on the screen
because there's undefined contents in
that buffer so the window background is
there for a reason it's there to tell
the window manager what to paint on the
screen when it has no other information
about the activity so keep the window
background but to avoid the overdraw
issues see how you can use that window
background to do the right thing instead
of then having an opaque background on
the container that overlays the window
also avoiding disabling the starting
window this is another situation that
results in some artifacts where people
will disable the starting window because
you know they didn't want that blank
window up before their activity launched
but again the window manager doesn't
know what to paint if we don't have a
starting window I would say instead
actually use the starting window more
effectively you can brand your
application with this we've seen
particularly ineffective approaches
where someone wants a splash screen
before they get into their activity you
know maybe that gain took you know a
couple seconds to launch or whatever so
they're like okay well we'll have a
splash screen experience here but then
they get this weird experience where
window manager doesn't know what to
paint
so it doesn't do anything for a while
because there's no starting window and
then a splash screen starts after a
second or so with this completely
different experience and then the game
starts with a completely different look
pretty awful or in some situations it
gets even worse where like they kept the
starting window cuz they didn't actually
understand what it was they have a
starting window and then they have a
splash screen that's completely separate
and then they have the game screen so
then you have three completely different
experiences over time which is you know
nice if you want different experiences
but kind of sucks
what they should actually do instead is
remove their splash screen and take
their logo take their branding situation
and use that as the background on the
starting window instead then they get
the benefit of having the starting
window so that the system knows what to
do before the activity is actually up
and running and then they also get to
brand that as well and have the splash
screen experience before their
application starts there's some tips
about avoiding UI stalls so the UI
thread
really likes to run and keep running
otherwise the user is gonna sit there
looking at a skip frame while it's
actually busy doing something that it
shouldn't be so inflation tends to be
expensive so try not to inflate when you
don't have to or try to minimize the
amount of inflation happening if you
have a really complex view hierarchy
maybe you didn't need all of that all
the time maybe you could actually use
view stubs in there and inflate other
stuff on the fly as necessary instead of
having like I don't know Play Store like
hierarchy that gets inflated on the fly
whenever you want your activity that
would be nice no handling events when
you get an event it's nice to do less
expensive operations
it's nice when someone clicks a button
if you don't actually make a network
call in general or go to the database
you kind of want to do that stuff
a synchronously off the UI thread
because those events are being processed
in the same thread that's handling your
animation events your input events as
well as your rendering events and layout
like all of that stuff has to happen on
the UI thread so anything that you're
doing that's not visual that's not UI
related should really happen elsewhere
even if it will end up in data that does
populate the UI which a lot of this does
like you know they click on the button
that means you know some transaction
where we need to repopulate the data
that the user is looking at that's great
but you don't have to do it
synchronously right so you could spawn
an asynchronous task async task or
loader or whatever to go get that data
and then when it's back then you can
populate the UI in the meantime the user
was actually able to interact with your
application and it didn't seem so janky
measuring in layouts is quite expensive
it's good to avoid it particularly
during animations so if you wanted to
let's say animate an object to move from
one location to another you could
actually animate the layout params right
you could change the the layout params
that were causing that thing to be
positioned in the window you could and
that's kind of the the physically
correct thing to do well change the
layout params that forces a real layout
and then it'll figure out where it's
supposed to be and then it'll draw it at
the correct place and in the meantime
it's going to run a lot slower than you
wanted it to you're going to miss frames
in there depend
the complexity of your hierarchy it's a
lot better to actually animate with post
layout values like translation X
translation Y don't change the layout
params which force a layout instead
animate something that makes it visually
correct and then fix up the layout at
the end or a typical technique that we
use in animations is run layout figure
out where it's going to be at the end of
the animation
so it'll run layout it'll figure out
where it needs to be and then you've set
a non pre-draw listener on it and then
in your own pre-draw listener you say
okay well I know I want to animate to
this other spot down there so I'm gonna
run an animation basically rewind to
where it was before and then run forward
to the new layout location so basically
running translation Y from negative
hundred to zero this is essentially the
approach that we use in the transitions
package right we put it on pre-draw
listener we figure out where it was we
figure out where it's going and then we
set up the animation to rewind and then
play forward in general that's related
to the allocation concerns and the
amount of operations you're actually
doing in the ondraw and then the
animation concerns in general just be
aware that when you're in the middle of
an animation every expensive operation
you're doing or every memory allocation
could be contributing to missing a frame
it may not seem like that big a deal
like 30 frames a second 60 frames a
second it's still moving on the screen
the real problem comes in when it's
inconsistent so if you're typically able
to get 60 frames a second but eventually
a GC kicks in because you were
allocating a bunch of stuff in ondraw or
whatever then there will be a skip frame
in the middle so yeah 30 frames a second
is reasonably smooth if it was
consistent but going from 60 down to 30
and then back to 60 causes a hiccup
that's very noticeable to the user in
the middle it's going to pause just
slightly and then skip forward longer
than it would have if it had a smooth
frame rate instead avoid complex view
hierarchies I alluded to this before
like don't have more views than you need
don't have deeper nested layouts than
you need I pull up some applications in
hierarchy viewer hos use hierarchy
viewer okay good getting there
okay there we'd like a hundred percent
someday it's a really good way to sort
of get a mental model of what your
application looks like on the inside
with a ma
and the containment hierarchies like
I've seen some applications that have
this you know long tail of containers
where they've got a relative layout and
then there's a linear layout inside of
that and then there's a frame layout and
like each one of these things like it
had a purpose somebody had a reason for
that like I want to you know have this
background here and then there's this
other layout that's tuned to you know
have the right fringe effect on I don't
know what their reasoning was I'm sure
there was a good one but not good enough
right what you want to do is figure out
how to have you know the single
container that you needed instead of the
long nested thing that's simply going to
cause more overhead for inflation for
layout traversal for rendering all of
this stuff every layer is in hierarchies
just causing more work for their
framework every time we need to redraw
you also relative layout is probably the
most flexible layout it allows you to do
the association with you know sibling
views and the stuff on the side and I
want to align this next to that so it's
it's the most flexible which is why
unfortunately it is the layout that we
use when you create a new project in
Android studio this is not something I'm
real happy about right now we would like
to change this eventually the problem is
that relative layout causes us to
measure twice right so if you are
associating views with other views that
means we're going to ask all the views
how big they want to be and where they
want to be well we're gonna we're gonna
ask how big they want to be because we
need to figure out where to put them so
we're gonna ask all of them and we're
going to take all this information and
we'll crunch on it a little bit and
we'll say okay we know how big everyone
wants to be now we we have more
information about all the relative
locations and sizes of things we're
gonna ask you one more time so it's
gonna measure twice before it actually
lays out so if you have a relative
layout at the top basically you're
measuring every view in the hierarchy
twice or even worse what we've seen is
nested relative layouts and then you
basically double it for every layer in
the hierarchy so a relative layout
sitting beneath another relative layout
you're measuring all the children of
that nested one four times probably a
bad idea
so if you don't need a relative layout
we understand that in some situations
you need it usually not at the top level
of
our hierarchy it's usually needed at a
container level where you actually need
the association of the siblings or
whatever so go ahead and use it when you
need it but be aware of the overhead of
it and try not to put it at a really
high level and certainly try not to nest
it yes is it better to have a relative
layout with a lot of views or a nested
linear layout it probably depends on so
the answer is always it depends it
depends on how high up in the hierarchy
it is so if it's sitting at the top and
then it's gonna cause all of that
overhead to everything sitting
underneath it at the bottom of your
hierarchy it's not going to cause that
much right you're gonna be measuring all
the views but you wanted to do that
anyway like you wanted those sibling
associations that's probably fine nested
linearlayout also has its own overhead
associated with it so it doesn't measure
twice but you just added a bunch of
layers in there it's also worth
considering custom layouts at some point
too if you find yourself tying yourself
in knots and adding more and more nested
lettering or layouts to get the
particular effect you wanted you know
with all the right padding and
associations between all the different
sub views and sub containment
hierarchies at some point it's much more
optimal to simply create a custom layout
so you use subclass view group or you
subclass some layout that does most of
what you want and then you do your own
measure and layout and that'll probably
save you time in the long run launch
fast go ahead and try to get the UI up
as quickly as possible this pertains to
some of the stuff I was talking about
before like not doing too much in static
initializers like not inflating all of
the views that you might possibly need
in the future instead just get up and
face the user with something quickly
otherwise you know they've clicked the
button they've seen the starting window
and then four seconds later they see
your application horrible experience
right wouldn't it be better to be faced
with a simple UI that could then
populate itself later as necessary defer
the extra work if you didn't need those
fields initialized maybe you could
actually initialize them lazily instead
and also measure cold starts so when
your application starts it's important
to understand the different dynamics of
what state it was starting from so when
it is started from the
first time after a reboot that's what we
refer to as a cold start this means it's
all the work that we had to do to
actually read in the apk to load all the
classes to initialize all the stuff and
then to do the first layout and
rendering of that thing there's the
window animation but you know what the
window manager deal with that it's all
the stuff that we're doing inside of
your application to simply get to the
first frame that is displayed so it's
important to understand how much time
that takes and to measure it or purple
leave so if you launch your application
and then you hit the home button and
then you launch it again your
application depending on the amount of
memory available in the system was
probably still resident in memory so all
we really needed to do was display it
again weary rendered it period
right we didn't reload it we didn't you
know I in a lot of cases we didn't need
to do another way we're basically just
you know showing the same thing that we
had before
this is great I can start in 50
milliseconds I'm super fast and then the
next time you reboot it takes four
seconds so what you want to do to really
get a better measurement is actually
kill the task right so go into recents
and swipe it out of the way and that'll
get you most of the way toward the
situation of a cold start from reboot so
get it out of memory make sure that
we're actually dragging in all of the
stuff again to really understand how
much time your application is taking the
launch I want to talk about some of the
tools that are important to use
hopefully everybody uses most of these
systrace talked about a little bit
yesterday Cole talked about it as well
super powerful tool super confusing
there's so much information in there
there's so many options you look at it
and you're like I see a lot of green I
see a lot of red I don't know what to do
about it we added the the tips the
little circular bubbles in the middle I
would encourage you to get the latest
systrace and play with that click on the
tips and see what it's trying to tell
you in general the problems that we've
seen that we can do some amount of
analysis on in the tool now for you tend
to be common issues like you're in the
middle of an animation and you ran
layout or you're not reusing the view
when getview is called on your ListView
so some some simple things that we
noticed over and over and over again
that we now fed into the tools that you
can get for free and then once you start
using systrace more you start to
understand okay well these are the vsync
pulses this is you know the
the CPU usage that was going on at the
time my threat is sleeping because you
know it's tied to this other event and
surface flinger which was processing the
GL like there's a lot of associations
that you can get over time and practice
with using the tool but it's really the
only tool that we have that gives you
sort of the the big picture of what was
actually going on in the device that was
causing the jank that you see and you
can see the jank in the output there you
can see you know I've got regular pulses
I'm I'm doing my perform traversals
which is the the rendering loop and the
UI thread on every single frame and then
I skip three frames why that's what you
need to figure out so that you can fix
the jank in your application allocation
tracker super useful for all of the
memory stuff that I was talking about
before so obviously we're using a VM
here runtime that's going to be
allocating objects you can't avoid
allocations what you should try to do is
avoid allocating during times when you
know it could cause jank for the user so
run that animation and then see what's
being allocated during the animation and
make sure that all of the objects are
not actually coming from your code
ideally there would be no allocations
during the animation but if you can't
fix that you can at least fix the ones
that are coming from your code that
don't actually need to happen during the
animation trace view there's two
versions of it there's a sampling as
well as a non sampling instrumented
what's the other way they refer to it
what the sampling means okay it's gonna
look occasionally and see where it's at
this has very low overhead which means
you're gonna get reasonable times back
for you know how long these these
various things are taking but it's not
going to give you the full call stack
for where the code was at any point in
time so you want to use the instrumented
version instead if you're trying to
understand the code flow in how you
actually got to this at that particular
time however that has a fair amount of
overhead associated with it just in each
of the method calls so make sure that
you're not optimizing the wrong thing
don't look at the raw absolute times
you're getting out of trace view if
you're using the instrumented version
because the times that it's reporting
for method calls is really out of whack
with reality I have optimized stuff
before and saved zero time and the end
result just because it wasn't really
giving me the right information so it's
useful
understanding the flow and for kind of
relative times but don't take the
numbers too seriously if you're using
the instrumented version hierarchy
viewer we talked about that Matt I would
also call out the new memory analysis
tool in Android studio memory monitor I
think there's a couple of new memory
tools woman is memory monitor that just
shows you the use of memory over time
the other one actually analyzes leaks
and dependencies in the graph so check
that one out should be a lot easier to
use and more tuned for android dynamics
than Matt which is an eclipse tool so
basically you you to use Matt you take a
heap dump and then you go into Matt and
you basically see where see what objects
are still alive that you didn't expect
so this is where you find out things
like activity leaks but as I said
there's there's a possibly an easier
tool to use in Android studio for that
there's also an external tool put out by
the folks at square called weak canary
that I would suggest you check out as
well
memory monitor I just mentioned that for
Android studio and then there's on
device tools so those were tools that
you run on the host on your desktop
machine but then there's device tools
where you can see in real time some of
the information that you need to to tune
performance there's strict modes you can
enable that and it'll do a red flash
whenever your code is doing something
that it shouldn't on the UI thread like
making a network access or disk access
or whatever GPU profiling there's the
overdraw set that we talked about
there's also the raw performance it'll
put colored bars on the screen to show
you how much time you're taking in each
of the various phases of rendering so
it'll show you you know whether there's
a spike at a particular time because
you're getting you know inconsistent
results from this thing or whether
you're just consistently taking too much
time you know creating all the rendering
objects or whatever it is
duration scale this is useful if you
want to just slow down your animations
so you can see what's actually going on
on the screen I actually find screen
record to be a much more useful tool for
debugging animations because I really
wanted to see it run in real time is
just in my eyes don't work that fast so
I'll do a screen record and then upload
the the mp4 from the device and then I
can frame step it in some animation tool
or just a movie player and then I can
see what happened on every single frame
just try to attract the artifacts or the
problems they're in Hardware layer
updates this is another visual tool on
the device that shows you when you're
updating information that is currently
cached in a layer which is generally
unknown oh I would say that there's time
for Q&amp;amp;A
except for the fact that the timer is
running out right now so thanks for
coming
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>