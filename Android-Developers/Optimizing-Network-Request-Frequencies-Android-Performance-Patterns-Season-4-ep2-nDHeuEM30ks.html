<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Optimizing Network Request Frequencies (Android Performance Patterns Season 4 ep2) | Coder Coacher - Coaching Coders</title><meta content="Optimizing Network Request Frequencies (Android Performance Patterns Season 4 ep2) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Optimizing Network Request Frequencies (Android Performance Patterns Season 4 ep2)</b></h2><h5 class="post__date">2015-10-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nDHeuEM30ks" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's important for your app to stay up
to date in order to give the latest
Social Feeds news and weather reports to
your users but in truth syncing too
often can be the worst idea for the
performance of your application my name
is Colt McAnlis and there's one hard and
fast rule when it comes to syncing your
data over the network
do not over sync I mean it's a pretty
common situation now the user has your
app active or maybe it was the last app
they used and you want to make sure that
there's plenty of new data available for
them so that they won't close your app
or let their attention wander elsewhere
so you sink you sink a lot you ping the
server you ask for new data and bring it
down as often as you can but let's face
it this is a horrible idea firstly this
destroys the users battery and as we've
said before networking is the single
biggest battery hog there is not only
does it drain battery just to initialize
the chip but then it keeps it awake for
an additional 20 to 60 seconds after
you're done with your request also
drawing power in fact you can fall into
a really bad place where each one of
your networking requests ends up waking
up the radio and paying this cost not
ideal secondly consider the sheer volume
of bits that your app is now responsible
for requesting on the user's phone for
users on restricted usage data plans
this can be a make-or-break crime I mean
one app eating up a months worth of
bandwidth simply because it keeps
pinging the server for new data not a
good idea and this is also a double
whammy because the slower the connection
the longer the radio stays on to help
transfer data meaning that you're not
only being taxed for bits on the wire
but also draining more battery as a
result so okay so syncing too often is
bad but let's be realistic here your app
needs the data in order to provide the
user with the best experience we can't
just cut syncing out completely right
and the truth is you don't have to
there's a few handy tricks that you can
employ which will give the user the same
sense of functionality but require much
fewer requests the key to this solution
is understanding the difference between
stuff that has to happen right now and
stuff that can be delayed for example if
the user takes an action requesting that
their news feed updates right now well
then you pretty much have to kick off
that request but really the second and
third types are where you can actually
start improving performance the requests
that happen on regular intervals that
keep things up to date but don't need to
happen right this second
if it's not super important right now
then you can be smarter about how it's
synced case in point you should really
never pull the server regularly for
updates so you're basically just wasting
bandwidth and battery for the server to
tell you that nothing's changed instead
it's better to leverage other services
like Google Cloud messaging which will
let the server signal the app when
there's new content this will reduce the
amount of battery turn the phone is
doing and reduce the overall number of
server responses that you need to worry
about now if there's a situation where
you simply have to sync then make sure
that you're not doing it on regular
intervals remember this wastes resources
and most of the time there won't be new
content waiting for you instead adopt a
back off pattern based on responses for
instance if no new data is available
double the length you wait until you
check again if nothing's available the
next time double your weight length
again this will still allow you to sync
against the data but will slowly back
away from higher activity based on how
frequent the server-side information is
updating and don't forget you can also
adjust seek frequency based on user
activity for example if you can detect
that the user is driving or running or
if the phone has entered into sleep mode
you can make a good assumption that they
won't need data at the same rate on the
other side though if you've noticed that
the phone has been asleep for 8 hours
and suddenly starts getting moved around
then there's a good chance the user has
just woken up and it might be the right
time to kick off the sync requests and
finally don't hesitate to adjust your
sync frequency based on the state of the
device waiting for it to be plugged in
or connected to Wi-Fi to do syncing
helps keep the battery happy while users
are out and about and the good news is
that you can update your app to adopt
these patterns without having to write a
massive amount of code GCM network
manager is a Google Play services API
which helps the schedule network
oriented tasks and handle batching for
you this greatly simplifies the
implementation of common patterns such
as waiting for network connectivity
Network retries and exponential back-off
basically all the good stuff you need
with one single helpful API and if you
ever wondering how your application is
using the network make sure to check out
the network traffic tool inside of
Android studio it will easily show you
the frequency of your data transfers and
the amount of data transferred during
each connection of course that's what it
all comes down to right watch some
videos improve your app make your users
happier but
you're not done yet that's why you need
to check out the rest of the Android
performance patterns content and don't
forget to join the Google+ community as
well so keep calm profile your code and
always remember perf matters</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>