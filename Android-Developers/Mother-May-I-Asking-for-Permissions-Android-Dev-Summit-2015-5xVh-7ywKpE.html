<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Mother, May I?&quot; Asking for Permissions (Android Dev Summit 2015) | Coder Coacher - Coaching Coders</title><meta content="&quot;Mother, May I?&quot; Asking for Permissions (Android Dev Summit 2015) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Mother, May I?&quot; Asking for Permissions (Android Dev Summit 2015)</b></h2><h5 class="post__date">2015-11-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5xVh-7ywKpE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everybody my name is fat Gandalf I'm the
tech lead for the Android runtime
permission model and the TL for Android
printing accessibility I worked on very
various other things and my name is Jeff
Sharkey I'm a software engineer on the
android framework team and i've worked
on things like SD cards package
management and parts of the networking
stack today so that's gonna dig into
permissions and how they've evolved in
marshmallow and then I'll be back up to
talk about best practices spread thank
you Jeff
so before I begin my talk you're
probably wondering what are these
permissions what is this guy gonna be
talking about and and so before I get
into the nuts and bolts of permissions
how the new runtime permission model
works I want to cover the very basics
and what what is the permission so
permission is a complete controls access
to sensitive data for example in my
contacts my SMS my in critical resources
so critical resources are for example
the camera the GPS and so permissions
are granted to applications by the user
and there are three different rotational
levels of permissions one of them is
normal dangerous and signature normal
permissions are considered not that
harmful to the user and applications
usually get them immediately as soon as
they're installed they don't need user
approval dangerous permissions they are
more critical to the user and these are
things like your contacts your camera
location which required the user to opt
in and allow the application to use the
permission there is a third type of
permission which is called signature
permissions signature permissions are
defined by an application or the
platform and in order for another
application to get this provision it has
to be signed with the same certificate
this pretty much means that it should be
developed by the same developer so I'm
gonna do a very quick dive on how
permissions used to work before on L and
priam devices in general before I dive
into the
your permission molo so what you
probably most of you know on L devices
you just go to the Play Store you find
an application you wanna install you see
the familiar install button you click
the install button you see this nice
list of all the permissions that the
application is using and you have
basically two options at this point
except operations or go away go back and
even if you don't like one of those
permissions and if you have some doubts
you basically have still these two
options like opt in or completely don't
install the application at all assume
that times approve all permissions the
application gets downloaded I open the
app and the application can be used all
the time so the old permission model had
had several limitations so for for one
the user had no control so basically you
have the big hammer you gotta hit the
nail or you don't is basically either
accept all permissions and install the
app or you don't
there is no context for the user why
this application needs this permission
so you're probably asking why is the
flashlight app asking for some
permission and there's probably a good
reason for that but the thing is it's
not it's not obvious everytime why the
applications is certain permission
another problem we had was we had too
many permissions and it was really hard
to make an informed choice when you have
30 options and interest and 30 different
concepts to decide what to do another
problem is the technical jargon that was
used by explanation for certain
permissions mainly because it's been
evolving over time and we've been adding
more and more concepts and to be honest
I'm an engineer working on this and
still it was kind of hard to understand
all the permissions at some point I just
need to look it up and of what it would
what was it and the other s which is
really important for you guys sub
developers is there was friction on
upgrade because if you get an update for
your application and require new
permission the user has to explicitly
approve it before the upgrade occurs and
this is problematic because many times
developers are afraid to add new
features because they may require you
permission
since this can limited this can limit
the adoption of their application and
they're really trying to or or district
leader the other pal to the other
pathological case where you request all
permissions up front just in case you
never know so in order to solve all
these problems I'm presenting how
permissions work on em or marshmallow so
what we did is we realized that we have
too many permissions and we decided to
group the permissions into nine
permission groups which are oriented by
topic
and and this is what we present to the
user when they manage the permission so
the user can give the permission if the
user grants you the contacts permission
they under the hood grant you all the
permissions in the contacts group so all
the permissions are runtimes
so there is no permission UI when you
install the app so if you go to the Play
Store you find your application you see
the install button then you click
install and the installation starts
right away you don't see any UI and it
dialogues for permissions you can you
can open the app so what the app does is
when the application needs permissions
it does request them at runtime and this
is one example of how the calendar app
is accessing asking for your contacts so
the idea behind this permission model is
that the user has more context where the
permission is needed for because you're
trying to use the feature you're trying
to take you know to use the camera and
you when you when you try to use the
feature it's asking for the camera
permission it's pretty obvious why the
permission is needed and you have more
contacts in more informed choices the
other benefit of the new permission
model is that you can always change your
mind you can say hey I granted this up
this permission but I don't feel
comfortable for the app to use this
permission you can go always go to
settings and change that or so you have
access to permissions by application so
now you can see all the permissions that
the hangouts app is using you can also
see the permissions so which apps are
using this permission so for example
which permissions are which apps are
using the camera permission on my device
and you can you can control that
so so this is how modern applications
works the reapplication has to be
explicitly written to use the new
runtime permission model which is
probably 0.1% of the applications from
the Play Store and you're probably
asking yourself what do I do for all
this 99.9% of the applications how do
they work because the way they're
written they don't expect permissions to
be revoked on them so if you--if you
revoke the permission on an app it will
just blindly call the API and will just
crash so the way a permissions work for
legacy apps is you go to the Play Store
again you find the application you click
the install button you see the familiar
permissions dialog and again you have
two options you have to accept all
permissions only or you go back the
difference though is when you install
the application and accept all
permissions now you can go to settings
and you can manage permissions for those
applications even though they don't
support a new runtime permission mode
and then the question is again you have
the nice permission than the nine
permission groups so from this point on
it's for you the application is
controlling permissions for legacy and
non legacy apps is absolutely the same
there is no difference and then the
question is how did you guys do this the
way we do it is instead of revoking
permissions for legacy applications we
just disabling the API we using a
feature called a pops probably some of
you are familiar with it
and what we do is literally for example
you revoke the contacts permission so
the application really has contacts
permission we don't revoke the
permission but what we do is when the
application is asking for contacts we
say sorry no contacts on the device so
we basically making the apps the app the
API is do nothing or return default
errors or empty data sets it's it's case
dependent so we basically had to visit
all the api's and just make them work
appropriately so how do you ask for
permission before I before I go into the
nuts and bolts a hydrating code I really
want to cover the UX because it's really
really important to have consistent
permission experience for all
applications for
it's good for the user it's good for you
it's good for the ecosystem it's good
for everyone so you can imagine a
2-dimensional matrix so in one dimension
you have how important is this
permission for my application is it
critical or is it is it is it an
optional feature so for example if I
have a camera app the camera permission
is critical for my app I mean it will
not work if I don't have the camera
permission however location is a
different story maybe I have a Jew
tagging feature but most users probably
don't understand why how location is
related to photos and in this case
probably I don't need a stranger right
away it's not critical for my
application to work also it's about
context the other dimension of this
matrix is the context so is it is it
clear to the user why you need the
permission form or it's not clear and
based on that I'll cover all the cases
and what is the UX recommendation in
each of these cases so case 1 assume
that it's a critical permission that
your application needs but it's not
clear to the user why do you need this
permission so now it's that's a great
opportunity for you to have a warm
welcome screen where you present the
core features of your application and
how to use the application and you
educate the user and in this context you
can it will be clear to the user why
this permission is needed and at the end
of this flow you can just literally
request permission and so the user will
not be wondering why you need this
permission at all so the second pattern
asking upfront so if you have an
application that really needs this
permission is very obvious so the camera
app is a perfect example you have a
camera app you need the camera
permission without the camera permission
the application cannot work so for the
user is not surprised if you ask for the
camera permission they just download at
the camera app so the third case is for
secondary features where it's it's it's
obvious why you need this permission for
example let's pick the geo-tagging
example that i gave you a little I mean
it earlier so if I have a photo and I
select geotag the photo and I'm asked
for location permission
I wouldn't be surprised it's it's
obvious to me again see in the context
that oh yeah I know what this permission
is needed so the fourth context the the
fourth pattern the fourth the fourth
pattern excuse me is educating context
so this is for cases where it's a
secondary feature for your application
and it's unclear to the user so you
really shouldn't have features that fall
into this bucket but in case you do you
should educate you can explain before
you request a permission you can educate
the user why you need this permission
before you ask in the permission we have
for even a dedicated API which has this
long name should show request permission
rationale that that you can use as a
hint whether you whether to show uh
permission rationale I'll cover this in
in detail a bit later but what is what I
forgot to mention is really important is
that when you ask for permission the
very first time the user does has two
options
except the permission or denied a
permission they do not have the option
to say don't ask me again
so the very first time it's safe to ask
the second time if the user says no but
the application keeps asking for the
same permission now the user has the
option say nah don't ask me again so the
very first time is safe that's very
important message to just just ask for
the permission upfront so there is a
fifth pattern which I would say it's
more like anti-pattern I've been asked
this question many times so this way I
decided to bring it up to your attention
but to be honest from all the all the
Google apps that were seeing this as a
problem nobody actually had to implement
this pattern and there was another way
around that so that's the case where you
have a service it runs in the background
and these you don't have UI the users
not using do you have the UI of your
application and now we need a permission
so what do you do
we don't have api's to request
permissions from services and that's on
purpose because we don't want to
interrupt a user so definitely when the
user is using another app it's it you
shouldn't throw an activity in front of
them asking for the permission because
this is disrupting the user flow what
you should do is
first avoid this if possible and the
other is just post a notification and
say hey this feature won't work and when
the user has time they can open a
notification which when they click on
the notification you should bring a
fullscreen UI where you can explain what
feature needs this permission why is
this permission used for and let the
user choose whether they want to obtain
a - at which point you can request
permission or opt out so here are the
permissions api's it you can they're
just a few API you need to learn they're
very very simple that's I really want to
have this message that it's very very
very simple to use permissions so the
first permission is very at the first
API is very simple do I have this
permission which means does my app have
the permission not somebody who's
calling for remote process the second
API is to request the permission as you
can see we have this API from activity
summon fragments once you request the
permission you need an API because
permission request is asynchronous but
this brings the UI the user has to
decide what to do so this way you have
this callback own permission result
request on a request permissions result
where you need to handle the result of
what the user decided to do the last two
api's our little non-obvious what they
do the should show permission rationale
so this is this API is it has very
targeted use and it's intended for so
this returns true if and only if the
user already declined the permission
once so the users you requested a
permission the user so the UI and said
no and now if now you can use this API
that as a hint whether maybe maybe the
user did not have enough context when
they requested permission the previous
time when you request to the permission
the previous time so you can help the
user and show this additional education
additional screen to explain why you
need the permission but again this is
very optional and this is only if you
feel that the user doesn't have enough
context context we really think that
most of the time this shouldn't be
needed but in case you do is there there
is another case where you
have device policy that says no this
apps this application does not have this
permission and it cannot get it so the
way to read this API is permission
revoked by policy yes does the user have
the power to give me the permission so
if the user doesn't have the power to
give you the permission you may not even
expose the feature because or or you can
explain to the user that the the feature
is not available because the policy
doesn't allow this permission now that
we have all the building blocks here is
how we put them together it's really
important the very first time the very
first thing you need to do when you call
an permission protected EAP I always
always first check whether you have the
permission so if you don't if you have
the permission just go ahead into the
work if you don't have the permission
now you can optionally check should I
show rationales so should I help the
user better understand why I need this
permission because these already if the
user already declined the permission and
otherwise you just go ahead and request
the permission once request the
permission you need to handle the result
based on what the user decided so this
is how permission result handling looks
like so the first thing you need to
check is is this the request I made like
is this the answer I'm waiting for if it
does the case the next check is is there
information in the answer so are this
arrays with permissions and results
empty so if they're they're usually
empty if there is a cancellation and the
next thing you check is did I get the
permission if you get the permission go
do the work so it's so great how do you
get on the boat like how do you get on
the train how do you opt-in to the new
permission model it's based on the
target SDK so what you need to do is
change your target SDK to 23 and
magically use the new API and you're in
the new permission model it's important
to note that there is no way out once
you get in there is no you cannot go
back to target SDK say 22 and this is
the main reason for that is we want to
we really believe that runtime
permissions are really good for the user
they're really good for developers
they're good for the ecosystem and we
really want to incentivize everybody to
use this new permission ball we have
this very special cases which I want to
point out a very very useful API one of
them is say you have a new feature that
you want to use so you want to add
camera feature only for M devices and
app you don't want to request the camera
permission because this can affect your
adoption on all the platforms so what
you can do is hey I want to use this
permission but only on platforms that
support runtime permissions so users
permission SDK 23 is your friend we have
another way of requesting permission up
to give an SDK so we say hey I want this
permission up to L so the way you do it
and you specify max SDK version in the
users permission API in your manifest so
upgrades was it was the greatest story
permissions are grandfathered so if you
if you have an L app on L device you
have all the permissions if the device
gets updated to M your application still
has all the permissions with a caveat
the user can go ahead and revoke the
permissions if you revoked if you have
great your application from target SDK
22 to 23 to opt into the new permission
model you still keep your permissions
also revoke permissions if I install a
legacy app target in L SDK and if I
revoke some permissions as a user when I
get the update the same permissions are
still revoked until I go ahead and run
them explicitly so we have support
library API I will not go into details
but the message here is for all the API
is that you saw in the SDK there is
corresponding API so in the support v4
library so you can use permissions from
the support library we also have API so
in the support library v13 if you want
to if you don't want to go back to v4
and this is kind of an edge case which
we wanted to point out for proxy in
permissions this is
again very edge case usually this
happens when say I have an app that has
access to contacts and I decorate
contacts so for every contact I'm adding
a smiley face for example and so when an
app is asking me so I have the contacts
permission I have access to all the
contacts but if an app is asking me hey
give me the smiley face contact I need
to verify whether this application has
the contacts permission in the first
place
because I don't want to be leaked in the
contacts permission without the user
approve it's really important to use the
permission checker from the v4 support
library to do this because it checks not
only the permission but should also
check whether the api's are enabled you
guys if you remember for legacy
applications we don't revoke permissions
we disable the api's so the permission
checker knows how to check the
permission and whether the API is
disabled by checking the corresponding
nabobs
there are some command line tools that
are very useful some of them is adb
shell p.m. grant revoke you can use this
to grant revoke permissions to your app
like during development is very useful
instead of having to manually approve
the permission every time you can
literally grant the revoke permissions
from the command line and I don't think
that's very useful for free developers
is you want to install the application
with all permissions granted you use the
familiar adb install with the - gee
which means grant all permissions
specify the package the APK and and and
a permission granted sometimes it's
useful to dump the state of permission
state for your application adb shell
dumps this package and then a package
name them stems the state of your
package in the package manager and it
also lists all the permissions we also
have some device policy api's this is
very for people who write device policy
which is fairly rare but there is a way
for you to specify hey this permissions
is this permission for this app is
always granted or it's always denied or
you can say hey for every subsequent
request
I want permissions to be automatically
denied or automatically approved
so some do's and don'ts please never
don't code around permission groups
don't assume that if you have one
permission in one group you have the
other permissions in the same group we
reserve the right because at the ID
application level you're operating at
the raw individual permission level and
the user controls the permissions at the
group level
so it's a simplification for the user
but please don't assume any any grouping
behavior we want to reserve the right to
add new permission groups move
permissions between groups I'm not
saying we will do it but it's it's just
for the flexibility of the platform also
avoid screening questions hey if I ask
you this permission like are you going
to give me this permission i we want you
to ask upfront because the first time
there is no penalty there is no don't
ask again option for user if you ask for
the very first time also follow the UX
patterns it's really important that all
the applications are consistent is good
for users it's good for you it's good
for everybody
I want to stress again check before you
call an API that is protected by a
permission don't assume that you have
the permission or don't rely on some
previous checks and this applies to any
API it's not only for permissions but
don't infer undocumented behavior don't
rely on undocumented behavior because we
may accidentally change that and we may
accidentally break your applications we
are trying really hard to be backwards
compatible but sometimes if it's hard
and and probably have the question how
do I know which IPS are protected by
permissions which is interesting
question
it was never documented so you can use
Android studio actually Android studio
is flagging if you call an API without
checking for information with this
asterisk that not all API are probably
annotated we have this special
annotation on the API which permissions
are guarding it so in some cases you may
have it may have some misses but we're
trying to get it better and better
so with that I'm tossing over to Jeff to
talk about how not to use permissions
Thanks
so yeah I think it's veggie sticks
to us the new runtime permissions model
in M how things changed and evolved
there and these powerful new permission
groups that we have that you can request
from users but I'm gonna shift gears and
talk about how you as an app developer
can actually ask the user for fewer
permissions over time so as an example
again we have these permission
categories they're nice and shiny but
some of them can be pretty broad and
scary you're you as a developer you're
asking the user to give you access to
all of their contacts to all of the
files that they have on their SD card
including all the photos that they've
taken in the past and so some of these
permissions they may make sense for your
app again if you're building like that
camera app on you need access to the
camera permission to make that happen
but other times you may be asking for
more than you need so that's what we're
gonna do we're gonna go through a couple
of these common categories we're gonna
look at use cases common use cases that
you as an app developer may have and
we're going to look at ways to still
build those parts of your application
without requesting the big broad scary
permission permissions so the first one
we'll dig into is storage you probably
recognize this as read or write external
storage if you've added these
permissions to your manifest and when
you ask for the user for this permission
and they grant it the user is giving you
access to all of the files on their card
even if you as you use an app to build
or you're not interested you're still
requesting and getting access to all of
that um some common use cases as a
developer is I you might just be looking
for a place to store additional data um
you're trying to be helpful you don't
want to take up the users valuable
internal storage space you want to put
that content out on an SD card maybe a
32 or 64 gig card that the users
inserted a second use case is maybe you
want the user to pick individual files
to work with if you're a photo editor
app maybe you just want to open the one
or two files that you want the user to
work with and you're not interested in
all the via all those other details so
let's dig into the details for that
first example there's a handful of AP is
that were introduced in KitKat on
context called
get external file ders casters and media
ders and when you call these the paths
that are returned they exist on the SD
card but they have your package name
burned into them
so if you look at the bottom you can see
the example of what those returned paths
look like so notice it would be under
the SD card / Android / data /
and there's a couple reasons for that
first of all that's how the system
recognizes who that data belongs to so
that it can give you access to that data
so the paths that are returned from
these api's your application always has
read and write access to any contents
under those directories you're free to
create new directories new files at any
time and there are no permissions
required to do that you don't need to
read you don't need to request those
read or write permissions on it they
still will work even if you have those
permissions but you don't need to
request them the other benefit here is
that there's better accountability on
the user as they if they go to uninstall
your application the system will
automatically clean up any files that
you've chosen to store in those
locations in addition if the user goes
into settings to see where their disk
space is being used
it'll be accounted against your
application correctly so it's better for
a lot of different reasons
the next example that we talked about
was just looking to pick an individual
file or work with a handful of files and
this is where I'd like to take a second
to talk about the storage access
framework this is something that we
built in KitKat and it's really an
abstraction layer between apps that
offer to store files or data say like an
SD card or Google Drive in the cloud and
apps that offer to work with content or
files say like a document editor or a
photo editor so in this case instead of
asking the user for those broad
permissions asking for all of the files
on their SD card or all of the contents
of their Google Drive you as an app
developer you're able to launch a
handful of common intents that go into
the storage access framework and ask the
data what files would the user like to
work with and they're given that freedom
to choose which things they want to
return access to your app the handful of
intents that are interesting here are
open document create document and get
content you can think of those
essentially like an open dialog box save
file and more of like an attached file
if you're building like an email
application and we'll dig into in a
moment and
little bit about how that works under
the hood another thing to mention is in
marshmallow we added access to USB OTG
or on-the-go devices so if you have a
USB flash drive that you've plugged into
your device those are now available
through the storage access framework and
so you as an app developer you didn't if
you were using these intents you didn't
have to add any additional code to start
working with those devices they
automatically appeared and that's true
of any other either a cloud storage
provider or any other storage medium if
they participate in storage access
framework there's no additional work
that you need to do as an app developer
and it gives users more freedom and
flexibility so then you might ask the
question how does this here's an example
actually we'll take a look at just some
of that UI around that experience so
these are those three intents open
document create document and get content
and it's one thing to point out here is
that we're giving a user users a
consistent experience when they go to
pick these files um you could build your
own UI for navigating the the contents
of the SD card but as the user comes
into your app they're gonna have to
understand how you've chosen to
represent some of those concepts and
it'll be slightly different than every
other time they've encountered that
before but by using these common intents
we're giving a UI that the user has
probably seen a couple other times on
the platform they're already familiar
with how to navigate and use to navigate
and pick the files that they're
interested in and this is beneficial for
the user because they can get the tasks
that they want to do they can get that
done faster they understand they
understand how to interact with this
framework so now let's dig a little bit
deeper under the hood how does storage
access framework actually work and I'll
talk a little bit about URI permission
grants so all the stuff we talked about
earlier today are focusing in on
traditional Android permissions which
are a string like Android permission
read external storage and that's
something that your app requests in your
manifest and when the user grants that
access you're granted that for the rest
of the the lifetime of your app either
until the user uninstalls you or until
the user goes into settings and revokes
that permission URI permission grants
are slightly different and the fact
they're centered around content
providers so a content provider it
surfaces its content on the system
through a URI a content
: / / an authority and then a path name
and the power here with with Uri
permissions is that we can grant access
to a very specific path inside of a
content provider for a limited amount of
time so for example if I just took a
photo in my app and I want to share it
with someone else I don't I can extend
access to just that photo that I just
took to the receiving app at the other
end temporarily and the lifetime of that
permission is until that activity stack
finishes so I extend them access maybe
I'm sharing it as part of a social
network they get access they can see the
data that they need to get their job
done and as soon as the user leaves that
activity stack the permission is revoked
so they only had access to the data that
they needed and for a very limited time
so you might be asking the question how
do I wire this up inside of my app and
one of the easiest ways to do that is
using the class called file provider in
the support library it allows you as a
developer to easily convert if you have
a file on disk you can convert it into
one of these content URIs that then you
can stick into just a traditional intent
that you might already be using today so
in this case there's an intent dot
action send I and we're instead of using
a file URI we're sending a content URI
to the other side and that's what allows
us to use that additional flag their
intent that flag grant read URI
permission and this is you as an app
developer communicating to the system
that you want to extend temporary access
to that URI to whoever receives it at
the other end and one of the reasons
this is becoming more important in
marshmallow is that I you may not know
whoever's at the receiving end they may
not have that storage permission or they
may not have the permissions to access
that content outright so this is your
way of making sure that whoever is the
receiving end they have the permissions
that they need to access the content
under the hood so in the I in summary
even if you're using file at your eyes
you'll want to look at transitioning
them even an M more towards using these
content your rights because of the power
that comes from them and there's a
strict mode API that you can use to help
track down in your application if
there's places that you might still be
using file your eyes you can turn on
that strict mode and it'll log it and
you can quickly figure out if there's
any places that are still lingering
around all right
so we've talked about storage let's go
into another category
talk about phone a couple permissions
that fall into that category read phone
state and call phone and these are
pretty powerful too when you think about
it they give you access to see the users
phone number to see their IMEI to read
the current state of the phone is are
they at a phone call or not unreality
you may have a couple of common use
cases that like for example you just
you're just interested in using the IMEI
as a unique identifier to be able to
figure out which devices this or you may
just want to initiate a phone call to
start a call to a specific phone number
for the user let's look at that first
example um and I'll say don't use IMEI
as a unique identifier on the device and
the the first the reality is because not
all devices have a telephony stack in
the first place most tablets out there
for example if you need some sort of
identifier you can always build one
yourself you can use like Java util UUID
and persist it locally in your app data
storage and then communicate that with
your server when you're not interacting
with it
another alternative is the is the
instance ID that's provided through
Google Play services and that's also
useful it provides a unique identifier
that then you would use if you're
integrating with Google Cloud messaging
for example its second of all if you're
looking for that unique identifier for
managing app licenses there's also a
solution in play the play licensing
server is another alternative to look at
there so takeaway is please don't use
IMEI because it's not it's not really as
useful as you think it is for that
second example of making a phone call
there's actually there's too intense
here that are interesting there's a
slight nuance between the two there's
action call and action dial when you
send an action call intent you're
actually taking the phone off the hook
darling the number and it starts ringing
for the user like they'll hear the
actual like ringing as its initiates the
phone call um
action dial on the other hand simply
launches the dialer activity the UI and
inserts the number it types the user the
number in the phone number you want to
call but it doesn't actually initiate it
it waits for the user to click a button
to confirm that they actually want to
initiate that phone call um and so the
difference between those two is the
action called requires the call phone
permission and so if you use action dial
you'll get that same functionality your
help in the user shortcut into making
that
phone call that they want that you know
they want to make but without requesting
that permission when you think about it
that flow is a little awkward you're
asking them for the phone permission you
know allow and then you're like
immediately launching the phone call you
think about using action dial instead
you launch them into that familiar flow
they click the call button and they're
on their way and here's just a quick
example building up that tell you RI and
sending action dial let's talk about the
camera or mic permissions um when you
request these you're requesting full
access to the camera and microphone from
now on maybe when in reality maybe
you're just interested in taking a photo
or small video for the user just for
this moment in time maybe for example a
picture of a check that the user just
wrote that they want to cash on so it's
really just lets some other common
one-off use cases I and you may not need
that permission like all the time you've
going into the future and there's some
nice intents that can help you out here
on media story there's action image
capture and video capture and one of the
biggest benefits here is that you're
launching the user into a consistent
experience if you were to request the
camera permission and build your own UI
and then you need to represent advanced
features like turning the flash on and
off or turning on other camera features
and functionality you're probably gonna
do that in a different way using
different UI then the user is used to
the camera app that's built into their
phone may represent it one way and then
you're giving them a slightly different
UI that'll take them a longer time to
get used to to find out where all the
additional features and functionality
that they're used to having access to so
by using these intents you're actually
launching into the built-in camera app
on the system the one that the user has
chosen where they've probably already
taken dozens of photos in the past
they're already familiar with how to
choose the advanced functionality and so
it's making the user experience faster
for them they're able to jump right in
they understand the flow and how to use
it and then they get the content back
that they need the one thing that I will
mention here is I you may think well
I'll try requesting the camera
permission and if the user denies me
then I'll fall back to using some of
these intents and that's something we
don't want to encourage if you need the
full camera experience ask for the
camera permission and make it and make
sure that the user either allows or
denies it and don't try falling back go
for the one that you
if you really need the full camera
permission ask for it I and or if you're
if you don't need the full camera
permission just use one of these intents
and the reality is if you ask for the
camera permission and the user denies
you and then if you try using one of
these intents the system will throw a
security exception at you so this is
purposely we want to have me focus on
either one path or the other contacts
permission let's talk about those
redirect contacts and again this is
accessing all the users contacts all the
people that they've added over the years
when in reality you may only be
interested in just reading one contact
you want to share something with one
person or maybe you just want to add a
little bit of additional detail to an
existing contact maybe a new email
address so we'll dig into two quick
examples related to those first there's
action pic you can launch that action
pic intent and ask the user picked me a
contact and return access back um and
this under the hood is using those same
URI permission grants that we talked
about a few moments ago when you launch
towards the system asking the user to
pick whatever item that they pick that
contact that URI is returned to you with
temporary permission that you can read
just to that contact you won't be able
to see any of the other contacts but
just the one that user selected so
here's that that quick example and
there's more details if you go to the
the link there for the contacts provider
to see how that works under the hood on
the flipside creating or editing a
contact there's an intent for that here
you provide just information that you
know you know their phone number their
name their email address and you give
the user the choice maybe their only
interest maybe they want to create a
brand new contact for this person or
maybe that there's this contact already
exists and you're just venting and
adding a little bit of extra details
that weren't in there before um this
you're launching towards the contacts up
on the platform and the user is the one
left in control they can make the choice
of what to do create a new one or edit
in existing and similarly here you're
giving them a familiar contact editing
experience on something that they've
already interacted with on the phone a
URI that they're familiar with calendar
permission again it's accessing all of
the users contact all of these is
calendar events when in reality you may
just want to add like one upcoming event
say for example this talk that we're in
right now here's the example of how to
do that there's an action insert command
or con intent for that and we can fill
in some of the details say like when it
starts in
the details around it and then just
start that activity we don't require the
right calendar event we launch into a UI
fill out the fields ready for the user
taste to say to say yes I want to save
and persist that so we're adding that
additional functionality with without
requiring that permission so in summary
we talked about how permissions in
marshmallow are much more powerful now
but at the same time the user has the
power to deny us access as developers
they can say no so what I would say is
carefully consider when you're asking
this from it for you for those
permissions and consider using some of
these strategies that we just talked
about to build your apps without having
to ask for those permissions in the
first place
in a way that you can still accomplish
the goals build the app that you want to
build with the functionality that you
need but without asking for those those
broad permissions and finally we talked
about those intent patterns so the
intents where the user is given common
familiar UI I saw there have a
consistent experience and they're able
to accomplish whatever they're trying to
do faster so hopefully you have a big
better picture of marshmallow and how
the permissions have evolved and so
spent and I will be available we're
running out of time will be available at
office hours later this evening if you
have questions for either of us but with
a without that thanks for your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>