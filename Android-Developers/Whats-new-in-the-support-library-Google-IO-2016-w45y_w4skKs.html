<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What's new in the support library - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="What's new in the support library - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What's new in the support library - Google I/O 2016</b></h2><h5 class="post__date">2016-05-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/w45y_w4skKs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone and welcome to what's an in
support library my name is Chris Bane's
and I'm an engineer on the developer
relations team hi my name is tingly and
I am engineer in the Android UI toolkit
team I'm Allen Vai Verret and I'm tech
lead for the support library project so
in the past year a lot has changed in
the support library we added a lot of
great new features in release 23 2.0 and
since then we've added a lot of bug
fixes and some minor features and today
we're happy to announce the release of
version 24 alpha 3 which coincides with
the Developer Preview 3 of Android n so
today we're going to be talking about
some of the cool new things in support
Lib and some of the things that we can
look forward to in the future we're
gonna start out by talking about support
v4 so everyone's familiar with this it's
where you have compatibility shims so
you don't have to do an if version check
it also contains a bunch of helper
functions and utilities that you can use
to make your apps backwards compatible
as with each platform version we've put
in back ports for various functions that
have smart fall backs that you can use
to target new api's on older versions
and we also have a couple of features
that we'd really like to highlight today
so in fragments we have some lifecycle
improvements namely fragment transaction
now has asynchronous commit so if you're
creating an encapsulated component
that's working with fragment
transactions you can synchronously
commit your transaction if your fragment
is being added it will be added and
brought to the host state immediately
you don't have to worry about ordering
conflicts with other fragment
transactions
likewise if your fragment is being
removed it will be removed and
disconnected immediately so you can
handle all of your life cycle without
having to worry about ordering this is
especially useful if you're a library so
we actually use this in the view pager
fragment module in the library to
prevent ordering conflicts Adam Howells
going to talk more about some of the
changes to fragments in what the
fragment which happens at 5:00 p.m. so
make sure to check that out we've also
made some changes in notifications in
particular we have a new conversational
messaging style so when you have say a
hangouts conversation that's
multiple parties back and forth that
shows up in notifications and shows you
snippets of the conversation this is
also supported by where 2.0 so when you
have a conversation that shows up on
your watch
we've back ported this in Android so if
you have we're running on an API 18 and
above device so that's when notification
listener was added notification listener
service and you use the notification
compat builder to build your
notification and you use messaging style
even on an API 18 device that'll move to
the where app which is also using
support library and understands that
communication channel and you'll get the
messaging style on your where device as
well we're also giving you more
information about what users think of
your notifications so one thing that
developers have really wanted to know
for a long time is have users block
notifications from my app so in Android
end there is now an API that lets you
tell exactly that's and we've back
ported this to API 19 which is when
users were first able to block
notifications from packages so you will
get an actual value from this that
reflects whether the user has blocked
notifications from your app on API 19
and above on API 18 and below it'll just
return false that the user are started
true that the user has not disabled
notifications we're also giving you more
information about how users rate your
notifications so if they think that your
notifications are less important or if
they want to block them completely we
have a compatibility method that allows
you to do that and use the API on older
versions it'll just return basically a
no op value that says your notification
is normal priority we've also made some
changes in the media framework so in API
21 for compatibility with Android auto
and where media browsing and playback we
added the Media Browser service and
Media Browser and in support v4 we're
now bringing back ported versions of
those so these are inter compatible with
each other on v4 and above so if you
have an app with a Media Browser service
that's exposing media that can be
consumed by a media brain
if they're both running compact from the
support Lib they're also compatible with
the framework implementations on 21 and
above so if you use this the support
library versions they'll be maximally
compatible work with a lot of devices
for a fully functional implementation of
both of these classes you should check
out the universal Android media player
which is in the Google samples on github
right and for applications that are
presenting web content you have a couple
of options right now you have an
embedded webview maybe you launch a
browser instance and these have some
issues they can be a little bit slow if
you're launching a full browser instance
you kind of bring the user out of the
experience of your app so custom tabs
are a new way to present web content
that we've already presented and we're
making some improvements to those so
this is new in 23.2 with some
improvements in v.24 the minimum SDK
target for this is 15 and the reasoning
for that is primarily motivated by what
most apps are targeting now so chrome is
has a minimum SDK target of 16 and above
so if you're using this on API 15 likely
your users device won't have any targets
and you'll just launch the regular
browser instance or you'll need to use
an embedded webview as I mentioned this
is alternative to a wedding embedded
webview that is performance focused so
it's going to share a cache with the
browser it's also going to share cookies
with the browser so if your user is
already logged into web content that
will be persisted when your application
loads that into a custom tab and because
we don't want to leet we don't want the
user to feel like they're exiting your
application we have a high level of
visual customized ability and navigation
callbacks so if the user leaves the
content that they landed in initially
your application can perform something
in response to that so here's a quick
example from the chrome blog of how fast
custom tabs is compared to some of the
other solutions because we have a
warm-up that can spin up the chrome
process in the background before you
actually launch your custom tab
and because we're able to preload and
pre-render content you can have an
almost instantaneous transition from
your app to your web backed content and
this is really simple to implement so
here we have an example of one-liner
warming-up of the chrome process and
launching a custom tab for a specific
URL one downside of this is that because
we're just very quickly spinning up the
chrome process and we're not keeping any
handle to it the process may be
collected garbage collected in the
background if the system is memory
pressured so one other thing you can do
is write a lot more code to create a
persistent connection to a custom tab
service for my examples I've been
talking a lot about chrome but this can
also be implemented by other browsers so
you may see Firefox custom tabs as well
but you'll need to handle connect and
disconnect with your activity life cycle
here and you can create a session
session to the custom tab service is
going to allow you to do some cool
things like pre loading content so here
we have one target URL that we know
we're going to land on and we have a
couple of links out of that that we have
a pretty good chance that the user is
going to land on
so as we load these that means that
we're using data that means that we're
using battery so you don't want to just
indiscriminately put thousands of URLs
in this you want to have a really good
higher than 50% confidence that the user
is going to need these so that we can
preload them and show them really
quickly right in addition to being fast
we want this to be seamless so we
provide a lot of customization aspects
that you can set up when you're building
your custom intent to that and then you
can customize the toolbar color so here
we've colored it teal to match our app
and you can also customize the actions
so we have a favorite action that we've
added bottom you can add actions to the
overflow menu and you can also set up
transitions so that you have animations
in and out of your activity that look
like a natural extension of the rest of
your app so this is really great it's
really easy so these are all just things
that you set on your builder when you're
launching your intent
and then you launch it out to the custom
tabs process and as I mentioned this is
API 15 and above if you're on older
devices or devices that don't have a
browser that supports custom tabs you
can also have a fallback path for either
launching the browser intent for view or
simply launching an embedded webview in
your own application all right so I've
covered some of the major features in
recent support library history but there
are some other features that are highly
anticipated that I will let Tang me and
Chris talked about so over 210 we for
vectordrawable
Thank You Alan great before we talk
about technical technical details for
the vector drawables let's start with
some design principles we have when
we're designing this new classes first
of all the first question we may have is
like why do we need vector graphics as
we all know Android has been using Bing
Maps for a long long time for the icons
and drawables and as the phone and
tablets grows bigger with higher
resolution those PNG files is ticking
more and more spaces in your apk file
and vector graphics is the perfect
solution to this problem it is using a
much smaller compact file format to
represent those icons and can scale to
any definition resolution in this
example on the left hand side the
multiple PNG files can take up to 10
kilobytes but on the right hand side
there's just we just need one single SML
file to represent the same icon which
can take only one kilobyte with more
icons in your APK file then that means
you can bring down the apk size
significantly the second question we
commonly get from developers saying why
do we not using SVG file format
I hope you all know the SVG is very
complicated for a spec and it's truly an
overkill for representing those simple
small icons for your Android app
moreover we want this newly designed
adorable is consistent with all the
other Android APRs especially those
animation API and theming API and work
nicely with all the other resources so
we introduced the vector drawable and
animated vector drawable in lollipop and
they work nicely for API 21 and above
and they use heavily inside Android OS
to bring down our system image and
because our simple design principle we
can continue to improve the performance
on this No I'm glad to report that on
Android and release we improved the
joint performance by two times faster
and the initial file parsing performance
up to five times faster and here is a
symbol of like how the vector drawables
file format looks like it's basically
just a tree structure and it's quite
similar to SVG a simpler all the
internal notes here are a group notes
and they are using two describing the
transformation information like scaling
translation or rotation and the leaf
nodes are the pet notes and they are
used to describe the geometry and Colour
information based on this vector
drawables format the animated vector
drawable is just simply adding the
object animators on top for example we
can set the object animator to target it
to one groups now through its rotation
attribute and set the value to change
from zero degree to 360 degree and when
the animation started then you will see
all the children nose will be rotating
in a circle
also you can add more object animators
to different notes to their different
attributes to make your animation looks
even better there's one caveat you may
be able to see here that means one
animated variable could involve multiple
sometimes even like ten or twenty XML
files to ease the pain we actually
introduced a new SML bundle format to
merge related SML files into one this is
in the latest bill qu and is also
backward compatible and here is one
example the animated vector drawable is
referring to a vector drawable whose
name is called icon and sit in silence
separate file by simply changing the
enjoyed job or attribute into this new
apt tag then you can cut and paste the
vector drawable the whole file into this
tag and then you merge two files into
one you can do the same trick for all
the object animators too
so basically you just need one single
file to represent your animated vector
drawable then hopefully that would be
easier for you to wait and debug this
drawable and now I will also briefly
talk about how do you generate those
vector XS and luckily we have Android
studio to help the first thing you can
use is this vector except with
procedural dialog in here you can see
all the material design icon library and
you can just pick one you like and it
will be saved in your job or directory
or if you have your own SVG files for
those assets you can also use this
vector XS studio inside Android studio
to convert your own SVG files into the
vector drawable XML file now I hope you
feel you can see these new classes is
useful to you but the major
questions we often get from developers
how can we get this new classes working
in the older version of Android we know
it is so important for you we actually
come up with two solutions the first one
is greater solution inside Android
studio when you bill your app the Gradle
will look at your minimum SDK version if
there's less than 21 and you also have
vector drawable XML in your job or
directory it will convert this XML file
into multiple PNG files for different
dpi automatically in a generated
directory and then the XML file will be
used for API 21 and above and the PNG
file will be used for older versions
then the best thing for this solution is
simple adoption so the only thing you
need to do is to swap out the PNG SS
into the SML SS and then Gradle would do
this by default and it will check the
minimum SDK version automatically
there's also some downside for this
solution
there's no animation animated vector
drawable support and it's only
supporting a limited features of vector
drawable and the last one is the
generated PNG file could still sit
inside your apk so on this we all all
also recommend you have a separate apk
supported by play you can have one for
API 21 and above which will only contain
the SML file and have another one for
the older version which will contain the
PNG file
we know this song like a hybrid solution
here so we continue to work her and then
we get out this more pure solution here
and based on support library in version
23 point you of support library we
introduce two new classes one is vector
drawable compact and animated vector
drawable compact so from the name you
can see we are supporting both
static asset and the enemy the exit here
the best thing for this solution is it
is SML files only there's no more PNG
involved at all and the same SML format
a file can be used for the support
library version and a non support
library version and we any also support
the full feature set of the vector
drawable there's some caviar for this
solution first you will need to turn on
a special grade of flag which is vector
drawables use support library which
basically turn up the PNG generation and
also have some special treatment on the
vector drawable XML file second you may
also need to be aware of the API
versions for example the vector drawable
compact is used only it's only back body
to API seven and animated vector
drawable is back Tata to API 11 and here
is one example I am using the support
library I manually create those SS and
it actually can run all the way back to
honeycomb as you can see you have the
scaling rotating and even like some clip
masking moving objects and there's also
some color change I know you developers
will be more creative than me I hope you
can also promote sweeter UI for your app
and without any much overhead to your
apk size last thing for this suppo Larry
the trouble reference is somewhat
different if you're using the old way
the image view of our sample if you
using the Android sauce it may actually
cause some exception in the older
version of system for this one I
actually have to ask our owner an esper
of a compact library quiz to help and he
came up with really nice solution so now
I will welcome him to talk about it
thank you
hi everyone
so Tengu is just spoke about sort of the
background behind vector drawables why
you would use them and the benefits of
actually using them so I'm going to talk
now about how you actually use them with
the support library and just one note
here I've abbreviated vegetable compound
and I'm a vegetable I might venture or
compact so if you see later in the
slides that's what they mean so the
first way you can use it is manually so
each class has a static method on it
called create which takes a context and
a resource ID pointing to your resource
and that will manually inflate that
resource and give you a drawback but we
know that's kind of clumsy to use for
two reasons number one you can only do
in code and number two you can't
actually use it from resources which is
you know it's the whole point you
actually have them so we went back to
the drawing board and before how can we
actually implement in app compat because
that has a lot of resource management in
it anyway with views and stuff so I
think that's really the best place to
actually implement this feature so we
have a couple of ways of actually using
it within app compat we have a new
attribute on image view called source
compact and that is basically a it kind
of supersedes Android source and that it
allows vector drawables all the way back
to IPR 7 and 11 for the animated
versions we've also overridden the set
image resource method so if you're using
that API anyway to set rebels you can
use vector drawables back to the same
API levels now for anything that compact
inflates itself so here's a good example
of menus when you inflate a menu in app
compat out compare is doing all of that
for you
so as it is doing it we can inject the
vector drawable compact class into it
and load the drawable for you it's a
basically we never touch the framework
there which means that you can use
vectors in those resources and they work
back to a 5 7 and 11 now around 23.2 I
wrote a blog post on medium called age
of the vectors and that had a section in
it which I called there's a section
called the magic way which is a really
bad name but what it allows you to do is
allows you to use the vector drawables
within drawable containers
now it was kind of experimental in that
it doesn't work in every situation so
that's why I put a bit of a caveat
around it we had to remove in 23.3
though due to some issues around memory
usage and also updating of configuration
objects we'll talk a little about why in
a minute
but thankfully we've brought it back in
24mm for you'll see there's that
asterisk next to it and the reason for
that is because it's no longer enabled
by default it's now disabled which means
that by default you'll know you won't
get the issues but if you do want to use
this functionality you can money of your
neighbor and with the caveat that those
issues still exist if you have a look at
the Javadoc of this method it's huge and
it tells you exactly what you're sort of
letting yourself into so what the reason
it has those issues is the way it works
internally it creates a special
resources instance but per up the per
context now in reality that's going per
activity usually your application the
resources instance you're usually only
have one which is reused across all your
activities and whatever else but the way
I compare has to work and the way this
allows this feature is by using an
instance per context now the increase in
memory usage is because of the caches
that each resource instance holds so we
said like one cash for drawables you'll
have like I don't know x times activity
now it isn't a leak in that as soon as
activity goes away the resource instance
will go and you'll get the memory back
most the most apps it won't really be a
problem and but if you if you have a
really resource heavy app you may see an
increase in memory the second issue is
because we also have that multiple
resource instance you can get into
problems if you manually call update
configuration and that's quite an
advanced call I don't imagine many
people are using it but if you do you
probably don't enable this feature
so to actually use his method this is
what I got
I advise you to actually use it it it's
a really lightweight method so in each
activity just stick a static block at
the top which calls true if you want to
use the feature and it's really
lightweight so don't worry too much
about you know putting in every activity
so we've talked about how to actually
enable it let's talk about what actually
gives you so as I said earlier it allows
you to reference vector resources and an
advanced effects of resources within
drawable containers so if you want to
use vector in a stateless drawable or
maybe a layer or insert or lever list or
whatever it is you can do so with this
feature enabled so we've got an example
where we're gonna wrap a vector drawable
in an inset drawable now this is quite
good because in set drawable if you
don't actually give it in in sets is
basically an invisible wrapper so you're
basically just have the vector drawable
and the container won't actually add
anything to it which means it can
actually didn't use it in more places so
here we got a text view and you can set
that wrapper as the draw left or we've
got the right or top you know whatever
it is but basically you can use it in
more places another example as a radio
button button these are just two
examples background works there's other
place as well so at least is nicely onto
app compat now app compat is designed to
be a kind of mini backboard the
framework so things like toolbar the
action bar all those sort of things I
mean back ported into here and they
currently was about to APR seven
recently so the pad sort past six months
the first big thing that I like is night
mode so that allows your application to
be themed light or dark based on the
time of day so here I've got an
application which is opened at noon and
it's a light background with dark text
and then if I ever use it open that at
10:00 p.m.
it'll be the it will be inverted so a
dark background light text which is
great for users if they've been in bed
let's go there so there's two things you
have to do to actually enable this in
your app the first is you change your
theme and change it to extend from one
of the theme
compact day/night variants so if you're
already using like no action bar or dark
action bar we also have those variants
on top of it and so it should be a
straight swap once you've done that
great but you need to tell app compat to
actually enable the feature and you do
that via the set default light mode
method now that method takes one of four
options the first is follow system now
most people don't know but night mode
has been in the framework since API 8
but before marshmallow it was behind a
couple of scenarios you had to be in car
mode and docked if you remember what
those were in marshmallow the feature is
actually always there but it you cannot
eat like it's you can enable it
basically but there's no usable visible
feature like there's no setting in the
settings for it so if you use this mode
in app compat basically we will always
follow what the system is doing the most
interesting one is probably mode night
auto and that will automatically change
between light and dark based on the time
of day and it will look at the last
known location of the device and then
try and work out a rough approximate
sunset and sunrise time and then use
that to say whether in day or tonight
that's very nice and then the follow to
that the last two yes and no which do is
like what you think basically day in and
day mode on night mode I wouldn't advise
you use these unless you have some kind
of user setting in your app because you
can achieve the same thing by just using
the proper theme parents over the dark
theme that I've compared or for light
theme to I come out to light if you want
to know more about this Alan and I are
talking tomorrow morning at 9:00 a.m.
and at or core themes and styles
demystified we're gonna get more into
this and also generally into themes and
styles another thing we've added in app
compat recently is color stateless and
specifically ones with theme - boots so
these were added to the framework in
marshmallow and we've back ported them
back to APR 7 and now this is in 24.0 so
if you're using the preview and you'll
have this functionality
internally app compat uses this a lot
for drawable tints which we've managed
to reduce the amount of log color stay
Disco's by loads or actually moving all
the ins of resources so it's an example
of just a kind of state list the first
item references a themed attribute in
this in this instance its color control
normal now the really neat thing about
here in this in the disabled item is
that you can using a color but you also
have this new functionality where you
can change the Alpha of the color at the
same time so using the Android alpha
attribute you can modulate the Alpha of
the color to whatever you want now it
takes a float value from 0 to 1 we're
just going to reference the system
default for disabled but yeah you can
set to it whatever you want to actually
use these and inflate them we've added a
new API called app compat and resources
so if you want to fight these use this
method we're going to add more stuff to
this class in the future and so yeah
Mach missing so follow along from app
compat we have the design library now
last year at last I've actually we
released it as a kind of first party
take implementing some of the components
for a material design since then we've
been in kind of book fixed mode and not
trying to stabilize it but we have added
some features recently the first big one
is bottom sheets now in spec there are
two types there's persistent and modal
persistent and when they are when the
bottom sheet is always part of your
content you can't dismiss it so a good
example is Maps here in that it shows
the detail for you know whatever the
address is or whatever on the right they
got the modal ones and that's basically
it described as being an alternative to
dialog so let's take a quick look at
what they look like so this is the
actual implantation as you can see as
the user Scrolls up and down it
collapses and expands but you can never
dismiss it and to actually use it the
first thing you'll note is that the
parent needs to be a coordinator layer
so if you use an app bar layout and
whatnot you're all set already and we've
been here you set the rest of your
content so in the map example it'd be a
map view and then we have our bottom
sheet here we're using a linear layout
but it could be whatever you want and
the way you actually tell it to be a
bottom sheet is by setting this special
behavior on it now in light write a
great post our medium
about behaviors so view one no more go
and read that first but this is the way
you actually tell it to be a bottom
sheet and then we also have an option by
default it will just sit the bottom of a
default peak height but you can also set
it to be what if you want the peak
height is how much it sits at the bottom
when it's collapsed the second type is
modal so I said it's like an alternative
to dialog so as you can see here when
the user clicks you get this modal
bottom sheet which you can scroll and
then dismiss so we know that most people
we've already scribed them there's an
alternative dialog so the way we've
tried to implement this is as simple as
possible
we know that majority people use and
dialogues we'll probably use a dialog
fragment so we try to implement this
using that so you should be able to just
extend and change the superclass of your
any of your fragments so this new bottom
sheet dialog fragment and they will just
suddenly become a bomb sheet it's really
simple to use I've used entirely in a
cup of app since nice once you've done
that you just create the fragment and
then call dot show which you know the
same thing as dialog fragment the other
thing in design library it's not really
feature it's more of a bug with fixed is
that any of the elevation handling was
previously hard-coded into the just for
ease of implementation for last year but
we should been trying to fix it so we
have there are free scenarios on the
material spec of app bar scrolling the
first is always elevated so here the
user Scrolls and regardless of the
scroll position it is always elevated
which means it casts a shadow basically
you probably can't see very well but it
is elevated and then we have the second
type so here the the header is not
elevated so it's in line with the
content and then as the user Scrolls and
it collapses it then becomes elevated
and then as I scroll off it doesn't eat
it's no longer elevated so that is
implemented using a clapping table while
I am but there's a third scenario on
spec which we didn't support and that is
when you have a collapsing content but
you also want it to stay elevated so we
were trying to think of ways try to
implement this in a nice way and the way
we sort fell with was stateless
so now we now have a stateless animatic
which controls all of the elevation now
this is similar to the button
implementation or material so when you
present when you click on a button on
material it was supposed to come to your
finger and large now that uses a
stateless animator internally to
actually do that so we're choosing the
same functionality so we've added two
states which you can use in your
stateless animators to actually import
this the first is collapsible which
means that there is classical content
within that bar layer and secondly it's
collapsed and that means that there is
collapsible content and it is also
collapsed so let's take a look an
example so here we're gonna implement
the scenario where you want it to be
elevated when it's collapsed so the
second scenario now this is already
giving you two by default you do not
need to implement this we're just going
to use this as a sample to actually show
you how to use the new States so here we
have two items with Miss Daley's
animator the first is ran when we have
some class for content and is also
collapsed so if you think back to the
scenario in that point it needs to be
elevated which means that we animate the
elevation up to eight dip now it could
be any value whatever you want look at
spec for the actual value should use
which is going to use eight dippers an
example and the second item doesn't have
any states which means it's the default
item therefore it'll be ran whenever the
first item doesn't hold true at this
point it is when the classical content
is no longer collapsed therefore we want
to elevate bring the elevation down to
zero and therefore it's not elevated so
as I said you don't need to implement
that that is done by default for you
just using an example if you think back
there was a third scenario which we
didn't model don't currently support now
that's a really simple stateless
animator it just has one item so it
doesn't even look at the states and it
just sets the elevations at a tip that's
all it does
to actually use this you just set the
stateless animator tag on your layouts
point into whatever status an almighty
you want and now we're gonna hand over
to Alan to talk about some of the sneaky
new stuff we're gonna plan him alright
thanks Chris all right so Chad was kind
enough to tease that we're telling you
about future things in support library
this morning so let's start out with a
little interactive part first a show of
hands how many developers here using the
support library good that's probably why
you're here all right show of hands keep
hand up if you're supporting API 14 and
above in your application or you know
we're lower 14 and above okay hands up
again we're getting exercise if you
support API 9 and above in your
application okay fewer people ah API 4
and above in your application Wow not a
single one guy one girl that's fantastic
that's dedication to your craft I
respect that you're not gonna like where
this is going
we are dropping support for api's below
9 this has been a long time coming so
less than it's only it's only API 9
don't get too excited so less than a
tenth of a percent of devices that have
access to Play Store are supporting API
is less than our running API is less
than 9 so dropping support means 1 we
have fewer methods so we're taking a
couple of steps back from your ProGuard
X limit yeah so about 130 methods right
now just remove from v4 we're still in
the process of backing things out this
is also going to reprove improve our
release cycle so we're able to now focus
on the same platforms that you actually
care about as it turns out supporting
API for takes a lot more effort than
supporting API 9 or 14 which is why most
people here aren't supporting API 4 so
we're going to be able to iterate faster
we're gonna be able to focus our fixes
and our workarounds for platform bugs
and our testing on the API is that you
actually care about so hopefully that'll
make your life a little bit better
second as I mentioned earlier support v4
contains backwards compatibility shims
so this is so you don't have to wrap
everything with a version check and then
figure out some reasonable fallback
behavior and support before started out
only containing this and then we added
some other things so we added fragments
in API 11 we figured it'd be good to
have a backwards compatible way to get
people on board with fragments
supporting older devices and then we
added some helpers for things like
accessibility and drag and drop and then
we added some more stuff and some more
stuff and support v4 alone has become a
very large library so we're gonna be
breaking that up into more focused
modules and the important thing here is
that we're going to support we're gonna
hold your hand through this process so
we're not changing any of the package
names I should also mention for the
minimum version change we're not
changing any of the package
so support v4 is still support v4
support v4 dot media is still support v4
media we're gonna be moving them into
different modules and we will have a
meta module that includes everything
under the old name so all of the
libraries that you use that depend on
the package naming structure and the
package names themselves of the module
names themselves will be fine we're not
going to end up in a situation where you
need a special version of a library
dependency let's say so hopefully this
is going to be a completely source code
compatible and binary compatible with
your existing applications and library
jars and hopefully this is gonna make
your life as a developer a little bit
easier so thanks everybody for coming
we have some other talks that you may be
interested in what the fragment today at
five data binding and recyclerview
thanks again everyone we'll see you
around
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>