<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Deep Dive Into the Gradle Based Android Build System (Big Android BBQ 2015) | Coder Coacher - Coaching Coders</title><meta content="Deep Dive Into the Gradle Based Android Build System (Big Android BBQ 2015) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Deep Dive Into the Gradle Based Android Build System (Big Android BBQ 2015)</b></h2><h5 class="post__date">2015-10-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Xw6CKEsWvxo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">had a funny incident last night I went
back to the hotel
and then you know went for my room put
in the room card and nothing happened I
forgot my room number tried out a few
other rooms and was completely weird
what is going on
so when down to the reception and said
either a card is broken or forgot my
room number let me see your card no
you're no Roman Hotel go down you one is
down the street is one further down I
said okay so it's not it's not even
finished a story then went when went to
the hotel I said wow it looks really
similar and then in a friend of mine
right I haven't seen for a while
and I just told her the story you know
what happened to me and so we went up to
the second floor and we said goodbye and
then she went to a room well she went to
my room and put a room card in the room
on my room du'a I said and she was in
the wrong hotel and she was in the one I
was before so that's the Hampton and the
holiday and that was really funny yeah
okay deep dive into the crater based
Android build system I'm Hans doctor I'm
the founder of Gradle and the CEO of
Gradle Inc and I want to talk about the
Android build system right the deep
concepts behind the Android build system
and why it is created that way and let's
start so what are the goals of the
Gradle android based build system I
think it is very important to understand
as an educated Android developer why why
what are the qualities what are the
deeper design goals of that build system
even if you use it from Android studio
right and it's still it's still I think
important to understand and also when
you compare it with other platforms and
it's also interesting to see how we are
actually doing in reality in regard to
our lofty goals right or not so lofty
we'll see so the first thing to
understand Android is a complex player
form right not quite as complex as C C++
but way more complex than Java right so
when you look at this diagram even if
you can't read what is in there this is
the workflow of building an Android
application right so you have and you
all know that you have complex resource
and code generation right you don't have
that in Java you have multiple different
languages the NDK Java you have to
interface definition languages and so so
there's a lot going on you have to
signing you have the deck saying plus
the compiling and so on and so on
so the original Java tools that were
used to build Android apps are not made
for that complexity that was and there
was eclipse and it was for quite a few
people Nathan right so they're already
hitting the limit in Java land and they
were not made for Android and and I
talked about it you know renderscript
and the native code and whatnot but
there's another challenge in Android
land
I call it platform diversity others call
it fragmentation and this has been one
of the biggest pain point for developers
to deal with right I just want to have a
little variation of my app for that
platform right and it was very hard to
implement with the current build with
the build system at that time so how to
make this diversity approachable from a
developer tooling perspective was a key
goal for the new build system ok I
forgot my transitions okay here we go so
what makes Gradle unique and what is
harnessed by the Gradle android plug-in
is that you have the expressiveness to
model the complexity right that you have
really concise descriptions of your
build
that's something may even do something
was doing a reasonable job in Java and
so that is that is a strength of Gradle
at the same time maven is concise for
simple use cases but can't go beyond
that and
or other similar kind of design systems
like a Facebook back or whatnot they are
very flexible but they expose a level of
complexity to develop us and build
masters that is at one point very
expensive to manage right so in Gradle
tries to combine the conciseness of a
declarative build language like maven
right without sacrificing the power and
and the flexibility and the extend
ability that you have with and an IV in
fact done right if you combine it you
get even better extensibility now we'll
talk about that later ok so to give you
an example what I mean with conciseness
right look at this very simple bill
definition for standalone Android app a
few lines of code you have two product
flavors right two dimensions and for
each dimensions you have two you have
two flavors right for the version you
have a free and a paid version for the
ABI you have a RM and x86 right so and
you could now do certain definitions
what you can already do when you have
such a definition you can put code in
source free or test in source free or in
sauce paid or and so say more sauce 86
and end what knows exactly the end what
builds into what to do with that
right it runs the free test only when
you built a free apk and so on and so on
so that is it is a reasonably simple
problem right and this is how it exists
is expressed so can you read that in the
last row no I'm joking
so when you do for this little build
script right when you do creative tasks
right - so all the tasks that cradle
creates - to build this right
you have more than 300 tasks right so
imagine how the end build would look
like right would be thousand lines of
XML right
with memnon Yellen it's completely
impossible to model this with unproven
one project maven will tell you well you
need a separate sub project per flavor
per test per flavor you would end up
with a sub-project 30 multi module maven
build or something like that right which
is also kind of you know hey I'm real
Android developer I have a little
requirement certain variants right I
want to express around my simple Android
app and now I end up with a 2030
sub-module maven build that's not what
you want to be challenged with as an
Android developer so so that gives you
kind of an idea right what what has been
achieved
so the key mission is accomplished
right there is now a powerful Android
build system with which you can
elegantly describe many of the typical
requirements you have one building
Android applications including kick-ass
dependency management right it has the
right mixture between flexibility and
structure right too much when you just
have flexibility you might have a lower
complexity to deal with as an Android
developer but if you have just structure
no flexibility you can't extend the
things so this is a this is a real nice
mixture and it's a true achievement by
the Google Android team who is
maintaining and creating the Gradle
android plug-in to have model to
functional domain of building Android so
well-well and based of course on the
capabilities of Gradle but and there's
more to come
so the foundation is rock-solid and the
feedback we are getting is that people
are very happy with that aspect right
and I haven't talked about performance
yet and I want to talk about something
else first so some other goals that are
behind this system it is not good enough
for most Android developers to just have
a good Android built right you have
back-end services right written in Java
C++ Ruby and whatnot you have other
libraries to deal with and potentially
written in other languages and you want
to be able to integrate deeply with
those during development cycles right
you don't want to be the isolated Andrew
team like it is still today in so many
organizations right the Android teams
are isolated from the continuous
delivery process of the rest of the team
and that is not good right
the people writing the back-end services
should be able to ask the question is
this change breaking the Android app
right and that is often not possible but
with Gradle you know I have to tool to
have a really unified build experience
right and Gradle is a powerful poly
cloud build system so with strong
support for C C++ and Java also for
Python and and interesting wrapping
around the JavaScript ecosystem so
LinkedIn is a very good example for that
link in has in a matter of languages it
all builds with Gradle and one or the
other way book 40-plus languages some
are very exotic all built with Gradle
right either with a direct
implementation or with great like with
Python adding some functionality on top
of the existing Python tool chain right
they've also integrated the Hadoop
developer tooling around it so so that
is a big benefit you get right if you
work in a team if you're not just
writing Android right you can you have
now a build system that can integrate
all the different pieces much better to
give you an idea of the scope how Gradle
is used in some organizations at
LinkedIn it is used by 2,000 engineers
and they have three hundred thousand
created build executions per week right
so the biggest Gradle build has 3,800
sub modules and and one other thing that
is interesting with LinkedIn like more
and more organizations they switch from
teams that have been created around
technology the Android team the iOS team
to functional teams right so teams that
share the backend and the different UIs
and apps that are they developed around
a set of functionality so now for Dan
it's even much more important to ever
have a build system that wraps around
the whole functional team right even
though they're using very different
languages
okay before I talk about performance
extensibility it is not just good enough
to solve the standard requirements even
in a polyglot salad right so you get a
lot of out-of-the-box stuff from Gradle
and so the example projects all work
right but people that are ambitious
about developer productivity and
automation and all work in a more
complex environment desperately need
extensibility right so with the new
build system you are able to inject
custom steps anywhere right you have
deep api's with listener frameworks to
get into the guts of the system if
needed even in a test execution you can
hook in a listener with Gradle hey send
me an event after you've executed the
test method I want to do something with
it whatever that may be
right maybe you have a fragile test you
want to deal with and you say oh this
test I need to run again to make sure
that it has really failed whatnot
whatever pathologies you need to embrace
right as as part of your work and they
are powerful features to integrate
deeply any other technology tool chain
into your build alright so and and it's
not just extensible you can extend it in
a way that you build stays concise right
you can extend the greater declarative
language with your own declarative
language element to make it very easy
for you developers to to work with your
custom requirements and even if you say
our extensibility is not important for
me well in an indirect way it is because
you will benefit from it by a very
powerful plug-in ecosystem that depends
on this extensibility right and they are
really interesting Android plugins out
there greater ran so extensible the
plugins wouldn't be so powerful so even
if you don't extend it you have a more
powerful plug-in ecosystem out there of
Gradle plugins that you can use forget
my transitions
okay so cradle is a very strong
foundation for the Android build system
it is a build platform whoops with
massive tractions we had just crossed to
1 million downloads per month 9 in
September it's evolving very fast we had
19 feature releases in the last three
years and we get a large amount of
contributions from individuals and
organizations like LinkedIn Netflix
Google Android unity technologies and
many more
so a lot of innovation is happening and
Gradle is a generic automation platform
right for whatever you want to automate
you can use it because you you as a
developer you're not just creating apks
you are shipping software with a group
of people which is a much larger scope
right you might want to have Auto
provision dev environments you might
want to generate documentation for
client API that you are shipping we're
all code snippets our integration tests
that's how we ship our documentation
every snippet in the Gradle user guide
is live tested we run before why we
creating the user guide we run the
integration test right against the
snippet in there then we extract the
output of the integration test and
insert in it to the user guide to make
sure that we don't have the money for an
editorial team I don't want to spend it
on that right and still want to give you
high quality documentation all right so
so when you really think about shipping
software there are so many tasks you can
automate right and and once you have a
system you that allows you to do that
you can get really creative right you
want to have a fully automated release
process you might want to have central
version strategies for the libraries
you're consuming automated database
migrations container integration for
your for certain integration tests right
how to deal with fragile tests big
problem we see in many organizations
right when you have a build system that
says well you can only have one group of
tests right that and when you have when
some of them have Redshaw test it
usually means people start ignoring if
this test suite fails yeah okay might be
interesting that it fails might be not
so with greater you could easily isolate
to say okay your non fragile test I put
in that group
right and they are really part of my
continuous delivery pipeline if the CI
is failing here everyone stop work and
fix it and then there's the other group
of tests a fresh are the menu will test
us might still use them to get some
indications but I don't want to rely on
them for my automated pipeline right
stuff like this or you have very
time-consuming suit of integration test
right where you want to maybe separate
them into DB integration tests UI
integration test so that you get faster
feedback people that work on a database
only want to create one to execute the
DB integration test before they commit
because they don't want to wait another
hour right so so there is a lot of
interesting stuff in the domain of
continuous delivery it's a complex
domain Gradle is your friend and so be
ambitious about automating your whole
your whole shipping process so let's
look at an example of some of the nice
features that that how Creator can help
you in getting better into the flow and
and achieving a higher degree of
automation so this is what we have here
is is an asciidoctor project look at
this so it's built with Gradle who of
you knows asciidoctor I asked you doctor
is a markup language more complex than
marked down it's kind of replacing the
dot box and the latest of the world so
Riley is using asciidoctor only since a
couple of years I think for their books
and so so there's a grade alaska doctor
blogging out there let's look at that
project right we have a source main java
directory so it's a java project and
with asciidoctor we create a manual for
that can you see that by the way we
create a manual for this Java library
right and example - manual is the is the
is - source file for the manual ok so
let's look at the source file
so here you see the asciidoctor
asciidoctor annotate on a map map a cup
language and we can now tell cradle hey
turn this into a HTML page all right so
we did that now we open the HTML page
and you see this ask you doctor document
now rendered in HTML okay so let's
change the source file to ask you doctor
file let's do something exciting
now go back to the command line you
build it again maybe fresh I don't
expect you to be excited yet so so now
don't let now we do something exciting
we run the asciidoctor tab in the cradle
continuous mode - - continues and what
you can see now now cradle listens now
cradle listens to any changes right so
if we now go back to the document that's
something really exciting and we save it
we don't need to rebuild we just do a
refresh and it's updated right and yeah
and of course we can continue to do that
continuous mode introduced with Gradle
2.5 and we are super excited about that
so we save it again we do a refresh and
here we go and yeah and you can now see
that the changes were detected so the
builds were executed and and
the interesting thing I mean is not the
first time that there is a watch
solution on the market you have that
you know you have four people doing Ruby
they had that and whatnot the special
thing here is you don't need to specify
anything you don't usually order all
this watch solutions you need to specify
some clock patterns where to look for
and what to do if that pattern changes
creator knows all that we have a rich
input-output model you just say run this
task in continuous mode and greater
knows exactly for what changes to look
because the input and outputs are
defined in a Gradle build that makes
sense so for developer it's super easy
right you can do this with any Gradle
task they don't need to configure
anything for this right and so for our
so we use that in many places internally
right documentation is the place in
other places if for our to our upcoming
cradle come offering right we we our
whole back-end app right is using the
continuous mode we started in continuous
mode and then whatever whatever we
change in the app right it's
automatically picked up the app is
redeployed and it's a wonderful rapid
application development mode and think
about what that means from a deeper
point of view so so so we're the shed
was LinkedIn yesterday and their goal
for next year is that they developers
never need to directly call the build
system that is the goal for 2016 so how
do we are going to achieve that that is
a key tool for that so they basically
will bundle a pre-configured continuous
mode settings with the IDE right so when
they when the developers fire up the IDE
they're not just fire up JetBrains
IntelliJ if I up a whole set of rules
that cradle gets instructed with what to
watch for right so when you have some
some source code generation some
specific one right you just fire up the
IDE it starts the continuous mode and
you develop us to some changes and let's
say the XML configuration file and boom
Gradle will automatically bility
developers don't even know is that the
IDE doing this is that the build system
doing that well and and the whole thing
is the IDE right it's the whole thing
and so so I so I'm super excited about
how continues mode can can basically
the capabilities of a classic IDE
because finally your IDE becomes
extendable with Gradle right who of you
has ever written an eclipse nature on
Eclipse builder who wants to do that
right yeah so and IntelliJ is the same
thing build systems are made for this
kind of stuff so continuous mode is
super super exciting capability and and
I'm sure we will find interesting
opportunities to integrate that with
Android studio so we already had a chat
with the guys and we will see what comes
out of that ok talking about Android
studio one of the most important goals
of the new Android developer tool chain
was a true Android IDE that natively
understands Android projects right in
contrast to let's say the Eclipse ADT
project right and and and the other key
goal was the IDE should build the same
way as the command line and CI right
that you have consistency and coherent
quality of service of the def tooling if
you remember Eclipse ADT had a separate
build system right you had an end built
on maven build whatever you Cho should
have chosen right but when you were
working in Eclipse ADT it came with its
own tool chain own merging on everything
right that's how you had to do it right
there was no way to deeply integrate it
so the goal of Android studio was the
IDE is not doing any actions themself
anymore right every every action execute
test generate resources is delegated to
the underlying Gradle build so that
whether you execute your build from the
command line or whether you're just
working Android studio it's exactly the
same behavior so and so unified build
system and I talked about with Gradle
you can now extend your build system
right you could easily write let's say
let's say you're working in Android
studio on some widget that shows you a
quote of the day right so you could now
let's say if it's just for fun for your
developers just you just use it for the
debug for the debug build time right and
you could now easily tell Gradle hey I
want to hook in another task while you
are generating the resources and I want
to I want you to retrieve the quote of
the day from some server and edit to the
resources files right so you just add
that task to your build script and if
you're working in Android studio because
Android studio instructs Gradle to
create a resources you will now have in
your in your visual design which it you
will have always a changing point of
today right so you get the point right
it's now fully integrated with Android
studio because Android Studios they're
getting everything to Gradle so you so
all so you can now really powerfully
extend your IDE with Eclipse ADT would
have been completely impossible separate
worlds what you do in the build and what
you do in your IDE and your idea is
usually not extendable right so and the
other part besides being extension aware
is as the Android domain is deeply
modeling cradle it is easy for Android
studio to arrive rich information from
the build spec all right so so if you
look at it at an example right so here
we have here we on Android studio so we
have that we have two product flavors
free and paid right
they use different for whatever reason
and use different version codes they
could use different dependencies but
that's not what I want to show here and
and so now we go into the visual mode
right and we can now change I will have
a stiff neck after this tour do you can
out change because I don't see that on
my screen the built very end right so no
issues free release and if we if we
switch to pay T bar all right that is
deep IDE integration and that's fun
that's how it should be
right so okay
I want to show you
yeah I skip the whole tooling API topic
so we have a special library that we
create so that I des can interact with
Gradle right period Android studio plane
IntelliJ or eclipse don't need to go
into detail the only thing that is
interesting that's the only thing I
would like to mention so so we support
we we we ourself create the cradle
plugin for eclipse or I should say yeah
the creative plugin for eclipse plug-in
ecosystem to be very clear and we only
do it for Java right we're not working
on Android support for Eclipse and one
thing we have added that is really nice
I talked about how you know what a deep
API Gradle has what you can now do from
eclipse is when you go to your package
or to any test class and you can
right-click it and you say execute you
know all the visual view you then get
that shows you the test execution
execution windows for test within an IDE
classically the IDE s come with their
own test runners right so now with build
chip you have no the same visual
representation really nice runner
alright that runs the test gives you a
green or red button but actually all the
tests are executed by cradle and with
the tooling API will hook into the
eventing system of cradle and can have a
really nice rich representation at the
same time it's no longer that eclipse
has a separate test execution and cradle
and think about it what it means for
integration tests I've been in many
organizations they told the developers
if you want to execute the integration
tests from your IDE you have to go to
the build wiki and what before you
integrate your integration tests you
have to go to the command line and
execute with your Gradle and may even
build a fire up database create test
data some manual step and then you can
run the integration test from eclipse
because you couldn't extend Eclipse to
do this kind of stuff
now with Gradle all this test picture
setup is implemented in Gradle so if you
now can run your your
tests executed by cradle from 90 you
don't need to go to any built wicked you
develop us don't care they just say run
my tests and great and make sure that
all your test fixtures properly setup
right because it's extensible okay so to
wrap this up I want to look a little bit
under the hood of certain core concepts
so so this is the plugin that has Gradle
hey this is an Android application and
we called that a declarative element and
we'll talk about that in a second what
we mean by that so first of all it
constitutes certain conventions right if
you tell created it as an Android
applications we say if you if you then
put certain things in certain places
like you know like the source code enter
tests s defined by the conventions you
don't need to specify anything right and
just by those few lines of code and
sticking to the conventions cradle will
provide you all the tasks that are
necessary to deal with this application
so that's why we that's how what we
define as a declarative element in a
build script the declarative element in
a build script is something that
specifies to what this is an Android
application the how is automatically
figured out to you by for you by grader
right the X we call this the executional
units right that every build system has
right you don't need to specify them
directly in and and it's fully
imperative right you you you you as a
built ortho or built as someone that
specifies to build with and you have to
do all the specifications why are
directly why the executional units why
the targets right with Gradle you have
declarative elements and the executional
units are derived right so so the
interesting thing and this is where
cradle goes way beyond other declarative
built systems you have very fine current
declarative elements so
to build types and you can specify a
release type or we have two product
flavors where you can specify free and
paid product flavors and those are not
simple kind of this is not like simple
configuration actions what you're doing
here you really you really using new
declarative elements what do I mean with
that when you specify I have a free
product flavor you trigger a whole
little mini framework right use when you
say I have when you when you specify the
free flavor cradle will automatically
create a number of tasks right to deal
with this free flavor assemble in order
free apk or resource generation a test
task that only executed the tests for
this for the free flavor you have a
certain set of conventions in place if
you now put code in source free it will
be automatically picked up so this is a
very powerful element right so and after
adding at the fact that you have a free
free flavor right you can see all the
tasks that are automatically created as
part of that so so for us yeah
declarative elements are a very
important concept to create give you the
right structure between the right
mixture between flexibility and
structure high-level declarative
elements right that you can that you can
pick and choose to describe your
requirements and what is a key goal for
us that you can describe it with your
domain language we don't make you think
like a build system you can think like
an Android developer specifying what you
need and we translate it into build
system concepts if you need to do some
really deep customization yes you need
to understand the build system right but
not for your normal for your normal work
okay finally performance so let's talk
about the created core performance right
unrelated to end were just the cradle
performance as a built system right
cradle is a very fast boot so if you if
you look at Java and you execute let's
say a 25 sub module Java build
clean and and create me all the jars of
that right that's too fun and I think
with the latest graded versions will be
under two seconds right you can do it in
parallel so with the latest graded
versions it would be a one second and
and if you do incremental mode you know
what I mean so this is this is all
cradle has a and we continue always
continue to work on that right there's
now a two hundred sup to and a
sub-module build right and even that is
if you do a full clean build it's not
strictly slow right see that and again
we have improved that even since I since
I did two recordings right so seven
seconds for two hundred SAP module
builds with with with a lot of code is
fine right so so and we are working with
some very large software stacks right
and they have extraordinary performance
requirements and one on our goal is to
be the fastest build system in the world
right and especially for those large
teams to to bring them finally into the
agile and when you have to wait for one
hour until you build finishes you can't
do agile development right and and the
LinkedIn build time got down when we're
creating from an to cradle from five
hours to 30 to 40 minutes right it's
still too long we want to get it down
under a minute we want to get there with
distributive bills and stuff like that
there's a lot of stuff we want to do we
want to be insanely fast even for very
large projects so but the key message
here is huh but even if we had all those
capabilities already in Gradle that
wouldn't remove the major bottlenecks
with Android build performance that you
are facing nowadays right so let's look
at the Android tool chain oh so you have
Android it's good to be aware of those
layouts right you have to create a Java
performance it's very different from the
Gradle android performance one reason is
that the Java compiler is very fast
whereas the Dex thing is not quite as
fast if the Java compiler were ten times
faster and the Gradle builds were ten
times faster and Java
we couldn't you could you shouldn't
press us you should press the Oracle
Java sitting right so we integrate with
a with low-level toolchains
s it's also the case with Android right
so so if you have bottlenecks in Android
tooling it's nothing has nothing we
don't maintain those tools we can just
use them right at the end of the day I
understand that you want fast builds and
that's what we will achieve more and
more but it's still important to
understand down right so and so you have
to enter our tooling right maintained by
the Android platform team you have to
create a platform and tank by us you
have to Gradle android plug-in
maintained by the Android tooling team
and you have android studio ide also
maintained by the Android tooling team
right Android studio is usually never
the source for any bottlenecks right
it's the three the three layers below
Android studio that have been improved a
lot but we will continue to improve that
that that you will have a very fast
experience but still it's interesting to
understand that there are different
layers right and so and all those teams
they are working closely together right
to achieve that goal right and they're
all doing a great job and just that you
can't solve everything at the same time
it was a lot of work to introduce the
new system right it's it's a massive
including a new IDE so so certain
optimizations will follow up later and
they're now always work in progress so
so let's talk about the cradle and and
by the way this was just the tweet today
from Gradle 2 for 2 to 8 incremental
builds went down from 10 seconds to 5
seconds on one project and 20 seconds to
11 seconds on another so always remember
to up to upgrade to the latest rated
versions we did a lot of improvements at
the moment coming with every release and
we release every 4 to 6 weeks right and
use the greater daemon if you're
building from the command line otherwise
so um
about that so let's look at some numbers
what how things have been proved right
so let's ignore one two two one
so you see the big improvements we had
for ten let's say a ten Android pretty
big Android build ten sub-project 10
variants per sub projects right we got
to build time down significantly
right this is now pretty extreme one
Android project with 400 variants but
you can see its array yeah so if you're
not on created to four right that is the
minimum you should be at because that
dramatic performance improvements right
so let's talk about the existing
bottlenecks right so what I use as my
guinea pig is the i/o editor at Google
i/o Android app from 2014 it's on github
it's open source so it's a nice it's a
nice it's a nice guinea pig it it's
pretty representative it has a bunch of
source libraries it's using and so so
when you look where the time is going if
you do a clean install right that it
that what at the end of the day what
you're interested in is the developer
you you do some changes and then you
want to see the changes either you want
to run your instrumented test which
require an install or you want to work
with the with the deployed application
on your virtual device right so you see
the big the big bottlenecks are texting
and pre-dexing
and installation right that is where I
don't know 90% of the of the time is
going right when you do a clean install
when you when you move everything and
you build again so the I want to talk a
little bit about the pre-dexing so the
libraries your android project depends
on also need to be dext right not just
your compiled source code and this is
done during the pre deck step and the
google android plug-in caches the Dex
libraries so that the next time you run
the build texting will be much faster
right but if you do a clean build this
cash is always deleted and all the
libraries you depend on needs to be pre
dext again
and that's if you look at this
pre-dexing this takes the longest time
right so clean builds are heavily
penalized if you like right or first
built because pre-dexing all the
libraries you're using takes such a long
time right and so we have some what what
we want to do right in over the next
three to six month right is a couple of
things right so first of all the
pre-dexing of your libraries is not
happening in parallel right so when you
have 50 libraries one is text after the
other the other thing that is something
we want to improve we want to put your
pre dex libraries into a cache that
survives it clean it sometimes you need
to do a clean and then when you always
have to have to pre-dexing it's a pain
in the neck right so so we want to
basically put the pretext libraries into
our library cache that that will survive
a clean alright so this kind of look at
a cache that is that it's much more
long-lived we want to use for those
pretext libraries of course we have to
store the version of the texting tool
chain so that if you upgrade to a new
Dex version we don't want to use this
cached version so we need to have a
reliably reliability in there but that
is something we will work on so so that
means the pre-dexing
when it will be will become faster
because we're paralyzed it and it will
survive a clean so you will have to do
it not much less often so pre-dexing
that is that is how how does it's going
to be trust so and what we also are
going to start working on next year is a
distributed cache this means I talked
about that we put the pretext libraries
into a cache on your local machine that
it survives to clean the next step is to
put it in the cache that can be shared
with all your developers so if one
developer has already protects the
library dam together don't do it again
or if you see I build has already done
that get it right all those sources will
feed the distributed cache right with
with build output right and then other
members of the team don't need to read
which means if you if you are not just
the one people team right if you have 10
50 people or let's say even 10 people
and a CI server
it means you will hardly ever have to
wait for pre-dexing once this is
implemented right so caching pre Dex
libraries across clean bills and
paralyzing pre-dexing will cut the
amount developers need to wait for
protection by an order of magnitude
right and so that that's that's good
news those are the things we want to do
so this is now the most common cycle you
don't do a clean bill your Android
studio right you say do Rian's I did
some changes now reinstall to my device
right now the situation is like and you
only let's say changed a single class
right still you have now no pre-dexing
anymore so it's twice as fast but but
still 33 seconds it's not paradise yet
right
so most is most time is spent now on
taxing and and then the other big chunk
is is installed right and we will
continue to work on making the other bit
bit right before Dec saying all the
stuff trailer needs to do before Dec
same configuration time this will get
faster and faster but obviously even if
we get all the other stuff down to zero
right it's still 75% is still there
that is not yeah that needs to be
addressed
so not requiring to do a pre Dex cuts
the build time in half so we said it's
not dominated by dexing and the problem
we have at the moment is a couple of
things so first of all texting takes
long right and and it's also not
proportional to the numbers to the
numbers of changes you did right even if
whether you change one file or hundred
files everything will always be read xed
your whole code path so so you have you
have a non incremental slow
DXA right now right and there are there
is stuff on the way to improve that
right there's not much greater can do
nothing at all to me to make texting
faster right so the Google Android
platform team is working on a new dexon
compiler called Jack who has heard about
Jack so I don't have any deep knowledge
about Jack right can only you know have
a look at the website what they're doing
the idea is that it consolidates two
source code compilation indexing into
one step right so no longer sauce byte
code a dalvik bytecode but directly from
source to dalvik bytecode and Jack has
already an experimental incremental
option that you can use so they're
serious efforts happening right and
incremental dexing plus faster
pre-dexing will lead to dramatic
improvements of developer time all right
so so I think with a little bit more
patience I think you should yeah things
will significantly improve when it comes
to your the performance of your of your
development cycles okay what else will
the future bring I talked about
performance in detail right for us this
is at the moment one of our one of our
major on the effort and so yeah you will
every greater release would be faster
and with the other changes I talked
about the specific Android bottlenecks
when they are when they are gone you
will have extremely fast Android build
so that they will come there is already
the new experimental and Gradle android
plug-in out there right it is based on
what we call the new cradle model which
has much much faster configuration time
which will eventually give you parallel
task execution so this is so I mean it's
still very experimental but it's out
there it's open source you can use it
right so to see what the future will
will give you in the benefits you have
already in this new plugin are
significant right performance wise
so with the so the new android plug-in
just the configuration time for ten
android project with ten variants with
the with the next generation android
plug-in has already cut down by a factor
three and more to come so okay
extensibility is already at the very
strength of the build platform but but
especially android is pushing our
extensibility to a certain degree we
have to create a platform we have the
Gradle android plug-in we have some
greater plugin by some virtual testing
provider in the cloud like testdroid and
then we have organizations that do their
do their own extension so when you have
this kind of extension hierarchy you now
we now put you sometimes in a situation
that you need to do some workarounds to
get the configuration auto ride and
stuff like that so we want even in this
very complex extension scenarios we want
to provide you a more solid extension
model that's that's something we're
working on and even if you don't use it
directly you will benefit from that that
ecosystem can can work better for you at
the other big area we're working on is
dependency management so we want to
support fully variant where dependency
management so that you can basically
have Android libraries and and Java
libraries that are we're not just about
their version but also is this debug or
release type library right for NDK is it
64 bit it is 32 bit and to make that a
first-class citizen when you do
dependency resolution that is exciting
work see C++ is a very important
platform for us we are partnering for
example with unity technology who are
migrating the whole native stack towards
cradle and the NDK support in a new
experimental android plug-in will no
longer be based on meg but on a greater
c c++ plugin and we're very excited
about that
so you will have a similar rich
a declarative language to describe your
native code requirements who of you is
doing any NDK work so that should be
really nice ok so last but not least we
are releasing assess offering very soon
that allows you to connect your local or
CI builds right
all your Creator builds in your
organization with our SAS offering and
and this service will help you with
understanding why something is wrong
with your build or why or helps
developer to understand why the why the
build is not happy with the code why the
tests are failing and things like that
so why is it working locally and why CI
failing and those kind of questions so
very excited about that if you're
interested please sign up for for the
better wait list and you should be yeah
hopefully in November we can we can have
a full GA of that product if you want to
learn more about how to work with Gradle
for Android there is now an excellent
Udacity class online it's your destiny
class we have created together with
Google and Udacity it's free if you
don't take it as part of the android
nanodegree I think it's now over 10,000
people that have already signed up it's
an old screenshot and Udacity is amazing
who have you guys ever taken Udacity
class yeah I think it's the best online
class experience I ever had and and this
class is really really good so if so
might be interesting for you might be
interesting for some of your colleagues
it's really good perfect starting to
cradle and we offer our own trainings
right if you want to get deeper into
Gradle
right we have introductory intermediate
classes but also very advanced classes
all delivered by Gradle core engineers
are people that deeply understand the
platform ok that's it thank you any
questions
questions yes please know the class our
class are not free
we're not Google so and they are the
difference is their instructor left
right so the Udacity class is yeah so
you can ask question whenever you have
so you get a good teaching experience
but you can also ask the credit
questions you ever wanted to are you
always wanted to ask yes please so
please can you can you say
yep yes it's it's a good point
understand it something you would need
to ask the Android tooling team
it's beyond yeah it's a good point so
but they I would ask it on the Android
dev list or something like that what
what they plan whatever if there are any
plans yes please yeah yes not yet but it
will be coming right so it's very good
point right so so just to understand you
and and to consumers for that would be
new developers you hire into your team
or yeah yeah yes yes yes no it's a good
point so that is yes we understand that
use case and you will you will you will
we will provide something so but it's
nothing don't read the manual you won't
find anything in it right now we invite
other interesting stuff in there but
yeah I mean strictly speaking right
because it's such a rich model I'm just
saying not don't we should do that right
but strictly speaking I think it would
take you or someone it knows a little
bit about cradle one hour to create a
plugin that would print out that
information on the console so so at
least at least you could do something
about it right not that we shouldn't do
it right so don't misunderstand that but
it's a cradle is so open and so rich
that you that we you don't need to
create secret master knowledge to do
that
you could do that pretty in a pretty
straightforward way actually yeah so you
so you could yes so what you could what
you could do that there is a nice thing
with the rich model right you could you
could ask you could ask the cradle
Android build with a Gradle plugin hey
what are you uh what are you are all
those sources are represented by which
object you can say hey main sources a
object please tell me where what is the
path to the Java files what is the path
to the resources files because it's all
in there and you can and then you can
print it out right it's because it's all
richly modeled and then o hey vairy in
container do you have some variants yeah
give me the variant object hey free
variant tell me where are the sources
for the free variant where the resource
is where the integration test so it so
I'm not even exaggerating would be one
hour and it would be on a console right
because it's richly modeled within it's
not just it's no metric properties
that's what we hate we hate something or
it just somehow made up and there's some
magic property hard-coded in the build
script no it's all changeable and
accessible but yeah we should come with
this out-of-the-box pun let's I mean I
my my flight is going no I'm seriously
thinking about it just thinking about my
schedule might not have because I need
to go to the airport maybe let's see
maybe I i heck it up on the on the way
back in the plane and we'll send you
something seriously we will see yeah
cool yes please
yes yes yeah you should be yes so I mean
the big comment ability issues we had in
the past and to be fair was when a great
android plug-in was ODOT something so
they were deliberately right there
whereby the designs at a it's i mean it
was a long period until we got to one or
with the Gradle android plug-in but in
terms of the contract it was okay to
break right so but since one always out
I think it's extremely compatible with
with because we are extremely compatible
words compatible right so so this so
what they were doing before one oh they
were always they were always because we
work closely together I just said o to
make us really good we needed we need a
feature that is only in greater to all
or or in created to one right and so
therefore it didn't work the next
version of the android plug-in didn't
work with an older version of cradle
until they have reached one or where
they now invest more into backwards
compatibility right so but that was the
reason right Gradle itself is extremely
backwards compatible we have a massive
tests with 16,000 tests right and we run
it every night against all different
Java versions and and and against you
know cross version of cradle testing so
that's something that did where people
usually very happy with it is the only
reason why we can release so often if it
would break people in imagine a you know
a team like LinkedIn with two thousand
engineer's if you break them two times a
year to say well thank you very much
right then then it would stop upgrading
right so so that is we can only have
that speed if we have to quality in that
respect yeah okay enjoy the show thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>