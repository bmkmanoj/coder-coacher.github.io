<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Android Studio for Experts (Android Dev Summit 2015) | Coder Coacher - Coaching Coders</title><meta content="Android Studio for Experts (Android Dev Summit 2015) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Android Studio for Experts (Android Dev Summit 2015)</b></h2><h5 class="post__date">2015-11-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Y2GC6P5hPeA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">
TOR NORBYE: Hello.
Welcome, everyone,
to this session,
entitled &quot;Android
Studio for Experts.&quot;
Congratulations on passing
the expert exam at the door.
The format for this is
going to be all demos.
You probably know some
of these tricks and tips,
but hopefully not all of them.
And we're going to take turns.
These are members
from the Studio team.
We're going to take turns
doing our own individual demos.
So I guess I'll
just get started.
Thank you.
So I'm going to show
you some editor tricks.
Can we go to, yes, you're
already showing the ID.
So the first thing I want to
show you is code completion.
Small, little trick when
you do completion like this.
If you just press
Enter to choose,
it's going to basically insert
and break your code like this.
And what you
probably want to know
is that you should
press Tab instead.
That will replace the
symbol under the carat.
[APPLAUSE]

All right.
Some of you already learned
something, that's great.
All right.
The other code completion
trick is, code completion
is really, really smart.
And so generally all you have to
do is just press Control-Space.
But did you know that if you
press Control-Shift-Space,
it gets smarter?
It actually will do chain calls.
And sometimes you have
to press it twice.
So let me show
what happens when I
have a context local variable.
This is a static method that
doesn't extend any Android
classes.
But if I press Control-Shift
once and then twice,
notice how it figured out that
I had a context variable that it
could get a drawable from.
So that's really useful.
OK, selection.
I've seen a lot of
users do this, right?
You get the mouse, you
try to select this part,
and you're maybe off by one.
Or maybe you do it
by the keyboard,
and you're pressing the Shift
key while you're selecting.
There's a better
way of selecting,
and that is AST selection.
So the action for that is
Extend Selection, I think.
Yeah.
So you can see the
shortcut right there.
So you can really
quickly select portions
based on syntactic elements
in the source code, right?
And I can press Up and Down to
select outer and inner things.
So if I quickly
wanted to select,
for example, this
statement up here,
I just tap on it like that.
And then, one or two or three
clicks, I have the expression.
And I can then press a
shortcut to, for example,
extract a variable from it.

Intentions.
Hopefully, you all know what
intention actions are now.
If not, that is going to
be the most useful thing
you learn today.
Intention actions are these
things that are invisible.
So they look at,
where's the carat
and what can I do at
the carat position?
So you can use that
to, for example, well,
let's see what we can
do on a character.
Well, I can convert to
string literal, for example.
I really like that when I
have a constructor like this
and I'm adding more fields,
I can invoke an intention
action here, and I can
bind the constructor
to parameter fields.
So it very quickly will add
variables and initialize it
in the constructor.
And likewise, if I add
a fourth parameter,
I can invoke it again.
And it'll also insert a field,
and bind it, and so forth.
So that's pretty handy.
This is also great
with instanceof check.
So I'm sure that many of
you have done this, right?
You're in here, you made sure
your parameter is a context.
You don't want to have to go
and actually declare a variable.
You can just put the
carat one line back up.
Invoke--
AUDIENCE: Scroll down.
TOR NORBYE: Scroll down?
Oh.
Sorry.
That's interesting.
I'm seeing different
things than you are.
OK.
So you can put the carat
back on the context line.
And there is now an intention
to insert a variable that's
already been cast.
It's pretty handy.
Suppress.
I just want to
make sure everyone
knows that when you have
a warning like this,
there's a quick fix.
But you can also always
press the Arrow Right
to suppress the warning, right?
So it'll actually
highlight the context
that the suppress applies to.
It's pretty good to know.

Live templates.
So you never want to go and
write a for-loop by hand.
You can, but there's
a better way.
And that's using live templates.
So if I just type fori,
and I press the Tab key,
it inserts a for
skeleton like that.
And then you can
just tap through.
And of course, you would
have the target size.
And there's nothing
special about i, right?
So if I do this I can
also call my variable j.
Right?
And the end condition could
be, for example, list.size.
Now, Romain Guy
wanted to show you
that you can also use post-fix
completion for this, right?
So you just type the variable
you want to iterate over.
And then the post-fix expression
will be fori like this.
And that does the same thing.
And it's already
preset, the size.
Yeah.
[APPLAUSE]

All right.
Some more stuff
on live templates.
If you're doing
Android development,
you're probably doing
a lot of logging.
And so there's some
live templates for that.
So I can, for example,
type logi to insert
a logging statement for info.
And you can see now
that it wants a tag,
and so I could of course use the
normal intention for inserting
a tag.
And that's going to create a
constant that I can add, right?
But there actually is
another live template
for creating a tag.
Logt.
And notice how that actually
pre-populates the value
with the current class,
which is pretty handy.
And so there are some
additional logging templates.
So for example, at the
beginning of the method,
If I want to log that this
method is being called,
I just do logm.
Notice how that inserts
not just the method name,
but all the parameters as well.
And at the end, maybe
I want to log that I'm
about to leave the method.
So I just do logreturn.
And that inserts, hey,
I'm about to return
and here's the result value.
This makes it really
easy to add logging.
Yay.
You're allowed to clap.
[APPLAUSE]

FilterSearch.
This is actually not
code, but navigation.
I want to make
sure everyone knows
that we have invisible searching
in almost every list in the ID.
Right?
So if I, for example,
do Command-N,
I get this Generate list.
If I want to go for toString, I
could use the Arrow key, right?
But even though there's
no search box here,
if I start typing toString, you
can see it starts filtering.
It puts a little text
field on top of it.
And this is true
basically everywhere.
So if I'm over here
and I want to do New,
if I'm looking for Vector,
I just type vector, right?
And it's navigating
right to that wizard.
If I'm in the Refactoring
menu, Refactor This,
I can search, for example,
for the Inline Factoring.
I can filter the Project
View, build.gradle.
So basically wherever
you are, and you're
trying to search
for long lists, just
start typing and
see what happens.
StructuralReplace.
So let me show you this
string file I came across
in one of our projects.
So the translators
had translated this,
but they left all these
translation description
elements in.
And when you do it
like this, it actually
gets packaged in VPK, right?
So you don't want to do this.
So how do I get rid of
all these attributes
from the translations?
You could probably
imagine a way to do it
with regular
expressions, but I'm
going to show you a different
way that's pretty handy.
And that is Structural
Search and Replace.
So, Replace Structurally, right?
So what we're going
to do is, we're
going to search in XML files.
And I want to find
a StringElement.
I can type string,
and I want the name,
and I don't care
what the name is.
So I'm just going to
make a little variable.
That will be a placeholder.
I'm going to look for
translation description.
And the description is
going to be whatever
it is, another placeholder.
And then we're going
to have some text.
And if the ID finds this, I
want it to basically remove
that attribute.
So if I've done this
correctly, if I search now
it's going to search my project.
And it's going to find
a bunch of attributes.
Nope.
Ha.
Apparently I didn't do it right.
OK.
What's the problem here?
AUDIENCE: Second dollar
sign on the text.

TOR NORBYE: Oh, you're right.
The audience got it.
And then we have to
fix the value as well.
Let's try again.
We're searching and
we're seeing matches.
So if I open this
here, it actually
offers to preview
the replacement.
So if I do that,
you can see it's
going to do the right thing.
So that removes the attribute.
And now comes my favorite part.
I'm going to open up
the Inspections UI.
And I am going to navigate
to the Structural Search
Inspection.
I can turn this on, and I
can say that I actually want
to add a Replace template here.
And it's going to just show
the last one we just did.
And when I add this
as an inspection,
I can also add a message for it.
So I'm going to say, please
don't include-- sorry
about the missing
apostrophe-- please
don't include
translation descriptions.
And notice what happens when
we go back to our source file.
It's telling us, hey,
this is not right.
And if I invoke QuickFix,
oh, it's got it right there.
And I can basically apply this.
So we can turn a Structural
Search into a QuickFix.
[APPLAUSE]

So if I go back, maybe you have
Thread.sleep in your source
code and you're not super
comfortable with having that.
Someone filed a bug that
lint should flag this.
And, you know, we
should flag that.
But in the meantime,
if you have APIs
that you want to blacklist in
your codebase at your company,
you can do it with
Structural Search.
So again, I will just do a
Search instead of a Replace
now.
Search Structurally.
And we can search
for Thread.sleep.
In fact, I'll just say that
any duration is a problem.
And you can see
when I search, it's
finding this element
syntactically.
And I could turn that
into a warning again.
Or the example that Romain Guy
came up with before this was,
you can use this
action to replace
deprecated APIs with new APIs.
So this method is
deprecated, and you really
should be calling setBackground.
Said drawable again, I think.
You could do another Search
and Replace on this API.

All right, let's talk about
designtime attributes.
So I'm going to switch
to the Topeka app.
So this is the puzzle app
that we showed earlier.
And the picture on
the left is what it
should look like when we run.
You can see that the designtime
is not looking quite as nice.
And this layout is composed
of a couple of elements.
So we have an included layout
for this avatar, so let's jump
to that layout.
Sign In Avatars.
And you can see when I'm
looking at this layout,
I'm only seeing the avatar list.
I'm not seeing the list the way
it appears in the final layout.
So for that, you can use
a designtime attribute.
And one of the new things
we have in our current build
is, code completion actually
for designtime attributes.
So if I do Tools,
you can see we now
have these things showing up.
[SCATTERED APPLAUSE]

Yay.
And so I can now, for example,
say I want to show this in--
and what is the name of
the layouts coming from,
fragment_signin.
If I do that, you
can see we now see
this layout surrounded by the
place that will include it.
And this, of course, is
sort of in translucent gray
a little bit so
that you don't get
confused about
what's in this layout
and what's in the other layout.
Comparing to the image
again, still a little ugly.
We need to have more
columns over here.
And so now the trick for
designtime attributes
is that I could, of course,
just set the number of columns
to something like four, right?
But I don't want to do
that, because this column
count is actually computed
by Java code at runtime.
It looks at the width of
the screen, and the size
of the images, and computes it.
But at designtime I'm not
running that code, right?
So let's just say we can put a
hard-coded value in the tool,
but not at runtime.
And the way we do that
is just to replace
this with a tools namespace.
So now you can see it still is
showing four columns over here,
but at runtime, it would not.
It's going to be continuing
to call the runtime code.
So you can call any of
the standard attributes.
You can just switch to
the tools namespace.
When we build the app, we
strip out these attributes.
So they're only
used at tooltime.
Still looking not great. .
So the other thing we can
do is, we can look at this.
This is a GridView, right?
Let's see how the
GridView is being used.
So I do Find Usages and
we see that it's being
used in the SignInFragment.
And it's associated
with this AvatarAdapter.
And the AvatarAdapter is
using this item_avatar layout.
So let's go look at that layout.

That looks not great.
So this is in AvatarView,
which of course is
being populated dynamically
with the right image, right?
So one thing we can do, we
can just basically update
the Custom View code
to call isInEditMode,
which is going to
be true in the tool,
but not when the app is running.
We can also do this with
designtime attributes.
And the way we
would do that is, we
can say that we want to set
the source attribute to-- oh,
let's see.
Can I remember?
It's @drawable/avatar_1.

OK, so now we have our avatar_1.

OK.
And if we now switch back
to our list, it's not great.
Because this whole
Find Usages thing
I did, I was discovering what
layout will actually be used.
That was all done through code.
The adapter decides what to use.
But again, we can use
tools attributes-- invoke
code completion here-- to say
what listitem layout to use
at design time.
So here we can say that we
want to use item_avatar.
And now you can
see, we actually are
starting to see a layout that
looks pretty close to what's
happening at runtime.
I realize now that I've actually
done something really bad here.
I hard-coded the icon to this.
And I don't want to do
that, I want to switch it
to the tools namespace.
So if I do that, you can see
we have an intention now.
So if you just write tools
anywhere, you came up QuickFix,
and we have it for you.
You don't have to
go and copy-paste it
from some other file.

All right.
So that was
designtime attributes.
Actually, let me find
back where I was.
OK.

All right.
Let's talk about
privateResources.
So in my content_main layout
out here, I am using a library.
And you can see that
my code completion
is getting filled
up with resources
from this third-party
library, ccl.
Whatever that is.
And that was not intentional.
Those strings are
used in the library,
but they're not meant
for others to use them.
So I can actually go into
the library source code.
Where are you?
OK, Library.
Strings.
Here you can see one of my
string files in the library.
And I can say that
I basically want
to set which resources are
exported from this library,
and everything else will
be treated as private.
By the way, one thing I
want to show you first
is, you can see it's
highlighting here that this
is an unexpected resource name.
That's because we have this
feature for a library where
you can, in the
build.gradle, say
that you want your resources
to all have a certain prefix.
And if you declare a resource
that doesn't have that prefix,
we will warn you about that.
So you can sort of be
consistent in how you're
declaring your resources.
Right.
So now we're going to go and
say that the only resource we
exposed from this
app is this one.
So to do that, we can
create an XML file.
It doesn't matter
what you call it.
I think the best name for it
probably would be public.xml.
Sadly, we don't let
you create one of those
because it's a keyword.
But that's a bug, because
it's OK for values.
So I'm just going to cheat
and use New File instead.
And I'm going to
put it here and I'm
going to call it public.xml.
Resources.
And the keyword public
is what you use.
This is another resource type.
You can also write item
and then type=&quot;public,&quot;
but public like this.
And I already forgot the name of
the resource we want to expose.
Well, let's do the first one.
And then you have
to declare the type.
And it's a type=&quot;string.&quot;
So now we've declared this.
And I actually have
to compile my app,
because the public
declaration is
written into this
part of the AAR file
that the clients will read.
So we are building.
And if I go back now
to my app module, which
is digesting the library, what
should happen-- hopefully--
is that when I invoke
code completion, yes.
You can see, it's filtered
out all the CCL stuff.
So we only get the one
thing we basically exposed.
And in fact, if I were to try
to use some other resource,
or if I had been bad
in the past and used
one of these things that
weren't intended to be used,
if I use it, you
can see we actually
warn you that you are using
a resource that you're not
supposed to use.
So if you have a
library, you definitely
want to look at all the
things you're using.
Your drawables, your styles.
And make sure that
you really are only
exposing for clients the
things that they want to see
in their code completion list.
All right.
The last thing I will show
you is resource shrinking.
So resource shrinking
is basically
a way to let you strip out
all the assets from libraries
that you don't actually need.
So if you depend
on a large library,
let's say, you
know, all the Play
Services, which might include
graphics for the Login button.
And you're not actually
calling those methods,
you can get rid of those.
You can't go to the
source code and delete it
but we can look at the code
you're actually calling,
then we can strip out the
stuff that's not relevant.
So the way that works is
that, in my build.gradle
I say, shrinkResources true.
By the way, this only
works for when you actually
are shrinking, right?
We could make it
work without it,
but it's not really much
of a point in that case.
So this is when
you are at the end,
you're having ProGuard
go in and figure out
exactly the call
graph you're using,
and deleting everything else.
And that's what frees up
these resources, right?
If you're using
the Login library,
Play Services is referencing
those icons, right?
For the sign in function.
If you're not
calling that function
and we strip out that code,
well, then the resources
become eligible for
deletion as well.
So you can do
shrinkResources true.
And when you've done
that, our code will
be very careful to try not
to delete your code, right?
So for example, if we see
that you have code like this,
img_%d.
So you're formatting something,
and then you're passing it
to this resource manager,
that .get identifier.
We don't dare to delete
any resource that
starts with the prefix img.
Right?
Because this is basically
an escape clause to get
access to any resource by name.
So that's what we do
by default, to try
to not make the app crash.
But there actually is a way
with designtime attributes
to tell us that you don't
want us to be that careful.
So the way you do that is,
you go into some value file.
I'm going to use
strings.xml, because why not?
And here I can say tools:.
I'll add the tools namespace.

All right.
OK, we haven't actually added
strictMode to the completion,
that's too bad.
So &quot;safe&quot; is what you
usually get out of the box.
If you switch this
to &quot;strict,&quot; then we
will not consider
reflection as a possibility.
If you do this, then
you are in charge,
just like with
ProGuard, of providing
the keep rules, right?
So tools:&quot;keep&quot; is how you
specify a comma-separated list
of resources that you know
might be called from code.
And you can also
do tools:&quot;discard&quot;
if you want to, basically,
something that you want
to discard even though somehow
we didn't figure out that it
was eligible for deletion.
And I think, with that, I
am going to turn it over
to the next speaker.
Siva is going to show you
how to use the Debugger.
[APPLAUSE]

SIVA VELUSAMY: Thank you, Tor.
Welcome, everyone.
I'm going to spend the next
five minutes giving you guys
a few tricks about how
to use the Debugger.
So let me start with a very
common operation that I do,
which is I receive a stacktrace.
A long time I used to
look at the stacktrace,
find the last file, and
then go back to the ID
to locate the class.
A trick that I
learned recently is,
you just have to search
for Analyze Stacktrace.
So I press
Command-Shift-A, which
is find an action by name.
That's a very useful shortcut.
You do that, and you just start
typing for whatever action
you're looking for.
I type AnalyzeStacktrace.

Let me just select all of
this, and then I do that.
It automatically fills
this dialog with whatever
you have on the clipboard.
And you just press OK, and
that will automatically
populate a console with a
clickable list of the files.
Now, what is
actually even cooler
about this
AnalyzeStacktrace dialog is,
there are actually
two options here.
At the top there's an option
to Unscramble your Stacktrace.
So in case you are
using ProGuard,
and you have a
scrambled stacktrace,
then you'd use the ProGuard
Unscramble plug-in.
And that would be able to
normalize the stack trace.
And at the very end, you have an
option to show the VCS history.
So in case you have .get, or any
other version control system,
plugged into your
project and you do this,
it will actually mark the files
that have changed in the last n
number of days.
And you can actually
also conveniently
look at who committed it,
and not to pick on Ben here.
So that is AnalyzeStacktrace.
I hope you find it useful.
And now let's switch
to the Debugger.
I already have the Debugger
connected to a running app
and I am waiting
on a breakpoint.
I'll show you a bunch
of things that you can
explore in the Variables view.
So the Variables view, which
is down here at the bottom,
you see all the local
variables and fields.

By default, you would know
about the renderings for all
the objects which just
use their toString method,
and just displays that object
using its object.toString.
And for primitive types you
just render it as a primitive.
We have a few other additions,
which is, for instance, in case
you have a bitmap, you can click
on this to view the bitmap.
That works for bitmaps
and bitmap drawables.
And then let's say I'm
in a different place,
and now I'm looking at different
things such as primitives.
Now Android, we use primitives
to express a lot of types.
So we use integers as enums,
as colors, as our references
to resources, as resource IDs.
And are many times
when you have an ID
and you don't know
exactly what it means,
you could just see View As
and select the type integer.
And so an Android
type integer would
be able to resolve
it to its reference.
In this particular
case it happens
to be a reference to a drawable.
Now how does this work?
This works because
of annotations
that you might have.
You already have annotations
in the platform source code,
but you could also have
annotations in your own source
codes.
In this particular
case, this variable
was actually annotated
as a drawable resource.
And so the annotation could
be on the local variable,
it could be on a field, it
could even be on the getter.
We would do sufficient flow
analysis to figure out,
what is the
corresponding annotation?
And then render an integer
in an appropriate manner.
This works not just for
reference to resource,
but in this particular
case, let's say
I have a variable that's
called a color, but again,
a Typed Integer,
and it references
to a themed background.
Same with just regular colors.
You would see it renders
it properly as a color.
So that is viewing
primitive types.
So, so far we've looked
at just the bitmap,
and then we've looked at how
to render certain primitives.
The other option is, you might
want to do your own custom
rendering.
So for instance, instead
of the toString method,
you might want to
render your object
in a slightly different way.
In this particular class,
this is the onBindViewHolder,
part of the RecyclerView API.
And the model object
for this list,
it holds a list of categories.
And if you look at the list
of categories by default,
this is what is shown there.
It basically shows the
toString of each category,
and many times it may not be
exactly what you want to show.
So an easy thing to do is just
right-click on it and then
Customize Data View for it.
And you would go to
Java Type Renderers
and you would add a new one.
Let's call it category.

And the object that you want
to customize is a Category.

So that's over here.
And then, instead of using
the default renderer,
you want to do something like,
I just want to show the name.
Or I want to show the name
plus-- this is a quiz app,
so it has a bunch of
questions-- so you
say you say that, I
want to see the name
and the number of questions.
Which would be
getQuizzes().size().

So I do this, and now you'll
see that each category gets--
as soon as we get this running.

Maybe I made a
mistake over there.

Ah, well.
It looks like a demo
issue right now.
But in theory, if
it's a category
it'll show you whatever
custom rendering you've
done over there.
Sorry about that.
I'm not actually sure
what happened over there.
All right.
Let's move on to
the next one, which
is, how do you
evaluate expressions
when you're over here?
So one common thing we
see is that any time when
you want to explore what is
happening inside a program,
and you're waiting
on a breakpoint,
you can actually
select a bunch of text.
Let's say in this
particular case I have this.
And evaluate and invoke the
Evaluate Expression option.
And over here you can actually
invoke whatever you want.
So in this particular case,
I have a variable category.
I can do all the operations.
I can basically query
methods on that object.
And it's not isolated
to just that object,
you can query for
whatever is in this code.
So this is extremely
useful when you
have a bunch of Boolean
expressions combined together
and you want to see which one
is actually false or true.
You can actually explore
entire APIs this way.
So if you have a
bunch of JSON values
and you want to see
how it's structured,
you would just
open it up in this.
And then just gradually
query different methods
to see exactly what you want.
That is Evaluate Expressions.
So, so far we've looked at what
you can do when you're actually
waiting on a breakpoint.
The other thing I want
to show is actually
setting these breakpoints in
a very conditional manner.
So in this particular
case, let's say, again,
I'm on a RecyclerView.
It has a whole
bunch of elements.
I press Continue, it'll again
come back and read over here.

So instead of having to do
Continue again and again,
you might want to
make this conditional.
So in this particular case,
you can make it conditional
on category.get
Name().equals something.
So that way you only stop
at a particular breakpoint
if you know the exact condition
when you actually have to stop.
But in case you don't
know the exact condition
when you want to stop,
your normal recourse
would be, maybe you add a log
statement there, you rebuild,
re-upload.
Instead of doing
that, you can actually
modify the breakpoint itself
to log a particular expression
whenever it hits the breakpoint.
To do that, you would go
into the More Options here,
and then you would
deselect the Suspend.
So that when it
hits a breakpoint,
you don't actually
want to suspend.
But instead you want to
log a particular expression
that you evaluate.
So let's say I just want to
see what the category name is
whenever it comes over here.
And I press Continue.
Let me move this breakpoint.

Over here you started
seeing the category names
being-- so you can see as I go
through it-- whenever it hits
the breakpoint, it'll basically
log exactly the expression
that you have
provided over there.
That is actually all I had.
I hope you found it useful.
Thank you.
[APPLAUSE]

ALEX RUIZ: Thank you, Siva.
My name is Alex.
I'm going to talk about
Gradle integration.
One of the common questions
that we get from the other
developers using Eclipse is,
I have this compile .aar,
aar This library that I'm
using my Eclipse projects.
But I also want to use it for
my new app in Android Studio.
What do we do?
So we can either copy the
file, there is a lot of things
that we can do.
Create a local Maven repository
and install that .aar there.
But Android Studio actually
provides a very nice shortcut.
And you can actually import
the compile .aar as a regular
module.
And I'm going to show you how.
So we create first a New Module.

Then we select
Import .AAR Package.
After you click Import, this
wizard is going to ask you
for the path in the file system
of the .aar that you want
to import.
To save some time,
I already did this,
and I'm going to show
you how it looks like.

So here, there it is.
That's the module that was
created by Android Studio.
It creates the module,
the buld.gradle file,
and also the .aar
that is wrapping.
After that, I added a
dependency in my app,
just like I would depend
on any other module here,
and I'm ready to use this code.
For this example, I
imported a tip calculator.
So now in My Activity, I can
just start using the code.

Very simple.

The second tip for the Gradle
integration in Android Studio
is, how do I run any Gradle
task without leaving my ID?
So this is something
very handy that we
inherit from IntelliJ IDEA,
which is the Gradle Task View.
So here you are going to see
all the Gradle tasks that
are available for your project.
They are categorized
by the top level
module, which is the project.
And here for example, I'm
going to select Dependencies.
So if you're familiar
with Dependencies tasks,
it's going to show
you a very nice tree
view of all the
dependencies of your module.
So I'm going to just
double click this.
It's going to execute.

Executing.

Well, sadly it didn't like
the way it was executed.
Because to execute
dependencies you
have to prepend the Gradle path
of the module you're using.
But we can fix that very easily.
The cool thing about this is
that the IDE Android Studio
will create the ROM
configuration for that task
that you just executed.
So we go here, we added
the configuration.
It's this one.
We fix it.
Oops.
There.
We apply the changes, click OK,
Run again, and there you go.
The problem is that the
text is a little small,
so you cannot see it.
But it's there.
And it looks very cool.
So besides creating
the ROM configuration,
it'll allow you to edit it.
You can save it.
So you can preserve
that ROM configuration
between ID sessions,
which is pretty handy.
And the last thing I'd like to
talk about is build variants.
So by now, I am assuming
that everybody here
is familiar with
build variants, right?
Please raise your hand.
Yeah?
Yeah.
For the folks who
didn't raise your hand,
I recommend you to please
watch the Gradle talk
when it's available online.
So build variants are different
flavors of your application
inside your codebase.
And we usually get asked,
where do I see these things?
And they're kind of
hidden in the ID.
So they are here.
So actually, let me
minimize this and this.
So, here.
So this is the Build
Variants window,
it's on the bottom left.
And here you have the list
of modules in your project.
These are only Android
modules, because they are
the ones with build variants.
And here, each
row for the module
has a drop-down where you
can select the variant you
want to work on.
You can work only with
one variant at a time.
Something that's a little
sad is that each build
variant has two test artifacts.
And because some
limitations in the ID
before, you can only work with
one test artifact at a time.
So you can either work with
Android tests or unit tests,
but not both.
So if you want to run
tests continuously,
you have to keep
switching between them,
which is not very convenient.
And another thing is that by
having only one test artifact
enabled at the same time,
one table at a time,
refactoring doesn't work.
And I'll show you
what do I mean.
So let's say that I have
Android tests enabled.
And I have this method here.
I rename it.

There.
So my Android test participated
in the automatic refactoring
and was updated properly.
But the problem is that
the unit test wasn't,
because it's not enabled.
So when they switch to
unit tests, it's broken.
And then you have to
manually fix that.
That's not really awesome.
So let's undo that.

Yeah.

Let's remove this.

OK.
So, how can we
make things better?
So, starting with
Android Studio 2.0,
you can have both test artifacts
enabled at the same time.
It is an experimental feature,
it's not on by default.
But it will be super great if
you can try it out and give us
some feedback.
How to enable this?
You go to the Preferences
and there is a tab.
So you go to Build, Execution,
Deployment&amp;gt; Build Tools&amp;gt;
Gradle&amp;gt; Experimental.
And there is this option,
Enable All Test Artifacts.
You enable that, click OK.
That drop-down is gone.

The unit test is active.

Also, I wanted to show
you something else.
If you see the Android
test, the folder
has a little Android head there.
So at least you can
somehow distinguish
which one is the unit
test and the Android test.
And now if I refactor this
again like I did before,
now, let's see.
Android test.
Beautiful.
It was updated.
And also the unit
test was updated.
Yeah.
[APPLAUSE]

And that's it for me.
Here is Michal, who is going
to talk more about testing
in Android Studio.
MICHAL BENDOWSKI: Hello.
Hi.
Can we switch to the
other computer, please?
OK.
Perfect.
Let me show you a
couple of useful tricks
that'll come in handy
when writing test code.
The first thing I'd like to show
is the Create Test Intention,
which is available when
my cursor is on the class
definition.
So here I'm going to press
Alt-Enter and just Create Test.
In the dialog I'm getting, I can
choose the name of my new test.
DemoActivityTest sounds fine.
So let's move forward.
And with our new
support for having
both test sources
active, now I should
choose which one I want to use.
So let's use Android
test for now.
And now I got my new
test class, which
was created in the right
place in my project structure.
You can see all the intermediate
directories got created,
so that's quite convenient.
Let's fill it in
with some content.
Now, there was a
session dedicated
to testing earlier today,
so if you haven't seen it,
I recommend you watch the video.
Because for the
purposes of this demo,
I'm just going to do
something very, very simple.
Let's just add an
ActivityTestRule
for my demo activity.
And it can even suggest me
a good name for my field.
And now I want new.
ActivityTestRule.
DemoActivity.
Perfect.
Next thing I'd like to show
is the Generate command
that Tor already mentioned.
It's Command-N on the Mac.
And in the test
context, I can use
it to generate a test method.
So in this case, let's
call it testBasics.
And let me just do
something very simple here.
I'll use
ActivityTestRule.getactivity.
And I can play with
postfix completion.
For example, the .var
to actually assign it
to a variable.
I'll leave it at
that for now, but let
me show you something else.
On any kind of
field declaration,
including rules for
testing, I can again
use intentions to Move
Initializer to setUp method,
which is quite convenient if
you find yourself in a position
where your test setup is
becoming more complicated.
So when I press Enter, Studio
will generate a new setUp
method for me,
annotated with @Before,
and move the
initialization here.
I can also use
intentions to get rid
of the unnecessary
generic parameter.
OK, next thing I'd like
to show you is Goto Test.
So on a Mac that's
Shift-Command-T. So when I
press it, I can jump between
my main code and my test code.
So from the DemoActivity
you can go to the test.
From the test I can
go back to Activity.
[INAUDIBLE] is that
the popup for Goto test
allows me to create
a new test as well.
So let's do that now,
because for a change
I would like to create a unit
test that will execute locally
on my machine.
And there's one method I'm
particularly interested
in, the
generateSecretKey() method.
Let's press OK.
This time let's make sure it
ends up in the test SourceIT
Again, we end up with a test
created in the right directory,
with the test
pregenerated for me.
Let me put something
very simple here.
Assert.assertTrue.

Let's just make sure our
keys are positive integers.
So Studio 2.0 is based
on Intelligence 15, which
means that on the
left margin here
we have icons that I can
use for running tests.
So when I click it, I can
choose to run my test.
And let's see it run.
Perfect.
All agree.
Exactly how I like it.
OK, so last but not
least, if I decide
to go back to my
activity and now decide
that, with all the
other test coverage,
it's actually ready
for production,
I can rename my
DemoActivity MainActivity.
And Studio will notice that
I have tests that corresponds
to my demo activity,
and they should probably
be renamed as well.
So my DemoActivity test
becomes MainActivity test,
and DemoActivity unit test
becomes MainActivityUnitTest.
So that's a very good idea.
Let's do that.
I'll click Select All, and OK.
OK, now that we're done
with this, close it.
I can then go to Test, I can
see my tests have been renamed,
and both of them use the
new activity name exactly
as I would expect.
OK, thank you.

And now Kathryn will tell you
all about our C++ support.
KATHRYN SHIH: All right.
Let's see.
So I'm going to just cover
a smattering of C++ topics.
We already saw some of the
things like intentions.
They're totally
supported for C++.
If you're curious, you can
find them in the settings
and check out previous videos.
This is more topics that
have been previously covered.
So things that are new in Studio
for C++ and that you might not
know about.
One of the things is
that we have recently
added Doxygen support.
So when you've been
using C++ historically,
you may have noticed
that, for example,
if you hit F1 to
bring up the docs,
you can see details on
where macros to find,
what the expansion is.
Similar to that, we
now have this syntax.
It's kind of akin to Java docs.
You can add it for a function.
And then when you go actually
look at the definition,
this one is very
dull, but you can
imagine putting in as much
detail as you may find useful.
So may be helpful
documenting large projects.
Other new support, let's see
if we've got this running yet.
So this is a hybrid activity.
And I've added a breakpoint
here in the Java code right
before we go into
this native call.
Get String From Native.
Once I've done that--
oh, this microphone.
I've gone and edited my debug
configuration to make sure that
the debugger type is hybrid,
because I'm curious about both
my Java and my C++ execution.
And I've actually launched
a debugger, hopefully.
Or I am launching a debugger.
For those of you who don't
have the superpower of reading,
like, size two font, it looks
like we're about to run.

This is totally the
curse of the live demo
Super suspicious.

All right, well,
at least in theory,
we now have the ability to step
from Java code into C++ code.
We will give this another
30 seconds before we declare
it to be primarily theoretical
[LAUGHTER]

Oh, come on.
Well, while that
thinks about itself,
so this was supposed to be
the stable functionality.
And then we have some
experimental functionality
that should also be helpful
for folks doing hybrid apps.
So we'll come back to that.
Sorry, something totally messed
with my emulator configuration
right before this started.
So historically, you're
running a hybrid app.
And this is an example.
I've got an app which
has a bunch of Java code,
and I've got a library
with a bunch of C++ code.
I want to express a reasonable
dependency that doesn't involve
hard-coding linker flags.
So we've added an experimental
first class syntax
for doing this.
In this case, I want to say
I have a jniLib dependency
on project Lib.
By default it's going
to pull in the same
build type and flavor that
my actual build is using.
You can override
this if you like.
And this thing is not taking
well to the huge font,
but by default you're going
to get dynamic linking.
If you want static
linking, specify it.
You can also define
dependencies on pre-build SOs.
So library file.
Maybe define that as
a jniLib dependency.
You're basically saying
to package it only.
If you define as jni
dependency, then it's
a buildtime dependency.
And this is experimental,
not because we
think it may sometimes
fail to work,
but just because
we know we're going
to be changing the DSL at
some point in the future.
So if you think this is useful,
go ahead and use it and try it.
Just be warned that
in the next n months,
you're likely going to have to
go tweak your Gradle syntax.
The other feature we have that
is more genuinely experimental
is, for C++-- Oop.
I forgot to put it in here.
We've actually added
the specification for,
I can now say cppFlags, if I can
type, for split-dwarf builds.
Oh, here's my Debugger.
[APPLAUSE]

So, I guess, finishing
one thought at a time.
Split-dwarf bills, if
you're not familiar with it.
When you start running
a debug build in C++,
the compiler is going to shove
all of the debug information
into your objects.
And this may result in
substantially larger files
that then take your linker a
much longer time to process.
If you use the
split-dwarf flag, you're
going to keep the
debug information out
of the objects of
the linker processes.
And it may result in like a 10%
or more increase in linktime,
particularly when you are
seeing slow link times because
of big files with tons
of debug information.
That one is more
genuinely experimental.
It's a new compiler flag, out
in the wild for the first time.
So give it a shot.
And if it, frankly, fails
to compile, please tell us,
we'll fix it.
So going back then
to our debugger.
I placed the breakpoint
here in the Java code.
You can see I've got
my Java debugger open.
I can start examining all
of the objects in here.
But then what happens when
I start stepping forward?

So I am stepping
into the C++ code.
[APPLAUSE]

And it should momentarily hand
this off to the C++ debugger
and let me see all
that memory state.
Assuming the curse of the
live demo does not continue.

App-native.
Native.
Oh, come on.
Yes, here we go.
So we've totally got
native code here.
I can keep on stepping forward.
I can go just to my
next break point.
And the other thing
you may notice
is that we've added
significantly better display
if you're using the STL.
So can actually start
inspecting my templates,
seeing what's in here.
And then if I'm running on X86
or a Nexus 9 emulator like I
conveniently picked, I can
start adding things to watches
and continue working
with the C++ code.

So as I step through,
everything updates.
So again, play with
the C++ debugger.
Let us know how it's
working, and we're
going to be continuing
to update this.
So if you have things
you really want to see,
the squeaky wheel typically
gets the grease here.
So, Gradle support,
Debugger, editing.
The next thing is going to be
a total change in projects.
You may have noticed during
the keynote yesterday,
we announced a snazzy
new-- and this is maybe
beyond experimental,
this is maybe
super-ultra preview alpha-- But
we announced a GPU profiler.

So come back to Studio.
So here is a project
with a bunch of GL code.
And there's two steps to
getting the GPU Profiler
working, which I've
sneakily done ahead of time.
You have to add a trace
library to your project.
It's distributed
with the profiler,
so you just copy it in place.
And then you have to add
a couple calls in order
to actually load it.
Once you've loaded
it, you'll see
that there is a new button
available over here.
Oh, come on.
Where's my monitor?
Well, if I could
expand the monitor tab,
there's a little red
button for running a trace.
When you launch an application
with the profiling library
included in it, the
application is actually
going to block on startup.
Because it needs to start
sending all of the GPU data
back to Studio so that
we can collect the trace.
So the first time you
run your application,
you're going to see this
exciting black screen
while it waits for you to hit
the Trace button on the GPU
tab.
Don't freak out, just
go hit the Trace button.
And be sure to remove it before
you send this thing to prod.
Once you've run the trace, you
should get something like this.
So I can see all of the
frames that were captured
while I interacted with my app.
For any given frame, you
can see Depth Buffer.
You can start seeing
Wireframe View.

And then I can actually
expand the draw calls
that went into it.
So let's look at
one of these guys.
So here's all the open GL calls.
In places where I was
dealing with memory,
I can click on this.
Oh, and normally the text
isn't clipped like this.
We blew up the size to make
it look good on the monitor
and now everything
is slightly confused.
When I'm inspecting the
memory, I can actually
see what matrix I was using.
Again, this works better
when my text size is not
gargantuan relative to
my screen dimensions.
And I can explore the GPU
state that was around for this.
So down here I've, got
let's say, my shaders.

I can see all of the information
that was actually being
used to generate the scene.
And then as I click through
the different draw calls,
you can also see the different
elements being drawn.
So it's going to look
better if I don't have it
on the wireframe mode.
But, for example, if I stepped
through the draw calls on this,
I'd see the foreground
coming in, then
the background, et cetera.
Again, this is highly
preview functionality,
but if you think it looks
interesting, give it a shot.
Let us know what works
and what doesn't.
There's a couple
gotchas around what
we know are currently
unsupported features for this.
You can see them
on the help docs
and we'll be hopefully
relaxing them over time.
So with that, here's Esteban
for non-GPU profiling.
[APPLAUSE]
ESTEBAN DE LA CANAL:
Hello, everyone.

So I'm going to be talking
in the next 15 minutes
about our performance
tools in Android Studio.
I'm still booting my emulator,
so bear with me one second.
In the last few days, I
put together a quick app
that I want to show you guys.
It's basically an app
that has quite a few bugs
hidden in there, and
I wanted us together
to use the monitors
in Android Studio
to see if we can detect
something there, and find
those bugs and fix them.
So let me run the app.
The app is now installing
in the emulator.
So for those of you not
familiar with the monitors,
they are in the UnderMonitor
tab on the bottom of the screen.
I will hide it for a
second while I run you
through my amazing app.
[CHUCKLES] This is
a slide show app,
so I'm getting some
images from the web.
I'm now loading them.
And you have an Next button in
there to go to the next image.
You can go back.
A simple app.
And I'm showing
the time at the top
just because I want to
know what time it is.
And I also have a menu with
a few options to have there.
The first option
is a Clear cache.
So I have a small
cache of five images
at the same time in memory,
so I don't download them
when you go back and forth.
So you can go and
clear the cache.
And I also have two filters.
I have a sepia filter,
which is quite popular.
And there you go, you
have the sepia image.
And I also have another filter.
That is a sharpening filter.
For those of you that are
not familiar with filters,
sepia filter is very
simple, because you only
modify each pixel at a time.
Whereas a sharpening
filter needs
to look at the
[INAUDIBLE] matrix,
it needs to look at
its run in pixels.
So it takes more time.
The reason I have that
filter is because we're
going to be looking
at some CPU activity,
and see whether
this filter actually
shows up in the CPU Monitor
as something being expensive.
And there you go, the
image is now sharpened.
So that's my app.
Now let's look at
the same thing,
but now hooking it up to the
monitors in Android Studio.
I'm going to uninstall
the app right now.
If you watched the
keynote yesterday,
you saw that we had a
tiny bug with Instant Run.
So I don't want to run
into that bug right now,
so I just uninstall the app
and I'm going to run it again.

You know, we just did
five live demos in a row.
Mine is the sixth one;
what can go wrong?
Right?

Cool.
I'm going to write again
here, and then we'll
see the app connected to the
monitors Just for curiosity,
how many of you have tried
the CPU Memory Monitor?
Can you raise your hand?
Oh, cool.
All right.
All right, here's my app.
Android Monitors.
I'm going to expand this.
Can you in the back seats
see the CPU Monitor?
The one at the bottom?
Yeah?
Yep.
If you don't say no, then
that means you're seeing it.
Cool.
Now, this is my app again.
And let's see if we can
spot some bugs, right?
So I'm going to go
to the next image.
The first monitor at the
top is an Android Monitor .
We recently added this monitor.
And as you can see, when
I'm requesting a new image,
you can see New Request.
Above the zero line, you're
seeing the bytes are coming in,
and below is the bytes
that are going out.
So the request is
basically tiny,
but you can see that
image being downloaded.
The area of the thing
you're looking at there
is telling you how many bytes
you're actually downloading.
So on the x-axis you have time,
on the y-axis you have speed,
and the area is the
amount of bytes.
So you can see the
bigger the area,
the bigger the request was.
And clearly, I have a
cache, so when I go back,
there shouldn't be any
requests happening there.
That's a bug.
Right?
That's how you spot a bug.
So my cache is not working.
I'm going to go
to my ImageLoader.

There's no space to see
the monitors and the code
at the same time.
Looking at my
ImageLoader, I decided
to add the image to the cache,
on the catch part of my code.
That was the wrong place.
I just moved it up.
And I'm going to
use Instant Run.
And Yee-hay.
Instant Run is working.
So I just use
Instant Run, and I'm
going to reopen the monitors
and see what happens.
So I'm going to go
to the next image.
This should request the image,
because we haven't seen it.
Cool.
One more time.
This image is a new image,
and now I'm going back.
No network request.
The bug was fixed.
[APPLAUSE]
Cool.
So now that we have the cache
working fantastically well,
we're going to move
on to the next thing.
You know, we thought,
sepia filter is fast.
We saw the image of [INAUDIBLE]
Sharpen uses a lot of CPU.
So I'm going run
my sepia filter,
and clearly we'll see one
spike on the CPU monitor,
and that's it, right?
My CPU Monitor is
now back to-- No.
It's doing stuff.
What did I do?
So we go back to where
I'm calling that.
By the way, if I
open the monitor,
OK, it did do something.
So I'm going to look where
I'm calling this function.
And you can see I
have, you guys know
the onOptionsItemSelected
callback that you get.
And I have my sepia filter
here, and my sharpener-- OK, I
forgot a break.
So whenever I was
doing a sepia filter,
I was also doing a
sharpener filter.
We don't want that.
So I'm going to put a break
here, run this new magic thing
that we have, and
open up the monitor.

Let's put in our
image and run sepia.
CPU spike, done.
That's what you would expect
when you fix this bug.
Cool.
Now let's move on
to another bug.

I'm going to run again
the sharpening filter.
This, as expected,
will use a lot of CPU.

And now it's done.
But I'm going to switch to a
different monitor, the Memory
Monitor.
I was not expecting
at all this filter
to have any memory activity.
Right?
So you see the seesaw pattern
there at the same time
that the CPU spiked.
So why this happening?
When you see a
pattern of this form,
generally it means that you're
doing a lot of allocations
in a short period
of time, and you're
getting your garbage collection
kicking in, and bringing them
back, right?
So I'm going to
do the same thing,
but this time I'm
going to run it
through the allocation tracker.
The allocation
tracker, what it does
is, you start in
a moment in time,
it captures all the
allocations that are happening,
and then you can go and dig
into these allocations, right?
So let's do it.

I'm running sharpen,
and I'm going
to start allocation tracking.
You can see in the Memory
monitor, what is the time frame
that I'm doing this tracking.
I'm going to stop it here.
And then we minimize the monitor
so we can see, here we go.
So now the file is
being transferred over
to Android Studio.
And then we see Thread 1,
36 allocations, Thread 3,
10 allocations.
Thread 13 decided to
do 65,000 allocations.
Something is wrong.
How do we go there?
OK, I'm going to start
opening this guy.
You can see the
asynchronous task t
that I used to do the filter.
You can keep digging, it
goes into the filter image.
Sorry, we have super huge
fonts so you guys can see,
but I keep digging,
digging, 65,000 allocations.
I get to the sharpen code.
I open it up.
Gazillion long allocations.
Why is this happening?

I'm going to go to source.
There's an action there
to Jump to Source.
Looking at my code.
In standard filter code, you
have two nested for-loops
and go through all the pixels.
OK.
I have a new location
of an array inside this.
So these images are
1,000 by 1,000, roughly.
I'm doing quite a
lot of allocations.
I'm going to move
this out of the loops.
It doesn't need to be at
that location in the loop.
I'm going to press the
magic button again.
And let's open the monitors.
Cool.
Now let's try again,
another image.
Oh, that image after two
sharpen filters looks beautiful.
OK.
Sharpen.
CPU activity, as you can expect,
the memory, safe and sound.
That's how you spot and how
you track down allocation bugs.
There is another thing I want to
show you on the Location view.

Here we go.

So this ImageUtils
class, the one
that was doing the
[INAUDIBLE] allocations,
I have it in a package called
Third Party Images Package,
right?
Imagine you're using a
library that you didn't write,
but you're calling it from
similar places of your code.
And that library seems to be
doing a lot of allocations.
If you use this view in
the Location Tracker,
you're going to find that
all these allocations are
being blamed on those packages.
You're going to drill
down and say, oh, it's
again this library, it's
again this library, right?
When you do an allocation where
you see the call stack, right?
So you see all the
call stack, and then
the final function
in the call stack
is going to be the
one that you blame,
to say, OK, that's the one
that did the allocation.
However, maybe one
of your classes
is responsible before
that code happened, right?
So you don't want to go directly
to the class that's called New,
but you want to go back and
say, OK, which one of my classes
is actually the
one calling this?
So for that, there
is a different view
that you can use, which we
call Group by Allocator.
When you do this, instead
of using the call stack
as the guide to group
the allocations,
we use the package names.
So here, like I
was saying before,
you can see that
com.thirdparty.images
was a package that was
doing all the allocations.
Not helpful at all.
We have a box here where
you can specify the package
that you want to highlight.
So this allocation that
go through many things,
but you want the last thing
to be one of your package.
I can put com.example, which
was my applications package.
And now you can see that
whenever we see an allocation,
we will not blame it
on the very deep call,
but we will blame
it on my last call.
So now you can go and
see that com.example.devs
ummit.MainActivity
is the class to blame
for all these allocations.
But with this, you can
better track the culprits
of several allocations.
Cool.
So, going back to the app.

The last thing that I
want to show you guys
is, my app is here.
I'm going to restart
the activity.
I could rotate the emulator
and it will go offscreen.
So we have a new shortcut
to restart the activity.
Everyone knows that when
an activity restarts,
we need to be very careful
about a few things, right?
We need to be careful about the
onCreate method being called
again, so if we create some
things that we don't dispose,
there would be a leak, right?
And leaking activities is
one of the most common things
that happen when this is
not handled correctly.
So while we keep
looking at this,
I'm going to restart
activity a few times.
It is always expected to see
some memory activity here,
right?
Because the old activity is
gone, something's going to go,
and the garbage collector
kicks in slightly later.
So I'm restarting the
activity quite a few times.
The purpose of this
demo is to show you
guys, when you see a pattern on
the monitors that is incorrect,
something that
should not happen.
A typical pattern of something
that should not happen
is that pattern, right?
I am leaking something.
Just as a last resort,
I'm going to go and run
a garbage collection and
hope everything goes away.
No, it doesn't.
So there is a bug.
How do we find this?
Well, the thing you do is,
you do a heap dump and dig
through your stuff,
and, you know, what are
the things that we are leaking?
To save time I already have a
heap dump here, that I took off
a very similar scenario.
The fonts are huge,
so in your computer
you will not see it like this.
But, you know, we
blew up the font
so you can read from there.
I could now go and dig in and
find, where are my activities,
how many do I have?
We added this very
handy thing that
is called Analyzer Tasks,
that we can automatically
run some tasks for you.
And we detect common
patterns of things.
We have this long list of two
things that we will take now,
but obviously, with time
we'll be adding more.
The most important we have
now is the Leaked Activities.
I open the Leaked Activities.
I leaked the activity every
time that I was rotating, right?
If you look at all the
instances of many activity,
I have seven instances of
MainActivity and six of them
were leaked.
That means that there
is something on my app
that is keeping a
reference to them,
and with that it keeps all the
resources of that activity.
So how do we find that?
Cool.
Let's click on one of
the leaked activities.
If you click here, it will
click on the main view
and we select the instance.
And then on the bottom pane,
you can see all the references
to that, right?
So you will see the reversed
references to your objects,
This tells you which
are the objects that
keep a reference to me.
We sort this by the distance
to the nearest root.
That means the nearest
garbage collection root.
That means that if
you expand the tree,
and you go in the first,
first, first, first child,
you're going to get to
the root pretty quickly.
And that is, in most cases, the
one that is keeping in memory.

On top of that, there is a
lot of Dominator calculation
retain size, so that you can
look at the documentation
and find what these things mean.
But I'm going to
quickly go and see
if I can just spot
the culprit of this.
I have my MainActivity,
and I have a ClockUpdater,
but it's a thread,
and this is a root.
So why is this still there?
I'm going to go to my code
and see why ClockUpdater keeps
a reference to my activity.
This is a thread.
You know, a &quot;don't do this
at home&quot; kind of thing.
I'm going to look at
all the usages of this.
And I actually know them.
Here are the ones
using the MainActivity.
I start this thread on
onCreate and-- whoops,
I left this comment out.
This is why my thread
was not stopping.
I'm going to press the
magic button again.
Cool.
Let's open the monitors.
Right.
I'm going to start
restarting the activity
and see if the memory
does something.
There we go.
Like we said, some activity
on the memory is expected.
This thing is going up.
Garbage collection, I'm going to
click on the garbage collection
button to see if it is a drop.
I think we're good.
Yep.
Memory is stable once again.
There's a garbage
collection, and we're
back to where we should be.
So the last monitor
I want to show you
is an experimental
monitor that we have.
And it is the GPU Monitor.

It's disabled by default
because when you enable this,
you might see some interference
with the other monitors.
So whenever we query the device
to get some GPU activity,
some allocations are happening,
and you will see your memory
monitor moving up and down.
So we have it disabled for
now, disabled by default.
I'm going to enable it.
For those of you
familiar with on-device,
when you go to Settings
and Developer Options,
something, something.
Then you go and
enable GPU Profiling.
You see on-device how
long each frame is taking.
We're showing the
same thing on Studio,
so you can see it at the same
time as the other monitors.

I'm going to start doing
something on my app,
and you will see some activity.
We have two lines there.
We have the red line
and the green line.
The green line is 60 frames
per second, everything
below that is super fine.
Then the yellow line is
30 frames per second.
You should really
not go over that.
You know, one is at
16.6 milliseconds,
the other one is double that.

And you can see
here that, whenever
I'm rendering a new
image, depending
on the size of the image,
we are going over the limit.
The reason for this is, I'm
not scaling the images at all.
I'm rendering them
as original size.
And, you know, this
will take some time.
I'm not going to fix
that using Instant Run.
Forgive me for that,
it's a bit more involved.
But this is how we would
use the GPU monitor.
So this is the last monitor
that I want to show you.
And I wanted to close
with a few words of where
we are going with the
performance tools in Studio.
So our idea is to
have the monitors
as a very quick thing for you
guys to look at your app, see
is everything fine or not.
And move all the analysis
that we could do automatically
to the monitor, so you
don't have to profile.
We'll do that live for you.
And we will highlight
the issues there.
And hopefully in the next
releases, the next year,
you're going to see
improvements on this area.
And we hope you have
healthier applications.
Thank you.
[APPLAUSE]
With that, I'm going to
invite my colleagues back
on the stage, and we'll
be happy to answer
any questions you might have.
TOR NORBYE: So, there's
microphones on both sides.

All right.
No questions?
Is there anything
else you want to see?
All right, we have a question.
Yes.
AUDIENCE: I have a question
about these performance tools.
Before, a lot of tools can
be opened as standalone app,
like a monitor or a view tracer.
Could these tools can be
opened without Android Studio?

TOR NORBYE: I was going
to say, right now,
we are moving away from that.
That's how we used to do things.
We used to have, sort of,
separate standalone tools,
and we're trying to put
everything into the ID.
And you want speak more
to the performance tools,
specifically?
ESTEBAN DE LA CANAL: Yes,
so, exactly what he said.
We are bringing all these
tools back into Studio.
And the reason
we're doing that is
so you can see multiple
monitors at the same time
and we can do more analysis.
The idea is to
integrate everything
into a more cohesive
experience, so you
don't have to switch
between different tools.
And having them inside
Studio gives us a chance of,
because we are the IDE,
we can see all your code,
we can explore the code.
And we could do from static
analysis to live performance.
We can do all the
spectrum of analysis.
That's why we're bringing
it all into studio.
AUDIENCE: But the reason I
ask is, sometimes opening
Android Studio is quite slow.
So I would prefer just
open a standalone app.
And it's just because, tracing
memory issues performance
is take a long time.
So if it just can open with one
app, and hook up with device,
or hook up with a simulator,
and a monitor can be easier.
TOR NORBYE: So you
do only analysis,
not coding or debugging?
AUDIENCE: We will, like,
coding and debugging,
but after we find the
issues, we can go--
TOR NORBYE: Then you want
to exit Android Studio
and just do your analysis.
AUDIENCE: Yeah.
TOR NORBYE: OK.
Yeah, the problem is
that for us, there's
a lot of convenience to
actually being integrated.
For example, like, you
saw all the text fields.
We do auto completion
on code, for example.
And that needs to
know about where's
your code, and what's
the project context,
and the classpath.
And so, you know,
integrating them
allows us to do a better
feature than when we
have really standalone tools.
So that's why we're
doing that deliberately.
All right, let's
go to that side.
AUDIENCE: Do you have any
update on the NDK side
to analyze memory,
like Valgrind?
Running Valgrind in the device
is a pretty painful thing
to do.
So I don't know if you
have any update on that.
KATHRYN SHIH: So, I don't think
we have an update right now.
But I would say that, in
general, we recognize strongly
the need for expanded
performance tools that
would cover and NDK development
and you should just stay tuned.
And we're sorry for the
lack of specificity.

AUDIENCE: I was noticing
that for shrinkResources, you
had that tools keep annotation,
in case you just needed to tell
the system to keep something.
TOR NORBYE: It's like the
ProGuard file, basically.
AUDIENCE: Yeah.
TOR NORBYE: Yeah.
AUDIENCE: So I
was wondering, how
do you do that for resources
that aren't defined
in XML, like something in raw?
TOR NORBYE: Well, those would
be at raw/ and then the name
of the resource.
AUDIENCE: Oh, so you
define that in an XML file.
TOR NORBYE: Yeah.
So I think whenever you
put something in raw,
they also get an actual
field name in the R class.
So the resource type is
raw, and then there's
the name that that field has.
AUDIENCE: OK.
TOR NORBYE: Yup.
AUDIENCE: So, Java
packages exist
so you can organize your Java
code and split it up however
you want.
But there aren't really clear
ways of organizing resources.
So if you have a
large app, you may
have dozens, if not hundreds, of
layout files or drawable files.
Are there any
plans or strategies
for organizing resources,
similar to how you
might organize other things?

TOR NORBYE: OK.
So I don't think we
have any concrete plans.
I know that people had
posted this workaround
on social media, where you
basically nest the folders
and you tell Gradle about this.
But there are some serious
downsides with that approach.
So I think for
now, what I've seen
apps do is, they
basically use a prefix.
Right?
So you sort of
organize everything
by a common prefix,
underscore, and then
the rest of the resource.
And I don't think it's
easier to do more than that.
I guess you can
use libraries, too,
but it might not
be very natural.
Anyone else want to say
anything about that?
Michal?
Gradle?
No?
OK.
MICHAL BENDOWSKI: No.
[LAUGHTER]

AUDIENCE: Hi.
So you showed some
really cool stuff
that looks like it ends
up being configuration set
in the local ID
for one programmer.
How do you see us sharing
that in the team, especially,
for example, the
structuralReplace,
talking about the
translation thing
that the translation
team shouldn't do,
that kind of thing?
TOR NORBYE: I think
a lot of these things
actually do get saved
as project settings.
And so I think by
default we actually-- so,
when we make a new project,
we put a gitignore.
We know that not
everyone uses gitignore,
but if you use
Mercurial, you probably
can translate it yourself.
So the gitignore is
basically documenting
what we think you want
to include and exclude.
And I think we actually
do encourage you to check
the .idea folder
into version control.
Because that's where you
store things like code styles.
I know in IntelliJ 15, you
also can import and expert
code styles really conveniently.
But I think at least
a structuralReplace
gets saved there.
So, yeah.
AUDIENCE: Thank you.
TOR NORBYE: Mm-hm.
AUDIENCE: Do you have any plans
for adding strace support,
or sort of bringing in the
web-based traces to IntelliJ?
ESTEBAN DE LA CANAL: Yes.
[LAUGHTER]

You want more detail than that?
Yeah, like I said,
we're planning
on bringing all the
performance tools into Studio,
and that's a very handy one.
So it's going to be on the list.

AUDIENCE: Hi.
Android Studio 2 looks amazing.
But I have a very simple
question about fine usages.
Is there an easy way to
prevent it from listing usages
and generated stuff like
merged intermediates?
TOR NORBYE: Yeah, I think that's
actually a question for Alex.
Because in general, we
try not to do that, right?
ALEX RUIZ: Yeah, but I
think that's a bug now.
TOR NORBYE: OK.
You found a bug.
Yeah.
In Gradle sync, you
do a lot of work.
To make sure that generated
things are recognized as
generated.
ALEX RUIZ: But we still
have to do more work
to get those generated
codes outside some searches
and refactoring targets.
TOR NORBYE: Do you already
have a bug tracking that?
ALEX RUIZ: I think so.
TOR NORBYE: OK, yeah.
AUDIENCE: Thank you.
TOR NORBYE: Alex
is working on it.
AUDIENCE: Hi.
I really like the Debugger, but
sometimes, in some projects,
it tries to resolve my
variables and it doesn't
seem to be able to do that.
Is that something you
recognized as well?
Or what's, kind of, the remedy
to get it working again?
SIVA VELUSAMY: When you
see it does not recognize,
are you talking
about it gets stuck?
Or are you just saying--
AUDIENCE: It just cannot resolve
the variables at a break point,
so to speak.
SIVA VELUSAMY: Well,
resolving a variable,
I'm not sure if it's a scope
issue stuck in the wrong area
and that variable is just
not visible in that scope,
or it's more of
an issue of, there
is an issue with the
connection, and then it
doesn't get through.
But if it's something that
is very specific and very
reproducible, you should
certainly file a bug.
As long as it's there in the
scope, it should be there.
It should be visible.
AUDIENCE: OK, but not
like clean project
or restart Android Studio?
SIVA VELUSAMY: I
mean, of course you
shouldn't have to do all that.
Certainly file the bug.
AUDIENCE: Do you
guys have any plans
for improving or integrating
Hierarchy Viewer and improved
view tree editing and reviewing?
SIVA VELUSAMY: That is correct.
That is coming
through pretty soon,
like over the next
year we'll see it.

Pretty much all the tools
that are present in DDMS,
I think all the
performance tools
will come in Android Studio.
Anything that was part of the
standalone or present in DDMS
monitor, you will
see all of them being
integrated into Android Studio.
TOR NORBYE: Yeah, I think
the only reason monitor
is a separate tool today is that
we haven't replaced absolutely
everything yet.
SIVA VELUSAMY: Yes.
AUDIENCE: Still about the
standalone performance tool.
My coworker point
out, like, do you
have any plan to
make some output
so we can use these
performance tool in the CI
so we can automatically
detect the performance issues?
ESTEBAN DE LA CANAL: Yes.
Yes.
So part of the
thing we plan to do
is, we have this in
a separate library.
But you could call command line,
all this analysis that will do.
So the idea is that you
can write regression tests,
or whatever you
need to make sure
that your application doesn't
regress in the performance
space.
So that will be covered, yes.
TOR NORBYE: Is there
something in Espresso as well
for doing performance testing?
MICHAL BENDOWSKI: Yes, it was
mentioned in the testing talk.
So, yeah, I recommend
you watch it later.
TOR NORBYE: Yeah.
OK.
Any other questions?

KATHRYN SHIH: Everyone knows
everything they would possibly
want to know about Studio.

TOR NORBYE: OK.
In that case, I thank you
very much for your time.
[APPLAUSE]
[ELECTRONIC MUSIC]
</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>