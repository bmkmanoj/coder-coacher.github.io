<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Engineer for High Performance with Tools from Android &amp; Play (Google I/O '17) | Coder Coacher - Coaching Coders</title><meta content="Engineer for High Performance with Tools from Android &amp; Play (Google I/O '17) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Engineer for High Performance with Tools from Android &amp; Play (Google I/O '17)</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ySxCrzsKSGI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">listen everybody yep hi everyone welcome
to our talk on the fact that no one
likes crashing or janky apps I'm Lydia
I'm a Technical Program Manager on
Android and I'm Ricardo engineering
manager on Google Play
everyone Fergus product manager for
Android BIOS hands up here who likes one
star rating okay we got one person in
the wrong talk I'm sorry but um the
people who don't like one star ratings
are in the right place so we're here to
tell you how you can engineer your app
for high performance with the new tools
available on Android and on Google Play
we're going to start off by talking
about why performance matters in general
and then we're going to jump into and
the new initiatives that we have around
android vitals and how we've simplified
it for you to be able to understand and
take action much easier by using the
concept of bad behaviors then we're
going to go into how you can detect and
fix these issues most effectively to be
able to have successful app great so for
the people who want to avoid those 1
star ratings the number one way you can
do that is by focusing on stability of
your applications we put Google's
machine learning to work to be able to
figure out what are people talking about
in 1 star ratings we found the 50% of 1
star ratings are talking about stability
and bugs then once you fix those issues
how can you get to a 5 star app what we
found is that if you want to get your
files around focusing on design
usability and speed are the things that
matter because 60% of 5 star reviews are
talking about those topics but don't
just take our word first are more likely
giggles machine learning words first you
need to actually take developers words
where the busuu team which is built an
amazing language learning app found that
by focusing on performance and making
that a part of their culture they were
able to increase their star rating as a
result
the big fish games team have even seen
increases in retention by focusing on
performance at Google and simply within
Android we're obsessed with our
performance and device performance
we've been assessing over this for a
number of years now back in 2012 we
launched project butter with jellybean
since then we've launched the doze mode
project Vulcan last year and this year
bunch of new tools in Android oak and
the ability for you to be able to get
insights with Android BIOS so what is
Android BIOS you might have seen this in
the keynote earlier today this is our
new initiative to be able to help you be
able to gain deeper insights into the
performance of your application across
core performance metrics the three that
we're starting with our stability
battery and render times you'll see many
more comb over the course of the next
few months and we'll be able to give you
those insights on Android and on the
Play console so let's jump into the
three that we're launching today first
one is stability so everyone knows that
you shouldn't have at your app crash
people to be focused on this for a
number of years and crashlytics has
introduced the concept of crash for
users now in the Play console you can be
able to see your crime history user rate
and your class race you can also be Oh
see your a and our race and this is
where your a and or is a concept on
Android which is application not
responding that's when your app appears
frozen and does not respond for five
seconds
the next area is battery so this is
where we want you to avoid using
people's advices and consuming their
battery inefficiently so this is where
we want to avoid using the radios are
using the CPU when you shouldn't be and
you don't need to actually the next area
is rendering so this is where we want to
be able to help you understand how do
you can you provide a silky smooth
experience to your users so that they
feel like your app is smooth and fluid
on their device and we've two metrics
that we're going to introduce to you
today that can actually help you be able
to deeply understand that area so we're
talking about three major performance
areas here and within each performance
area we're going to be introducing two
metrics it's a lot of data to be able to
understand and consume so we've
simplified it to this concept of bad
behaviors this is where we take your app
and we study the performance data and we
figure out if you're in the bottom 25%
of a according to that metric we flag it
to you and say hey you need to improve
in this area let's do a show of hands so
if let's say 5% of your users are
experiencing that 50% of their frames
are taking more than 16 frames per set
it's 16 milliseconds to render on the
screen is that a problem
hands up stating its problem okay great
so laps people agree that's the problem
at last feel like don't agree that
that's a problem well we will actually
tell you in the console when you've
reached the boundary of when when that's
a problem and you're in the bottom 25%
right now that's at about 2% of users
impacting experiencing data race will
actually be flagged and that is putting
you in the bottom 25% so we're really
trying to simplify it there for you so
you can be able to understand where
you're positioned according to the
benchmark so where do you see this data
you see this data in a new top-level
navigation item in the play console
called Android vials it's live right now
to all of you and if you have enough
data you'll see the insights that I'm
talking about
and that Ricardo is going to tell you
more about right now
Thank You Fergus so Fergus just said we
just launched a new section in the play
console which is called android vitals
and it is available to all of you today
and you can go and check it out now what
it does it summarizes all the findings
that we have about your app performance
across these three domains that Fergus
just mentioned stability battery and
renderings it works out of the box
without any integration needed no SDKs
to add nothing to add your apk size the
data that you find there is collected
from millions of Android users that have
opted in to share diagnostic information
with Google to help all of you
understand and improve the quality of
your apps android vitals also eye light
whenever wherever at any given time
there is a problem that affects a
significant fraction of your users for
example you can see one of the red marks
over there to indicate that you should
be looking at your rendering and
understand if there is an issue there
and so you can use this as the first
port of call to understand your
application performance so we're going
to spend some time now to go in the
detail about all these three domains
stability battery and rendering I'm
going to start with stability stability
is about crashes and ANR reports
applications not responding until today
the only way for an ANR or a crash the
surface in the play console was if your
users explicitly acknowledge a dialogue
on the phone for each ANR in crash to be
reported and these obviously tedious and
it led to low volume of crash and in our
reports so the first thing that we have
done with android vitals we have greatly
reduced user friction as I mentioned the
data that you find there comes from
users that have opted in to share
diagnostic information opt in typically
happens only once when a person
activates a new phone and that is a very
low friction gesture so this means that
in the Play console now you see over 100
fold coverage in the number of records
with reports coming from users running
and versions of Android as all this
jelly bean and these which is 98% of the
Android devices that apply services in
store
so let's start with the first domain
stability what are the bad behaviors
that we want to flag out there crashes
an application not responding which is
application phrases for sure you never
really want any user of your app to
experience one of them and so we define
these bad behaviors in terms of
percentage of users that are
experiencing any of them in any given
day you may be familiar with the
equivalent metric that other crash
reporting tools have introduced crash
free users and so for the next few
minutes I'm going to focus on ANR
specifically what is an NR NR means
application of responding and this
happens when your application freezes
and stop responding to user input this
could be because you have a dead look in
your multi-threaded code because if a UI
thread which is too slow or because you
have background receivers that do not
complete within a meaningful amount of
time a nurse are super disruptive of the
user experience and therefore you should
aim to never have any of them and
because application is frozen during an
NR it means that you cannot typically
use a cross reporting SDK to collect
them on the other side the Android
platform trucks all of them
automatically so they are all available
in the Play console without you having
to do anything at all you just go to the
Android vital section and in there you
will find a tab which is called a NR
rate here you can see how many unique
users experience an application of
responding when the app was used on a
given day across app versions device and
OS versions and if the fraction of the
user is significant you give you get a
red eye light to drive your attention so
you can focus on the most prominent
issues and dive into the litres you can
click there relatedly in our section and
in there you arrive in the NRA crashes
section of the play console here in
addition to reviewing your overall crash
be rate and ANR rate you can dive into
each crash na NR that has been detected
for your application
Android collects a in arson crashes
almost immediately as they occurred so
here you find crashes in ours they're
typically a few minutes old at most
there is a bunch of little new features
for example we highlight when a given
ANR has been introduced for the first
time in your most recent app version
with those little orange highlights to
let you track the quality of your last
release you also get to see the number
of unique users that have been affected
by that particular in our so you can
distinguish between high volume issues
that are affecting only a handful of
users versus widespread ones that might
be affecting a significant fraction of
your user base you can dive into the
details and observe how the number of
reports and the number of affected users
trends over time and now he breaks down
across device versions or aspiration app
versions and obviously you also get the
full thread dump that captures the
application state at the time Leonar
occurred and for crashes obviously you
get similar functionality where you get
the stack trace that was observed when a
crash occurred so I think this gives you
a pretty good information visibility
into what is happening on your users
phone the next step is to try and
reproduce and debug them what I
recommend is new Android studio 3.2 that
has plenty of new profiling capabilities
the new Android profilers is studio 3.0
provide real time data about your app
CPU memory and network activity and I
think this is a great next step to debug
your ANR's because root causing them
often lies in not taking into proper
consideration CPU intensive operation or
blocking operations like fetching data
from the network the CPU profiler for
example gives you real-time CPU usage
for your up process on a timeline you
can dive through instrumented method
traces and understand which methods in
maybe in your UI thread are in using up
most of the time and become blocking
similarly
the network profiler display network
activity on a timeline showing the data
was sent received and associated
latencies again you can use this to
if a slow Network poll is making your
thread blocks for a response or Ambika
zone of an NR this way and instead
showed in the keynote before it's very
easy from here to jump directly into the
code that is responsible for that
network code if you want to learn more
about the speed profilers there's a
great talk tomorrow morning in alpha
theater that I encourage you to go and
attend to okay now we discussed how to
reveal many nrcs how to debug them but
the thing is how do you prevent them
from happening in the first place
textbook recommendation Android 101 is
do not do blocking operations in the UI
thread and use for example a sync task
instead you can use strict mode to catch
accidental disk or network access on the
application main thread as well
another common case is when you have a
broadcast receiver that receives an
intent and does not finish processing
within a window of time which is around
10 seconds or your brokers the receiver
goes a sync but you forget it will
finish on the pending result that you
get back again this Android 101 very
simple examples most likely your code is
much more complicated than this you may
be using cues a synchronous operation
libraries like rx Java the basic do not
change the same recommendations apply be
mindful of which threads are on which
threads the callback for your a
synchronous processing end up executing
on use semantics in your coding
practices that make sure that you don't
end up executing accidentally on UI
threads when you don't want and so on
finally be mindful of introducing dead
lots in your app and beat because if you
inject Leonar traces that you're
collecting when the device is connected
to your PC when you're doing debugging
or by downloading the tracing from the
plight console you can easily spot if at
any time you have deadlocks
by for example looking when a given
thread like the UI thread ear is locked
waiting for a background one and vice
versa so this is all I have to cover
about ANR the fundamental question
remains how much do they matter how much
should you care and the answer is you
should really care a lot we look at the
apps that have a high and low crush
weights in play
high crash rate more than 5% of trash
users experiencing a crash or an arcade
date and what we find is that these apps
are 30% more uninstallation
in the first day than apps that have a
low pressure rate less than 1% so the
message is pretty simple here is find
Europe and they include experience a
crush most likely they will leave as
soon as they found it I will now hand
over to Lydia for battery and rendering
thanks Ricardo Android users care a lot
about battery life in fact making it
through the day without needing to
charge their device is a top concern for
Android users because of this the
Android platform has spent a lot of time
building features to save battery one of
the number one ways we can conserve
power and battery power is by putting
the device into deep sleep when it's
idle this means powering down the CPU
radio and other components that would
otherwise drain power however you as
application developers can prevent the
diet device from going into a deep sleep
and conserving power one of the ways you
can do this is through wakelocks
way clocks keep the device awake so that
it can perform an activity on behalf of
your application there's a couple
different types of way clocks the first
is a full-weight clock this keeps the
screen on and this is usually used by a
video app or a gaming app because the
screen is on the user is going to be
aware that the way clock is being held
and in full control of powering down the
app and saving their battery there's
another kind of way clock though this is
called a partial way clock a partial way
clock doesn't keep the screen on because
of this the user doesn't know that the
the way clock is being held and so if a
wakelock a partial way clock is held for
too long if you can can become a silent
and deadly killer of battery power
because of this we defined a bad
behavior around stuck partial way clocks
we define a suck partial way clock as
one that's held for over an hour
by significant percentage of your users
the Android vitals dashboard will show
you how you're using and possibly
abusing way clocks it will show you the
distribution of how long wait clocks are
being held by each version of your
in this example you can see the majority
of wake locks are being held for a
minute or less which is ideal from a
power saving perspective however there's
a long tail of wake locks that are being
held for over an hour which meet our
definition of bad behavior or stuck wake
locks so you can see that we flagged
this app for this bad behavior in the
Android vitals dashboard in the Android
vitals dashboard we'll give you the
information you need to debug your stuck
wake lock most importantly the name of
the wake lock in order to prevent to
protect user privacy we will only show
wakelock names if it's been used across
many sessions this will prevent the
leaking of any personally identifiable
information because of this I encourage
you to use standard wake lock names for
each distinct wake lock in your
application in order for them to be
debuggable in case they become stuck
wake locks the reason that we're
highlighting stuck wake locks in the
vitals dashboard is because of just how
dangerous they are I mentioned in
Android we care a lot about conserving
power so every day we collect reports
from internal Google users who have
experienced a bad battery day a bad
battery day is one where your device the
battery doesn't last as long as it
usually does or as long as you expect it
to do so they'll send us these reports
we did some analysis across a two month
period of all these reports last summer
and we found that 30% of these bad
battery days were caused by stuck
wakelocks I think this highlights really
how dangerous wake locks are they cause
real problems for real users
because of this I encourage you to avoid
using wake locks entirely wake locks
were introduced in the early days of the
Android platform and since then many of
the use cases for which you needed a
wake lock you no longer need a wake lock
for for example if you're doing a
long-running download you can use the
download manager instead if you're
synchronizing data with an external
server use a sync adapter instead if you
need to run a background task use the
job dispatcher and if you're holding a
way
clock so that you can process an intent
before the device goes to sleep use the
new job intent services which is being
released in the support Lib v26 that's
coming out later this quarter both job
dispatcher and the job intent service
are compatible with the background
restrictions that we're going to be
rolling out and oh so it's a win-win you
get a background check
background restrictions compatible
service and you don't get any stuck way
clocks so definitely check out job
intent services in support lid b-26 if
you're unable to use any of these
alternatives and you need to use a
wakelock in your application i'll rehash
some of the fundamentals from cs101
because they're just so dangerous aiya
I'll spend some time rehashing first it
keep the logic around your way clock
extremely simple because any errors in
the logic could lead to them getting
stuck second try to do as little as
possible while you're holding this way
clock so that it doesn't you know need
to run for an hour or more to do
whatever operation you're holding it for
and finally use defensive air handling
you can see in this example here if I
hadn't defended against my clean up task
throwing an exception the release method
on my way clock would never have gotten
called and some poor user or perhaps
millions of users would end up with dead
sound batteries so if you follow all my
advice and are able to not use any way
clocks in your application I still want
you to go check out the android vitals
dashboard for stuck way clocks because
it's possible that services you depend
on are using way clocks under the covers
for example the network location
provider way clock in this case it's
used by millions of apps to find a
user's location if you're using it too
aggressively it could hold my clocks for
an extended period of time that becomes
stuck and you get flagged for that so in
this case you would fix that subway
clock by throttling back the amount of
calls you make to this service so
definitely check out this tab even if
you're not using wait cloth so you can
tune how you use the services under the
covers that might be using wait clocks
the second way you as an application
developer can prevent the phone from
going into a deep sleep and saving power
for user
is through the use of wake up wait
that's our alarms that you can fire
outside the lifetime of your
applications to wake the device up to do
some sort of task on behalf of your
application if you do this excessively
the device won't be able to rest and
you'll end up draining a lot of power so
we've identified a bad behavior of
excessive wakeup we define frequent app
wakeup as a percentage of users who are
impacted by wake up's that occur more
than 10 times per hour just like wake
locks you can get a full report on the
wakeup that you're using or possibly
abusing in the vitals dashboard and just
like wake locks you'll see the
distribution of the number of wake up's
across sessions and you'll be able to
see the names of each wake up so you can
debug any frequent wakeup issues and
just like wake locks will only show the
wakeup name if it's seen across a lot of
sessions so that we don't leak any
personal identifying information so
again be sure to use a standard name for
all wake up's a lot of people use the
pattern of firing a wake up to get the
device awake and then holding a wake
lock to keep the device awake so that
you can perform some sort of task this
is a double whammy of possible bad
behavior because you might be waking up
the device too frequently and your wake
lock that you're holding may get stuck
so let's get rid of both of these a much
better alternative to wake up's and wake
locks is the fire based job dispatcher
the Android platform itself does have a
job scheduler but I encourage you to use
the firebase job dispatcher because of
its backwards compatibility in the
firebase job dispatcher you can set up a
task to run as a repeating task for
example I can run this every 30 minutes
dialing back the frequency that you're
running the task is a first step to save
some power so 30 minutes is certainly
better than running this every 5 minutes
however you can also constrain the job
to run only when it's on a charger this
is obviously the ultimate battery saver
because it would never run while users
on batteries here at Google a lot of our
apps employ this method for example Play
Store will wait to update auto-update
apps until you're on a charger this
because we understand a user would
rather have a device that lasts through
the day than a latest update of some
apps
so I encourage you to use that same very
critical lens when you're considering
scheduling jobs see if it can wait until
the device is on a charger the final bad
behavior we'll talk about today is
render time render times measures the
amount of time a frame drawn by your
application takes to actually get
rendered on the screen Hardware render
time directly correlates with how users
perceive the performance of your app
Android devices render at 60 frames per
second this is based on the refresh rate
that's available in the screen hardware
itself if you do the math 60 frames per
second breaks down to having to render a
frame every 16 milliseconds so as long
as your app is rendering a frame every
16 milliseconds users will feel that
your app is very smooth very fluent and
very pleasant to browse if your frames
take longer than 16 milliseconds even
just 17 milliseconds it will get dropped
if you have a lot of dropped frames your
application will feel very stuttery
very jarring to users so you want to
minimize the number of dropped frames
that your application has if you drop
many frames in a row and you get to the
point that it's been 700 milliseconds
before you draw the next frame in your
application this is the point at which
users will think your app is
unresponsive and they'll begin to feel
frustrated by it you should aim to have
0 frames that take 700 milliseconds or
more to render we've used both of these
thresholds to identify some bad behavior
the first is slow rendering we define
this bad behavior as the percentage of
users who experience more than 50%
dropped frames the second bad rendering
behavior are frozen frames we define
this as the percentage of users who
experience more than 0.1 percent of
their frames being frozen
the Android vitals dashboard reports on
both of these metrics and will flag you
if you're excessively slow and rendering
or too many frozen frames just like wake
locks and wake up you can see the
distribution of wakeup of rendering
times across sessions and the dashboard
will also give you some other statistics
that help you understand what might be
causing your rendering issues for
example I can see a high percentage of
slow UI thread activity this indicates
this indicates to me that I'm probably
trying to do too much work on the UI
thread so I should move things like disk
i/o or network activity to a background
thread these statistics though are
pretty high level and they'll just hint
at the root cause of your rendering
issues to really understand what's
causing your rendering issues you'll
need to dive deeper you can do this in
three steps the first step is to
instrument your app with the frame
metrics aggregator API this API is built
on the frame metrics API that was
released released in android Mugen the
frame metrics API collects statistics
about how long each frame takes
surrender the frame metrics aggregator
API as the name suggests aggregates
these systems these statistics across a
series of activities that you define and
you define the start and the end point
of that collection so you can collect
statistics about how long specific work
flows in your application take to render
once you've done this step step 2 is to
get this debate of data off the device
and upload it to the cloud or your
servers where you can then analyze it
you'll analyze it to find what flows are
rendering slowly for the majority of
your users from there you can move on to
step 3 which is getting your device out
walking through those flows all that
means meanwhile recording a trace once
you reproduce that flow rendering
behavior or those frozen frames you can
upload that trace into systrace which
will tell you exactly what was going on
in your application when that slow
rendering occurred and not just your
application but what was going on in the
system as well from there you can figure
out which specific code path you need to
optimize the
fix your rendering performance I've just
skimmed the surface of the frame metrics
aggregator API as well systrace luckily
you have two more opportunities to learn
more about them this evening Tim Murray
who's an expert on systrace will give a
talk on how you can use it to debug
rendering issues tim has analyzed over a
thousand cysts races and is a true
expert in the field on Friday you can go
learn from Chris and check the authors
of the frame metrics aggregator API
about how you can use it to really
understand your application performance
and with that I'll give it back to
Fergus to close thanks so much
incluye great so today we introduced
three performance areas with many other
performance areas we're going to be
introducing as I mentioned earlier over
the course of the next couple of months
app startup time memory and network use
for each one of these performance areas
we're going to introduce bad behaviors
so it's really easy to understand the
metrics and how you're doing in that
metric compared to other apps a lot of
these tools we talked about especially
on the Play Developer console side for
them Android vital dashboard aggregated
over your whole apk if you want to
understand within your apk specific
performance areas I'd encourage you to
use the firebase performance monitoring
tool whose launched earlier today at the
developer keynote and enables you to be
able to instrument your app out of the
box comes network and startup time but
you'll also able to use your own
counters to the other track whatever you
would like to track in your application
there's a talk on this that's going to
happen tomorrow and I'd encourage you
all to attend that to learn more about
how you can be able to use at the fibers
performance monitoring SDK in your
application to be able to improve
performance so we covered a lot today we
covered why performance matters
we covered Android BIOS issues the new
concepts around bad behaviors and the
six performance six bad behaviors again
those bad behaviors are high a and or
race high crash race excessive wake-ups
subway clocks
a slow rendering and frozen frames we
introduced the Android BIOS dashboards
in the Play console talked about the
Android studio 3.0 profilers and the
Android AP eyes are available for you so
if you're not motivated by all the
things we talked about around
performance today I encourage you to
come to our talk tomorrow where we can
give you a BuzzFeed like talk on why you
should care more about performance with
all the Play console tools that we have
available so one of the things that
we're going to talk about in this talk
is the rewards like the Play Store is
going to offer you for being able to
improve the performance of your
application I will get more into the
details there but we're just going to
start using this performance data in the
promote ability within the store another
reason why I should care about
performance is with 2 billion users on
Android right now it's a lot of users a
lot of users are using their devices to
make emergency calls if you improve the
battery life of your device and your of
the device itself by improving battery
life of your app then users device the
last longer they'll be able to make more
emergency calls and that you're
basically I'm gonna ground lame and say
it saving people's lives by focusing on
performance it's great maybe stretching
a little there but hopefully you get it
great thank you very much everyone
I really appreciate joining today</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>