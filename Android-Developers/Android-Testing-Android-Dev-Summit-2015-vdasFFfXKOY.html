<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Android Testing (Android Dev Summit 2015) | Coder Coacher - Coaching Coders</title><meta content="Android Testing (Android Dev Summit 2015) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Android Testing (Android Dev Summit 2015)</b></h2><h5 class="post__date">2015-11-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vdasFFfXKOY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey guys welcome to our talk on Android
testing api's and today we're going to
show you how you can write higher
quality apps using automated tests my
name is Jeff Allen sneh i'm jose alpha
raka and i'm yun felix mark I'd and via
developer programs engineer on the
developer platform team here at Google
and you might have seen some of the
sample coding some for libraries that
we've been working on in particular the
N draw testing support library is
something that they've worked on and
with that our lee ki-woo stefan who's
going to talk with more about how
Android testing has evolved over the
last few years thank you guys so almost
two years ago when we started thinking
about how we can make developers more
productive how can we enable you guys to
write higher-quality apps one thing that
repeatedly came up was automated testing
but if you look at the testing ap is
what you will find is some of them have
changed in API level 3 which was cupcake
and most of them have been around since
API level 1 so what that means is in the
meantime Android has evolved a lot right
and I'm I'm so proud of what we've
achieved in the last five or six years
in Android and I'm pretty sure everyone
in this room is but we haven't evolved
in a testing space and that's what we
wanted to change we wanted to make
testing easier and we wanted to have a
better testing experience across the
stack so since then we've made a lot of
progress on many levels of the stack and
we've created a new suite of tools and
frameworks to enable a better testing
experience and make it even fun to write
tests so we have Android studio in
Gradle which added amazing new features
like the new unit test report which
allows for faster development cycles and
makes you more productive
we have new ways to write and run tests
and we also now have compelling ways to
display test results and code coverage
reports in Android studio and now with
Android studio 2.0 you can even refactor
across unit and instrumentation tests
which is amazing but we went even
further so we ended up creating a full
support library for testing code
the Android testing support library this
library contains all of our testing
api's and you can just apply it to your
project and get easily started with
testing but even more importantly this
libraries unbundled from the platform
which means we can update it at any time
and we can iterate faster and we can fix
bugs more quickly which was a problem
before on top of that we also created a
new testing library called espresso and
this address is actually one of the
biggest pain points that we had in
Android testing for a while which is UI
testing and espresso you will see that
if you start using it has a really nice
beautiful concise and fluent API which
makes for frictionless testing and with
that I'm going to hand back to jf he's
going to talk about the codelab app that
we've built to show you how you can use
our testing API as an action in your
project cool Thank You Stefan so the app
I'm talking about here is actually part
of a code lab that we are going to be
referring to throughout this
presentation at the end I have some
links and resources you can actually
check it out and see exactly what we
have done so the app we wanted to build
was meant to be a you know must meant to
showcase the best practice for testing
today you know how you care how you
should be using testing in your android
application so what we have built is a
very simple very standard notetaking
application you can view a list of the
notes that you have in your app you can
add a new note which means you can also
take a photo attach it to your note you
can click on a node and it opens up and
you can see it's full content and you
have some navigation in there as well
and as you can see this is very much a
stock standard Android application
probably quite similar to the way you've
built an Android app before you're using
a recycler view to display the list of
notes we're using a system intent to
open the camera app to take a to take a
photo of using the system camera
application
and we have a and we have a navigation
drawer in there as well with the menu
options just remember the key here was
to create an application that shows you
how you can you know show you the best
practices friend we're testing today so
as part of that do you have mirror
thinking very carefully about the
architecture that you use for it
occasion let me be very clear here MVP
is mana bleep reside architecture
obviously but there are many other great
architectures out there and it really
depends on your use cases and your
application to select something that
works for you just remember the key part
for any architecture is that you can
separate the different parts of
different components of your application
from another so you can test them
independently and you can maintain them
independently as well so in our case for
our application that was the Model View
present architecture and the way this
works is that we have the data storage
the list of nodes at the model we have a
view this is where the actual Android
magic happens that's the V deal with
recycler view and display the actual
nodes so for example if you want to load
in a list of nodes and display them on
the screen the presenter talks to the
model loads in the list of nodes and
tells the view to display it and then
the view talk to the cycle of view and
then displays it so just remember the
key part here is to separate the
different areas and different components
of the application and it makes it
really easy and really useful for
testing now we're for say coming up next
telling with more about testing and
independent components thank you yes
so jf mentioned testing in isolation in
order to test in isolation you need to
be able to create a hermetic environment
so before talking about the types of
tests let's talk about hermetic testing
why do we need hermetic testing because
there's something worse than having no
tests that's having flaky tests I've
seen this lie so many times I do
remember was finding a test is flaky
when it fails sometimes so if a test
fails just 1% of the time you run it you
will submit your code so make your test
and in 3 weeks you'll get a call or you
get an email saying something went wrong
because this test failed
so you'll start your investigation you
login into your Jenkins instance if you
have one and after 15 minutes you said
you will say the famous last words
it's probably
just a flaky test that's something that
should that you should never have to say
or hear so in this code lab in this
project we decided to what we had an
objective to reduce flakiness as much as
possible so the first thing we did was
to isolate from external dependencies
external dependencies are one of the
most important sources of flakiness
especially the network for example
because the network can can fail in
network goals when you talk to your
back-end API can fail in many steps your
Wi-Fi your ISP connection the server has
to be on and working but also all the
external dependencies to our code like a
storage device all the devices sensors
the camera etc so what we're gonna what
we're going to do is replace the
components that talk to these external
dependencies weak with fake
implementations that are going to
intercept that and return fake data
immediately for that we could use
something like dependency injection
framework like dagger or dagger tube but
we found something that is simpler
flavors product flavors is a feature in
the Android Android Gradle plugin you
probably familiar with it because this
is what you use if you want to create
versions different versions of your app
sharing code base so it's very common to
see free versus paid dimension for
flavors in this case we have prod and
mock prod is your production version
what that that that you distribute and
mock is the one that is going to use
this fake data if you open the project
with under studio and you look at the
build variance window you'll see that we
have three variants that's because we
are filtering out mark release because
it makes no sense and we don't need it
if you look at the Gradle tasks list
you'll see that there's no install debug
anymore
so now we have to choose which version
we want to install we can install mock
debug or debug to run tests we usually
use connect instrumentation tests we
usually use connected Android tests but
we are we can now also choose what
version to test against with connected
mugdha but under test and connected
proudly above enderchest so let's see
how it's done first you create a source
set per flavor so we have prod and mock
and we also have another interesting
sources Android test Mach this is where
you put the tests that only make sense
for the mock version of your app check
out the code to see why we use that this
is where the actual replacement happens
the injection class lives in both mark
and prod sources so that is the class
that is going to be replaced depending
on the version that you're using also we
put the fake implementations in the milk
source said this is great because it's
actually going to hide this classes from
the production app so that you can't use
them by mistake zooming in a little bit
this is the injection class of the mock
flavor of the mock source set rather it
has two methods both injection classes
look the same from the outside it they
have the same public methods provide
image file is the method that we use
from the component that talks to the
camera so we're going to return a new
fake image file implementation that
class the only thing is doing is
returning a string a path to an image
file that we preload it so it's a fake
image really provide notes repository is
the method that we use to create the
repository so if you're using the mock
flavor it's going to create an actual
real in-memory repository but we're
going to inject a fake dependency in
this case the fake notes travel service
API implementation that's a very Java
name I know
is going not to start any HTTP
connections but it's just going to
return immediately JSON file in this
case and that's it that's how we set up
that's that that's how we set up our
Matic environment is it actually three
to twelve I'll be pretty cool yeah more
or less right this has some interesting
side effects NOC mode this I mean using
the the mock flavor is interesting if
you are developing your app you usually
do manual testing right if you're
developing you I specifically you change
something in UI you deploy and then you
you test manually that what you what
you've doing works if you use fake data
this iteration is going to be shorted so
your development is going to be faster
it's also good for concurrent
development so if you don't have a
back-end API yet you can use fake data
in the meantime we're not only going to
run instrumentation tests against the
product the mock flavor we can also use
the production app because it's going to
give us very nice end-to-end tests if we
want to test the whole project from the
backend to the app this test is going to
be obviously more flaky but you don't
have to run it very often you can run it
every 24 hours
or it's actually a very nice pre-release
check so before uploading to Google Play
or your distribution channel you run
this test against brought to make sure
that everything works well so now that
we have a hermetic environment we can
start talking about tests and the first
one the first type is unit tests they
are fundamental for a good testing
strategy that then can be completed with
integration and UI tests a small number
of end-to-end tests and other tests like
monkey runs robot rounds oven
performance tests that jf is going to
talk about later the unit tests also
called local tests because they they run
on your local workstation so they are
really fast but they're also fast
because they are small unit testing is
about making sure that the individual
parts of your code work as expected so
the unit tests must be small and you
should be able to run thousands of tests
in seconds the problem is that because
we are running on our workstation we
don't have access to the framework we
don't have access to Android so the
problem with Android is that we see
these a lot we just we just have huge
activities with all the code typed into
them or huge fragments so this is
horrible for unit testing don't be this
developer be this other guy he you need
tests his business logic and he's really
happy about it business logic means what
your app actually does so if you have a
filtering up sorry a photo filtering app
the business logic would probably be the
algorithms that you use to filter the
images only if you have small
dependencies with the framework you can
use this nice feature that we added to
the unit testing support in 1.1 the
mockable Android or the Android jar is a
file that you download with the SDK
manager and it looks like Android from
the outside it has all the public
methods and all the public classes but
it's actually empty so if you have a
small dependency on Android you can use
a mocking framework like mojito to to
mark this classes we have an example in
github that is mocking shared
preferences so if you don't want to wrap
that class
you can use mojito and on your unit
tests and running on your local
workstation so let's see how the tests
the unit tests look like they live in
the test folder we have five five
classes if you open well the first thing
you have to do is go to the build
variants window and choose unit test as
the test artifact this is going to
enable the unit test but also
refactorings and refactorings and
something else but this is actually
going away in Android studio 2.0 you
don't have to do this anymore because
both instrumentation and unit tests are
going to be active so you'll be able to
reflect across both test artifacts if
you know what I'm talking about you know
this is huge this is how normal unit
test looks like it's a J unit for test
it has the a presentation the name and
it's as simple as it gets the add new
node method is called on the real
presenter and then we're verifying that
the mocked view in this case was called
via that method show add node method
verify is a mojito API by the way in
order to execute it you can right click
on the method right click on the class
or right click on the file and
indirectly menu to just click on run
from Gradle we simply use test because
your unit tests are supposed to be fast
and they should pass really fast so you
don't need to filter one so we just run
all all of them all the time on the code
lab in the code lab we use a test-driven
development approach this is about
creating the unit tests first and the
unit tests will act as a contract it's
that is going to say how your app
behaves so the first thing you do you
create the unit test you see that it
fails when you implement the behavior on
your app until the test passes and
then you move on to the next test until
you have something like this a glorious
list of tests all passing so with all
that we've talked about the fact that we
have an architecture that in this case
is MVP but you can use whatever you want
they have the the fact we have the
Hermetic testing in place and that we
are using unit tests and TDD is going to
lead you to a very very healthy code
base we're adding new features is super
easy it's a matter of adding an unit
test a couple of methods in on a in a
interface and then Android studio is
actually going to tell you where to fill
in the gaps great for me interests as
well you don't need to be afraid of
refactorings anymore because you are
covered by by tests and you'll see that
instead of adding to your technical debt
every time you modify your code all the
pieces are going to fall into place so
to finish off I want to talk about a
hybrid type of tests these are the unit
tests that run on a device or an
emulator they are by definition
integration tests by the way so we call
them you need Android tests because we
are good at naming these tests allow you
to test things like like your possible
implementation or your sequel ID
integration and they're actually visible
sorry invisible you just upload the
tests you run them and then the results
come back so you don't actually see
anything because they don't open
activities they don't open fragments if
you want to test to test those UI
elements and the UI interactions as
Stephan is here to talk about UI testing
with espresso thanks thanks
yeah so let's talk a little bit about UI
testing so yeah I think the previous
part was great because it showed that we
can create that we can implement all our
business logic we can verify its
correctness using a unit test and then
we can move on to a higher level of
testing and write some UI tests for it
but the other thing that it shows and
you will actually see that if you do the
code lab which I by the way I hope you
all do right after this sessions go down
there downstairs is that we use the IDE
to generate it to generate most of the
code for us so because if you look at
the test as your specification and if
you do TDD you can use the IDE to
generate almost all the code for you and
you just fill in the gaps but it also
shows how you can use meaningful
abstractions and use a unit test to spec
the behavior of your system how your
objects interact how to send messages to
each other how they behave but we can
apply some of these same patterns to the
AI testing and we'll look at this now so
UI tests should be a crucial part of
your development strategy like
essentially they test your application
through its user interface it's already
in the world and what that also means is
that these tests have to run on an
actual emulator or device and the great
thing about them is they will give you a
lot of confidence in your application
because you can run on a wide variety of
configurations on emulators and you can
now even use cloud test lab to run on
real devices in the cloud and so for the
next release you can just sleep well
because you know your app is just going
to work across all these different
configurations but um I think I lied a
bit um because um it turns out that UI
testing is actually quite hard to do and
writing a reliable and non flaky UI
tests before espresso it was a challenge
and many of you I'm sure have
experienced this and this is essentially
why we
created espresso because we want you
guys to focus on being productive on
writing code implementing new features
maybe even focus on a test but we don't
want you to fix your flaky tests and
what espresso will give you is a nice
fluent and concise API which you can use
to hide all almost all of the complexity
that comes with writing UI tests so when
we started creating espresso we tried
off we try to look at UI testing from a
different angle right we didn't want it
to focus so much on implementation
details like activities and fragments
instead we you know we took a step back
and we thought okay what would a user do
and if you think about it what do you do
every day if you interact with your
device you pick it up you'll find some
view on the screen then you'll perform
some action on it you might click on a
button swipe and then you observe some
UI state change and this is essentially
how our API however a special API looks
like
so we have the on.you method as the main
entry point and then we can just use a
view matcher to tell us press o to find
us a view in the current view hierarchy
and then once we have that view we can
either perform a view action on it or we
can verify a view assertion like a state
change in a UI and a view action in this
case which would be something like a
click or a scroll the good news is that
we created all the view matters actions
and assertions for you and I'm pretty
sure the ones that we have covered like
90% of the cases but the great thing is
all these three are extension points and
they make espresso very customizable and
you can actually tailor it to your needs
by writing your own measures actions and
view assertions but now let's look at
how you would actually write an espresso
test for your application but before we
dive in the implementation let's have a
look at the add node feature from the
Notes app so this is a UI flow I'm going
to show you and we're
going to implement it afterwards so we
start on a main note screen then the
next thing one do is we want to click on
a button this will bring up the add
notes fragments where we can type in a
title and a description then we can save
the note and this will bring us back to
the previous screen and as you can see
the note is displayed the new one is
displayed on the main note screen and we
want to verify that in our UI test so
yeah let's write a test so the first
thing that you have to do is you have to
create the note screen test in your
Android test source set and then you
have to do two things the first thing is
you have to tell j-unit that you
actually want to want to use the Android
j-unit forerunner and then the second
thing is you have to assign a test to a
bucket this is something that you don't
have to do but we recommend to do it
because especially if you run on a build
server you don't want to run all the
tests at a time you just want to run
either the small the medium or the large
ones and this isn't particularly
important for the large ones because
they will run a long time so once we've
done that we need to set up the stage we
have to set up our test fixture and we
do that using a new API in the Android
testing support library called activity
test role and so you might have heard of
rules they're not a really new concept
they have been around a while enjoying
it for but they're essentially that this
nonsensical API you can use to create
reusable components which you can use in
all of your tests and they've reduced
boilerplate code and that's exactly what
we can see here so in order to use
activity tests rule the only thing that
you have to do is you have to create an
instance in a public field annotated
with the add rule annotation and then
what this will do is it will start the
activity before each test and will
finish it after after each test run
which is great and now we're we're
actually ready to exercise our UI and
here's how you do it with espresso if
you remember what I just showed you the
first thing that we want to do is we
want to click this button at the bottom
right of the screen so the way we do it
in espresso we ask a spresso to give us
the view for
responding at node ID from the current
view hierarchy and we do that by using a
with ID view matcher and espresso will
return us that view and then we want to
perform a click action on it an espresso
will get the view click on it and then
the add notes fragments will show up and
then we want to type a title enter
descriptions in the corresponding edit
text fields and again we use the same
entry point on view we use a with ID
matcher again to get ahold of the title
and description abuse from the view
hierarchy but this time we don't click
on it we just use a type text action to
type some text in the inner title and a
description and then we want to save the
note and this works pretty much the same
like the first step we get a whole of
the view using a with ID matcher and
then we perform a click action and the
last thing that we want to do is we want
to actually verify that the note that
we've just added to our model is
displayed on-screen and this time we're
going to do things a little bit
differently we use the on view method
but instead of matching a view by its ID
we can also use text and tell espresso
give me the view from the view hierarchy
which contains these text and then we
can use the check method to verify that
the view is actually displayed on-screen
so if you if you look at this this UI
flow it's not an easy UI flow but if you
look at the code it looks really easy
it's really readable and there's no
implementation details
there's no activities no fragments you
essentially don't have to deal with
those details anymore and and in fact
espresso only cares about views and
windows
that's all it cares about and it hides
most of the complexity and most of the
UI synchronization from you and now of
course you want to run your tests
um this works pretty much the same like
Jose showed you with the unit tests so
you can either right-click on a test
class and click on the play button or
you can also do it on a method level
from the test class but what this will
do is it'll create two apks for you a
test APK
and an app apk it'll deploy both of them
to your device and then the test apk
will instrument the app using
instrumentation and exercise its UI so
you can of course do this from Gradle
this is something that you wouldn't use
in your local development flow but it's
something that comes in very handy if
you actually run from a build server and
if you use as the I server which is
something that I think most of you guys
do anyways so and now at this point we
need to wire up our Android code with
our architecture right and the good news
about this is because we already
implemented all the logic in the
presenter our Android implementation
will be much simpler often it's just
setting some text on a text view field
and often it's very simple and the other
good thing is because we know that
everything already works because we have
the UI tests for the presenter this is a
great approach to attempt testing
general and combine the unit testing
with the UI testing and at one point
you'll actually go green your tests will
pass and then you will see something
like you can see your on the right and
I've been working on this since many
years now and I'm still fascinated if I
see those tests run on a device and you
should really try it out because it's
it's a lot of fun to write UI tests with
that presser so let me summarize
espresso gives you frictionless UI
testing espresso is really reliable you
will see that if you switch to espresso
if you start using it you will see your
test will be much more reliable they're
also more readable they're almost like a
UI spec so think about onboarding a new
member to your team you can just point
them to the test they can read through
the test they can almost figure out the
whole UI flow just from your test and
maybe they get excited when they see how
easy it is to write a UI test and it's
easier to onboard them to write to write
UI tests in the first place the last
thing I want to mention is espresso is
blazing fast
you do all the synchronization for you
and we know when to execute the next
view action immediately after the
previous one has finished and you will
you will immediately notice this if you
have a lot of tests and if you switch
over to espresso so to summarize the
spresso makes for non flaky tests and
you should really try it out because
it's amazing framework and it's a step
forward in UI testing on Android and
with that I'm very excited to have J to
talk about some of the newer stuff that
we've been working on because now that
we have all the low-level API is we
really want to take a smarter approach
to testing and we want to build the
higher-level tools which sits on the
low-level API is to enable more powerful
use cases cool thank you very much the
fun
so we've had Jose talking about unit
testing as the fundamental way we should
be testing our applications then we had
Stephan talking about integration into
eye tests being able to test the actual
Android part of application and as
you've probably all realized by now this
testing tool that my team have matured
quite a bit over the last few years so
now is the time to start thinking beyond
simply verifying the functionality of
our of our application let's think about
performance testing and this very much
sits at the top of our testing permit
you know we take advantage of all the
all the great testing tools and all the
platform features that are already out
there to build our performance tests so
performance testing today I'm sure many
of you have experiences yourself is very
painful traditionally you have a few
lower spec devices for example you have
a QA team that has access to those maybe
you have a slower network at home that
you just try to run the application and
see if it performs okay or if anything
is a bit slower than it should be and
the problem with that is you can't
really easily reproduce any of this it's
really hard for you to make tuna to
track trends to see how your application
is performing right and especially if
you're already or if you've automated
the rest of your tests already
why can't you automate our performance
tests and why can't you take advantage
of the existing tests that you have
already written for our for this
particular part let me introduce the
performance testing harness this is
actually power of a great code lab that
we've put together that I highly
encourage you to check out after our
talk the way this works is that we have
a new custom Gradle plugin that contains
a task that you can run which is used to
around your performance tests the trick
comes from a special test listener that
sits in your test apk the basic idea is
that we capture some additional
statistics and some additional log files
as you are executing the tests so for
example we can we can track the
rendering performance the Lochhead
output for each of the tests as you're
running it captured on the device copy
it back to your development development
machine and then do some analysis on it
the key part of this are some custom J
unit test rules that we have added
and Stefan talked about rules already
these allow you to add some additional
functionality to your existing tests so
here we have three rules the first one
basically runs the dancer's graphics
info command which you might have
already used if you've tried to track
down some jank issues in the application
it allows you to gather some statistics
on you know for example the number of
janky frames that you had and the
rendering performance you can do exactly
the same for the net stats command which
allows you to track your network
performance number of received and sent
packets for example and you can also
capture the logcat output individually
so just remember these rules are applied
to each test as it's being executed so
for each test we can now capture the
graphics performance Network performance
and the Lockett output and this is
pretty powerful and this is all being
executed through this new test listener
that gets added to our test apk on the
device and that's what we can capture
some additional statistics as well such
as a systrace output if you want to
track down in any other performance
issues this is what it looks like if
you're actually running it on if you're
actually running the test first of all
we have to run our new custom tasks run
local perf test and then as the test is
being executed our listener captures to
lock the locks for each of the tests in
our case we only had one test we have
executed here but you can see that for
each test we have now a locked file we
can go back to and then analyze further
and of course there's the systrace file
as well that gets captured for the
entire test run and this all happens
automatically for you and I think is
very powerful so here's an example where
our test actually failed and you can see
that we had an excessive number of janky
frames 91% and this is clearly a problem
this was one of our existing tests that
we had and he simply marked it as a perf
test and ran our test harness over it
and captures all these statistics so we
had 91% of janky frames janky frame
means that the the frame took longer to
render on the device so it appeared a
bit janky on the on the device so our
test failed instead of having to go back
getting the device out having to
reproduce it and trying to see what's
going on there we have captured all the
log files already we have the systrace
file there as well so we can go straight
back to the locks you have captured to
see what the problem was I made
fix it straightaway and this is a great
way to scale as the scale up your
performance testing if you think about
it just imagine where you can take it
from here right running it on one device
yeah that's okay you can probably
already do that but imagine scaling this
up and running this as part of you
continuous integration tests right what
if you can run all these performance
tests as part of your you know for each
commit or for each build that you're
creating and this is very powerful
because this now allows you to capture
statistics and trends as they develop
you might even be able to go back all
the way to one commit they introduced
ten performance issues that didn't come
up until later on so no longer you have
to rely on just simple manual
performance testing you can use our
testing harness to automate some of the
work for you and I would like you to
think about you know this is just the
beginning right there's so much more we
can do with this right now that our
testing tools have matured we can start
thinking about other ways we can test
and improve our performance and
applications you can look at battery
usage for example you can look at the
network performance as well this is very
much just the beginning so my point here
is really that we should now be starting
to think about smarter testing smarter
testing performance testing and then
many other ways we can we can automate
some of these some of you things we're
currently doing manually to build better
apps make it much easier for us to
verify and test our applications to
delight our users and give them a great
great experience as we work on our
applications with that I highly
encourage you to check out our code labs
they are great first of all the Android
testing code lab this is the one that
you've seen throughout this entire
presentation so we have a great code up
that we've put together that shows you
how we've used the MVP architecture
however using test-driven development
and how we have how we're doing the unit
testing and the UI testing in a great
concise application you can check this
out in the code lab area downstairs and
there online as well if you're more
curious about the automated performance
testing that I've talked about and you
want to see it in action and ever play
with it to see how you could use it to
actually track down a performance issue
check out the automated testing
automatic performance testing code lab
here are some amazing resources we've
put together the code labs are all
available
online for you to try out at home or
later on your laptop as well if you like
we also have some great samples out
there that show you everything from
basic unit testing to much more
complicated espresso testing so
definitely check this out on github we
also have a great project called the
Android testing blueprint and that shows
you how you can integrate many different
ways of testing into one great project
for example the unit and the UI testing
that you've seen today and of course we
have the ADSL the Android testing
support library that we've all been
working on so definitely check out our
check out the great documentation for
that as well and with that I would like
to thank you very much it's great to see
so many people interested in testing
here we'll be around in the office hours
area and we have stuff on joining the
Android tools panel the fireside chat
this afternoon as well so you can
definitely find us if you have any
questions and I think with that it's
time for lunch
so happy testing</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>