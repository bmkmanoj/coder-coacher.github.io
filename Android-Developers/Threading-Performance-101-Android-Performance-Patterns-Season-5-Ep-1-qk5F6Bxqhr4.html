<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Threading Performance 101. (Android Performance Patterns Season 5,  Ep. 1) | Coder Coacher - Coaching Coders</title><meta content="Threading Performance 101. (Android Performance Patterns Season 5,  Ep. 1) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Threading Performance 101. (Android Performance Patterns Season 5,  Ep. 1)</b></h2><h5 class="post__date">2016-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qk5F6Bxqhr4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">ah threading so powerful that you can
fold genomes with it but so difficult
that it can drive the average programmer
insane my name is Colt McAnlis and as
far as Android development is concerned
threading is one of the most important
and most confusing things that you can
deal with which means if you want to
write the fastest out possible you've
got to take a minute and understand the
subtle art that is multi-threaded
programming remember that in the vast
world of Android functions there's a
whole boatload of operations that only
execute on the main thread system events
input events application callback
services and even alarms and for the
most part any code that you write
execute inside one of these operations
which means it also runs on the right
main thread now if you recall work that
executes on the main thread gets there
after being pulled from the front of a
work queue so blocks of work are done in
order and the next block of work isn't
processed until the current one is
completed which means if there's a large
chunk of work between an input event and
its callback then the user will have to
wait longer than expected to see results
and don't forget that the main thread is
also where most of the screen rendering
occurs while an animation or screen
update is occurring the system will try
to draw the screen every 16 milliseconds
or so to achieve smooth 60 frames per
second the problem is that this is
happening while the thread is also
responding to app input events so if
your app is in the middle of an
animation and some random work packet
takes longer than expected you'll miss
your chance to render that next frame
within the 16 millisecond window and
that frame will be delayed this is what
we call a dropped frame and when this
happens users start to notice the direct
solution here is to move anything that
might upset the 16 millisecond window
over somewhere else like to a different
thread this way it won't be contesting
with the UI thread for work to be done
and won't be interrupting the drawing of
the screen which is the whole point of
threading on Android in a nutshell so
the question at hand what's the best way
to offload this work and how do you
choose what types of work to offload
thankfully the android framework has
provided a handful of classes to help
make this a bit easier for you for
example the async task class is ideal
for helping you get work on and off the
UI thread the right way handler threads
are great when you need a dedicated
thread for callbacks to land on thread
pools work best when you can break your
work up into really small packets and
then toss them to a bunch of threads and
intent services are really ideal for
background tasks or when you need to get
intent work off the UI thread and like
everything else there's not a silver
bullet here but knowing which primitive
is best for what situation can save you
a lot of headaches but note that having
all those fancy helper classes doesn't
hide the big problem memory see
threading and memory have never really
played well and on the Android platform
it's no different for example if you
declare one of those fancy threading
primitives inside of an activity it now
contains an implicit reference to the
outer activity which can cause a memory
leak if the activity is destroyed but
the threaded work is still alive or what
happens when the user rotates the device
destroying an activity that spawned a
bunch of threaded work I mean chances
are that those work packets would have
references back to various UI objects
that don't really exist anymore and the
truth is that the Android platform is
flooded with threads if you need a
reminder that grab a cyst rate capture
and check out all the cool stuff that's
going on underneath the hood that you
never really knew about see at the end
of the day threading is critical to
ensure high performance of your Android
app but there's lots of other problems
that you have to worry about as well
which is why you should check out the
rest of the Android performance patterns
videos and also don't forget to join our
Google+ community so you can ask
questions when you run into problems so
keep calm profile your code and always
remember perf matters</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>