<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Serialization performance (Android Performance Patterns Season 4 ep14) | Coder Coacher - Coaching Coders</title><meta content="Serialization performance (Android Performance Patterns Season 4 ep14) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Android-Developers/">Android Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Serialization performance (Android Performance Patterns Season 4 ep14)</b></h2><h5 class="post__date">2016-01-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IwxIIUypnTE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">data serialization is an important
aspect of every Android application but
when it comes to performance there's a
right and a wrong way to do it my name
is Colt McAnlis and your choice of
serialization provider and format can
have a huge impact on your apps
performance see at its core
serialization is the process of taking
some in-memory object and converting it
to a formatted chunk of data that can be
converted back to an in-memory object
sometime later and serialization is
everywhere from sending packets between
the server and the android device
sending data between two processes
storing user preferences to disk and
even simple stuff like passing the
current song information to the UI to be
displayed typically most Android
developers will default to the easiest
method to serialize their data namely
extending their class with the
serializable class but in terms of
performance you actually couldn't find a
worse solution to the problem
see built-in classes like serializable
and object output stream will work great
from a functionality perspective but
these approaches have significant memory
and encoding overhead making them
entirely too slow for the job at hand
for the sake of performance you're going
to want to avoid all of that chaos and
instead look at things like the json
library which produces much faster
serialization and more memory efficient
results although there's a large problem
with json in that it uses the json
format which is known to produce bloated
files see text-based poor formats like
JSON and XML tend to decode slower and
produce more verbose results the problem
at hand is that these formats are human
readable that means that there's lots of
overly verbose syntax that's added to
the file for the ease of readability and
use in addition these formats tend to be
extremely flexible meaning you can make
ordering changes or data changes easily
but again that comes to the cost of
needing extra data in the file that you
may not actually want to send it the
user by the way one quick note Android
resource files which are XML formatted
don't have any of these problems they
are compiled at Build time into a more
compact format that is more memory
efficient and faster to load so you
don't need to worry about any of those
so when it comes to serialization you're
going to want a fast codec that produces
the smallest file possible and lucky for
you we've got three great options
available first are
the Google protobufs library gets a lot
of recognition for being a very compact
flexible format for serialization
downside though is that the Java
implementation of the library has
significant memory and code size
overhead which isn't ideal for mobile or
developments which is why the nano proto
format was made now basically it's
protobufs but optimized for Android
development
so less memory allocations a smaller
number of method calls and just less
code overhead in general but of course
my personal favorite has to be the
flatbuffers library this format was
built by one of google's game
development focused teams and is focused
on performance in fact when it comes to
file size you can see that flatbuffers
produce smaller files than their
protobuf brethren and when it comes to
encode and decode times flatbuffers have
a huge advantage their overhead is
basically non-existent but the truth is
that sometimes the most performant
solution is to not use serialization at
all for example if you're trying to
store user preferences you shouldn't be
storing that as a serialized file
instead try using the shared preferences
API it's basically a fast key value
store and perfect for this type of data
same goes for passing data between
running processes serialization is still
the wrong answer here instead use the
parsable
api which gives you a slightly
serialized format but with a huge
performance boost and if you've got a
lot of structured data that you plan on
serializing don't the overhead of
walking those serialized objects not to
mention the time it takes to load them
is horrible compared to creating a local
database with the SQLite API see
everything in performance is about
understanding the caveats and choosing
the best options and trust me caveats
are everywhere which is why you should
watch the rest of our Android
performance patterns videos and don't
forget to join our Google+ community to
ask questions to other folks as well so
keep calm profile your code and always
remember perf matters
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>