<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ðŸ’¥ Angular Router Course Sample - Covers Angular Final Release | Coder Coacher - Coaching Coders</title><meta content="ðŸ’¥ Angular Router Course Sample - Covers Angular Final Release - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Angular-University/">Angular University</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ðŸ’¥ Angular Router Course Sample - Covers Angular Final Release</b></h2><h5 class="post__date">2016-09-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VES1eTNxi1s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone how's it going it's Vasco
from the angular diversity in this
lesson we are going to set up the
angular 2 router and we are going to
avoid a couple of huge pitfalls from the
beginning to give you an optimal angular
2 router learning experience it's coming
right up when setting up the router the
first thing that you want to define is
your base path you can do that using the
html5 based HTML tag and you should
point it to the entry point of your
application so in this case we are
pointing to this particular folder most
of the cases you will have a base of
slash meaning it's the entry point of
the server when configuring the router
what we are doing is depending on how
the URL changes certain sections of the
page will display a certain content we
call those sections outlets we are going
to define here the primary outlet of the
angular 2 router this means that in this
section of the page the content of this
tag will be replaced by a certain
component depending on the state of the
URL which sections of the page
correspond to which URLs that's where
the router configuration comes in let's
set up our router configuration so it's
just an array of route objects and each
one must define a path so in this case
we want a certain component to display
when we navigate to home and we are
going to display the home component in
order to be able to use the router the
first thing that we need to do is to set
it up in our application because it's
not included by default in angular so in
order to do so we need to go to the root
module of our application the app module
and we need to import the router module
but we should not simply import it we
should call this method for route and
pass it in the router configuration we
are going to understand why this for
route method is necessary in our lazy
loading and shared modules
right now this is the configuration that
we need to get things started if you now
try to access the route URL of our
application we're going to get an error
but this is normal because we only
configure the path to home not a path to
the root folder so we would think that
if we add home to the URL and we hit
refresh to reload the application that
this would work but we get a different
error we get a 404 not found from the
server this is a very common situation
for someone just starting with the
router and it's the main pitfall that we
mentioned in the beginning of this
lesson how to fix this and what's going
on exactly here so what's going on is
that when we modify the URL and we hit
enter we are actually triggering a full
page reload from the server so we are
not modified the URL using the history
API when we modify the URL manually and
we hit enter this is going to trigger a
request to the server to lower the file
named home without an extension this
file does not exist so we get back a 404
to avoid this problem what we need to do
is to configure our server so that any
and matched requests will return the
index dot HTML file that contains our
single page application so slash home
should return this as the HTTP response
the index dot HTML file then angular
will bootstrap itself the router will
kick in inspect the URL and take us to
the home path let's apply this logic to
our concrete case of our node.js Express
server so we simply need to create an
express middleware that redirects us to
the index dot HTML file if the request
was not matched by any of the previous
routes that we configured we will see in
a second a better way of doing this but
let's try this out so if we type in here
an unmatched path we get redirected to
index dot HTML and this file contains
our single page application our
application kicks in and angular takes
over from there but this situation is
tae-il because we created a redirect
there's a better way which is to
configure the server to do instead of a
redirect to return directly the index
dot HTML file so if we do that in
express using response dot send file we
are going to get back directly index dot
HTML which is our single page
application angular 2 kicks in the
Rooter kicks in and notices I should be
displaying slash home so it's going to
look up the router configuration to see
which component corresponds to slash
home and it's going to display the home
component I really advise you to
configure your server this way from the
beginning in order to get a good
development experience with the router
otherwise you will just get 404 all the
time now one last trick which is we can
enable debug information in the router
we do that via the enable tracing
property then with this you are all set
up to further explore the router we are
going to explore shell routes auxiliary
routes and we are going to explain why
does that contribute for a much better
user experience and allow us to more
easily build much more modern and
dynamic applications so let's continue
our deep dive in the router next step
router navigation hello everybody and
welcome
it's Vasco here from the angular
University and in this lesson we are
going to learn about the router link
directive learn a couple of different
ways to use it there's more than one and
we're going to see how it can actually
be applied to different elements on the
page not only links it's coming right up
to start let's configure a few more
routes in our application by the way our
application is a small elearning system
where we will have a list of courses we
click on it we can see the lessons so
it's a small elearning platform in this
section of the router we are just simply
going to focus on the routing but in an
upcoming section we are going to build
the whole application including the
back end we're going to use firebase so
let's get started let's first configure
a couple of extra routes we are going to
configure besides the Home route we are
going to configure the courses route we
are going to show the courses component
and the lessons routes where we are
going to show the all lessons component
let's give this configuration a quick
try so if we type in the URL home we get
displayed a home component now let's try
it with courses this is the courses
component containing just a list of
courses and this is the lessons route
where we have a list of all the lessons
available this confirms that the routing
configuration is working now what we
want to do is to create a top menu where
we can click in one entry and navigate
directly to that section so let's do
that using the router link directive
let's start by applying router link to
an anchor tag so we can apply it by
simply passing the path to which we want
to navigate the angular2 router path
that is so the directive will cancel the
navigation that is associated to a
normal anchor HTML element and it will
instead trigger the router let's
configure another menu entry like this
and let's show another way of using
router link you can also pass it in an
expression you are not forced to pass it
a string so if you pass it an expression
you should pass it an array containing
the different paths to which you want to
navigate in this case we want to
navigate to the lessons path the router
link directive is not only meant for
anchor elements you can apply it
actually to any element on the page so
let's apply it to the home icon what
happens here is that the click on the
element will be detected and in response
to the click the route will be triggered
notice here that in this component we
have included in its directives array
the router directives without this
router link will not work also any other
routing directive would not work without
this so this is already a good start you
have an applet
you have a couple of routes configured
you have a menu what you want to do from
the beginning in an application is to
configure a fallback route and also a
default home route we are going to see
how to do this in the upcoming lesson
hello everyone and welcome
Vasko here from the angular university
and in this lesson we are going to learn
how to set up an index route and a
fallback route for our application and
why that is important it's coming right
up so let's start with the index route
whenever you go to the root of your
application you probably want to display
something to the user but with our
current configuration that is not the
case because the root route or the index
route does not get associated or it's
not matched with any of the routes that
we have currently configured so let's
add some configuration to it let's add
it an index route and we're going to
give it an empty path we are also going
to give it the home component in an
upcoming lesson we are going to see how
we could have done this in another way
let's try this out so if we access the
route URL of our application we get
displayed the home component which is
the expected behavior now what happens
if we type some other URL that is not
mapped to any route what is the current
behavior what happens is that we get an
error in the console saying that we
could not find that match for this URL
in the route configuration if you want a
better user experience we can redirect
the user to for example the home
component for that we need to configure
a fallback route so let's do that the
path of the fallback route is the double
star wildcard and this is going to match
all URLs we are going to give it for the
moment the all lessons component let's
try this out if we now type an unknown
URL we should be redirected to the
always sense component and that is the
case let's now just make the fallback
component the home component
instead of all lessons now what we might
not have noticed before is that in the
routing configuration the order matters
your that is very important so let's say
that for example we take the fallback
route and we put it as the first item in
our configuration let's try this out if
we now click around the same links that
were working before we can see that
everything is being redirected to the
home component that's because the routes
are searched for a match in the order in
which they are defined and so the first
match is always the fallback route so
make sure that you always put the
fallback route as the last entry in your
configuration and so a relative
configuration is now at a good starting
point you might have noticed that when
we click around the top menu that the
current menu gets highlighted in red how
did we do that that we're going to find
out in the next lesson hello everyone
and welcome this is Vasco from the
angular diversity and in this lesson we
are going to learn about angular to
child routes as part of our router
course so let's get started shell rods
allow us to navigate deeper into our
application the key thing to realize
about shell rods is that only one shell
trout can be active at a time and this
might sound familiar to you take a look
at this free top-level route so home
courses and lessons also these free
routes are only active one at a time
so we could also see our application as
having one main entry route let's say
the empty path route and that empty
route has free child routes each can
only be active once at a time so this
would be an alternative way of
configuring our application let's try
this new configuration so as you can see
the application still works exactly as
before let's now give a more common
example of the use of a shell trout
let's say for example the route courses
typically we would want a shelter out of
it to show the
details of a given course so in the URL
we will type slash courses slash one or
two so we will type the ID of the course
something that uniquely identifies the
course let's configure this we can
actually configure something similar to
this scenario even without using shell
routes so let's for example configure a
route course notice that its course and
not courses course / : ID and then we
map it to course detail to the course
detail component let's try this out if
we now type slash course slash and then
a number let's say that's the idea of a
course we can see that the course detail
component is being displayed to the user
another way of doing this configuration
is via the use of shell routes so under
the path courses we typically have the
route path where we have the list of
courses and then we have a shell route
with the detail of each course well we
only want either the summary route or
the detail route to be active at each
time and never both so this is the ideal
scenario for using a shell route for
this let's make courses a component less
route this means that the route is there
for routing matching purposes but the
route itself does not instantiate a
component now we are going to configure
two shell routes for the courses route
the empty path route which corresponds
to the courses component the component
that shows the list of courses and paths
with the ID of the course this
corresponds to the course detail again
only one of these two will be active at
a given time let's try this out if we
reload the application and go to the
path courses we still have the courses
list being loaded as expected and now if
we type manually in the URL
courses slash and then we give it an ID
we are going to be forwarded to the
course detail route like we expected you
might have noticed that this file is
starting to contain a lot of routing
configuration so it's a best practice to
split the router configuration
across multiple files so let's create a
new routing configuration file courses
router config and we are going to copy
it in the definition of all the routes
that relate to courses we are then going
to import it in the main configuration
file and we are going to include it by
using the array spread operator we are
getting deeper into routing and this is
only the beginning so be sure to watch
the following lessons for learning what
is an auxiliary route and we are going
to do the exercise at the end of the
course where we are going to build a
complete dashboard so stay tuned for the
upcoming lessons how's it going it's
Vasco from the angular University and in
this lesson we are going to explain in
detail auxiliary routes in the angular 2
router it's coming right up so first of
all what is the use case for auxiliary
routes let's give an example for example
we go here to the courses screen we
would like when the user clicks in an
item in the courses list we would like a
playlist to be displayed here in the
right-hand side of the page this
playlist is a section of the page that
might contain different content
depending on where we navigate in the
application now we could definitely add
the playlist as a component inside the
courses component right that would be a
solution but imagine that this section
of the page will always be filled in
with a certain playlist no matter where
you navigate in the application so here
in the courses screen it's showing the
playlist of lessons of a given course
but in the lessons route it might
display something else so the lessons
route contains a list of the latest
lessons well the playlist might display
in that case the list of the most
frequently viewed lessons in other words
we want this section of the page to
behave like if it was a mini browser
window with its own navigation URL
separate from the main URL so that when
you go back
and forth to a given route we can match
it to a different component if you find
yourself in this situation where you
have multiple regions of the page that
you want them to react differently to
the URL let's say dialog boxes for
editing forums or the left-side menu
that you want to adjust each time that
you navigate this is a good case for an
auxiliary route okay so then let's
configure a route an auxiliary route for
the playlist so we are going to use the
playlist path and when that path is
routed - we are going to associate it to
the playlist component now we are going
to mark this as an auxiliary route by
filling in the outlet attribute we are
going to call this outlet playlist now
to which section of the page does this
outlet correspond to we are going to
configure that by having a second router
outlet tag to the page with the name
playlist so the only difference between
an auxiliary route and the standard
primary route is that it must have a
name the default route does not have a
name by definition and it has its own
separate outlet which specifies the
section on the page to which the routing
is going to be applied well you must be
thinking then how do we access this
route using just the URL let's find out
so if we access this page we are going
to see that there is nothing in the
playlist section because we have not
routed to it in our URL we only specify
that we want the primary route to
display the home component but we did
not mention anything about the secondary
route and how could we do that because
after all there is only one URL in the
browser window right how can we specify
the second URL of the auxiliary route
angular provides a special syntax for
that so here inside parentheses we are
going to say first which outlet we want
to route to we're going to say it's the
playlist outlet now we add a
and after that we are going to add the
URL of that outlet to which we want to
route to and it's as simple as that if
we try this out now we can see that the
playlist is being displayed as expected
let's give another example let's say
that when we are routing to the playlist
path inside the playlist outlet we want
to display let's say completely
different component the course is
component let's try this out
if we now that we get to playlist - path
inside the playlist outlet we're going
to see again the courses component so
this shows that this outlet really has
its own separate routing configuration
where there is a separate URL one key
thing to understand about auxiliary
routes is that they are just plain
routes so they have all the properties
of a standard primary route you can
define shell routes etc you can nest
them one inside the other it's really
like you have a different section of the
page with a completely separate URL to
which you can provide a completely
different routing configuration we are
going to go deeper in this course in
auxiliary routes this is just beginning
actually in the end of this course we
are going to use auxiliary routes
extensively to build a dashboard with
multiple auxiliary routes next up we are
going to see auxiliary route parameters
hello everyone how's it going it's Vasko
from the angular university and in this
lesson we are going to learn about one
of the most useful features of the
angular 2 router lazy loading it's
coming right up so what is lazy loading
and why is it useful imagine this
situation you have an application that
grows in size over time you will
eventually get to size in your
application where your startup time
takes a long time and that causes a user
experience issue when your application
grows beyond a certain scale what we
want to do is you want to split it up
into multiple
so that not everything needs to be
loaded at once at startup time take for
example this small application imagine
that it's a very large application
actually for example we would only want
to lower the courses functionality if
the user clicks for the first time on
the courses menu like that we don't have
to serve all the functionality related
to courses at application startup this
will reduce the application startup time
and it would improve the user experience
let's give a concrete example let's
extract the courses functionality and
put it in a lazy loaded module and let's
see what that means in practice at
runtime so you can see here that the
root module of our application the
application module is importing the
courses module let's take a look at this
module so it contains all the courses
related functionality such as the
courses courses list and course detail
component and we can see that the common
module is being imported so this is a
normal feature module that is being
loaded together with the rest of the
application so what we are going to do
now is we are going to configure the
router to lazy load this module the
courses module so the first thing that
we need to do is to remove the import of
the common module from our application
root module this way there is no
reference between our application and
this common module the second step for
making a module lazy loaded is to
configure the router to do so so we need
to go here to the Rooter configuration
and we need to remove all the routing
configuration that relates to courses in
place of this configuration we are
simply going to configure the following
if any URL starting with courses is hit
we are going to load this module and via
the property lowered children we are
going to point to the courses module
file next we want to take the routing
configuration which is
cific of courses and for the moment we
are going to define it in a route config
variable inside the courses module file
what we want to do also is to take any
services or any injectables that were
specific of the courses functionality
and will only be used by the courses
functionality we want to take them out
of the providers of the route module and
we want to move it to the providers of
the courses module be sure to see the
next lesson on share modules and lazy
loading because this will not always be
the way that you want to do this but
these two route cards are specific of
the courses functionality so it's okay
to put them here in the courses module
so there we have it we have everything
set up so let's see lazy loading in
action let's try this out so if we now
look at the application only the
functionality related to home and
lessons to these two menu options with
LowE with it if we now hit the courses
menu we are going to trigger the lazy
loading of the courses module so let's
inspect the network tab and see this in
action as you can see only when we click
courses is the courses module loaded and
then the components of the courses
module follow but we can also see here
that there is an error in the console
let's inspect it so we have here the
error message cannot find default in the
lazy loaded module so what is the cause
of this remember when we configure this
module to be lazy loaded via load
children we only define the name of a
file but a file might have multiple
exports there could be multiple
constants classes etc defined as exports
in the same file so this error means
that the file was found and it was
loaded but we don't know which export of
this file to take into consideration to
fix this we need to mark the courses
module with the default keyword this
will make it the default export of this
so let's now try this out to see if it's
working if we try this out we can see
that we get a different error here what
happens is that the courses module
functionality does not know the router
link directive so even though we have
imported the routing directives in our
application module this does not mean
that a module that gets imported by the
application module also knows the same
set of directives that's why for example
we had to import common module inside
the courses module to recognize standard
directives so this means that we also
need to import the routing directives
inside the courses module also we need
to pass in the routing configuration for
the courses functionality you'll notice
that the variable is still unused so in
order to do both of these things we are
going to call router module for shell
and inside we're going to pass in the
routing configuration for the courses
functionality
what for shell will do is that it will
add this configuration to the already
existing application configuration
without overwriting it if we now try
this out we are going to run into a
difference issue let's take a look at
the error message it says if lessons
list is a web component etc so this
means that lessons list is not known
inside the courses module as a component
because we have not yet added it to its
declarations let's now do that and see
what happens if we now try this out we
can see that we get another error and
this time the error says type lessons
list is part of Declaration in two
modules this is because we have added
lessons list both to the root
application module and to the courses
feature module and one component can
only belong to one module so how can we
solve this what we need is a shared
module that contains components that are
used by multiple modules of the
application to fix this last problem
with
living set up we need to start by
removing lessons list from probe the
application module and the courses
module we are going to create a new
module shared module we're going to do
that in a separate file we're going to
simply annotate it also with ng module
the shared module is simply a feature
module like we saw before that contains
one component lessons list in order to
use it we need to import it both in our
application route module and in our
courses module which is glazy loaded
we now have everything in place for lazy
loading to work so let's see it in
action if we refresh the application and
we now hit the courses menu we can see
that the courses module and all its
components are being correctly lazy
loaded let's confirm that everything is
working correctly using the dev tools so
if we inspect the network tab we can see
that the courses module is only lazy
loaded when we click on the courses menu
and also we have no errors on the
console and so here we have it lazy
loading in action there is one final
pitfall that concerns shared modules and
the Declaration of services inside them
and lazy loading in general and we are
going to cover that in the next lesson</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>