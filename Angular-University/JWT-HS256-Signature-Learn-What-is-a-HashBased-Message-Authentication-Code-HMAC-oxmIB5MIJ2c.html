<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ðŸ’¥ JWT HS256 Signature - Learn What is a Hash-Based Message Authentication Code (HMAC) | Coder Coacher - Coaching Coders</title><meta content="ðŸ’¥ JWT HS256 Signature - Learn What is a Hash-Based Message Authentication Code (HMAC) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Angular-University/">Angular University</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ðŸ’¥ JWT HS256 Signature - Learn What is a Hash-Based Message Authentication Code (HMAC)</b></h2><h5 class="post__date">2017-09-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oxmIB5MIJ2c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone and welcome back let's
talk about the two different ways that
we have for signing payloads of JSON web
tokens what's the difference between
both and which one should we choose for
our application now let's have a look
here at our first example so this is
creating here at JSON web token and it's
doing so using the default algorithm
which is HS 256 this means that the
signature of the JSON web token will be
produced using the share 256 H max
algorithm to understand how these
signing mechanism works let's start by
creating a JSON web token so we are
going to do NPM run and then we are
going to run this example
JWT - HS 256 this is the signature
mechanism that we will be covering in
this lesson and here we have it we have
our JSON web token which has this
payload here and it has been signed with
this secret key to prove that this is a
valid JSON web token and better
understand how this type of signature
works let's copy-paste this complete
string and switch over here to the
browser to JWT dot IO so we are going to
paste in here our JSON web token so as
you can see this has been decoded we can
see here the Heather the payload and the
signature is still marked as invalid now
if we type in here in this box the
correct password the signature has been
verified so this is a valid JSON web
token let's now talk about how this
signature here the first part of the
JSON web token was produced so this is
what is called a hash based message
authentication code or age mac for short
and we are going to go over what is
exactly a Mac code the goal of the Mac
code is to prove that the message is
authentic meaning that it was sent by
who we think it was sent that's what the
signature which is the third part of the
JSON web token
the signature is a Mac code how is it
produced we're going to take the payload
and we're going to take a secret key we
are going to hash everything together
using a hashing function such as for
example share 256 the result of that
operation which is the hash output is
the message of indication code itself so
the idea is that we are going to send
the message and together with the
message we are going to send the message
authentication code and that's exactly
what we are doing with JSON web tokens
so the payload part is the data and the
signature part is the message of
indication code the receiving party is
going to validate the content of the
message in the following way it's going
to take the data which is an encrypted
it's going to take the secret key that
it also possesses on its side and it's
going to hash everything together again
trying to reproduce the same hash output
again the goal is to check if the
message received is indeed correct and
to confirm that it was sent by someone
in possession of the private secret that
was previously shared between the two
parties so if we manage to take the
payload take the secret key we hash
everything together and we obtain the
same message authentication code this
proves that the message is correct
because this message authentication code
could only have been produced by someone
in possession of the secret key if we
assume that the key was not lost then we
can safely assume that this message is
indeed correct and it was indeed
produced by the sender this information
could not have been modified by a third
party that does not have the secret key
only someone in possession of the secret
key could have produced this message
authentication code so this code proves
that the message is indeed correct so
this explains why a JSON web token is a
self validating token this means that we
only have to look at the token to make
sure that the token is correct we only
have to inspect the signature and
validate the message
of indication coal we don't have to
contact a third-party service to make
sure that the token is correct and we
don't have to keep it in memory between
requests those are two key advantages of
JSON web tokens now let's see how do we
verify a JSON web token in practice we
are going to copy this string and we're
going to switch over here to this second
example file so it's called GWT check a
J's 256 because it's based on the share
256 algorithm and here we are going to
paste the jason web token the complete
JSON web token that we have taken from
the browser we are going to put in here
the secret key correctly so remember
this JSON web token is the same that we
generated here using this file here this
is the file that we have used to
generate a new JSON web token we took it
and we have copied here so now we are
the receiving party that has received
the JSON web token and we would like to
validate that the JSON web token is
indeed correct so we don't want to write
code that takes the signature here and
validates the payload the library
already provides us a solution for that
so we just need to use the JSON web
token library we pass to the verify
method two arguments one is the complete
JSON web token with all three parts that
we want to verify if it's correct and
the second argument is the secret key
let's see what we receive on the screen
as we print out the output so if we head
over to the terminal we are going to do
NPM run and then we are going to pass in
the same name as the file GWT check ages
256 without the Jas extension so as you
can see we did not receive any error on
the screen and the output of calling
verify is the payload as we can see at
this point we have simulated the typical
interaction between the sender and
receiver the sender produced the JSON
web token using the secret key and here
we have verified
using the same key what would happen if
we would not have the key at the
receiving sale or we had the wrong key
or a key that has been meanwhile changed
let's have a look we're going to run
again the same program so as you can see
this time around and never here was
flown so we would have to catch it and
handle it and this is essentially how
the HS 256 JSON web token signature
mechanism works we have covered a lot of
ground in this lesson let's switch over
to the browser and summarize so these in
summary is how this particular type of
signature HS 256 works in JSON web
tokens we simply take the payload we
hash it together with the secret key
produce a message authentication code
and append it to the message the
receiver can be sure that the message is
indeed correct this is because the
message authentication code allows the
receiver to make sure that this was
indeed the payload sent by someone in
possession of the secret key the message
is not encrypted meaning that it can be
read by an attacker but an attacker
without the secret key has no way of
forging its own messages now this is
only one of two mechanisms we have here
a second mechanism called RS 256 this is
the signature mechanism that we will be
using to implement our server and it has
a couple of advantages over HS 256 in
order to understand them let's talk
about a potential limitation of the HS
256 signature mechanism there is one
fundamental problem with HS 256 both the
sender and the receiver must have
exchanged beforehand the secret key this
means that the secret key is needed in
many places in the sender and in the
multiple receivers everyone has to have
that key installed on their system so
more places where the key could be
stolen and potentially misused also this
means that if we want to change the
secret key we need to change it
everywhere
with all the parties involved that might
mean coordinated downtime where all the
parties agree that at a certain time the
keys will be swapped it might mean
temporary service and availability and
all of that is inconvenient RS 256 that
we are going to cover next solves all
these problems</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>