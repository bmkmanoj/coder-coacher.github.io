<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ðŸ’¥ Angular Tutorial - The Complete Angular With Typescript Course - Sample Lessons | Coder Coacher - Coaching Coders</title><meta content="ðŸ’¥ Angular Tutorial - The Complete Angular With Typescript Course - Sample Lessons - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Angular-University/">Angular University</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ðŸ’¥ Angular Tutorial - The Complete Angular With Typescript Course - Sample Lessons</b></h2><h5 class="post__date">2016-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ahb9XOHSr9k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is an extended preview of my the
complete angular 2 with typescript
course in the next hour I'm going to
guide you through angular 2 components
and directives we are going to learn
together the angular 2 router and we are
going to learn how to build complex
forms with the angular 2 forms module we
are going to learn how to handle the
data of our application using rxjs
observables and the new angular 2 HTTP
module and without further ado let's get
started
hello everybody Vasco here from the
angular Academy we are going to see how
to pass input data to a component and
even if you are already aware of this
you might not know how to pass in a
string a simplified way to pass in a
string property into a component coming
right up so we have here our search box
component let's add it an input property
in this case we want to configure what
the placeholder text will say instead of
search so for that we use the square
brackets notation to pass in a property
into the component now we assigned to
the text property we are going to assign
a string notice the quotes around the
string without this this will not work
now we are going to declare the property
in the component using the add input
decorator we annotate a property name
text using the add input decorator and
it's all we need to pass in an input
variable to the component now what we
want to do is to use the value of the
text variable in the component template
in this case we are going to use the
interpolation syntax so double curly
braces right now we just use it to
output the placeholder value into the
template if we now try this out we can
see that type your search is now
displayed in place of the placeholder
now
that tip that I mentioned in the
beginning of the lesson this is a very
common scenario we just want to pass in
a constant string as an input to the
controller this variable input will not
be variable it will never change for
this there is a simplified syntax where
we can actually remove the square
brackets from around the text property
and we can remove the quotes from the
string and like that we have a
simplified way to pass in a string as a
constant value for a component input
next we are going to see how we can
subscribe to a component to receive an
output event that it generates how can
we receive data from the component stay
tuned
hello everyone how's it going Vasco here
from the angular Academy this lesson we
are going to learn the template syntax
for events we are going to learn how
components can output custom events
coming right up
what we want to do here is to add a
click handler to the Clear button so
when the user typed something in the
search box and click clear that value is
erased to do that let's add a click
handler using the parantesis syntax so
inside the parentheses we can specify
the event to which we want to respond in
this case the click event this could be
Mouse down mouse up mouse over keydown
keyup or any standard Dom event in order
to clear the input box we are going to
pass it as a reference inside the clear
method for that we need to give it a
name and we can do that using the hash
tags intact so hash tag box assigns the
name box to the input to clear the value
of the input we just assign the empty
string value to the input box let's see
this in action if we type something in
the search box and we now click clear
the value is deleted now let's say that
our component search box has an output
event called search which is the content
of the
search box whenever the user types on it
and presses enter other components that
are interested in receiving the latest
search will subscribe to this custom
event to create custom events we need an
output event emitter we can create one
in our component by creating an event
emitter instance and annotating it with
at output decorator now let's start by
detecting when a new search is available
to implement this
let's start by detecting the keydown
event on the input box and specifically
the enter key and remember this syntax
because we are going to need it in an
upcoming exercise now when the user
clicks enter while typing on the input
box we are going to trigger an Unser's
method and we are going to pass it in
the value of the input box for the
moment let's just output it to an alert
box to see this in action if we now type
something in the search box and press
ENTER then the alert box will be
displayed what we want to do now is
instead of showing an alert box we want
to generate an output event for that we
simply use the emit method of event
emitter and we pass it in the value of
the new search now a component that is
interested in subscribing to this output
event will use the same syntax used for
Dom events so with parentheses we are
going to subscribe to the search output
event and the name of the event is
determined by the name of the output
event emitter property let's add an
event handler to the search event when a
new search is available we are going to
trigger the Unser's method and we are
going to pass it in the value of the
last search and we have it available in
dollar event dollar event contains
whatever we have passed to the event
when we triggered it via the emit method
to see this in action let's simply take
the output of
Custom Search event and output it to an
alert box so the alert box will contain
the value of the search when the user
pressed enter now this is the tip that
we mentioned in the beginning of the
lesson take a look at this syntax in
typescript with backticks
and strings this is called a string
literal and we can output variables in
the body of the string using the dollar
curly brace syntax if we now type on the
search box and click enter we can see
that the output of the search box shows
in the alert box as expected we now know
how to handle events in angular 2 and
how to create our own custom events next
we are going to see how we can organize
our component templates how can we add
CSS styles to the component and we are
going to see a larger example with a
more complex component tree everything
coming right up hello how's it going
it's Vasko from the angular university
and in this lesson we are going to learn
how to build our own custom angular 2
directive it's coming right up so you
might have noticed while coding in plain
HTML that there are certain attributes
that we add to elements that add or
remove existing functionality to those
elements such as for example the
required attribute that marks an input
field as mandatory in a form in this
lesson we are going to learn how to
build such a custom directive again
extending the standard functionality of
plain HTML with our own custom
functionality this is what angular allow
us to do the custom attribute directive
that we are about to create is the
collapse on click directive whenever we
apply it to an element on that page that
element once it's clicked will disappear
from the screen so this is just an
example and the directive can be applied
to any element on the page
including two angular 2 components a
directive in angular is simply a plain
JavaScript class annotated with the ED
directive decorator in there we're going
to pass it a selector and notice the
square brackets this means that the
directive should be applied to any HTML
element on the page that has a collapse
on click attribute it is a best practice
in the case of attribute directives to
always use attribute selectors instead
of for example element selectors like we
do so for the case of components please
be sure to check the end of this section
for the exercise where we're going to
present an implementation of collapsible
that uses more features right now we are
simply going to define a CSS selector
that says the following any collapsible
section inside the collapsed element
should not be displayed on the screen so
display:none be sure to check the
section on ng if so this directive will
work in the following way we need to
detect clicks on the element on which
the directive is applied to and that is
known as its host element the directives
host element in this case it's this div
with the CSS classes of card and card
strong next what we want to do is
whenever that click occurs we want to
add or remove a collapsed class to the
host element and that will trigger the
appearance or disappearance of the
collapsible panel let's see how to do
this let's first create a is collapsed
private variable in the collapse
unclicks directive and what we are going
to do is whenever a click event occurs
in the host element so we are going to
use the add host listener decorator to
detect events in the host element
whenever a click occurs we are going to
toggle the value of the private variable
is collapsed which has a default initial
value of false what we want to do now is
add the collapsed CSS class
to the host element depending on the
value of the is collapsed private
variable for that we are going to use
the host binding decorator the host
binding decorator allow us to write two
properties of the host element so in
this case what we want to do is we want
to set the property class not collapsed
in case that the property is collapsed
of the directive is set to true so let's
now see our first custom directive in
action for the first time if we now
inspect the HTML we can see that for
example when we click on the dispatch
section is collapsible text whenever we
click on it the CSS class collapsed is
either added or removed from the host
element where the directive was applied
as we can see directives have the
potential of giving us more useable
functionality compared to components any
functionality that we have in a
directive we can add potentially to any
component but directives are really not
that different from components let's
have a look why in the next section
hello everybody welcome this is Haskell
from the angular University and in this
lesson we are going to learn that
components are actually just simply
directives that's right a component is
nothing more than a directive all the
functionality that you learn about
components so far like being able to
pass them inputs receive outputs all of
that functionality is also applicable to
directives let's have a look at this in
action for example in our collapse on
click directive let's pass it in an
input property collapsed we can use this
for example to initially set the
collapsed state of an element directives
just like components also support output
events for example in this collapse on
click directive we can subscribe to
let's say a collapsed event and trigger
an on toggle method whenever the event
occurs just like in a component
in order to implement is just like in
the case of components we simply use an
event emitter inside the directive so
we're going to create a collapsed output
event emitter and whenever a click
occurs we're going to emit a new event
notice that inside the output decorator
we have specified the name of the event
in the directive API to which the user
can subscribe to in this case the name
of the event is collapsed and not
collapsed output which is the name of
the event emitter if we now try this out
we can see that everything is working as
expected so whenever we click the panel
we can see that the panel is being
toggled collapsed or expanded and that
logging statements are showing on the
screen we are going now to present a new
feature of directives which also applies
to components which is the ability of
the directive to export itself into the
template on which it's being used under
the form of a name so for example the
collapse unclick directive we would like
to get a reference to it we are going to
assign it the collapsible template
reference this comes from inside the
directive as we will see in a moment we
can use this reference collapsible
directly in our template in order for
example to add a CSS class collapsed if
the boolean flag collapsed is set to
true we can set up the collapsible
reference in our directive by using the
export as property of the directive
decorator in this case we're saying that
export is collapsible so export this
directive under the template reference
name collapsible you can see why would
this would be useful it's in situations
where you have multiple directives
applied to the same element which could
be an angular 2 component or a plain
HTML element a standard browser element
this would allow us to have three or
four directives applied to the same
element each one having its own
functionality and we would still be able
to directly access those directives and
their public API in our template if we
so wanted and so here we have it our
first angular 2 custom directive angular
2 also comes with a lot of directives
out of the box we are going to explore
what is available to us in terms of
standard directives in the following
sections then we're going to do a more
complex example to put everything that
we have learned in practice together and
after that we are going to do an
exercise where we are going to improve
this directive the collapse on click
directive so stay tuned hello everyone
how's it going it's Vasco from the
angular University in this lesson we are
going to setup the angular 2 router and
we are going to avoid a couple of huge
pitfalls from the beginning to give you
an optimal angular 2 router learning
experience we're going to set up routing
debugging information from the beginning
as well it's coming right up when
setting up the router the first thing
that you want to define is your base
path you can do that using the html5
based HTML tag and you should point it
to the entry point of your application
so in this case we are pointing to this
particular folder most of the cases you
will have a base of slash meaning it's
the entry point of the server when
configuring the router what we're doing
is depending on how the URL changes
certain sections of the page will
display a certain content we call those
sections outlets we are going to define
here the primary outlet of the angular 2
router this means that in this section
of the page the content of this tag will
be replaced by a certain component
depending on the state of the URL which
sections of the page correspond to which
URLs that's where the router
configuration comes in let's set up our
router configuration so it's just an
array of Route object
and each one must define a path so in
this case we want a certain component to
the display when we navigate to home and
we are going to display the home
component in order to make the router
work we need to configure the angular 2
dependency injection system with the
routing injectibles so for that we use
provide router and we pass it in the
router configuration that we just
created if you now try to access the
root URL of our application we're going
to get an error but this is normal
because we only configure the path to
home not a path to the root folder so we
would think that if we add home to the
URL and we hit refresh to reload the
application that this would work but we
get a different error we get a 404 not
found from the server this is a very
common situation for someone just
starting with the router and it's the
main pitfall that we mentioned in the
beginning of this lesson how to fix this
and what's going on exactly here so
what's going on is that when we modify
the URL and we hit Enter
we are actually triggering a full page
reload from the server so we are not
modifying the URL using the history API
when we modify the URL manually and we
hit enter this is going to trigger a
request to the server to lower the file
named home without an extension this
file does not exist so we get back a 404
to avoid this problem what we need to do
is to configure our server so that any
unmatched request will return the index
dot HTML file that contains our single
page application so slash home should
return this as the HTTP response the
index dot HTML file then angular will
bootstrap itself the router will kick in
inspect the URL and take us to the home
path let's apply this logic to our
concrete case of our node.js Express
server so we simply need to create an
express middleware that redirects us to
the index dot HTML file if the request
was not
by any of the previous routes that we
configured we will see in a second a
better way of doing this but let's try
this out so if we type in here an
unmatched path we get redirected to
index dot HTML and this file contains
our single page application our
application kicks in and angular takes
over from there but this situation is
not ideal because we created a redirect
there's a better way which is to
configure the server to do instead of a
redirect to return directly the index
dot HTML file so if we do that in
express using response dot send file we
are going to get back directly index dot
HTML which is our single page
application angular 2 kicks in the
Rooter kicks in and notices I should be
displaying slash home so it's going to
look up the router configuration to see
which component corresponds to slash
home and it's going to display the home
component I really advise you to
configure your server this way from the
beginning in order to get a good
development experience with the router
otherwise you will just get 404 all the
time now one last trick which is we can
enable debug information in the router
we do that via the enable tracing
property then with this you are all set
up to further explore the router we are
going to explore shell routes auxiliary
routes and we are going to explain why
does that contribute for a much better
user experience and allows to more
easily build much more modern and
dynamic applications so let's continue
our deep dive in the router next step
router navigation
hello everyone and welcome this is Vasco
from the angular diversity and in this
lesson we are going to learn about
angular 2 shell droughts as part of our
router course so let's get started
shell rods allow us to navigate deeper
into our application the key thing to
realize about shell rods is that only
one shell drought can be active at a
time and this might sound familiar to
you take a look at this free top level
route so home courses and lessons also
these free routes are only active one at
a time so we could also see our
application as having one main entry
route let's say the empty path route and
that empty route has free child routes
each can only be active once at a time
so this would be an alternative way of
configuring our application let's try
this new configuration so as you can see
the application still works exactly as
before let's now give a more common
example of the use of a shell route
let's say for example the route courses
typically we would want a shell route of
it to show the details of a given course
so in the URL we would type slash
courses slash one or two so we would
type the ID of the course something that
uniquely identifies the course let's
configure this we can actually configure
something similar to this scenario even
without using shell routes so let's for
example configure a route course notice
that it's course and not courses course
/ : ID and then we map it to course
detail to the course detail component
let's try this out if we now type slash
course slash and then a number let's say
that's the idea of a course we can see
that the course detail component is
being displayed to the user another way
of doing this configuration is via the
use of shell routes so under the path
courses we typically have the route path
where we have the list of courses and
then we have a shell route with the
detail of each course well we only want
either the summary route or the detail
route to be active at each time and
never both so this is the ideal scenario
for using a shell rod for this let's
make courses a component less route this
means that the route is there for
routing matching purposes but the route
itself does not instantiate a component
now we are going to configure two shell
routes for the courses route the empty
path route which corresponds to the
courses component the component that
shows the list of courses and paths with
the ID of the course this corresponds to
the course detail again only one of
these two will be active at a given time
let's try this out if we reload the
application and go to the path courses
we still have the courses list being
loaded as expected and now if we type
manually in the URL courses slash and
then we give it an ID we are going to be
forwarded to the course detail route
like we expected you might have noticed
that this file is starting to contain a
lot of routing configuration so it's a
best practice to split the router
configuration across multiple files so
let's create a new routing configuration
file courses router config and we are
going to copy it in the definition of
all the routes that relate to courses we
are then going to import it in the main
configuration file and we are going to
include it by using the array spread
operator we are getting deeper into
routing and this is only the beginning
so be sure to watch the following
lessons for learning what is an
auxiliary route and we are going to do a
exercise at the end of the course where
we are going to build a complete
dashboard so stay tuned for the upcoming
lessons
how's it going it's Vasco from the
angular University and in this lesson we
are going to explain in detail auxiliary
routes in the angular 2 router it's
coming right up so first of all what is
the use case for auxiliary routes let's
give an example for example we go here
to the courses screen we would like when
the user clicks in an item in the
courses list we would like a playlist to
be displayed here in the right-hand side
of the page this playlist is a section
of the page that might contain different
content depending on where we navigate
in the application now we could
definitely add the playlist as a
component inside the courses component
right that would be a solution but
imagine that this section of the page
will always be filled in with a certain
playlist no matter where you navigate in
the application so here in the courses
screen it's showing the playlist of
lessons of a given course but in the
lessons route it might display something
else so the lessons route contains a
list of the latest lessons well the
playlist might display in that case the
list of the most frequently viewed
lessons in other words we want this
section of the page to behave like if it
was a mini browser window with its own
navigation URL separate from the main
URL so that when you go back and forth
to a given route we can match it to a
different component if you find yourself
in this situation where you have
multiple regions of the page that you
want them to react differently to the
URL let's say dialog boxes for editing
forms or the left side menu that we want
to adjust each time that you navigate
this is a good case for an auxiliary
route okay so then let's configure a
route an auxiliary route for the
playlist so we are going to use the
playlist path and when that path is
routed - we are going to associate it to
the playlist component now we are going
to mark
this is an auxiliary route by filling in
the outlet attribute we're going to call
this outlet playlist now to which
section of the page does this outlet
correspond to we're going to configure
that by adding a second router outlet
tag to the page with the name playlist
so the only difference between an
auxiliary route and the standard primary
route is that it must have a name the
default route does not have a name for
my definition and it has its own
separate outlet which specifies the
section on the page to which the routing
is going to be applied well you must be
thinking then how do we access this
route using just the URL let's find out
so if we access this page we are going
to see that there is nothing in the
playlist section because we have not
routed to it in our URL we only specify
that we want the primary route to
display the home component but we did
not mention anything about the secondary
route and how could we do that because
after all there is only one URL in the
browser window right how can we specify
the second URL of the auxiliary route
angular provides a special syntax for
that so here inside parentheses we are
going to say first which outlet we want
to route to we're going to say it's the
playlist outlet now we add a colon and
after that we are going to add the URL
of that outlet to which we want to route
to and it's as simple as that if we try
this out now we can see that the
playlist is being displayed as expected
let's give another example let's say
that when we are routing to the playlist
path inside the playlist outlet we want
to display let's say completely
different component the courses
component let's try this out if we now
don't forget to playlist
- path inside the playlist outlet we're
going to see again the courses component
so this shows that this outlet really
has its own separate routing
configuration
where there is a separate URL one key
thing to understand about auxiliary
routes is that they are just plain route
so they have all the properties of a
standard primary route you can define
shell routes etc you can nest them one
inside the other it's really like you
have a different section of the page
with a completely separate URL to which
you can provide a completely different
routing configuration we are going to go
deeper in this course in auxiliary
routes this is just beginning actually
in the end of this course we are going
to use auxiliary routes extensively to
build a dashboard with multiple
auxiliary routes next up we are going to
see auxiliary route parameters hello
everyone how's it going it's Vasko from
the angle university and in this lesson
we are going to learn about the
problematic of introducing memory leaks
while routing it's coming right up this
code has a memory leak can you spot it
the memory leak has to do with the way
in which routers work so whenever you
navigate from a master route let's say
to a detail route then the detail
component gets instantiated if you
navigate to another detail component
then the same detail component is reused
we saw that before
now when you navigate back to the master
route then the detail component is
destroyed now when you go back to the
detail component you get a new detail
component at that moment the problem
with this is that if inside the
observables to which we subscribe to
inside our component we keep a reference
in directly maybe to the component
itself what is going to happen is that
when the component gets destroyed upon
navigation those observables might not
necessarily be destroyed they might but
they might not and if they are not
destroyed they have a list of observers
which contain our function which points
to the components of the component
will not get garbage collected so the
end result is that in this application
as it is as we navigate around and enter
the course detail route multiple times
from the home route from the lessons or
the courses route what happens is that
we get multiple instances of course
detail in memory each time we get more
instances that to not get garbage
collected and that causes the memory
leak let's see the memory leak in action
so what we are going to do is we're
going to print to the screen the number
of instances that are present in memory
of the course detail component so we are
going to look inside the query parameter
and we are going to look into its list
of observers the observers are in this
case the functions that are subscribed
to this observable so in this case the
only observer that we have here is this
small function on which we are
retrieving the value of the description
we are going to see that the number of
observers will grow over time let's have
a look we can see that as we click from
detail back to the master view and back
to the detail the number of observers
increases over time and this is the
memory leak there are multiple instances
of this component in memory how can we
fix this the only way to fix this is to
clean up these observers as the coarse
detail component gets destroyed to do
this we're going to tap into the energy
ondestroy
lifecycle method that gets triggered
whenever a component gets destroyed for
that we're going to implement the on
destroy interface and on ng on destroy
what we are going to do is we are going
to clean up these observers that we
subscribe to our observable query params
for example what we're going to do is we
are going to at the moment of the
subscription we are going to keep a
reference to the subscription and we are
going to store that in a component
variable then on ng ondestroy
we are going to use those
descriptions to cancel the subscription
to these observables therefore
preventing the memory leak it's very
hard to tell which observables will be
destroyed also upon navigation the
safest is to unsubscribe from them all
let's see if these fix the memory leak
so if we not navigate around the
application back and forth from master
to detail we can see that the observer
count is always the same it's 1 this
shows that the component is being
garbage collected because there is no
more references to the component because
there aren't any observers that are
pointing to the component and there you
have it a huge pitfall avoided you will
only notice a problem in a large
application and after a while as user
uses the application the memory would
get filled this could be a problem that
is very hard to troubleshoot now next up
we are going to talk about router guards
and we are going to learn what are
axillary routes it's coming right up
everyone and welcome to our angular 2
forms course I'm Vasco from the angular
University and in this lesson we are
going to start by learning why do we
need a full framework module for doing
something apparently as simple as forums
well the main reason is forms are really
not that simple forms can be a very
complex part of our application
especially if there is a very large
amount of fields if the forums spend
several tabs if there are editable parts
of the form that can be edited via a
dialog forms can be very complex there
can be a lot of business validation
rules interdependent validations
depending on multiple fields of the form
you could have a whole tab in error
could have multiple fields that are
related in error angular 2 helps us deal
with all that it helps us extract the
data from the form in a simplified way
so you will never have to write code
that gets the data from the form and
populates an object that's done for you
also angular 2 helps us dealing with
validating the form showing proper error
messages to the user clearly identifying
which parts of the form need to be
edited that's the big added value of the
forms module not every form is that
complex take a look at this example
where we are creating a lesson in a
course so we are going to put the title
the duration and we're going to put the
level either beginning or advanced and
then we click on a button create lesson
now what we want to do in this form is
we want to extract the data that the
user types in from the form let's start
with that that is called data binding
let's configure this in a template
driven way this is the closest that you
can get in angular 2 to the angular 1
way if you are familiar with angular 1
if you are not familiar with angular 1
don't worry we are going to explain now
data binding
this simple form what we want to do here
is we want to synchronize continuously
the content of the form we want to bind
it to this lesson object this lesson
object is an instance of the lesson
class which has these properties take a
look at the type annotations in the
constructor these are actually optional
because we are specifying default values
for each constructor parameter so if we
remove the type annotations we still
have type safety in this program this
typescript feature is known as type
inference now the forms module is
optional if we want to make use of it we
need to configure it in your application
we need to pass it to our bootstrap
function we need to call their the
provide forms function from the angular
slash forms import barrel now what we
want to do in this form before using ng
model is we want to turn off certain
html5 features that are on by default
because we don't want html5 to be
handling the validation of the form we
want angular to do it for that we simply
use the no validate property in the form
we also don't need autocomplete so I'm
just going to turn it off let's also
output the value of the lesson object to
the screen using the JSON pipe so that
we can see be directional binding in
action now let's configure the title
field to be be directionally bound to
the lesson title property for that we're
going to use ng model and we're going to
assign it lesson dot title this syntax
here with the two parentheses is called
the banana box syntax if we try now this
out and we start typing in the title
lesson field we're going to see that the
less an object is automatically kept in
sync with the content of the input field
with each key app event so this is the
ng model functionality in action we
don't need to code anything for doing
data binding it's done for us
automatically
but that is only half the story of
angular 2 forms data binding let's
inspect the HTML we have here several
state classes valid or it could be
invalid touched pristine ng model is
also helping us validate this form and
we are going to see exactly how to do
validation in the upcoming lessons so
stay tuned welcome
it's Vasco from the angular University
and in this lesson we are going to start
learning a completely different way of
making angular 2 forms model driven or
reactive driven forms why do we need two
ways of doing forms what's the
difference when to use each is coming
right up so first let's take the same
form that we did in the template
children forms section it's just a clean
HTML form that you're looking at we're
going to write it in the model driven
way the main difference towards template
driven forms is that in this case we are
going to create the form and its
controls programmatically and then we
are going to bind it to form elements as
opposed to using a set of directives to
create implicitly behind the scenes the
form and its controls for us but enough
about the theory let's see this in
practice to create a model driven form
the first thing that you have to do is
to import the reactive form directives
into your template otherwise this will
not work
this is turn off by default actually
forums are turned off by default you
have to enable them with provide forms
now let's create the form actually let's
use the form group directive to assign
to this element an existing form so we
are not creating it in the template I
cannot stress this enough so in this
case my form is the form associated to
this HTML form all the reactive form
directives start with 4
so we can see that they make a
consistent group now in our controller
let's define a variable my form which is
of type form group that represents the
forum now let's start our program and
let's see what happens here
we have not initialized the my form
variable so we get an error
this is expected again reactive form
directives bind form elements to
variables that we need to initialize
ourselves programmatically so in this
case we need to initialize my form and
we are going to create a new form Group
instance we're going to pass it in for
the moment an empty configuration object
let's try this out again now the error
is fixed we have created our first
reactive form now let's add some
controls to the form before we were
doing that using ng model in this case
we are going to use the form control
name directive and we are going to
assign to each form control a name like
the directive says now let's run this
what will happen try to guess of course
we get an error because again this
directive is only binding to an existing
control that we need to create ourselves
so let's do that let's create free-form
controls one for each input field the
title the duration and the description
we are going to create the form controls
inside the configuration object that was
passed on to the form itself so each
property of this object each property
name is the name of the control and the
value is the control itself that we are
going to create with new form control
and we are going to pass to each control
its initial value let's try this out so
as you can see the form controls have
been initialized with the initial value
and we have no errors on the console so
congratulations you have created your
first reactive form why is it called
reactive what's the point what's the
difference we're going to start to
understand that already in the neck
lesson where we are going to go over
validation in reactive forums so stay
tuned hello everyone and welcome this is
Vasco from the angular University and in
this lesson we are going to start our
journey exploring services and HTTP the
HTTP service of angular 2 in detail now
you might have noticed that when you are
using the angular 2 HTTP module in the
early examples that we present it to you
that whenever you need a result from the
server you need to subscribe to it what
is this SUBSCRIBE method we're going to
learn observables in this first section
of this course and then we are going to
use them to build service layers with
HTTP you noticed before that we were
calling the server and that we were
storing the state in a state variable in
the service this is actually not a good
idea at least not in this form how
should we build angular to service
layers then the answer is simple by
using observables now let's start at the
beginning what is an observable and what
is a stream in our applications we have
streams of values everywhere imagine
when you drag your mouse around the
application so that series of values of
pairs of x and y-coordinates
that's a good example of a stream so a
stream is just a series of values in
time okay
that's simple enough but then what is an
observable well let's start by saying
what an observable is not an observable
is not a stream those are two different
concepts that it's important to separate
from the beginning now instead of
focusing on the perfect definition of
observable let's just build one and take
a look at it and see what can we make of
it let's build our first very simple of
and take it from there for example when
we type in the adolescent input box the
stream of values of the input box in
time that's a good example of a stream
now let's write an observable so that we
can tap into that stream let's for
example print the values of the stream
to the screen using the observable API
let's do observable and then from event
the first argument of from event is the
Dom element on which we want to listen
for an event and the key up is the Dom
event that we want to listen to the
output of from event is an observable
let's assign it to a variable in this
case - the keys variable that ends with
the dollar this is a convention to
identify variables that correspond to
observables if we try this out we can
see that this doesn't really do anything
visible in the program that's normal we
haven't even tried to print something to
the screen let's do that using the do
operators so observables came with a lot
of built-in operators this is just one
among many it's used to typically for
debugging purposes so it shouldn't be
used for anything other than that
because it produces a side-effect let's
see this in action if we now type in the
input box we can see that nothing still
happens and this is critical to
understand the difference between
streams and observables so the stream
exists when we type in the box there is
a series of values in time for the key
of event what happens here is that the
observable is really just a definition
of declaration of what we want to do
with the stream so and we need to
activate it we need to subscribe to the
observable otherwise nothing will happen
this is one of the main properties of
observables you need to subscribe to an
observable
other than that the observable before
subscription is simply just a definition
of what we want to do with a stream is
just a declaration it's just a blueprint
for a functional processing programming
chain that binds an input of a stream to
a consumer that is interested in values
that are derived from that stream so if
we now type in the input box we can see
that the key that we just pressed is
being outputted to the console we can
see here that the variable Keys dollar
is really just a declaration of what we
want to do with the stream values we can
pass it around in our program we can
combine it with other such declarations
but this is not the stream itself it's a
way of handling the stream it's a way of
building programs based on the notion of
stream remember the notion of observable
is essential for being able to use the
angular to HTTP module as well as
several other parts of the framework
let's continue laying down the
foundation for understanding observables
in the next lesson hello how's it going
it's Vasco from the angular University
and in this lesson we are going to
understand how to use angular to HTTP so
the module the standard module to build
our service layer it's coming right up
so we have learned before that angular 2
HTTP returns observables so how should
we use it
should we just inject HTTP everywhere
and just call it directly the answer is
no we should use HTTP inside our service
layer and our application our components
should call the service layer and get
back observables the application doesn't
know actually where the data comes from
it can come from a rest back-end
it can come from firebase that is
transparent for the application itself
it's the serve
that knows where the data comes from so
let's see this in action let's pass to a
list of lessons the lessons data coming
from the back end for that let's call
the lesson service and call the load
lessons method this method will get us
back an observable of lessons so an
observable whose values are arrays of
lessons let's assign this to a variable
lesson dollar again this is an
observable now like any other observable
we need to subscribe to it let's do that
and let's assign the result of the value
returned from the back end to a variable
that we can pass in to our lessons list
the member variable lessons is of type
array of lesson and lesson is just a
plain type script class that we have
defined we can see it here so in our
success handler we receive the next
value of this stream which is an array
of lessons we are simply going to assign
it to our member variable lessons we are
now going to pass the lessons variable
to our lessons list component and this
should print our lessons to the screen
but now what does exactly the lesson
service look like let's have a look
let's now implement the lowered lessons
method in our lessons service service so
what we're going to see here is typical
of how service learns are often
implemented this is just an option there
are other options we are going to call
HTTP so HTTP stays inside the service
layer and it's not used directly by the
components we call it we call get
lessons and we get back an observable we
map it into its data and we return it
this is very important we return it from
the service layer and the consumer will
get an observable to which it can
subscribe while returning observables
from the service layer it's a good idea
to add a type annotation to specify what
is the type of the data returned in this
case it's an observer
of lessons array now that we have added
the type annotation in the return of our
function in the service layer the
application code so the component that
called the service layer no longer needs
to use type annotations itself the
lesson observable variable will be
immediately known by the typescript
compiler as being an observable of
lesson array so this is type inference
at work helping us build our program if
we try this out we can see now that the
lessons data is being retrieved from the
server and injected into our lessons
list as expected now this concludes our
introduction to observables and HTTP the
reminder of this course of services in
detail is going to be about the several
common use cases of using observables
for example combining multiple HTTP
requests doing an HTTP request after
another but only if the first request is
successful retrying an operation
canceling an operation this is what we
are going to cover right in the next few
lessons we are going to conclude in the
end with an exercise so stay tuned hello
everyone and welcome this is Vasco from
the angular University and in this
lesson we are going to learn how to more
easily consume data coming from
observables using the standard a sink
pipe we're going to see a way of
building our programs that is closer to
the functional reactive programming
paradigm so stay tuned we can see here
that we are using a state variable in
our component lessons this contains an
array of lessons so this is OK but
imagine that we would prefer to build
our program around the notion of streams
and observables only so in this case we
are going to define our program in a way
that our views our components simply
react to the arrival of new day
and displayed on the screen but they
themselves don't contain directly any
state so the application does have state
it always has state the state is for
example at the Dom level the state can
be somewhere in our application it
doesn't have to be in your application
code state variables are actually a
source of bugs so mutability is a
well-known source of bugs in
applications in general so the more
state variables we can avoid the better
as long as it's still practical to write
our program and does not present a lot
of cognitive overhead for the developer
we can do that by instead of using state
variables using observable member
variables instead of using a lessons
array variable we are going to use a
lessons observable so it's just an
observable that each value is an array
of lessons let's now try to pass it to
our template to see what happens if we
try this out as it is we will see that
we will get an error saying for example
cannot find a sporting object ng for
only supports binding of iterables so
this basically means that we have passed
to the lessons list something else other
than what it was expecting and we got an
error if we want to pass in data coming
from observables into components that
are not expecting and observable we can
use the standard a sync pipe let's try
that we just do pipe a sync and what
this a sync pipe will do this is an
impure pipe that will subscribe to the
observable and it will retrieve its last
known value and it will pass it to the
component so this also works for
promises as we can see now the lessons
list receives correctly the lessons just
like we wanted now if we want to pass
the observable to another place in the
template we need to apply pipe a sink
again let's give an example let's print
out the total number of lessons to the
screen if we cry this out without
further modifications we can see that we
get an error that says cannot read
property length of no this is because
the pipe has subscribed to be observable
but while the observable does not return
its first value the value will be no so
if we try to call null dot length we
will get this error we should guard
against this error condition in our
template by using simply the Elvis
operator like we saw before
so using observable member variables is
just a possibility that we have to build
our program it's not in any way
mandatory it's just an interesting
possibility one thing to avoid in at
least in retrieval operations is to call
the service layer directly from the
template so for example instead of using
lessons pipe a sink we will do less and
service dot blower lessons pipe a sink
this is really something to avoid
because the template is continuously
being regenerated and it's expressions
are continuously being re-evaluated so
you would have a series of network calls
being made to the back end and you might
not understand immediately why
speaking of which we are going to learn
in the next lesson what is maybe the
biggest pitfall that you can find while
using angular 2 HTTP so it's coming
right up
I hope you enjoyed the free sample of
the course remember this is just a very
small sample the course is much larger
and goes into much more detail in
angular 2 I invite you to have a look at
the course itself here is a link and I
am proposing here a 50% discount I want
to invite you to have a look at the
course I hope that you enjoyed the free
example I want to thank you very much
for watching and I hope to see you again
in one of my angular 2 videos thank you
and have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>