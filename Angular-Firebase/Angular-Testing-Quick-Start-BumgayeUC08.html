<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Angular Testing Quick Start | Coder Coacher - Coaching Coders</title><meta content="Angular Testing Quick Start - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Angular-Firebase/">Angular Firebase</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Angular Testing Quick Start</b></h2><h5 class="post__date">2017-12-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BumgayeUC08" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">test-driven development is the single
most powerful tool you have for
preventing bugs within your application
that's not just my opinion but it's a
scientifically proven fact in exchange
for effort and productivity you get
better quality software that is more
maintainable long-term lucky for you
angular comes built-in with jasmine and
karma so testing is really easy to get
started with in this video I'll give you
a tour of angular's testing tools and
show you how to deal with third-party
dependencies like firebase if you're new
to the channel make sure to subscribe
and you can always get the full source
code on angular firebase com the first
thing I'm going to do is generate a
brand new angular 5 app and then I'll
show you what all the different testing
files do the angular CLI generates all
of the boilerplate code automatically so
we'll start by looking at the karma
config file karma works by setting up a
web server that will run all of your
tests automatically every time a file
changes you have some configuration
options here if you want to customize
that experience you also have a
protractor config file which is
specifically for end-to-end tests and
end testing uses the browser to simulate
how the end user sees your app so it's
completely decoupled from your main app
code that's why we have this été
directory in the root of the project and
I'll show you how to use it in a future
video now moving into the source
directory we have a test ts file it's
required by karma to load all your spec
files you shouldn't really have to
change anything in here now let's take a
look at our first real test which is the
app component spec ts file this just
looks like a big jumble of code so let's
break the test down into its fundamental
parts the first part of any test is to
describe the test suite in Jasmine you
do this by using the describe keyword
followed by whatever you're testing the
purple text represents jasmine the green
represents what we're going to write we
write all the tests inside this describe
block each one starting with it so we're
going to say it should be awesome then
you'll write an expectation that
verifies whether this is true or false
so with jasmine we could do something
like expect component to be awesome the
end result is that you've described the
behavior of your code in a way that can
be easily read by a non programmer
describing and validating your code in
this way is the reason that testing is
so effective at reducing bugs now we
need something to test so I'm going to
start by generating this alert but
Component it's just a simple button that
will toggle the visibility of this alert
message whenever it's clicked
we'll start by testing its static values
but eventually we'll use angularfire to
to populate it's warning message if we
look at the component type script I just
have a couple of properties hard-coded
in here and then I have a toggle method
that will toggle the value of the hide
content property then the template HTML
just shows these properties and adds a
button that will toggle the visibility
of that message the message is hidden by
default and that's something we're gonna
test here in the upcoming steps so now
let's set up our alert button spec from
scratch the first thing we're going to
do is import angular's testing utilities
and then we're going to describe our
test suite which is the angular button
component at this point we're going to
declare a variable for the fixture and a
fixture is just the test environment for
this component so it provides access to
the component itself as well as its
debug element which is it's rendered
HTML now before each spec we need to set
up a test bed which is just an NG module
specific for this testing environment
the most simple example is just an
isolated test of the component itself
and that's where we're going to start
but this will get increasingly more
complex if you want to compile the
components HTML and CSS then you'll call
this compiled components method after
the test bed after the test beds been
compiled we can then set up a few
variables here that we'll actually use
for testing we can test the component
directly or we can test its rendered
HTML via the debug element and lastly
we'll run angular change detection
before each of these tests but you could
test things before change detection as
well now we're ready to write the first
spec the first thing we'll test is
whether or not the component is created
successfully so we can say it should
create and then we'll expect component
to be truthy just a quick side note
truthy means that something evaluates to
true in a boolean context it doesn't
mean what you're testing is actually the
primitive true value this is one of the
many Jasmine matters and I recommend
going to the docs to get acquainted with
all of them now that we have our spec we
can just run ng test and that'll bring
up a browser window saying whether or
not it passed or failed now I'm just
gonna leave karma running so we can see
how it updates every time we write a new
spec the second spec is going to see
whether or not the content message has a
string of warned in this case the
content was just hard coded as a
property on the component so we can say
a component content to contain the
string of warn the to contain match sure
we'll check for a substring or if it was
an array it would check for an element
in that array now if we save this file
you can see the karma runner on the Left
will update with the spec and it will be
passing as well so the actual message
content is you will be warned so let's
see what happens if we use a Jasmine
matcher that looks for an exact match
this time we'll get a failing test and
it's also going to tell us exactly why
it failed it expected that string of you
have been warned to be warned which
would be false you can also rate specs
based on logical numeric values so let's
say we have a severity level on the
alert and we want to see if it is
greater than two in this case it's
actually 423 so if we say expect
component severity to be greater than
two that should be a passing test so far
we've only tested properties on the
component itself but now let's see if it
actually rendered properly in the Dom so
we'll say it should have an h1 tag of
alert button to do that we use the debug
element and it has a DSL that allows us
to query elements in the Dom so we would
say query by the CSS of h1 then we can
get the native HTML element at that
point we just have the string that's
inside the h1 tag and then we can
validate that it is the alert button
text so now let's move on to a spec that
will tell us whether or not a function
is doing what it's supposed to do we
wrote a toggle method earlier that
toggle is a boolean variable so we'll
say it should toggle the message boolean
and first we'll expect the component
hide content to be truthy because it's
hidden by default then we can execute
that toggle button method then we'll run
another expectation that this time the
component hide content boolean is fall
see that one passes as well so we know
that our method is performing what it's
supposed to perform but what if that
change happens asynchronously as many
things do in angular back in the
component I'm going to define a method
called toggle async which will run the
toggle method after an rxjs timer of 500
milliseconds runs out the spec is going
to be it should toggle the message
boolean asynchrony
then we're going to wrap this in the
fake async helper from angular this
creates a fake angular zone that we can
use to test asynchronous activity the
test is exactly the same as the last one
but calls the toggle async method as you
can see here it fails because angular
doesn't wait for the 500 milliseconds to
run out before testing that property we
also have a tick utility that we can use
here in the fake async block and so if
we set that to 499 milliseconds you can
see here that we still get a failing
test the time when we set is 500
milliseconds so if we add just one more
millisecond to it then the test will
pass that gives you a few basic examples
of angular component testing but now
let's add a service to the mix using an
angular fire - what we're going to do is
create a service that returns an
observable from the firebase real time
database and that's going to replace the
content that we had hard-coded in the
component before if you're not familiar
with angular fire - make sure to follow
the setup instructions on the main
documentation you also need to have a
firebase account and inside the real
time database I have an alerts node with
a test alert that says you have been
warned then I'm going to generate a
service with the CLI and you can test
your service directly but for this video
we're just gonna focus on the component
the service itself is very simple we
just add angular fire database to the
constructor and then we'll set up one
method in here called get content which
will retrieve that message from the
database as an observable when running
your tests you don't want to actually
use live data from the real back-end you
should only simulate how that backend
data would be returned by using what's
called a stub a stub is simply a method
that returns some data in a way that's
predictable and reproducible so what I'm
doing here is setting up a variable
called service stub it's going to be an
object that has a function in it that
returns the observable in the same form
that we had expect back from firebase so
the get content property is a function
that returns an observable of the
message you have been warned this gives
us mock data that we can use to interact
with the service without actually having
to make a real request to firebase then
we can use this stub as a service by
adding it to our test bed in the
providers array but instead of providing
a live service we do an
object that has provide with the message
service and then use value with our
service stub this tells the test
environment to use the stub instead of
the actual live data at this point all
we have to do is write our spec and it
should return this observable like we
would expect this time we'll say it
should have message content defined from
an observable and then what we'll do is
subscribe to that observable and put our
expectations inside the SUBSCRIBE blog
we expect the content to be defined and
to be you have been warned this is the
easiest way to test mock data from a
service but it is limited in certain
respects for example we can't tell how
many times this method has been called
which might be important if you have a
method that is not item potent to
address this I'm going to stub our
service using a different method called
a spy this time we're going to actually
use the live service so we're going to
need to set up our test bed with
angularfire too
then I'll set another variable for our
service and another one for the spy from
there I'm going to add angularfire to to
the import section of the test bed and
then in the provider section I'll take
out the stub and add the live service to
it then we can get rid of our previous
service stub and then we'll set up the
spy here which comes from Jasmin we can
call spy on and then pass it the main
service class as well as the method that
we want to monitor so in this case it's
going to be our get content method we
still don't want to use any live data
from firebase so what we do is tell our
spy to return a value of an observable
of the message what this is going to do
is allow us to see whenever this method
has been called and with what arguments
it was called with and it's never going
to actually make a live request
so it just stubs the return value and to
get the service class we call debug
element injector get with the message
service
so our spy is ready to go now we can
just jump down and write our next spec
this time I want to make sure that the
method is only called once and I want to
make sure that the view is updated with
the corresponding observable data so we
can make sure our service method was
called by calling expect spy to have
been called then we can see how many
times it was called by calling spies
calls all which is an array and then we
can test the length of that array
and it should be one so we'll say two
equal one then we're also unwrapping and
observable in the HTML so I want to make
sure that this method results in an
observable that gets rendered in the
HTML itself so we'll use query on the
debug element to get the message body
then we can look at the native element
inner text and that should be the
message you have been warned so we can
just call to contain warn to verify that
then we can go ahead and save it and
it's going to run our spec and it passes
as expected the spike can do a whole
bunch of other stuff too like see where
the method was called and with which
arguments so check out the Jasmine docs
for more information on that that's it
for angular component testing basics if
this video helped you please like and
subscribe and if you want to learn more
advanced concepts consider becoming a
pro subscriber at angular firebase comm
you'll get a whole bunch of exclusive
content one on one project support via
slack and a free copy of my book thanks
for watching and I'll see you soon</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>