<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>You Are Hacked: End-to-End Java EE Security in Practice | Coder Coacher - Coaching Coders</title><meta content="You Are Hacked: End-to-End Java EE Security in Practice - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>You Are Hacked: End-to-End Java EE Security in Practice</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EV2EkFh2MXo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon everyone thank you very
much for coming to our session you're
hacked end-to-end security in practice
so who are we
my name is Karthik sham cinder I'm a
principal technologist at Verisign I
also serve as an adjunct faculty at
Johns Hopkins University teaching
courses on distributed computing and
enterprise computing there's my twitter
handle and you can also email me at
karthik jumps and there at gmail.com I
have with me funny part Abu funny right
Thanks funny so what is the overall goal
of this presentation we actually have
two goals first to give you an overview
of the Java EE security features that
can help you in building secure
enterprise applications in the cloud
second best practices that you can
employ while you're using these Java
security features that's available in
the platform so here's the outline first
we want to talk about the internet
threat model then we're going to talk
about the Jawa security model itself
then we will talk about securing in the
web tier we'll talk about securing the
EJB tier the business logic tier then
we're going to talk about securing the
enterprise integration to your data
services and then some Java security
challenges in terms of the EE platform
somebody and hopefully if time permits
we'll do Q&amp;amp;A it's going to be a pax
you know type session lots of stuff
going on over here this and the slides
will be available right after the
session okay so let's talk about the
internet threat model well thousands of
mission-critical applications are being
developed and deployed on the you know
on the Internet worldwide but the
reality is most of these applications
are vulnerable to attacks by hackers and
crackers and an attack by a cracker or a
hacker is detrimental for that
particular for that particular company I
don't want to name any company or put
any specific headline but if you look at
any of these security news or any of the
internet news cloud computing news you
see a lot of attacks like this
the problem is real guys the reality is
cyber crimes and incidents are actually
on the rise and the interesting fact is
that three out of four businesses or
vulnerable to attack according to
Gartner and the even more interesting
fact is that 75% of the attacks actually
take place at the application level now
when you're working for an enterprise
you know you're dealing with those you
know security security professionals
that have all these firewalls in
recovery to make our life difficult but
the reality is that they are actually
doing a fairly good job in keeping the
hackers away in terms of network
security and things like that but when
it comes to application level security
it's our problem we need to take care of
that so here are the seven steps of doom
for many companies they develop software
they deploy it they get hacked they fix
the bugs they deploy it again they get
that you know they get hacked again they
fix the bug and it is keep on going you
know it's it's a vicious cycle what you
really want to do is think about
security when you're building software
think about security you know secure
design secure development secure testing
secure deployment and operations audit
process and most importantly build your
software on a platform that gives you
the security features and if you really
think about it the jury platform
actually does that so let's look at the
Java EE security model so the lion over
that indicates the client versus the
enterprise in your enterprise you have
your application server you know you may
have many of these application servers
behind a firewall behind a load balancer
you have the web container the EJB
container and then you have your
enterprise services enterprise
integration services yeah like a
database message queue your AI services
which is your mainframe systems that you
may have to interface with or other
systems that you may have to interface
with with you within your company or
even services that you may have to
interface with in the cloud so you have
your web tea
you're EJB tear and the enterprise
integration tier in terms of client you
have standalone client or the browser so
when it comes to standalone clients they
can be non Java clients they could be
Java clients or they could be the
browser you can also have a Java EE
client there is something called the
application client container is a cc
which is part of the Java EE
specification that allows a Java EE
client to talk to the application server
directly to the EJB container so you
have standalone clients like browsers
talk to you web container the web
container would end up talking to your
business logic container or it may end
up talking to the EIS tier directly and
then the Annie is the EJB container the
business logic container will end up
talking to your AI services or your
clients will end up talking to your EJB
container directly which of course end
up talking to the AI services so what we
are going to talk about in this
presentation is how to secure the web
tier how to secure the EJB tier the
business logic tier and how to secure
your Enterprise Services tier all based
on the Java EE standards there are
certain things that we need to
understand when it comes to application
security authentication authentication
is ensuring that the users are who they
say they are this is typically done by
using user user IDs or certificates
client certs
authorization organization is ensuring
that the users have permissions to do
whatever they want to do the operations
which is typically done through groups
and roles confidentiality or direct our
data privacy ensuring that only
authorized users can view the sensitive
data usually done through SSL for
encryption non-repudiation ensuring that
transactions can be proved that they
happened to the fact that the fact is
the client dips in the transaction to
the server and the fact that the server
did send the transaction back to the
client with notification on both ends
typically done using SSL auditing
maintaining a record of transactions for
every transaction that you're going
through all the security auditing
information
quality of service this is important to
ensuring that the users experience a
good quality of service when they are
using your application the most
important thing is that the Java app
server and the app services offer
several mechanisms that actually address
all these characteristics of an
application security there are two ways
to express security in your enterprise
application there is the declarative way
or the programmatic way in declarative
way there are two choices you have Java
annotations where when you write a class
or we write a method you can put
annotations in your class the advantage
is you can do security annotations right
there as you're writing your code the
disadvantage is that you're keeping your
security characteristics which are
architectural characteristics as part of
your code but there's one more slight
disadvantage it's not a big interest
which is there's limited functionality
when it comes to annotations you can do
a lot of things with decorative external
external deployment descriptors but
there's a few things that you cannot do
annotations the deployment descriptor
annotation of course the advantage is
that it keeps security concern outside
your code and the most important thing
is it can override security features
defined through the annotation so at the
deployment time you can do different
things when it comes to programmatic
annotation many times
declarative security is not good enough
to solve your problems in which case you
end up going to programmatic annotation
and the logic is embedded in your
business logic the most important thing
is you should prefer using declarative
security and drop down to programmatic
security only if the declarative
security is not going to solve your
problem in fact funny is going to talk
about that
so in Java EE security there are a bunch
of terms that we need to understand user
credential group identity storage
security ROM principle role so let's
talk about those things
user credential and group according to
Java specification a user is an
individual or machine don't forget users
can access your system or other systems
machines can access
system but the most important thing is
whose identity is defined in the
identity storage so there is something
called an identity storage where you
have to keep track of the users that's
how they define a user credential
information used to authenticate a user
typically it's a user is a password but
it could also be a certificate for to a
authentication again this information is
stored in some kind of a storage
identity storage I know I haven't talked
about identity storage yet it's coming
soon but we'll get into that then you
have GRU it's a set of users with a
common set of characteristics you know
that have a common set of permissions
and access levels to access certain
resources you take a bunch of users put
them into a group in this case I've
taken user 1 user 2 and user 3 put them
into a group called manager and this
information is again stored into an
identity storage so what is this
identity storage and the related term
security ROM an identity storage is
where you place your user group and
credential information in some kind of a
storage it could be a flat file it could
be an our DBMS system it could be an
LDAP server it could be a certificate
repository and a security room is a term
in Java EE where it's a mechanism by
which an application server stores and
most importantly it retrieves users
credential information so that it can do
the authentication and authorization for
that particular user GlassFish
application server which is what we like
to use I'm going to talk about that in
specific over here provides for major
ramps it offers file JDBC LDAP insert in
fact it also offers Pam for Unix and it
also offers customs if you want to do
your own authentic authentication
identity storage you can do that so
let's take a look at the JDBC ROM so
typically when you have users in the gdb
store that's the most common way because
in a JDBC you know that's where you want
to keep track of all the users are in a
file so you would have something like a
user table the most important thing
important attribute over here is the
user name attribute and of course the
credential which is the password and
then you have a group table which is the
list of all the groups that you may have
in your system the most important
attribute in that particular
table is the group name and then because
a user can belong to multiple groups and
the fact that a group can have many
users what you want to do is a mini it's
a many-to-many relationship so you may
want to have some kind of a join table
that joins everything together and then
what you really want to do is put some
kind of a view on top of that you know
if this is how you do it in GlassFish so
you put a view on top of that where you
have the username and the password and
the group name and then you can insert
records into the groups and users so
what I'm showing you over here is Hollen
GlassFish administrative console you can
say what the JDBC aromas that's you know
which is the which is the class that
represents the rum and then you can also
give a name for the ROM which is the
jazz context you can also give the jndi
name of the data source which accesses
the database so that the application
server can do the authentication there's
also a user table of course in this case
it's going to be the the virtual table
and then you have the username the the
password and the group information all
available you configure this now you can
configure all these things using a
console or you can use something like an
ace admin tool to configure all this in
every application server does it
differently now let's talk about
principles and roles so you have the
concept of principle a principle is
really a Java EE concert for a user
there's a class called Java dot security
or principle that represents a user
because a user in Java EE could be a
regular user with username or it could
be a client-side certificate so there's
actually an x.509 certificate that
inherits from the principal class when
it comes to role it's the groups that
maps to the Java EE roles and once again
you have the group information which
gets mapped to the role the mapping of
the principles and the roles is done in
the application server using a vendor
specific file for example in GlassFish
there's a file called class fish - web
dot XML file which is in parallel to web
dot XML file where there's an element
called security role mapping which Maps
the GlassFish roles in garage which you
don't talk about in terms of groups you
talk about an app in Java you talk about
in terms of roles so you take a role and
you can map the role to agree
or multiple groups and you can also map
it to principals you can have as many of
these roles defined
okay so now you've taken the physical
world into the Java EE virtual world so
let's talk about the web here security
now all right so if you think about it
your clients which are the non Java
clients in this case the standalone
clients the browsers they are trying to
access a resource in the web container
and if the users resource of the web
container is a protected resource then
credentials need to be exchanged between
the client and the server and so the
application server kicks in and tries to
get the credential exchange done okay so
what is the authentication
well authentication in the web tier we
know that authentication is really
proving who you say you are in the web
tier there are four authentication
mechanisms there is the basic the digest
form-based and client cert and I'm going
to go through each one of them it's
really important to understand the
differences between these things so you
can make the right choice for your
application so we'll talk about the pros
and cons of each one of these things
when it comes to doing authentication in
the web tier you can do it declaratively
using XML based annotation you can also
do it programmatically which is a recent
API as part of the server 3.0
specification if you want you can you
know if you remember we said in
declaration in declarative annotation
there's the Java based versus the XML
there is really no annotation for this
it's only XML based so let's talk about
declarative authentication and web dot
XML file you have your web dot XML file
there's an entry called log in config
this is all part of the Java EE spec
where there is an attribute there's an
element called odd method which has one
of the four different values basic
digest client cert and form again I'm
going to talk about these things you
have to pick any one of these things and
then there's something called the run
name so this matches this Maps the
application service round that we
defined we actually define a JDBC or arm
there's a name that's given of the in
the configuration level and then there
is also something called the form
in config element which is used only for
form-based logins when we talk about
formas logins we'll talk about that
right so let's talk about decorative
authentication using the basic method in
this case you define login configured is
basic and by the way I left an element
here which is the ram ram name you can
add that and it's part of the spec and I
just wanted to keep it simple over here
the basic idea here is that you have a
user the user wants to access the
protected resource so when the user
accesses a protected resource the
application server says wait a minute
this resource requires you know some
kind of a role you need to authenticate
so the application server simply sends
an HTTP 401 Ruhr this is basic
authentication in basic authentication
when the browser receives a 401 with the
Ram name which is the special W W
authenticate header the browser says oh
I need to pop up a dialog window it pops
up a dialog window asks for the username
and password you entered the username
and password and that information is
sent to the server using the specific
header called the authorization header
the most important thing to remember
here is the password is base64 encoded
it's not encrypted and of course once
you're authenticated you basically are
able to access the resource and there is
no concept of logout over here because
the application the browser is
maintaining this session all the way
through in digest based authentication
it's pretty much the same story the user
accesses this protected resource the
server sends back a 401 the pop up
happens and then you know in this case
it sends back you know you know a little
bit more things happened is there's
another negotiation nones and all those
things but the reality is in this case
rather than sending the password in
base64 encoding it actually sends the
digest so did the difference between the
the the basic and the digest is the fact
that you're not really sending the
password here you're only sending a
digest some kind of a hash from the from
the client back to the server well this
also means is that one of the things
that we noticed was in your application
server when you are storing the password
you need to make sure that
you actually create the digest of the
password when you store the password and
not really the password the way it is
okay so now let's talk about decorating
authentication using form this this
authentication is a really nice
authentication because it allows you to
build your custom forms because the
other one is pretty ugly you know you
have this pop-up window that comes up
from the browser so the idea here is
that you fill you create a page called
the login dot HTML or the login dot JSP
which has a four minute it has three
major elements that is j underscore
security check jailer scores underscore
username and g underscore password these
are three things that are defined as
part of the java specification so the
you know the idea here is that the
gender school security check is a very
special service a very special servlet
that gets called upon which does the
authentication for you by the container
there is also an error page that's
available so if the authentication ever
fails it'll we will actually end up
going to the error page so in this model
when you say login config or method form
you basically define the login page and
the error page and by the way you can it
can be the same page if you want you can
do some ajax over there and the idea
here is that the user accesses a basic
secured resource when the user accesses
a secure resource the application server
says this requires log n so the
application server rather than sending a
header which is the wwr educate header
it ends up sending an HTTP 302 back to
the client redirecting them to the login
page which is the custom login page to
tiro so the browser gets the login page
the organ bitch comes back the browser
displays it the user types in the
username and password grew aji
underscore username and Jane underscore
password or the two special form
elements that get submitted to Jane
underscore security check in the form of
post the application server then uses
the mechanism to log in it logs in from
the into the data from the from the
realm which is JDBC Rama in this case
sends back a redirection saying that
everything is good and redirects you to
the the original page that you're asking
for
and all these things are happening
within a few milliseconds hopefully the
network is good
so here the username and password is
sent via post it's not encrypted so you
have to make sure that you know you use
the appropriate transport again funny is
gonna talk more about this
the next authentication model is the
cert based authentication model here the
automated is client cert the key here is
that you expect a client to have some
kind of a client certificate of course
we you know I work for Vera sign and we
had the security business and we would
want everybody to buy a certificate
client-side certificate this is
definitely a very nice authentication
model in this model the client has a
certificate it's a little bit more
complicated when it comes to negotiation
here what happens is the client makes a
request to a resource the server
basically does mutual authentication
Roemer this is client-side so it's not
just the server-side certificate when
you have a server-side certificate all
you're saying is that the client says
yeah I know you're a good server but we
never clients that certificate the
server says I know you're a good client
I know you're or not that you know
you're a client that is mean that has
been validated so there's a bunch of
authentication if there's a bunch of you
know conversations that go back and
forth and you know I can talk to you
about that for an entire hour you know
but that's not what this is all about
but anyway the negotiations take place
and eventually you know the
authentication takes place and you get
sent to the right page it's a stronger
authentication model when you want to do
you know things like financial
transactions maybe this is a model you
can use and it uses visual significant
significant regular password
alright so now all this is great but how
do you do programmatic authentication in
web tier for a long time we didn't
really have that what I mean by that is
in Java EE application server when you
access the resource that's when the
authentication kicks in right if you're
accessing a resource that's not
protected authentication is not going to
connect again there was no way to
actually force authentication but when
you're building applications that are
Ajax like applications where you have a
form and you want to specifically go ask
for authentication and still want to use
all the other mechanisms that's
available as part of a Java EE for
protecting your may be a restful
services and things like that because
now the you know programming model is
shifting more towards restful api HTML
client javascript lines making restful
calls and you're exposing everything is
a restful api you still want to have all
the joy security model built into it
this you know we have programmatic
authentication that allows you to do
that
so now as part of the HTTP surrett
specification three-dollar specification
you have a method called login that's
available which takes the username and
password and you can login so you fill a
form you submit the form and then you
can do the login explicitly using this
particular API and then there is also a
method called authenticate now that's
available there allows you to instigate
login if you are in a page that is an
unconstrained resource page of course
once the user is logged in you have a
session and you want to make sure that
this session is managed because as part
of security you want to make sure that
the session is managed then you know
that somebody is logging in from Public
Library the session is not open you know
for the next ten years so you want to
defile define idle session timeout in
your web browser XML file declaratively
you can do this by having a session
config set to 30 minutes or 15 minutes
or whatever you want the application
server will set your timeout you can
also do it programmatically by invoking
the sessions or set max interval method
so that's how you define timeout and now
you also have a explicit way to
invalidate logged in session by invoking
a method called log out so now longer is
also a complementary a method available
as part of the server three orders
specification so you can do a log out
funny is going to now talk about
authorization
okay so okay but they already miss a
moment of authorization and everyone is
familiar so it's just basically puts to
access control and a way to regulate
access to things not be based on the
rules that the user current user is
doing so it knows of it if it's like a
liquid of authentication authorization
also can be humanity creatively
automatically for a combination of both
the curriculum and protomatter let's
look at iterate all our agent in
directional so first foundation for any
authorization is being able to define
the lows the dip erase or the condition
of the rules happening in tax so you
specify a list of explained enumeration
of all the rules supported by the
occupation in y direction we can have as
many anymore so once that also defined
then you need to start specifying your
security constraints as the blue
connector swap so now the leaf is inside
take you to constrain you need to
specify what is the reference of
collection that you're trying to protect
so that you can feel the need for
methods of collection and then we have
to fix by the off pattern that is in the
context of history so then once you have
they all pattern so by default if you
don't specify any editing methods then
all of the methods are acquired within
this step constrained resource
collection but then like we specify one
or more of the
method there's only these methods will
be protected by this authorization
transcript so you can fight one
amorphous we get post put option space
even if you want all dismissed by
experimental omission
what happened series so only these
methods will not be protected and
everything else will be protected so if
you don't have a simple method or
mission either of those then by default
everything will be part of the service
of policy if you have specific tips if
you matter then only those will be but a
basic web whispers collection and if we
have holidays America missions then
everything except those will be
protected now once you specify whatever
it was collection is that it is
specified with the rules have access to
this resource culture taken without
using autumn and spring and all intact
but there's also other elements called
crimes World News thanks for guarantee
would you look at the opposite but this
is how you define security transfer
what's the example so when you start by
defining your rules very simple example
yes from one goal here I will start with
your resource collection so in this Sun
columns of every sauce collection as 0
so the you know 506 find the password
now I'm say on protecting that method
and I also want to take a post member
and the authorization constraint is HR
is only
is that so
or you could leave it open if you want
let's look at the correct otherwise it's
an interesting connotation where is it's
typically used in conjunction with
programmatic secure it's very similar to
the sticky okay roll that we just saw in
the XML it's best to use to declare a
security role for a specific class so
you have service activity so this is a
very similar they have the same
connotation as security constraint that
that we saw it directs them all but it
can be applied to a server to define
different specific constraints and we
have a history to be constrained so this
is basically there is no tag put this
for a specific we don't have any history
method or metal permission then how by
default everything is protected that's
basically what it does in some
sanitation's so you can also write
to a particular matter method that we
can use it if you method constraints are
and there is also annotation called one
as which is used in security propagates
subject propagation between the back
tear on the DJ region example so you
solve it and you all fucking for the
Soviet girl and you start with the
select security so one of the things you
can do in is if you constrain need in
also specify the transport directly as
well we come over there but what I'm
saying is interesting here is you say
the most allow is miniature but we not
say what method we are talking about so
what happens is that any history to be
met that in this servlet can be accessed
by a minute if that's a constraint so
you can also add specific method
constraints which state precedence over
the significance plane so first times
that we bring is the get method can only
be accessed by Pichardo and we also say
we say in the placement that but you're
not saying what Kalitta what that means
is that anybody can hello can act as the
trace method we can also do something
like this where i the method as delete
but I this cleaner by the flag saying
I'm table semantics is gonna so I'm
basically reversing the meaning of the
empty roll say do not allow anyone to
access the delete method so in somebody
what's happening here
that no one can actually believe under
the Trade Center can be accessed for
anyone the get method can only be
accessed for HR and can be accessed by a
miniature so how do we do programmatic
all the way she left here so cockpit
cover a few API is in the H typical
request so there's still more one that
they get remote user base predictions
the reasoning of the currently logged in
user allocated user and you know the
principle basically determines the
principle of the representing the user
or the fighters for entry box business
security package and the also a method
called is user Enzo which basically test
if the users current user he has a rule
that is quite an example so you have
again a simple servlet so we have to
declare row so earlier mention that
declare rules allocation is used in
conjunction programmatic authorization
so basically for you
karthick briefly vegetable
continentality non-repudiation so
basically it's a way of protecting the
data that is communicated between the
client and the server and also making
sure in terms of non-repudiation
we can basically confirm that whoever is
claiming that they are they can
basically be asserted so you can use
history TPS to secure the communication
so it basically uses the Secure Sockets
to try as a transport layer and it
basically encrypts all the data
communication between endpoints so you
can achieve non-repudiation again so
when everyone identifies sowe're but
then how do you identify if the client
is who which says it is so that for that
you can use the client certificates so
we kind of looked at the transport
grantee element in web.xml that we said
we're gonna talk about later that's the
element we can use to ensure
confidentiality non-repudiation in our
application so it basically takes on
three values which is confidential or
integral or not so confidential
basically says that the data is
protected and the integral value
basically says that the data is not
tampered in the way but then there is
only one it is typically one way of
achieving it which is basically using
SSL so in Java EE typically they have
the same meaning it doesn't really
distinct there much between what they
really do they do the same function so
again you can just use this identity tag
in the web.xml like we saw earlier and
if for some reason in your application
if you had to verify how the request is
coming in what scheme it's being used
HTTP or HTTPS you can do that using a
get scheme method on the request object
okay auditing again are we all mostly
familiar with filters so filters are a
great way of hawai doing auditing
inside the web tier on Egypt interrupt
here they can basically config filter
and you can basically write a simple
filter which basically locks our
question response but one thing we're
not talking about is a vendor specific
stuff so basically a glassfish has a
rich logic mechanism for auditing so you
can basically see who is logging in who
is logging out all those things are
available readily in class-based you can
do a lot of configuration and tuning of
that as well if you wanted to and there
is also a custom API class called audit
class that's provided by class-based and
similar stuff in other vendors as well
which you can use to write programmatic
or auditing more sophisticated origin or
easier on it in yes so call it your
service again I've caught the kind of
mentor this also briefly so it's
basically a way of making sure that high
quality of service is provided to all
the users that keyword is all so it's a
way to ensure we need to try to ensure
that as a user a particular user or a
set of users are not depriving your the
rest of the users of the resources that
they need right so one of the things
that people typically do is the denial
of service attacks again you're not
gonna go over everything that you can do
to stop in on so we said that it's so-so
but some things you could do here is
because what people are trying to do is
they're trying to basically consume the
scarce resources that are available like
network bandwidth CPU memory things like
that so it could basically in
architecture one thing you could
possibly do which will help is trying to
identify different classes of users and
trying to segregate the resources for
appropriately so one group of users do
not affect others so you can also all
prevent hypersphere from basically
injecting malicious code doing things
like a site scripting cross-site request
forgery and there was a really good
session um about this kinda stuff more
detail onto cross-site request forgery
and stuff yesterday
Masoud and mike did this talk yesterday
i mean that table should be online
sometime later so i recommend you to
check it out and so basically just to go
will find details it's you should never
touch a client obviously so you should
assume that all clients are bad clients
and assuming that you validate all the
input that your application receives
from the client for different aspects
like correctness the type format whatnot
and typically an application if you have
any
access control mechanisms try not to use
blacklisting why is whitelisted meaning
completely seal it off and open it up to
people who need it
instead of basically saying it's open
and then I'll blacklist this kind this
kind this guy so it's probably it's a
better approach to doing security and
try to escape all the input for our HTML
and coatings and things like that so you
don't basically get execute malicious
code on your application and also
likewise when you send out output try to
encode that as well
so one more thing typically you want to
do is again this is all going back to
the basics trying to protect your
internal details of the application come
other people so try to use suicide
comments if you're doing that use AJ
special comments how mapping pages for
exceptions and errors so there's a lot
of information available on this the
Kartik actually did a couple of blocks
viewers earlier at JavaOne on the series
your hacked so first stop was in 2004 it
was ten top ten secrets or for securing
your veggetti web applications
and he did a talk in 2007 as well which
is more about ajax security so both the
talks including this one will be
available or available actually at your
hat comm for you to download if you're
interested all right let's talk about
EJB tier security so we probably saw
they see this area diagram all for third
time here but also what we have what's
happening here is so when you talk about
authentication in the EJB tier so it is
typically two ways of that happening so
the users log in to the web tier and
then they try to access the
functionality of the end EJB tier
via the web tier in this case the
container basically makes use the
subject propagation is happening
security context is being propagated
from the web tier to the EJB tier so
another way of doing that is you might
have an application client container
which is a ezb client standalone client
that's trying to access the EJB tier
directly even in that case the east
application container the ACC basically
has mechanisms to do authentication and
once it basically passes the
authentication when it makes a call to
the EJB tier then it propagates a
subject our security our propagation
happens
similar to the EJ bit of prep tear
propagation so the authentication on the
application client container is very
vendor specific all the configuration is
vendor specific there's not much origin
in the spec about this so it's I'm not
going to cover that as part of it in
this presentation because we're trying
to just tell us ee rom so if in case you
wanted to do a programmatic
authentication of then just as an
example blasts which has a way to do
programmatic authentication on the web
tier on the edge a bit here as well it's
very vendor specific so that's the class
that they have and they have couple of
methods were login I mean they actually
have four to four back tear into for AJ
beat here so you can basically pass in
the username and password or optional
you can also pass in the around the
errors boolean as well it will basically
establish the security context if the
username and password match the ones
that are in the realm and you also
obviously have a logout method which
will attempt to log the user out
basically opposed to security context
established all right let's look at
other ization declare a to otherwise in
using aj vji or XML so and just like you
do it in a web tier even the ej bit here
you need to specify what roles were
trying to work with so you need to
specify all the roles that are good to
be used in the EJB it here so once you
do that then similar to what we have in
the web tea or web.xml very have
security constraint we have method
permissions here so in depth here we
were talking about how to otherwise at
the level of the granularity of a HTTP
method similarly in the EJB tier here
the granularity is an EJB method so
we're trying to define what are the
permissions available for a specific
method so we start with a user friendly
description and we start with a kind of
a little bit different from web tier so
we start with a roll name it can have as
many rules as you want so you say what
roles we're trying to permit or you can
optionally say unchecked meaning you're
trying to open it up saying any other
indicated user can access my method
which we are going to mention in just a
bit so you either specify a list of
roles I say I'm saying okay anyone can
access it as long as they're
authenticated that's fine so you can
specify the issues beside the name of
the ujb that we're talking about and the
method name you could also do a
wild-card
you're saying star meaning it applies to
all the methods in the ajb and if
there's any parameter signal satisfy the
matter params as well so there's also a
feature called exclude list which
basically says no one can access this
again I kind of didn't pry the same
thing again but it's the same tag as a
both the method tag we apply the EJB
name and the method names and method
params but basically what he was saying
is we don't specify the role here
because he's saying no one should be
able to access this typically seasoning
it's not very widely used it's used in
case where you have the functionality
written but you don't want to use a
functionality in this particular
deployment we said just don't learn I
didn't want to use it okay let's put an
example so in this case what I'm saying
is the rule name unit or anyone who is
authenticated with the role manager can
access the hire new employee method in
the payroll service I'm ignoring a few
tags you're like the description name
and stops just to make it succinct and
the next one says the HR role anyone who
has the role HR can access any method in
the payroll service EJB and here I'm
saying
no one can fire all employees just can
happen alright so there's a few more
types that we haven't looked at or we
aren't much detail run as so sometimes
you may want to control what the EJB
tiers are some when some functionality
is being run as you want to say this
functionality should be run only as a
particular role regardless of the user
that's currently authorized so it could
be a sub role it could be a different
permissions window I mean this is not so
widely used as well but you can specify
the run as in the security identity or
you can use a run as annotation as well
on top of the EJB or the source of light
as well actually and there is also
something called use caller identity
which basically says use whatever
identity the caller has just propagated
here all right let's look at declare it
authorization using annotations so we
looked at a few annotation in the web
tier and in EJB tier there's some
overlap but there's three major
annotations one of them is roles allowed
so it basically takes enumeration of
roles a list of roles basically which
can
applied to either a class or a method
and obviously applied to a method it
basically says what all the rules that
are allowed to access this method when
applied to a class it says all what all
the rules in access all the methods in
that class so there's also a permit all
annotation and you know the name implies
it basically says that any role in any
authenticated user with any role can
access this specific method or all the
methods in the class depending on where
it's applied to like whereas that's
opposite of it which is a deny all so
restricting access from everyone and you
can also use the declare rules
annotation on the run as annotations
that we saw in the bacteria they have
the same meaning here as well let's look
an example so here employ a service
class we're saying the rules allowed is
restricted users so basically the view
employee info method can be accessed by
any authenticated user who has the role
restricted users and hire a new employee
we're saying the rules allowed his
manager so any authentic Ettore user
only authenticated users with the role
manager can access the hire new method
likewise provide feedback we're saying
any other indicated user can access that
and same example fire all employees no
one can access that let's go get
programmatic authorization in the EJB
tier so EJB context has a few couple of
methods which based cloud with the
programmatic authorization one of them
is get color principle so basically i is
used to obtain the security principle
that represents the identified that
identifies the currently logged in user
and you can also use the east coloring
role it's kind of similar to the ease
user enroll back at the web tier
basically tested the current user he has
the rule that we are just looking for an
example so let's say we have our payroll
bean and we say in the declare rules HR
so we're gonna use a roll HR in the is
user in row so we'll see that so in the
update employee method infer method is
trying to get the principal name we're
trying to figure out who is currently
logged in and we're doing some database
stuff to retrieve the user information
by getting the name of
simple and then we're trying to compare
what is what's happening is we're trying
to compare the current cell rate of the
new cell that were trying set and in
order for us to set the salary what
we're saying is that the user that
currently logged-in has to have the role
payroll if not by throwing a security
exception if yes we will proceed with
the for business functionality so again
try to use a declarative security as
much as you can but there might be
instances where I mean this can be done
perfectly way decorative as well but
they might be instances where you want
to limit by let's say time so payroll
can issue paychecks between 9 a.m. to 6
p.m. Pacific time that's it they can't
do it before or after if that if there's
something some hypothetical constraint
like that then you can't obviously do
that we decorate too
that's when you will resort to
programmatic auditing again like filters
in the web tier you can use interceptors
in the EJB tier which provide a nice way
of auditing again I'm not going to go
into too much detail of oil interceptors
itself but there's nice annotations
available to do those as well so at
interceptors is an annotation to use the
apply interceptor to ajb and it can
basically write your or aspect
functionality using the ionian vocal
orientation okay stop what yes dear ok
so we talked about securing the web tier
we talked about securing the ejv the
business logic tier and now let's talk
about securing the EIS tier right so
basically the idea here is that you have
your application server which has the
web container the EJB container but the
reality is that your application server
also has these integration services you
know database services messaging
services it may it may want to access
other services that's on the that's on
the internet or within your company so
the idea is here in this particular
section is how do we protect this and
what are the kind of things that you
want to keep in mind there so the first
thing is you know stealing stored and
transient data many security compromises
or because applications store and
transmit data and plaintext
right so and so really the concept is
you need to encrypt all critical data
passwords cookies hidden fields whatever
you know whatever is important now I
mean I say encryption here I'm saying it
at a very high level we understand the
difference between you need to
understand the difference between
encryption which is two-way vs. hashing
so for example passwords you want to
hash and the second thing I've seen in
many places is people try to invent
their own algorithm oh yeah I'm going to
take this and multiply it by 17 and add
45 and you know don't do that you know
don't admit your own encryption
algorithm there plenty of good
algorithms that's out that you do it or
not I've seen it you know we do one my
review and we like oh really you think
nobody can find that okay so try to make
sure that you use a library and you know
if you think about it the Java J SCC
library has a bunch of encryption
algorithm built into it and you may want
to use that okay so now let's talk about
protecting the databases itself now in
your application server you have data
sources and then you have your you know
your your configuration the database
connection pool and things like that and
of course your database itself should
have a username and password associated
with it try to use the application
server configuration to configure your
applications data sources because they
actually typically encrypt the password
they keep the password an encrypted
fashion rather than you keeping in some
kind of a file in in clear-text
the other thing is if you're using
databases this is true for pretty much
any application that is whether it's a
web tier that's accessing the database
or the EgyptAir accessing the database
if you're trying to talk to the database
prefer using JPA
for current operations because what JP
is do is they try to prepare generate
prepared statements or if you want to
write your own sequel you know try
prefer using prepared statements let me
give you an example of why for example
let's say that you you want to you know
take the username it's a very simple
example in example of sequel injection
where you try to take the username and
password from the user and then you want
to build a sequel statement so if you
look at the sequence statement it says
select star from users where username
equals single quote and then your ESR
which is a body that you got from the
parameter and then the password and
password equals whatever the password is
we'll consider what would happen if the
username was single quote space or
equals one equals one - - and the
password doesn't really matter in this
case it's fubar one when it's all put
together it looks like this select star
from users where username equals single
quote single quote or one equals one and
- - anything after that is interpreted
as comment by the sequel interpreter so
now you have a statement where username
is empty string we know it's not going
to happen but it has or one equals one
which is always going to be true
so you just retrieved all the records
depending upon how you wrote the logic
you probably allowed the user to log in
so you want to use prepared statements
again JPA does that prevent statements
for you but if you yourself you want to
do this now of course using prepared
statements as many other benefits for
example it's performant it also helps
you to have Irish names like O'Brien o
single quote Brian or o corn or whatever
you want because if you do the
concatenation yourself those things
don't work so even functionality wise it
doesn't work well
protecting message queues so you know
data comes in from the client it could
be through ap I could be through the
form interface whatever it is your
application server picks up the data and
may decide to take that data and put it
in some kind of a message queue it may
you know massage the data maybe pull
some things out and put it into a
message queue that could be consumed by
other services other integration
services that you may have within your
organization and if this services pick
up the message from the message queue
you get into a situation called poisoned
messages in messaging so if you put a
message into a queue and let's say the e
is tear all the MD be the message driven
bean tries to pick up the message
typically does it in a transactional way
it starts a transaction picks the
message up processes the message but the
message could not be parsed because
there was an error in the message so
basically let's the transaction go the
message is put back
and then the next message driven bean
comes in picks up the message and so it
keeps on doing this thing if you ever
notice your application server has
something called a net letter Q that you
could configure or many of them have
this and the reason for that is because
they're because of this because you
could put a message in and it becomes
what is called a Poisson message and
your missus German bean is just simply
churning through the same poisoned
messages again and again and again so
you want to make sure that you validate
it and the validation is very very
critical over here right we heat we
talked about validation you know
especially if you're writing HTML
javascript code and the client-side
there's this validation confusion Oh
while I did an HTML Javascript well you
gotta validate an HTML Javascript you
are validating the web tier and you
probably should even valid it in the EJB
tier because it's completely possible
that you may have clients within your
company that may access the EJB TR
directly and also when you may put
messages in the queue you might want to
configure the queue to have certain
sizes because you don't want somebody to
put in a 10 megabyte message into a
queue protecting integrated systems now
many times you know your application
would end up talking to some kind of an
system within your company a service
within your company it may end up
talking to a service outside your
company maybe in the cloud
so in that case you'd open in connection
to that particular site you want to make
sure that you're using SSL to do that
you know make sure that and if you have
to use client you know client search use
client search use JSC so that you can do
an SSL communication and the other
interesting thing about ejbs and it's a
you know less known fact when you
actually have ejbs many application
servers have this concept called max
beans and pole so you know for example
if you have an application server that
is going to be talking to an app to a
mainframe system and you can only have
15 connections to the mainframe system
because of the limitation there you can
actually set max beans and pool for that
particular stateless session bean so
that no matter how many requests that
come in be a lot of you know you know it
doesn't only be 15 beans that are in the
pool so only 15 connections will be
established to the application server so
if there is even a denial of service
attack that takes place in your
application lots of requests coming in
at least you're not
forming that particular request into
your internal systems or external
systems I mean I there was a situation
where somebody made requests to us and
we didn't do that and we were making
requests to Google and Google was like
wait a minute why are you sending so
many requests to us well that's because
we didn't actually limit our resources
on our application server through a
mechanism like this
okay so funny is gonna talk about some
of the challenges with this all right
let's look at some challenges or
limitations that we came across in Java
a security so one of them is there is no
out-of-the-box support for sam'l based
authentication if you guys if some of
you are trying to do single sign-on so
that you could do it but you have to
write code yourself to support that so
it's not out of the box that's one
limitation I see and so cotton web
applications there is no concept of
remember me in Hawaii so let's say if
you want for sister sessions or if you
want your users to be able to use
remembering functionality then you have
to resort to programmatic
yeah but if you wanted to support it for
use we there is a balance between
security and user friendliness right so
the more secure application is you're
basically giving up little bit on the
user friend s so depending if your
application needs it it's not there so
it's always good to have something Oh
error messaging so if the authentication
fails there's non-rich error messaging
it basically like for example form
identification it just takes you to the
error page so it will be nice to have
some little bit more error messaging
that's not there and for you all log out
so let's say you want support a logout
functionality for first but basic and
digest you can do logout you have to
close the browser for the session to for
it to for you to basically lose the
session so you basically can do it
but then if you take form of the
indication you have to go to the code we
saw there has to be a servlet which
basically does a log out which session
you'll add a session or basically cause
logout method on the request API so
you'll nice to have some kind of a URL
pattern just like je security check if
you have something like j logout which
basically automatically does that will
be easier then there's no support for
our limited support for regular
expressions for URLs so back in the
security concentrate in the web tier we
said the URL pattern is for example
payrolls last R so that's okay but then
if you want to put a regular expression
in there saying something like secure
secure star secure sometime you really
can't do that
if the specification does not support
that and linking the groups principles
the rules happens or is very vendor
specific so cut takes you an example of
how you can do that in glass fist
web.xml so the gain that kind of when I
put our limitation on the portability of
it because you're trying to do vendor
specific stuff and you're not able to
define again this probably is a very
connor case so the rules are being
defined as part of your web XML or as
part of your application use and declare
roles so it's actually in the code so
yes the application is running tomorrow
if you want to add new roles so if you
want to just remove a role altogether
you can't really do it on the fly you
basically how to change your code to do
that so it really nice if it was
actually in
itself or somewheres in the division if
you can define it are very nice so
that's my thought on that
so in summary so we all I hope you all
agree that security is a problem and
basically more and we're in for the
applications moving in the cloud so it's
basically it's only going up to secure
tor is only going up and July II
provides several security mechanisms so
it I think it's important to understand
what it all first and so you can use
them efficiently and always think
security first while building software
keep security in mind thing toxic your
platform secure designs that you
developments like your testing and
secure deployment there's a few other or
security related sessions in this gel
one conference or which are not done yet
so you know if you're interested you can
basically take a look at those sessions
and thank you for listening
and one thing we request you is we would
like to know how you feel about the
session or what is it that you're
looking Fury or really obtain what
you're looking for so please take a
couple of minutes to give feedback on
the schedule builder so we know exactly
how we did thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>