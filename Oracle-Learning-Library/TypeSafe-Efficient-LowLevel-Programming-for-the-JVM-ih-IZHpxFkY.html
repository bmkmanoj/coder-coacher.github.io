<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Type-Safe, Efficient, Low-Level Programming for the JVM | Coder Coacher - Coaching Coders</title><meta content="Type-Safe, Efficient, Low-Level Programming for the JVM - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Type-Safe, Efficient, Low-Level Programming for the JVM</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ih-IZHpxFkY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning welcome I'm not sure why
you came so I try who came for typesafe
okay who came for efficient and who came
for a lower level okay let's see if
motivation what does this mean
yes some of you programmed in I don't
know if it's Pascal or whatever language
so it it could mean not equal or equal
or whatever so most of the time we divas
programming languages which are non
intuitive so we don't know what their
what the things mean
another thing is a font of who users
still fixed-width font and his editor
like Cuvier or something who use how you
say proper proportional font like Times
okay this is if you still use a fixed
width width font it's like using a punch
card because this is a thing we did 5060
years ago now we have different devices
and we can change things and we should
use them so this is another example now
in the proper font what does this mean
at the java programmer you would say
this is an assignment if you ask
somebody coming from from school he
doesn't know that this is an assignment
so again things are non-intuitive but I
wanted to do almost 20 years ago is to
have a new programming language which
supports what I know from school which
is mostly mathematics so this means X is
equal to 2
and not two will be assigned to X or
whatever and we now have Unicode which
means that we can use our tools or
characters which are more precise in
this case it's simply says exist not
equal to two so this is what I wanted to
do now 20 years later I'm allowed to do
it I'm allowed to write a programming
language because I can there are several
other people who have done it and I
don't know if it's good for anything but
I can do it and so I'll try
in 1992 I read an article from a guy who
said that a programming language is
independent of several things
and the things are the machine the
problem the humans and the time so what
I wanted to create is a language which
will be independent of the machine
independent of the problem independent
of the humans who will program with it
an independent of time this is of course
not possible but I try my best and he
defines what independence means and one
thing might be interesting he for
example said run any program written for
one architecture on any other
architecture so this was 1992 and you
remember in 1995 we had Java and Java
had the promise write once run anywhere
so it seems that some of these goats are
possible and so I'm still optimistic to
achieve my goal that you know why I
created the language is it's a whole
family and the idea between of this
family is that you can address several
problems and I want to use only three
different syntax elements the first
element is a keyboard followed by a
token list I don't know what they're
talking mean the program the compiler
extender has to define what this means
for example you know the important
so it's followed by a package name and
the package will be important
another thing is a block statement it
starts with a keyword it will be
followed by several tokens then there
will be a beginning keyboard and
everything will end by an end so you as
a Java programmer will say we are the
curly braces I don't have curly braces
for this purpose because I wanted the
things to be similar in every level and
then of course I have expressions which
as a function calls or something else so
let's take a look at an example you have
a namespace and you see the tokens are
like you are a URI so it's a little bit
different than in Java but then you have
a function the function gets integer
values and returns an integer value you
see there's an assignment the assignment
with the column means that it's also a
definition this type of here and so we
know that Z will be properly in it then
you see a block by the way the function
of course is also block you see it
starts with a function at the begin
kavadis is within the is and the end is
the block whatever the block does so for
function we know there are instructions
commands and you see the if so it's
again a keyboard and if it keyboard is
allowed is defined by the block so it's
fairly simple and it's extensible if I
and and for example if you want to add a
try and catch it's very simple you
define a new syntax element which starts
with a try and then you define the rest
in a special manner the funny thing is
that syntax elements can be imported
which will avoid the problems Java has
if they introduce new elements you
remember the enum thing and you simply
can say import enum and then the in
herbs are only available
you have imported them so that's a plan
I have several levels and the one level
is we are interested in is that never
one this is because we only do things
which can be managed by a virtual
machine for example the Java Virtual
Machine on a lower level we have things
like
give a pointer a specific address for
example you have a device and you assign
the address of the device to the pointer
this is not this is not possible with
Java so we have to admit this and on a
higher level we have things like control
structures like if and and so on because
the level we are talking about is
strictly based on the virtual machine
but we will see that so what we can do
in this several levels is especially in
the other one we have managed memory and
level 2 we will have control structures
records and so on and in level 3 we will
have object orientation and so on we
have of course object orientation also
and the level 1 but in a lower level
manner ok so it might look like this we
have the JVM at the bottom and above
that we write our code if necessary we
can also use the lower level and what I
plan for the future is what Java also
tries to do is that you can use the CPU
without using the JVM and without
explicitly using the Java native
interface so if you need any special
things from the CPU you can use them by
using the level 0 and you don't need the
JVM for that and you don't need to care
about the binding we are giant J&amp;amp;I
another thing which i think is very
useful is that you can have some sort of
protections so if you don't want your
developers to work with the level 0 you
can simply say you are not allowed to do
that I think this is very important
because if you have pointers the people
will use the pointers
even if you don't want it so you can
simply say this is privileged and you
can only use it if you have the proper
privilege and you see that an
application can base on the several
levels so you have higher level things
lower level things whatever is needed
for your application
okay now let's go started last thing the
file format is a binary format if you
only use the text you can still use it
the normal text editor but usually you
will embed pictures and so on for the
documentation and so there's a internal
file system and the internal file
systems allow us to store those binary
data what I think is very useful is that
there's a supported version and the
compiler options are embedded in the
file so this is very useful if you have
special algorithm which requires special
options then you can put the options
where you need them and not yeah if you
don't know that you have to translate it
was a special option then the
information might get lost so you put
everything in the file even if you like
to the version history change lock or
whatever you like to do okay who deals
with byte code okay for everyone else I
have a short introduction how the JVM
works and why I've made this level one
and yeah the JVM is a a sect based
machine this is very useful because if
you've read the byte code you can do it
very quickly and you can build a syntax
tree very quickly so the byte code this
is a very good idea let's look at the
next example if we have a small class
here simple in the simple class has two
things one method F which simply does
something and one method half which
divides the given parameter of by two so
fine then we have a main and the main
creates a new simple then chords the F
method with 37 and 44 if you translate
this we will see that the main things
stays the same so we have the signature
above it's the same and it will be
encoded in some manner which is not very
interesting but necessary if you have to
deal with byte code and you see here the
byte codes so it says I load which means
that the int will be loaded from the
position 1 I will show you in detail in
a short moment and you can see if you
have little instructions on the left
side you have little instructions on the
right side let's take a look at the
other thing you see now it's becoming
more complicated because we have local
variables we call a method and you find
this all here in this bytecode just to
show you how this work the main the main
method is more complicated because long
things are standing here this is because
if we could use a static variable then
we need to define which field is used so
for example if you look at the
instruction 8 get static number of 28
and the number 28 to refer to the
constant pool in the byte code the
constant pool contains all the strings
and all the information the meta
information needed to run the program
and you see that the position 28 marks
the field the field Java long system out
and this is of type Java IO print stream
whenever you deal with the object then
it's surrounded by an uppercase L and a
semicolon so we know what this means
above you for example see the init
method the init method has a special
name surrounded by those angled brackets
and you see it has no parameters because
the parent e this parenthesis are empty
and it returns nothing
so it's void so this is encoding and
it's quite interesting below there you
see the
f is a method which takes two integers
and returns an integer we are only
interested in this part we will take a
look what happens if we run our code
from instruction 11 so first we load
from somewhere an address and we put the
address on the stick then we push the
value 37 onto the second than the value
of 44 and then we call the method F the
method the method F is from the class
simple and because we are in the class
simple the main routine is in the class
simple we don't need to say where to
find it because the bytecode the class
says use this method okay now something
happens and I don't know if the various
will be copied or whatever but for the
chord function it looks like this we
have the address and it has the name
this in our Java program and it stands
at the position 0 then we have the 37
this is in our program ik x and it's at
the position 1 whatever that means
so our stack is now accessible and we
can explicitly excess of the values 0 1
2 &amp;amp; 3 the three we know because we had
one local variable R and this local
variable now is on top of the stack and
we can access it with the number 3 we
can't do anything else everything else
is just stacked and we know that because
every method has to give the information
about how large the stack will be and
how many local parameters are used and
the parameters from the function or
treated as local parameters ok so let's
start first we load the value at
position 1 so the 37 is on top of the
stick then we load the second element
which is the 44 then we add both and you
see both elements has been
removed and the recite from the head
function will is on top of the stick
then we store this element at position
three so we can read it later then we
posted the address under stick then we
load our stored 81 and now we call the
function a half we don't know what the
function half does it works the same way
and the recite will be pushed on top of
the stick so you see the address and the
parameter has been will have been
removed and now the result is on top of
this second and now we store this
element in our local variable then we
load it again and you see in if you take
a look at Java bytecode you see a lot of
things you might think are not necessary
for example we made a store and then a
load so we could have omitted this but
the Java compiler is let's say not very
bright so he says let's do the thing in
a very simple way but the just-in-time
compiler is very clever and he needs
simple things to make more optimizations
this is a problem we have if you try to
write code in the assembly language then
you have to be very careful what you do
if you are too clever
then the just-in-time compiler cannot
cope with whatever you have done and
cannot optimize it as good as it could
have been if it had been a little easier
okay then we pushed 50 then we compare
both elements and now we remove both
elements and decide if the first element
is greater or equal to the second and if
the element is greater equal then we
jump to position 19 but because 40 is
less than 450 we go to the next
instruction we push 50 again and we
return 50 so now the 50 is somewhere on
the stack of this
is the stick-frame is not needed anymore
and so we return where we came from
and we remove those elements and put the
50 on the stick so that's how the Java
Virtual Machine Works and the bytecode
is pretty straightforward it's very
limited we have several methods for
several instructions for int for long
for double for float if you have to cope
with bytes then you have to translate
the byte to an int you sign extend it
and then you work with an inch and then
you have a method which allows you to
shorten it back to a byte and then you
can store the byte wherever you need it
to be for example in an array otherwise
you simply work this inst this doesn't
seem to be acceptable especially if you
want to do yeah other things for example
if you want to check if and if you have
an overflow this is very annoying if you
have to do it in Java or you want to
have unsigned arithmetic so this is also
impossible in Java so I said I will
build an assembler which allows me to do
everything I need and I will put it in
the proper byte code and I assume that
those byte codes I create are optimal so
you want to solve a problem by using
unsigned values you can do it and I
promise you I did my best that you don't
waste any time doing this okay let's
take a look we have data segments and
the data segments are like static
variables in a class the advantage is
that you can put things in an arbitrary
order and if you take a look you see
that a sequence of byte and the sequence
of bite means there is a sequence of 20
consecutive bytes lying there however I
do this it's not a pointer to an error
whatever in our model this really means
we have 20 consecutive bytes this might
be useful for you if you need a special
special initialized data then you can
simply use it because you know the first
20 bytes are the greetings sequence this
example is not very useful because we
have strings we can use every Java
function we like and so we could do it
in a better way
but let's simply assume we have a
function print which like in C uses
every character until we see a zero byte
and then you use the target operator for
the greeting so they have the address
and then you give the average through
the print at the print will go through
the byte sequence until it sees the zero
in most of the cases you will use simply
logic Java stuff so if you have let's
say a real string then it will be a
reference to the string so four bytes
will be reserved for this string yes
yeah because I change it and for the
 up to change it change it just
before I started the presentation in the
earlier version everything in this level
was a callable it seems to be very
useful to know if a thing also on this
level has a side effect or not
so everything is a callable but the
function is a special callable which has
no side effects a procedure is a special
callable which has side effects which
the print does sorry here the same
problem okay if you deal with this
low-level then you have new problems
which you hadn't before for example if
you read an INT in java it is a hint if
you have now access to the memory the
order of the memory is important for
example if you say i have a data segment
with 4
security bites the first part has the
value 1 the second part has to value in
X 23 and so on and now you access this
as a tetra tetra means 4 bite so if you
load it and you start at address a zero
then all these things will be
interpreted in some specific way and you
don't know it if you don't know on which
kind of machine you are if you have a
little endian machine the way to baby 6
7 5 4 and so on and if you want a big
endian machine your value will be 1 2 3
and so on so this is very important and
this might be a problem so the language
might be type safe but you can do a lot
of errors if you don't know what you're
dealing with so if you want to make sure
that your program will only run on a
machine where you have a big-endian
order then you simply can make an
assumption so you say assume config byte
order is big endian and if you try your
program on a machine which has not this
byte order it says sorry this wrong
it's the same if you want to run the AWT
and you are on the machine where there's
no a no screen then it says to you
here's an a WT error because we are
headless ok let's see how a program
might work I have a program which finds
0 l word and we can do it by twice but
this is very slow especially on a 64-bit
machine it is more efficient to read the
64 bits and then try to figure out where
the zero is instead of going there pipe
a bite because if we to the PI twice
then we have to check a times and this
seems it doesn't seem to be a very good
idea so this is an example for
rhythm which marks specific bits and we
take a look at this we have a mask and
this mask looks like this so we have
almost zeros but on every bite the most
significant bit is zero then we add this
mask to our original value and you see
that we will sorry we end this mask and
so you see the most significant bit of
each bite is still zero
and the rest is unset unchanged now we
add the mask to it and we will have an
overflow you see it here we have an
overflow whenever there is a set bit
because of because of our masks with the
addition one bit will be propagated to
this most significant place then we are
it sorry then we are it to have the
first bit which we eliminated in the
first instructions then we audist
then we are it with the mask and you see
that we will have all ones if here's a
set bit and all zeros and the most
significant bit is zero if there's no
bit inside it you see this is a
different kind of thinking and if we
invert this now you see only one bit a
set and we don't need it if to figure
out the specific place if you do this
this is a whole new world we can do of
course everything we did here we can do
in Java but Java doesn't seem to be the
right tool for doing this if we go to a
lower level then we go to a lower level
which means we manipulate bits we try to
avoid
comparisons because a branch is very
expensive a mispredicted branch is even
more expensive and so on okay now we
have a problem we have marked our bits
but we have to cope if we are in a big
endian machine or a little any machine
because this bit will be on a different
place if we have another orientation
because we have our bytes we want to
find the correct zero byte but if we
load the bytes in words tetras octaves
of is 4 bytes or 8 bytes then the order
might be in the wrong place so we have
to cope with it and my language offers a
possibility which is a variant it's it's
like and see if you have those if steps
but you can only print you can only have
correct code the problem is with if is
the if deaf and see is that you can also
put in things which are not valid for
itself when it see fragments and so we
have a possibility to define different
algorithms which depend on specific
preconditions so we have two variants
here we have a big there big endian
variant and a little endian variant and
if we take a look at it we see if the
conflict byte order is big endian then
we use number of leading zero bits to
find out which is the correct word the
correct offset in our byte stream and if
the byte order is little endian then we
use number of training 0 bits to find
the correct offset so for the proper
this is static so for the proper machine
machine do you have your assumption and
then it will be translated for this
specific machine this is not anemic so
if you have your Java program on you
learned on a wrong virtual machine it
won't work ok types
these are the types I have I could have
given them proper names like machine
worth like integer like unsigned and so
on you can still do it because these are
only abbreviations so we have machine
boots and machine words are always
peopIe words where P is a power of two
so we have for example a byte which is
one byte we have a void which is two
bytes for pride eight bytes sixteen
bytes and this is unlimited so if you
need a word with 128 bytes you can have
it and especially you can have an
addition multiplication division and
whatever function you need is available
if you need 128 byte words so it doesn't
seem to be very useful because it's not
very efficient 128 bytes are very hard
to load but it's possible you don't need
to care about it so if you need 128 bits
it's not easier then you have 16 bits of
let's say it 32 bits 32 byte words this
is something you might need and so you
don't need to care about them we have of
course machine words are bit patterns we
don't know what they are they have no
meaning they simply have bits the
integer the then the bits will be
interpreted in a proper manner and so I
will have integer values which might be
negative unsigned the bits will be
treated so that I have unsigned numbers
and so on I have a special type there
the J type this ensures that I only have
values which fit in both unsigned and
signed values because it reduces the
number of methods I have to offer then
we have a float and decimal decimal I
haven't I wasn't interested in floating
point and decimal point arithmetic yet
but this will follow soon the decimal
will be oriented at the
the new attribute attribute is standard
so if you have a decimal format which
might be a little bit faster than the
big decimal in Java but this is not sure
but we will see and then we have the
boolean values true and false so as I
said you have special machine words with
different width and you have especially
preferred machine word which is on a
Java Virtual Machine in a 32 bit int you
have several properties coming with your
machine words so if for example I have
an m4 then I have a specific width size
and element size you see the square
brackets this is a unit so the width is
a number and the unit is bit so I
support units okay you see there are my
bytes they said arbitrarily but they are
numbered in a specific way so the least
significant bit is always bit zero at
the most significant bit is always bit n
minus 1 where N is a power of 2 for
example if we have a tetra then the
width is of course 32 bit the size is 4
by it the element size is 4 bytes and
alignment is 4 so this means if we want
to access a tetra then we must provide
an address which is divisible by 4 then
you have several other possibilities to
access a word and this might be useful
you can always access the high part the
low part you can access the by it's the
lights the tetras and and so on so you
see if we have a 32-bit tetra then you
can access the least significant byte
the least significant half you can of
course treat it as a signed or unsigned
and
I'm not sure if this is really needed
because in their better area sometimes
it's needed that you need the high byte
of the low ride and the low byte of the
high white this very complicated throws
there's a need for this sometimes but
I'm not sure if it's necessary to have
an instruction the idea is with my
instructions is that they will deal with
the common case which leads to a lot of
functions for example I have you you
will see six eight functions or
something which have different purposes
and if I know the proper purpose I know
how to translate it to the for the java
virtual machine or for any other
processor okay here's a another example
you see there's the high there's a low
you see which bits are used and so I
think it's clear okay what kind of
insurance and fractions are offered
I have everything which will be needed
for bit and boolean functions what's
interesting is I also offer a knot and
the knot is not implemented in Java so
if you want to flip all the bits in a
word you need to load minus 1 and then X
or it with the word you want to flip so
I say there's an instruction and how
it's done it's you don't need to cope
with it but there will be a best way to
do it on a specific platform so I know
to do what I know what to do in it on a
Java Virtual Machine
I have generics the generics are always
in those oxford brackets and you see
that t is a machine word of a specific
size and if you put in T you get T out
this is useful for example if you have a
signed word then and if you do something
with it then the sign to earth will come
out and so on ok then I have functions
for the number of leading 0 bits the
of trailing zero bits and so on and he
is important that you know if it's
available as a native function for
example in Java it doesn't look like
that it's native because it's there's a
integer in the integer class there's a
function it's called count bits or
number of trailing zeros and they are
they will be recognized by the virtual
machine so the just-in-time compiler
knows that it looks like a static
function but it knows it can translate
it to a machine operation and you don't
need to care about this either so if you
use number of one bits then I call the
integer bit current function and this
will be because I know it will be
translated to a machine machine in
structure which is very fast if it's not
available you can test this in one of
your preconditions and then you know in
a variant that you don't want to use the
bit count because it becomes slower the
problem is that we don't know how the
virtual machine implementers will do
those things because there is no
requirement if you for example take a
look at integer bit count it simply says
it counts and above bits but it doesn't
say if you are building a virtual
machine make sure that this is a machine
instruction and they are of course
machines where there is no miss machine
instruction for counting bits okay
addition if you want to add two numbers
we can do it and what it's different to
Java is per default I check if there's
an overflow so if you add two signed
numbers and they the result wouldn't fit
into a signed number then you get an
overflow exception sometimes I don't
want this so I use add unsigned the
downside that the add function are the
same they have only a different overflow
behavior but the unsigned will never
check the overflow because this is what
we are used to
if we do this entire things then they
will wrap around it's fine then to it
with larger numbers a big integer for
example then we want to add with a carry
so we only have let's say 32 bits but we
want to know if if we have an addition
if there will be an overflow this can be
checked very simply with order if so
this function offers you the possibility
to access the carry bit and to provide a
carry bit to have an multiverse addition
of course if you edit signed there's a
different overflow behavior as I said so
we must have a head with carry unsigned
add function and then sometimes you want
to add signed and you want to document
that this is a side Eadie but you know
that you won't have an overflow you
simply say it unchecked and the same
with an unsigned value you want to check
if there's an unsigned overflow then you
can do it so you see it seems to be very
problematic but it's always the add
function and then you have additional
properties but the add will do for you
okay same the substract division
division is a little problem because the
division might not work as you expect
who of you knows that dividing by a
power of two is the same as 50 who of
you knows that this is wrong if you have
negative numbers
okay you see that's a problem because
it's not an intuitive and so we have the
possibility to divide in several ways
and these are the four most important
ways to do it and you see you can round
to minus infinity or you can run to the
nearest you can round to the two plus
infinity or you can round to zero which
is what the Java fraction does
so if you have a division in Java it's
it usually divides by rounding to 0 this
fleets sometimes subtle arrows shown
here for example if you have those
numbers and you have those slots below
and you want to put the numbers in the
slots so let's say we take a look at to
how we get this in the slot and every
throat can keep three numbers we divide
by three okay
two divided by three is zero so we put
the two into the slot zero let's do it
for five again 5 divided by 3 as one yes
will be rounded it's one something and
it will be rounded toward zero so it
will be fun okay fine
if you do it with the other numbers they
will fit but if we do it now with minus
one we have a problem
by rounding towards zero what will
happen we want to be it in - money
because we want only three three
elements per bucket but if we do it in
the job of a we will have an error here
because this function is not symmetric
because minus one divided by three is
also zero because it's 1/3 1/3 rounded
to zero means zero and so we have in the
zero bucket we have too many elements
this is wrong and this leads to arrows
if you have negative numbers and I
didn't want to do it so I simply said ok
I will have the proper fraction another
thing is if you have for example 13
elements and you want to put put it in
boxes with each four elements then you
simply call 'roof and the group gives
you the division but rounds towards plus
infinity so you know that you need four
boxes and if you want to know how many
elements are missing in the last box
then you use the pet function and it
gives you the correct number so this
might be useful
I think it would be more useful in the
higher-level language but these
operations are offered and it's a little
bit tricky to do it based on the
division which is available but you
don't need to care about it the proper
versions are offered ok if we have
multiplication it's the same with the ad
we have a multiplication that carry
which allows us to have a multiplication
with several elements and we have
special versions which use shift
operators and if there's a machine
instruction available then we can use
the machine instruction those is what we
have to hurry up a little bit we have
shift operations the shift left the
overflow the shift left unsigned with
not overflow this is what we have in
Java we have a lot of other functions
which are very very fine ok
control we have a go-to and with the
go-to you give a label and what might be
interesting is you don't need to find
proper names you can simply say go to
one and the arrow points downwards you
know this one is needed and if you say
go to one up you know it's the one up
this seems to be not a very good idea
but this ideas around since the 50s and
it seems to be a very good idea to have
numbers of temporary labels which are
only used in a small scope please use
proper names like loop and in it for
more interesting things then we have
jump tables on the left side you see
that you need a continuous set of
numbers you can of course a mid sum but
if you switch the offset then you see
from 0 it goes to 0 0 label if the
various one it goes to the one label and
so on so this is a switch behave and you
can put annotations there to say please
do it this way or that way for the
virtual machine and another thing which
is interesting is that you can enhance
those mechanisms whenever you have a
function which gives a number which
we have some elements you get this
elements and you translate them to 0 to
n minus 1 then you can use of course at
the left side and you can incorporate it
very easily so you don't you can reuse
it and you don't need to program it
every time if you have a conditional
jump we write it like this there's no
simple instruction you simply say if
condition then go to somewhere and then
and if you cannot put anything else
there this is this if specific and it's
only to check the condition and if the
condition holds you go to the specific
place
everything else is forbidden everything
else is wrong you have also conditional
assignment you can put an assignment
there if the condition condition holds
these are the only two possibilities to
use and if in this level these are the
predicates you can use on the ready
relations like equal less greater than
and so on
there are two exceptions the use of
operators is only allowed in two cases
the one is to the Amazon operator which
allows you to have a boolean expression
a condition and it gives you the proper
bit so for example if you want to know
if there's an overflow and you have this
is a boolean condition do I have an
overflow or not then you get 0 F for
false and 1 for true you see here
there's a very efficient efficient way
to get the sign if you for example say
give me the value from the positive if
it is positive then you will have 0 of 1
and if you is abstract from it a 0 of 1
if this is negative then you have the
sign so this is very interesting in a
very efficient way assuming that you
have those machine operations then we
have the target operator which is a
special operator which allows us to get
the address of any object we have we
work with
for example you see there we have it up
in our data segment there's a variable
there's a element X it's Tetra and if we
say load and we get those the address of
X then we can of course load the proper
element okay and now I think we are
coming to the interesting part sorry
that the took so long we have points and
lines a point has two elements except ly
a line has two points if we make it in
Java we have to allocate the memory we
have to create a new object and the
object have to be initialized and so on
keep in mind that if you have a point it
extends object so this means that we
have additional information and the
additional information might be
necessary for example if you use hash
code and so on but it's in our case it's
not interesting now so a point looks
like this and the line looks like this
if we say in our Yama program give me a
line a line variable then we have some
sort of pointer and the pointer points
to align if we create one and then we
create points and assign the address the
reference to the line so this is what
the typical no object-oriented programs
we do how does it look in l1 we do it in
the same way but we don't call you if we
say allocate managed because we have
also the possibility to allocate memory
unmanaged which might be interesting so
managed code is we don't need to release
it and it can be relocated and so on
this exactly is the same as in Java and
this might be interesting for special
cases of course we can also shorten it a
little bit if we use the Cologne arrow
notation
and don't forget to initialize your
elements so if you want to initialize
your object which is necessary in Java
you simply say line dot in it and give
the address of the object to be inertial
initialized then we have several load
functions we load and store but if you
store elements it will be checked if the
value is small enough to be stored in
the specific thing I will skip this
sorry
and there are special loads for
references and pointers so a managed
memory is always a reference a managed
unmanaged memory can be referred to with
the pointer okay what I want to show you
is okay we have three ways to allocate
memory allocate managed this is what you
know from Java and it will be in the
managed memory pool and you have all the
problems you have because it's the Java
memory and all the advantages allocate
unmanaged this gives you a pointer which
has X to explicitly be released again so
we have a lock and a free and this will
return a pointer a pointer is not the
same as a reference of course because a
reference is a number which refers to a
place where a pointer is stored and we
cannot extend access this pointer this
is hidden for us but this indirection
allows the virtual machine to relocate
memory to garbage collect memory and so
on okay if we do it by ourself we have
all the problems we have a C because we
do everything by ourselves
the arrows be to releasing wrong memory
and so on you can do whatever is right
so you must have a good reason to use
this feature and the last thing is we
can allocate memory locally we cannot do
this with a virtual machine but so it
will be some sort of manage memory but
you don't see the difference so it
doesn't matter for you
okay and a-one because of the higher
levels you don't say class you say
object because we describe objects and
not classes if we describe a class we
describe something else so our object is
I'm sorry it doesn't seem to be a good
idea to change everything but the
problem is that Java is not everything
which means that if you have class this
is the way in C++ and a Java but there
are other languages which use the key
word object and so I thought it's a
better way to describe it because we
have also records and the record is one
thing so the corresponding name for
objects is object not class yeah okay so
if you translate our Java example you
see we write simply object point and
what happens is that we create a record
and this record extends object maybe so
there are additional informations and
the point name from the object is
actually a reference to this created
record just to make sure that they are
similar so if you have a record which
will be managed by ourselves and we have
an object which will be managed by a
virtual machine that we have
similarities and we can use it in the
same manner okay so let's take a look we
have a line here we have an array of
lines what will happen we create a new
array in Java then we create a line and
then we create the points so this is
what we have to do to create a line and
this might look like this
so we have our array with several lines
what we need is a lot of things and if
you sum it up you have 64 n you need 64
by it for every entry and every entry
means aligned this points plus an
overhead of 12 are
the question now is can we do it in a
little better way because if we have to
access something here
sorry then we have the problem that we
have to first access the line then we
have to access the point and it would be
nice if we can shorten it we could do it
like this we can embed the points into
the lines so we only need to create one
object but it contains two objects each
of those objects contains two objects so
let's see how can we do it we simply say
either record points so we know that
this is something which will be embedded
so our line is something this points
which are record so it will be embedded
automatically if we don't have access to
the object because point is defined as
an object we simply say embed and then
he knows that he copies the structure
and can put the elements into the line
so we get rid of one indirection okay so
this is like how it looks it looks
before no if we embed at the point but
we still have the error problem and most
of the time we deal with a collection or
array of lines so there's a question if
we can incorporate the line objects also
into the array and it is possible then
it will look like this and it will have
many advantages one advantage is the
space we only need 16 n not 64 N anymore
so it will only take 1/4 of the space
and let's take a look if we have to
access something if you want to access
the I think the Y points in each line so
we go and get the first element then we
access
the key element and then from the P
element of from Freud element we get the
Y if you want to access it the next one
we have to get the next line and then
from this line we have to get the
correct point and from this point we
have to get the the Y if we do it in a1
it looks the same the only difference is
that we have to do everything explicitly
so we say load element reference so we
get the reference of the specific line
load field reference then you get the
reference of the specific field and then
load field and then you can load the
field Y if you do it again you have to
do everything again if we can now
incorporate this then we have an
advantage first it seems that everything
is the same calculate element address so
it calculates the element of s of the
specific line then we get from the line
the specific field address which is the
point and then from this address we get
the field the wire okay and if you do it
again we have to do it again fine but we
know that we can also access these
things by pointer so for example if you
see load field address and we get now
the field address and now we can do it
with load so the difference is this is a
the pointer to the line and this is the
poem that sorry the pointer to the point
and this is a pointer to the element
because this is a pointer we can misuse
it in a proper C way you see that to
access this Y and to access this way we
can simply jump our pointer to the next
interesting point so if we know that our
data is 16 because it's for tetras then
we can simply say at 16 and then load
the element again
so this is an advantage the first thing
is we can compact our elements
they are not distributed into in the
memory anymore we can put them in one
array sequentially and if we for example
loop over those elements we can use the
structure information we have and we can
simply say at sixteen and so we can read
every point for let's say a million
elements and it sometimes it's if you
have the correct structure it's more
efficient because the things can be pre
fetched
so you have no caching problems and so
on but you have to be very careful
because the virtual machine is very
clever and most of the time those in
direction in territorial structures can
be handed very efficient and you must be
sure to use this way and you have to
test if you have the the results you
expect ok this was a lot of stuff we
have two minutes for questions yes
how I type all that you think Unicode I
have just a second I don't know where my
window went okay
you notice from vert if you type for
example - and then greater it shouldn't
be a problem I don't have the time to
write an eclipse plug-in or something
but it's no problem on the Mac you can
use for example those tables and you get
used to it
so if you need anything within a short
time and I expect that there may be
something in the editor where you can
use the mouse or you can type the things
you can type - names or whatever
whatever other questions that this is
interesting most of the time the people
ask me is your keyboard big enough and
so on so the only problem the people
seem to have is how can I enter the
information what I want to do is I want
to offer a possibility to read the
things properly for example if you use a
mathematical like notation the chances
are very high that somebody understands
something which says if blah blah blah
then and then then you make an
assignment with a arrow you of course
can learn everything and you of course
can learn everything and if you have
learned everything everything's fine so
it seems time's up
thank you for your patience and have a
nice day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>