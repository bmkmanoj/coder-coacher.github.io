<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Take Full Advantage of the PL/SQL Compiler with Steven Feuerstein | Coder Coacher - Coaching Coders</title><meta content="Take Full Advantage of the PL/SQL Compiler with Steven Feuerstein - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Take Full Advantage of the PL/SQL Compiler with Steven Feuerstein</b></h2><h5 class="post__date">2016-08-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fLMJl8GmRfA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is steven feuerstein I'm the
Oracle developer advocate for PL sequel
I rejoined Oracle back in March of 2014
after being away for 22 years from the
company obviously not the technology and
I now have a team of people working with
me working for me it's really nice Chris
are you here so listen it's really great
having people who are smarter than you
and know much more about the Oracle
database than you do working for you
because then when I'm stuck with a
really hard sequel challenge I don't
learn the new features of sequel to
solve my problem I say Chris or Kim with
Kim still here anyway so Chris and Conda
McDonald have taken over for Tom kite
and they're now running the ask Tom site
the answer site so in case you are still
going there it's those guys and they're
doing a great job and I still do PL
sequel and not much else so I've got a
blog twitter feed youtube etc etc etc
check it all out and I think probably
the best way to describe the title of
this talk is more let Oracle do the
heavy lifting if Oracle has built some
stuff for you you should take advantage
of it this is similar to Patrick
Burrell's talk earlier which is you know
get the most for your money out of the
database fully leverage what we have to
offer now the main focus on for my talk
today is the compiler and what the peel
sequel compiler gives you that you may
not be aware of but hopefully I'll also
have time to at least throw in peel
scope which is a really fantastic
built-in code analysis tool that you can
be leveraging and probably aren't now so
I don't live in the future I live in the
moment but I have to put it here I'm not
going to talk about any future stuff and
if I do I got the safe harbor in place
there are lots of resources for you know
I'm going to fix this because Brynn is
right Bryn Bryn Llewellyn is the peel
sequel product manager and it's not peel
sequel developers its database
developers oracle database developers i
know you know engineers I'm not going
there
I have I have a lot of respect for
engineers I do not call myself an
engineer and I'm sure some of you are
you might even be computer scientists
I'm not a computer scientist so I'll
just stick with developers they'll tell
you a little funny story about engineers
so what got in a plane it was really
packed and I was all the way in the back
because i miss my earlier flight or
something like that anyway 27d i had at
least in aisle seat i was very happy so
i get there there's my seat right behind
me there's a sky holding his boarding
pass this 27f and we look over and
there's this guy sitting in 27 f so we
look at him he looks at us and i find
they say could you check your boarding
pass and he looks up but he says I'm a
mechanical engineer I think I know how
to find my seat on an airplane seriously
he said that's where I go ok and then
after a little while he took his
boarding pass out of his pocket and
looked up and said uh I'm in 28 that was
pretty good but really some of you I'm
sure engineers I know I'm not and I'm
not going to try to pretend so there are
lots of resources for oracle database
developers and engineers so we have a
landing page for PL sequel you can just
start there for your new to peel sequel
you want to find out about new resources
we have the good old sequel PL sequel
forums that are well handled by dozens
of really great experts from around the
world who are not oracle employees
answering those questions for us thank
you so much as anybody here active on
the forums Patrick great thank you thank
you so much and probably the most
important blog you could know about is
the pl sequel an EBR blog by Bryn
Llewellyn so I think one of the great
events for the pl sequel in EBR
community really last year was that
Brynn started a blog Thank You Brent and
it's full of really great stuff and you
should check it out he often basically
as the frontman for the developer
organization so he'll get people on the
development team to write up some really
great information about PL sequel nebr
and then publish it through the blog so
please do book Marcus and read it
regularly and this is the place you can
go for why use PL sequel which brim
presented on this morning hopefully a
lot of you were there and this is a
great piece of information for you to
have when you're facing off against
the developers or engineers a new
organization and they're saying we want
to do it all we want to write all the
sequel what do you need anything in the
database forward besides bits and bytes
that you pull in and out with single row
processing that will be a key weapon in
your armor if you want to use military
stuff okay Oracle Learning Library big
repository of content both on our
database technologies and much more
there's the PL sequel challenge my
website for taking quizzes and hopefully
some of you are doing that now and more
of you will and today actually or
yesterday we just announced the early
adapter version of our next generation
quiz website but unfortunately looks
like we lost the Internet there we go
it's the dev gym so the dev gym is a
place you can go to do workouts on
oracle database technology you can
actually pick topics and will generate
workouts that involve quizzes and videos
and blog posts and so on so check it out
you don't have to do the workout you can
just exercise you can compete but it's a
great way to deepen your knowledge about
oracle database as Tom hopefully you all
know about it is pretty much the number
one go-to site to get answers to hard
questions on anything apparently not
even Oracle related we've had Microsoft
Word questions lately and Star Wars
questions and they handle it all
gracefully a little bit of sarcasm
sometimes Vitter live sequel to oracle
com anybody here use live sequel so live
sequel oracle com is a 24 by 7 12 dot
one database soon to be 12 to when it's
in production and it's a place you can
go to just play around with the
technology but you don't have to do that
you've already in the technology but
what you can do is go there for the
script repository so there are hundreds
of scripts I've published about 110
myself of all my different PL sequel
scripts and examples and i'll use it
during the talk or I'll show you the
scripts that you can use to back up what
I'm presenting and you can use it
yourself you can use it as your own
private script repository so you can
post scripts up there and if you're a
consultant moving from location location
you don't have to carry that floppy disc
anymore you know that floppy disk could
carry around you can I just go to live
sequel and there are your scripts and
then there are two sites from non Oracle
folks Oracle developer net Adrian
billington
is has been a great publisher of content
detailed articles and every version of
as sequel and Peele sequel up through
11g release too he kind of got caught up
with children and hasn't gotten to 12
safe and then of course Tim Hall site
Oracle based calm and he's been moving
into the video world in producing a lot
of videos anybody here do his dot com
forum anybody recorded calm okay so
check out his videos fun guy interesting
content so lots of resources the reason
I wanted to take the time to show you
these things is that you only get so
much out of these talks in fact my
feeling about these talks is they're
mostly infotainment you know you can't
absorb a lot of new information real you
know detailed knowledge about things
will hopefully raise some flags and your
head about things you can do so the main
thing is to know where to go afterwards
to get access to stuff okay so let's
talk about the PL sequel compiler and
we'll focus on three different areas
automatic transparent optimization of
code compile time warning strain work to
improve the quality and performance of
your code and conditional compilation
you actually get to tell the compiler
which parts of your code you want to be
compiled or not be compiled and
variations on that theme so this was
let's see do I so I remember a long time
ago I remember the year anymore probably
Brynn remembers when 10g came out do you
remember when 10g came out a long time
ago yeah so we had a scare for a little
while java was put into the database and
it was a concern among us in the
community that oh my god is they going
to throw up Cael sequel and only do java
programming in the database which would
never have happened but anyway with 10g
it became really clear that oracle was
very committed to the PL sequel language
so they completely rewrote the compiler
now prior to 10g the compiler compiled
our code turns it into a know partially
compiled code at least and then we can
run that code and it would tell us if we
have mistakes in our syntax or
referenced objects that don't exist and
so on but with 10g they basically added
pretty much brought the compiler up to a
modern standard that you would expect in
any programming language so automatic
optimization compile-time warnings also
known as lint checking everybody know
what lint is probably not you have a
sweater you get these little
on the sweater that that's lint and you
pull off the lint you clean up your code
and then conditional compilation so
optimizing compiler so now unless you
disable optimization which is a really
bad idea and I doubt you'll ever do it
when the compiler compiles your code
first it makes sure that it will compile
and then it will possibly transform the
code change it in various ways to make
it run faster and the idea of course is
that it doesn't change logically what
your program does it just changes the
performance so yes in theory your
compile time increases but I don't think
you'll ever notice you get to choose
among four levels of optimization so the
default and that's when when the
optimizer was first released in 10g the
default was to it remains to that was
also the maximum at the time you can
turn off optimization entirely you can
reduce the amount of optimization with a
level one that is the same as turning on
debug so debug mode is currently
deprecated if you want to compile your
code under debug you set the
optimization level one and then two at
least until 11 g was the most aggressive
in terms of doing the maximum possible
number of transformations for your code
to improve performance then in 11g
Oracle added another layer or another
level level 3 that specifically focuses
on allowing inlining of nested
subprograms in your code and i'll show
you more about that we have six people
sustaining in the back to you like to
stand for an hour I don't and there are
a number of seats up here so come on up
feel free just scoot on it you guys
could scoot in that's the polite thing
to do but we don't expect you to do that
or you can have people climb over you so
the recommendation from the pl sequel
team is simple set your optimization
level 23 so it's going to come by
default it too and that'll handle most
of your optimization needs but if you
want to get the full benefits of
optimization set it up to level 3 this
is obviously something your DBA would do
and then all your code will by default
compile under level 3 let's take a
closer look
so one of the really great things about
the optimizer is you really don't have
to care about the details you shouldn't
care a whole lot about the details it's
a liberating experience and I'll talk
about some of the details or give you
some examples to talk about what you
don't have to care about anymore so I'm
not going to go through a lot of the
details here but basically the pl sequel
team identified like what they would
call freedoms the kind of things they
can change in your code that will not
affect the logical outcome of the code
and potentially improve performance and
then they implemented those there's a
white paper on the pl sequel landing
page there's also additional information
about the optimizer through Bryn's PL
sequel an EBR blog ok but I have this
page will get I think give you a better
example so suppose that the optimizer
saw that you have the same computation a
couple of times and nothing in between
that's changing them it will declare a
local variable do the assignment once do
the expression once assign it to the
variable and then use that temporary
hidden variable in the code obviously
this is nothing you ever see it just
does it for you so instead of doing that
same expression or evaluating the
expression multiple times just once loop
invariance so let's see I think I
probably have a piece of code here and I
think loop invariance so there was a
time a long time ago when you should
have looked at code like this and said
oh my why are you doing that why are you
writing this kind of code this is
inefficient and there are a couple of
things that are that are pretty obvious
here but let me just point out the basic
idea I'm passing my name in it's an in
parameter so can i change it inside my
code right it's essentially a constant
but inside my loop I uppercase the name
and over and over and over again so
prior to 10g this could actually degrade
the performance of your application and
it's doing this unnecessary work you
don't have to worry about it anymore you
could still say that's a bad idea and
I'm going to move it out I'm going to
going to declare a constant in my
program i'm going to sign the upper to
it and reference the constant here but
you don't have to do that the optimizer
will do it
for you so that so now you essentially
can make it you can make a decision does
it make more sense to leave it there
from the standpoint of readability then
I'm reminding people that I'm doing an
upper right so but you don't pay any
kind of performance penalty so the
compiler will look at all the possible
all the looping variances inside the
loop pull them out and make sure that
they're executed just once and then my
personal absolute favorite cursor for
loops so cursor for lips are probably
just about one of the coolest features
of PL sequel in fact let's go to live
sequel so here i am in live sequel let's
get rid of my bookmarks totally
uninteresting and i'm going to search
for optimized what an automatic
optimization of christopher loot so
again go to live sequel search look
around at the scripts and certainly you
can search for keywords that will help
you find this stuff quite easily so this
is something i posted a few months ago
and then you can just run it and check
things out so let's run it and i think
it will take a little while because
we're showing you how slowly things can
run when they're not optimized but the
basic idea while that's finishing up is
quite simple when you code a cursor for
when you write a cursor for loop and
when it's executed what you're really
saying is you're it's a high-level
declarative statement to the compiler
you're saying i want to go through every
row fetched by this cursor and then
execute whatever the body is but i don't
want to pay attention to details oh i
don't have to open the cursor do the
fetch figure out when to close the
cursor exit the loop close the cursor
it's all done for us automatically so
I'm literally describing what I want not
how to get it done does that sound
familiar what what does that describe
what did I just described sequel that
was the magic of sequel how many of you
word have been using sequel for more
than 20 years it's been around a while
and it's still fresh as a daisy and
getting better every day but the amazing
thing about sequel and I know this
because in 1987 and 88 what I was doing
was standing up in front of crowds like
this and saying check this out
this is amazing and I would press ENTER
and run a sequel plus script and it
would say select from data order by a
night whoa and joins and whatever the
magic of sequel is that you're
describing what you need either the data
set you need of the data used to change
you're not writing a program to do it
the underlying engine figures out the
best optimized way to satisfy your
requests and that's what the cursor for
loop is in a procedural language like
PLC equals a high-level declarative
construct because of that because I
don't tell it how to do its job it can
optimize that code and so what a cursor
for loop does it automatically be
optimized to run like a bulk collect so
it fetches a hundred rose at a time
instead of one now those hundred roads
are then you know prossie h one of those
roads are processed with a loop again
you don't have to care about these
details but it's good to know that it
happens so if we go back to live sequel
and take a look at the results so I've
got a little timer in here using sis
time stamp and showing differences so
what I'm doing is looking at three
different ways of iterating through rows
one is cursor for loop the other is I'm
going to do it myself I'm a control
freak I'm going to open the cursor i'm
going to set up a loop to fetch a row
exit when the cursor not found and then
close the Christian when done I take
control of my world in this case it's a
really bad idea or you can use both
collect which under a number of use
cases for using even over a cruciform if
your cursor for loop has non queried EML
inserts updates deletes you will want to
explicitly convert to bulk collect and
for all but anyway let's take a look at
the results so implicit cursor for loop
took 5.8 seconds explicit took 5.7
seconds wait that's about the same and
bulk fetch notice point 38 seconds a
little bit faster but wait a minute I
said that the implicit cursor Froelich
would run faster so what's going on
there I didn't have optimization turn on
i turned off optimization and I did that
right here
I turned up optimization then I turned
it back on and now take a look implicit
cursor for loop oh point three eight
nine seconds row-by-row processing 5.6
seconds okay so that's probably the
clearest demonstration that I can give
you of the power of the optimizer and
the smart well yeah and the smart way
that the pl sequel team went about it
they didn't just do this standard set of
optimizations that any language has they
looked the specific nature of database
programming and then optimized wherever
they could from there yes what was that
how do you control the fetch size so I
said it fetches 100 rows at a time can i
modify that you can modify that by
switching to an explicit bulk collect
fetch you cannot modify the hundreds
Rose fetch size of the cursor for loop
hard coded or might not be hard-coded
but it's not something we can adjust so
for most situations 100 rows it gives
you a nice big fat boost in performance
as you can see if you're working with
massive amounts of data you might find
that fetching a thousand or 25,000 or
50,000 will give you much better
performance and that's again when you'd
want to switch to that bill collect and
be able to specify a higher limit but
the bottom line is that for a lot of the
normal use cases you're going to run
into just turning on optimization we're
leaving it on gives you this incredible
boost in performance other questions
okay
a question I often get brynn scroll the
gyne to is is there a way for us to see
the compiled the optimized code so that
we can learn what you're doing so that
we can write our own more optimized code
right we write our PL sequel code and
the answer is no there's no way to see
that it's not even plc cool when they're
done with the optimization phase and you
shouldn't be asking that question you
shouldn't care first of all is I'm sure
some of you are aware from version to
version optimizations will change so
that's like too much information you
might get it might be dangerous for you
to know what the optimizations they do
are because then you end up trying to
trick the compiler be smarter than the
compiler I don't know about you but I
know that those guys and women on the
peel sequel team are way smarter than me
so for me to try to outsmart anything
they do is ridiculous so you don't you
don't want to care about what the
optimizer does you wanted to you just
want to rely on it and focus on writing
readable maintainable code so in 11g
Oracle added a new level 3 to optimize
the inlet or the execution of nested
subprograms you're not going to see
usually a hundred percent order of
magnitude kind of improvement but you
can see some nice incremental
improvement in performance depending on
how much you rely on in essence of
programs and how often they're executed
so I think the main thing is to show you
an example of in lining
so nested subprograms I think is one of
the most important techniques for you to
write readable maintainable code how
many of you do this now you declare
procedures and functions inside other
procedures and functions pretty good
okay and I know the rest of you actually
do but you just don't like to raise your
hands so just here's an example here's a
procedure called in tab but basically
does a select star from table in plc one
most of this code which is about four
hundred lines long is relating to
formatting your code but if we go down
to the bottom in fact of this long
program here's the main executable
section and I can read it you it's a
table of contents essentially first load
the column information then construct
and parse the query then do this then do
that you can literally just read the
code it tells its own story now these
could be separate so programs declared
at the package level or other schema
level programs but with nested
subprograms they only really make sense
in that localized contents they're very
specific and so you keep them inside
there so here they are these are all
procedures and functions defined within
the higher-level procedure they're
nested inside it so that's the that's
the feature and again I strongly
encourage you if you don't do this now
to start using these nestings keep your
executable sections really really small
so that they're not intimidating they're
easy to read and you're the people who
maintain your code will love you but
here's a problem every time you call a
nested so program there's a small amount
of time spent CPU cycles expended to
essentially look up the code for that
nested subprogram and go run it okay now
in this kind of piece of code I don't
think you'd ever notice it it's let's
say doing five of these lookups and a
few more higher up but if you've got a
loop if you've got recursion in which
you're doing a lot of qualities message
subprograms the overhead then you can
start to see the overhead accumulate now
in that case you might want to look at
inlining again the recommendation from
the pl sequel team is just set it at
three let the PLC let the compiler in
line everything and then you could
actually except that i'll show you i can
turn it off selectively if you want so
the basic idea is that when the code is
compiled if inlining is turned on this
call is replaced by the code
so essentially the compiled code size
increases perhaps dramatically there are
literally copies of that nested
subprogram put wherever the program is
invoked but then the so the compile time
is longer you'll never notice it the
compiled code size can get bigger but
the run time will be faster make sense
so if you want you can be selective
about inlining and again I think the
idea right now would be to turn on
inlining and only use no to turn off the
in lining there apparently are some
circumstances in which inlining can
negate other optimizations that could
occur in your code so in theory there
are circumstances in which you could it
could result in slower code it's very
unlikely but in those kinds of cases you
can selectively turn off the inline you
for specific indications okay so that's
my presentation on the optimizer any
questions so the question was as you as
you upgrade from one version to another
should you run explain basically compare
explain plans between the versions to
see if things have changed I would say
yes and Chris you can you know add notes
to that as much as you want you should
at least do some check on some of your
key queries but that has nothing to do
with this optimizer so you've got the
cost-based optimizer which optimizes
sequel you've got the PL sequel compiler
optimizer that that optimizes compiled
PL sequel code completely distinct okay
in terms of you comparing how it was
optimized on how your PL sequel code is
optimized in 10g versus 11g I don't
think they'd be anyway you can't look
there's no explain plan for the peel
sequel optimizer at best you could run
tests on performance and you'd like to
see that you're at least getting similar
performance so I've got some old code it
was written years and years ago maybe
before there was even 40 in bulk collect
which means a really long time ago and
you'd like to be able to compile it into
the new version and have it magically
transform it into using all the latest
and greatest stuff and the answer as
well yeah
so no so the cursor for loop will be
optimized to similar levels of
performances bulk collect but there's
currently no optimization that will
automatically transform your DML code
your transactional code like inserts
updates and deletes into for all like
behavior or performance we can't do that
safely yet so so the answer is arisen
sorry that you have to go through that
code and make changes to it and that's
where the warnings come into play
because they will help guide you the
kind of changes you should be making I'm
not exactly sure with the questions but
if the question is should I write code
in anonymous blocks declarative begins
at the end run scripts the answer should
be almost none of your code should be an
anonymous block you should rights stored
packages that contain all of your
business logic and then you have scripts
that call those those pieces of
functionality absolutely that is the way
to go okay so warnings that help you
build better code so the compiler first
of all says can you run this code and if
it compiles then you're allowed to run
the code and it's done what it could to
make it run faster automatically for you
it doesn't really address the fact that
you might have written some really bad
code in one way or another bad can mean
you're not taking advantage of key
features bad can mean it's entirely not
maintainable bad could mean that you're
going to get an error when you run that
code so that's what the warnings are for
so basically the compile time warnings
framework when you turn it on will give
you feedback on how to improve the
performance or maintainability and
general quality of your code so there's
an Oracle document called error messages
the error messages manual check it out
of the doc center it has all the
different errors different categories of
errors the pls errors RPL sequel
compilation errors the POWs are the peel
sequel warnings and you'll see there are
dozens and dozens of warnings that have
been defined and hopefully we'll just
keep adding more and more over time so
by default unlike optimization warnings
are turned off we don't bother you I
think we should keep them on actually by
default but i'll show you how you can
just set that and have them on all the
time so there's essentially a PL sequel
warning setting either at a program
level you can actually say for a given
procedure i want to set
my warnings level for that procedure you
can set it at a session level and then
when your code compiles it'll be the
warnings framework will engage and will
give you feedback on your code and you
can simply say things like enable all
disabled all enable errors so you can
turn on you can make every warning a
hard compilation error if you're really
strict about your code that's what I do
no no that's not what I do I get like
five thousand warnings after i compile
my code and I look through every one of
them very carefully and I agree it's not
so bad you can say things like enable
categories performance you can enable it
and into visual warning you can even say
that I want to treat a certain warning
as an error so there are certain
warnings that I think are great
candidates for there's no way I ever
want code that has that problem to go
into production and it you can say
literally don't let this code compile
with that warning let's take a look at
some examples and again you will find
lots of this on live sequel so if we go
to live sequel and look for morning
there must be more than that ok well
there's at least one script I put up
there it probably runs through a lot of
the warnings yes or a few okay so so
essentially for example what I do in
sequel developer is I go into
preferences I search for compile because
I can ever remember where it is and
here's the page the PLC compiler page
and I can decide how I want to set my
warnings so right now I've enabled all
warnings and if I want to make them if I
want to get really serious and never
ever be able to compile any of my code
ever again I said it to error but I
don't enable and again you can pick for
the different categories you can change
your optimization level so if I want to
make sure that my optimization is always
being at level 3 which I'm now going to
do I forgot about that and then there's
PL scope hopefully I'll come back to
that today depending on how fast i go
how many of you is PL sequel developer
here no wait a minute
how many of you use toad okay put down
your hands how many of you use sequel
developer from Oracle as your primary
development tool as your primary
development tool go ahead sequel
developer primary development tool okay
and PL sequel developer as your primary
okay a lot how many of you sequel plus
is yard how many of you sequel CL okay
right well I won't get into all that so
the reason I asked about PL sequel
developers is a very capable very
low-cost tool it's not as cheap a sequel
developer but it's kind of close and
what I find interesting about PL sequel
developer is that for years they have
had warnings there I think it's their
own warnings framework is it built on
the pl sick one now I remember anyway
it's always on and the only developers
I've ever met in my multiple years in
the world of PL sequel who insist on
clean compiles are people use PL sequel
developer because they don't like seeing
those warnings at the bottom and in toad
and in SQL Developer it's not turned on
by default so I admire that greatly okay
so here's an example and I'll go through
a few examples but you get the idea you
should just start using it and exposing
things in your code so one of the really
great analyses that the compile time the
compiler will do is identify unreachable
code so in a program like this you can
probably tell pretty quickly right that
especially because of my excellent
documentation that this line of code
will never be executed right X is
declared to be ten it is ten that
executes snot that obviously in real
programs it's a little bit harder to
find things like that and you can be
very surprised what you'll find in your
code when you run it through the compile
time warnings and you suddenly notice
that 30 or 40 lines entire sub programs
are never possibly executed it's a could
be alarming often it's just a matter of
saying oh yeah I don't use that anymore
and pulling it out now I've got these
names of files to these plw 6002 if you
go to the Oracle Learning Library you
can search for the PLC learning library
you can download all of my scripts but
again i've loaded most of the useful
stuff on to life sequel that might
be the best place to start a couple more
examples so what am I definitely my
favorite from 11g was adding 6017 so
something's going to raise an error so
when the warnings were first added in
10g I was so excited now finally they'll
tell me if I do this and I was kind of
disappointed when it turns out that it
didn't but they got to an 11 and it was
then in an interesting way so the 6017
will basically tell you and let's see if
I'm still connected I don't remember so
turn on warnings nope I got to reconnect
so basically when you oh that was fast
thank you don't expect that well it
doesn't always reconnect that quickly
for me alright so I'm going to compile
this code I just made sure that all
warnings were enabled even though that
was done automatically for me so it
compiled I'll look at my compiler log
and it tells me two things one is Steven
you forgot about your auth ID clause so
no it is there that's not the right one
let's clear this out let's do it again
and now I don't see it I hate when I do
that and I have to get the compiler view
back I'm just how to do that yeah right
excu
so what the 6017 warning will tell you
is if you run this code it's going to
have her out so it'll detect for example
that this is not going to fit it'll
detect that you've got a zero divided it
doesn't actually selectively point to
the well it points to the lines it
doesn't tell you what the arrow will be
but it tells you you're dead this is
never going to work that's kind of nice
and lots of other warnings so the bottom
line is that and one of them was put in
for tom kite so when others then no of
course is one of his famous diatribes
around PL sequel and it's just one one
of many forms of swallowing up
exceptions you can say when others then
dbms output.put line error but that
allows your processing to continue so
the 6009 warning will give you a warning
if you're when others Clause doesn't end
in a raise or raise application or
you're not rear acing the arrow back out
lots of things like that nice ways to
enhance the quality of your code so
that's the 6017 here's an example of
treating a warning as a hard compile
error so 5005 is one of those that i
think would qualify actually the 6017
really does qualify for being an error
right we have a runtime error but i
guess because it's not a compile-time
out of the compiler lets it go the
compile time warnings are warning you
about PL sequel code nothing to do with
sequel ok and we you know obviously we
talked about in and in many ways these
languages are very tightly into
integrated but you still they still are
two different languages with two
different compilers and parsers and all
that kind of stuff right well PL sequel
uses the sequel parser okay right so
5005 so 5005 is is the area that says i
ran my function and it didn't return a
value do you ever get that i execute my
code and it said function return without
value I find that to be a really
embarrassing error usually I'm busy i'm
writing some great code i write a
function I figure it all out and I'm
done and I compile my code it compiles
fine or I didn't look at my warnings
actually that's what it is I just don't
look at my warnings maybe I should do
that then I run my code and it errors
out because i forgot the return
statement literally it's a function
without a return statement the more
classic case when you run into this is
when you have multiple returns right so
if this is true return that if this is
true return that and then oh no there's
a branch that doesn't and of course when
you're testing your code you don't test
that branch for whatever reason mostly
because we're really bad at testing and
then it goes into production and of
course the first thing that happens is
the user forces the branch to go where
it has never gone before and you get an
error so the compilot the warning will
tell you that it found a branch of logic
that resulted in not executing return
and again you can flag that as one of
the things you want to specify as an
error and then it will not allow that
code to compile if it finds that the
problem ok so compile-time warnings the
first thing that I would do is go to the
website look at the documentation and
read through the warnings that Oracle as
has implemented that partly Apollo time
warnings are about educating you more
about the pl single language for example
there are a number of warnings around
using no copy so if you have an outer
and out parameter and you attach the no
copy hint you can often improve the
performance of your program by avoiding
copying in and copying out without going
into the details a lot of people don't
even know about that feature so what
you'll get out of the warnings process
is partly just saying well I never heard
of that let's go find out about that one
and start to use it in your code right
and then of course there's a whole QA
side of this is going to raise an error
this exception handler is inadequate
it's missing the Rays and so forth and
so on and then with each new release of
Oracle check for additions Brynn can you
talk about 12 2 and compile time
warnings can you say if there are any
new ones coming out ok what if I let's
find let's let's do an experiment no
sit down that's it he didn't sit down
turn mornings disable the answer
mentality so always compile requesting
warnings are an error and then you'll
notice that you really really really
agree you want to do and then you can
disable with that same you doing so what
are you saying is disabled all and then
as you go through the company are all
sorry turn every warning into an error
and then go through the list of of
compile-time errors and decide which of
those you want to ignore for example you
don't want you really don't want to be
bothered about the auth ID close you
don't use in vocal rights you now and
care about putting an auth ID definer so
you can then not include that in your
definition of what your compile-time
warning should be great idea okay last
not least but probably the least likely
to be used anyway is conditional
compilation so that's the name tells it
all you get to conditionally or you tell
the compiler conditionally to include or
exclude not compile chunks of your code
and you do that through various compiler
directives so for example with
conditional compilation probably the
classic you have a question no okay
classic yeast cave case would be that we
sell an application that runs an Oracle
and we support versions unfortunately 9
and 10 and 11 to 12 now it's hard to do
that because there are different
features in every version that you'd
really love to take advantage of but you
don't want to end up with four copies of
the file with different chunks of logic
and some crazy commenting scheme so what
we often end up doing is least common
denominator coding I'd love to use for
all but I have to support Oracle 7
that's a really extreme example but you
get the idea so with conditional
compilation you can literally say if I'm
on this version use this else this
version else else and in a single place
in your code have your maximum feature
utilization across your different
versions
we might want to run variations in your
code between tests debug production from
the standpoint of both unit testing
exposing private modules for testing and
then hiding them back when you actually
go production or different levels of
tracing and debugging in your code all
that kind of stuff Brynn is written
white paper on conditional compilation
it's about a hundred pages of detailed
use case analysis and I encourage you to
check that out if some of these ideas
look attractive too by the way that the
title on the slide is not meant to imply
that other features of peel sequel are
not finely nuanced that's not really
focused is it it's not just my eyes
isn't that's number one that's the right
one so I better do it what yes okay well
anybody who wants to adjust keep
adjusting go for it so again I'll just
run through this pretty quickly I'll run
out of time and also probably run out of
your patience the main idea is to give
you a sense of what you can do so
essentially what you're looking at is
dollar sign syntax in plc quotes meta
code inside your plc blue coat and so
you have if statements you can say if
this certain condition is true then
include or exclude or you know if it's
not true don't include it you have
dollar sign error so you can actually
force a compilation error if a certain
condition is true and i'll show you an
example of that where you might want to
do some essentially quality control in
your code using conditional compilation
and then dollar dollar are your
different conditional compilation flags
that you can use essentially as
variables they'll be constants that you
can use in your if statements for your
expressions so let's run through some
examples and let's just go to the code
to do it
let's make sure that's turned back on
okay so suppose I've got all this
different trace levels and if debug is
true so what I'm saying here sorry what
I'm saying here is if debug is turned on
and my trace levels at least five add
that additional trace information and
then if commit is turned off then go
ahead and don't do the commit comment
disabled else commit so here's my
session statement that says set my PL
sequel conditional compilation flags
turn on debug set the trace level 2 10
turn off commit so I'm going to execute
that statement I'm going to execute I'm
going to compile that procedure and then
I can run my code now you have a very
legitimate question to ask which is can
I see what my code looks like that's
going to be run because this supports
all the different variations the
question is what what I'm actually
running and in this case yes you can see
that code so there's a separate
procedure package called dva Mets
preprocessor print post process source a
mouthful and then you can run that and
find out what is actually what has been
compiled what will be executed so you
can say that I've got my trace and I've
disabled commit and you see a lot of
white space around here so the pl sequel
team was really careful to preserve the
original line numbers and locations in
the line of your code this matches
exactly what you see up here if I take
out all this stuff and so on and so
forth so does anybody know why why they
do that why we maintain that white space
like that yeah so if when an error
occurs and when you're doing execution
call stacks and you see line numbers for
your code you can go back to your
original source which has all those
dollar signs in it and it's it's still
the right line
just made them up so those are my flags
I just made them up right there I can
even I can even never use these in my
code and it wouldn't you know complain
about it that's it you just make them up
yourself there are a set of flags that
come with conditional compilation so
there and I'll cover some of those soon
but you can make up whatever you need
for your own application they can only
be bullion's or integer values and you
can also use packaged constants as well
you can have your own packages with
constants in it but they have to be
static constants which essentially means
no matter how many different people
execute that package or reference the
package the value of the constant is
always the same if your constant is
being given the value of sequence
sequence next Val that is not a static
constant because everybody who
references that package every session
that reference to the package gets a
different value so what I'm going to do
now is set my plc equal CC eight flags
just to turn off debug and by
implication that'll be null that'll be
no so I do this alter my session compile
my code and I'm going to print out my
code again and now you can see that it
looks quite different right so the
commit sin DBMS output is gone so that's
that shows you the essential nature of
conditional compilation you get to
decide what the compiler actually
compiles so when you compile the code
the warning settings are associated with
that program unit whatever is current in
the session is recorded with the program
unit the next time Yuri compile the code
unless you say alter compile and is it
reset Ryu settings thank you if you say
reuse settings when you recompile it'll
keep whatever your settings are for that
program unit no matter what the session
settings are but what I did here was
simply say recompile so it used the
current session settings and those are
now stored with the program unit so when
you do the alter session commit it has
no impact whatever on your currently
compiled code
so you're saying if I if I do an alter
session then I have to remember where
did I use that flag in which subprograms
so I know to recompile those sure so
conditional compilation is not something
you're going to use in any way casually
in fact most people will will not how
many of you have used conditional
compilation use it in your code
excellent it's a good number let's we
see the numbers going up every time we
do a conference but relatively few it's
always going to be relatively few it's a
fairly specialized kind of feature and
your should not be in a situation where
you're saying oh where did I use
conditional compilation again but
obviously it's not that hard to search
your code and find it either you don't
have a lot of dollar signs showing up in
your code and brend yes most from having
using comparison exercise performance
testing most of the data matrices in
production your research if you want to
compare two things it's a very elegant
way and I think what would be great
Brynn is if you publish on your blog
showing people how you use conditional
compilation abilities really powerful
expressive and concise analysis scripts
that'd be a great boon to the community
but don't you think doesn't that sound
great
he has so many really excellent scripts
that he's written over the years that I
get to see but you don't get to see him
and I want to share that love with all
of you so our directive you would not
want me to publish your stuff we know
this ring we know this okay so here's an
example of how you might want to use
conditional compilation for QA quality
control in your code suppose there's a
program that has a that has to be
compiled with full optimization work
runs really really slowly so
optimization at level 1 or 0 is simply
not an option you want to make sure
you're not going to trust anybody to
make sure that the default level is set
to 2 or 3 so you can literally ask
here's an example of a predefined
conditional flag CC flag PL sequel
optimized level and if the optimized
level is less than 2 you'll actually
stop the program from compiling so
that's just one example you might come
up with some other ideas yourselves well
that variable you have to you don't get
to define it that's built in yes so
essentially all the columns of the pale
sequel compile object others there's a
view that contains all your viewer
compile time settings and these are all
the built-in values that you can get out
of the table so the code type whether
it's native or interpreted what your
warning settings are your conditional
compilation flag settings for that
program unit so these are all built in
if you reference a conditional
compilation flag that is your own or
that is otherwise just nonsense you had
to type 0 it evaluates to null and when
you do your conditional compilation
logic your conditional statements you
want to make sure that the default state
which is nothing's been set is your
production state and it works like you
want it in production in other words you
shouldn't design your code so that a
conditional compilation flag should be
set in a certain way to get your
production behavior because then you
might run into problems where it's not
been set every version of the database
that supports conditional compilation
which is pretty much everything these
days has a new package or a package
called DBMS TV version so this has a set
of constants that have been defined to
give you absolute and relative
information so if you ever want to find
out what your version and release of
your databases dbms DB version has that
information and it has a number of
relative ones as well so here what I'm
saying is that if the version is less
than or equal to 10 1 then use some
logic that essentially gets rid of all
the empty gaps in my collection
otherwise use indices of which is added
in 10 dot 2 so that's how you write the
code for different versions of the of
the database all right I am at a time so
conditional compilation very powerful
feature not that hard to learn it's
something you have to be very careful
about how you implement in your code do
check out Bryn's white paper about it to
sum up entirely and I'm not going to get
to peel scope optimizer just enjoy the
default or get it up to 3 but even a 2
you're still doing really well don't
worry about the details don't worry
about for example looking at your code
is saying oh I'm doing an uppercase
every time I execute my loop you don't
have to worry about those things anymore
you might still decide you want to take
it out you don't have to compile time
warnings turn them on take a look Go Go
Bryn's route and make them all errors
and spend a lot of time sorting at your
code and figure out what you want to
keep and not keep but give it a try and
at least at a minimum read the doc we
look at the warnings that Oracle has
defined and especially as every new
version comes out conditional
compilation the main thing is to be
aware of it so that if one of those use
cases come up so hopefully something
will a light bulb will go off your in
your head in the shape of the dollar
sign but it'll be conditional
compilation and you'll go check it out
all right well it's I'm right at the end
but let's see if we have any questions
for a moment or two all right thanks for
joining me have a great case coat thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>