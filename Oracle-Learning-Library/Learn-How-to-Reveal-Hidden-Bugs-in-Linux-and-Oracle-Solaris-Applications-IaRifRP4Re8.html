<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Learn How to Reveal Hidden Bugs in Linux and Oracle Solaris Applications | Coder Coacher - Coaching Coders</title><meta content="Learn How to Reveal Hidden Bugs in Linux and Oracle Solaris Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Learn How to Reveal Hidden Bugs in Linux and Oracle Solaris Applications</b></h2><h5 class="post__date">2014-04-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IaRifRP4Re8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello my name is Darrell go I work in
the Solaris to do comparative doing
performance analysis today I'm talking
to Raj Prakash the project lead for the
code analyzer about the code analyzer
what it is and why it is important
it's a Raj can you tell me a bit about
the code analyzer and why people should
know about this tool code analyzer is a
comprehensive set of checking tools it
involves three different kinds of
checking one is static one is dynamic
and a coverage it also comes with two
visualization tools one is a command
line tool called codec and a code
analyzer GUI the advantage of having a
checking a suite like this is that the
learning curve is very small and because
all the three different tools use the
same display mechanism so you do not
have to learn a different tool to get
the data from three different kinds of
features so tell me a bit about static
analysis so static analysis is
essentially the errors that we can find
by program inspection so you do not have
to run the program and we just scan the
program as it were and tell you what
could be wrong with the program so is
this light Lynn's but don't we get this
from lint or error messages it is light
point in some ways however this is much
simpler for example with studio all you
need to do is have an option to your
build is actually called X and always
equal code and you get the results and
you can view the results in the two ways
that I mentioned before and so then
you've got some static analysis at
compile time and you said you have
dynamic analysis what what does not
destroy dynamic analysis is also
sometimes known as memory access
checking so this is when the program is
actually running and it's doing
something wrong for example you have
uninitialized memory you have allocated
get a heap in one place in the program
and later you're accessing it but you
never initialized it and so will be able
to catch errors like that and so the
third thing you talks about was code
coverage so that sounds different from
the other two but how's that fitted yes
at first it does sound different but
it's not in this that you cannot
possibly find errors in parts of your
program that you have never tested okay
so that is the bottom line you want to
make sure that all all parts of other
relevant parts of your program are
tested and tested in dynamic checking
and as well as static checking obviously
so uncover which is our our coverage
tool tells you that your test suite is
actually covering certain parts and not
covering other parts and even better
they're actually coverage tools out
there that tell you this that certain
parts of your program are not covered
however they for example will give you a
thousand functions that are not covered
in any particular order and therefore if
you want to sift through this that it is
a lot of trouble what we do is we give
you a sorted list of functions that are
uncovered at top most being the most
important function in fact it is the
function that has most functionality
under it right
okay so that gives you a way of
organizing your work so you focus on the
bits okay the neat little help the most
exactly so you start with writing a test
case that would cover the topmost
function that we should show but at the
bottom of the list you'll probably would
have function that are your debugging
functions that you don't really care
about and so you will work in the order
top to bottom and that you then you can
cover it very quickly so you get biggest
bang for the buck if you order if you
write your test cases in that border you
mention the static analysis is a
compiler flag that gives you the
analysis as a separate and set of data
do you need to do anything special to
get the code coverage or the dynamic
analysis no you do not need to do
anything special any binary any
executable or shell object that is
produced by studio compiler is ready for
the dynamic checker and the coverage
tool so you do not need to do any
inspector so you've got three different
types of code testing so what are these
together how does the packaging together
help them well so static checking and
dynamic checking our bullets
complementary and supplementary so let
me give an example if it's complementary
because if some cases static checker
would find that's the uninitialized
thought compiler therefore might assume
that it is always zero and go on now
dynamic checker have may find other
things based on that assumption so now
when you see the two of them together
and remember that our visualization tool
is is the same so in fact you see the
two errors in the same context at the
same time and it really helps understand
understand difficult bugs which are
otherwise hard to figure out what's
going on</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>