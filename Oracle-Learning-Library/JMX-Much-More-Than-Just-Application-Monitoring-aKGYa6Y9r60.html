<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JMX: Much More Than Just Application Monitoring | Coder Coacher - Coaching Coders</title><meta content="JMX: Much More Than Just Application Monitoring - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JMX: Much More Than Just Application Monitoring</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aKGYa6Y9r60" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone my name is mighty Lisa
Barham and I work in the product
development team and the enterprise
manager of center team in Oracle and we
use gmx very extensively in our product
it's actually a part of the core
infrastructure our whole product is
built around it so how many of you are
really from a systems management
background here just a show of hands
okay and how many of you are familiar
with jmx and what it does okay that's
good so I won't spend too much time
going over what gem X does so we'll do a
quick overview of what it is and why we
need it I'll be going over the JMX
architecture also briefly but my primary
focus is going to be on you know the
applications of JMX how you actually use
it in the real world I will do a brief
demo on two of the tools J console and
visual VM which are bundled with the JDK
these are for monitoring your VM and any
applications that you might have which
have gmx enabled and then we'll look at
more practical applications of JMX in
the real world and hopefully you'll have
time to go through some gem X best
practices and the future of Gen X and
ideally you can ask questions at any
time but you know it would be preferable
if you wait for a particular section to
end and then ask your questions at the
end of that so let's move on what is jmx
and why do you care why should you care
about it so can everybody hear me okay
at the back
okay so jmx literally the acronym stands
for java management extensions and what
it is is is the standard recommended way
for managing and monitoring anything
that's Java enabled and it's an
extension because it was an extension
for a long time
it has been around since the early days
of Java and it was an extension for a
long time but since Java 5 it's part of
the core Java SE and the primary thing
that you need for JMX is more than a jar
you need a container a JMX an mmm bean
container and that's also installed now
there is a platform and being
that is installed as part of Java since
Java 5 and it's also part of Java EE
since July e 1.4 so in recent years it
has become much easier to use jmx
because it is part of core Java now what
else is it it is an API it is an
architecture and it's also a spec and a
standard and there are two J SRS which
are related to jmx or which form part of
the jmx
spec specification one is jsr three so
that's really ancient and the other is
jsr 160 which added the remote JMX
manageability to JMX so basically that
means you will be able to manage
something from a remote agent I mean a
remote client and that's very crucial
because most of the time you don't want
to be managing running the management
client on the same system that you are
running your manage resources on there
are also other related J SRS I'm not
going to go in the details of those jsr
174 is related to the the JVM monitoring
and jsr 255 is JM x 2 dot o the next
next version of the spec and that's
basically frozen right now I mean and
it's not frozen its dormant so we don't
know when it's going to make it into the
platform I'm also going to compare some
other technologies which are related to
JMX but not exactly you know the same as
JMX and this is just to make it more
clear of what JMX is and what it isn't
and how it's related to these other
technologies and this includes you know
the technology is listed there RMI EJB
geni Web Services SNMP and things like
that so we we have a separate slide for
that and I'll go over that and one thing
that I want to emphasize at this point
is that because JMX is now part of the
core java infrastructure it's very easy
to use it you don't really need anything
additional than what is there installed
with your jdk so you should really look
into leveraging it even for any of your
programs that need any kind of
management and if you are doing SNMP at
all you know you should look into JMX as
an alternative to SNMP because you don't
need meb's you don't need any
proprietary tools you know to do the
management just your Java SC
installation will do ok so Java is
everywhere right so we know that it's
running
on millions of the billions of devices
and not only is it running on billions
of devices you also have millions of
applications which are running on Java
and most of those devices and
applications irrespective of what are
you know vertical domain functionality
they provide all of them unless they are
like you know in a trivial hello world
application they also need monitoring
and management and so the recommended
way in Java I mean the standard way is
Jam X and so typically again to
elaborate more on what we mean by
management so any java application you
take will have some business logic that
implements the actual functionality of
the application but any non-trivial
application would also need to be like
deployed and then you need to started
stopped it and then once you are running
it you might want to change its
configuration dynamically at runtime you
want to monitor its performance detect
false you know take corrective action
things like that so all that falls under
monitoring and management and you know
every application or device typically
needs these things to be done so this is
like a cross-cutting aspect of any
application that you take and so you can
use gmx for that and you can also take
it to the next level where you make it
the cornerstone of your application
where your services themselves can be
mbeans and mbeans I will come to what
that is it's a managed bean and it's one
of the core components of the JMX
architecture and you can that'll lead to
a very highly modular pluggable design
and you know the original JBoss
architecture took that approach and also
in OP Center the Enterprise Manager op
center we do the same thing so not only
do we model you know the managed
resources like your server and your OS
your virtual machine your you know
virtual guest or whatever else that you
are managing those are of course mbeans
but in addition to that even the
services themselves like you know you
can take security or persistence or
transactions you know those kind of
services which an app server will
typically provide those themselves could
be implemented as em Dean's and then
loaded into this and being container and
the advantage of that is it leads to a
highly modular pluggable design you just
keep whatever services you want and you
can deactivate the ones you're not
interested in it
as easy as just removing that mxp nor
the EM beam for the service that you
don't want and it's also very easy to
replace it with some other service so
say for example you have you know
hibernate implementation of persistence
and then you want to replace it with say
a top link implementation and then you
know you just swap it in you so apart
the M beam for the hibernate and then
put in the the top link so it's you know
but that's the next level but the very
basic thing is just modeling your
resources as mbeans and then doing the
monitoring and management now a brief
comparison of JMX with some of the other
technology so you know how is it related
to things like our a mic or bar and soap
so whenever you want to manage remotely
so you have your management client
running remotely and your manage
resources are running you know somewhere
else you need some remote technology to
connect that connect the two and for
that you can use any of these
technologies RMI soap or even you can
use plain sockets as well and there are
various connectors available for each of
these technologies depending on what you
want to use so that's how it's related
to those how is it related to EJ B's so
EJ B's would typically implement your
business logic but then the EJB that
itself has to be managed right you need
to deploy it you need to you know
install it uninstall it you basically
the lifecycle management of the of the
EJB inside your application server and
typically most application servers use
jmx
in order to manage your manage the EJB
lifecycle genie and J&amp;amp;D i basically used
for discovery so when your remote client
wants to discover the agent to talk to
then it can use a URL and it can specify
a jndi name there to actually discover
the remote agent SNMP I have a separate
slide for that I'll come to that in a
bit it's closest in intend to jmx
our MIB already covered web services
again another technology to communicate
and JMS so JMS and JMX are not the same
thing though they sounds similar just
one letter difference JMS is basically
the the messaging Java messaging
technology and it can be used actually
if you want to send because GM X
supports something called notifications
when you want to send events from the
agents back to the remote clients and
you can use JMS as one of the
technologies because it does give you a
lot of
you know quality of service and things
like that guarantee delivery so you can
substitute or you can use JMS for that
also a JMS queue can be managed with
through jmx so you can because it's any
other resource so you can manage it with
JMX okay comparison of JMX and SNMP so a
lot of you might have heard if you are
from a systems or network management
background SNMP is a de-facto standard
used for managing switches routers and
the like and most of the vendors they
publish MIBs management information base
to manage the devices and then you write
a client basically to that mem and you
write an agent also to that map and
basically if you are interested in doing
more than network management especially
if you are doing java applications
management or a combination then JMX
would probably be a better fit some of
the things that provides are like with
certain kind of mbeans you know if you
make structural changes on the agent
then those could be visible to the
remote client with the dynamic mbeans
SNMP everything is static all the time
both support events SNMP support straps
gmx notifications and also because it's
a Java API it supports very rich data
types you know including objects and you
know your custom classes and types like
things like that whereas with SNMP you
just get primitive support and again
there's no true method invocation in SM
SNMP you just do you know a hack if you
want to really do a method invocation
you do a set like set power on true to
actually do a power on and also the most
important thing probably is that you
need a special and most of the cases
it's a proprietary toolkit to actually
implement the agent for a specified map
which you don't need as I said with DMX
it's all out of the box with July I see
and you know even the client the gem X
client is out of the box which is your J
console and visual VM so very very easy
to manage
ok brief look at the JMX architecture so
you'll start at the bottom so there's
the probe level there those are your
manage resources so you would for
example if you have a server you have
you're a middleware an app server you
have you know anything that you want to
manage your own custom program right you
would wrap you would expose the
management interface of that not the
business logic but rather the management
interface whatever you want to manage as
an MV okay and then you would provide an
implementation of that we'll see some
code examples of how to do that a little
bit later but basically you generate
these mbeans and then you register them
with the agent level the primary
component of which is the ambient server
and this ambient server as I said in
Java SE from Java 5 onwards it's
standard it comes you don't have to
install anything it comes installed when
you install your you know JDK basically
and so you register it with the ambient
server and then afterwards you have your
remote clients connecting to that mbean
server to actually talk to the mbean so
nobody talks to the ambience directly
they always go through this mbean server
so that's a container within which the
ambience are hosted and again for the
remote connections you can either do it
you know the MX client in which case you
would use a connector so a connector
either like RMI or HTTP or any other
connector exposes a JMX api to the
remote client so the remote line must be
JMX capable in this case and as i said
it could be an out-of-the-box client
like j console or visual vm so in that
case you don't really need to do
anything they automatically understand
and they can figure out what mbeans you
have in your environment on the other
hand if you are SNMP or if you are you
know you have an SNMP client say or you
have an HTML browser and you want to
look at your mbeans and you want to
manage them through that interface you
can do that as well so the client does
not have to be Java in this case and so
there are some adapters available for
these various protocols so that's
basically the three layers and again
most of this I mean you get all of this
for free with your Java installation
Java is the installation yeah the SNMP
adapter is not but there is an open J
DMK open DMK project and that does
provide an SNMP adapter so the the Java
comes only with the RMI connector the
JDK comes with the ARMA connector that's
the standard okay so I think I've
covered things in this page is there
anything else here let me see
so again when I said you implement the
management interface of the mbean you
would basically the mbean can have
attributes which can be read or read
right and also operations which you want
to invoke on it and also notifications
that it can emit and we will see some
examples of what I mean by this a little
later and as I said the services and
even parts of the infrastructure itself
can be an EM beam so it doesn't have to
be just a managed resource anything can
be an MB register with the ambient
server and then you can access it and
you can manipulate it remotely and there
are several kinds of mbeans you know I'm
not going to go over all these in
details because we don't have time but
if you're interested you can always
investigate I'm going to look at the top
the most commonly used ones which is the
standard and the MX pane but you also
have dynamic model and open those are
the other types so standard and beam so
so basically that is how do you define
one so you write a Java interface say
for example you want to expose the
management interface of a cache so you
write a cache mbean ok so you write
something mbean that's the interface and
so that's basically equivalent to your
map in SNMP if you are familiar with
that and then you would have an
implementation of that so in this case
it would be like a cache or and then
that implements the interface and
provides the actual functionality and
every method in the interface is either
going to be an attribute or an operation
so if it's like a get it so it's like
standard javabean notation so if you say
get or set those are the attributes and
if you say just like for example in this
case clear is an operation so and also
operations will take they can take
arguments whereas you know plain gaiter
will not take one so that's just so hit
rate and policy these are simple
attributes and also see how it's
actually returning policy which is a
user-defined type so you are not
restricted to only primitive types here
you can return user-defined types as
well and if you are doing that with a
standard mbean then the remote line
needs to be aware of that class it needs
to know
this policy class the structure of that
but if you have an MX beam which is
probably what you should do if you are
working with Java 6 and later because
that Java 6 allows you to create your
own MX beans and you can define your own
user-defined classes and the remote
client does not need to know about them
as long as you are
this custom class is following certain
rules there so it basically needs to be
able to convert that the framework
should be able to convert your custom
class into one of the standard open
types and it can do that if you specify
this annotation either add constructor
properties or you add a static method
from composite data which returns
actually your which basically can
recreate your custom type at the client
end so once you do that then it can
actually so MX bean should be the way to
go if you are working with Java six and
higher and that way the client does not
need to know about your custom types
that you are using ok let's move on
notification so notifications are very
important you know if you think about
we'll look at use cases later on when
you see the real world examples but
basically this is the event mechanism
right and most of the time I mean you
would need you know alerts there's
something going on when you're
monitoring you want to get notification
something may be going on with the
system you want to know what that is and
so if an M beam wants to emit a
notification it needs to implement this
interface notification emitter or extend
notification broadcast or support and so
you just construct an instance of this
class Java X management notification or
a subclass which is typically like
attribute change notification and then
you pass the instance to this node
notification broadcasters support dot
send notification so that's how an AM
beam will emit a notification and any
client that wants to listen to that
notification basically needs to register
a notification listener and then that
implements a method only one method
that's handle notification what it wants
to do with it and so typically you would
only be listening for those
notifications on which you want to take
some action and a good practice again
because the client might be interested
in 100 mb/s and 100
vacation so you don't want it to be
registering with all of them so you can
just create a notification hub which is
basically listening on the server side
to all the note okay all the em beans
and then it itself becomes an emitter
and then the clients actually just
registered with this notification hub
which itself is an EM bean and it can
basically forward all the notifications
to the clients and then the clients
basically filter the types that they are
interested in and take action on those
in the handler the agent here I think I
already talked about that's basically
the ambient server it also has some
services service em beans also would be
registered so this is basically the
container right so this is a container
with which all your em beans are
registered and we use an object name
which is of this form domain name colon
property equals and a set of property
value pairs so every um bean has to have
a unique object name with which it is
registered with the MB server and then
it can be looked up by the client later
on okay and then the remote management
client I already talked about that we
talked about the connectors and the and
the adapters so the connectors are used
when the client is JMX aware HDX enabled
and so with through the connectors using
a protocol like say RM I you expose the
API remotely and then the client can
access the mbeans why are the M bean
server in the case of protocol adapters
as I mentioned your client does not need
to be JMX or Java and depending on
whatever protocol it is if it
understands SNMP you use an SNMP adapter
or otherwise UNH HTTP adapter and things
like that so the advantage is obviously
here that you are not restricted to just
Java for the monitoring for the client
piece of it okay so we'll have a quick
example of how we can manage a resource
with jmx so you take any resource that
you want to manage and then whatever
functionality that you want to expose
through the management interface you
develop an EM bean out of that so we
already talked about writing the
interface and the implementation then
you register the EM beans with ambient
server and then from the client side you
access the ambience through connectors
or protocol adapters
and so let's look at some code example
of how to do this so here I am modeling
a server so I have a server and I want
to manage this so this is just I have a
very bare-bones implementation here
typical servers there would be lot more
things that you want to manage and
monitor but I'm just looking here at the
power state the power info and maybe the
sensors and see that I actually have
some custom classes power info and
sensor and for that so these are like
complex attributes that I'm able to
actually implement and then you have the
server implementation implementing that
interface and it's actually emitting
some notifications here so when it
actually does the power on on some load
low-level driver code that calls the
power on power off on the actual server
so you are here you're managing remotely
controlling the turning on and turning
off the server and once it's turned on
maybe you generate some kind of
attribute change notification and it
sends it and anybody who is listening to
that will be able to get that
notification so that was the EM beam
creation and then here we are just going
to use the platform and beam server
which is standard installed with the JDK
and using these commands management
factoring out that form and beam server
you can actually retrieve a reference to
that mbean server you create an object
name a unique object name for the server
and beam that you just created and
register it with the M beam server and
now from the client side this is how you
access that M being so you need to first
get a connection so here you can see
that we are actually using the RMI
connector in the JMX service URL and we
are going to connect to the ambient
server and once we get a connection to
that a reference to that M beam server
we access the M beans that are
registered with it and there are two
ways you can do this so you can directly
access it you know with this composite
data and get attribute and you know
passing strings but obviously that's not
typesafe it's not going to catch any
errors say for example there is nothing
called sensor info I'm not going to know
that at compile time so the better
approach is to use the proxy which is
the second method so here I'm actually
constructing you know a version of the
server MX been remotely on the client
and then I can just call attributes on
it as if it was a local object so get
sensor info get status so this is more
strongly typed I'm actually using the
server MX bean type here okay so that
actually finishes the first section you
know of talking about the the
architecture and the introduction to
what jmx is and now you know if there
are no other questions I would like to
move on to practical applications of jmx
in the real world and is that a question
does it yeah yeah sure as I mentioned
you know JMS if you have some JMS
resources like a message queue or
something like that you can certainly
monitor it with JMX so you would need to
implement a nemmine representing the you
know the management interface of the
message queue depending on what you want
to monitor do you want to monitor its
size you know just like a queue right I
had an example with I think a queue
early on
so the message queue would self
represented as an MP and then you would
just put the attributes and the
operations that you want to monitor on
it and then you would register that with
e so you wouldn't be polluting the the
business logic or the queue itself say
you would write a different end beam you
know that's on the side just for doing
the management of it okay
yeah sure
right so you should try to keep them
separate you don't want to put for
example if you want an e you have an EJB
which is implementing or any other you
know beam that is implementing business
logic you don't want to make that the M
beam right you would have a separate I
am beam and probably you would contain
that M beam would contain a reference to
your other end the other business logic
beam that you are managing so yes it
would be more like that you don't want
to make I mean you could you could make
it but that's not good practice to just
make your existing you know because then
you are combining the business logic and
this management which is really
orthogonal to as I said this is like a
cross-cutting functionality it's not
related to the business logic so you
want to keep that separate
so the container itself is only going to
manage the mbeans
part of it right so you have to actually
write the driver code as I said when you
implement the EM beam about what you
want to actually do with it so for
example in the server example we saw
that I was actually trying to turn on
the power turn on the server or turn off
the server I need to provide the actual
driver implementation to do that so this
is only exposing the I can do it
remotely it's giving me an API but it's
not going to go to the server and turn
it off until I write the driver code to
actually do it so you have to write that
the implementation logic for actually
managing it this just gives you a nice
clean way of doing it like even through
remotely through for example an existing
console like J console and visual VM so
yeah so the ambience over is pretty
lightweight in terms of are you saying
is it going to impact the performance so
it's it's very lightweight and in terms
of the port you basically when you want
to start it for remote monitoring you
have to specify like our Emma you can
say which port you want to start it on
so you can actually specify that but it
is basically the management itself you
are going to do remotely right if you
are running your management client is
going to be remote and then the local
monitoring as long as you are not doing
again there are two types of monitoring
you could do right you could do like
detail profiling where you're collecting
statistics and stuff very frequently the
other thing is you know you just let it
sit there and only when you want to do
like maybe power on or power off you're
actually doing something so if you are
doing very intensive monitoring yes it
could you know take up things but if you
are just using it - okay whenever I want
to turn it on or turn it off I'm going
to use it and I want to redeploy I want
to use it then really it's just sitting
there it's not doing anything and
actually we have even deployed the agent
on you know Java ME because it doesn't
come with a standard container but we
have our own implementation which we
have put on that and it's pretty
lightweight so even the agent footprint
is really low and we can put it even on
those small devices so it's not a major
okay so for the J console and the visual
VM just going to very quickly give a
demo
how we can use those so let's see
actually I think I might just do visual
VM first I don't know if we have time to
do the other one
but basically this is an out-of-the-box
tool that comes again installed which
any case you just go to your JDK bin
directory on J visual VM and it launches
this so this is based on the NetBeans
architecture and you know here I already
have some so it by default it
automatically starts monitoring the
local java processes that are running
and then remotely I can establish some
connections and I can say that C hope I
got that right okay in the meantime
let's take a look at the Tomcat local
process that is running here oh okay
so basically this is the dashboard kind
of thing that shows up and you know it
tells me that I'm running a java hotspot
on this Tomcat it tells me some of the
arguments that my JVM has been started
with then there is a basic monitoring
thing you know which tells me the CPU
usage memory usage threads classes
things like that I can go to threads and
look at all the threads that are running
I can look at the details and you know
if I see a lot of red in here it
probably means that there is some
contention going on I can even take
thread dumps and then analyze them later
and then there is this mbeans so
basically you can see that the JVM the
Java itself has these kind of by default
these are the mbeans that are registered
by the java JVM and then these are the
ones that are registered by Tomcat and
if we go look at for example the logging
one we can see how we can dynamically
change the logging level without a
restart so for example I want to take
this and I go to the operations and I
try to get the logger level for this and
right now it's not set to anything so
there is no logging turned on on that so
now I can say I want to for that
particular logger I want to turn on info
level logging so I say set logger level
it invoke that and then now when I check
the logger level you see that it has
been set so without even requiring a
restart I was able to for this
particular logger any methods that are
being generated by this logger on any
log messages generated by that logger
will now be logged at the integral level
and I can do that even for Tomcat or
anything like that so this is very
powerful and if you have any other
configuration stuff that you want to
really expose you know so even if you
hide your
own applications they would show up here
as well so you know you have exposed
them as mbeans and if there are any
things that you want to change on those
then you can actually change them
dynamically here without requiring a
restart so basically it starts
monitoring everything without requiring
you know I didn't even have to do
anything I just started it up it
detected what local Java proxies were
running and it's showing me all this
monitoring information and a lot of
these you know app servers and web
servers and things like that they
already exposed gmx interfaces which is
why you see that there are EFI showing
up for tomcat automatically here yeah
so you are going to be connecting to it
is you're connecting to an ambien server
but that's basically a remote JVM right
you don't need to run visual VM there no
yeah you don't need to so actually
that's the thing I'm trying to do I have
something running remotely let me see if
I can actually get that to work
so because this is running not on your
remote box which are monitoring so the
actual work is being done here and as I
said on your remote box it depends on
how much of monitoring you are turning
on which is why actually if you see
there is a profiler option here okay and
that can be very intensive and visual
wium actually allows you to only do that
on local processes okay it doesn't let
you actually do the profiling because
profiling can be very intensive so these
options will not show up on a remote so
if I hopefully this I can connect so
this is a remote box and I actually
don't have visual sorry gmx enabled on
that I have something called a stat D
and that exposes some basic monitoring
information but to get that
maybe I should just restarted to see if
it shows up
so as you can see it's in the JDK bin
and everybody should have it installed
by default as long as you're running
Java 5 above ok
I don't know if I'm on my DPN because I
need to actually yeah I am connected
yeah I'm not sure I think the remote
stuff for some reason is not coming up
right now but basically it looks similar
to the the local stuff and except that
as I said the profiling options will be
disabled so you won't be able to do this
one because it's very CPU intensive and
I can actually try turning this on here
for example if you see this okay it
takes a while to actually perform the
instrumentation but you can run detailed
instrumentation on CPU and memory here
so typically you would do this only if
you see some error issues in your
primary monitoring say you see a lot of
CPU usage or you see memory leaks you
think you suspect there is a memory leak
you would run the profiling for a
limited amount of time and then you
would go through the profiling results
and see if you know there is something
that you can track you can see what's
going on so that's typically when you do
and this can be quite intensive so you
don't want to run it for a long time so
you would run it for a very short time
and try to just deep out the issue and
then you would turn it on and yeah
yes you can take heap terms anytime you
want so actually let's see yeah so you
can take the heap jump and you can even
cause the memory I mean a GC collection
to happen so it can be done and actually
it's good to take heap terms like if
you're suspecting Co you know memory
leaks take two different heap terms and
compare them and then that can help you
track some memory errors and stuff and
so basically I mean these are for
something that's really out of the box
these are very very powerful tools both
this one and J console and you should
really look into using them okay so this
one does not have the J console plug in
okay sure so security part so for the
local process it will only automatically
start monitoring the processes which
belong to the same user so if you have
processes running for some other user it
won't for the remote ones because it's
using RMI and things like that you can
always set up whatever so since it's
using existing underlying transport
mechanisms you can use the security
offered by those for doing so typically
I mean for my testing purposes I just
turn everything off I don't really
enable the security but it is highly
secure if you want depending on how much
security really want to enable so it's
very flexible that way yeah thought I'd
configure these but for some reason it
seems to have disappeared
yeah let me just start the J console by
itself if I can find my VNC
okay so this is the other tool that I
was talking about Jay console and Here I
am connecting to like a WebLogic server
that I'm running there and this is
similar to visual VM it's actually not
as powerful as visual VM I would say but
one of the cool things here is I mean
here you can you can do the same thing
you can do the garbage collection and
for the threads there is even a way to
you know detect thread law deadlocks and
stuff like that so I'm not really doing
anything but basic deadlock detection
and stuff it can actually detect and
then you can actually even look at the
thread details what they are doing what
state they are in intake thread dumps
and then the mbeans again similar to how
we looked at the ambience and the other
one you can actually look and so this is
running the BA WebLogic server and you
can see that they expose a lot of mbeans
as well so this all comes out of the box
I haven't actually done anything these
are all the mbeans that are exposed by
the WebLogic server and also of course
we always have the the java dot Lang and
Java dot util which are the the JVM em
beans and basically all these other tabs
are getting information from these
ambiens only if you think about it right
it's more of a better user interface but
the same information that's available
here so here it is just available as
attributes and operations and things
like that and then the same information
is collected and displayed in a better
fashion in some of these other tabs so
that's basically what it is and so you
know you should really look into using
one or both of these tools visual vm i
would recommend more than this one
because it has j console in it plus it
has a lot of other command-line tools
like j stack and j stat and things like
that integrated with it so it's pretty
cool okay i want to move on because we
don't have too much time here and i want
to make sure that I go through the rest
of the presentation so let's go back to
okay so we saw the two things here
visual VM and J console and we saw we
can monitor performance memory usage
leaks thread deadlocks and more so you
have to you know you should really look
into these and play with these a lot
more you know we just did a very brief
intro here and again the overhead is
typically negligible as I pointed out as
people asked and the other good thing
about visual VM also is that it has a
lot of plugins and so it really helps
you to extend some of its functionality
it's an open-source project and there
are a lot of plugins available like you
know similar to dtrace and things like
that so you can really extend its
functionality and then there's also this
j-rock admission control is another tool
which is not bundled with with the JDK
and I think there was a presentation on
that yesterday so I'm not going to go
into that ok app servers in JMX so as we
just saw the WebLogic server exposed a
lot of stuff you know a lot of mbeans
a lot of functionality and these are
used typically a behind the scenes the
app servers use gmx for managing
monitoring and a lot of other
administrative tasks and if you also
look at some of the in addition to the
app servers you should also look at like
we also saw tomcat right and then there
are also other middleware products
hibernate eh cache coherence other
fusion middleman most of these products
expose jmx interfaces so you know if you
are working with these products you
should look into the documentation to
see if there are JMX interfaces they
expose and then all you need to do is
launch up for visual VM or J console and
you will be able to see those mbeans
like we did for the fab logic and the
tomcat and you know there are some
things cool things that you can do also
again HP openview Tivoli these are some
other management tools so if you're
using those company-wide you can also
even those expose jmx interfaces and you
might be able to manage use that as your
gem X client okay so as I mentioned
before JBoss uses JMX you know at least
in its initial architecture it used it
as its fundamental
infrastructure so there was only a basic
microkernel and everything else was you
know an ambien so all the services
everything was plugged in as an ambien
which gave you know which basically gave
a very very flexible modular
architecture you could plug in plug and
you know deactivate services based on
what you needed what you didn't need but
now they have also moved added something
called a micro container which
apparently seems to me again I don't
know all the details of this it's just
based on what I've read and this is
allowing you know it doesn't require a
JMX container and so you can do direct
force your deployment and it's it has
got an IOC framework some water spring
so but it definitely supports still the
JMX architecture it's part and parcel of
jpas even now so they're always backward
compatible with that but they also have
this ioc framework now span jmx so a lot
of people might be using you know Spring
Framework and if you are you are in luck
because spring actually provides very
good support for JMX and you don't have
to write you know all the boilerplate
code that we saw earlier you know to
sort of create you know publish your
make you know create your NBN interfaces
and then do all the wiring you know
getting connect publishing your MB into
the ambient server and configuring the
proxy all the tedious boilerplate stuff
that we saw doing which we did through
the API can actually be done in spring
very conveniently so you can you know
use annotations to indicate which
attributes and operations you want to
manage so you can take any photo class
spring class or a spring beam and then
you can convert it to an MP in a managed
bean very easily and also you know you
can use XML configuration for doing the
connection wiring and things like that
so definitely look into that if you are
a spring shop and see how you can
convert some of your spring in your
spring beans very easily into GM XP and
swap on a drink you can just decide
which things you want to expose for
management and you can basically expose
them visitor and again you can just use
J console or visual me up once you have
done so you you can just register them
with your platform and pin server and
you can want to manage and monitor them
through the standard gem X console
okay other user applications so you know
in addition to all these standard app
servers and spring and other things
offering you support what about how can
you as a programmer use gmx in your
day-to-day work so assuming you are
writing anything other than you know
very HelloWorld kind of application
these are some of the things that you
might be interested in your app to have
right so as I already mentioned you
might want to change your applications
configurations and properties without
requiring a restart you can change the
logging level you don't want to restart
every time you want to manage the
lifecycle of your business
components you want to deploy and deploy
start stop you want to collect
performance metrics and statistics you
want to say you have a cache you want to
flush it you know and when you do that
you can get a notification if you are
using JMX
saying that your underlying data has
changed and you can use that
notification to take an action to clear
your cache caused it to be fetched you
can be tracking your application state
you know get notified about transactions
or transitions threshold crossings so
different ways that you can really use
this and one and another thing is also I
mean I think couple of Java ones are
goats the JMX team actually demoed this
if you google this you will see how they
actually used it you know for online
game monitoring and you know I mean you
could do that game control and things
are things like that as well you can you
know maintain the state see who is you
know logged in into a game and how many
users are there and what's the current
state you know is the game finished so
any kind of basically state management
and state tracking and things like that
you know you can use that so pretty much
it's only you know the possibilities are
endless you know so just use your
imagination
okay just a brief one slide about how we
use this in OP Center as I mentioned we
use this extensively it is the
fundamental framework for us so what is
off center it's a systems management
product from Oracle for managing a
distributed enterprise data center from
the OS and below the rest of the
enterprise
another suite manages things above the
OS so the apps and the middleware and
things and the database are managed by
the the regular product but we manage
the system side of it and as I said not
only do we represent all the resources
and their associations as M means but
also all the services themselves are
also modeled as M beans and because we
have to deal with very distributed data
centers we have a multi-tiered
architecture and so we have all the
managed systems running on the which are
running JMX agents then you have a bunch
of these managed systems typically in
the same subnet connected to another
proxy controller so they are all talking
to one more JMX agent aggregating there
and all the proxy controllers are then
finally talking to one enterprise
controller which itself is a gem X agent
and so there is a normalized aggregated
domain model view presented at the
enterprise controller layer and the
clients and then this is exposed to the
service tier at that enterprise
controller layer which are themselves GM
x and x beans and the thing is that the
standard JMX implementation does not
provide this functionality it's part of
the GM X 2 dot o spec or as I mentioned
it's available in the open DMK open
source project that does provide
functionality like this cascaded and
being servers for the Federation virtual
mbeans you know when you want to create
many AM beams which are short-lived like
threads and things like that you don't
want to keep creating them a priori
you can create them and you need them
and throw them away so things like that
are not provided by the existing gmx 1.4
implementation which is part of the JDK
but you know we have built a specialized
container around that but you know the
same functionality is available in the
open DM case so that's something to look
at if you are looking at bigger
deployments distributed management we
also do actually cloud control which is
like we have we can deploy IAS clouds
through our ops center product and if
you think about it some of the common
cloud management tasks fit into the JMX
model very well right so one of the
things that you want to do in a cloud
model is you want to provision right you
want to setup your infrastructure you
want to set up your application
stack and really what you are doing
there is you know managing your you're
basically deploying you're laying down
your components and JMX is perfect for
that and then once deployed do you want
to manage and monitor that right and if
most of the things that you're deploying
are the middleware and the application
stack then as I said those things
already come with DMX support you know
WebLogic Tomcat if that's the thing that
you're laying down it already comes with
a lot of support and you can just use
that to the management and monitoring so
they expose the API is already then
because of the notifications how you can
use that right so you are monitoring you
it JMX helps you to monitor the
utilization you're keeping track of how
things are being used if you feel that
there is a lot of utilization for an
extended period of time
probably this customer needs to be
scaled they need a bigger deployment so
you auto scale you do the that's the
elastic cloud concept right you can do
that using notifications again since
you're also monitoring their usage you
want to do the charging and metering
thing you can do that because you're
calculating you're monitoring how much
they are actually using if you want to
charge them based on that and then
quality of support so you say that you
know it's going to be highly available
or whatever and because you're
constantly monitoring and it helps you
you know rebalance and do performance
tuning and things like that so it's
pretty good for that as well and so the
OP centers IAS product is also heavily
based on gem X okay just a couple more
slides here we have 10 more minutes
that's good
so jmx best practices so these are like
you know just some high-level design
patterns on how you should use JMX so if
you define an object name for an MV in
the remember that's the name that you
use to register it with the ambient
server it has to be a unique name and
typically you would give a type so there
are a bunch of name value pairs you can
give but usually you give a type and a
name and the name that you give should
be user friendly because remember these
ambiens are directly exposed in the j
console or or the visual VM so they
should be user readable and then I
already talked about this I think
somebody raised the question about
keeping the business logic and the
management
logic separate so you don't mix the two
you keep them separate mbeans are going
to be there is an overhead so you don't
create too many of them
the ambience should be more like one M
being functional component so if you
have like a shopping cart that would be
an M being you know just maybe a credit
card
charging would not be an MD that would
be more like an operation within a
bigger M being so you don't want to
create too many of those use M X beans
wherever possible we talked about that
already
instead of M beans use M X beans because
it lets you the client does not need to
know about the the custom types you are
using because it can convert it to the
open types use proxies again as I
mentioned because of the strong typing
do not directly access it with the
strings notifications again use
prudently don't use notifications all
the time if you can log if all you're
going to do with your notification is to
log it just use logging at the
appropriate tier notifications should
typically be used only if you are going
to take some action on them and then the
cascading Federation that I talked about
when you have a distributed environment
you want to do that with several MB in
servers and again unless you want to
implement your own you can look at the
open DMK support for that it's not
available in the standard JDK version of
JMX and same thing for virtual virtual
mbeans is also supported in open DM k as
is the SNMP adapter and some other
adapters is HTML adapter and HTTP
adapter Web Services adapter all those
things you will be able to get from open
DNK future of GM x so j MX has been
around for a long time it's a very
mature and stable technology as I said
unfortunately the next version of JM X
which is to dot o seems to be you know
dormant right now I think there was a
plan to put it in Java 7 it never made
it doesn't seem like it's going to make
Java 8 I didn't see it in the Java 8
list but the features that were proposed
for JM x 2 dot o are available in some
form shape or form today in the open DMK
project so it's not like
you know in the meantime we are stuck we
can certainly use namespaces cascading
virtual mbeans and for annotations you
of course you can use spring so a lot of
these things are available somewhere and
again as I said other connectors
rest-based connector a JMS web services
connector if you want to look at those
they are available also I also found
something called Jolokia which is again
another open-source project or with an
HTTP json adapter and a lot of work
community projects around JMX if you
look around you can see like groovy and
Ruby are providing JMS hooks to make you
you know being able to connect to gem X
and beam servers from Ruby or groovy
clients so there are projects out there
which basically help you get a reference
to the NBN server and then wrap a groovy
and being around it and then you know
it's like a groovy object or if it's
JRuby it's a JRuby object and then you
just you know invoke the methods and
everything else as if it's a local
groovy or JRuby so there are you know
community projects going on around it
and you know hopefully this is something
that you can take advantage of and I
think the slides are going to be posted
and here I have a lot more references
for you you know to which go more into
detail about how these things are
actually being used so I didn't have
time to actually cover everything that I
want I mean in detail so you know these
are the references to go to to get more
information and there are also some
blogs that you can use people blogging
about JMX and you can get more
information as well there and with that
actually we are done so if there are any
questions we have about five minutes and
I can take any questions people might
have yeah
ah database file system
yeah I mean you represent you can
represent your database as an ambien and
you can manage it definitely any any
resource but you have you would have to
put a Java wrapper around it basically
so depending you have to decide what
interfaces you would need to what part
of your database you need to expose and
then after that but I ultimately you
would still need to write the driver
code so this will give you a way right
through Jay console or something you can
connect but the final driver code to
actually talk to the database you would
need to provide in the implementation of
the MB there doesn't need to be a JVM in
the database so but there has to be
driver code that you will use to talk to
the database whether it's sequel code or
any other whatever type of code you
would put that and that could be so your
Java code will actually call that the
lower-level driver code and that will
actually go and interact with the
database and do whatever operations you
want to do it will return the results
back to your mbean and then that will
display it back so that's how you do it
yes file system anything can be modeled
so but as long as you are writing the
driver code right to actually talk to
the file system and once you get that
back you need the Java wrapper around it
so it's already in the JDK you don't
have to install anything what's on yes
and even the J console and visual VM is
installed by default you just need to
launch it so</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>