<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Reactive REST Clients in a Microservices landscape | Coder Coacher - Coaching Coders</title><meta content="Reactive REST Clients in a Microservices landscape - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Reactive REST Clients in a Microservices landscape</b></h2><h5 class="post__date">2017-07-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nHgHhkE9qjc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi welcome to this Oracle code session
today we will discuss resting in a
synchronous world so the goal of this
session is to discuss restful web
services given that we are working with
Java we will base our discussion on a
jaxa right now this session will
basically look at 2 angle we will
contrast and compare synchronous
approach and a synchronous approach now
we will do that for both producing rest
endpoints and consuming rest endpoint so
that basically means that we will look
at what a sink and sink mean on the
client side but also on the server side
so let's first discuss the client side
so in the Java space we have jax-rs
jax-rs stands for java api for restful
web services it's a standard base API
that we can use to produce rest endpoint
and since jax-rs - we can also use that
API to consume rest endpoint so if you
look at jax-rs prior to a jack's rise to
jax-rs was basically an easy to use
frameworks that you would use to expose
rest endpoint it was part of Java EE
having said that you can also use Jack's
right chakras outside of Java so you can
use address just on top of Java C so
prior to tax rest - you had an easy to
use server-side framework to expose
endpoint but when it comes to consuming
those endpoints you basically had to
write yourself the code to do that and
either you were you would use an API
such as the HTTP URL connection from the
JDK which is a very old and very
low-level API so there was clearly
mismatch between the client-side so that
how we would consume the rest endpoint
and the server side on the server side
you had a very easy to use API
API so you had to do that either using a
low-level API or you could rely on tough
patty solution this was solved in jax-rs
too with the addition of client-side API
so now in jax-rs injector is - we have a
server-side API that we can use to
expose rest endpoint but we also have a
client-side API that we can use to
consume is lead those rest endpoints so
today i will discuss about jax-rs -
which is the current version of the
specification J's are 3 3 9 which is
part of Java e7 but again you can also
use a phrase outside of Java EE so
purely on top of July C I will also
discuss partly as access to 1 which is a
next version of the specification which
should be released during the summer
this year and that is GSR three seven
zero which should be part of to evaluate
something which is important to mention
and I will based my discussion on jax-rs
and I will use Jersey because it's the
open source reference implementation of
jax-rs but given the fact that sector ax
is a small ax typically I see you can
obviously use any compliant
implementation such as a refugee apache
wink and so on and so on
so actually there is nothing really
specific to Jersey during this session
so let's look at all the jax-rs
23 egg works
we first need to have a client instance
we get a jax-rs client instance through
this very simple bootstrap mechanism so
client builder new client will get us a
client instance that we can use then
from that Kent we will have to construct
a web resource target a web resource
target it just is just the location of
the network where our remote endpoint is
then based on the target we will
actually construct the request itself so
in this case let's say that we want to
get the forecast of the city of Paris so
that's why we are setting some query
parameters we also use the get HTTP
verbs given that we want to get a
resource from the network and we also
specify what response type we expect to
get from the remote endpoint in this
case this is a focus class and you see
that the result of our invocation is
indeed of type forecast now given the
fact that we have this kind container
and this kind container is a relatively
edgy object we need to make sure that we
close that time container once we are
done so injector is - we have this new
client API it's a fluent API so that
means that it's a very easy to use API
where you will basically chain all the
method invocation to construct your
request
so it's like a phrase where you actually
step-by-step you specify what you want
to do what you want to get from your
waste invocation so and the API itself
introduced different new objects like
the trial container that we have already
mentioned it's so if you don't decieve
anything if pacific convention over
configuration what if you see you have
the ability to customize that client
container we then have a web target so a
web resource target which is likely some
kind of glorify your i it's
the location on the network of our
remote endpoint to construct a web
target from a client container and the
nice thing about the jax-rs client API
is that it basically shares a lot of the
concept that we have on the server side
so we have the notion of path obviously
we also have support for templates like
we have on server side we have support
for query parameters matrix parameters
and so on and so on so if you are
already familiar with ajax is service
ipi you will see that the client-side
API is very simple to learn and we also
have this notion of request invocation
builder where basically you have really
the ability to customize your request
like you have the ability to set the
cookies what media type you expect to
get set the headers and so on and so on
obviously your security to define web
which HTTP verbs you want to use
something to mention is the exact rest
one's also having the ability to set the
visited or services we will come to that
later on
the flow of the invocation as we have
already seen is very simple so we have a
client container from that land
container we will construct a web target
and from that web target we will
construct our request and book that
request to get a response if we look at
that example it is the liquid some
example the only thing is that this time
we are specifying that we expect to get
some JSON type in return we also set
some headers and in this case we don't
want to have one single forecast but we
want to have a little forecast so that's
why we are using this generic type of
Vista of forecast now the tracker is
client API has also the notion of
invoker so if you look at this example
this is the example that we have been
using until now we haven't specified an
invoker so that means that we are
getting the default behavior and by
default the invoker that we have
originating is a synchronous invoker so
that means that this is a blocking call
so that means that as soon as the count
sorry the get method is invoked on the
client that method will block until the
response has been sent by the remote
endpoint so this is really a blocking
call the good news is that is that
jax-ur is - is also an asynchronous
invoker - introduced invoker basically
allows us to consume rest endpoint in a
non-blocking fashion to do that it's
exactly the same api the only thing that
we have to specify is that we need to
specify that we want to use the async
invoker and you see at the bottom of
this slide I'm invoking this icing
method so this is basically to tell that
to the objectors can container that I
want to use an icing invoker and the
difference here is that as soon as we do
we do the get invocation the method we
will return directly and if you look at
the return type that we get from these
Oracle's invocation this is not a string
or but it's a future type of type string
so that means that we have a future
object that we'll be able to use at some
point to actually get the result of our
I think rest invocation so to do a
remote and point a synchronous
invocation we basically need to tell on
the client side that so we balakey need
to tell to our objective client
container that we want to be dancing
invoker to do that we just need to use
the ethic method while we conserve the
request so you see that in this case
what we get in return
is our future off string so that means
that we have a future object that we can
query later on to actually get the
result of our with the remote endpoint
location the problem is that if it takes
a long time for the server to send the
response our call to the get metal not
know future object will be basically
blocking waiting for that result and
worse than that if for some reason the
server if the remote endpoint is not
able to send the result our client
application will wait forever for that
result that will never come so we need
to make sure that we set a timeout so
this is some example but you see that
this time we set a timeout of five
seconds while we do a get invocation on
the future object so that means that
this future object would be query for
maximum five seconds after that time
exception will be raised so our
application will not block even if the
server is not able to sender the
response but there's still an issue if
so that means that our application might
in worst case scenario be blocked for
five seconds so that means that
basically our client side thread will be
blocked for puffs at five seconds this
is athis is a big issue because that
thread is directly not able to do
anything else
so if we are using the same that
particular thread for example to update
the UI our UI will be frozen for five
seconds
given that it's a future object we can
do something like that instead of
invoking the get on the feature object
which is in itself a blocking call we
can check the is done and Ethan is
basically through once we have the
result
so once the feature is completed or has
been cancelled or an exception has been
raised
that is a workaround to overcome that
issue but still it's not very practical
once we have we are sure that is done is
true we can actually invoke the get
method on the future object which in
this case we know I will not be blocking
it in this case it's also a good idea to
set the client container timer because
we want to make sure that the get
request so the the get rest invocation
doesn't text too long something which is
also part of jax-rs too
on the client side is what what we call
an a synchronous invocation callback
that we can use it's basically a very
simple interface who has two method 1
method is completed so that method is a
basically a callback that will be
invoked when the a synchronous response
has been processed and the second
callback is a fel method that method is
automatically invoked a Finneran
exception has been thrown so if there
has been an issue in the invocation so
it works like this as usual construct
from the client the resource target we
are using the I think invoker given that
it's an asynchronous invocation that we
want to do we are using the get HTTP
verbs method but this time we pass an
instance of an invocation callback and
remember that invocation callback as to
call back the first one completed so
that's the invocation callback that is
invoked once we have the result from the
remote endpoint
the second callback is the cell method
that would be invoked if something goes
wrong now if you look at the definition
of the invocation callback we have
defining parametrize type in this case
this is a customer so that means that
what we expect to get from the remote
endpoint is a customer type you see that
the return of that resource invocation
is a future object of type customer and
you also see that the completed callback
is expecting to get a customer type as
parameter make sense that's what we
expect to get back from the invocation
now let's move on and let's put that
into this perspective here we have a
simple micro-services typical scenario
where we have one travel agency services
that will be the kind of multiple back
end
read services the scenario is as follow
so we have a user coming in through the
travel agency services and that travel
agency services would like to propose to
that user some potential destination
that you might want to visit so the user
gets to the travel agency services the
first services that will be invoked will
be the customer services so the idea is
that we first need to have some kind of
history for that given customer based on
that the travel agency services will
invoke the destinations received the
idea of that services is to provide some
potential destination for that user so
that means that the travel agency has
now a list of potential potential
destination to suggest and what we also
want to do is that for each destination
that we are about to suggest we want to
invoke the weather services and the
quoting services to add some weather
information to each destination but also
we also want to have some price
information to the destination that we
are about to suggest to the user once we
have all those results we basically
combine them and send them back to the
user so the user we
get a list of potential destination that
you might want to visit with for each
destination according to a price
information and some weather forecasts
now obviously given that we have
multiple services to consume we
basically need to implement some
workflow so the travel agency services
will have some kind of very basic
equation layer to invoke the different
services so the first service is to
invoke the customer services based on
that it will invoke the destination
services and once it has all the
destination it will invoke in parallel
the weather service services and the
coating services so it's very obvious
that a pure synchronous approach doesn't
really make sense for such an approach
this is a very simple scenario but still
in terms of performance it would be very
bad basically the the time it takes to
get the result to the end-user would
basically be the addition of all the
individual requests that the travels and
the services as to do so this is not
something that we want to do it's clear
that we have to go a synchronous for
that and let's simplify that services
and only look at two services we just
want to simplify the workflow and invoke
the destination services so we want to
have some destination and for each
destination we want to have some weather
information we want to do that in an
asynchronous fashion so if we look at
the code this would looks like this we
first do a request to the destination
services to get some recommended or some
suggestion obviously we are using the
sync invoker we have to specify an
education callback remember an
invocation callback you need to have to
call back the first one is a completed
callback that will be invoked once we
have all the result from the invocation
in this case we would get a list of this
nation so a list of potential suggestion
that we might want to provide to the
user then we would basically go over
that list and for all the element of
that list we would do another rest
request again we have to do that in a
sequence fashion so we use do a sync
invoker given that it's nothing
invocation we have to specify an
invocation call back when invocation
call back needs to have to call back
define so the first one is the one that
will invoked whenever we have all the
results now we also have to make sure
that we provide the thread callback for
the - I think request that we are doing
so we would have something like that
so I get that you see that that kind of
code is getting a little bit difficult
to write and that means that at the end
of the day we would have a called that
is all difficult to write debug and
maintain you also see that the error
handling is basically a spread across
our code so it's clearly something which
is a bit difficult and why is that well
we said that we want to go synchronous
because we want to get the the
performance and the scalability we don't
want to be blocking to do that we have
to use the ransom from the API but given
that they are dependency between our
services we see that this API doesn't
really fit that model where we have to
invoke in an asset instruction multiple
services and each services as dependency
between another services so it doesn't
really work Zachary's - as to invoker
the default invoker which is a
synchronous invoker so that means that
it's blocking and it has also another
introducing proper this is the I think
method injectors - one is adding a
thousand blocker it's a reactive a
synchronous invoker it's the RX method
that you see at the bottom of the slide
and you see that one when we are using
that invoker what we get in return for
the
requesting location is of type
compression stage so let's quickly talk
about the completion stage API it's a
new API that was added to delay see 8
and I'll deny thing about that API is
that we had the notion of a state of
stage being an operation computation
that performs an action or computer
value in a synchronous fashion and we
have the ability to basically chain
different stage so we can define a flow
of different stage that needs to be
invoked in a specific order
so on termination of a stage a stage may
in turn trigger another dependent stage
execution now if you look at the
compression stage RDoc it the API itself
might seem a little bit daunting it has
a lot of methods it has around 40
methods to grasp the API you just have
to understand a few concept and for each
concept there is logical keywords and
that keywords will basically be used to
construct the method that you're going
to use so that's why we are lot of
methods but at the end of the day those
methods are just basically a combination
of different behavior for example on one
stage execution we may trigger another
stage so if you just want to trigger the
execution of another stage you will use
it then keyword but if you want to
trigger the execution of a given stage
once to a given stage are completed you
would use a combined stage and if you
want to trigger the education of first
stage on if one one of the two
completion stage are done you will use
the other keywords so other concept that
you have to know does the computation
takes an argument and returns a result
for example we have the hot light
keywords so that means that you are
going to supply the function with a
result of the previous stage as argument
and that function will return the result
you have to accept keyword that one
takes a consumer I need only technology
so it doesn't return anything given that
it's a consumer you also have the run
keywords that takes a runnable so it
doesn't have an argument and Inter's and
returning results another concept with
its keywords that you would have to
understand is a out execution of the
compression the do computation is
arranged so if the letter doesn't hand
with the I think keywords that means
that we are using the stage the default
execution facilities but only high on
the other hand if the method ends with a
sink that means that we want to use the
stage default a synchronous execution
facilities and in addition you also have
the ability to pass specific a trivet or
services so basically to view the
compression stage API you will have to
combine those different keywords to
basically obtain the method that you
want to use so for example you have to
then accept method then you if you want
to perform that in a synchronous action
you have to done except I think or then
except with the ability to pass an
executor and so on or you might have
done except both if you want to wait for
the execution of both completion stage
before triggering another completion
stage or then accept both passing method
and so on and so on so to get the
constants a GPA you really need to
understand those different keywords and
then it's just a matter of using the
right method if we look at an example we
have a first request so this one's
requested to remote endpoint with some
pricing information for a given
destination you see that we are using we
are using the Oracle invoker and then we
have a second request this one is used
to get the forecast information for a
given destination and again you see that
we are using to our it invoker so it
that means that what we get in return is
to completion stage
when both states complete normally the
two result are passed to the function
that we have here so that's what that's
why we're using two then combined so
that if we are for the first compression
stage and we want to exhibit that one
and the second compression stage so the
GS F once we have the result they are
passed to the function which in this
case is reserved if affordable method
that get that get as a parameter of the
to result of the invocation so the
following example obtains in parallel so
in another construction of price and a
forecast for the destination and it
makes a reservation if some specific
condition rmx so this is basically a new
injector as to one we have this new
Ericsson rocker that allows you to
consume in a synchronous fashion remote
rest endpoint and then I think about
that API is that we are using the Java
jet compressing Search API to basically
define the dependency between the
services that we want to invoked the
completion stage is supported out of the
box injectors to all those actors
implementation all the jacks or s21
implementation must abort the
compression stage API having said that
the goal of the specification is to make
it extensible and open to the octave
frameworks for example the Jersey plans
to add support for rx Java let's look at
a quick demo to illustrate this so what
I am running on my machine is the
basically this travel intensive services
it's one of the vectors a sample that
sample has basically all this the
services needed to fulfill that scenario
so we have travel urgency services and
then running on the same machine we have
the mythical back-end services the
weather services destination services
and so on this is the gate of
that sample so basically we have
identity services so this is basically
the travel identity services and it has
multiple implementation it has a
synchronous implementation so if the
travel agency services will consume all
the backend services using the
traditional synchronous approach so the
booking one there is also a synchronous
approach and finally we will also use
the completion stage again so the one
using the computers instead GPIO if we
look here we also have remote services
so this remote services are basically
the back-end services for example we
have is one remote destination visited
will give us a list of visited services
so if we go to the URL so I'm going to
my local machine where or 9090 let's see
our extremal destination visited I
should have just talked this is what I
get sold as summary story so this is
just a result of one services on your
hanif am asking for recommended the
deposit area where the user has to what
this nation was just to the user we have
some result and so for example I can
also ask to ask some specific forecast
for one given destination so we need to
give a city here this is just the result
of one location let's now invoke the
traditional travel
agenda to reseed using the pure
synchronous synchronous
approach so I'm using the synchronous
agent and we see that well it takes a
bit of time ok now we have the result so
that is a result that is composed of two
are using location from the multiple
services so we have all the history and
we have a set of recommendation and you
see that for each recommendation we have
not only
destination but we'll serve some
watering for some forecast information
and some pricing information and we have
that for five times what is interesting
is at the end works out the total
processing time and we see that for the
bottling approach to invoke all those
services basically necessary and fashion
it takes more than four second same
approach but using now this time the
asynchronous API object arise - and we
can have all the result we see that it
was quite faster so we have all the
destination that were visited and we
have a set of suggestion with each time
forecast and pricing information and the
processing time is all under one second
so it's really faster and last but not
least let's use the compression to the
API and again it was very fast
so we are gonna have all the results on
this destination and the process state
processing time using the compression
stage is basically more is the same as
distinct as the a synchronous approach
the takeaway here is that in terms of
performance and scalability you should
go a synchronous approach and then you
have a 2 choice header using the console
as a synchronous API or using the
reactive as and release API and in terms
of performance you will basically get
more than the same performance but
clearly if you have dependency between
your services and that's what we have
here so for example
it doesn't make sense to invoke the
Weather Service's before having the list
of suggested destination so if you have
dependency between your services then
your code will be a lot easier to work
using the reactive a synchronous API
so in summary and we have injector s2 we
have a client API that we can use to
easily consume rest remote endpoint we
have this client side container that
basically hides a lot of the complexity
for us so it's a high level API that we
can use it has multiple invoker it has a
synchronous behavior that's one you are
not specifying an invoker you will get
the default invoker which is blocking we
have also net synchronous invoker that's
part of Jack's rs-24 that you have to
use the async invoker you see that in
some case get my block so it even though
it's I think it my block because
remember that future I get might just
block waiting for the enter so if we
want to get around that we can use the
invocation callback facilities that is
part of Jack's rise to the zero but we
saw a so limitation typically when we
had multiple services to invoke and when
we are
we had dependency between the services
so it was not really easy to write such
a code so that is something that is
being solved in the access to one we did
new reactive invoker that the rx method
that we are using to get reactive
invoker let's discuss the low side
breast to expose rest resources endpoint
using the X rays we would have to do
something like list we have a class with
a few metals we are using the add Pat
annotation to specific are the trusted
also specify that this is the you write
for all those resources from that method
and then we also use the same at
presentation on a given method specify
the sub path
example I'm also using a path parameter
that would be resulted from times and
finally I'm using that reduce in
addition specify that this particular
rest resource end point is producing
that specific media type XML note that I
haven't specified any HTTP verb so that
mean that I'm using the default one
which is get and if you see I have the
ability to use different verbs like post
in this example so in this case my rest
endpoint is producing XML and it
consumed XML also note that I'm using
some query parameter in this particular
example so this is termed objects our
scope that we have been using Tinder's
now injects rise to we also have yogi to
the synchronous capability on the
service value so it works like this so
we have a Jack's arrest which force
method and note that we are injecting
using the Ab suspended animation this
new object
nothing response also note that this
method is return void so it doesn't
return anything so we now have these
sexers response that we can basically
use to basically do the request
processing in a different thread
so what I'm doing here let's say that
I'm in the Java environment so I'm using
a magnetic texture services to start a
new thread in that thread I would do
something that would I likely be very
expensive in that sort of resources so I
have an external thread I'm running some
very long-running computation and then
have this a sink response subject that I
can use in my external thread to
basically resumed the thread that was
processing the incoming requests all of
that is done using this analyzing
response object this approach gives out
the ability to execute the business
logic in a different thread something
important to mention is that the
underlying i/o thread is still blocking
so that means that my client is still
blocked until my I think response is
video this is true on both sides of the
connection connection so on the server
side and on the client side we have the
new Vasek response which now provide
them in for a synchronous server-side or
respond processing so we have the
ability to do the processing of the
response in a different thread that we
create it's injected using this new
extended annotation and we have
different way of working on that I think
response object so typically we inject
the right sync respond so we basically
suspend the thread we do the processing
in a different thread and in that
different thread at some point once we
have the result we would resume the
reaction of the request so basically we
would have to send the result the
response back to the client we can also
cancel the request we can also configure
the request to set some timeout and so
the thing that is key and that is really
important to keep in mind is that the
underlying thread is still blocking and
it will be blocked until the resistance
is being sent to the client and the
client will block until it has the
response so that is a key aspect
to keep in mind so if we try to look at
a basic schema that would be big that
would work we have a child that would
issue a Request on the south side we
have our Czech Terez
container that would process the request
and then on both sides of the connection
the IO the treads are blocked so that
means that on the server side the ioad
thread which is in orange on my Clyde is
locked
so my Jack's rest application is running
at some point in time one of the
dejected methods will basically suspend
the request by injecting the suspended
I think response object we now have the
ability to do the processing so the
business logic to get those the response
in a different thread so typically we're
in Java environment we do that using a
managed fixture services and then
extract that's an example once we have
the results available from that external
thread we would use the result the sorry
the resume to basically send that to the
clamp until then the client is locked
and the i/o thread on server hours about
so we invoke the I think response resume
later to basically resume the execution
of the response and the Jersey container
is now able to send the response back to
the client and until then the child is
blocked
now that the client has the response is
ready isn't blocked anymore so it can
continue to work do something that we
are typically used on the server side
one we have long-running rest operation
so it works like this so we do a post
request some long-running operation
happen and then at some point in time we
send a response back to the client so we
would send something like a 201 through
the resources being created and there's
the location of the resources now we
might want to use a different patterns
to solve
test use case so same approach we first
the current will post request and then
the server would answer directly with a
202 which is basically mean I've
accepted the redzone the resource
creation but I know it will take time so
what this ever will do it will tell the
client ok I will now work on creating
that resources but I know that it will
take time so please come back later to
see what when this is done the server
would also send send some temporary
location that the client can use to get
by the key or the status of that
resource creation so that mean that the
can't charity to issue requests against
that temp temporary or resource using
the complication that was send back to
him and then the server would answer
something like 200 so that means ok so
this is a valid temporary resource and
disabled has also the ability to add
additional details like for example I'm
expecting that resources together
available in the next 20 seconds so it
would basically give an indication on to
the client when they can expect the
resources to give it available so and
then the can that's only time will do a
request against the same temporary
location and if it has been created the
server so the rest server endpoint would
issue a 3 and 3 all trick which is a
c-collar so it buddy came in that the
request has been created and it's a
basically ever redirect to the new array
of the resources which has been created
after a post so that response would
include not only the 303 which is a
redirect but also the location of the
the final location of the resources
which had been created in the first
place so this is something that we would
use one we have a long-running operation
this is a popular patterns for showing
that case so it basically avoid to the
client to have to wait
in the case where resources takes a lot
of time to be graded on the server
now let's talk about something that
might be useful in that specific use
case and a tea service and event so ICC
is a widely used mechanism that is
basically used to send payload from the
server side to connected client this is
something which is widely used on the
web there is a well-defined standard for
that it's one way only
so that means that the can't establish
the connection once the connection is
established the server has the led to
push from the server some payload to
that connected client so the client has
no way to push notification from the
client to the server this is really one
way only
but we could typically use that
mechanism to allow the server to send
some notification to the plant for
example when a long-running operation is
done so as I see something that has been
added to eject or s21
so the jax-ur is to one they really
introduce different new object like a
sassy event so when this event is body
clip of a presentation of in service and
event it's a super interface that is
extended by two interface on one hand we
have outbound ACC event which is the
self side representation of an SS event
and on the other hand we have inbound
SEC event which is a client side view of
a server sent event so on the server
side we have the led to create event on
the client side we don't have the
ability to create event again this is
one way only so on the client side we
are just consuming server sent events
that have been pushed by the server if
we look at the API while we have this
new SSE even think object which is
basically a connection between a server
and a client
restaurant point and that is used to
string SS event so this is basically the
server side view of an SSE connection to
API allows us to group
multiple connections or multiple asset
even thing in one object which is a
broadcaster and SEC broadcaster and the
idea is that Elizabeth chapter is just a
collection of connected kind so if you
are pushing a payload to an ACC
broadcaster it will be able to magically
push to all the connected client if you
look at the our wit works using the CC
API you well we see that it's very
simple so we have this method we inject
to object the first one so this is a
server-side you so on the server we are
injecting the SS even thing which is the
connection between the server and the
trend and we are also injecting the SSE
object which is a convenient object that
we can use for example to create easily
SS event then all it takes is to
basically leverage the existing jax-rs
annotation so we're using the pad get
annotation in this particular case our
sse endpoint will be exposed using the
SSE endpoint and it produced that
specific media type service and event
media type then our method do something
and obviously at component time we are
expecting to push some payload to the
trend for example to tell the time that
- a very runny
- long-running operation is done so now
the current can fetch the actual
indifferent give resources and to do
that we just need to invoke the send
method on the connection object so in
this case even King dots an and
obviously we have to send some actual
payload so for that we are creating an
event and we can use the SSC object to
have that gives us a shortcut and energy
way to create some SS event we can do
that multiple times as needed by the
business logic of our application so
here the ID would be to send
notification to the connected client to
specify that that specific on running
operation is done
and if the tea at some point in time we
would have to close that SEC connection
object now if we look at the client side
we also have an object that's working on
the connection but now from the client
to the server so it's called as a
seventh source to consume is this event
on the client side we are using the JAXA
rise to one channel side API we need to
first create a connection so as each
event source we set the word free source
target of ours at the endpoint we have
the ability to configure that connection
so in this example we set the
reconnecting interval to five second and
so on and we see we need to make sure
that we actually involve
invoke the build method to actually
convert that object so we now have our
connection what we have to do next is to
register some callback the first
callback that I'm registering in this
example is a in Bangladesh even consumer
so it's basically a consumer that we
consume incoming event in this example
the only thing that my consumer is doing
is just print what as beans and I have
the ability to register different
consumer for example I can register a
travel consumer that will be invoking
something goes wrong and finally what I
need to do is to invoke the open method
on the SS events or so on the connection
itself so that's basically where I tell
my container that I want my client side
container to establish the connection to
my remote decision point and the
container the client-side container will
do all the heavy lifting for me so it
will establish the connection it will
register also callbacks and so on and as
soon as my connection is established and
any time some payload is being sent from
the server to the client my inbound
decision even consumer will be
automatically invoked for me and if you
see once I'm done I need to make sure
that I actually close my client ID
connection so the ID is just either
Jack's arrest one having a status report
and it might be useful to use
I said she support when we have on the
south side longer in operation let's
rocket
so uh today we have discussed jax-rs
basically we have talked about Jax
mainly about Jax raised to the zero
which is the current version of this
specification it's part of device seven
but we can also be used just on top of
jealousy and we have also discussed some
of those x-rays to one new capability
that are part of Java yet where again
they can be used in just Java C so the
two capability the two new capability
that we have discussed are the new a
synchronous for active account API or
Jax rs21 and also the introduction of
this report so jax-rs is a standard base
restful framework and it has support for
the service sites in the beginning and
singe access to we have added support
for client-side API that is standard
base is the fact that you can basically
choose which implementation are you are
using today I've used a Jersey but I
mean you take that code and logically it
would work on any standard checkers
implementation on the client side we
have discussed the client side container
that basically do all the heavy lifting
for us so it provides a very high-level
and simple to use API to consume rest
endpoints it has three invoker injector
eyes - so injectors 2.0 we have a
synchronous capability which is the
default in default invoker we also have
an a synchronous invoker and injector
act one we are having a tub a
synchronous reactive invoker and
typically you would use that reactive
invoker when you have multiple services
that need to be invoked and wonder
dependency between those remote services
in terms of performance I think that
it's fair to say that the pure a
synchronous invoker reverse is as fast
as the synchronous reactive invoker
so it's only really when you have
dependency between services that
you really need to look at the new
invoker that will be part of Jax rise to
one
the reactive invoker using the Java ec8
completion state API this is a mandatory
per third check first one specification
but it said that we also recognize that
there are already actual solutions out
there so the specification is open to
tough party rectified works so for
example Georgi support to the arocs Java
I will travel to and reasonable features
from guava and the only thing that is
mandated is the support for the
compression stage api and it will up to
the implementation to decide which
additional frameworks they are going to
support we've talked about jack first on
the server side so we saw this java this
capability and this has increased ins
capability that has united injectors to
that basically allows to resume the
location of a request processing from a
different tribe we also discuss a parent
that is used for long-running operation
to avoid that the client is blocking for
a long time and finally we have
discussed our service an event which are
part of Jack's rest one might be useful
when using that patterns
the focus of the presentation was
rejects arrest - and also we have
discussed some of the technology objects
rise to 1 which are part of Java 8 but
Java 8 actually broader than that
for example moon jelly yet we have the
salad for API which had support for HTTP
2 we have a new binding API to do
mashing and amassing of Java object to
and from JSON document we are CDI 2
which had a synchronous even capability
which is something that might be very
nice used with objects rise to Eric's
API even that the sync capability of CDI
to support also compression stage API on
July 8 and so on and so on so there are
really a lot of new stuff in July 8th
July 8 is about modernization of the
platform and simplification of the
platform this is really work in progress
the goal is to finalize Java 8 this
summer we have the open source
implementation of Java yet which is
GlassFish 5 that will be finalized
shortly after that but in the meantime
you can already have access to the
different Java 8 reference
implementation like GlassFish but also
Jersey and others so I think that today
you can already play with the API that
will be part of Java 8 including jax-rs
2.1 and in fact we have recently moved
all the Java development and the last
few development from java.net to get
that so so just go on github.com sorry
and you will have the ability to look at
the different specification which are
some are already finalized and some are
in a draft form and so you can already
have access to that and are excited to
do reference implementation and the ID
that we would like to get your feedback
on that before its final in the summer
so I
conclude with some resources that you
might want to check to learn more to
learn more about this
the first one is check Sura
specification I also encourage you to
check the different an example but our
part that are in the github repo of the
jax-rs Whipple repository you might want
to check the Jersey documentation which
has a lot of details about the
synchronous capability objects arrays
so we now conclude with a question and
answer so feel free to raise your
question and we will answer them thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>