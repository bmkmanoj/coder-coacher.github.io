<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Delivering Bug-Free, More Efficient Code for the Java Platform | Coder Coacher - Coaching Coders</title><meta content="Delivering Bug-Free, More Efficient Code for the Java Platform - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Delivering Bug-Free, More Efficient Code for the Java Platform</b></h2><h5 class="post__date">2013-01-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wjb2D9hbKa0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is ashwin rao and i'm a group
product manager with the delta / tues
organization i specifically focus on
netbeans hence the shirt the basic
agenda for this session is kind of
really look at the motivation and you
might ask me why I should anybody talk
about motivation right but i do want to
come back to that and you know kind of
talk a little bit about maybe what kind
of processes and best practices we
should be looking at and kind of review
some of the features now i'm going to
show you some things in netbeans but i
will clearly state that you know it's my
intent for this particular session is
kind of to see if we can engage with
provide my perspective on this and
perhaps looking look to see if you folks
can really pick some things up use other
tools to kind of accomplished delivering
better code so that's kind of the
overall nature of the agenda and the
preamble i kind of want to give is
really this I first proposed this topic
for a conference in India and I wasn't
too sure whether this would be kind of
accepted you know most of the sessions
were about the latest and greatest what
school and things of that sort and it's
like hey right bug free code and let me
see how many of you actually think you
can write bug free code thank you so
that's the first thing you know it's not
the intent is not really about hey can I
deliver bug free code but it's getting
into the mindset that you want to
deliver bug free code alright so that's
get that clear it sits there is no magic
bullet doesn't there is no big red
button that I can provide in the tool
saying bang now make sure that I don't
have any clue you know buds so I was a
little nervous whether it's going to be
accepted did get accepted the putas me
oh yeah I was quite happy about that at
the conference I go into room it was a
relatively smaller room because all the
big rooms were
you know the sessions that were like the
in things and I was surprised I was
surprised because a hell of a lot of
people trying to get in kind of like
today and I may be really nervous and
like own way what's the expectation here
right i mean i hope they're not
expecting that i'm going to reveal
something magical and kind of started
off and I said what I just said and I
expected a few people leave so I mean if
you're looking for a magic bullet there
is no magic bullet all right so let's
let's make that really clear up front in
this thing but the session went well and
in fact a lot of people came and said
they had certain perspectives about it
and I said okay that's pretty good so I
got the session you know into the a nug
basically submitted it over here and
here we are so that's a bit of the
preamble to it the other thing is I just
thought I'd kind of talk a little bit
about you know why would you want to
listen to me i'm here to provide a
perspective because i started my career
in the defense industry how many of you
are are with the defense already there
are a few folks here okay and from the
standpoint of the difference industry
you know when i got in i got and
directly from college and it's like okay
you're up you learn c c++ and by the way
i started working ada project any ADA
program is here okay that's great so I
started with that and it's very soon
became very clear the focus in the way
we were kind of working towards you know
delivering a project was all about zero
defects I mean I was writing code for
the command and control system for a
naval frigate really so my the machine
subsystem that I was working on as a
close-in weapon system something that
shoots down missiles and pretty much you
know you don't want to have defects come
up when you're actually when I missiles
coming at you at Mac to write so it's it
was that complex and the whole process
was very long drawn I mean if that's a
particular project you know the design
phase itself ran in a couple of years
right so you started doing a lot of
actual little bit of prototyping per se
but it's mostly designed
you know kind of level prototyping and
you've got into the coding cycles and
it's relatively short compared to the
years of design and the requirements
phase before that that went into it and
then you have this huge testing cycles
so the whole concept was you know you
want to make sure absolutely sure that
you could to the best of your ability
figure out whether this particular
software has no defects I mean again
zero defects I I don't think anybody can
claim that but close to zero yes that
was the intent and so the mindset was
delivered towards that so that's how I
started Mike area and and quite frankly
when I switched a few years later and
then I got into the commercial side I
was with the R&amp;amp;D organization for bond
which is an ERP company it's kind of
gone away and I started working I was
like wow this is pretty cool i mean i
can start coding you know I get
requirements i can start prototyping and
I can start delivering coal that's great
I was clean 10 and then I moved into
product management for a few years and
then I started working product teams and
the whole concept is different right
it's time to market nobody can wait for
45 years and I you know to kind of
deliver something somebody else was
coming to the market and delivered
already if you want a fish in code
return on investment is key and jauntily
compared to my previous background the
kind of longer coding cycles
interspersed with the testing it was all
kind of going hand-in-hand to some
extent very short design cycles right
the heart hardly much design actually
being done or vetted maybe design is
being done but actually vetted and that
was interesting I found that actually a
kind of like got a lot more freedom on
my hand and I was like quite happy with
that but all the course of time I've
actually noticed quite a few things that
really made me question whether that's
kind of right i mean we have a lot of
tools now trying to accommodate this and
this agile and the spare programming and
all these things you do sprints and so
on and so forth and that's fantastic the
time to market
but there are a few things that's a
question I started questioning as to the
validity of these choices you know
projects that I've been involved with
projects that I know of you know you
take decisions you look at some of the
code that's been written two years ago
on all of a sudden people have left the
code is there it's got some bugs in it
people don't know what it is and we've
been taking decisions you know what the
cost of actually maintaining that code
is far greater and lets you know rather
than probably rewriting it or dropping
that support completely it our
motivations to drop support just because
the code was not maintainable a lot of
bugs which shouldn't have been there in
the first place and so I started looking
back and saying is this the right
approach and fundamentally for me I
think there is a middle ground and
that's my perspective so one of the
things that I want to talk about was
really about hey can we get back to the
basics there are certain things you can
do and it doesn't necessarily mean it
has to it has to come in a way of some
of the newer techniques and the new your
philosophies for developing code so
that's pretty much my background you
know it's about 15 I started in the
1990s and so span from the defense to a
totally different world to a something
of the pendulum swung and I'm just
wondering whether there's a middle
ground and that's the perspective that I
want to provide and I certain tools that
help us and that's the other aspect of
it so you go through the process we look
at the tools and the tools are there and
I was really asking these questions are
we using these tools including in our
own organization and the answer was no
and I'm like why and so we can have a
look at bit look a bit of that as well I
mean there's many ways to do it I've
just put a very simplistic things what
is small at an efficient code really
know so people I asked people in say hey
we has to consume optimal resources you
know you don't want your code to be
hogging up all the resource that's fine
performance you want the performance
that's that's how it's kind of key for
everybody right easy to maintain that is
that that is kind of an afterthought in
many cases easy to maintain is one of
the clear one of the things that I think
is lost in
all of the kind of processes that we
look at these days when you write your
code up front the focus is on how you
know how well you do it and you know how
quickly you can deliver it the features
it meets but not a lot of thought goes
into will this could be easy to maintain
and we look at look a little bit about
you know what essentially does that mean
whether other tools or is it the best
practice that can work and really yes
the point is you've got to focus on
delivering software that has no bugs
that should be your focus if you go in
thinking you know what bugs are fine we
can handle later that's probably not the
best concept now even when you do when
you go to the focus you're always going
to have bugs all right so does there is
nothing like bug free code but you can
minimize it all right so just a bit of
history anybody here in terms of why do
we call a sulfide effect a bug thank you
very much the answer was the original
machines actually had bugs so this is
this is an interesting one the term bug
was gone by grace Hooper you know a
hopper sorry and it's essentially
essentially because there was a moth in
the original machines the you know these
are mechanical machines there's actually
more that was found right and that
caused some that caused a defect and so
there's this photograph and it's
actually on the wiki pedia of the actual
first bug all right so that's how the
term bug came into this effect it's a
sulfa different now I must submit it
spin you know it was a few years after I
was into software that I actually caught
on to this and somebody mentioned this
to me i was like huh that's interesting
i never really questioned why we call it
a bun so that was how it was basically
the first defect was introduced why our
bug generally where would you think you
can actually introduce defect
it's important to kind of understand
this because i think the motivation for
getting into this bug free mode it kind
of lies in over here you know a lot of
bugs can actually get in during the
specification kind of the requirements
gathering phase itself and when we see
that it means is ok you have a basic and
you know basic requirement for providing
a solution and you may not be thinking
all the corner cases and when you when
you look at those anyone you don't
provide those requirements and you
provide a solution and somebody gets
into a particular situation from a
consumer perspective or the end-user
perspective it could be a defect because
it's not a defect is not necessarily
something going crashing on your system
it may be handling not being able to
handle a situation it should have
handled in the first place now when you
try to fix it that's gonna be sooo you
and we'll have a look at that so the
design specification there are bugs
introduced what about coding that's
obvious any idea why data entry is in
here well I'm not saying I have any idea
what happened with your Apple maps stuff
how many of you have issues at Apple
maps in iphone 5 all right the lots of
people complaining about it I don't have
an iphone 5 I don't know whether that I
issues it looked pretty cool to me when
I saw it but I've been reading some of
the feedback a lot of it has to do with
something no data not missing and that's
kind of one example of you know hey data
actually providing you know actual
end-user defects that people log is bugs
so of course there are algorithms they
say that is kind of not good you know
somebody says hey you know what that
Google Maps routes me better but
sometimes the data itself is wrong you
say hey wait a minute my street is not
there it's not named or something of
that sort so you know that the fact that
data can also cause bugs is also an
interesting thing that people don't keep
in mind and certainly documentation as
well if you got wrong documentation it
leads to perhaps it leaders your you end
users doing something wrong and then
thats kinds causes defects and it could
cause
effects in how your software reacts to
those wrong inputs so it's it's not just
coding it's predominately in my opinion
requirements and design phase
predominantly a lot of it is introduced
because of coding as well and Deena data
is kind of a keen an interesting
combination and again I have no insight
in what happened with Apple maps I'm
just assuming that I might be off base
completely but i think it's when i'm on
a good example of perhaps data being a
cause of a defect being introduced so
from that standpoint you know this is
another interesting aspect that
organizations and teams don't really
focus on and I I tell you why because
when I started my career this was the
first sessions I have we had with the
team when he got into the project it's
like okay the bean counters came along
and said you know what here's what
happens when you guys don't do your job
properly interestingly when I got into
Commerce Commission's office space
nobody really talked about it when I
started looking to see if there's any
actual essential data that's available
regarding cost of fixing a defect bugs
defects there's not much newer data
coming through people are not
necessarily collating it so what
technically happens in the requirements
design when you catch a bubble with that
essentially what it means is when you
think of certain things that could go
wrong and you figure out that's a
requirement that your software has to
address that not way few people involved
that's basically you're an architect
they've got it yeah there's not much
happening and the cost is minimized to
that time it's not you know it's not
rolled in developing teams are not
involved and as you move forward when
you start coding yes it gets a little
more cost intensive you've got your
development teams now involved but it's
still the developer in question who
potentially can fix some things if it's
caught there so you literally the cost
of fixing a defect is relatively low the
idea of being that you
or extended team is not involved when
you move into integration there are
problems because now people are perhaps
dependent on what you've delivered and
any of things go wrong other people are
involved there's more time involved the
more of the teams involved and that's
that's an issue I mean you have
container continuous integration and
things of that solid Hudson and I've see
i see this even in our own teams and
it's a conversation i attend to have and
i tried you know try to have is all of a
sudden somebody you know delta /
shenzhen and says hey wait a minute I've
just made these changes to these api's
do you want can anybody tell me who's
affected all right ok this is in the
trunk it's gone into the integration
mode and then all of a sudden six people
said you know what I've got to redo this
stuff because your API has changed yes
we have refactoring tools yes it does
your job quicker but a lot about sixty
or seventy percent of the time some of
those API changes need not have happened
if you're thought of the design earlier
on and that's an important aspect that
you know that needs to be addressed it's
going to minimize the cost of addressing
these changes I mean you're going to
testing it's even more now you've got QA
involved you've got an actual process
that needs to get into players your buns
have to be filed to be dealt with q has
got to look at it and that's resource
intensive so it really concerns me when
teams nest you know are pretty much
going in this full steam ahead mode with
unnecessary giving a little bit of input
and once again i'm not advocating
getting back to the 90s or the defense i
just feel that pendulum can't come down
a little bit that's the concept over
here so i think it's kind of
self-exploration when you want to
deployment who is involved now it's your
customer base and my theory is when once
the defect comes into this it's probably
hardly going to be addressed just
killing it depends on you know support
and things of that sort and that in and
and there's a hell of a lot of thing
you know costs involved as well now you
somebody can actually give me a probably
give me or you know another perspective
to it maybe a lot of people make money
because if you don't have the effects
you know you don't get support contracts
fair enough but I think you don't want
to take a bar in a gamble on your sofa
because considered buggy right so that's
that's an important thing so as I said
we use we had a lot of bean counters
giving us data back in the 90s you know
little dedicated teams that were
reviewing it I don't know how many of
you would find this relatively old
information now this is something that's
all the web as I said I just borrowed
that it's from patty boom given in 2007
quite frankly there's not too much newer
data our own teams don't really call it
that this kind of data but this is very
very close to what I had experienced or
what we had to go through in the 90s if
you look at the cost of fixing a defect
beyond the coding stage things start
really jumping up and that's an aspect
as if you're part of if you're leading a
team I think it would be great to start
looking at these metrics because that's
probably going to help in the end for
you to provide better code so that's
kind of the motivation right as I said
you know maybe the first question is you
know why would anybody talk about
motivation to fixing the you know
writing better code it's obvious but to
me I make the case it's not really that
obvious because people don't really give
to spend that much time earlier on and
the motivation should be the last slide
over there now the challenges when
you're pretty relatively new to the
industry that's probably not something
that you're going to be tracking it's
it's probably going to be your
development teams and so on and so forth
and that's an important aspect but I
think you can make a better case for
yourself as you as you move up
through your carrier in producing a lot
a process and getting involved in making
it a habit and that would be much more
productive for the team as well as you
all right so when you start on your
preventing bugs okay this is kind of the
place where in you know people would
probably think is there a magic bullet I
guess I said no but I would probably
want to change it now to say you know
what there is it's actually you to a
large extent right that it's not Leah
it's not a to its it's you because as
much as we like to write good code very
clever code and for me clever is not the
same as good god you you got these
particular things to keep in mind as
programming styles programming
techniques that can help now if you look
at programming style what makes
programming what is important factors to
keep in mind the very fact if you want
to make code readable goes a long way in
reducing defects why well when you do a
court-ordered it's easier for somebody
to figure out what's going wrong in your
code and that's an important aspect
doing code audits how many of you don't
do code audits if you weren't willing to
share great okay so everybody is doing
code audit the point is it's easier when
you write code that's readable in fact I
actually did one of the you know things
I liked about ADA was it forced you to
be more descriptive when you're writing
code variable names need to make sense
you know it's not x y&amp;amp;z it it's always
about you know tracks targets and things
of that sort as in the difference in to
see kind of going on and you write code
now what is defensive programming now
it's actually an approach
basically allows you to kind of minimize
code by making it readable but also from
the standpoint of understanding whenever
you start doing something in your
process in your functions to think of
complete end cases you know so if I'm
looking at writing something that's you
know literally taking in an input which
has a actual limit on the string length
or something as simple as that your
defensive programming aspects of it is
really here looking at looking to see
hey what happens if I hit that limit is
that it is it an issue can I put in a
test to see what happens when that
happens a lot of the denial-of-service
kind of attacks and all of that stuff
the code injection actually happens
because people are not taking defensive
programming techniques seriously and
that's that's that's an important aspect
we have hell of a lot of denial of
service hell a lot of Unicode injections
kind of things happening and its basic
when you boil down to the end problem
most of the time it's because the code
got in between nobody put in those
checks you know using certain assertions
it's kind of part of this defensive
programming techniques you do that
you'll be able to minimize a lot more of
that all of these issues so that's the
style saree and when you when you talk
about programming techniques kind of
interchangeable you know the other
aspect is trying to make sure that your
code is kind of self-monitoring you know
in the sense you know the assertions
putting in a lot more assertions into
your code saying you know what I've got
this variable and I want to see what
happens when it hits its max or you know
as particular use case and scenarios
unit testing at that level should be in
the developers control and pretty much
looking at defensive programming
techniques it's going to add some time
yes but it still is much more worthwhile
across the lifecycle of the project so
that's pretty much the defensive
techniques the other things that you can
think of our development methodologies
there's lots of it and I'm not this is
not really going to deep dive into it
and there's language support right i
mean as i said ada for instance want
to make the if you look at some of the
strongmen documents in the middle
standards for ADA which by the way Java
kind have kind of if you look at the
history of Java its leveraged a lot of
some of the design work that's gone into
the language and that pretty much was to
make the language readable now so you
got these kind of programming language
kind of support one example is not
support pointers in Java that's kind of
done with this particular aspect in mind
and then there are things like you can
do with code analysis inspects the code
for errors beyond what the compiler
catches so you know these are things
that you could look at pretty much
immediately and this is where tools can
help now the other thing for me was
there are tools there are free tools in
the market are people using it a lot of
the time i see you know everybody's
using their very very keen about an ID
there are the ID wars as we call it as
NetBeans eclipse I include you all good
products certainly in their specific
areas of influence and many of them have
these tools but a lot of the time it's
all about the code editor that's great
collated is very very useful no doubt
about it but there are things that you
can use to start helping you with these
techniques to figuring out if you code
is that actually a fish I mean you know
static analysis tools right how many of
you use fine bugs excellent now with
this approach it's much easier to catch
a lot of these defects and we see we
kind of look at a little bit of what
fine bugs does in a minute for those of
you not used it and also being able to
kind of make sure that the dell yo code
the app unit level is delivering a
fishing code use the profiling tools
available this is no i'm not talking
about system level massive profilers and
things of that sort that's different you
need those you still need the system
level testing and all that happening but
you can certainly run your own software
very quickly throw profiler and figure
out what's going on before you actually
check it in or integrated visualvm is
something that is pretty
good now from that standpoint I
personally believe when you put that all
into an editor and you have an editing
environment does it leverage it right so
it bring it all together in an IDE and
so that's kind of where we jump into the
you know the ID specific aspect but i do
want to leave this open contrary to you
know what what I represent it's not
about just that means it's about tools
other tools in the market that have
these features leverage it right so fine
bugs right what what it essentially does
as many people already are about it
identifies potential bugs in many
categories there are different kinds of
categories and we'll have a look at it
and what we've done in 702 is
essentially making easier to use it
within the workflow that you're already
familiar with rather than switching off
and trying to do it again and things of
that there are merits to kind of
generating reports we want to take this
further there are ideas around it but
it's really to get that work for so easy
that there shouldn't be an excuse for
not having done it and that's the intent
so fine but we haven't done anything
clever ourselves it's fine bucks it's
it's an open source this thing it's from
the university of maryland it's an
excellent product i think and what we've
done is made it more accessible now if
you look at fine bugs as I said it's
open source there are lots of things
that tries to find you know back
practice this it's a category
correctness internationalisation
malicious code I'm just reading off the
list over here but the most important
thing a lot of the performance and the
security aspects of fine bugs or any
others static and static analysis tools
that you're going to use a hell of a lot
of things can be caught right there even
before you get to the profiling stage
and and I like the category term they
use dodgy code you know that's that's
very dodgy code yeah don't know exactly
what it's going to do right we don't
know this sounds different method
ignores return value is this okay
so when you pass that through your kind
of in catch a lot of things even before
you get to the profiling stage now what
we've also had in netbeans for a very
long time is a profiler and the same
profile as I soon see what you can
actually see it's part of the jeddak
java jdk gym in a part of visual vm
offering again there are other tools in
the market that have similar capable
erke pair capability tools so what do
you get from these you should be able to
quickly as i said you know run your even
your act unit testing quickly good they
take it through and do a cpu profiling
for instance or a memory profiling you
want to see how you know where are the
bottlenecks right just just go I have a
look and see what happens when you're
running your program see look at look at
the heap and see how many instances how
many classes variables are there and
you'll find a lot of the time that
you're looking at a wait a minute why is
there so many you know areas of strings
you know why is why is that is it
required at this point of time that's
taking too much memory what can I do and
guess what a lot of the time it's
actually perhaps a better design that
can address it and if you caught it at
this time you can probably change the
design pretty you know its ghostly gonna
cost because it might affect the other
teams but it's not necessary as advanced
in this in this stage as in when you
would find once the products in testing
or in the cup with the customer and so
this is a kind of key thing from that
standpoint is to understand that these
tools are there and it has to be
leveraged so what I want to kind of
switch now is to probably run through
some things we've done in at beans IDE I
talked about profiling I talked about
fine bugs and I've talked about
profiling and it's it's a simple it's a
simple thing to kind of think of the
concept of what it needs to happen but I
do
believe it happens often enough all
right honey how many of you are netbeans
users at this point of time okay I mean
if you actually used fine bugs with
netbeans kind of drop down there I mean
for me that itself is an indication that
it can improve and I really don't
believe there's any kind of actual
software that's out there that that is
completely you know for your bugs that
find bugs one catch now I actually
wanted to pick up and put Gertie an
on-the-spot guardians in the audience
over here he's one of his fine bugs
demos that he's done where he's profile
his own project and he caught a lot of
errors that he was a bit surprised off
himself and then I realized that
particular project required javafx which
I'm an older version of it now so I I
dropped that so this is going to be a
little bit more in terms of showing you
the capabilities rather than really
going to proving what kind of benefits
there are so I've got an anagram game or
a simple game this is just these one of
these example that we have and some
extent I could go to source and do an
inspect when you do that as I said this
is for us it's one of the start of
providing these kind of tools right now
we have the we would like to kind of
start what looking at more of these kind
of capabilities so fundamentally you can
actually do your introspection across
the project or across all open projects
and sometimes even at the file level so
that's something that you can choose and
you can actually look at what you want
to do so fine boxes got to separate
these things and I just do an inspector
at this point of time so it's it's not
going to look at the code the code is
extremely small it's probably going to
have a couple of errors if I remember
correctly or reports it's not necessary
in error per se and then I get this view
over here when I expand it
it's got some information that i can
look at there are two errors one really
and it gives me it give me some details
this is directly from the find bugs
documentation non transition onto that
instance field and cereal business class
and I you know if a double click it I
should go back to the code right there
now it you know it starts help stuff the
process of introspection already in fact
the accorded it is actually going to be
giving you these kind of hints right
when you're editing so perhaps that's a
good thing to take a look at it but fine
bugs also catches it I've got another
view that with fine bugs and also is
easy to kind of look at and this is my
category so so now I want to figure out
you know how much of this dodgy code how
much is a bad practice and if there were
security type of examples that would
come up here and you know you can then
start drilling down and looking at
exactly where this particular thing is
so this is a simple example of using
fine bugs and it doesn't take you more
than two minutes to do this but it's
going to take you it's probably going to
save you hours of rework if you had some
real issues here alright so that's a
quick example there the second thing is
ok once you've gone through the coding
phase we want to have a look at or what
exactly would be the capabilities that
you can do with the profiler right
alright so to do that we've got a
profile window here and I just start the
profile project immediately I'm given a
few options I can do cpu profiling
memory profiling and you can select
these you can customize the things that
you want if I select cpu for instance i
can do a quick one or an advanced one
with a little bit more instrumented and
profile any project classes or profile
all classes that you know the project
depends on so you can choose what you
would like to see I typically would like
to see this project classes I've got to
look at it and I said alright this looks
good I'll just do a quick simple run to
a run
and it starts the the actual app now
what I'll do is I'll switch on the
telemetry view and here it's starting to
give me a live view of what's happening
with respect to the heap size the used
heap some of the other threads thread
information and so on and so forth
loaded classes and that's already
started giving me that view what i could
do now is you know look at a few things
i could take a look at the library
results and now it's giving me
information about okay hold on a minute
this is more information about exactly
which classes and what objects we're in
the program you know that the
bottlenecks are you know the time taken
in anagrams initialization main these
are relatively simple but it gives you
that concept and I've got this live view
I could save this or I could take a
snapshot at this time and the snapshot
now gives me a lot more information it
gives me the call tree and tells me
exactly where all the time spent is I
can figure out okay what what calls are
causing some issues over here i'm
looking at main at the anagram get
install looking for you and it's kind of
taking me to the code which is
essentially where i can start seeing why
why why is that so much in our time
taken it probably it's a call to set
looking feel and that's that's not that
bad so i'm already getting a bit of a
sense for it there's also hot spots
right so it's again telling me which
exact method has those issues over there
this particular software has is very
simple in nature so you know it's not
necessarily telling me there's any big
problem but I could I could start
figuring it out and I could go to source
show back traces find in coal tree and
so on and so forth so this is kind of
the back-trace for that
so that's that one example if I look at
it I could also get a combined view the
if you're in a bigger monitor it's
easier to see I've got to kind of
address it to this particular resolution
so there's lots of information there and
as an info we're wearing I could
actually save this information or later
usage edit and put some comments and
send it to somebody to have a look at so
on and so forth I could even dump the
heap now kind of it's the profile
project choose ok and the heap has been
successfully saved to a file it's asked
me whether I want to open it in a heap
Walker right so I could not choose to
say yes open it in a heap Walker and
I've got some summary information about
what's in here total bytes total classes
total instances it's quite a lot of it
already i have a class view over it i
can look and say home there lots of hash
table any aware strings over here
showing instance view and it tells me
all the instances of that particular
class right now that now that I've got
the information over here I can look at
it see you know is there a reason why I
have to have so many instances of this
class and so on and so forth again
genuine if there's you know larger
larger projects landscape projects you
could have more of these challenges
right away and this can be done at your
unit testing level to some extent if you
have some example data or if you're
going to use some just some sample data
for yourself you could also inspect it
and I'm not very familiar with object
query languages but you could also do
your own kind of queries on on this
particular heap so you can do a lot more
you can get more information from this
just to make sure that your design your
implementation of a design is correct so
that's that's a quick example I didn't
really I start running this app it could
probably start doing more interesting
things you know but I'm not necessarily
trying to load up the app over here but
you can actually do some amount to load
testing answer if you know you start
putting in a lot more
entries into it you can actually perhaps
run some writing scripts to load up your
app and and then see what happened what
what does it do when the load starts
increasing it's a little more involved
but I think it's useful so that's a
quick look at it I could stop the the
profiling session now just look at what
might what you might get with the memory
memory profiling at this time so for
that I could restart oh I want to stop
this Ernie go back to the projects and
profile project and this time I'm going
to choose memory so similar kind of
stuff but the different kind of data
points you know you're not looking at
exact memory usage glasses objects
instances and things of that sort and
you run it
and I guess again start looking at the
view I got a telemetry view which you're
familiar with I could take live results
and this time it's kind of showing me
okay how many bytes are being used where
is where is the most kind of allocation
happening as an inter a I can go to
source now let's a primitive area am so
again you can start looking at it you
know if it's something that's putting
into your class per se take a snapshot
the snapshot provides similar
information than life but gives you more
info that you can save the snapshot we
use the snapshot and things of that sort
so by by adopting these tools not
necessarily NetBeans but I'd be more
than happy to hear feedback if you know
if you use netbeans you're going to be
influencing the quality of your product
and the delivery of a really better
solution much earlier in the life cycle
costing much less there are other things
that you could do with that but you know
probably things they can look at and
then by no means is this a case for not
doing profiling at the system level that
needs to happen that obviously does
happen in most most of the other
projects that you work on all right so
those are the tools but particularly
that's there in seven dot to
predominately help you write better code
and profile your applications and so
what what is it that we can actually
look at for me it's actually a very
simple thing you know I did lose a
bullet did I okay a defect already I
should have probably tested that one hmm
it's very simple bug-free coat should be
your goal whether you deliver about
record that's a different issue that
they nobody can deliver about free code
but you can minimize the amount of bugs
by practices that you employ this is for
the Java platform or elsewhere apply a
bit more process there are tools that
are available for free leverage them if
you do this I can assure you that we
look less that you have to worry about
when you start delivering the solution
set and it's all it takes in my opinion
to provide that tools are not the answer
it's actually you because you've got to
actually a employ the right process and
be use these tools so that's pretty much
it from the standpoint of of what I my
perspective is on this particular
subject and I hope you know there's some
takeaway to it and maybe at least causes
a discussion of sorts thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>