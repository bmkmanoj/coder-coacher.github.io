<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Redefining Modularity and Reuse in Variants—All with Object Teams | Coder Coacher - Coaching Coders</title><meta content="Redefining Modularity and Reuse in Variants—All with Object Teams - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Redefining Modularity and Reuse in Variants—All with Object Teams</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IfVXKp1IzCM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome I appreciate everybody who found
his way to this last session before the
party let me just right away start
introducing myself my name is Stefan
Hammond and while introducing a
recognizer kind of have a split identity
so the logo to the lower left indicates
that I'm working via my daytime job for
company called GK software within
Richard software my interest in that
company is providing the tools so that
developers are more productive in the
work the next people who know me would
probably expect me to speak at a Java
one about my work on Eclipse and
specifically I'm a committer on the
Eclipse JDT where contributed null
analysis based on annotations and other
stuff which is not the topic of today
because I am very happy to speak today
about the project that's most dear to my
heart which is also an eclipse project
but originated from a university project
actually about 10 years ago which is the
project called object teams and I would
speak II be speaking about modularity
hopefully in a way that's quite
different from what you heard on
modularity doing previous talks in this
conference so i hope to set some ideas
that will make you think differently
about modularity i will not speak about
modular here as a goal in itself so my
focus is modularity for the purpose of
building reusable software and for
reusing I far actually really reusing
those modules with different variants
and all that and how we do this with
object teams and the very brief
introduction to object teams is that we
have a language called otj uh yeah this
diagram pretty much says it all our DJ
is
specialization of Java which means most
of the syntax is just javis in text so I
want to show a whole lot of source code
because most of the source coding object
teams as egg actually looks exactly like
Java so I will focus on the concept
behind that and try to explain how we
approach modularity and to start the
story of modularity let me start right
at the beginning with a little history
of spaghetti because that's what we're
trying to solve here isn't it and in the
beginning the word consisted of
different instructions or statements
some of them are listed to you and then
people found that one of these
instructions is dangerous and so with go
to consider travel they found that the
real danger is here jumps are dangerous
because if you use them in an
undisciplined way that every statement
in your program can potentially branch
to any other location inside the same
program so you have any to any
relationship between locations in your
program and this is kind of the
definition of spaghetti everything is
tangled with everything else as we all
know this is not modular so this is the
start of spaghetti and software and
luckily people foul the solution maybe
is something like in the 1960s where
they found that those instructions
should be grouped and two as we all know
subroutines of procedures now we call a
method so program the soft spaghetti is
sought we can go home have a beer and
all is fine except they forgot one
essential thing they solve the problem
for control flow that did not solve the
problem for data because if you only
have procedures as your only kind of
module in chrome how do you share data
between the different procedures and
didn't
first primary approach might be to pass
data as parameters to those procedures
please but you cannot pass all the data
through parameters into other procedures
so the most convenient thing is to just
have global variables and share state by
a global variables and what happens now
each procedure can relate to every
global variable in the system that means
what do you have we have data spaghetti
great so we are upgraded from
instruction spaghetti to data spaghetti
and as we all know spaghetti is not
modular that's not what we want so
luckily ear came object orientation now
we are able to combine procedures and
variables into classes and with that
here the problem is solved the data is
included in the modules and not no
longer everybody relates to everybody
else and this is fine unless your system
grows and grows and as you have
thousands of classes and with a
potential that every class relates to
every other class what do we have class
spaghetti great so if you like spaghetti
enjoy your meal yeah i'm at a software i
don't i want to get rid of this and if
we observe the timeline we want to
create everything as a module and we
start with statements which are tiny and
then we group let's say about 20
statements / procedures a pretty good
metrics and then we group 20 of those
procedures into a class etc what happens
actually in java lon we are adding
packages the next level so we may be
able to cope with eight thousand lines
of code great but packages are too fine
grained so what do we add Austria a adds
bundles or what you name it and on and
on the number of names for modules
greater than classes wouldn't even fit
on the slider I'm afraid so if you're a
researcher this is very good news
because you will remain
you're in business you will remain busy
inventing new kinds of modules as we go
and as software grows and as the
software gets more complex and larger
and pervasive from an economical point
of view this is completely insane if we
have to invent new kinds of modules over
and over and over again and since I'm a
great believer in our terms of
programming I think classes and objects
are wonderful a means of structuring
your software wouldn't it be great if we
have a system that consists of a few
classes and if it gets larger would it
be great if we could just use this wrap
a box around it call this a class again
and we have another class with nested
classes have another class with nested
classes and all we do at this level
connecting these three classes and if
the system goes grows larger zoom out
this is all system create a box around
this is a class and here's another class
here's another class and we only have to
connect them at any level of scale we
only deal with classes we're done
modularity is solvable at any scale with
only using one kind of concept classes
could be enough and so it's pretty cool
actually except here's one consequence
of using this approach with Java and
classes and inner classes why is this
not feasible it simply doesn't work this
way because it would imply that your
entire application would have to be
coded in one file now that's a very big
great reason not to use this kind of
technology is it so now we learn why
Java actually has the next level of
module modules which is called packages
because packages are good in structuring
files and folders
and they even have arrived Oracle
ordering a structuring of folders
although the packages themselves are not
in a hierarchy by contrast classes are
conceptually very powerful a means of
structuring your software that have this
boundary between here is a signature
here to implementation and classes even
support nesting and I should repeat
packages although it looks like do not
support nesting right so if I want to
create a module in Java I have to choose
do you want to create a class or do I
want to create a package the warm up
into object teams is to show just a very
very small addition to the Java language
where we say this option to choose
either package or a classes bad choice I
don't want to be asked this question I
want to have a class that can be
structured into files in sub directories
corresponding to the nesting of the
class so as the name of objectives kind
of implies we have a new kind of class
with a modifier called team and this
kind of classes has properties of both
modules egg packed classes and packages
and if you look at a class structure in
the Eclipse package Explorer you have
two options either you're interested in
the logic instruction then you'll see
that there is for example it team clause
the yellow thing which has directly
nested classes for example citizen there
could be a mayor that could be town hall
there could be a look at different kinds
of member glasses off of the team direct
members this is a logical view it
doesn't show any files actually it shows
the top level file but if instead you
are interested in the file structure and
how do i store these in a version
control system for example all these
things then I only have to toggle the
banner
on top of this view and then I see the
physical view and the same project
actually looks like this where we have
the same classes a city and a citizen
and the meaning is the same but we have
two additional nodes we see that the
team community dot city actually
corresponds answer to a package
community dot city and inside that you
have a file for the nest applause very
very simple a trick and you just choose
I'm interested in the logical structure
or in the physical structure and then by
a toggle of the button you see this all
that and so that's actually the first
item for you to take home from this
session that with team classes you are
no longer forced to choose either
package or a class you can use something
that's both and by unifying classes and
packages we finally made nesting really
feasible it works and you can even do an
incremental compilation of inner classes
and so there's no longer excuse or for
not using a nesting as it needs to scale
your modules and just use the core
object oriented concept classes and
objects so life would be nice if this
would be all we need for for modular
software and this is a very very much
simplified view of the word of course if
we could have these Lego bricks and just
group a few of them into a larger module
and then have some of these
prefabricated modules and then just hook
them on top of each other if suffer
composition would work just like that
and the top level blocked would then
automatically be on system would be
great what life is different life is
more complex and there's different ways
of looking at the complexity that
forbids creating software using only
this hierarchical a breakdown
and one aspect of this complexity that
I'm especially interested it is reuse
because now we're not only speaking
about breaking down one single
application into this neat hierarchy
which is very difficult to find but now
we're speaking about one mortal being
part of many of these hierarchies and so
there's conflicting is an interest how
the modules should be structured in each
different application of in each reuse
scenario there's different demands on
the same module so that is the challenge
I'm I want to address within the next
step of this presentation and I would
say the core problem the core difficulty
in reuse is that there is a requirement
from a customer here is a module that
looks pretty much like what I need but
this is two percent mismatch or five
percent in this match and so I'm
typically forced to either say well the
customer doesn't get exactly what he
wants or I'm forced to just not reuse
that thing are anything of that kind and
the true art of reuse is to transform
this near miss that's almost what I need
but not exactly to transform this into a
perfect match because I want to deliver
exactly what the customer it requires
not something only similar and this
could be called a problem or difficulty
in reuse I would actually say this is
the essence of doing reused to be able
to transform a near-miss into a perfect
match so what do we need we need to it
that allows us or is an existing module
we want to use it in our application
with a few adaptations and I'm not
speaking just about those adaptations
that the module provider already
anticipated that's easy so if your
module provider it just adds bunch of
parameters so the modular we just
configure the module and then it does
what would you write let's
that's easy and wouldn't be worth the
presentation at javaone what the problem
that our want to tackle here is the
problem of unanticipated adaptation that
is I'm going to do something with this
module that the provider of that what
you did not think of and this is the
power that creates a new value i believe
and an object-oriented programming which
i'm a fan of this is actually more or
less the tool we need to solve this
problem because with inheritance we have
both these properties we acquire
everything that had has already been
coded so we inherit all the methods from
the super class and for those methods
that don't fit our needs we are allowed
to override them we allowed to adapt
those bits and pieces that don't fit
unless people were very very keen on
final and private and Static on these
things let's leave this discussion are
out here basically inheritance is a very
good tool for doing this and the
observation if we met this on to what I
said minute ago is that for methods this
works pretty good but if we are starting
with a system that's constructed from
classes with inner classes with inner
inner classes there is no way i can
change the implementation of these inner
classes inheritance of classes of inner
classes is broken and java it doesn't
work the way i wanted to be so if
inheritance is defined by a choir
everything and in depth the things you
need it doesn't work for in your
analysis oh that's pretty sad and let me
show you what i would like to be able to
do with classes with inner classes so i
want to be able to create a module that
implements the common parts of all board
games on the world so
there's players as token says move this
route these are common parts of more or
less all board games that we have and if
I want to implement a specific board
game I want to be able to just create a
new module just by inheritance from this
one existing big module and this
includes that I want to be able to
refine also the inner elements so the
play of the token the move of the routes
now should be chess player chest token
etc and with the object teams we have
the capability that with team
inheritance team classes inheriting from
another team class and this overriding
of inherited inner classes as possible
this is a concept that is a very
established and well-known concept
actually in computer science it's called
virtual classes like virtual functions
are functions that are over a table now
virtual classes are classes that are
over I dab'll so don't worry this is not
something fancy i just made upper and a
crazy night that this has established
theory behind it and what i can do with
this it allows me to consistently refine
all the elements are the inner classes
that inherit from the super and with
consistently i mean it is not possible
the type system prohibits it's not
possible to mix for example a chess
player with a tic-tac-toe token are
playing by the rules of a checkers move
this is simply not possible and desk
quite some type theory behind this and
which takes care of this the good news
is even if this is quite sophisticated
stuff in the normal case you don't even
have to see the difference between a
regular Java type rule and what's going
on here so it establishes consistency
which is pretty great and for another
property of the steam inheritance let me
expand the example just to tell a little
bit assume we already have the chess
game fully implemented and now we want
to make
a little derivations this is something
like a near miss and transform it into
perfect match I want to have a blitz
chess which means it's exactly the same
rules as chess just you have to complete
each move within 10 seconds and so all I
need is to override let's say the method
rubella date and this method takes care
if more than 10 seconds have passed the
the move is no longer valid and you lost
so it's a very very tiny adaptation and
with virtual classes what I need to do
is I can do deep overriding that is i
inherit a class rule i override this
rule and inside that overridden class i
can overwrite its method validate so i
can selectively drill into the inherited
implementation at any level of nesting
and can override specifically that
method that i need to override which
means forget anything everything you
learned about frameworks if there is a
module that implements some
functionality in order to adapt this to
your application all you need is this
kind of nested inheritance with
overriding and deep deep overriding in
fact and it's not only very very
flexible it's also a modular again
because they're overriding the
inheritance actually happens at the
level of the outer and it is again not
possible to mix specializations that
don't fit together and in fact it's only
one statement the in sensation of the
outer that decides about all the
behaviors of the inners so as soon as i
say i want to create a new blitz chess
this decides that all the routes will be
talking about from here on in this
context will be blitz chess rules which
means all the implementations of
validate will always be
the implementations from this specific
overridden class so this is for the
consistency just one in sensation
decides all the other individual DC
selections so this is item number two
for you to take home and that's are
already very very powerful means to
combine modularity with reuse and truly
unanticipated reuse would be worth a JSR
but I'm afraid this is too big a change
for Java to ever do in the next 10 years
and what this is just step number two on
what we're doing in the object teams
Chris sure so I have to ask you to hold
on to this question because the this
part of the story of object teams plays
by the rules of Java visibility but
that's that's of the final answer that
will be watered so we've been speaking
about taking classes very very seriously
taking inheritance very very seriously
and using those for modular thien for
reuse so another way of describing what
we did so far is that we describe the
commonalities of what we want to reuse
by super classes which may be abstract
lot and describe the variations by
subclasses and with object teams we
added the capability to do this with
even larger things so we can have
abstract in classes as the common parts
and such teams as the variations that we
create this great so far but it's only a
part of the story of reuse because so
far we are only speaking about how do we
decompose
a system in two variations and reusable
parts we haven't spoken about reuse that
much and in order to get the full
picture we also have to think about how
do we compose those variations into a
running system that may be even harder
than the first two steps we saw so okay
here it says creating a system leave
office didn't like this lines that so it
keeps deleting that so in order to
compose a system we have to ask our
question ourselves question like this
how do i select among the different
variants that are created in on the top
part of the slide how do i select them
and when exactly do i select them which
is a actually two questions when in the
development process can i select a
varian oh maybe i want to select sus and
do some of these selections even later
at runtime will I be able to do that and
to make the challenge even more fun I
don't like to speak about just one step
reuse because as you may remember for
the first part of this talk I don't like
solutions that only get you one step
further hey I like to have a solution
where everything you create is reusable
and somebody else can create something
new from it and what he will create is
again reusable and so we have arbitrary
changes of reuse this is what I consider
fun and so let's see how we can do about
this now we're getting at the very core
of object-oriented programming actually
so for the flexibility we need for reuse
we're using polymorphism right so each
variable that you have as a type and
that type is only the only escribes a
range of possible time or possible
behaviors and the actual selection is
postponed and thus the module is
reusable
if we would peek down into what happens
at runtime some point we will have a
instance with a specific type and that
type decides exactly what they behave of
this application will have at this point
and this instance is locked to this
specific behavior so what happens
between here and there on the top we
have the flexibility and this is
reusable on the bottom we have something
that is locked to one particular
behavior and it's no longer adaptable
what happens between here and there
that's a very innocent little tiny
keyword in Java that makes this
transition the word new whenever you use
this keyword you're making a selection
and so in sensation as a great
responsibility in this game because with
the in sensation we actually select the
behavior if we use inheritance as our
mechanism for creating variants so we
create we select the class by that
weekly select the very end of among the
different behaviors and the bad news is
that the new statement hard codes this
decision into your programs and this
selection is final so you have to choose
either you create your application as
reusable and then you're not allowed to
use new or you have to use it at some
point and at that point your application
is no longer fully reusable and the
sense you may have some mechanism to
allow some reuse but it's not completely
reusable for any unanticipated
adaptation for all unanticipated
adaptations so new is a very powerful
instruction and it has very great
responsibility in this game but the
reuse by this mechanism is limited to
one step as soon as you say new this
decision has been made and it's fixed
the selection cannot be revised and so
in this kind of conflict that can only
be one winner the one who
right what type to instantiate and now
people start saying oh baby we should
just say new is considered harmful don't
use it and then they have patterns and
say well you shouldn't use new you
should use factories in the beginning
anyway or maybe you should just use
dependency injector up entailing a long
discussion we could have here but I I'd
like to make a shortcut here and say all
these approaches they may take you a few
yards but they are not the full solution
the full solution has to acknowledge
that the core problem we're facing and
why we have this contention with the new
instruction the core problem is an
inherent limitation of inheritance now
this kind of bad news because I started
saying classes are great inheritance is
great object under program is great this
should be all we need a now saying
inheritance is limited well then people
say I told you you shouldn't use
inheritance just use composition and
well yeah maybe we should just use
modular too it's a wonderful language
for that style of programming very well
in doing modular programming with
methods and data in one place and that's
it yeah I seriously this is a very good
language but I still wanted to a step
forward and say I want to use be able to
use inheritance and if in some
situations inheritance is too rigid I
could do one of two things I could
change inheritance or I could create a
brother something that's similar to
inheritance which does not have these
limitations but has slightly different
properties and that in order to it come
up with an idea what this brother of
inheritance would look like let's go
back to the 101 on object mentor program
what is inheritance what do textbooks
say about inheritance
well they say inheritance is if you can
say man is a person is a equals to
inheritance a woman is a person so use
inheritance and textbooks also say and
employee is a person so use inheritance
I mean at least that the textbook for
from last century used to say this I've
seen it seriously and several of these
text book but wait do I have to choose
am I a man or an employee how do i
express male or female employees doesn't
work even worse who a few has been born
as an employee if I want to have an
employee instances it has to be an
employee instance and there's no way I
can derive an employee instance from a
person instance so if you're not born an
employee you will never be an employee
or even worse if you lose your job this
object has to be deleted but that's the
person right so if you lose your job the
person dies I hope I have a life after
employment and even more fancy consider
you have two jobs but you're still only
one person right so how many salaries do
you have at most well no good reason to
have got two jobs then so what's missing
inheritance is missing first of all the
two verbs become and quit well smalltalk
had become but nobody remembers so what
we need is some dynamism that allows us
said that an object can change its type
during its lifetime the one direction is
very easy to the other direction is easy
in certain contexts to drop a certain
slice of an object and something that
simply not possible but with the
standard object on the technology is to
have multiple instances of the same
field on the same object just doesn't
work yeah so can we do better as I said
we could go back to modular to
programming or we can try to think of
something that has as many of the
problem properties of inheritance as we
like and just change these things we're
in her tins is too rigid and the answers
I didn't even have to invent that that's
been around for quite a while we only
have to rephrase what has been said as
employee is a person that's at a precise
statement the statement we should be
saying is employee is a role played by a
person in a certain context at a certain
point in time etc etc so just by
shifting that the phrase the
prototypical phrase we use to represent
the model and natural language shifts
the focus and this is how we do this an
object teams well here's a keyword
language programming language we
introduce a new keyword called played by
and this keyword sits in the same
position were also extends would sit so
it's a similar to inheritance yeah awed
by this plate by relationship we can
connect now to separate classes employ a
person just as we did before with
inheritance nothing fancy so in order to
see the difference we actually have to
move from the class view to the instance
view yes Jared Joe is a man sub type of
person okay so inheritance may for
normal cases be sufficient here Jose is
a man and he has a name Joe when he
grows up he enrolled as a student so now
he is a man and a student I some
additional properties so for example he
also has a matriculation number
for his enrollment in University so what
we have we have a typing that is dynamic
we can not a confused with type less
programming but the type of this object
gets richer by adding roads to it we can
even add another road to the same object
so now Joe is both a student and an
employee so he has three fields and I'm
matriculation number and a salary and
which tells us as the same base object
can even have multiple roles attached
simultaneously odds when he leaves
university is no longer soon Joe still
lives and he may accept a second job now
he is Joe is one person and he is two
employees no problem with that he has
two salaries great we finally managed to
model this and which tells us the
multiplicities exists in two dimensions
we can add different behaviors and we
can even add the same role multiple
times if we have the context information
to select and these concepts have been
round in the research on object under
program language about 20 years and so I
actively participated in this discussion
in the academic context for about 10
years so my claim is not I invented role
but my claim is that are pretty much
heard everything that researchers said
about how should we represent roles and
object under programming and so my
contribution basically is to get the
best of the breed from all these
approaches and integrate all this into
one consistent programming language and
that language is object teams so just a
few more details about this role-playing
relationship it's a relationship we
start out by is by connecting two
classes but then we want to be able to
like
we want to be able to call a method get
named even on the employee part of the
object although the employee doesn't
have that method that method is defined
here and we do not want to duplicate
that method so we could say all these
methods are also visible at the role but
i decided to more decouple both of these
parts so we have to add just a tiny
little declaration which is this get
name right arrow get name which declares
that our method method calls get name
should automatically be forwarded from
the left to the right that's kind of
importing that behavior into the role
the inverse directions even more
interesting now I have a method called
get phone ask at the person object if
this person currently sits in his or her
office pretty smart if he actually
answers the office phone number because
otherwise the phone at home will ring on
here nobody answers so if we're in the
context will want to be able to let the
RO intercept this method call and
redirect it to the behavior in the role
and if you compare nope sorry I'm
getting ahead of myself the essence here
is that conceptually we want to see the
role at the base as one object and these
little wirings we are doing forwarding
this way interception that way are just
wiring within the object between the
different slices so to speak of an
object this is conceptually is one
object just decomposed in its individual
slices and if we compare what we see on
this slide with inheritance then the
call-out binding the left to right
binding is what established the
acquisition of features that are
inherited from the base what they call
in binding is very very similar to
overriding the mechanism we use with a
standard inheritance for adapting the
behavior we found in
but close so very close few differences
but I won't go then the mapping why
would you not do no magnet all as if the
urge all the members that are okay the
thanks for the question sir so the
question is why do we do the explicit
mapping or not do emerge the reason is
the merge would create implicit
dependencies on what methods are in the
base and I want to make it all this
explicit and as a good pattern for us
for still decoupling it even more would
be to add an inheritance hierarchy of a
super role which only has the
implementation and a sorrow which only
has the bindings so we can separate the
behavior from the binding and use it
just with inheritance that we can apply
to roads so wrapping up this part which
is the central contribution of object
teams whenever you find that inheritance
is just to reach it and it doesn't
deliver the flexibility you need for
reuse you have two options either throw
tens hundreds of design patterns at the
problem which blows your application or
with which we means they're just
workarounds in my understanding many of
these design patterns indications the
language is not strong
enough or you could use the the instance
based composition are supported by the
language in object teams where one
instance can accumulate multiple
behaviors and the instance can change
its behavior over time at runtime even
so this would be the item number three
for you to take home and this is how we
do it and maybe this should be the point
where should mention although I'm
explaining all this in terms of employee
and person all this is very very much
applicable to technical classes as well
as well to casa from your business
domains and of just one example if you
you could say I have an item in my
merchandise management system and I have
an order why not let the item play the
role of an order position so it gets
additional behavior in that context etc
etc or we could say if if you need to
observe her behavior but given class
doesn't implement observable why not
just add an observable role to this
class and add this behavior to this
class and maybe even dynamically at
runtime so don't think this is only for
for employees and students and persons
it can solve real hard technical
problems it can solve real problems from
any business domains as well so I have
created a new kind of relationship
between instances which could easily
create the new low of spaghetti if you
like spaghetti enjoy a meal I'm in a
software business so I should better
avoid spaghetti and this question
actually has two sides we have to
consider that the base objects aren't
the role objects better be embedded in
some modules that are larger than
classes one side and now I'm getting
closer to the initial question
consider rolls on the left side base
classes on the right side and some
bindings consider those space things
reside in a module and that module has
an encapsulation boundary and that's a
pretty hard wall yeah that means you
cannot detect general Salm right i means
you cannot do any forwarding to these
methods which may be a package visible
or you cannot even mention those names
that you will want to intercept yeah
that's what reality normal normally
wouldn't tell you so it only works for
public things except there's a little
conflict didn't I just say this base
thing and the role slides are actually
one object didn't I just say this is one
conceptual thing and this would imply
that I have an encapsulation boundary
cutting right through an instance it
doesn't make any sense I mean that would
be true split identity of the simpsons
and one side not being able to see the
other side so what we have an object
teams is controversial but we give it a
name so we can actually discuss what
we're doing we have d capsulation as the
inverse of encapsulation on what we do
is we allow you to explicitly specify
the few locations in your program were
you knowingly a disregard the
encapsulation boundary and so no yes
little holds these arrows are actually
allowed to cross the encapsulation
boundary and it's like legalizing what
has been prohibited before and the
advantage of this is that now those
trespassers will be visible and
controllable if you don't do this people
will find their ways and you're not
going to detect if you make it visible
it's controllable and you can approve
in our case by case if you want to allow
this or not and my experience is that by
allowing d capsulation a few locations
the total coupling of your system will
significantly decrease which is kind of
a paradox maybe but it's my observation
and I invite you to play around and make
the same observation so item number four
for you to take home in our shop
encourages with D capsulation we have
this ability to actually bind role to
anything and the base application that
can be private and it can be final or we
give warnings and this one it can be
tuned to a arrows of the policy of
projects it's not a lot but it you have
the technical ability and now it's on
the person's to negotiate what's allowed
and what's that a lot the other side of
the road spaghetti concerns the roles
and you were actually have some some
more innovation waiting for you because
the roles are now embedded into a team
instance which has several advantages
the primary idea behind rolls is
actually that they are implemented as
interaction between each other so the
functionality of this module my team is
implemented entirely only in terms of
those roles and if roll one would be
tempted to invoke behavior of c2 now
Chun it should always to talk to the
road to as a representative and so the
only connections between the role level
and the base level is through these
declared bindings and no direct method
calls across this boundary so this
significantly increases the reusability
of the team implementation actually and
the comprehensibility maybe even more
this is no mobile number tier the team
has one very simple I capability it has
a switch which you control on or
off you have an idea what the switch
does it has two consequences one direct
one indirect the direct consequence if
you turn it off watch this the effect is
that the caller in binding will fade
away if the team is deactivated none of
this interception magic happens anymore
so any changes the team imposes on to
the system are disabled and the cool
thing is this is not per call in its not
parole it's per team so it's modular
it's on a large scale that I can disable
our entire feature can put the entire
application into a different mode create
a new instant T Munson's turn it on I
mean still a different mode turn the
team off again I'm back into my previous
mode and so that's highly modular and
that's actually the last item we're
going to put into the shopping cart here
the combination of role-playing and
teams with a powerful concept of nursing
and the powerful concept of inheritance
creates teams as the ideal module to be
reusable and to apply adaptations also
to other modules in the system so that's
what we have team classes are unify the
concepts of classes and packages so
there nestable make nesting finally
feasible team inheritance makes all the
framework technology you know of more or
less obsolete because all adapting a
framework can just be done by
inheritance with deep overriding with
role-playing we added a second
relationship that's similar to
inheritance but more dynamic more
flexible and with D capsulation we
entire the trolls to specifically
disregard some rules if you wish to and
with teams as modules for roads we
those adaptations themselves nicely
understandable comprehensible module
again so being at the developer
conference I kind of feel obliged before
we leave the zoom to show you at least a
tiny little bit of source code so if you
download our tool you can play around
with this and just by saying file new
example you will get offered a selection
of prepackaged example 10 so the flight
bonus example is the one thing I already
installed here and what is it about it
about three things first I have a
library booking jar which is a toy
version of a flight booking system so it
has classes like wait a minute in the
model package to tears classes like a
flight a passenger and the flight
segment and we fake we could do some
flight working with these the second
part we have is something that would not
be possible to implement without object
teams I entirely implemented but unbound
module for any bonus program so beard a
frequent flyer or be it a payback of
your favorite video rental anything
where you can earn bonus credits while
you buy some item the abstraction of all
these is implemented here and almost all
you see here is just plain Java code the
main difference is this keyword here Wow
we have a modifier this is a team and
then we have a subscriber which has a
field where bonus points are collected a
credits are collected and we have item
roll this is the thing you are buying
and so this is responsible for
calculating the credit left this
abstract here and then I have a method
so when this thing will be bought by the
subscriber we
the credit by first calculating this and
then pushing that value into subscriber
collect credit so it's implemented only
in terms of what we have inside the
steam but nothing magic happening here
and the hard question is can we
integrate these two modules the bonus
program and the flight booking and
neither one has any reference to the
other one still I want to create one
application from both of them so this is
real reuse measure all we do is create a
team class actually fits on one slide
even at the font size is all we need to
do so we create connections in two
directions first of all we connect to
the implementation of the bonus program
by inheritance the entire code
collaboration with the inner classes and
what have you is just extended by saying
flight bonus extent flow extent bonus
this entitles us to create a class that
overrides another class that is
inherited this is what it looks like and
inside that we are able to refine the
thing that we're already defined in the
super version of this same class so like
the super part is implicitly he included
here inside these classes what we have
we have a little implementation where
the distance of a flight is mapped a
number of bonus points and we have we
are importing some of the methods for
using these call-out bindings so we want
to have access to the get name method of
the passenger we want to get access to
the get start get destination and get
distance of the flight segment and only
two lines do the actual connection
whenever the method book of the segment
class flight segment is involved we want
to combine this with our own behavior
say after that method it has been
invoked additionally please also invoke
our own credit method similar for the
book method on the passenger class but
that's all there is
and although the flight booking was
shipped as a jar I only have to specify
to the launcher that in addition to this
jar it should instantiate the flight 10
steam and activate it and now I have
flight booking application with bond
with frequent flyer logic in it I for
reasons of time I'm not showing this toy
example because you can imagine that
when I do is some of this booking at the
console I will actually see you earned
two thousand credits I hope you believe
me otherwise download that will play
with the example so this would be the
slide version of the example and if you
like what you have in this shopping
chart to check out you don't even have
to pay you just have to go to this
website and check out eclipse.org /
object teams or if you already have a
pretty recent version of Eclipse
installed just drill down in the like
indigo or Juno repository just drill
down to the program language kit
category and find the object teams
development tooling and the object teams
equinox integration which would be
another talk extending this modularity
even to the osgi level great fun so let
me conclude by going back to where
started lgj as a seamless extension of
java to improve modularity for the sake
of reuse unanticipated reuse and the
objectives development tuning which
you've seen briefly is well i'm also a
committer on this project sure so i
should be very careful with comparing
quality of our e's because nothing can
compare no I well so this is a great
idea to base upon by using our own
technology to adapt the JDT are we are
able
with much less manpower to provide an
IDE that has a very similar experience
than the JDT has but still knows about
all the concepts of object teams and
provides refactorings provides quick
assists and all this what goes beyond
the typical Ides of the basic idea
support so yeah we are extending driver
we are adapting eclipse so I think this
itself proves that we are able to do
quite a bit of interesting reuse in
unanticipated situations as a result is
extremely modular so thanks for
listening I'm ready for your questions
all right I'd never heard about before
and just knowing you know this is an
academic words like that it looks very
interesting but re ok so the question is
just briefly repeated about the user
base is this just an academic project
all this for real it started out as an
academic project we had a three-year
significant funding which made the main
contribution to the implementation and
also make sure to make sure this is
conceptually sound but by moving this to
eclipse as a sustained project the
messages are this is intended for a real
world application so from what I know so
far still the object teams development
tuning itself is the largest application
of itself I know there's a few users but
I mean the opportunity here is to grow
the user base it will stay I promise and
if you or your company is interested in
that you can contribute to ensuring that
it will stay but it is mature it works
in real work and I'm in the midst of
introducing it into my own company I'm
not owning it but the company where I
work it but aside from that I cannot
show you examples of industrial usage
but I see no reason why this should not
be possible so many people like to be
second so maybe you want to be first
please
so the question was about adding syntax
adding keywords to files that have the
Java extension can this be compiled on a
build server and in fact this can be
done pretty easily simply because our
compiler is an extended version of the
Eclipse Java compiler and the Eclipse
Java compiler can be used and and built
can be used in wearing belts and if you
do that it can be used otherwise the
regular Java compiler will simply fail
to compile this certainly so this
picture is only a part of the reality
the compiler itself is just to you to
meditation because we first had to
implement the compiler and then we
already had the implementation so this
adaptation technology using object teams
applies to anything in the UI the
compiler itself is a fork of the Eclipse
Java development core yes
tolling support
so the question was about to tooling
supporter when we program with can we do
it debugging easily and yes so this
picture only says we adept at JDT I
should be more precise we adapted jtt UI
which contains also refactoring and all
that we adapted JDT debark we even it at
that pde the plugin development
environment and fun and it's you I so
yes are we there was a student who we
invested quite some ideas into improving
the Dabangg experience we have an
additional view where we can see the
active teams and we made some
beautification of beautifying off the
stack tracer that you seen some coloring
and using jsr all 55 to ensure that the
debugger knows the correct sauce
position even if it's not plain java
code there and lots of these things so
if anything and their experience with
JDT doesn't directly work in the same
way with the object teams development
tooling it's a bark and you should file
a bargain and the Eclipse bugzilla the
intention is that all this is support
there may be little little holes that is
the intention and we would quite far far
to actually achieving this goal
debugging is definitely supported and
many of the other activities in the IDE
are supported thanks for the question
so the question is if we're not getting
into trouble with a key some of the the
arrow dash greater and my first attempt
to really were good quite scary but I
pretty soon recognized that this is very
local on very contextually and so I only
need to add a little bit of look ahead
into the parsis so that in this one
particular situation where we have an
arrow actually didn't even show any
location where it would be ambiguous
there is something like a parameter
mapping or we can add details to a
method mapping or can bind this
parameter to that parameter and that we
have expressions and these arrows mix
but it is possible to disambiguate of
this it's it's work it's pretty
challenging work but I have a branch
already where the preliminary version of
the Java 8 implementation which I'm
involved to anyway so is already much
with the Java with the object in Java
implementation so it will work it will
actually create some very interesting
scenario in the future one more question
here here is really kind of normal
anyway exist about each other it well
and are you thinking about so the
question was about teams and roles being
kind of orthogonal and whether one or
the other or eventually both should be
taking it into the JCP and proposing
this to be here become part of the Java
language I made a little hint at right
when i explained team inheritance with
virtual classes this is probably the
part that is most thoroughly researched
in and they're all community and the
academic community and it is suddenly
mature enough to push it into Java
certainly but everybody I spoke to about
this I says it is just too huge a change
for any committee to ever agree on this
in a reasonable amount of time and and
so it I think it would make it perfect
match in Java because it's so clear and
fits so nicely into any object on the
programming language it deserves that
space it's placed there similar for
roads but but I would gain if I would do
it I would do it in this in this order
first go about virtual classes and then
about role playing and then combined
both of them I simply don't have the
manpower to do this if if there is
interest I mean each of these steps
would be great wonderful gainful for the
java programming language and i would
certainly support but there would have
to be some major player putting this
some experience this
so the question is about if given that
the object team is good for creating new
systems do we have experience and
guidelines are for converting an
existing application into a off track
teams application so the main experience
we have is with adding object teams
parts to an existing java application
and that's where that's really the
killer application right now and we can
do wonderful things we have we also have
in this research project where the case
study creating an entire application
from sketchy using object teams by just
claiming the guideline whenever you
think of creating a package creative
team which goes a long way but we have
no significant experience with actually
converting in an existing application
into an object teams application might
be worth well maybe this is something
you wouldn't do want to do in one step
my feeling just from the top of my head
would be you would probably do it in
small steps as you needed as you need
more flexibility in your program as you
need more encapsulation boundaries even
so objectives despite having d
capsulation also has much stronger
protection also of your objects whenever
you feel you want to apply some of this
to one of your modules do it one more
deal at the time and I think you should
be pretty fine the cool thing is that by
staying pretty close to the core of
object under programming there is
nothing fundamentally different if you
have a module converting it into a team
might be a no-brainer actually I for the
places where it's not the type system
will tell you exactly where you need to
be a little bit more explicit of what's
happening it works best if
you have a model where the rolls what
the classes that should become roads are
never referenced from the outside so it
teams work best if the team is actually
a facade for everything that's inside
because then you can define a team just
in terms of only of classes that
everybody can see it gives you the means
to four very strong encapsulation
there's other you can expose roles as
well but then you have to make sure to
get the typing right which well I
mentioned there some theory guide that
but as for refactorings or for
guidelines how to do it I wouldn't even
think that would take very much to write
those guidelines because of the close
similarity to fundamental object hundred
concepts
we
special
I'm so questioners will when comparing
two aspect on to programming whether
have they are typical examples of
logging and security whichever what you
mentioned it is there some comparable
interaction so if there's a specific
kind of module where we would typically
always say this is where object in
should be applied I mean my personal
experience is focused on developing
towards and whenever one of these tools
doesn't exactly do what you want this is
a very strong indication to use
objective but no at the general advises
whenever you have to do this transform a
numerous into a perfect match it's
always a strong smell that this can be
very easily solved but using object
teams and this is what one of the smells
and the other smell is if you have two
modules neither one knows anything about
the other one you want to combine them
how do you do that here's a team that
has rolls into both of them and combines
and mediates between the two behaviors
that's an even stronger indication that
objectives would be what I consider the
perfect solution actually and so I just
recently a little mesh up using an X
text editor who knows X text
domain-specific language and combine it
with the wiki text editor and so they
share one outline it's impossible to do
unless you use objectives and it's a
nice module the combination one more
question
did you say combination yeah so the
question is so the question is do we
have experience and combining aspect
under program with like aspectj with the
objectives approach we had a few users
who actually tried exactly this I'm
currently still discussing with with the
aspectj guys at the IDE level there is
some interaction actually between the
two IDEs it may work but they're each
each team has its project has a few
assumptions that are pretty difficult to
reconcile with the respective other t so
object teams has some similar to
aspect-oriented programming in the first
place except that it doesn't have the
one thing that causes the maintenance
pain if you use too sophisticated
pointcuts we don't have this
deliberately so if you actually need
that are we should probably work
together and it should work but but it
hasn't been we don't have much
experience with that otherwise if you
don't need this really wide scattering I
actually recommend try using object
teams also for those cross-cutting
concerns you may have to enumerate a few
of those joint points instead of just
using a wild card but this may actually
be an advantage so we have the same
capability except for these wild card
things and endpoint cuts so either way
if it's feasible to do the same
cross-cutting concerns also an object
teams this would be the easy solution if
we if you want to combine both it should
work and I have experiments successful
experience with having both technologies
in the same
at the same time just a lot a whole
bunch of real projects where I can say
yes it's rock solid we're not there yet
but this is devon driven so far the
demand wasn't to a very big enough if
people are interested it can certainly
be reconciled and I know the people from
their spectra even pretty good odds so
if there's something they can help make
it a work together we just talked a
target over over a beer so thank you
very much for for you sustain interest</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>