<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modernizing the Explosion of Advanced Microcontrollers with Embedded Java | Coder Coacher - Coaching Coders</title><meta content="Modernizing the Explosion of Advanced Microcontrollers with Embedded Java - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modernizing the Explosion of Advanced Microcontrollers with Embedded Java</b></h2><h5 class="post__date">2013-01-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/smgj8jUXrx4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay thank you welcome for coming why
did this skip there we go so I'm here to
talk about how we can harness this
explosion of advanced micro controllers
that were coming that that's coming at
us this wave of new intelligent systems
and what we do need to do from a
software perspective to enable that I
don't know how many people were at the
keynote this morning raise your hands
okay so you know I don't I don't know
how you feel but I've been in the
embedded software area for quite some
time I started off as a software
engineer and I always thought we could
do much better with the embedded systems
you know make them easier to program
make them more versatile more connected
more intelligent and I was really
excited to see oracle moving in this
direction Judson's keynote I think this
morning was very compelling laid out a
very compelling vision for addressing
this huge opportunity together so I'm
very excited to to be here to be part of
this my name is terrance bar i am a
senior technologist at oracle and i'm
also the product manager of the product
i will be discussing today the Oracle
Java ME embedded software initially I'd
like to go into just a little bit of an
overview of what the opportunity is
that's lying in front of us and and some
of the challenges that are are present
when developing you know these these
rich intelligent connected clients and
then of course what what role Java can
play in that go into a little bit of a
deep dive of the Oracle job embedded
client product I know this is a business
audience all I'll keep it high level but
I think at any time if you have
questions just interrupt me and we can
go into more detail and then I will talk
about three use cases where java using
Java for these client devices creates
you know tangible business value for the
customer and for the the partner was
delivering the solution
and a brief wrapper okay so we heard a
lot about m2m this morning in the
keynote m2m of course being
machine-to-machine so it's any sort of
connectivity between two intelligent
devices they exchange data create data
you know move data around base decisions
on that data and come in and
traditionally I mean these m2m systems
have been around for a long time right
and traditionally they were sort of
single point dedicated solutions right
the whole stack was vertically
integrated you started off by creating
an embedded device you're selecting the
platform selecting an operating system
selecting your tools your libraries are
selecting some protocols you know
integrating everything together writing
a dedicated back-end infrastructure to
manage that solution and basically what
ends up happening is the solution works
but it's just a lot of effort it's
expensive to bring out into the market
the time to market is pretty lengthy and
it's just an approach that's not
scalable in the long term so what we see
happening is that there's a pretty
radical shift in the mtm space where
we're going from this proprietary single
function approach to a more horizontal
platform based and more integrated
approach right essentially we're
transitioning from proprietary solutions
from proprietary networks and standards
to open standards and network protocols
and along with that we need to enable a
horizontal delivery service enablement
platform right that takes care of things
like security upgrades lifecycle
monitoring you know data management and
analytics because it turns out that if
you look at many of the m2m use cases
and market they all require sort of
similar plumbing underneath they all
require a certain amount of horizontal
functionality and of course it makes
sense to create that in a standard
in platform-based way and then reuse
that as you move from use case and
market to the next opportunity right so
so that's really what's happening this
horizontal platform enables the spread
of these vertical applications so
instead of reinventing the wheel every
time you base your solution on that
horizontal platform you build a vertical
application to deliver that business
requirement that business solution and
your time the market is much much
quicker and and also m2m is all about
data right and not just a that's
information so data that you haven't
processed and analyzed is useless you
need a process analyze and filter it and
turn it into information that is
relevant for your business need right
and so that's also where m2m comes in
because as the data flows from the edge
of the network up back into your systems
you're going to filter and analyze it
along the way to reduce the amount of
traffic and to make the information more
valuable right and so all of that is
common functionality that every m2m
design really needs now if we look at
the client um specifically
microcontroller so really small low-cost
resource-constrained devices these are
the ones that will you know be shipped
in the billions and billions as we heard
today from arm and free scale those are
the sort of disposable computers of the
future but creating software for these
today is just a very cumbersome business
right so you have to integrate all these
different parts and components makes it
very complex you need to choose your
platform your CPU your operating system
your programming language is your
libraries um you know these are just
some examples and you know that's this
just doesn't scale very well so we need
to move on beyond this model to really
be able to harness this wave of
microcontrollers make it much more
efficient and streamlined to create you
know business intelligence and
algorithms on these devices
so to take a little step back when
you're building one of these embedded
systems for your target use case there
are a couple of things that you really
have to worry about these haven't
changed over the years these have been
you know true for many years on people
building these embedded systems you have
to worry about how do you connect these
devices you have to worry about security
manageability how do you track what
these devices are doing how do you
monitor them like cost is always an
issue how do you reduce the bomb cost
the cost of your solution and then on
the delivery side time to market right
as more and more vertical industries
understand the value of these types of
solutions you need to start delivering
more of these solutions quicker and more
cost-effectively right developer
productivity is a big part of that if it
takes you nine months to create some
software your market window might have
passed or your competitor might have
stepped in right and it's part of that
of course also supporting standards
right the more standards you can
leverage the quick of your time the
market is instead of reinventing what
you need every time so if we take a
broad sort of view of what the embedded
space is in terms of the actual hardware
devices right we start at the very large
set your right side these are typical
systems that are you know not cost
sensitive they have a fair amount of
compute power typically large amounts of
memory so these obviously are not you
know the types of systems I'm targeting
in my talk here we go down a little bit
the devices become a bit more cost
constrained they're often used in sort
of consumer electronics so I'd like
blu-ray players or smart TVs but you
still have the need to be able to update
them there's still some cost sensitivity
we go down further into the small range
what is labeled here is general embedded
so this is really sort of the vast range
I believe where the bulk of the number
we'll come from so these are the
microcontrollers the low-end
resource-constrained systems where
you're very constrained in terms of cost
and size and power but there is a lot of
compute ability if you look at the the
cortex m0m for type architectures these
are microcontrollers you know costing
only you know fifty cents or a dollar
for an SOC but there are pretty powerful
platforms you can actually utilize them
in many interesting ways so that's sort
of the focus area for my talk and then
on the far left on this smart card or
Java card which is sort of a special
case because it's it's more dedicated to
the security of a system so it typically
integrates with other devices to provide
a secure environment but what what you
have across all these systems or ideally
would like to have is a common set of
functionality right so you have a set of
api's and and libraries that you can use
you can create applications that work
across of these platforms and you have a
level of hardware abstraction so you
don't have to deal with the device
dependencies of every single platform
you're looking at so if we drill down a
little bit deeper into what does this
mean for small embedded devices
specifically right so as these devices
become smarter over time they need to
acquire more intelligent and more
functionality to be able to integrate
with this m2m solutions scenario that
are outlined so we need robust operation
these things have to run 24 7 for you
know years at a time they have to be
managed remotely so once you have
devices sitting out there in the field
then you need to push soft or updates to
them that has to be you know fully
manageable even out in the field and
there are difficult conditions they need
to support various types of interfaces
to connect to the world around them you
know be its sensors or networking
capabilities low footprint is something
we already spoke about economies of
scale so you need to be able to take
your solution
they said initially take your solution
and scale that two different use cases
in different markets without having to
rewrite everything you're doing and
changing your model you would like to be
able to separate hardware and software
from each other why is that important in
the embedded space typically what
happens is that you have to develop for
a dedicated hardware platform that
hardware platform in your development
cycle might not actually be available at
that point when you start software
development that or it might still be in
design the system on a chip might still
be in design so you are now pipelining
or you know making sequential the the
development process where the software
team has to wait for the hardware to be
available right which of course
increases your time to market what you
want to be able to do is have the
software and the hardware development
happen in parallel and they come
together at the end intelligence is
really important as I said one of the
big benefits is that we can start
delivering more intelligence into these
devices as Judson spoke about this
morning as well there are many types of
data filtering of data gathering of
local business intelligence that you can
push to the devices to create more
meaningful data or quicker and having
smart embedded devices allows you to
build on star on top right create value
up on the stack rather than reinventing
the wheel at the bottom so that's
essentially you know where Java comes in
that you know should be fairly obvious
but I think it's it's very important to
you abstract a little bit from the
technology itself and understand that
Java is this common platform that allows
you to sort of push away all the
complexity of the underlying client it
allows you to build a solution that's
much more scalable and portable across
your different markets and use cases so
don't reinvent the plumbing every time
you start a new project build on
something and then you're only adding
the last you know 10 20 percent because
the other eighty percent have been done
tested for you but Java is actually much
more than just a plan
from abstraction because Java offers
Java essentially enables the device as a
service platform so this is a bit of an
eye chart I maybe I have too much
information on here but but the core the
core statement here is that by using
Java you get an application platform
that allows you to continuously deliver
and update services that translate into
business value without impacting the
integrity of your system it's a very
simple process in the past if you wanted
to do that with native platforms there
was a lot of complexity involved
security issues and it was just
something that wasn't done very often
whereas with Java you can extend the
lifetime of your solution so let's say
you have a smart meter use case right
every once in a while standards change
standards get updated if you have a
device out in the field that sits there
for 10 20 years and monitors energy use
you need to be able to update the
algorithms by which it does that right
if the standards change and it's a
non-starter for somebody to have to go
out into you know 50 million homes and
update the software somehow what you
want to be able to do is push down the
logic out in the field and a secure
robust way so that's really you know it
drives our business value because you
can make your solution more long-lived
and more valuable to your customer
so to wrap up the the first sort of
high-level introduction I think this
slide there was a similar slide on this
morning where you know this is an
abstraction of how Java delivers
business value in different ways as I
said it extends the product life cycle
it gives you a competitive advantage
because you spend less time on building
the plumbing and you can focus on your
value add and your expertise um it
drives innovation because there's a
large pool of talented developers out
there there are itching to write
software for this right so you can
innovate much quicker and there's yeah
this is large developer ecosystem on on
the cost side you know as I mentioned
because you have a much more portable
system it reduces cost increases time to
market and you're building on a
well-tested reliable secure platform
that's been battle tested over many
years you know in the case of our
product we've shipped this into millions
and millions of phones over the last
couple of years and so you can rely on
all that functionality to work you spend
much less time testing that whole stack
so to get a little more product specific
you might have seen this in the keynote
on Sunday in the technical keynote if
you attended so we release two new
products in the embedded space last
Tuesday on the Left there's the
microcontroller or the small embedded
product stack called Java me embedded 32
is the current version so that's the
product i'll be talking about and the
rest of the presentation and then we
have the java embedded suite 7 which is
a pre-integrated a full java runtime
database application server which you
can use typically for sort of the middle
tier of m2m architectures so that's you
know managing devices that are connected
to it collecting data filtering and
analyzing data establishing a connection
to your enterprise intelligence on the
back end that's what Java embedded sweet
will be used for
and the to you know work ideally
together on the two different tears of
an m2m architecture so let me talk about
the product so so the official name is a
bit is a bit wordy Oracle Java ME
embedded it's so as I mentioned we took
all the expertise on all the technology
that we had for the mobile phone space
and we optimize that and customized it
for the needs of embedded platforms so
this java runtime is a complete java
runtime it's essentially ready to use it
has all the components that you need to
and it's enabled for low footprint
resource constrained arm architectures
so what we did is we're targeting and
i'll talk about the system requirements
a bit we're targeting a very broad range
of horizontal type of platforms with
this product it's optimized for embedded
in a number of ways it has very robust
24-7 operation we have a number of
extensions in the product that make it
more portable that make it remotely
manageable and monitor a bowl and
another number of other features that
are relevant for this type of use case
and we have a number of new AP is that
we introduced into the product that
specifically allow applications running
on this platform to to do to trigger
various types of embedded functionality
so interfacing with devices for example
by using the existing Java platform that
we had for the mobile space we are also
bringing over a number of standard jsr
so Java specification requests those are
the API standards in the Java world so
these are all existing jsr s that people
have been using for
number of years people are very familiar
with and it gives you a rich set of
functionality to to build upon right
well we're going to a little bit more
detail on a product chart and then
finally we support this platform with a
tool chain multiple parts of multiple
tool components because of course making
it easy for developers you know making
developers productive is always been a
big part of the Java platform so we
support this product directly with the
standard tools that Java developers are
very familiar with so in this release
release theta 2 which is our first
release you know targeted to the
embedded space these are the types of
platforms the types of hardware we
support the main target for this release
is really wireless modules and
horizontal m2m s or a general platform
we expect that partners will take this
product and then customize and
specialized it for particular use cases
in their area where they have the
expertise but the goal of this product
is to be broadly applicable and close to
deployment so it should not take a lot
of effort on the behalf of the partner
to create an optimized deployable
solution so as I mentioned we are
supporting arm architecture sips system
on a chips and that includes arm9
implementations arm11 cortex-m r and a
so it's a pretty broad spectrum pretty
much from the small microcontrollers all
the way to you know embedded type server
environments the dash the dash a cortex
a would fit that so very scalable
product from down from about 130
kilobytes of RAM on the low end if you
customize it and you're really pressed
for space you can make it that small but
it runs really well starting at about
seven hundred kilobytes of RAM and can
scale up to you know megabytes of RAM
easily so it's very versatile
the type of device is a headless device
so we're initially targeting sort of the
deeply embedded you don't have an HMI
you don't have a user interface so
everything is headless
resource-constrained as I said always on
devices including battery operated
devices the operating system we are
pretty flexible all you need is a small
embedded colonel doesn't have to be able
to do much and the platform is very
portable so if you have particular you
know check marks on requirements for an
operating system we can probably support
that easily or the product can support
that easily I get questions and people
say does you know do you need linux no
linux is way too big for this space I
mean we're talking about less than a
megabyte of memory so Linux is not
appropriate in terms of networking and
connectivity that's always very
important in the space so we support a
variety of different connectivity
options there's a full IP stack in there
as well as a range of peripheral I owe
our partners for example Centurion is
using this product they of course have
them have this product on their wireless
module so it's two and 3G connectivity
what's also very important is that you
give the system the ability to
intelligently use multiple communication
channels if available so a typical use
case in the for example in the smart
metering use cases these systems might
be sitting out in the field for long
times you know monitoring gas and water
and electricity use and typically the
connectivity out in the field might not
be very good you might have limited data
bandwidth the prices might vary
dramatically you know time of day
different carriers providers so what's
standard in the industry and in that
type of use cases actually have two sim
cards on the module okay you actually
have two sim cards on the module and
depending on
your particular needs and the logic of
your application you want the system to
be able to switch intelligently between
these two communication channels based
on some policy right so for example if
one channel goes down you switch to the
other channel you know that's more
expensive but it's a backup channel that
works and then you start reducing your
data bandwidth your data needs right
until the other channel becomes
available and you switch back so that's
an example of local intelligence where
you can provide a better solution by
having local software and local
algorithms running on the system okay in
terms of peripheral i/o we have all the
basics in place to connect to various
bits of hardware so things like sensors
and actuators you know meters buttons
you know contacts all these things you
can support directly from Java so your
java application can directly access
those we also support file systems and
gps location based services if the
hardware supports them so all that
functionality is there so let's dive a
little bit deeper into the software
stack this is actually simplify the the
full platform has more more components
than this but these are the more
important ones so we start at the lower
part at the embedded hardware and
artists we're really agnostic to that as
long as it's an ARM architecture with a
reasonable operating system the product
can support it we have a porting layer
that comes from many years of experience
of working with mobile handset
manufacturers and having the ability to
port quickly to a number of different
platforms so that's in there that would
be done either by Oracle engineering
services or done by a partner if they
have the expertise in this so if you
have some platform that you need to
support for your particular use case
that would be the place to to do the
porting and the adaption in terms of the
runtimes the next level it's the cldc
high virtual machine so that's Oracle's
implementation of the Java ME stander
a very robust virtual machine including
multitasking so you can actually run
multiple applications in parallel so
it's offers a really rich set of
functionality including also on-device
debugging so if you have your
application running on the device you
can actually very very nicely debug it
in your integrated development
environment on top of that the
application model is IM P&amp;amp;G i don't know
of many people familiar with that it's
it's kind of like mid p in the mobile
space but without the graphics so that
gives your applications the context in
which to run and a number of a pis and
features and then all the little boxes
on top are different types of api's
different types of functionality that
you can use i don't want to go into
every one of them but you can see that
it's a very rich platform even though we
we can run comfortably in less than one
megabyte of memory you actually have a
number of features available to your
application so you can actually create
very sophisticated intelligent connected
applications that can do a number of
things for example they can process XML
streams they you know they can support
certain protocols that the backend might
need they can control the the whole
system and the way applications run to
implement your own remote management
functionality so there's a lot a lot of
functionality there then finally on the
right we have the tools support as I
mentioned so we have actually i'll talk
about the tools in a bit okay
so I don't know how many people in the
audience come from a native embedded
background developing native
applications I mean all all the benefits
of Java that I described earlier apply
but I wanted to dive in a little bit
deeper just to give you a bit of a sense
on the technical level where Java
competes with you know for example C and
C++ an assembly development now of
course add a portability cross-platform
level there's no contest native code
ports very difficult involves changing
your toolset recompiling you know
retesting Java just just works right
because it's in a sandbox virtual
environment security is tricky our
native you have to do a lot of testing
and you can't always rely on the
underlying platform being robust and
secure whereas in Java that's proven
many years that there is a very robust
security model including permissions and
you know signing and things like that
that also extends of course to the
robustness of the system because you're
running on a underlying platform that's
been battle tested over many years
chances are your solution is going to be
very robust that's something that's hard
to do on native on this you spend a lot
of time on testing with the advent of
multi-core right many many system on a
chip designs today will have multi-core
have multi-core going forward so
multiple the ability to run multiple
applications on different hardware
components to speed up and do more
sophisticated algorithms that's tricky
to do a native typically very system
specific in Java that was built in from
the beginning so you can support
multiple cores and multitasking very
easily in Java again with a portable
design so you can move that to a
different system which might have a
completely different architecture and
different types of course different
features and it'll just work performance
that's something people always worry
you know Java is really slow right those
were the old days we what we've seeing
is that Java is very well suited for
many many applications in terms of
performance and in fact native is not
always as fast as one might believe it
depends on the circumstances I spoke
about update ability again that's very
good in Java because you're not actually
shipping around native applications your
shipping around java applications which
are just modules that get downloaded and
installed and run in a sandbox they
don't affect the integrity of the system
the stability of the system and that's
very hard to do in native of course the
development model is something that
speaks for Java so you can use the same
skills in the same tools going from
large server enterprise systems all the
way down to embedded that's much harder
in native where typically you switch
from one platform to the other and you
have to start over it's it's much harder
to get embedded expertise development
expertise um whereas there is a large
pool of nine million developers in Java
now granted they're not all embedded
Java developers but the step to become
an embedded java developer and
understand the limitations of the system
and the design challenges and job is of
course a much smaller step than in
native
I don't want to spend too much time on
tools but just suffice to say we have a
complete range of tools that allow you
to develop embedded java applications
very efficiently for a typical software
developer in the embedded world this is
a godsend they are used to a much more
difficult development environment and
development process here you just use
high-level integrated development
environments and you write Java code
just like you would on any other Java
based system there of course certain
limitations you know you there's only so
much memory you have but fundamentally
your expertise applies here as well
so we're going through this fairly
quickly if you have any questions let me
know so now you have background on the
product on the types of environments
we're targeting I wanted to speak about
three use cases that I found very
valuable to highlight sort of the
business advantages of using Java on the
client the first one is probably one
that you've heard already at the
conference our partners Centurion but I
I still wanted to highlight it because
it's really an almost an ideal use case
for what we're trying to do here and so
Centurion has been a longtime partner
with with Oracle in the java space and
their modules are really you know these
small wireless modules completely
integrated including IO connectivity and
everything they're complete computers
without a screen run off a battery low
power low cost and they are being used
in a wide range of use cases across
different industries so industrial
automation is one home health care i'll
talk about that in a second security
monitoring so it's really a Centurions
way of adding intelligence to these
devices and in fact one of the major
reasons that Centurion went with Java
and that's you know all the other
benefits aside you know big developer
community productive environment it was
actually because they wanted to get away
from native code as much as possible
native code impacts their system design
every time you change native code on
these wireless modules you have to re
qualify the module right because it has
a radio stack so you have to go through
recertification of the local authorities
they wanted to get away from that and
make the native layer as slim as
possible and never ever change that
again and alt add all the business
intelligence the application the
management of the module go to Java
because that's just a much easier way to
to provide that software stack so
they're smart programmable devices as I
said they are running oracle java me
embedded clients so they're running this
product and Oracle's
sorry Centurions specialized this
product in a number of ways on the added
remote management and provisioning
functionality and they are helping their
partners to integrate with the
particular solution right so that's that
Centurions value add here in creating
that customization for particular
industry yes you know I don't know and
you don't care you never see the
operating system but yeah so you mean of
the Centurion solution okay I I don't
know what the operating system is um and
centurion i believe is flexible to
change that based on the requirements of
the customer but the whole point is that
as an application developer you never
see the operating system right you just
see the Java layer you turn on the thing
it boots up and you run your java
application and you're completely
abstracted from that that's you know
centurion does all that integration work
for you but you know typically in the
space there are any number of small
real-time kernels you know arm has their
own it's called r-tx there's you know II
cost is an open-source version there's
thread X there are a number of you know
number of operating systems and they all
are you know fairly similar they have a
certain type of functionality and the
Java stack just plugs into that and off
you go
you mean the networking stack yeah
typically you would rely on the
operating system provides so so what you
need from the operating system for this
product for the java runtime you need a
simple way to execute a thread which
will be the java you know virtual
machine you need some basic memory
management although most of the memory
management is done by the java runtime
and you need a set of drivers that
support that particular platform and
once you have that you just build the
java runtime on top so it's it's a very
very smooth integration path and any
software that you wrote on top in java
just seamlessly my grades for one
platform to the next one so here's a
case study that we that Centurion and
Oracle have been talking about since
last year this is a device by the
philips healthcare division it's called
philips respironics system one and it's
a really interesting device because it's
something that showcases how you can
make patient health care much more
efficient with the use of these small
embedded devices so what this device
does is it actually monitors the
sleeping pattern the breathing sorry the
breathing pattern of a patient at night
when they're sleeping you know to
monitor sleep apnea and things like that
and the system continuously monitors the
pressure that the patient has the volume
of the air intake and things like that
the frequency and it collects that data
it does some pre-processing on the data
and then sends it to the healthcare
provider so the doctor can actually sit
at the terminal in the office and look
at all the data that's accumulated over
sometime and can detect you know
problems in the patient's breathing
pattern and in fact the doctor can
actually make changes so if they see you
know for example there's not enough
pressure
applied when the patient is inhaling
then the doctor can actually change that
parameter its gain push down to the
device and so the doctor can actually
adjust the care that's being provided
without ever without the patient ever
having to come to the doctor's office
right so so it's a very compelling
system that allows you to to provide
better care while reducing costs at the
same time exactly so so all the local
functionality all the intelligence that
connectivity to the actual device
everything's running in Java Java does
the pre processing of the data to make
it more valuable connects to a back-end
and then also receives the parameters
that are being pushed down turns around
and and a keel affects the the behavior
of the device right and so I found it
really interesting to give you a quote
from the senior vice president of
Centurions gemalto Centurion unit
because it wraps up pretty nicely I
think the value that applies to to Java
in general in this space right it's so
it's an open robust cross-industry
application environment that makes
development and deployment of software
or services and the integration with
back-end services much more efficient
and it ultimately improves the bottom
line because you deliver a better
product at a lower price and you're
quicker to market and you more flexible
moving on to a slightly different use
case this is one that is currently being
rolled out in a trial environment in
germany deutsche telekom are gay so one
of the largest carriers has worked
together with quicken and processed to
deliver a home automation platform into
the European market now admittedly this
platform you see the yellow box in the
middle is actually a slightly larger
platform than the Oracle Java ME
embedded product because it runs osgi as
a framework so this is a more capable
platform in terms of hardware and
processing power but the the concepts
you know this was devised before before
we launched this product but the
concepts apply just as well you could do
a lot of this with a smaller device now
a microcontroller based device so what
this system does is it's basically a
home automation gateway that sits in the
in the home it's connected via dsl it it
can interact with all sorts of
peripheral I oh so for example you know
zigbee devices which is a short-range
wireless communication to turn on and
off lights it can interact with your
home ventilation and heating system it
can do a number of it has a number of
integration points with different
components in your house including other
consumer electronics devices the really
interesting aspect of this is that it's
completely managed by the carrier
infrastructure so you can actually push
new applications down to the system
there's actually or will be an
application store so they envision that
third party service providers can
actually write applications that add
functionality to the system offer it in
a store and the user can then actually
select their application and change the
behavior of their system that way so
it's a whole integrated solution
including you know software hardware
management that's being rolled out in in
Germany at this time it's in field trial
they
want to go live i believe next year and
so if you look at the the business
analysis behind this there are a number
of benefits that the java platform
brings to the system time-to-market was
a very critical one they could have not
done this by developing their own
plumbing on both sides right so they use
job on the backend job on the client so
time-to-market very important of course
over time they will start offering
different client devices different home
automation gateways are four different
you know user types user requirements
different integration so they have to be
able to change the hardware over time
without reinventing the whole client
software right so the ability to swap
out the hard when putting something else
underneath was an absolutely an absolute
requirement you need to be able to
manage these devices remotely because
they're long-lived you know things might
go wrong you might have to push new
software on them new security updates
you know new integration integration
features so remote management and update
abilities is key local intelligence so
by having the ability to execute
algorithms locally you can involve third
parties and they can build applications
that customize the functionality of the
device depending on the user needs so
all these things is what the Java
platform brings to bear and I think if
you talk to partners like process they
will tell you know they they've been
involved in this for many many years and
they see Java is the key component to to
all of this
another use case the third one I want to
talk about is so the concept of smart
grid in general so we heard freescale
this morning talked about you know the
need to make our electric grid more
efficient more adaptive Oracle has been
working with partners in various markets
for a number of years now there's a big
deployment in France for example with
EDF electricity difference come to you
because of a mandate of installing smart
meters across the country so we have an
architecture that supports that but I
would really like to go into the client
aspect on the right and specifically the
application sorry smart metering and
adaptive energy use use cases so smart
metering is the ability of course to
monitor energy use and optimize energy
consumption with the help of an adaptive
energy use system right so there's this
concept of demand response energy demand
response standards that are being
developed where the utility can
essentially set a price and react to
demand and supply imbalances in the grid
right so for example on a hot summer day
everybody's turning on their air
conditioning the utility will want to
basically send an event to all the
consumers saying okay we're at the limit
I'm raising prices please try to reduce
energy use if it's not absolutely
critical right your operation oi to your
home to your life so to make the grid
much more efficient and balance and
supply and demand so that's what energy
of that adaptive energy use is about and
we actually have a demo on the demo
grounds at javaone showing off an energy
demand response client which
periodically pulls this energy demand
server on the internet waits for energy
events and then can react to the event
based on the parameters that they'll use
set so the user could for example say
all right I can I can afford to turn off
this row of lights right i can afford to
raise the temperature of my AC control
you know by two degrees to conserve
energy and reduce my costs so the
benefits of java here is again very
important the ability to swap out the
hardware over time these systems are
deployed over many years electricite de
france in in france that was one of the
key requirements we need to be able to
multi source from different hardware
vendors these smart meters and we can't
afford to rewrite the software every
time you can update the software in the
field of course so for example if you
want to add new functionality support
new standards you can do that even if
the devices are sitting out you know in
the home somewhere far away from your
central management server also hear that
you know the the the ability to add
local intelligence is very important we
heard this morning about this de lujo
beta that's coming like all these
devices producing you know petabytes of
data and it's absolutely mandatory that
we find a way to reduce the data at the
source and extract only the valuable
information and send that back rather
than a lot of noise with a little bit of
information right so for example in the
in the case of smart grid what you want
to do is you want to filter your local
data you get lots of you know energy
usage measuring points and you want to
filter that data and find out where the
interesting changes in energy
consumption right and only send those
back or or maybe even coalesce them and
only send packets every once in a while
because you don't need an immediate
response it's good enough to do once an
hour right so reducing your actual
service costs because of course every
time you send a packet over a cellular
network it's going to cost you money
right so the fewer the less data you
send the more valuable the data is you
reduce your costs immediately right you
need to support obviously a variety of
protocols and interfaces both on the
local connectivity side what devices do
you into
act with different types of meters for
example different types of interfaces to
control your consumers but also up stack
you need to talk to different types of
integration points on the backend that
might implement different standards you
know in different countries for example
energy standards yeah so that's um
that's what I wanted to talk about in
this use case so that's pretty much at a
high level what I wanted to talk about
just give you a little bit of deep dive
into the roadmap and you know what you
can expect over the next 12 24 36 months
again apologize for the eye chart I
think we'll what we'll focus on is the
lower part on the gray area so we're in
2012 now we've released these to the
Java me embedded 302 product as well as
the appropriate corresponding toolset
Java me sdk 32 we are currently planning
to rev this product very quickly because
we're already seeing a number of people
coming to us and say we have additional
requirements can you fulfill those so
we're planning a update release first
half of next year roughly with a couple
of features to enhance integration
points support more more platforms out
of the box and then really the big the
big incremental step will be in the
summer of next year timeframe late next
year time frame where we upgrade to the
next version of Java ME so we just filed
two new Java specification requests
yesterday the day before yesterday
essentially to bring the small embedded
platform up to the standards of java SE
so you can use a lot of the language
features and api features of SE which
makes the platform even more homogeneous
and allows developers to translate their
skills even easier so there will be a
number of new features coming in Java ME
embedded eight and then the tools will
will support what
ever we do as well in parallel NetBeans
IDE always has the support for the
latest and greatest features of these
products and platforms so a pretty
aggressive roadmap a number of products
that need to be coordinated you know in
parallel we also have java SE embedded
for the larger systems evolving over
time we're also bringing together some
of the functionality to align big java
and small java again to make the
platform easier to address a more
homogeneous for for developers and
people who are deploying this yes yes
right so so java SE embedded will bo
have more tunability more modularity
over time to be able to address a wider
range of systems but pretty much because
Java Sea embedded was designed for large
systems there is a lower bounds on how
low you can take those systems right now
it's around maybe sixteen twenty four
megabytes roughly so with java SE
embedded you can't really address the
microcontroller market you never will be
in it's not designed to do that so
that's where Java ME embedded comes in
so any basic you can span from the lower
part up to where it meets se system
requirements so we have will basically
have two products spanning the entire
range currently we have three we also
have the cdc product but that's going to
be integrated in Java Sea embedded going
forward so again the story at the end of
the day is it'll be one java aligned in
terms of features languages tools and
then you just basically pick and choose
which product you need to run based on
your hardware requirements so it's going
to be a very simple choice
and again you know reduced complexity
reduce time-to-market that's the goal
Mike exactly CDC is is is covering sort
of this middle tier but we're making
java SE embedded more configurable more
modular so that it can cover cdc in the
cdc product basically goes away so it
makes things easier but we'll still
cover that range of devices yes sure
I figure
so the plan is will there basically one
product that's completely tunable and
the answer is no and that well that at
least not in the near future and the
reason is that fundamentally the design
of the software of the runtime has to be
very different depending on your target
and it's essentially not possible to to
develop a java runtime that scales from
one megabyte up to 500 megabytes it's
just software architecture just it
doesn't work so well probably for the
near future have two products one that
scales you know from 0 to 10 megabytes
20 megabytes and the next one that
scales all the rest that's the plan but
from a developer perspective because
we're aligning the ape at the developer
level at the API level and the feature
level we're aligning the two so as a
developer you don't care you just know
oh it's Java ME aid or Java SE aid but
it basically has the same features it's
to the platform implementer they have to
make a choice but the software
translates just fine
talking with development give me
language consequence but when I think
about it I have different architecture
adapted with the different interfaces
for everybody then leave in OS which is
finally impacting to the one on the
other hand we learn things about data
the data have to be sent to any other
machines and believe protocols how does
this fit finally together that is easy
so my developer transfer for UC system
legacy Java has wonderful language for
having a different operating system back
sorry n so I do not agree with some of
these content updates
so compared to native development where
you build your own stack you integrate
all the parts you have an operating
system right okay right
like okay I think I understand the
question yep right right so yeah so we
only have two minutes left and there was
one more question back there so maybe we
can take off offline you know some of
the details but fundamentally if you
have a dedicated solution somebody ships
you a stack you're happy with that you
don't need to make changes you always
stay on that platform you know you just
want to write your software for that
dedicated point solution native is
probably fine that's what people have
been doing for decades right once you
have the use case that you want to
translate what you've been doing into
different areas of your business you
want to support different types of
protocols different use cases different
platforms you want to leverage some of
the AP is and the features that the java
community has out there right once you
want to do a modular upgrade out in the
field rather than you know be flashing
the entire device you want to do modular
upgrades to save bandwidth and
complexity in all these cases Java is as
far as I believe a much better solution
it allows you to scale quicker it
involves less risk it increases it
reduces your time to market but we can
take it offline and I'd like to take
another one more question up there yes
right
I
what is better well nothing really
changes from a developer's perspective
the system is faster it has more memory
it might have more io bandwidth io
connectivity but so it depends you would
from a system design perspective you
would say okay what are my requirements
in terms of you know the ability to
handle data the ability to process data
to store data what is my response time
right and then you go choose the
platform that meets your needs right you
can go very low if your if your
requirements are pretty low you go very
low into the cortex m3 m4 and very low
system costs a couple of dollars per
system or you go into the a9 range which
is a pretty high-powered system if you
can afford the space the footprint the
power right but from an application
developers perspective and that's the
beauty nothing really changes your
applications run faster you can allocate
more memory right you can do things
quicker you might be run you're running
multiple applications at the same time
without degradation but that's the
beauty if you develop let's say you
develop a horizontal application of
vertical application for some market in
that particular use case is very
resource constrained they have to watch
the bomb cost right you will choose the
appropriate system cortex a for for
example low-cost arm later you go to a
different customer they have the same
basic functional requirements but they
need more horsepower you choose an a5
and a line you can just take your
software drop it over onto that system
and you're done right so call it time
the market dramatically reduce
development costs dramatically reduced
because all you're doing is changing the
underlying platform and on top you don't
notice what's happening right so that's
the benefit so we're done thanks for
good question being engaged I hope you
enjoy the rest of the show thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>