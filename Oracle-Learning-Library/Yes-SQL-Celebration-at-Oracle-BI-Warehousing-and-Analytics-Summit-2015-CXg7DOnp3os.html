<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Yes SQL! Celebration at Oracle BI Warehousing and Analytics Summit 2015 | Coder Coacher - Coaching Coders</title><meta content="Yes SQL! Celebration at Oracle BI Warehousing and Analytics Summit 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Yes SQL! Celebration at Oracle BI Warehousing and Analytics Summit 2015</b></h2><h5 class="post__date">2015-04-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CXg7DOnp3os" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome my name is steven feuerstein
and we're here for a yes ql celebration
we held our first yes ql celebration in
oracle openworld and last year and we
thought we'd do a repeat of at least
part of the event hopefully you'll enjoy
we have two special guests Tom kite and
Andy Mendelsohn here to share some of
their stories and views on SQL one of
the most amazing technologies ever
invented and then at the end of the hour
I'm going to introduce some members of a
new Oracle database evangelist team
which I am leading feel free to tweet
away on hashtag SQL so y SQL i'm sure
you'll go heard of this you've heard of
SQL structured query language and you've
probably heard of no SQL as well no
sequel so no sequel is a fine technology
if it wasn't we wouldn't have an Oracle
no sequel database but it's got a pretty
lousy name and it basically has
reflected or at least it was taken to
reflect an unfortunate trend out there
in the world to diminish the importance
of database and diminish the importance
of SQL else and key technology and just
use databases a dumb datastore which as
you can imagine we had Oracle don't
think all that much about and we don't
think it makes a lot of sense in terms
of powerful maintainable scalable
application development so we thought it
was time to start making sure that we
all understand and remember how
important SQL is and remind the world as
well so one of the things that I I've
been reflecting on since I rejoined
Oracle back in March last year is that
SQL has been around a long time
obviously in the in the faddish world of
software and one person described it to
me this way that the only industry
that's more fashion conscious and
faddish than the fashion industry is the
software industry if it's not new if
it's not bleeding edge how good could it
be SQL has been around for a long time
how good could it still be really do we
really need to use this language and I
think what's really clear is that this
is an incredible enabling technology for
the entire information era Internet era
and mobile air so to give you a sense of
that and to drive home the importance of
SQL I've asked Tom kite to stay over
from his last session to offer some
reflections on the cyclic nature of
languages for database manipulation no
sequel sequel maybe sequel not only
sequel etc so
explore that a bit and then we'll have
Andy come up and spend a half hour with
you sharing some stories of his time at
Oracle the things he's learned over the
years and some really excellent insights
on oracle database technology so turning
it over to Tom kite thank you for
joining us so this is sort of a mini
reprise of what i started my last talked
with think of this question show me all
the employees who make more than ten
percent of the total salaries in their
department now go back to 1975 your
programming an RPG cobol maybe even
assembler you got the employee file how
many lines of code do you think you're
going to write to answer that particular
question it's going to be hundreds if
not thousands and you know what else you
have to do you not only have to write
the code to do that you have to be an
optimizer because you got to figure out
should I do this part first and then
flow that into here or should I do this
for you know looking at a complex query
trying to figure out what the joint
owner is how many people think they
could look at a query plan for example
for a given arbitrary query and tell
with one hundred percent degree of
accuracy that that is the perfect plan
for that query does anybody have that
confidence because if you did I need you
to see me afterwards we need to hire you
to become the optimizer right it's a
really complex thing even if you're
given a plan looking at it and saying
yeah this is the best plan ever
especially when it's a 15 or a 20-page
plan is is really hard that question
show me all the employees that make more
than ten percent of the salaries in
their department is rather trivial to
answer in sequel I just need like a
sub-query adjoin and things like that
that is something that in 1979 with
version 2 of Oracle you probably could
have answered and he's going to have to
verify that but I mean had some queries
they had joins and it was rather
revolutionary yeah if you were
programming in the 70s I wasn't I
program
in the 80s but when I learned to program
i learned program on a teletype you know
if you wanted to program codes you were
typing a line at a time you couldn't see
the entire program when you backspace it
actually went back to space and put an X
through what you were looking at it was
rather primitive and so for sequel to
come out and all of a sudden you could
ask questions of your data that you
didn't even think to ask before because
it was just too difficult you had to
write a program every time you were
doing that sequel was sort of
revolutionary and we sort of come back
somewhat full circle you know because if
you're talking about going after in no
sequel datastore you got Jason documents
keyvaluepair I can get a document out I
can put a document away I can do simple
queries but if you want to do a join
who's doing the joint you would be doing
the joint I'm going to be a lot like
going after v Sam file again I've got a
key give me a record that records got
other keys let me go walk those keys and
so on no referential integrity no
constraints no indexing no nothing
that's sort of what the no and no sequel
stands for all I want to do is be able
to get put delete and sometimes
simplistically query some data and that
works great in a certain environment for
some things like a shopping cart it
works fine for a payroll system it's not
going to fly right and so sequel really
forms the the foundation for all of this
stuff and do you really want your
developers to be in optimizer do you
really want your developers to know when
they need to transaction and then how to
program a transaction so that they have
redo logs and undo capability and
persistence and they can dataguard the
stuff and they can do all that other
things that the database does it's it's
a bit liberating once you know the
language you know I've got example as I
keep him filed away because I really
like the queries but I can't throw them
up on the screen because the font would
be really really tiny to see him but
way back in the day anybody remember
Palm Pilots they had 64 kilobits of
memory and they used to do this thing
called a palm sync go back in the 90s i
wrote a palm sink is synchronized with a
calendar database in an oracle database
it was one line of code it was one
sequel statement it could take the
contents of the Palm Pilot join it with
the contents of the Oracle database and
it generated all the change records
needed to be applied to the palm and all
the change records need to be applied to
the database one sequel statement took a
little while to debug it but it's like
debugging any other program but it
wasn't hundreds of thousands of lines of
procedural code all over the place it
was just one thing and it ran amazingly
fast a lot of people are shot sometimes
it how fast sequel can actually run you
know as long as you've got the right
structure the right schema in place
sequel can basically outperform anything
any sort of procedural approach I've got
slide I should have stuck it in here
let's say you come up with an operation
that takes one millisecond and you need
to do it five million times you know how
long that is it's an hour and 20 minutes
give or take now do it 50 million times
now you're talking ten hours now do it
500 million times now you're talking
over a day you need to do it five
billion times five trillion times the
old procedural processing that we've
been trying at databases for years
doesn't scale up once you get into
trillions of Records or even billions of
Records would you give me a sequel
statement that needs to go through a
trillion rose given the proper hardware
and say an exadata environment I can
process the trillion rose very quickly
using a single sequel statement but if
you ask me to go row by row procedural
code it's not going to fly sorry to keep
saying this Steven because you know he's
the PL sequel guy if you will and I'm
sorry the sequel guy but if you bulk up
your sequel you can do things in an
amazingly short period of time hopefully
some of you saw the previous session
where I was showing you some of the cool
things you could do in sequel go out
there and learn those new things impress
your friends there's nothing more fun
than walking into a meeting and saying I
took your 10,000 lines of code that
takes five hours to run and I got a
query the does it in 22 seconds that is
fine right and I love being able to do
that you'll be able to find many places
it requires reengineering in some cases
right I got to understand what I was
trying to accomplish and then re
architect it but by making major changes
like that you can go a thousand times
faster on the same hardware okay so now
I'm going to turn it back over to Steven
and thank you very much and see you guys
later thanks thanks so yes it's true
several years ago Google Facebook many
different vendors said we don't need SQL
we've got a better faster way to do it
we need to do in terms of scaling up for
massive numbers of users enormous recent
time with the data that they had to deal
with and what happened is that people
came around and said how well we got
this database technology it's pretty
good for what we need but writing
applications against it really really
hard what we need is a language that
allows us to query the data at a high
level in the declarative fashion we need
SQL but now we'll call it new SQL or
whatever it's going to be bottom line is
SQL is a fantastically powerful
technology it's been around for a long
time it's going to be around for a long
time to come and what I'd like to do now
is invite andy Mendelsohn to come out
he's an executive vice president for
database server technologies not only
did he write the Oracle btree indexing
code that we're still using today but
for the last 12 years he has managed the
server technology division including
oracle database most notably so we owe
it to this guy this one man for all the
features of oracle database no of course
not an enormous organization of
extremely talented people great please
brought together and kept together also
part of my favorite aspect of Andy's
history co-designer of the oracle PL
sequel language yes that's the only
thing i know so i tend to talk about it
a lot and i'm really glad we chose 8 is
the model Ford etc etc but I certainly
subscribe to to Tom's mantra do it in
SQL if you can't do it in SQL do it in
PL sequel if you can't do it in plc
whatever so what we're going to do now
is have a special treat of Andy sharing
stories from the last couple of decades
of working with oracle database database
technologies in general and we'll have a
lot to learn and be very entertaining
Andy thanks for joining us stealing hey
good morning everybody see okay so
Stephen asked me to do some storytelling
today so i'll be happy to sort of tell
you some stuff about the old days and
maybe get up to the new days and you
know tom was talking a bit about sequel
and why it's been so successful and i
thought i'd put up this slide is just
sort of a backdrop for my storytelling
but the interesting thing that you see
here is that your relational database
concepts was invented I think the late
60s there was a paper by EF Cod and then
there were various research projects in
the 70s at IBM research called system
are and when at Berkeley called the
ingress project that was led by a
professor stone break Michael
Stonebraker who's still very active to
this day starting up database companies
but relational database technology is
very unusual right it from a software
standpoint software ideas usually come
to market they're really hot for 35
years they mature and then you just
forget about them like yeah will you see
and yeah there's some new standard but
nobody cares about it and etc but the
technologies will last for a while but
they they mature and they pretty much go
dormant relational databases have been
very unusual in sequel relational
databases and that they have been
evolving steadily as we go from one
computing generation to the next oh so
they started out in the mainframe days
and went to many computers then
client-server with the PC the internet
came along and now we're into the era of
cloud and big data and sequel and
relational databases continued to evolve
as you go from one generation to the
next and
the reason they could have all so well
is because of what Tom mentioned you
know the developers write these
applications in sequel and sequel
doesn't change you know those that code
I wrote 30 years ago against Oracle
version 5 or whatever it still runs
today and it just runs faster and it
runs in parallel and it uses column you
know stores etc but it's all transparent
to me as a developer I just specified
what I wanted my result set and the
query optimizer and the query runtime
execution runtime just figures out the
best way to run it for me and as I go
from one generation to the next it just
gets better and better so my investment
is preserved in both the applications
I've written and also in my skill sets
you know I wrote the skills I learned 30
years ago for sequel they still work
today sequel has evolved but the core of
sequel is the same and so that's one of
the real secret this whole declarative
sort of basically functional programming
language style of sequel is what's
really unique and it's what let
developers work at a very high level of
abstraction and then my developers you
know who write the query optimizer and
the query execution runtime they are
allowed to innovate under the covers and
constantly evolve the product under the
covers as we move from one computing
generation to the next and and make the
product relevant for each new computing
era and that's really been the big
secret of relational databases and if
you look at all the modern programming
languages out there there are some
people now trying to dabble with
functional programming languages things
of that sort but in general they're all
the same as I were 30 years ago the
procedural you right step by step what
you want want to do and that's great
your program works great but it doesn't
really naturally evolve from generation
in the next generation like like
relational sequel queries do okay so
I'll tell a couple stories from the the
old days and move forward so I thought
the first thing I'll talk about is sort
of where did sequel come from so the
concept of relational databases you know
came in the late 60s early 70s but
sequel wasn't there it was
look at that original paper by cod it's
very academic he was a mathematician and
it's all about you know national algebra
and relational calculus and all kinds of
other stuff he didn't really have have a
language in mind the language came in
the 70s when there was an IBM research
project called system are they invented
the language called sequel was spelled
seq uel and they were actually competing
with the berkeley researchers led by
stonebraker and he had a language called
quelle QEL so sequel and quell as you
can see they were sort of competing even
than in the names of the languages so
anyway they had come up with would their
their their research projects and system
are and ingress where the were the
databases that grew out of that and then
oracle came along in the late 70s you
know Larry Ellison I mean Bob miner were
working at a company in the valley
called ampex who's they did tape drives
and they got into the music industry I
think eventually but they decided they
wanted to go off and start a company and
they were both mainframe guys because
that's what was the big thing in the 70s
by being mainframes and many computers
were just starting to come along then
and they started a company and they got
this idea they actually there's a
contract that the CIA put out for
something called Project Oracle and the
CIA wanted something like a relational
database built and Larry and Bob bid on
this contract and somehow or other they
won the contract I have no idea how this
happened and they didn't know anything
about relational databases but they
thought this idea from system our was
pretty cool and they got the research
papers and they read the papers and they
built you know the first version of
oracle and they use sequel which was the
IBM system our language and you know
version 2 of article was born because
Larry already back then was a really
smart marketing guy and he knew nobody
would buy version one so he started
version 2 and that was like in the late
70s they wrote it in like I think was it
the first version was probably written
on like either a pdp-11 assembler or
mainframe assembler language I'm not
sure which and then they got
this idea that oh you know we could run
right a product that was portable across
different operating systems if we wrote
it in a high-level language like at that
time the emerging new systems language
was C and C was pretty new then I'm they
had used it to write the UNIX operating
system way back in the 70s and Oracle
picked it up and any of you remember Ken
Jacobs out there Ken Ken's famous quip
back then was he would say people didn't
even know how to spell the language see
okay that was one of his jokes because
see you as a letter as you guys know and
so anyway that was one of the court
they're really unique things or it will
figured out is we could use the C
language we rewrote the whole engine
back then that was before I started
actually there was like four developers
back then they wrote the thing in C and
they ship version 3 in version four and
I joined when they were shipping just a
chip version five so I joined about 84
so that was about seven years oracle's
old seven years old then and when I got
to Oracle we were just sort of finishing
out sequel I got to work on sub queries
sub-queries sort of worked a little bit
when I got there and I got to finish
that and make sub-queries fully work and
then I got involved in in a in the
sequel standard effort and there was a
sequel Standards Committee not it was
actually not called the sequel Standards
Committee there was a an ANSI standard
Committee for a relational data language
it was called RDL and these guys were
were sort of practitioners and from
various companies but they didn't really
know much about relational databases but
they somehow got together and took over
this committee to define a relational
database language and they started you
know they were lucky there was quell
they could have chosen or there was
sequel they could have chosen but these
guys were smart and they knew they were
smarter than those guys at IBM in
Berkeley so they created a new
relational data query language they
called RDL and it started going through
the process of standardization and IBM
and there's this guy named Phil Shaw who
was on the standards company from IBM
back then IBM decided they would just
bring
the definition document that they had at
IBM for sequel they brought it to the
standards committee the standard
committee thought you know this is
actually better than this thing we've
been working on for the last couple
years and they were smart enough to just
take the IBM language and in about
nineteen eighty six they standardized it
as the sequel language that we know
today the standard back then was
probably about 50 60 pages long the
standard today is God knows how many
pages right over a thousand but the core
of the language was defined and that was
really important for Oracle because
Oracle had chosen sequel as a language
so we were we had gone in the right
direction ingress which was the company
Stonebraker it spun spun off from
Berkeley they had used quo of course
because that was the Berkeley research
language Stonebraker basically didn't
know what hit him cos quo obviously was
much much better than sequel I mean you
know hit you know that and he believed
that to his very core and it took him
about four years of banging his head
against the wall trying to compete with
this standard before he finally gave in
an ingress sort of moved to sequel
eventually too but they were years
behind Oracle because of that so that's
sort of how sequel evolved the next
thing that evolved was sort of PL sequel
so I'll talk a little bit about that so
Oracle was doing really well in the
early days you know like a lot of
startups we were growing you know
doubling revenue every year when I
joined in 84 our revenue was about seven
eight million dollars big time and it
doubled to about 12 million and then it
was doubling every year until the late
80s and then something came along that
the next generation which is
client-server computing came along the
PC had come out actually probably early
80s maybe even before that ms you know
Oracle had a version that was running on
ms-dos we thought we were really cool
but when client-server came along things
changed out from under us suddenly in
the mini computer mainframe days the
application in the database were all
co-resident on the same server there was
no network between the application code
and the database so we didn't worry
about you know minimizing messages
between a client and
server which is what became really
important the PC era we were just
implementing an API but then Along Came
sybase so sybase was a startup in the
mid 80s and their big idea was they
would design a database from scratch for
client-server computing and they came up
with these ideas for minimizing messages
issued from a client to a server and
they came up with this key idea story
procedure I can issue one message I can
invoke a procedure on the server do a
whole bunch of operations and then come
back and they invented this language
called transact sequel which is also the
language before sequel server uses
because Microsoft ended up buying the
source code from sybase for sequel
server which is another story I won't
tell today but I'm but anyway sybase
came out with with stored procedures and
they also had this other innovation
called triggers triggers also let you
let things happen on the server side
without any messages over the network
and triggers were used to implement
things like referential integrity and so
orgo although we had a really powerful
oltp engine that we had rewritten and
for version 6 in the mid-80s and that's
when i did my be my be tree rewrite and
we added things like consistent read and
row level locking it was really cool
stuff we had a great back end but over
the network we were very inefficient we
would send you know every API call was
buying this value and fetch this real
everything was generating lots of
messages so we had to scurry about to
try to riorca tect the product and
basically make this transition from the
mini computer era to the client server
error by riorca texting the product and
while we were doing that in development
the business completely collapsed and by
the early 90s Oracle was virtually
bankrupt I mean we we went from doubling
every year to I think our revenues you
know grew only like twenty or thirty
percent which was is good today it
sounds good but back then that was a
disaster and Larry actually had to send
this guy Ron wall to Japan Ron wolf some
of you may know ended up running the
applications business for many years at
Oracle and Ron went
japan he managed to get an investment
from a company called nippon steel which
is a steel manufacturer and they
invested in oracle we managed to have
enough money to get out get out the next
major version of oracle which was called
version 7 and version 7 came out in
about 1991-92 and version 7 was where we
introduced PL sequel stored procedures
PL sequel actually came about was
actually shipped in version 6 as well
but there was no stored procedure notion
it was just something we called
anonymous blocks where you'd send this
PL sequel to the server and we'd come
back and butt in version 7 we had the
full thing we had stored procedures and
we had PL sequel which is of course much
much better than transact sequel and
instead and we added triggers because
sybase had triggers but we also added
declarative referential integrity
constraints back then which was much
better you know you didn't have to
program triggers you could just say you
know here's a foreign key there's a
primary key you know here's the
constraint with sybase you had to write
these complicated triggers to do the
same thing and then we added a
declarative two-phase commit back then
you know you could just say commit and
it was a distributed transaction it
would do all the two-phase commit under
the covers with sybase you had this
complex set of api's to make two-phase
commit work so when version 7 came out
we really blew sybase out of the water
we we leapfrog everything they had plus
we have this great sales force that went
out there in a couple years we pretty
much dominated what was the relational
database market back then in the early
90s okay so that got us through the
computer the client-server era we were
doing really well and then from
client-server we sort of evolved into
the internet as we went into the the
mid-90s and companies like you know
amazon.com came up back then ebay yahoo
they were all big Oracle customers and
we had evolved the product of course the
deal with the demands of the internet
but the internet wasn't really that much
different from an architectural
standpoint you still had a server
running the database now you had an
application server running the app
tation instead of the application
running out of fat on PC necessarily but
from a database server standpoint it
wasn't a big change so we didn't have a
big challenge in the market from from
for a technological reason but we did
get challenged by competitors again and
so you know ingress was the early
competitor then sybase came along and in
the Internet era the emerging competitor
was actually informix I'm sure a lot of
you remember in for mix there's so
people using it i'm sure out there in
the audience so we sort of tangled with
in for mix as we sorted you know we're
in the early days of the internet era
and Stonebraker was still of course a
very active you know he had already
formed ingress and that company didn't
do real well and he went back to
berkeley and you know went back to doing
research and his new research project
was called postgres and postgres was
about adding object-relational
capabilities to relational databases you
know so before postgres relational
databases just stored you know rose with
scalar values you know a number column
value or a date or a string that's all
relational databases could do but with
postgres we added object relational
capability and Stonebreaker as he always
did repeatedly what year is once he had
a research project that he thought was
in good shape he would spin off a
company using that research project as
the core and he spun off a company
called a Lustra around postgres Oracle
of course was also monitoring the the
object relational research and we had
started a development project also in
the early 90s I'm to add object
relational capability and actually one
of the cool things that happened back
then as we quite already be when was
that Steve about 94 yeah in 1994 so we r
DB was the digital equipment sequel
engine and anybody remember digital
equipment out there it's amazing but
they were very successful mini computer
manufacturer in fact
circles flagship product was Oracle for
vax VMs you know in the 80s and early
90s that was the the platform well
fortunately and Dec our DB was one of
our big competitors actually but the on
that platform they were the sort of very
low cost all turned off by the hog the
hardware vendor but fortunately somehow
we convinced i guess chuck rose wat was
over there and deck and he decided
somehow to sell our DB to oracle and we
got the rtb code and the rdb development
team and we were working on this object
relational project then and we needed
people to work on on adding new data
types to the server so the RDV guys
became the core of the of our object and
extensibility effort back in New England
and that's the the beginnings of things
like spatial and text and other stuff
like that that and I see spatial is a
big topic of the bwalk conference this
year but anyway we tangle with informix
informix got wind that we were building
object relational technology and they
decided well the fastest way they could
get to mark was to buy elestra so they
bought a Lustra in about 1994-95 maybe
was 95 and they announced this is really
cool because we're going to take a
Lustra and we're going to take in for
mix and we're going to take those toques
to different source code products and
we're going to merge them together to
create infirm Excel server and we're
going to do it in six months and Larry
just thought this was the most hilarious
thing he'd ever heard you know he's they
were going to take these two separate
products and merge them together and
ship it in six months and so Larry had a
great time telling everybody these guys
are a bunch of idiots there's no way
they could do it and of course Larry was
right you can't they can't merge
databases that fast but meanwhile while
informix was busy trying to merge their
code together we ship a version 8 point
of the database that had our object
relational capabilities in it and that
of course is you know the foundation of
you know as we get to Big Data nowadays
that's that was when we started adding
support for all these different data
types in the server since you guys are
at the bwalk conference I guess the
other is maybe the lab
story i'll talk about is the data
warehousing story you know how did we
get to where we are on the in the data
warehousing market so i guess the story
there starts way back in the in the deck
you know the pre the mini computer era
you know we had a version of oracle that
ran on the vax VMS vax VMS supported
something called a cluster file system
and basically there was a way of sharing
files across clusters of sm piece deck
back servers and we made in a virgin of
oracle that worked on that kind of
configuration and that was sort of the
beginnings of what oracle what became
were holes and today rack clustered
technology so we had that version that
worked on version 5 he went to version 6
it became something we called parallel
server parallel server sort of let let
us do she would we called shared is
clustering it worked pretty well for
warehousing you know parallel queries
scaled pretty well and power parallel
server customers also tried to run
transaction processing applications
those didn't scale at all unless you
were you know there were few customers
who got to scale I shouldn't say it
didn't Scout at all but if you
partitioned your work load properly you
can get the parallel server to scale
pretty well NTT DoCoMo in Japan did a
really good job of that but by the mid
90s no although we had we had to begin
parallel query working with version 7
points something or other in the early
90s that was the first parallel query
version that came out and we were doing
pretty well in the emerging data
warehouse market but we weren't doing
really well in the transaction
processing side so we had a project that
was started by Franco boots Lou Franco
was a guy from tandem and you're in fact
he started out in system are and the IBM
system our days and Franco proposed that
Oracle should ditch its shared disk
parallel server technology and moved to
shared nothing technology which is what
everybody else was doing you know IBM
teradata informix they were all using
shared nothing technologies for doing
parallel query data warehouse database
products so we went to larry and we had
a big meeting you know should
we go shared stay shared disk or go
shared nothing and around then Roger
Bamford was one of the early developers
of Oracle came up with a bunch of
algorithms for do making shared disk
scale really well for transaction
processing it was something we call cash
fusion now and larry was always a big
risk taker and you know there's a lot of
value in having a unique product that's
differentiated from the competition if
we had done shared nothing we would have
been like everybody else in fact we
would have been behind everybody else so
what Larry took a big risk and we
decided to go with Rogers a new version
of of how did you share disk parallel
database technology that became rack
that shipped in about two thousand one
version 9 of the product and that was
that huge differentiator for Oracle
because we had the only clustered
database that actually could scale
pretty well for running off the shelf
packaged applications like ebusiness
weed and s AP and that remains a big
differentiator for us today on the oltp
side Microsoft was has never been able
to make that kind of technology work IBM
db2 sort of has something like it but it
took them 10 years to do it this thing
they call pure scale but this was also
really important for data warehousing
because of course parallel query is is
the core of what people need to do in
scalable data warehouses see what else
is worth mentioning there that space
yeah the other I guess the end of that
story sort of is really Exadata so in by
the mid 2000s we were sort of struggling
no customers this whole era of big data
was starting to loom customers are
starting to build now they want to build
hundreds of terabytes data warehouses
and the customers were struggling to
implement to get oracle to scale on sort
of off-the-shelf industry components you
know they buy a bunch of servers there
was no problem there they connect them
together via some kind of internet
interconnect technology but then the big
problem was the storage the storage
vendors you know like EMC they didn't
know how to build scalable storage
technology that could scale well in a
big data warehouse environment and so
our customers were data warehouses we're
all bottlenecked on I
oh and they would all come to us say
your product doesn't scale Oracle to
crack doesn't scale etc and we talked to
emc they were not interested in fixing
this problem because emc storage is
perfect and there's nothing wrong with
it so we started this project that beak
was the original Exadata storage server
project Juan Louise &amp;amp; Company did that
and that was to solve this problem we
had in data warehousing where we
couldn't scale out well on an
off-the-shelf conventional storage and
so exited of course I solved that
problem and those of you who are running
oracle data warehouses virtually all of
you I'm sure are now using Exadata
there's just it's one of these
no-brainer things that it just makes it
so easy to sort of you know by the
hardware you drop it in you've got this
scalable infrastructure there runs not
only scalable data warehouses but you
know scalable transaction processing and
now clouds and everything else in
between so so anyway that sort of brings
us to today so you know we're moving to
this area of big data and cloud and
again where you know there's there's
there's challenges in two ways again
there's in the Big Data space where we
are in pretty good shape so on the
relational database side of course we
have this very scalable Exadata
technology for a relational database
side we're being challenged by the dupe
guys who who originally said sequel was
pretty stupid and you just need
MapReduce and now they're all like Oh
sequel as you saw from those quotes
sequel is really important and there's
like 17 versions of sequel they're
trying to implement on Hadoop you know
there's cloudera has one and high
there's the hive thing and the Gorton
works skies of another one etc but at
the end of the day we're very excited
about this space because we know sequel
much better than everybody else we've
been in the space for for 25 years
writing curry optimizers and parallel
algorithms and we came out recently with
this big data sequel technology that
lets you run oracle sequel scalable a
across data you know in Exadata Big Data
appliance are no sequel database as well
so we're we're continuing to innovate in
the big data space and then as we go to
the cloud the other big thing of course
we did was 12c multi
an architecture which is a major newry
architecture of the product we went
through every component of the database
we architected to support multi-tenancy
that makes oracle a great database for
clouds whether it's a private cloud or a
public cloud so so again you know we
think we're going to do a good job
transitioning as we go to this as we're
in this era of big data and cloud but
there's lots of challenges and I think
you know 30 years from now I I fully
expect the sequel technology is going to
be there there's no end in sight and
it's just because of this unique
architecture that as the as we continue
to go whatever the next computing error
is after cloud you know I'm confident
you know Oracle's engine group is going
to be re architecting innovating to make
sure you know it brings all your
applications forward without change as
you and take advantage of whatever the
new computing era rings and with that I
think I'll close and thanks the things i
love about andy besides the fact that he
has such great stories to tell us that
he's so punctual like I gave him 10
minutes at oracle openworld he's 10
minutes he's done everybody else was
running late everybody wanted ND to come
back on and tell more stories so we gave
more time this time thanks so much so to
finish up we have about 10 minutes I'm
going to talk a little bit more some
reflections I have had over the last few
months about why SQL has such staying
power just another way of looking at
things then I'm going to bring up my
database evangelist team to introduce
them and then we'll close up so one
thing that's really been striking to me
is the staying power of the SQL language
and Andy's addressed number of aspects
to that its ability to innovate and
really not just us but in the space
generally and stay on top of the data
needs the data requirements but I think
there's something deeper about it too
partly because we have to you know
recognize that this language this way of
manipulating data seeing data
visualizing it and changing it it's a
very powerful language that I think is
actually deeply connected to the way we
see the world
that's what I want to talk about for a
moment so in general of course we're
building software to provide a way to
take data take data in take dated back
out and essentially allow humans to
modify the world to do it and the thing
I found myself harkening back to where
my days in philosophy class at
university so how many of you studied
philosophy in college a little bit even
a little bit how many of you have ever
heard the term Platonic ideal so in
platonic philosophy this is this idea of
the ideal thing that for example in a
platonic philosophy there's the ideal
tree and then every tree you see is a
variation on that perfect ideal trade
same thing with humans same thing with
everything and I was thinking about that
and realizing that that sounds a lot
like an object-oriented modeling
approach or you have this class that's
the ideal thing and then everything are
instances off that class or subclasses
that vary from it in some way an object
orientation is obviously a very powerful
model and it's used by a lot of
organizations but it didn't really take
hold the way that SQL did it certainly
didn't displace SQL is a dominant
language for working with a modifying
data and I think the reason for that and
the reason that we're going to see SQL
sticking around for years to come is
that we don't see the world that way I
don't know about you but when I go out
into the forest I don't look at a tree
and say that almost looks like the ideal
tree that I have in my head but it
varies a little bit from that ideal
right that's not what we do we take in
lots of data and we do pattern analysis
and identify sets of things and we
identify common characteristics the way
they relate to each other or the way
they don't relate to each other I think
it's very clear that SQL is not only a
powerful algebra and a theory of
mathematical theory but it reflects in a
very deep way the way humans live in the
world the way our brains evolved to work
in the world and for that reason I think
it's going to actually be very very
difficult for sequel to be displaced to
come up with a language that fits better
the way we live naturally and think
naturally in the world so for what
that's worth some of my thoughts on SQL
I could offer some thoughts on PL sequel
but we're running out of time and the
next thing i want to do is talk about
the oracle database evangelist team so
back in March 2014 i rejoined oracle
after 22 years away very exciting moment
I mean for of course Oracle too and I
thought I'd pretty much be doing the
same thing PL sequel evangelizing
writing about it reading right and doing
videos and so on and I have been and I
will be doing that but I also have was
invited by Andy Mendelsohn and Thomas
Korean to lead a team of evangelists
that we have a very specific mission and
that is to help our current users and
the next generation of use is especially
those 20-somethings who are building all
those amazing apps to fully utilize the
Oracle database technology for
application development as you probably
know and this is true across I imagine
any software platform any software
technology you learn enough to get the
job done and very often you stabilize
what you leverage and what you know
about in that language and we come out
with more and more amazing new
functionality but a lot of people don't
use it so I'll commonly be doing a
presentation on PL sequel to open world
and brynn will be in the back listening
to me and correcting me when necessary
and I'll ask questions like who's using
addition based redefinition who's using
compile-time warnings this that in the
other in very few hands will go up now
on the one hand that speaks to the power
of the base language of PL sequel and
SQL we can have the same experience I'm
sure Tom does when he tries to find out
who's using what so obviously we're
getting by and we're succeeding with
this technology but there's a lot more
we can be doing so my team was pulled
together basically to help us all
leverage this functionality more
effectively to build new kinds of
multimedia content to build new kind of
how to's and resources to help you get
your job done better and full utilize
all the both both basic and advanced
features of PL sequel SQL and the other
apt f features of oracle database so
part of our mandate is to kind of change
the way we communicate and hopefully
entertain as we train you so just to
give you a sense of the kind of stuff
we're thinking about doing
hi i'm steven feuerstein and i write
practically perfect pl/sql and with that
I thank you for joining us we have to
bring on the next speaker you'll be
seeing and hearing a lot more from all
of us in the coming year we're going to
be inviting you the community to help us
build a vast expertise repository that
we can share with all of our users and
help us all use Oracle database more
effectively thanks for your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>