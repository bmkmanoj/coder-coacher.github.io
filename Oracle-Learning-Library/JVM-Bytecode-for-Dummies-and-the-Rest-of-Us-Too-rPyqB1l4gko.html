<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JVM Bytecode for Dummies (and the Rest of Us Too) | Coder Coacher - Coaching Coders</title><meta content="JVM Bytecode for Dummies (and the Rest of Us Too) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JVM Bytecode for Dummies (and the Rest of Us Too)</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rPyqB1l4gko" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so JVM bytecode for dummies and
anybody else that wants to generate
bytecode and doesn't necessarily
consider themself a dummy I'm Charles
Nutter I work now seems like every time
I'm here I'm somewhere different but now
I'm at Red Hat working in the JVM
language group and JBoss mostly still
just working on JRuby but in working on
JRuby since I'm primarily responsible
for compiler optimization performance
stuff I do a lot of like cogeneration a
lot of bytecode analysis lots of
low-level JVM stuff and after doing this
for years I kind of figured that there's
there's two talks that I could give to
kind of give other people insight into
how the JVM works and how you can take
better advantage of it so this is really
kind of a two-part talk I've given it as
one long tutorial thing before but
there's two parts the first part is what
we have today talking about JVM bytecode
a little bit about how to inspect the
code actually a decompile or yet
disassembled Java class files and
understand what you're seeing a little
bit generating it and I'll talk about
several different libraries in brief
that you can kind of look into on your
own they all have generally the same
structure it just depends which language
what sort of DSL format you want to use
and how the bytecode actually works how
the VM executes sit how the stack
operations work how local variables work
and then kind of the basics of getting
going
generating bytecode and understanding
what it's doing the other talk which
I'll give tomorrow morning at the same
time same room we'll talk about from the
bytecode level down talk about how the
JVM actually takes that code and
optimizes it into native code how you
can monitor that process how you can
view the optimizations as they're
happening and if you want how you can
even go down to the native assembly code
that the JVM is right so if you're if
you're intent on getting the best
possible performance out of a piece of
java code that's a good talk to check
out because you can actually see what's
running on the hardware and it you not
be scared it's not not that complicated
understand it okay so other talks I'm
given my quick plugs like I said JVM JIT
for dummies tomorrow morning talking a
little bit about how we've been working
how all the challenges we've had when
we've implemented JRuby tomorrow
afternoon some of that is going to be
relating to invoke VM
and performance a lot of it's late also
relating to calling native libraries and
making that all work well and then to
polyglot talks that should be a lot of
fun tomorrow night the buff we're going
to go through as many of the jvm
languages as we possibly can there's
like 250 languages that people always
talk about we're going to try and get
through as many as possible and just
talk about what crazy things people are
doing with the JVM and how you can start
doing some crazy stuff on your own and
then a more practical one polyglot for
dummies will talk about using kind of
the big three or four non Java jvm
languages we're to integrate them where
it fits how to tie them all together
okay so back to the subject at hand byte
code what is byte code these are
definitions that I pulled off of
Wikipedia an instruction instruction
sets designed for efficient execution by
a software interpreter or a virtual
machine essentially suitable for further
compilation into machine code and that
pretty much sums up how byte code is
used in most VMS today some VMs don't
actually have an intermediate
representation that they execute some go
straight to native but in general they
all fit kind of into this general
pattern so byte code the key there is
the word byte of course it's one byte
instruction
there's 256 possible op codes then if
you're using an unsigned byte right now
on the JVM about 200 of them are in use
and so of course there's room for more
but we haven't had any new byte codes
added since invokedynamic in Java 7 was
a huge deal major changes to the JVM
specification not likely to see a lot of
change in the JVM bytecode set over time
especially since invoke dynamic is kind
of a window to all sorts of other things
that we don't need to add new byte codes
for now like dynamic calls like I say
little variation since Java 1 now
there's a couple of instructions that
have been deprecated a couple
instructions that have been added but
mostly pretty static Microsoft CLR is
also sort of a bytecode VM its stack
based but they don't actually have an
interpreter like the JVM does on the
first time you execute a piece of code
on the CLR it takes all the intermediate
representation their bytecode and
immediately compiles it to native so it
doesn't do what the JVM does where it
runs it for a while let's it optimize
learns about the code a little bit it
goes straight to native and that's one
of the reasons that they can do much
faster out of the gate as far as
executing code but a lot of
optimizations the JVM can do like
reducing null checks array bounds
checking all that stuff they can't do
because they don't have any runtime
optimization so why would you want to
learn about bytecode and how it works
how to generate it well it's it's
actually pretty good to know your
platform from top to bottom most people
start with some sort of managed
languages their CCS degrees or as their
tech degrees or whatever they're doing
and never really get below that and so
then they don't understand why
performance has a problem why certain
constructs in certain languages have
performance implications what actually
all this concurrency nonsense about
caches and parallelism and all the
tricky parts they're they'd understand
how that works because they've not
gotten down to a lower level so learning
your platform as low as you possibly can
at least the basics of how it work make
you a better programmer it makes you do
a better job of what you're working on
it's also kind of fun because you can
generate code that Java can't you can
generate little algorithms in byte code
that you would not be able to get
directly through regular Java byte code
for example you could have done a switch
that switches on strings as part of your
language or as part of a code generator
long before Java did it because they
didn't use any new byte code to do
strings as in a switch statements they
just used standard switches and some
additional tricks inside the code so
there's lots of fun stuff you can do to
military own languages or modify
existing languages generate code and you
may need to be able to read the byte
code someday there are cases where a
particular piece of code may be from a
different language than Java generates
bad code or code that has performance
problems like certain features in Scala
or Ruby that generate a much larger
amount of code or not as optimized as
well being able to understand what that
code is and at least recognize it as a
problem with it will let you know which
features maybe you should be questioning
okay
so we'll start with a simple hello world
here written in Java the first tool that
most people will end up reaching for is
Java P is anybody ever used Java P here
all right so Java pk
you to things if we run it with just the
basic no flags command line we get
something that looks like this basically
the general class structure in sort of a
pseudo Giada Java syntax so you can see
what the methods are what the signatures
are what file was compiled from little
basic details about the class if we pass
the - see flag we actually get the D
compiled or disassembled version of it
that shows the actual byte codes in
there we can see the default constructor
that we've created by Java C for us and
we can see our main that's doing the
hello world logic here and you can even
turn it up even more and go verbose and
then you can see all of the constants in
the file like method references and
strings constant integer variables
things like that and it goes on and
there's more to what the stack is what
the size is where the line numbers are
all the jump-off sets so you can get
basically all the information you need
about how the byte code works from this
tool another way to do this if you want
to be able to take that and then make
modifications to it from ASM there are a
couple different ways that you can do
this trace class visitor you feed a
class file through it or class bytes
through it and it dumps out essentially
the same sort of thing that Java P does
and actually there's some discussion of
trying to add line numbers and other
information to this as well
if you want to get code for the ASM
bytecode library that would generate
this file you can pass it through the
ASM fi air class visitor that actually
will take the bytecode in and turn it
into regular Java ASM calls which you
then can tweak and modify to generate
the same class file but using your own
code and of course this goes on and on -
and that's a
that's all there is to it right
everybody's ready to go generate
bytecode okay so we won't we won't just
dump that on you
disassembly tools and raw bytecode
generation will try something a little
bit easier that it's a little more
simpler to follow so I'm the examples
I'm using today since I'm a ruby guy and
I like dsls and all that nonsense I'm
using a little library I wrote called
byte script my script is essentially a
ruby DSL for generating JVM bytecode and
the beauty of it is that it kind of just
looks like Java pea output and you just
type it in like an assembly file run it
and it's actually generating bytecode
for you all right so here's our Java pea
output the basic output for the the D
disassembled code in it this is the byte
script version and again this is
actually just a regular executable
script it'll just run like normal code
but it gives you some of the niceties of
having an internal DSL you can do normal
language e things so we've got our get
static of the out field on system which
is a print stream we load our hello
world string we call print line with
this signature returns void takes any
object and then we return void from our
main method and this actually is just
executable and we'll create the class
file for you or run it if you just run
it as a script we can clean this up a
little bit we can import some of those
classes so we don't have to use the
fully declared versions of them we can
use a few shortcuts all of the primitive
types void object and string have basic
DSL smarts in there so you can just use
void or object rather than digging up
java.lang string java.lang object and
whatnot this is actually a much quicker
way to do it there's a way that you can
define little macros within byte script
so a print line is a macro that does all
of that logic loading the outfield
calling print line on it and it
basically looks like this macro a print
line and there's our get static we swap
it with whatever variables already on
the stack and then call print line on it
and you can build up pretty complicated
systems with this so now that we've got
a tool that lets us generate bytecode
kind of Reason about it play with it and
have fun with it
let's get into the basics of how
actually
so first of all the JVM is a stack
machine the operand stack is where you
push and pop values most of the time all
you're doing is pushing values doing
some computation popping stuff off
juggling values on this stack it's kind
of your your the meat and potatoes like
if you ever worked with x86 or you
understand how register based processors
are if this is your registers where you
do all of the work
everything goes in there and all
everything all the other instructions
work against that stack so you push and
pop stack values the stack is maintained
as it has a consistent depth part of the
verification process for JVM classes or
JVM bytecode is to make sure that the
stack is never it's a fixed length
you don't walk off the end of it you
don't have any overflows things like
that so it is explicitly sized so let's
see we've got our little hello world
will actually walk through how this
works we've got our JVM stack on the one
side all right so we start out with our
get static we get the print stream from
system the outfield and then that's
that's pushed onto the stack at the zero
depth we're going to load our hello
world string and that pushes everything
down again do our print print line call
and both of those values get popped off
the stack and the method invoked so here
of course if you wanted to keep that
print stream around you could have made
a copy of it could have duped that
reference in there and had another extra
one on the stack but each of these
instructions will either push some
things on the stack or pop some things
off possibly leave a value there since
this is a void call there's nothing left
to put on the stack after the calls done
so the target object that you call
against and the one value you pass to it
get popped and it executes and then
return void basically just says okay I'm
done with this method and I have no
values to return all right so the basic
operations of working with the JVM will
start out with a stack stuff like I say
this stack is where you're going to do
all of the work in bytecode so as you'd
expect this pops pop two is for popping
two elements to 32-bit with elements off
of the stack
duping various types some of these are
rather unusual swapping elements there
is no
swap to on here you might notice those
are things that you can build you can
compose out of the other elements byte
script actually does have some shortcuts
for pop or for swap to and other forms
of pops and whatnot pop and things like
that okay so a little bit of how abouts
house tack juggling is you know most
people have worked with a stack of some
kind but we'll walk through this real
quick so we have our two values on the
stack what they are doesn't really
matter in this case so if we do a dupe
we get a second copy of the first value
push down to the stack will pop that off
we don't need it
swap the two values again just swaps the
top two elements on the stack and if it
was swap two or the you know the missing
swap to instruction it would swap the
top two elements with the two below them
for example the dupes are a little bit
weird so doop x1 takes the top value and
puts it below the next one and there are
reasons for doing this if you're working
with wide variables Y elements or if you
just want to be able to move that top
value down below the other ones dupe 2x2
is another example it's a little little
unusual takes the top two elements and
pushes them down below the next one and
one of the reasons for this will be will
be clear in a moment but doop 2x2 is
actually 2 X 2 or doop X 2 is one of the
ways you can compose a swap to sort of
operation okay so now that we're out
we're dealing when we're done with the
stack you notice that none of those
really had any notion of type what type
of value is on the stack all they're
doing is popping and pushing elements
they don't really care if they're
integers primitives objects whatever now
we get into typed operations and what
you'll see is that they're all prefixed
with a letter that means what kind of
type they operate against byte short
char cetera and you'll see a as a means
a reference an object reference of some
kind so in that a print line a for that
particular macro meant that this
expected an object to be available on
the stack it's going to print an object
out and now you'll notice if you look at
these values there's no boolean so where
is boolean we still have that in the
Java level
well boolean is generally just an int 0
or 1 and it's encoded as such at the
bytecode level and in fact most of the
primitives actually are passed around as
in most of the time because across call
boundaries and within fields and objects
and whatnot they end up being usually
represented as a 32-bit with item or on
the stack or in the local variables so
most things get represented internally
boolean actually literally is an int so
if you want to encode boolean logic it's
going to be an int you can use ones and
zeros most of the time okay
there are also ways to push constant
values obviously you need a way to get a
null onto the stack if you're going to
do a null comparison a constant all will
do that for you
there's various loads I load for from
minus 1 m1 up to 5 for literals literal
one literal minus 1 through 5 for lungs
floats etc doubles there are some
narrower versions of the integer pushes
push-up bite onto the stack why would
you want to have these extra
instructions why would want to have
instructions that that do a push of 1
always can you think of any reason why
well when the first came up with a
bytecode one of the big concerns was
transmitting this to a remote user as
code and they wanted to try and pack
that code down as small as possible we
were talking about you know 2400 baud
modems back well maybe not that far back
but slow much slower than we have right
now and anything they could do to pack
that code tighter they did so there are
single byte instructions for loading 1 2
3 etc on the stack rather than requiring
a 2-byte instruction or a byte
instruction with a lot an int value
32-bit those sorts of things so most of
these are redundant and they you'll feel
like they're redundant but they are
they're kind of as a legacy thing
alright now I talked about that here
yeah so it's kind of pre optimization
the JVM also back then did not have a
JIT and so avoiding a lot of instruction
churn was important if you could say I'm
going to load a one rather than I'm
going to load an int what's the value
it's a 1 make that instruction a little
bit quicker if you can do multiple
things at once in a single instruction
the old interpreter would work better
obviously for the jits that we have now
and the current JVM it doesn't make a
whole lot of difference
all right pushing constant values so
we'll load a constant hello
string onto the stack will load a double
onto the stack so we're loading a double
one zero and you'll notice this actually
takes up two elements that's because
doubles are 64-bit and all of the local
variables and slow and stack elements
are 32-bit so whenever you push or pop a
double you make sure that you're pulling
off actually two elements and this is
another part of JVM bytecode
verification making sure that you're not
chopping doubles in half for example
there you go oh I should look ahead
shouldn't I okay so yeah so the 32-bit
wide you may see if you print out the
bytecode most of the bytecode libraries
will do this for you but you may see
that the bytecode that actually is
generated will have W prefix or wide
prefix on some of these instructions
because it knows that it's working with
a wide value a 64-bit value this also
brings an interesting point 64-bit field
updates are not guaranteed to be atomic
because they are two 32-bit
modifications of a field so it's
something to look for if you're doing
that usually atomic long is a much
better much safer value okay constant
values back to this so we push to null
simple enough push a four so this
becomes an int it takes up 32 bits on
the stack but it is just a byte
operation in the it's a smaller width
instruction in the bytecode and then in
bytes script we have LDC float LDC long
etc because since it's Ruby it's not not
statically typed but in most of the
statically typed byte code libraries
like ASM LDC you pass it a float it'll
push a float okay so now we know how to
work with our stack we know how to push
some constant values on there local
variable so the next thing you're going
to have to work with you can get away
with using just the stack for a lot of
things but it gets tricky since we've
only got dupe and pop and other
operations stack operations that go down
three four maybe five elements into that
stack if you need to go any deeper and
juggle things around you have to do some
creative magic so putting stuff in local
variables is a cheap way to avoid
abusing the stack or getting lost at
where you are in the stack and because
of the way the JVM
demises it really doesn't matter whether
your values are on the local variable
table or the stack they get optimized
pretty much the same way all right
so local variables are typed unlike
stack pushes stack moves so we have I
for integer long float double and
reference for loads and stores you'll
notice there's no byte no short no char
that's again because these are all going
to be 32-bit values in the local
variable table anyway so there's only
eye for anything that's 32-bit or
smaller there are some some packed
versions of these like floats store to
store this value that's on the stack the
store this float in the second local
variable in the table again packed
instructions fewer operations for the
old JVMs smaller code meaningless now
and then increment is actually a local
variable operation takes a particular
local variable and increments it by a
certain amount all right so a little bit
more complicated now so we load our
hello onto the stack we're going to push
a for value as well and now we're going
to store that in local variable 3 on the
Left we've got a double that's going to
be zero point zero the constant value
and now we store that one in the one
local variable and again like when
you're working with the stack it ends up
taking two slots so this is where
juggling doubles and Long's around in
byte code can sometimes get a little
tricky some of the libraries have ways
to help you but you need to make sure
you're not cutting local variables in
half either like if I was to do a store
load from local variable to the JVM can
statically verify that this is the
second half of a double in there and
will not allow that code to load because
it's not a valid value to load at this
point all right we'll store our hello
off load it back and then we'll actually
increment the variable at 3 the integer
value at 3 by 5 up to 9 and so this is
another interesting detail in in Java
our increment operator is only one up or
one down right increment or decrement
but the actual instruction can take any
integer value and increase it by that
amount again little features that exist
at the JVM bytecode level that
Java doesn't even use arrays are very
similar to working with local variables
you load and store particular type
elements out of them the only difference
is that you have to have that object
that array available on the stack before
you do your your guests or your sets
into it new array creates a new
primitive array and at the byte code
level you'll say new array of int or a
float or byte a new array is a new
reference array so any object reference
can go in there array length simple
enough the Ray on stack array length and
multi-multi a new array creates a
multi-dimensional array of some some lip
some complexity okay working with arrays
so first of all we'll load a two out of
the stack and we'll create a new integer
array and so at this point we've
basically got a zeroed out array of two
integers we'll dupe that and now like I
mentioned before when we saw the hello
world example if you want to keep
anything around you're going to need to
dupe it under the stack so you don't
lose it or store it in a local variable
somewhere either way this is going to
get popped off and once it's popped that
reference is gone forever
so you need to store it somewhere so
we'll dupe this because we're going to
be working with it a little bit we'll
load is zero we want to get the zero we
want to store into the zero element of
the array we'll load a minus one on to
the stack store that into the array and
now you'll notice it took our value our
index and the array reference and popped
all three of those off the stack to do
this operation so if we hadn't done that
dupe to begin with our array would be
gone at this point and we'd no longer
have a reference to it so we've got the
got the reference it was already on the
stack we can see it's been updated with
minus one and now we will just pull that
value back out again zero element I a
load and we've got our minus one on
stack simple enough all right math
operations I'm not going to go into any
deep example you can imagine how all
these are pretty simple they work pretty
easily
the only one here that is unary is
negation all the other ones will expect
two of those elements to be on the stack
two integers two longs two floats
whatever and they'll push that result
on the stack afterwards all right
boolean and bitwise operations again
nothing too complicated here these all
map pretty much straightforward to the
standard boolean and bitwise operations
you expect at the JVM level or at the
Java level and then conversions again
I'm not going to go too deep into this
but if you want to do a cast up or down
from an integer to a long or from along
to an integer
there are simple byte codes that do
these you have a long on the stack you
do the l 2i byte code and you get an
integer takes the two two 32-bit
elements of the 64 bit long and
truncates it down into an int okay
basic comparisons ll comp F comp L etc
these will take the two elements and
push a lose - one zero or one on the
stack depending on how they compare and
these are mostly working with the 64-bit
Long's and then floating-point values
alright flow flow control is a little
bit more interesting get back into some
actual actual fun walk through here so
the basic logic for flow control is that
you just inspect what's on the stack
make some decision about it and then
branch or there is a go-to operation at
the byte code level that will just do
have immediate branch to a piece of - at
a particular target at the byte code
level you mark points in the code with
labels most of the JVM live byte code
libraries have various simple ways of
doing labels you should be able to see
what we have with byte script here in a
second
lots of different ways that you can test
if EQ if any for doing simple 0 on the
stack or non 0 on the stack and these
are actually kind of confusing because
if you do a comparison and it's not true
it will push a 1 and you know this by
script actually defines an if true and
if false that reverse these because I
always get them mixed up less than
greater than etc whoops that was not
intentional less than greater than etc
then doing some integer comparisons and
branching if they're equal not equal etc
and like I said if there is a go-to
there are a bunch of other flow control
instructions
that I'm not going to go too deep into
today maybe not at all
jsr and wrench are actually the only two
bike codes to be deprecated at the JVM
level they were for doing finally blocks
it's a jump subroutine jump down to this
piece of code and then when you're done
return back up to the top and it turned
out that the flow of doing a subroutine
jump was actually really hard for JVMs
to optimize and so now old java c
compilers you'll see will emit the
finally block at every possible exit
point from the code something to keep in
mind if you put a lot of logic in the
finally block it's going to increase by
that many possible exits from the from
the given method table switch and lookup
switch for different types of doing
different types of switches the table
switch if you have a very short
contiguous array of values it can just
do branches based on a table a jump
table that's there so it'll be a simple
oval one operation real quick to do that
jump the lookup switch is more of like a
hash lookup it does a hashing based on
the incoming value and then has a table
that it goes to to find the the proper
jump location a little bit slower but
you can have wide ranging values they
don't have to be contiguous so and so
when you're lost it and then of course
returns are part of flow control and
this method and there they have the the
five basic types integer long float
double + r/n reference return is just a
void return it's called void return in
bytes script because return is a keyword
and Ruby if null and if not null again
just branches based on null or not and
all being on the stack all right a quick
example of how this all fits together so
we'll a load 0 and in this case this is
in our main method so this 0 local
variable is the argument array so we'll
load that under the stack and whatever
we passed in we passed into string
branch for that alright we'll load a 0
so we want to get the 0 element out of
this array we'll get that we've got our
string now we'll load a constant we'll
see if they passed in branch we can
actually do a comparison here so we load
the branch it's constant string onto the
stack now we're doing an invoke virtual
I'll talk a little bit about the invokes
later but
we're convulse method on string that
returns a boolean and takes any other
object standard equals right so we do
that the result is a one that's on the
stack okay they are equal so we need to
check if not equal right it's confusing
because if not equal is going to look
for a zero to be on the stack and then
do the branch which is what we will
actually want we want to branch the
other direction so we do this branch
down to here and now we're in our equal
branch we've actually determined they
are the same and will continue and
actually I'll rephrase this a little bit
cuz confusing if not equal looks for non
zero on the stack which is a little
confusing because it's a true value and
not equal is a false in my head but this
is why if I was to write this in my in
my byte script stuff it would probably
be if true which makes a lot more sense
than if not equal but this is how it is
in the JVM bytecode something to keep
track of ok so we have our we load our
equal out of the stack once we've gotten
to the branch point and then we'll print
it out and be done ok so now a little
note about classes and types before we
go into how they actually function at
bytecode level the trickiest part is
probably gonna be working with
signatures you might have seen in the
java p output there's kind of an encoded
version of every single type that's
referenced within the code most of the
libraries have ways to work around this
or ways to generate those signatures for
you in byte script you just kind of put
put the types in an array and we figure
all that out in ASM you can get a type
instance or a method object that
represents a signature but it's
something to keep and keep them keep
track of and if you look at the Java
peep out put it's not too difficult to
read ok
so using classes getting in setting
static fields and instance fields for
instructions for those there were
traditionally for invokes for a virtual
invocation which is a normal object
invocation interface invocation special
invocation which is for constructor
calls and super calls that can only be
done
from within certain contexts under
certain conditions special conditions in
a VOC static for invoking a static
method which is essentially just a
function call and VOC dynamic is new of
course in Java seven depending on time
we can talk a little bit about how that
looks at bytecode level invokedynamic
basically says here's some objects
here's a method name and a signature and
ask me when you make this call and I'll
give you the right piece of code so
let's you kind of wire in anything you
want at that point with a call back from
the JVM and I'll show example that a
little bit later that kind of clears it
up new is for creating a new instance of
an object you give new and the type
check cast does a casting operation and
raises an error if it doesn't fit
instance of will just push non zero if
the object on the stack is of the
specified type alright quick walk
through this here so new ArrayList we
create a new ArrayList and we
immediately dupe it and notice over on
the on the right hand side here it says
that we have an ArrayList on the stack
twice that's uninitialized if you were
to go ahead and start using this object
the JVM knows that you have never called
the constructor on it you could need to
create the object and do the constructor
call that's kind of the immutable pair
of operations that you have to do with
the JVM bytecode level so that'll be an
invoke special on ArrayList we call the
bracket a knit method you might have
seen in byte code output now we have a
fully initialized ArrayList that will go
up the constructor chain do all the
backend stuff that it needs to do the
JVM is now happy with letting us use
this object so we'll do a check cast
cast this to collection and now what we
have on the stack is a collection and
part of the JVM verification actually
tracks all these different types on the
stack in local variables and make sure
that you're working with the object that
you expect to be working with if we were
to start calling methods that are only
on array lists at this point it would
not not load properly or it would try
and call methods that just don't exist
all right so we'll dupe that because
we're going to use it we're going to
load a first element string onto the
stack and we're going to add that to the
collection and this is an invoking
device interface operation you cannot
use invoke virtual on
your face types so if it's an interface
type that you have on the stack you need
to know that you're doing you need to do
an Evoque virtual if it's an ArrayList
on the stack the JVM does know that it
can be either an ArrayList or treated as
a collection so you can use either and
invoke virtual on a ray list or invoke
interface on collection and it will both
work alright so we did that we got our
boolean value saying that we added it
back we added it in just fine we'll pop
that we don't need it we'll cast it back
to an ArrayList load zero because with a
zero element out and here we have our
invoke virtual of an ArrayList now get a
particular value and put it back on a
stack once we've got it we print it and
we're done
okay so doing pretty good on time
invokedynamic is a bit more complicated
the basic invoke instructions have a
very specific way they work they look
for static methods they look for virtual
methods interface methods and then just
call them that has been great for Java
and for other statically typed languages
for dynamic languages that's been a
little limiting and so really what we
have with invoke dynamic is a new way of
telling the JVM how to do a call it has
two parts the call site where you
actually make the call from in the code
and then a bunch of VM operations in the
backend that we actually can wire into
and what this kind of translates into as
far as this talk goes we've got the
bytecode the invokedynamic bytecode that
looks pretty much like an invoke virtual
at the bytecode level and a bootstrap
method a method that we can that the JVM
will call to get a piece of code on a
handle to that target method rather than
finding it itself we give it the right
piece of code so like I say the bytecode
is invokedynamic pretty much structured
like the other invokes it has a
signature and a name
the magic though happens with the
additional part which says here is that
here's my code to call my function to
call to get the target method that you
need rather than the JVM just going and
getting it it asks us for it and so we
can do anything at that point
that's how dynamic language is actually
able to leverage this the bootstrap
method is just a usually just a piece of
Java code it'll look at what the type is
that are coming in the signature that's
expected the name of the method probably
you know what parameters were passing
and make a decision about how to route
that call so rather than having it done
statically we can do it dynamically at
runtime and method handles if you
haven't heard much about them or played
with them yet the basically like
function pointers and then plus plus
there's a bunch of other stuff that you
can do around them so you can actually
give the JVM a reference to any function
any method in the system as part of
invoke dynamic and it will wire it right
into the the actual call site optimized
like it's regular Java code a little
walkthrough of how this actually works
more visual so up at the top on our
switchboard here we have the
invokedynamic bytecode somebody's making
an involved I am O'Call at the bytecode
level the JVM will call our bootstrap
method because it doesn't know where
this invokedynamic supposed to go it's
all dynamically figured out at runtime
our bootstrap method then provides the
JVM with a method handle this is the
function you want to call at this point
in the code I've done my calculation
figure to what I figured out where it's
supposed to go
that method handle then is just a
pointer to some target methods some
piece of code somewhere in the system
and the magic here comes at this point
the JVM actually can whoa route directly
from that bytecode to whatever piece of
code we handed it
whatever method handle we gave it and
all of the rest of that logic can just
disappear from then on and that's why
it's able to optimize basically like any
other invoke instruction any Java static
call without actually being statically
typed all right so few more things I'm
not going to go into there are the
exceptions in synchronization have
various complicated vagaries that are a
little bit tricky to show in a couple
slides try catch you provide a table
that says from this line to this line if
this exception is thrown branch here and
then you nest those and you build up
multiple tables of tried caches and for
a finally for example you just try to
catch everything and branch down or
embed it directly into all of the exit
points of the code like I said and you
would have to do that manually in most
libraries monitor enter and monitor exit
acquires or releases a synchronization
on a particular object and the monitor
exit must is verified
to happen before you exit the method
body and within a finally so it will
make sure that you are properly
releasing synchronization on an object
before it will even load that code and
it can be a little little goofy
sometimes to get it right a few more
examples here will run through so this
is in byte script just basically a
simple loop we've got our main method we
load 0 onto the stack or we load this
the 0 value 0 local variable which is
just the array of arguments again we'll
push a push a 0 onto the stack another
way of doing it in byte script load that
value will dupe it print it out and then
loop forever so we've got our go-to in
there that's going to continually dupe
that value on the stack and print it out
very simple loop loops forever here is
Fibonacci a little bit hard to read
perhaps in the back it's it looks almost
exactly like what you would have at the
bytecode level if you wrote it in Java
uh I think almost everything in there is
almost identical to what you would have
in Java pea output but this is just
executable Ruby code essentially oops
now the fun half of this is actually the
main method that runs our little
Fibonacci so yeah we have our main and
then we have all these other
instructions that look like they're they
don't exist at the JVM level load times
a print line is in their start timing
etc and these are all again just little
macros that have been defined in byte
script they could be call-outs to
methods but it's kind of nice to have
them as little macros load the number of
times basically pulls an integer out of
the arguments that's coming in an
integer string parses it and leaves with
an int on the stack start timing loads
the current time from current time
milliseconds just like this in timing
loads that time again subtracts it from
the original one and we've got our
actual time on the stack L print lines
another one it's not built into byte
script but it's easy to write same thing
as before with a print line except that
we're doing the long version of print
line when we do the call all right so
that's that's all byte script and
like I said most languages have some
sort of dsl for doing ASM we'll get into
a couple of those in a sec here okay so
one way like I said the ASM afire the
visitor that you can do will give you
code like this it's not the prettiest
thing in the world and you know talk
about not being dry there's about thirty
instances of the word visit on the same
same piece of code but this is the raw
ASM API that you would use to generate
code and you can see I load a load
they're all basically constants in the
API and you can use any one of them a
nicer Java API that I've been working on
with some other people is called Jade
script which is essentially kind of
building a DSL idea off a byte script
it's very similar to what the Java pea
output looks like but it's a normal Java
library it doesn't have any Ruby
dependency so here is perhaps a little
too small the Jade script version of
this define a method main that's public
and static returns void it takes a
string array as its arguments LDC hello
world gets static out again this is all
just plain Java code but as a DSL it
looks a lot nicer and it's a little
easier to work with now at the bottom is
a different version the more fluent API
where you essentially have a builder
that you crank code into LD see a return
and so on and then you know loading it
is just basically given a class loader
and you've got the bytes
you've got the class in hand groobie has
actually a bytecode annotation that you
can annotate a particular method body
with this bytecode annotation and then
you get a DSL within the body that is
essentially like Jade script and here is
actually the defib again looks almost
identical to the byte script version
looks very much like the Java peak
output but this is an internal DSL you
can do groovy stuff in here and
essentially generate bytecode with a
much simpler API Scala it has another a
builder as well I'm not sure if this is
the standard one that people who are
playing with bytecode and Scala use but
it's the one that I found cafe babe so
everybody know where that comes from
right yeah maybe well I'll show you
later if you don't know
so here again create a method LD see a
return very simple a little bit cleaner
than using the raw ASM API directly and
I'm actually going to skip over this
because it's complicated okay yeah I
could show you later if we got more time
or if you want to see the slides offline
so what are the real-world cases for
doing by cogeneration like I mentioned
it's good to know how your system works
and what's happening beneath the the
language you're writing in but there are
a lot of good actual practical uses for
this for example if you're doing a lot
of reflective invocation you've got a
very meta framework you probably be
better off generating some code at some
point rather than constantly using all
of the reflective method calls they have
their own overheads internally they have
requirements of passing all arguments as
an array which very rarely through the
reflection API can be optimized away and
they do a lot of checks over and over
and over again making sure you've got
all the right types making sure they're
in the right order making sure the
target method actually exists on
whatever object you're calling so
avoiding all that in a framework that
uses a lot of refraction reflection is a
perfect case for generating bytecode
what you would do as a reflective call
generate a little stub class generate a
little utility class and it'll do that
call for you and you can
programmatically build all that stuff up
by coded data objects again in in
frameworks like hibernate where you want
to be able to just have a normal-looking
POJO normal looking Java object that
somehow magically gets all of this
persistent behavior behind the scenes
well that's usually done by generating
some bytecode when you first load that
code up or potentially offline into a as
part of a build step so if you want to
be able to generate additional logic on
top of existing classes without actually
modifying that code maybe you can't
modify that code you can use bytecode
extend it build your own stuff on top of
it or modify that class directly using
some of the ASM visitor transformation
api's as well
and then of course language compilers if
you're interested in writing a language
even if it's just a simple expression
language that you might want to use for
something internally generating it to
bytecode will guarantee that you get the
best possible performance out of it
you're giving the JVM the best chance to
optimize your code like I said this
tools
byte script is a lot of fun to play with
Jade script is actually probably more
practical for general Java use and we're
actually using it with in JRuby in a
couple places
there's a couple other language of
limitations that are using it now of
course all the stuff is built off of ASM
which has kind of become the standard de
facto perfect
whatever library for doing by
cogeneration and if anybody is you all
heard about Nazz horn and the new
JavaScript limitation whatnot Nazrin
actually uses ASM too and so ASM is very
likely to get pulled into at least open
JDK and maybe at some point in the
future exposed as a standard bytecode
api so it kind of just is the one that's
winning at this point okay
I want to have room for questions so
like I say this is fun kind of the first
part of a two-part talk part two
tracking the bytecode it as it goes
through the JVM how it optimizes it
monitoring that whole process when it
compiles code when it in lines code when
it doesn't in line code and optimize
things and then actually what the native
code looks like and tracing it all the
way from the bytecode down to the native
level what to look for how to get the
best performance out of a piece of code
I had this up before so yes tomorrow is
the part two of this and I think we'll
leave the rest of the time open for
questions so any questions about this
yeah here
yeah actually so the question was would
this be a good approach for filtering
out assertions from byte code as you
probably we'll know as Java developers
the assertions don't get executed unless
you have them turned on but they are
still in the byte code yeah very very
much so you could pass this through an
ASM transform or visitor thing and
basically just ignore those and re-emit
everything else because the asserts just
going to operate on its own line it has
no other state that goes with it so you
could filter all of those completely out
of the code as it's loaded actually it
might for some arcane reasons a hotspot
the open JDK JVM has certain limits on
the size of code that it will optimize
or inline in particular cases and
anything you can do to get the method
size down will help assertions do I
believe still count in the bytecode
count that's something I need to check
but I'm pretty sure that they do count
against you they do so there's there's
one of the the key JVM folks John right
there so yes they do count against you
and having a tool that could strip out
assertions when you know you don't need
them anymore
could actually help you in some cases
like I say arcane reasons but it is
there other questions yes
Oh
or
right so right now I think Jai script is
just expecting that an ASM version is
going to be available it doesn't vendor
it in anyway like like a lot of
libraries do but my hope it's based on
ASM for and in ASM for they did do some
work to hopefully make it more future
compatible making some things be
abstract classes having there be little
factories built into some of these
things that they can plug in for future
versions and keep the API is the same so
hopefully as things go forward with ASM
we're going to have fewer cases where a
new versions break the sm4 was a big
break because there were a lot of
changes that were needed to support and
book dynamic the right way to support
some of the newer features coming up so
it's it was bad in the past but I think
it's not going to break as often now
okay anything else yeah ah yeah yeah for
for concurrency so so are there op codes
for compare and set various atomic
operations there are not and it actually
would be it's an actually ancient
interesting question because since these
operations are becoming so key to doing
concurrency properly on the JVM you
would think there'd be something JVM
level and in fact this this kind of
plays into the talk tomorrow
there are sprinkled throughout the JVM
something called intrinsic s-- the
compare-and-swap operations are an
intrinsic the JVM just knows about and
so rather than doing that call it sort
of is like an instruction and actually
John has been fond of telling us that
whenever we want a new instruction just
stick it in a static method and call it
because the JVM is almost always going
to inline that static piece of code
depending on size and other metrics so
it's really not necessary for us to have
an operation at the bytecode level for
every possible thing we need to do on
the JVM we can compose it out of other
operations or some of the built-in
intrinsics like for compare-and-swap
and not have to actually bloat up the
bytecode that much we don't need to be
like parrot which I think had like
20,000 op codes or something yes
why was yes so why was invoked dynamic
not in intrinsic okay well-well-well
will allow the the jvm guys to to answer
that one
any other questions yeah sure they
essentially are they essentially are and
actually if you look at the the native
code that comes out of it it actually
will be there'll be assigned to
registers in the output that you get
from the assembler and since tach moves
will often be represented as registers
to or just optimized away but yeah they
essentially are registers at that point
so the stack is kind of your your you
know moving stuff around putting things
in it's kind of like your key registers
like your ax and your BX that's where
you put stuff to actually operate on it
and then the local variables are like
memory locations or all the other
utility registers that you have all
right anything else okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>