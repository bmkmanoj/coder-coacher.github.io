<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JVM Diagnostics - Using Java Workload Explorer using Oracle Enterprise Manager | Coder Coacher - Coaching Coders</title><meta content="JVM Diagnostics - Using Java Workload Explorer using Oracle Enterprise Manager - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JVM Diagnostics - Using Java Workload Explorer using Oracle Enterprise Manager</b></h2><h5 class="post__date">2015-12-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/77L3hcjMRlg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Java workload Explorer is a JVM
diagnostics feature introduced in Oracle
Enterprise Manager 13 it enables you to
investigate causes for slowness in your
Java applications Java workload Explorer
presents a time and resource model time
by resource and resource utilization
with Java workload Explorer you can view
summarized metrics for the entire JVM or
even across multiple JVM
you can filter the data to see metrics
for a specific combination of entities
here I'll investigate a request
performance problem that was reported
recently it's part of an application
that retrieves data from a remote server
and caches it using coherence for quick
retrieval since I'm looking to solve a
problem in a specific request I'll look
at only the data associated with that
request to do this I filter out
activities of other requests
the thread state chart reveals that
there was a change in the work that this
request creates on the JVM many threads
have been sampled while waiting for i/o
in the last 10 minutes or so to identify
the cause of this change compare the
current data with the earlier time
period where the i/o weight was lower to
compare time periods first create a
dataset
use the newly created data set as the
baseline for comparison with the current
data
view the top methods to see which ones
have a different behavior now look for
methods that cause a lot of io relative
to the baseline the top method send get
is one that was sampled many times as
waiting for IO in the current period but
wasn't sampled at all during the
baseline period looking at the call tree
for this method shows that it executes
an HTTP call probably to an external
server something that can be quite slow
remember this application retrieves data
from a remote server using HTTP and
caches it using coherence it looks like
what we're seeing here is data retrieval
from the remote server now go back to
the request level and look at the
request call tree comparison
you
the application retrieves data using
HTTP possibly using a rest service and
in the baseline it retrieves the data
from the coherence cache this explains
the performance differences that started
a few minutes ago
it's likely that the application can't
find the required data in the cache you
can use coherence management for further
investigation thank you for watching
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>