<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Getting Started with the NetBeans Platform | Coder Coacher - Coaching Coders</title><meta content="Getting Started with the NetBeans Platform - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Getting Started with the NetBeans Platform</b></h2><h5 class="post__date">2013-03-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YZGJN1feN9M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I am hi my name is herion I'm a member
of the NetBeans team and you may be in
the wrong session because this isn't
about anything other than power agent
which is a which is a which is an
application that you get when you buy a
exercise bicycle from a company called
cycleops so you get your exercise
bicycle from cycleops
and you get some software you install
that software and then you connect to
your laptop from your exercise bicycle
and as you do your exercises you can
track what you're doing and you can see
what's been happening and you can
evaluate your results over periods of
time now of course this application
happens to be created on top of the main
subject for today but I'm showing you
this because very often people say that
that desktop applications are basically
used in house in the back office
somewhere and in fact they're not
there's a lot of applications out there
that you can download straight off a
website for example if you go to
docudesk.com you'll get a PDF reader a
PDF editor and PDF related functionality
that you can download and buy from them
that is also based on that B's platform
so there are there are multiple
scenarios where Java desktop
applications are just pure end-user
software but beyond that the dark the
the Java desktop or the desktop at all
is quite broad so on the NetBeans
platform home page you'll find a list of
hundreds of applications in places where
you might imagine them to be for example
air traffic control defense related
applications banks oil and gas services
kind of scenarios where there has to be
heavy processing of some kind where
there's to be offline usage because
there isn't a network or the network is
unstable or
liable where security is a large concern
such as in banking environments in
practically every software development
environment imaginable you will find
that there are desktop solutions and
without any plan for those desktop
solutions to ever be migrated to the web
it's not that these these pieces of
software are there temporarily and kind
of hoping to one day be web applications
this is where they are because I don't
see a traffic control happening in the
browser nor in a mobile phone so this
this domain is extremely large
but underrepresented in in conferences
and the like and in this session I want
to introduce you to a simplified but at
the same time very strong way of a very
stable way in which you can create these
applications so on NetBeans dot org
there is a tab NetBeans platform you get
to the to platform NetBeans storag which
is the home page where you will find all
the documentation a list of what the
features are the showcase I just refer
to if you go to the documentation page
that there are literally hundreds of
tutorials and there are books and
there's there's a lot of support for
this approach that I'm going to talk
about
and since throughout the conference
there have been some sessions on this
topic already focused on an introductory
slide based material and as well as
demos and showcases I thought in this
particular one it would be nice to to
just code for an hour and see how far we
can get and see what the result is and
so you can actually see the workflow of
working with the NetBeans platform and
it makes a big difference seeing
something for real rather than I'm
talking about it theoretically so I'm
just going to create an application it
will be a application on the Java
desktop it will have a number of
advantages and that you see
automatically on name some up front so
we're going to be correcting a modular
application right now the how jigsaw
project is
years away from being completed there is
the NetBeans module system there is the
OSGi module system either of those can
be used in the context of a NetBeans
platform application which module system
having a number of advantages that that
we can also refer to you'll see a window
system you'll see a menu bar toolbar you
see many basically anything that that
any application would normally have a
better standard to any application
should be provided out-of-the-box by a
framework in this space but before I
begin I'm pretty curious about who you
are so anyone who has ever created or
begun curating a NetBeans platform
application who has basically been at
this point right before creating the
first application would you raise your
hand okay a couple of people so I take
it that for the majority you've never
actually seen the nipping platform in
action before is that true
if yes okay excellent you're in the
right place after all so I'm going to
create an application and I imagine the
scenario to be similar to this power
agent so there is some kind of external
device that is plugged in in some way
and we want to read information from
there be it an exercise bicycle or a
testing object or some kind of robots or
whatever we want to control that from
from an application so I'm going to
create this application and I've just
called a device manager device manager
and I'll click finish so what I now have
even though it looks like I have very
little is a the starting point of an
application and this application reuses
modules that are part of the NetBeans
IDE in which I'm creating this
application so I can see this I could
see that the NetBeans platform of this
application is the NetBeans IDE that I
am using to curate it normally what you
would have at the very start of your
development work you would download
NetBeans platform so that is a
distribution of nicknames IDE without
the IDE
and that distribution would be a zip
file containing a bunch of jars that
constitute the NetBeans platform so a
very small subset of what NetBeans IDE
is you will check that into your own
repository and then you would register
that download that zip file into
NetBeans IDE and then when you create
your new application you would set that
platform that you have downloaded as the
basis of the application you're going to
create that is the assuming that you're
starting from scratch it's possible that
you want to create your own application
on top of an of another existing
application so for example there's a
farm management system that's been
referred to a couple of times in the
conference and that one at Jiggs Choice
Award there's a NATO defense application
you could register those applications
inside NetBeans IDE and then when you
correct your own application point to
that application that already exists and
have that as the basis and then build
your application on top of that so the
neck means platform is is modular and
any application that exists on the
NetBeans platform is potentially the
starting point for your own application
in this case we have Nipponese ide which
is what i'm using to create this
application but within that one there's
one check box in this long list of
possible clusters of modules that I can
use there's one check box and have asset
on the platform and you can see here
that there are a number of check boxes
and each check box is next to a jar file
these are jar files from NetBeans IDE
but underneath NetBeans IDE in the
NetBeans platform so for example what we
have is a window system so there's a jar
in the NetBeans platform this provides a
window system so we don't need to create
a docking a docking framework there's
also a jar that provides an action
system and so in the action system we
will in the actions jar you will find a
menu bar in the tool bar you'll also see
that we're going to have the possibility
to install plugins into our application
because I've selected those additional
jars
there's a dialogues API so we have
access to standardized dialogues we
won't have to create our own dialogues
but reuse existing ones let's see what
else do we have here we have the
mechanism for communicating between
modules could look up so there's a whole
bunch of standardized functionality that
we already have available so I'm just
going to run this application right now
and it starts up and you can see the
progress down here right now when I'm
creating as an ant base NetBeans
platform application I could be creating
a maven based and it means platform
application and there are maven
archetypes for this so you could just go
to the command line type the maven
command for the archetypes get your
archetypes open them into any IDE you
like so the point is that there is no
necessary connection between the
NetBeans platform and the NetBeans IDE
except that you could say NetBeans IDE
as the reference implementation of the
NetBeans platform and if you use
NetBeans IDE to create your NetBeans
platform based applications you will
find yourself looking at NetBeans IDE in
a different way you'll be thinking hey
that's interesting this is drop-down
button here so there's a button in the
toolbar of NetBeans IDE which I can
click on and then many items appear
where is that in standard jarvan nowhere
it's somewhere in NetBeans IDE so then
you can look in the source code of
NetBeans IDE and find that source code
or hopefully you find an API that
NetBeans IDE exposes so that you can
have those drop-down buttons so then you
begin looking at NetBeans IDE
as a container providing examples of
things that you could be doing in your
own application but the application is
started up I'll make it a bit smaller
and I'll close it and I'll run it again
and what you should notice is that the
application starts up in the same
location and in the same size as where I
left it open properties window an output
window so these are the predefined
windows that the that the NetBeans
platform provides and there are API is
for these windows so I can plug it into
the output window I can write instead of
writing just a two standard out I can
write to the out of
output window I can display properties
in the properties window
there's an exit menu item there is an
about box I can customize this remove
the splash screen that is shown here
there's an options window so as you can
see we can almost settle this
application already to our customers
it's almost there it's not far
not really right but at least the basis
the basis is there the basis for any
software now we're talking software
we're not talking Web Apps I'm not
talking mobile not talking tablets we're
talking software on the desktop so all
the basics are there ok indeed the point
should be made that if you're creating
some kind of trivial small or even
medium-sized
application this potentially is not the
way that you would go this is really a
system for for large larger applications
because yes there are a number of jars
that are included but because it is a
modular system you can choose which jars
you want to include and the the minimum
jars that you include are only six jars
and they're quite small and none of
those six jars that are mandatory
contain GUI components so that provides
a lot of interesting possibilities
because then you could create
potentially which I mean it would be a
lot of work you could create a Java FX
based as opposed to swing based a
framework on top of that container or a
scholar based and there are open source
projects around that even server-side
things I have a command-line tool very
useful where I can type something on the
command line phrase from Shakespeare
press ENTER and then a web service
returns where that comes from and the
speaker and the play and whatever and I
can add additional modules onto the
classpath and then search in other
places as well and because it's a
modular system yes yes we can we can do
it immediately yes so here is the
NetBeans platform so this is each of
those clusters you saw actually folders
on disk so here
platform and here are the modules and
the the core so is the is one of them is
called core and another one is let's see
well here's this one here yeah well just
that core one this core and this file
system well for this view on things and
you could remove everything and be left
with a bootstrap because one core is
another not the other cores just that
particular core startup is in this list
the file system which means every single
neat news platform application has as a
file system in the same way as a
computer as a file system so when you
install modules into the NetBeans
platform application you're you putting
new folders and files into this virtual
file system and in that way other parts
of the application can find information
for example the menu bar looks for a
fixed folder in the file system so
there's a folder called menu and all the
action listeners from from plain Java
that you have registered in that menu
folder are automatically loaded into the
menu bar at start above the application
and all the action listeners you've
registered into the toolbars folder
automatically loaded into the toolbar so
anyway this five or six small jars that
are the the core and you could create
server based applications this is not
necessarily a client solution but most
typically it is a client solution
because normally when people see that
without any coding they can undock
windows and move them on to other
screens and that is mainly what they
want to do so if you're creating air
traffic control or stock trading type
applications this is what you need you
need a GUI that is much more flexible
out-of-the-box then playing swingley to
be or playing JavaFX let you be
only Eclipse which one platform and on
there are competing products on on
individual parts for example you could
look at other window systems but as in
terms of the entire application
framework you only have the Eclipse our
CPI makings platform in terms of all the
things that it provides and there the
code difference is swt vs swing and
there are details in some cases this is
better in other cases this is better but
when it comes right down to it and
eclipses RCP is tied to a stability one
nettings platform is is two swing which
lets you integrate java sx much more
easily than it does in SWT ok so let's
actually create more of this application
and so we have this device manager as a
starting point and what we want to
create is a manager for devices so we'll
create a first module I'll call this
device domain and this is the nice thing
also about the modular system and so we
say org device domain because we imagine
we have a website device org and that's
basically the unique name for our for
our module which also turns out to be
the main package of the module and the
nice thing about a modular system is
that it lets you organize your code into
logical places and we now have one
module inside of which all of our domain
classes will be found we'll have another
module that will provide a specific
feature so each module in the
application will provide a different
feature to the end user which will then
enable us to distribute the parts of the
application that are relevant for
specific users so in the case of Nick
means IDE we have a PHP distribution
which contains just the modules that are
part of the PHP story and a Java
distribution a groovy distribution and
that kind of approach you can take for
your own software so you're creating
form management software some of the
users are our farmers others are
managers others are they're all doing
different things but don't want this
massive application there was a small
application providing just the features
that they need and that is one of the
features that a module system gives you
yes absolutely so I create as a starting
point a new class and I call it device
okay so device I'll try and make this a
bit bigger has a string type and maybe
int ID we create some getters and
setters for this and we create a
constructor okay that's enough for the
moment we have our device object ready
and this is another nice thing about the
NetBeans platform and modular
development you can start off with your
domain objects and build your entire
application around that exactly as I'm
doing it now so we have our device
object inside a specific module we'll
create a first new module that will
provide a a Explorer window where a long
list of devices will be shown that are
connected into our port so we'll have a
window over here that lists all our
devices whatever they are and when
double clicked on them another one they
will open sharing some kind of graph or
a chart or something about the current
device so I create a new module code
device viewer and this also shows that
because often when someone is introduced
to the fact that ok now you're working
in a modular system I think oh no so now
I have to use as how module thing that
the point is that the module thing is
really helpful it's it's it's useful in
what you're doing it's not something
that you have to adopt because you're
you're going down this road and also if
you if you want to you could have one
single module where you put all of your
code that's completely possible but not
not really making best use of the
features available so org dot device dot
viewer so here it is so now we have two
modules plus all the modules we already
had from the NetBeans platform and let's
inside this new module create a window
that will be displayed on the left-hand
side
so I went not just like this one in fact
in NetBeans IDE so again you can by
looking at NetBeans IDE and all the
other applications you can really learn
a lot about the kinds of things that you
might want to do in your own
applications see how others have done it
and many of these applications are open
source so you can download the sources
and there's a mailing list and everyone
in the world working on these
applications is on the mailing list
somewhere so there's a lot of support
and hope that you get all for free so
right-click on the package and there are
a number of templates here which is the
reason why NetBeans IDE is really useful
for doing this kind of work especially
when you get risk get started with it
but once you've created your basic
artifacts a new window new mania ads and
these things you could open your
application into any other IDE if you
are using maven because with a maven
based application you have a pump fire
when it clips and IntelliJ and all the
IDS understand what to do with that pump
file so I all say I want a new window
but I could create a new action which
can be displayed in a menu bar on the
toolbar a new wizard so step multiple
dialogues with predefined buttons we can
extend the options window we can create
a Java help set there was a question in
a previous session there's a template
that you'll use later on to do create
Java help sets you can change how
windows are laid out there's a lot of
predefined support so in a way NetBeans
IDE is the SDK for the NetBeans platform
even though it isn't mandatory to use to
use that so we'll choose a position so
you should imagine the application frame
as having a number of fixed positions
the vertical on the left is called
Explorer position the horizontal along
the bottom is the output position so
they're all fixed positions and within
the application frame and you can put
you can register windows into the file
system into the folders that relate to
those particular positions so in the
same way as when the application starts
up the menu bar looks in the menu folder
and the tool bar looks in the tool in
the toolbar folder the window system
looks in the window fold and finds all
the windows they're registered in
folders that relate to the areas where
they should be displayed so we say
explore a position and it should
open when the application starts and we
say this is code device viewer click
finish and what is now curated is
something that is very similar to a J
panel but it's a different class it is a
top component and it has a number of
annotations at the top which is because
we are moving more and more towards
annotation based registration ultimately
the file system a module contributes to
the file system
by providing an XML file so each module
can have one of these that registers the
GUI features such as the windows such as
the menu items into the virtual file
system now you could have fun typing
those things in XML by hand but first of
all it's not fun especially if you're a
Java developer you would prefer to do
everything in Java so therefore we have
annotations which when the module is
compiled result in those XML entries
being generated by the annotation
processor from those annotations that we
have defined at the top of the class so
we see here for example because of the
entries we filled out we have a mode
attribute for this top component
registration annotation set to Explorer
which means this top component will be
registered inside the file system in a
folder within the windows folder and
that folder will be called Explorer when
the windows system looks inside the
windows folder it will find this window
and displayed and the Explorer position
it will open at startup and
automatically a menu item will be
created for it because more than likely
if you have a window you want to let the
user open it once they've closed it so
automatically a menu item is created for
opening that window there is also a nice
feature that relates to these
annotations which is these messages so
normally you will have or what can
happen is that you have texts and
display text and whatever inside your
java classes somewhere which isn't very
nice for translation purposes for
localization so then your next step is
okay I'll put all of my display text
into a properties file which is separate
for my Java classes but then the problem
is you have a properties file with a
long list of string
and you don't know what classes they
relate to anymore so the solution here
is that the NetBeans platform gives you
a messages annotation which lets you
create keys and values and at compile
time this is turned into our properties
file so I can see in here where the
strings belong to because they're within
the class where I've created them so
they are not inside a long list of
property of keys and values in a
property cell that I have corrected but
they'll be created automatically at
compile time so there's a lot of support
via annotations and we really like the
annotation based approach because we
really like Java so this is this is a
train that's going to continue a lot
each new release of NetBeans comes with
new annotations then you will get an
error yes there's a check that's done so
if another class already has this key
and I type this key in here then there
will be an error mark and I won't be
able to compile this or compilation will
fail of this class if you want to add
another language you correct another
properties file where that translation
will be done yes then you have to go to
the properties file this is for your
base language exactly ok so here we are
Splatt that version from correcting the
window but interesting nonetheless
I hope application starts up again we
see now we have another window and this
window automatically behaves in the same
way as all the other windows we can
undock it and move it out and we can
dock it again and a new feature that's
come in recently is if we had multiple
different windows here
we could float the whole group of
windows which is something that air
traffic control companies and stock
trading organizations have asked for
that they want to be able to undock
multiple windows that relate to each
other at the same time so it might seem
like a small feature but it's it's been
a blocker for many organizations and the
reason why it's been implemented now is
because JDeveloper had that feature so
JDeveloper has his feature and now J
developers on the NetBeans platform the
J developer team said ok we agree with
moving our framework to the NetBeans
platform if the features that we had
before are going to be supported
once you've actually moved there so we
had to make a bunch of changes to the
NetBeans window system to support
JDeveloper being ported to the NetBeans
platform some that's already done the
current release of JDeveloper that you
download when you you I have a new
folder called NetBeans when you start
subjective ellebra you'll see NetBeans
messages in the output window or in the
ins in system out you'll see properties
that are nothing specific in future
releases so you will not see anything in
the GUI yet but in future releases you
see the NetBeans window system and
gradually you see more features that
resemble NetBeans and this makes it
possible for us to share features
between each other there's never going
to be a point where we merge because we
have completely different audiences
NetBeans is really the the IDE for the
open-source community while JDeveloper
is the IDE for for Oracle customers with
EDF and WebLogic and their specific
requirements but it doesn't make sense
for us to have two teams solving the
same problems for two different products
so when it comes to the Windows system
and to the project system into those
kinds of common concerns we want to be
able to reuse as much as possible from
from bases where it makes sense so it is
also conceivable that NetBeans will have
pieces of of JDeveloper like NetBeans
has a pretty poor XML editor and
Geographers a pretty nice one so those
kinds of options become possible now
that we're on the same basis anyway
again a slight diversion let's continue
and we have now a window and we would
like to display a list of devices in
here now NetBeans has a very nice
solution for for complex swing
components if you're creating a complex
swing components like a.j list J table a
J tree and components like that you find
and it's completely standard if you're a
swing developer you don't even think
about this anymore but each of those
swing components has their own model
clocks so there's an abstract list model
for for jalis there's a tree whatever
mono for tree and there's a table
whatever for table
wouldn't it be nice if there was one
single model that you would define once
that all of those different swing
components could understand and do
something with so in the NetBeans
platform the solution for that is called
node so there is I'm going to add a new
dependency in my application on nodes
API
and this gives me a wrapper around a
business object such as we have right
now at Koch device so I'll create a new
Java class and we'll call it device node
so here it is and it's there are
different node subclasses but you take
the the simplest and most powerful one
as a starting point being node okay so
in here I create a constructor and I can
see that there are three different kinds
of constructors the plane constructor
that accepts some objects which in this
case is going to be device as a second
constructor which optionally lets us
provide children of the device so we can
imagine device and sub device and sub
sub device and and so on so those
children are passed into the constructor
of the node and then as a third
constructor we can pass in what is
called a lookup which is a whole topic
on its own but is a messaging strategy
and loosely coupled mechanism built into
the NetBeans platform so for example if
we want to enable the Save button for
our node we will put some object into
this lookup mechanisms or into the
registry of the node and then the save
action will be listening for that object
and will become enabled when that object
is published so there's kind of a
publish/subscribe mechanism but we can
that you can look at it this time but
let's take the simplest one and we want
to not pass in the object but you want
to pass in the device I'm sorry
yes yes yes sure we could
however the problem or as you see soon
not a problem but a really good thing is
we cannot import the device object so
even so we could think right now okay
this is a bug in NetBeans we can't get
the import statement so we can try and
type it but you see that we cannot find
it it's not there and the reason is that
each module in the NetBeans platform has
its own class loader but definition
everything inside a module is hidden
from all other modules and the reason
for this is to create a clean
architecture so only something can be
reused if the author of a module
explicitly decides ok I'm now ready for
others to reuse my code preventing the
situation where some new person on your
team decides hey that's a cool utility
method I'm going to reuse that utility
method over here and use it start to
start depending on it you change the
utility method somewhere and completely
destroy the application and cause
problems so only once something has been
explicitly exposed within a module to
the rest of the application can other
parts of the application use that code
so I need to go in here so I can see in
this project metadata which feeds into
the manifest file so when the module was
built the information inside this
project XML file is put into the
manifest file and I can see right now
that I have no public packages so I go
into the project property so another
place where Nipponese ide is useful to
use in this context and i say so
ultimately unlevel long as the packages
here and for each package i need to
decide explicitly to say this is public
ok so now you can see we have public
packages when the module is compiled
this information will be found inside
the manifest file so the the manifest
file of modules in the nippy's platform
have specific keys so there are keys
that are specific to the Niki's platform
in the same way as OSGi as keys in the
manifest file that are specific to OSGi
so now that we have done this we can
depend on that other module yes it's a
bi-directional relationship always so
one side needs to expose one or more
packages the other side needs to say I
depend
that so it's a very strict system and it
really helps in correcting a clean clean
code clean architecture so now we can
get the import statement okay so we've
received this beam and we say for
example set display name there's a lot
of different setters the display name
the icon so this note class in fact is a
GUI wrapper around our object because in
our object we have a type and an ID we
don't in there have an icon and a
display name those are things that are
not of concern for domain objects but
this class is of concern and giving a
GUI wrapper around that object display
name and icon such as all of the things
you see here you can see an icon display
name when I right-click on the node I
can see actions there are properties for
for a node so when I have the properties
when they open I can see the properties
displayed on the right hand side so
there's a lot of features that a node
has so with this knowledge you can look
at NetBeans IDE in a new way and see
everything that I am moving up and down
here these are all nodes and they are
found in a net being specific Swing
component that knows what a node is and
can display it as we're going to do soon
so I'll say set display name and from
the being I will get being dot get type
for example and I could set the short
description which is the tooltip I can
set actions but we'll just leave it
leave it here for a moment so close that
I have a device node I have a device and
I have a window so now I want to display
this this node inside my window and the
way this is done is via special swing
components that the NetBeans platform
has on top of the standard swing
components so where there is a j-list
NetBeans platform is a list where
there's a tree there's equivalents for
each you can continue using your
existing ones so a typical migration
path is to to use the window system to
use these these windows which are called
top components because they extend the
top component class so typically you'll
move your J list your J trees your J
tables directly into these into this
window classes just copy and paste them
in just say add in here and you have a
jealousy or whatever but a next stage of
porting would be to think about the
using the NetBeans platform swing
components because they provide some
additional features as we go to us you
know so first of all I will add a new
dependency on the module providing those
the swing components and here it is and
one of those swing components is called
bean preview and so here is being
treeview oh sorry
bean preview and this will be device
viewer equals new bean tree view and we
will add it to the top component device
viewer and we put it to borderlayout
Center set the layout new order layout
okay so let's run the application and
see where we are it's still running
yes okay run the application again
there's also actually a nice plug in for
NetBeans which lets you not need to
restart the application you can just
leave it running and reload your module
into the running application and really
treated like server so um here we had
now have the starting point of a tree
view that's going to have a long list of
of our nodes what we would now do in
standard swing we would now say device
viewer set model and then somehow and
then here we have we have a model which
is a device node so here we would say
new device node probably something like
this this would be the standard swim way
of doing things but the Knik means
platform has a very nice mechanism for
this it uses an MVC approach which means
that you did not attach your model to
your view instead you attach your model
to the controller and here is our
controller it's called the classes code
Explorer manager and this will let our
node be detached from our view and very
easy easily exchangeable it is just a
controller it is not a component you
will see this it is not going to be a
top component in the way that we end up
with it ok so we return it
return the Explorer manager and here it
is and now that we have the Explorer
manager we will stand she ate it
and so instead of this line of code we
are going to say instead set which
context which is the same as set model
in standard swing and here we would now
refer to our model however we don't want
one single device note we want to have
as many devices displayed in our tree as
they are connected to our to our
connection so what you really would want
to have is some kind of factory class
that will connect to our device load up
all the information and display it so
for that we have a nice class code child
factory so device child factory and this
child factory exists to create device
nodes in this case so it extends child
factory and it has some very nice
built-in functionality that you're going
to see so here we go here it is we have
one method predefined in here which
means once we initialize device child
factory automatically this method will
be cold and this method is automatically
run on a background thread and therefore
this is where you make your connection
to your data source be a database web
service whatever it is you will
automatically see a weight a symbol
appearing an hourglass so all of that
kind of handling will be done for you
and you will also not see your UI not
being responsive your UI will be
responsive while this connection is made
and until a trulia street earned here
your entire application will be as
performant as before so what you have
here so we'll just simulate a couple of
these so I'll add to the list new and
new device so here is a new device it
has an ID so one two three and the type
blue whatever whatever that is four five
six or some other number Green so here
we have two devices
and now when truth is returned whatever
is found inside of that list is used to
correct nodes and for that we have a
method override method correct node for
key so here it is correct node for key
and this is where we return our device
node a device node node equals new
device node key let's get the inputs
with the try-catch block so here's the
node device node and return the node
okay so we have we started with a device
object plain normal Java object we
created a device know to give it a
display name and now we have a top
component which will display a bean tree
view the bench review will display
whatever the Explorer manager tells it
to display because what happens at
runtime so the application is deployed
the bench review is put into the top
component and it asks its parent in this
case the top component do you implement
Explorer manager provider so built into
the bean tree view and inside of all of
the net new splat ensuing components is
a component hierarchy search for a
parent that implements Explorer manager
once that parent is found get Explorer
manageress code and here we have get
Explorer manager and so Explorer manager
is returned and set on the Explorer
manager is a root context so you'll
create it
children dot create new device child
factory true you need to create a new
root node and there we have it okay so
the benefit of this is going to be clear
in a second so we run the application
that's already running
we run the application embassy are our
two devices okay so now we think okay we
don't just want to see a tree of our
devices we also want to see a list of
icons so there's another NetBeans
platform swing component called icon
view so I choose icon view new icon view
and not the standard one but one that
okay so here it is and we put it into
the east now the cool thing is both the
bench review and the icon view are going
to ask their parents do you implement
Explorer manager the parent will say yes
to both the same Explorer manager will
be returned which handles what is
currently selected and well thank you
and therefore in both cases we will see
our devices displayed still what typos
in both places we will see our not only
where we see our nodes but you should
also see when I select one node it is in
one of the viewers it is also selected
in the other of the viewers which is a
very important concern in large
applications where you have multiple
windows when one item in one window is
selected you want the related item in
the other window wherever that is to
also be selected so there is a selection
system built into the NetBeans platform
which is really useful and you can see
it that this is a concern for large
applications if you're creating a small
application with one window probably the
next platform is not something that
you're going to be needing but once that
application becomes larger and you need
to have multiple windows you need to
have multiple objects being displayed
and obvious being synchronized with each
other then this is a logical logical way
to go we can now publish this node you
can see we have this node selected we
can publish into the registry of the top
component so there is a registry for a
top component there is a registry for
our node so if we make a change in
NetBeans IDE you can see that the Save
button is now enabled because I've made
a change if I now press save the Save
button is this a
so this in itself is not magical
behavior but how it works is when the
change is made a document listener that
is inside the editor here publishes a
particular object and implementation of
a certain interface and the save action
is listening for implementations of that
interface and it so happens that that
particular interface has a set has a
method called safe and so when the save
action listening for that particular
implementation of a particular that
particular interface discover that one
has been published it calls that method
without knowing what will happen on when
that method is invoked but that method
is defined by the editor component so in
this way all of the different editor
objects anything that needs to be edited
inside a nippies platform application
can all integrate with the same save
action it is of course possible for each
object that needs to be saved and edited
and so on to provide their own Save
button their own edit button and
whatever but what you would like when
you are creating an application like
this is to let users create plugins and
when they create plugins to integrate
with the existing idioms of the
application so rather than creating
their own save functionality integrating
with your existing say functionality so
a lot of what NetBeans platform is about
is finding these entry points into the
existing features and publishing objects
to enable and disable existing features
and creating your own objects that are
sensitive to certain other objects so
we're going to publish now into the
registry of the of this top component
via a helper class the Explorer manager
and the Explorer manager itself is the
container of the nodes because you can
see here we have set the node hierarchy
on the Explorer manager so by doing this
by running the application now we have
published the nodes into the lookup of
the top component which means when I
select a different node the properties
when there is automatically updated
because the properties window is
listening for node objects so now when I
select a different node a different node
is published into the registry into the
lookup of this top component which is
because this window is selected
published into the context of the whole
application so there are a number of
different sometimes called registries of
this code lookup some called context so
these are the same
concern so you can see here we have an
application we have a window we have not
spoke with us but we always have one
selected window and we have a node so
there's the the lookup of the node
they look above a window the look above
a selected window and the lookup of the
whole application the properties window
is listening to the lookup of the whole
application the application wide look at
when I have a particular window selected
whatever is in its lookup is merged with
the lookup of the application so
whenever I select a node what is in its
lookup is merged with the lookup of the
top component therefore by selecting a
node in this tree I am actually pushing
it pushing the underlying object into
its lookup and from there into the top
components lookup and by selecting the
top component into the application wide
lookup which is where the properties
window it has indicated an interest in
node objects so this mechanism of of
publishing and subscribing and of
messaging between modules is what keeps
the application loosely coupled because
their properties were knows nothing
about my device viewer window it only
knows about the node object therefore
built into the NetBeans platform are a
number of coding patterns and ideas and
and and insights into large application
development into loose coupling that
have that have developed over the last
10 years or so have all been integrated
into the thinking behind these api's and
components and so on ok so what you also
see in the small application right now
is a plugin manager which means we can
go to the plugin manager and install a
plugin and there are plug-in portals all
over the world which are comparable to
what app stores are so I can go to
NetBeans dot org and there's a plugins
portal here these are plugins for
NetBeans IDE but some of these plugins
for NetBeans IDE are not editors or new
tips and tricks for the Java editor but
are interesting other things such as
what I believe every application needs
your application is not complete until
you have Space Invaders integrated into
it I know this is not a very widely
known
rule but you can download this plug-in
and install it directly into this into
this application and you have you know a
new feature so potentially what you
could do is find all the games that have
been published as modules in different
plugin pro tools assemble them together
create a new update center which puts
all those games in there probably you
don't want to include the games in the
in the distribution that you make
available to your users because it
provides features that they may not want
so what you would do is you would
register an update center so an app
store inside this window here so this is
ultimately going to have a long list of
these update sensors one of them could
be the games update center and then the
user can choose which ones they want to
use potentially they would have to pay
for them so this could this is also the
basis of a of a business model around an
application the there's a farm
management application that's been
referred to a lot on this conference
also because of a jigsaw sword but what
they're doing is they get they've
discovered that farmers don't like
buying software so they give the
software for free to the farmer they
start planning way to plant their
potatoes and whatever their load maps
into the application and they start
liking it and then they are told if you
want to buy a new fertilizer or whatever
it is you need to connect to your
service provider and you need to pay a
couple of dollars per month to make that
connection and the service provider has
had a plug-in created for that
particular service provider or has
created it themselves needs to pay a
couple of dollars as well to be
subscribed to the system to provide that
service so on the basis of that model
you know all based on modularity and
based on plugins and and all
out-of-the-box it's not something that
you need to invent on your own so let's
see what else we could quickly show well
the options window is a central last
place where you want to let user
configure your system each module that
is so that the whole problem of a
modular system is you don't know how
many modules are going to be as the
curator of the application so you want
to leave extension points for others to
contribute into it
therefore when a new module is corrected
the module could
include a panel that that is registered
again into the file system in a certain
folder and when the options window opens
it looks inside a folder looking for J
panels to add into itself and that could
be used to configure something that is
provided by your module also the help so
there was a question about Java help in
the previous session so Java help the
the the worst thing about Java help is
that there are a whole bunch of small
XML files required that are part painful
to set up and that provide enough excuse
for people to not provide documentation
for their application the unfortunate
side-effect of this being solved by a
wizard and NetBeans is that you have no
excuse to not provide documentation from
you you can see here we have an HTML
based Java help system so in NetBeans
IDE you can see this to help contents so
each of these sections that you see here
come from different modules or
potentially in this case definitely so
when the web service modules are
uninstalled from NetBeans IDE
automatically this section of web
service topics will also be uninstalled
because they come from the same set of
modules so if I run this application now
I've just completed that one Java help
wizard application starts up I got to
help and now I have a menu item have
contents for the first time and I have
this about device viewer as a first help
topic each module there'll be a device
viewer device editor device analyzer
could provide its own help topics which
would automatically integrate into here
into the search as well as so all of
that is is also solved so let's create
another module so this module will be
used for editing devices so we have a
viewer that we want to let the user do a
bit more than that and I'm sorry device
editor and potentially we will have two
different distributions one for viewing
the devices it's completely reasonable
use case user wants to view what what's
what
what's on the connection what devices
are available and there could have this
for free and then they need to pay a
subscription fee or a license or
something to have access to the editor
feature add a new window editor app
application start device editor okay so
here's the editor window so let's say
that so now we want to start listening
to the lookup so so this is the this is
the NetBeans word for registry or
context so this is a context listener so
implements lookup listener what you
would ideally like to do is to listen to
the context for new device objects that
are there so we need to have a
dependency on a device domain okay so so
here is the so this result changed
method will be fired whenever there is a
new object of our of our type available
in the look so here we set that up it
when the component opens so each window
each class of top component has a method
open and closed so it's a Texas global
context and listen to the lookup for
device objects device class and from
this we get a result object lookup dot
result for device all devices in lookup
so here are all devices in lookup this
equals that and then we need to start
listening and lookup listener and when
the window closes we want to stop
listening yes
inside the lifecycle events so when the
component opens when it closes we will
start a new stop so it the each module
also has a life cycle so you might want
to do something when the module is
loaded or unloaded each each window has
a life cycle when it's closed when it's
open when it's hidden when it's shown
when it's activated okay so we have here
Isis in lookup and so when there is a
device in the lookup this method will be
called so now we're going to say we are
interested in the last one so if all
instances so if it isn't empty we could
we could do something with all of them
but in this case we aren't interested in
one of them so all devices in lookup
this is iterator so we're just getting
the last one as next device and we want
to make this
and not hasnext but next right okay so
here we have one device and let's go
into our top component and the nice
thing as well is when you're designing
gooeys you have the wonderful which is
GUI builder to help you so type so
here's the type I just drag-and-drop
this is all swing and you might be
wondering okay what about Java FX Java
latex can be integrated it very easily
into swing there's been sessions about
that especially in the context of a
NetBeans platform during this week and
there's also a tutorial that you can
follow and there's stuff being written
the nice thing about Java FX now in Java
x2 is that you can do that before you
know you would see a nice demo of Java
FX and you'd say yes I want to use this
and you'd be told oh you have to rewrite
your banking application to use JavaFX
script now you can gradually take the
pieces that make sense there's no one
saying you must be you must drop swing
and use only Java FX the reason why
there's integration that's possible now
is said that you can pick the pieces
from Java FX of next sensitive you pick
the webview pick some of the nice job
effects charts pick those pieces that
makes sense
and keep your je labels and whatever
because there's no immediate need to
change those so we set the text to the
device get type okay so that's all we
need to do so this is the subscription
side so here we are listening for
devices and displaying the current one
in the lookup now on the other side we
need to publish so right now we are not
actually publishing anything yet okay
five minutes left and it's we're almost
done device node so we can say so we're
using the simplest constructor we're
going to say children that leaf so the
devices will not have sub devices but
the device is going to have a registry
and the registry is can be populated by
the device object so we have now added
our object into the lookup of the node
and when the node is selected it's added
to the lookup of the top component among
the top component is selected it's added
to the lookup of the context and the the
two of them
now integrate completely with each other
so very small application but showing
all of the essential features not all
really there's we haven't looked at
actions yet the nice thing is if you
want to correct menu items you never
need to type again menu item is new menu
item because instead there is a wizard
for this and either actions are always
unable to conditionally enable let's say
it's conditionally enabled so enablement
is a nightmare to set up normally so
we'll say device here we'll put it into
the file menu so it would be nice if I
had a toolbar button but I don't think I
have an icon lying around
we need to display some okay so we're
not going to do the toolbar but you see
the you see the menu bar okay next so
this will be analyze device action and
reliance device click finish now what
you see here is a plain old action
listener there's another special
NetBeans platform class this is a
standard Java class but it will also be
registered into the file system in a
special way it's going to be registered
in there together with the icon that
we've set if you've set one display name
also it's going to be in the file menu
so we want it to be in a device meaning
okay so now we've created a new folder
in the menu folder and which will
display which will be displayed in the
device menu and the final bit of code
message no and we have the context
immediately which is very useful so this
is very clean code we don't need to
spend any time frittering out how to
enable our action because at the time
when the module is compiled these
annotations are turned into XML entries
and because we've said we've put this
device context into the constructor of
our class because of that and the way
that this action listener is registered
is in such a way that it maps to a
conditionally enablement functionality
in the NetBeans platform so if I look in
device right now it is disabled because
no device is selected now a device is
selected and now it is enabled I mean
and this was no coding at all and that
is a lot of work that you would normally
need to do to achieve this and it's all
done via mapping from these annotations
to XML and internally the XML is mapped
to into an internal class and handles
enable it for you for that specific
object that you have said so it we're
specifying for this object that action
should be enabled so there's a lot more
but these are the basic concepts the
module system the window system that
you've seen and the action system this
lookup mechanism for for clean
communication between the different
windows there's I very carefully left
one minute for questions
so are there any questions yes yes so
what you can do is you're right click
and you say package as in the MS and
don't leave yet because I have a gift
for you so if you're working right now
you're not going to get the special
present okay in the build folder once
you've chosen that option you'll find
the an updates XML file now this is an
XML file that lists all the modules that
your update Center is making available
so I can put this XML file on a server
somewhere and then have it registered in
my application either pre registered or
let the user register it and in here you
can see there's a distribution attribute
and the distribution attribute points to
the place where the nvm file was found
so in this case it's found in the same
location as the file itself but it could
be in some subdirectory there was
another question yes automated GUI
testing that the nice thing is that
NetBeans IDE and uses the NetBeans
platform so the NetBeans IDE engineers
have solutions for that that were used
for NetBeans IDE that I have made
available or more generally so on the
tutorial page you'll find a test
tutorial and there are modules that are
provided that are used for for GUI
testing sorry I'm not finding the right
location but if you go to the to the
next platform page to old documentation
you will see a section on testing and
somewhere
their nephews platform test and other
cool thing is net mean so this is kind
of boring test board is interesting as
gesture collection don't you want to
know what your users are doing with your
application and NetBeans IDE engineers
do want to know so they've created an
application a support for that in
NetBeans IDE which is generally
available so you can log the clicks that
people are making on your application
and and ask them either at some point in
the process whether that information can
be sent to you and also there are charts
there's a whole charting a web
application that is used by NetBeans IDE
which is open source with which you can
integrate that logging information and
NetBeans IDE if you want to see some
interesting statistics statistics has n
V statistics NB statistics NetBeans dot
org which has a lot of cool information
ok no it's actually getting to the right
place in these that this means well I'm
finding it anyway this is a place there
we see lots of graphs and you find out
that a lot of people are doing cut and
paste programming because you can see
all the the actions that are being
performed in the in the IDE ok so um if
you give me your business card and which
will only be used by me myself
personally to tell you about upcoming
courses and things like that
you will get in return a cheat sheet
which introduces you to everything and
if you if you're interested in the
course please let me know immediately
and we'll be in touch soon thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>