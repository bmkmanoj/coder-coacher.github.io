<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Rediscovering Your Architecture Through Software Archaeology | Coder Coacher - Coaching Coders</title><meta content="Rediscovering Your Architecture Through Software Archaeology - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Rediscovering Your Architecture Through Software Archaeology</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vE0WpHuHrLE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this presentation is kind of an
interesting one it's called software
archaeology which is the more
politically correct my supposed for
reverse engineering in some ways and
what this presentation is about is
basically something that I have done for
many years as part of my day job working
for doing consultancy and customer
support so what I end up doing is I go
on to client sites and start looking at
their applications and based on doing
analysis of the way their application
runs I can often have an intelligent
conversation about what the application
does what it's supposed to do and what
the architecture is so this presentation
is really some of the process flow of
going through that to to work out how an
application actually works and often
you'll find that how an application
actually works and how the people that
own it and designed it think it works
don't match and when they don't match
you often have some kind of defect or
architectural problem performance
problem that you can fix so being an IBM
presentation the first thing you get is
whole list of disclaimers and these are
just saying that you know if the
presentations rank products product
direction can change there's no
commitment will deliver a feature that
we talked about in the presentation but
there's nothing in here that's trying to
sell you a product it's more about the
method and the process and what you get
out the other end the examples I use
happen to be IBM tools and I run with an
IBM JDK but there are equivalents in
other places and basically everything I
use is free anyway so myself I've been
working as part of the the IBM Java team
for 12 years now it becomes 13 years on
October 20th I spent most of that time
working on client engagements doing
customer support and consultancy I now
do what we call consume ability but it
which is really usability monitoring
Diagnostics that kind of work as well
and I've also got some work that if you
saw the keynote session on some
they from Jason McGee where he talked
about Java in the cloud and patterns I
also now do our integration for that for
base Java runtimes so basically as i
said this presentation is coming of
spending a number of years looking at
other peoples applications trying to
work out what it does and they're having
a conversation with the architects and
the owners of application about you know
whether it's supposed to be what it
actually does so the goals of the talk
are to introduce software archaeology
and talk about the the software
lifecycle and how we closed the software
lifecycle so it becomes a circle will
discuss some of the methodologies so a
couple of ways that you can do it thru
static analysis or runtime analysis and
hopefully by the end of it will have
shown you how to understand what your
application actually does and reconcile
an architecture the diagram that you may
have with what it actually does and if
you don't have architecture diagrams how
to kind of generate them from from an
application that you do have so before
first talk about the software lifecycle
then we'll talk about software
archaeology itself will do an
introduction to uml I'm not a UML guy I
only use UML as a fairly standard way of
drawing some diagrams I could just as
well as you pen and paper I could use
you know flow diagrams from Visio or you
know whatever UML's just just handy and
I'm sure the way i use UML is probably
not right but you know it's usually to
help me visualize something and be able
to communicate it to other people and
the last third of this also is to actual
actually dig into a couple of
applications one of them is a very very
simple application that's only a couple
of classes the other one will take a
look at is is actually Tomcat so first
of all the software lifecycle so this is
what it's supposed to look like
according to wikipedia so it should be a
continuous circular development process
where you start off with your
requirements you know this the business
requirements for the system that you're
about to build
and from the requirements you generate a
design and you have what should
hopefully be a clean architecture and
then you take your architecture and you
start to implement it so as we all know
when someone comes up with an
architecture and you start to actually
write the code there's a very good
chance that it's not going to end up the
way it was designed right we you hit
roadblocks you frankly fer for reasons
of having to get it out the door you cut
corners and you do things differently
because the way it was envisaged at the
start isn't as practical as you thought
and you know a July teach this is where
you do things continuously because
things evolve over time so you've been
through requirements you've been through
your design you started implementing you
then start testing that system and as
you test it you find defects and those
lead to changes and then you have this
evolution that happens as a result and
it may go into to maintenance and you'll
get further changes as defects occur but
you should go back to your requirements
because every code change you make
should have a requirement whether that's
a defect whether that's a request or
enhancement whether it's a change in the
business requirement on the system
really there should be some form of
requirement for every code changing
maker and as I said they could just be a
defect in a bug tracker but from that
you should update your design and go
back to the implementation so it should
be a continuous circle that means that
your design and your implementation are
actually in sync so that's what it
should be the best that usually happens
is the waterfall model where you do
start off it requirements you go through
to design you go through to
implementation you do testing to verify
that model it goes into maintenance you
keep making changes and what you end up
on the right hand side no longer
reflects your requirements in the
slightest and that's usually what
happens so as the changes get made at
each and every stage of the the
waterfall model where you just end up
being more and more divorced from your
requirements in your original design
when you've got your system running in
production and it gets worse with with
legacy systems and legacy code because
the truth of the matter is you may not
have the requirements and you may not
have the original design
all you've got is the implementation and
that implementation may have been
changed do in the field anyway so what
you end up running with further legacy
systems can often look nothing like a
design if you have it now the problem
with legacy systems is that usually
they're there because they do a job so
you've got to keep them and as long as
you don't have to change them that's
fine but let's face it if you're using
any vendor software that vendor software
eventually goes out of support and that
means you have to move you get given no
choice and some technologies do go away
right there's not many people doing work
in Fortran anymore so if you had an
application that was written in Fortran
and you want to move to a new language
you kind of need to understand why it
was written the way that it was written
and what it actually does now some of
those requirements hopefully you've got
written down or you have business
requirements but if you don't have any
form of that then a starting point is
what the old system did and how it
worked now obviously that's not the best
way because often the requirements got
changed when it went to implementation
so the existing implementation probably
isn't exactly what you want to do but
it's a good starting point so for legacy
systems there could be no design at all
and maybe no requirement so software
archaeology is basically the study of
poorly documented or undocumented legacy
code and software implementations so
it's how to take something you've got
and go back and basically reverse that
life cycle so you get back to where you
should hopefully have started from so
the point of software archaeology is to
make it possible to to effectively build
designs get understanding for legacy
code and the legacy systems or it
applies equally to things which you know
kind of broke the life cycle model when
the work was done so when we talk about
getting your design back from your
running code that the standard way these
days if or should be I suppose of doing
designs is is UML the unified model
unified modeling language
so um L started in the early 90s or so i
think i was around 94 96 and the whole
idea of UML is to have a standardized
model for looking at different levels of
your architecture and the architects
have blueprints software developers have
have UML models and UML's basically brit
broken into two categories of diagram
you have one which is behavioral and
this is kind of how things flow through
the system so it's the dynamic behavior
in that the use case level it's kind of
like you I want to interact with the
system in order to be able to find out
how much money i have in the bank and
it's that kind of flow system and
structural diagrams are the physical
layout of things so it could be a
deployment diagram that shows you what
servers you've got where they sit inside
the network what your DMZ is and so on
so behavioral diagrams if we go through
them one by one starting at the highest
level really the highest level is your
use case diagram and these are kind of
the visualization of the requirements of
your system so this shows the
relationship between the actors the
external influence on the system and the
system itself so actors can be human
beings but they can be other systems and
this shows you basically the
relationship between your your users and
the building blocks of the system so in
this case it's a banal example with a
band manager and you've got a record
manager and how they interact with
things like how they're doing in the top
40 the next level down is an activity
diagram so an activity diagram basically
goes down one extra layer and starts
looking at how there is flow between
slightly lower level of components it's
you basically just one level down it's
it's more in depth than than a use case
diagram and tells you how things move
through the system but it's not the kind
of level that we're used to as software
developers
it doesn't get modeled at the level of
classes and the interaction between
classes and objects that really is even
a state further after state chart so
state chart is as you go through as you
go through the parts of the activity how
does state change and how does
interacting with this object in order to
do a change something affect your state
then the level below that which is what
we're probably more used to is the
sequence diagram so the sequence diagram
really does get tend to get down to the
level of these are my objects and this
is how one object interacts with the
other one which is effectively a method
cool so it shows you the cool graph of
methods we're starting from one object
moving to another by calling a method on
it and then that may call another object
by calling a method on it and this is
how your objects interact now you can
actually do a sequence diagram in the
same way a much higher level and talk
about how organizations talk to each
other but the usual one is to do a
sequence diagram where classes interact
with each other and objects interact
with each other by making method calls
on the structural side again if we start
the highest level you've got your
deployment diagram and deployment
diagrams are generally used to represent
your physical topology so what machines
you've got what applications are on each
of the machines how they connect to each
other what fire will you've got in place
and so on where your storage is this
kind of thing below you structural
diagrams you have component diagrams now
these could be represented at the level
of services so here what we've got is
we've got a billboard service and we've
got a reporting tool so it's kind of
that high level application building
blocks whether they're inside one
process or the separate processes is is
the level which you pitch it but it's
the interaction between between
components and then we get down to the
level that as developers we're probably
more useful used to which is class
diagrams so class diagrams are
individual classes of code usually it
will define the fields that you
so whether you have static or instant
fields inside your object will be
defined hear it often adds in what
methods are defined in each class what
the inheritance is between classes and
interfaces and what the reference is
between classes are in terms of you know
my object instance of this class
references another class so you have
those dependencies and you also have
object diagrams and the difference
between an object diagram and a class
diagram is that an object diagram is
basically a snapshot in time of your
system so it's a class diagram at a
given point in time so with object
diagrams you can often start to add in
values so you can say at this point in
time the installed in this object is
four ok so those are the kinds of
diagrams that we might want to build and
basically fer for software engineers at
the developer level you're really
looking at sequence diagrams so how
objects and how classes that you've
written interact with each other and
class an object diagrams so how the
classes are physically laid out what the
inheritance is what object references
there are from one class or one object
to another so if that's the kind of
information that we want to build how
can we do that from from our application
so the first way of doing that is static
analysis right there are tools out there
where you can load your source code into
the tool and it will start generating
UML for you automatically there are some
limitations here most of the tools will
do class diagrams for you but they won't
do sequence diagrams so they won't do
the flow between objects and the other
problem of static analysis is you need
to have the source code so if you have
an implementation that you are running
you've got a legacy system you've had
for 15 years you can't build it anymore
it's in a foreign language that you
don't know and you don't have access to
the source anymore then the static tools
won't do you any good also if you have
you know if you're running an
application server and you've got your
web application or you've got your j2ee
EJ
the application and you want to see how
it's interacting with with the third
party vendor code with the application
server with things like the spring
framework again static analysis we do
that for you because you don't have
access to the source code so you won't
show you what that's doing you can only
see the code that you've got so static
analysis works but there's some
limitations the next one is trace based
analysis so you can put trace points
into your code and see what it's doing
there are tools out there that use
either aspects at compile time to put it
into your source code or byte code
injection so at runtime it puts trace
points in and it uses that to try and
find out what the flow is through your
code what objects you're allocating how
they relate to each other and so on now
that works fairly well but it's
expensive so the fact that you're
continuously tracing is an expensive
activity so if you've got a test system
that is representative of what you do in
production then you know that's an
option for you but if you've only got a
production system that's the only way
you can exercise the system trace can be
expensive and the third option of using
a debugger is even more expensive where
you're going to step through K basically
you can't run that on a production
system you can run it you know in
development only so those aren't the
various options and I'm actually going
to go through showing a way of doing
static analysis in a way of doing a
trace based analysis for for each of the
steps so first of all we'll have our
sample application and this is a very
very simple application that's just a
bad java implementation of grep so it's
called Java grep and all it's going to
do is take a term and a list of files
and it will search those files for that
term and printing print out any
instances that it's finds so the usage
is java grep the pattern that you want
to search for and one or more files that
you want to search through the
implementation of java grep is here so
in terms of what it does in the main
method it compiles a regular expression
which is the pattern that you passed on
the command line
and it takes the list of files that you
added and your abs it to an ArrayList
called file list then for each of the
files that you've passed to it it will
create a file scanner and against that
file scanner which you passed the file
name and the regular expression to it
called scan it then queries the file
scanner object to ask it for the number
of match lines that's that it's found
and if it's found a number of them it
prints those ain't and then it prints
out a summary so it says you know we
found five lines ain't of 200 that
matched and here's what they were so all
java grep does is takes your regular
expression compiles it adds the files to
a file list for each of those files it
creates a file scanner object calls scan
on it and then gets the results so most
of the works done in the file scanner
and what file scanner does is to first
create a line number reader for the file
that you've passed to it so it creates a
file stream creates a line number reader
that file streams are then for each of
the lines in the that the line number
read it brings back it calls get line
suggest file reader read line checks for
any matches by doing a regular
expression check and if it finds them
adds it to an ArrayList called match
lines and that's it and it's got some
getters and setters so the first of
those is the implementation of scan line
itself and scan line just calls pattern
matcher dot find matches and then we've
got the getters for the for the get
match lines which are java grep class
calls the scanned line came so we can
cool get line count to find out how many
lines that there were and we can get the
number of match count so it's very very
simple to classes so in order to find
out what the dynamic behavior was
effectively what we're looking for is
the method call graph we're looking for
how one object when we start and we're
going to start in with the main method
from
the main method what's the next method
that's called what does that cool when
it returns what's the next method from
that class and so on so you're basically
going to be building a tree of cools and
what that looks like and that basically
equates to a UML sequence diagram so in
the example here if this was your main
method its we call main then we see that
this is going to be creating a file
scanner then it's going to be a cooling
scan and those sorts of things right
that's what we're expecting to come out
the other end so when we try this and we
want to generate a sequence diagram I
said there's two mechanisms that I'm
going to talk about one of them is
static analysis so the one of the
problems would try a static analysis is
that from what I'm aware there aren't
too many tools out there that do good
sequence diagrams anks of static
analysis in fact most of them don't even
try there's actually a in the exhibition
center upstairs there's a company that
does a uml modeling tool and they do
great class diagrams they don't do
sequence diagrams IBM's got its own
product that that does static analysis
called rational Software Architect it
does great class diagrams for sequence
diagrams does one method only and you
can try and patchwork them together but
you know basically the tools aren't
there for sequence diagrams today so
really if you wanted to do static
analysis you do it manually now you get
a uml modeling tool you start trying to
create a sequence diagram and you walk
through the code by hand and it's a slow
painstaking task especially when you
don't really know which bit that you
might care about so your other options
to do runtime analysis so you can turn
on tracing you can run the application
hopefully you've got a test case that
actually you know hits most of the code
paths so you need to do that when you're
doing your code coverage testing when
you're doing QA your performance testing
maybe or if you've only got production
system you want to be able to do it in
production which means you're tracing
overhead has to be really late so doing
it via static analysis where we've got
access to just a Java grip class and the
file scanner class is possible to get a
diagram that's actually pretty good
it's slow as I said you can't of doing
it manually and it is limited to just
Java grep and file scanner but that's
okay because we don't really care what's
going on around that but it does work
now it is possible to include other
calls I could you know I create a file
reader so I could include the call to
the file reader but if the what file
reader does something else yeah I don't
know about I can't do that from my
manual analysis so if you wanted to do
runtime analysis there's a couple of
good tools out there for doing this
right IBM's got one called a health
center and it does full call graph
analysis for virtually no performance
cost and it gets away with doing this
because it uses the just-in-time
compiler to generate the this
information so it has a full court call
graph of every method and what it calls
and Oracle's got an equivalent in
Mission Control so there are a couple of
tools out there which will do this so we
have pretty much platform coverage but
what this will do is it tells us that we
have at the top of Java main method
sorry Java grep main that calls our foil
scanner we've got file scanner that
scanner gives you that the full call
graph of absolutely everything that
happens so this is great we've got you
know the starting framework of being
able to build our diagram and if we so
hopefully this is much easier to see if
we dig into particularly file scan
adults can it can show us that file scan
adults can coolz scan line equals the
line number read read line it creates a
string buffer and doesn't append to it
it creates an array list and does an
array list or add so we've got all of
that information and in fact we can go
stupidly far down the cool rough if we
want to we can see that scan line
creates a matcher it fight tries to call
find on the matter what the
implementation of the reg ex matcher in
Java does is it called search it creates
a pattern start calls match against it
so you've got absolutely every bit of
Java code that's running in the system
so you can go you know from
your code into container code out to
jdbc drivers you can build the full
picture if you want to now one of the
things you might notice when you look at
the anklet on the right hand side though
is it's not ordered so you'll notice
that in some cases we do initialization
according to the hierarchy here after
we've used the object and it's because
this tool doesn't actually know about
the order in which methods that have
been called they just know that they
have been cooled and the ordering is
actually done according to web most of
the CPU time is spent so most of the CPU
time inside file scanner is spent
calling scanline in fact that's what the
forty three point five percent is so
most of the CPU time inside scan is
calling scan line to the tools designed
to do performance analysis but it does
give us this cool graph so you've got
two options at this point you can say
well logically I can look at this and I
know initialization has to happen first
and I know that I have to find a line
before I can scan a line right so you
can apply some common sense to it but
you can also decide to where are we yeah
you can decide to drill into bits that
you care about and turn on tracing and
find out the order of the calls using
tracing so again this is just some
inbuilt tracing that's in the IBM JDK
you add some command line options and it
starts tracing method flows but this
tells us that inside the file scanner 88
coolscan equals get match lines it gets
cooled get match count then it calls get
match count again it calls it twice and
it calls get line came so we now have
the complete call graph of everything
that's being run and we've got some
ordering information
so between the two we can now build a
sequence diagram that basically goes as
far through the application as you care
to go and has correct ordering
information and if we're calling the
same method twice for whatever reason
what we have that so a combination of
low overhead sampling profiler that
gives you the full cool tree plus the
ability to drill into the bits that you
care about using method racing gives you
the ability to basically build a good
sequence diagram for any application so
the other side of this is structural
diagrams and we said that the best
structural diagram for what we care
about really is a class diagram so class
diagrams give you the inheritance
between classes and the references
between implementations of those classes
soon so objects so again I said there's
lots of tools out there that will do
static analysis and they're actually
pretty good at this so if you've got the
source code you can run static analysis
you can get UML class diagrams out of it
if you don't have the code or you want
to be able to see how your code
interacts with party code and so on you
can do runtime analysis and that means
again you run your application and you
generate a system or a heap dump this
works in all platforms if you're using
hotspot you get an H prof format dump on
the IBM platforms there's something
called a where you can get an OS level
system dump or you can get a PhD format
heap dump and that's all the data that
you need in order to be able to build
class diagrams from runtime so if you
did the static analysis approach what
you get on is in our case you've got the
Java grep object and you've got the the
file scanner object so it tells you the
fields which exist in in either and you
get the methods and you get the fact
that one uses the other so you've got
the information if you wanted to do this
from runtime analysis and once you've
taken a system dump or a heap dump and
you've loaded it into the tools what you
get initial
looks a little complex so what i've done
here is i've just searched for the java
grep class and what you've got in the
panel on the right hand side is every
single reference from the java grep
class to anything else in memory so lots
of that stuff is things that's in the
class itself so when you've written the
class and you put some strings of text
in there there's a reference to those
strings but the interesting stuff for us
is at the bottom here so it tells us
that we have a reference to a match
string and that match string contains
four it tells us we have a file list
which is an ArrayList it tells us we
have an underscore pattern field which
is an implementation of reg ex lock
pattern and it tells us that it contains
four and it's been compiled and if we
care about inheritance where we care
about does this class extend another
class or implement in the interfaces you
get that in the top left hand corner so
you can see Java grep here doesn't
extend anything it's it's blank is just
insensitive java.lang.class and you get
a summary of your your statics so
anything you've declared as being static
inside the class on the left hand side
if you cared about things that were
instance fields instead so not declared
a static just fields that you're using
they would come under the attribute's
heading so from a system dump I can go
and search for Java grep and it
basically tells me that we had a match
string is value is 4 we've got a file
list which is a java.util.arraylist it's
got one entry and that's bill thought
source java grep so basically wrapping
myself for instances of for loops and it
tells me that there's a pattern and that
pattern is the compiled version of four
so it's just doing an anywhere in the
line search for the string that I gave
it so you take a system demand it
basically tells you exactly what your
application is doing what's being used
in memory in the interaction between
them so that's the Java great class so
the next thing is the is we can actually
drill into anything right we can drill
into code that you own or anybody else's
code so if we wanted to look at the file
list which is our array list of files
that we passed in that we wanted
search from the file list which we have
here we can see everything that I
references we can see it's got instance
fields one is element data which is an
array of objects it's got an in code
size and it has an encode mob came
whatever that is so it tells us its size
one and there's an array of objects so
we can go into our element data and we
can actually see what's in that object
array we've got it sighs we've got its
Kang we could also go into file scanner
and inside the file scanner we can see
from what it references in the list of
attributes on the left-hand side that
it's got a file name it's got an F
reader which is our line number reader
it's got a string called underscore
pattern which is our our our which is
our for that we passed in changed into a
regular expression and then compiled
we've got match lines which is an
ArrayList of the lines which we found
were matched we can then drill into that
array list if we want to see what lines
have been matched by the application at
this point in time we know that there's
41 lines that were scanned and we know
that there were four that matched so the
system dump gives us this full
relationship between every single object
on the Java heap and the values inside
every single field whether it's a static
field on a class or whether it's an
instance field on an object so you can
use that to generate your UML so what we
would expect is that it looks exactly
the same and it does bar one thing the
only thing you don't get by this route
is the list of methods which I said you
could optionally add to each of your
classes but we do know what the methods
are because we've got that from our
sequence diagram and if you wanted to
you could run java p at the java probe
against which ships as part of the java
runtime you can run that against the
class you can get the list of methods if
you wanted to anyway so a system dump
will give you the full architectural
layout the full class diagram for your
for your application and a mix of
profiling and tracing will give you the
sequence diagram
so that was a pretty simple application
it was only two classes and we had the
source code for it but I can do the same
thing for anything and what we've got
here is trying to do it against tom cat
so what this is running is against
apache tomcat 70 27 so this was run
probably a couple of months ago when
when that was the most current release
and again the approach for doing it
through the the call graph method
profiling is to start off by searching
for your main method so when we search
for our main method we find that that
main method is Apache doc Catalina star
top top bootstrap domain and what
bootstrap main does is it effectively
calls in it load and start but it
delegates those through to a second
instance so it does use his reflection
to try and find a class which is the
order Apache up Catalina does start up
the Catalina class and then it calls in
it load and start on those so we now
know a little bit about the way that
tomcat does it start up it has a
bootstrap class and it effectively calls
low class and then invoke on a Catalina
object so we could then get our system
dump and start to go in and say ok so
given that it calls the Catalina object
the object and that calls it in it
loading start methods what does the
Catalina object itself look like what
data does it storm what does it
reference so what we can see here is we
have a Catalina object and it contains a
fair amount of data is got a reference
to a config file so that's just a string
but it's comp servidor xml so we know
that it's loads its configuration from
from server.xml file in the conf
directory we know there has a child
object called server which is an
instance of standard server we know that
it's got inside the server we have a
s called localhost so we know this
applications running on localhost well
you know it's got an mbean server and we
can probably go into the mbean servin
see what m beans are available and what
values that they're currently making
available over the network so you know
if it's being used to provide monitoring
we can go in and we can see the current
state of monitoring when the dump was
taken what else might we want tonight we
know there's a state object so that
state object probably tells us something
about the state of the tomcat server at
this point so it might tell us it's
initializing it might test its running
it might tell us it's stopped we know
that there's a shutdown object and we
know there's a shutdown hook so we can
see that it does some kind of processing
when it shuts down so it is starting to
tell us quite a bit about how tom cat
starts up how its configured and what it
does so we can then start digging into
that server object and go a little bit
deeper so inside the server object we
said that there was a state object and
that state object might tell us a little
bit about what the the applications
doing at the moment so there is a state
object and it has a value in there
called name which is set to start it so
okay at the point that this dump was
taken our tomcat server was started and
running we can also see that it
obviously does some processing work
around that lifecycle state because we
have a life cycle support object with a
number of listeners registered so we've
got a number of life cycle listeners so
our application cares about changes in
States has a number of listeners for
those changes in states and they're
going to do something when that happens
so we now know who those listeners are
so we've got a life cycle listener
Jasper listener a leak prevention
listener so we can then start drilling
into those to see what they want their
current state is and we can then go back
to the profiling view of all of the
ethicals to see okay so we've got a leak
prevention listener and I can see look
at its data to see what is current state
is and what calculations it looks like
it does and then
can go to the method call graph to find
out what the flow is and what methods it
calls and this probably will give us a
good idea about what kind of leak that
it's looking for and roughly how it goes
about doing it so this is how you can
start going moving backwards towards
I've got an application it does stuff I
need to know what it does so between the
two tools between using cool graph
analysis and having your object graph
your your object diagram you start to
get a good idea of what your application
does and whether you choose to create
UML from this you know standard notation
or whether you choose to you just use it
for your own understanding you know
either is fine but the data is there to
allow you to do this so in summary it's
possible to do static analysis and find
out what your application does and how
it runs there's also runtime tooling out
there you know I always using some stuff
that's built into the IBM JDK that's
free Mission Control for hotspot does a
lot of this as well there are
third-party tools which will inject
trace and allow you to look at the the
flow of your application by that
mechanism but you know it's all there
and it will let you find out exactly how
your application runs over time that's
good for closing the development
lifecycle yourself it's always
interesting talking to system
administrators and people that look
after production systems and showing
them these tools and then then talking
back to their architecture team and
saying so why does it work this way why
does it do this and then you start to
see some debate where the the architects
are saying it doesn't do that and you
start to reconcile the two and you
realize that there's a fundamental
problem and you at some point between
design and implementation things went
awry and the system no longer does what
it was actually designed to do so you've
got that ability to close the loop
you've got that ability to talk
and to actually work out whether the
system's doing what it's supposed to do
and that helps if you ever wanted to
migrate your system and you had to
migrate that system and you want to know
what state is actually in now how your
application actually works and this
whole thing really is very useful for
helping to debug problems as I said I
spent you know probably 10 years working
with customers by doing this kind of
analysis to work out what the
application does to then start having
that conversation about why certain
design choices were made why it was
chosen that you know it's implemented in
this particular way and often the answer
that you come you get back is that's not
what we designed it's not supposed to do
that it's supposed to work differently
so it's often pointing out that you know
a mistake was made there's some
reference is there the tools that I use
a rule linked there the the cool graph
processing is a tool could haul health
center the memory analysis stuff is a
tool called memory analyzer it works on
all platforms there's an eclipse version
of it there's an IBM port of it which
builds in some information about IBM
products but it's all freely available
there's a blog that we run and there's
some discussion forums and the like and
the obligatory IBM trademark and
copyrights on the end so we've got about
15 minutes for questions so is anything
anybody wants to to ask
so that the tool that I use to get the
call graph automatically is health
center and then what it does is
basically the just-in-time compiler from
both IBM and Oracle are tracing
compilers so what they do is they watch
the way that code flows in order to make
the right decision about how to compile
it so it generates this data anyway and
what health center does and mission
control from from Oracle is allows you
to visualize that data that's already
been generated so it gives you the call
graphs and the cost in terms of
performance is less than 1% because it's
just sending data over wire that's
that's already been generated so those
really are the two tools either health
center from IBM or Mission Control from
from Oracle yes
and
it's a little big problem with respect
to our interfaces but what is its work
works equally well to bring down the
concrete or on vacation with with which
battleground only only put the choice I
so so so you're right so says the first
part you could d compile code in order
to get source and work off that there
are often legal aspects that says that
you're not allowed to decompile code so
you know I work for IBM I'm not as I
said at the beginning the software
archaeology is the the pleasant term for
reverse engineering now I'm not allowed
to talk about reverse engineering I'm
pretty sure this is being recorded which
means I'm probably in trouble for that
but new the clean side of this is you
can do it with profiling now in terms of
from the bytecode Oh from the reserve
reverse engineered code generating the
cool grass from that as I said from what
I've seen there's not much in the way of
good tooling out there and that's kind
of the problem if there was then being
able to do it statically would be really
useful the only the only difference is
that if you can do it from a running
system you actually get to see which
bits of the code really get used versus
those bits of the code which happened to
be there and may never get invoked it
all yes
God
so yes a system dump is a snapshot in a
point in time now regardless whether
garbage collection kicks in what the
tool shows you is all of the live data
so it's the full structure of your
application it removes the garbage for
you the limitation from doing it runtime
is is the same that it is for static
analysis for sorry for runtime analysis
for cool graphs which is you'll only get
to see the bits of the application which
are being used so if you've got
ancillary bits which you know we haven't
used that function yet we've got an MDB
that's not loaded because that message
format has not arrived then yes it's
missing it's a limitation of the
approach but again the other side of
that is you actually get to work out
which bits are used and which bits
aren't so it's it's a trade-off yes
what if bad
yeah so it is it is true that if people
have obfuscator their code so they know
they mechanically modified method names
and field names then life gets a lot
harder you it's not impossible to
generate a good understanding of what's
going on is just significantly harder
and in all honesty I think people should
know that security by obfuscation and
security by obscurity doesn't work
long-term so yeah I mean you should
write code that people can understand in
the first place but that's just my
opinion yeah
a lot of vacations
Sofia
so the question is is there any tooling
that that works at the the higher level
so you know we said that there was
deployment diagrams component diagrams
and i was looking at class diagrams at
the higher level there maybe I I'm not
sure in all honesty right I think it's
fair to say that from the work that I do
going on to to talk to to different
clients they generally have a better
understanding of what happens at the
higher level because there's less
information and people can eat more
easily hold it in their heads is when
you start to go down to the level of
well this was developed by a team of 150
people you know no one has a clue how it
actually works anymore and you know
people work in their silos and the only
ends down there little bits so there
probably is tooling that will track
transactions and interactions across
processes I know again there's an IBM
tool called I tcam real time tracker I
think it is which does exactly that it
does correlation ID passing between
processes and it follows new like web
service transactions and so on that's a
commercial tool I don't know what what
other alternatives there are
British
vacations visualize dependencies only
doesn't count the graph that the chosen
in tendencies of Pikachu structures and
understand
for component
I should look it up here any other
questions
so how do you find the time to let okay
so it's surprising how quickly you can
start generating the data it's
unfortunately there isn't much
automation tool that sits on top of it
at the moment so once you've got the
data you do sit down you spend two or
three days manually working out how
everything works but in terms of the
call graph data right you can gather
that at less than 1% seat overhead on
the application you can gather in
production and take the file and just
look at it offline and the same third
for system dumps system it's more
expensive it's a one-off costs and it
does depend on how much memory you're
dumping so if you're we actually do
performance narcissus if your
application is 3 gigabytes in size it
takes a bank 40 seconds to write a dump
but you only do it once and it does so
non-destructively so yeah you you you
miss your s la's for a short period of
time to gather a huge amount of data
yeah
you
there
so so the question is for the call graph
analysis what do you do if there's the
likes of an if-else block so the the
basic method profiling will tell you if
there is to method calls from the parent
which one's called more often it does a
cpu break down it won't tell you you
know this is inside the if and this is
the else if you want that kind of
information then your only option is to
drill down into that particular method
with some kind of tracing so it the
advantage of the method profiling at the
high level is that you get everything
very very cheaply you then have to drill
in if you really want to know specifics
about specific methods anything else
okay then thanks for attending any
everyone if you want to see more some of
the tools I've got like live data on my
system at the moment I can show you
really want to thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>