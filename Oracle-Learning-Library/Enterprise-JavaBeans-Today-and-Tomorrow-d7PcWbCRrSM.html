<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Enterprise JavaBeans Today and Tomorrow | Coder Coacher - Coaching Coders</title><meta content="Enterprise JavaBeans Today and Tomorrow - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Enterprise JavaBeans Today and Tomorrow</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/d7PcWbCRrSM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone my name is Srinivas si
GU and the WebLogic e JV team lead and
my co-presenter today is marina wat kena
who's the EJB 3.2 a specification lead
we'll be talking about enterprise
javabeans today and tomorrow agenda
we'll start with an intro where we look
at how simple yet powerful eg beasts are
following which we'll look at we'll take
a closer look at some of the key
features that have been added in EJB 3.1
next we'll go or what's up and coming in
EJB 3.2 for language we'll have a Q&amp;amp;A
session alright let's get started with
the poll how many of you guys are using
ejbs
hey they're for work or personally Wow
okay that's a lot of time how many of
you guys are using hav 3.1 okay how
about 3.0 okay how about 2 dot X all
right okay how many of you guys are
using CDI okay looks like there are a
good mix of people hopefully everybody
will get something that was a
presentation eg B's today have come a
long way since their inception they're
really easy to develop and deploy from a
programming model perspective any poggio
can be used as an EJB and for session
beans if you want to expose business
methods you can choose to extract an
interface and expose the methods through
that or you can expose the no interface
view where the bean class itself is used
as your business view now from a client
programming model to it's fairly simple
you can either dependency inject your
type of pjb which will be the interface
or if you want using the bean class
itself then there could be the type for
no interface video and if you are doing
a junior look up it's pretty much the
same you still expect the same type you
can do the lookup now in addition to
that there have also been
simplifications on the metadata front
they're intelligent defaults used for
most cases so configuration is really
done by exception and for cases where
you need to provide metadata you can
either use
patience or you can use XML or you can
use a combination of both annotations as
well as XML and for cases where both are
present then there's going to be a merge
that's going to happen and if there are
conflicts then XML wins right
so another area that you gb7 be improved
on especially in 3.1 is packaging
traditionally jeebies had to be packaged
in jar files so what this meant was if
you have a web application which uses
ejbs
you would package all your web content
in a bar file you would package all your
eg bees in a jar file then you would
have to combine your file in jar file
together into a year file and apply the
gear file with EJB 3.1 this restriction
has been removed and now you can patch
package you JB's directly into a war
file so this greatly simplifies users
who want to keep their all the content
in just a war file and don't really care
about having a separate component for
each GB as far as the class's code they
can recite pretty much anywhere where
classes Java classes can reside in a war
which is under web in flip jars or under
web and classes and all of them together
even though they're in the jars and web
and flip will be just part of the War
module it's not a module in itself per
se for the descriptors the descriptor
goes under web and so to keep consistent
with the rest of the for easy access so
another thing that was standardized in
EJB 3.1 was standard jndi named for the
different client views so previously if
you deployed an EJB for exposing the
various client fields through jndi you
have to provide a jndi name and there
was no standard named way of doing this
you had to default to you had to resort
to using vendor specific descriptors
starting EJB 3.1 there are default jndi
names that are computed for every
session bean that gets deployed for
local remote knowing a face home and
local home views so it's easier you
don't have to mess with vendor specific
descriptors and the clients also don't
know of the standard naming later on in
the talk we'll get into the details of
how the names are computed unit testing
so one of the complaints has been around
for a while for EJB
this was testability so with each abs
you have to have a server running you
have to have your EJB deployed to be
able to unit test it and for local use
it was even more trickier because if
your j unit was running in remote view M
you needed a remote facade which would
invoke the methods on the local view
when a degenerate is running at a remote
VM one of the features that was added in
EJB 3.1 which we'll get into later is
embedded EJB container with embeddable
EJB container you can use your j unit to
launch the EJB container it will deploy
de GB jars which are there in the system
class path and you can invoke on local
as well as remote client views there it
makes it real easy to test eg B is both
local as well as remote client views
moving on to the powerful aspect of EJB
is in introduction section so there are
several container services that the GB
container provides dependency injection
whether it be injecting your JMS
resources or your data sources or other
persistence units or persistence context
into eg B's as well as injecting EJ B's
into other components like servlets or
other AJ B's so their support for
lifecycle callbacks for both construct
and pre destroy for all session beans
and massage even beans and for stateful
session beans you also have callbacks
around activation and passivation
there's also support for
transactionality for lifecycle callbacks
we currently have that for Singleton's
and there's work-in-progress to do the
same for stateful session beans
there's interceptor support interceptors
can not only nurse have business methods
they can also intercept lifecycle
methods they can intercept timer method
time-out methods it's it's a pretty
useful interception technology there's
also support for transactionality you
can use container manage transactions or
if you wanted to programmatic he can do
beam manage transactions there's Method
authorization timer service has been
around for a long time and there been a
lot of new enhancement that have been
done recently for both programmatic as
well as declarative timer support
there's a persistent as well as non
persistent timer support and there's
also newly
a sink invocation support as a part of a
JV 3.1 we'll get into the details in one
of the sections egb being the core
component technology here it's been well
integrated with the various platform
specifications so singleton as well as
stateless session bean x' can be exposed
as historic to a root resources they can
also easily be exposed as jax-ws web
service endpoints and when CDI is
enabled it recognizes session beans and
as first-class citizens and deals with
the contextual lifecycle management as
well as injection all right so we have a
demo here which kind of demonstrates
what we have been talking about alright
so hopefully I guess able to see this
okay all right so here's a simple new
registration page new user registration
page the UI is fairly rough the UI as
well as the persistence layers are kept
simple intentionally because the focus
is in the middle tire here so you can
create a user so one user one and give
some password and it registers the user
and mr. B there okay and it's just here
it should see the same page again to
register another user so now if you go
back to seeing what what it takes to do
this so we start off here with a user
registration servlet and we don't have a
middle tier so we inject the Energy
Manager factory directly into your
servlet and you have to inject Energy
Manager factory because that's the third
safe component and you can't really use
our energy managers and servlet sir can
be accessed concurrently so you also
inject a user transaction object you get
your name from the request parameter or
and if it is there you call on to a
register user method and the register
user method as you can see creates a
entity manager out of your vanity
manager Factory then it begins the user
transaction makes the entity manager
join the user transaction that was their
big
and then calls persist on it and commits
the user transaction for failure cases
it does a rollback and it closes the
Energy Manager so there's a lot of work
that's happening here
for just being able to purchase the
entity now if you want to switch over
switch this over and start using ejbs
I've already coded up a DGP sir we don't
have to spend too much time on it but
here's a user registration service which
is just annotated at stateless and you
inject an Energy Manager into it
directly because the container takes
case takes care of making sure that
there's only one user accessing the
particular instance of this Jeff LESBIAN
so you have the create new user method
and all you do is e m dot persist with
the method being transactional by
default this should take care of it
multi logging a element to the system
dot out to be able to see from the log
file but obviously it's not really
necessary here so now if you want to
switch over this to be able to use your
hey JB here's all the code that you need
to do so you go here you get rid of your
persistence context you don't need your
user transaction anymore you just inject
your EJB and and then in your actual
method so you go over to the register
user method that you had here before and
you can start using the user
registration service and get rid of all
of this
and to create a new user with username
and password right so so here you've
started using your stateless bean and
now I'm gonna switch over to building
the simple demo and redeploying it and
now hopefully this is gonna work so I go
back to mr. new user or he say one web
user two three all right so we've
registered web user - and we can also
probably look at the
and hopefully you can see these
hour-long here which says that the I
guess I hear she's guilty it's going
through the EJB service that we just
chatted and doesn't go through the
servlet that we had before so if you
look at this it simplified a lot of this
stuff to care of the transactions it
took care of the registering the error
in Energy Manager with it and you can
just inject the Energy Manager it really
simplifies stuff the client programming
model all you had to do was inject you
didn't have to extract an interface it's
a plain Jane pojo and you had stuff here
so now if you want to say for example
start exposing this as a say herbs as a
web service all you need to do that's a
jax-ws web service and all you need to
do is add our web service here and that
and then go back here your rebuild know
they're ready to fly okay say if you go
back here so we're love you'll see okay
looks like there's okay so here's your
web service and now if I do a new page
so for a web services GlassFish provides
our tester page which you can use if you
don't have a client but others could
have to write a web service client for
this but now you can do one web service
user one and fired one two three
so create a new user so there's no
return value but you see that you can
use it as a web service now if you want
to do it as a
jax-rs web service is a little bit more
work that you need to do but it's really
in the metadata level again so we had a
path so to say where it needs to be
exposed and you mark it as say for
example post method and I'm going to
replace this and stuff typing it for you
so and then talk about what I just did
so I added I post
annotation saying that this is a post
this is a query parameter which is going
to be username and there's another query
parameter which is going to be password
all right so now if you want to rebuild
it here and then gonna do a deploy okay
so again for jax-rs - there's been no if
we're done in the UI so it's a bit rough
alien so we were using postman which is
a restful victorious claim so here I
have the service I can create a
jax-rs - user - one I guess I miss zhuo
one but that's fine so I do uh I swear
Advanta three into a post when a friend
and I can send it up oops looks like
some things because the resource is not
available let's look at deluxe ok that
seems fine okay that's like whatever you
think yeah oh you know what so yeah so
another thing that you need to do when
you're doing a jax-rs client is in
addition to actually annotating the ugb
you'll need to create a application
cache which is needed for Jersey to be
able to detect the resource so here in
my demo notes I have that copied so I
can copy it here a stricture
alright so all you see here is the get
classes returns to user registration
service which is our EJB which we're
exposed as jax-rs subs so let's do a
deploy here hopefully it's gonna work
this time that it needed yes
application Panna to have the interest
ratio service here okay
see if you have user registration
service okay I have resources here in my
application
yeah have resources here so anyway I
mean I think we we don't have time I can
I can look for this while my
co-presenters parenting and show you so
it's fairly easy to even expose it as a
jax-rs resource it doesn't really take
much to expose it as any of the web
services now all in all there have been
a lot of complexities addressed to make
each if it's real easy to use and the
container is fairly feature-rich and
well integrated with the platform so
moving on let's take a closer look at
some of the features that have been
added in EJB 3.1 so here in this section
we look at the individual features we'll
talk about singleton session beans we'll
talk about a synchronous session bean
invocations we'll look at what has been
added newly in each furfle for EJB timer
service we'll look at how the portable
junior names are computed we'll also
look at what it takes to use the
embeddable EJB container for testing or
running in a j2se Java SE environment we
also will look at EJ V 3.1 light where
we look at what are the features that
are part of the g3 dark on light so
moving on to single transition beans so
this is the first time that a new
session bean type was added it was part
of EJB 3.1 so for singleton session
beans as the name suggests there's one
instance created however there is one
instance per JVM so if you have a deploy
to a cluster you would expect one
instance per JVM on each node of the
cluster so the singleton session beans
are intended to model the use case where
state needs to be shared across
different clients while it has its own
set of features it has a lot of
commonality with other session beans too
it's inherently designed for
taxes because it's internet for sharing
state as far as commonality with other
session beans you see that it exposes no
Affairs local remote as well as jax-ws
and jax-rs client views
it supports container manage
transactions as well as beam manage
transactions the same container services
whether it be method authorization or
time or service or all the other eg via
timer services continue to be available
for single transition bean still so
here's a POJO
which is named have conflicting it
stands for application configuration
being shortened to be able to flick on
the slide and then you have config data
which is a which you can think of has a
memory representation of your
application configuration and the
assumption is that you have a post
construct method which is not shown here
which creates the config data it could
be populated from a properties file from
an XML file that you guys have or from
say a database and you have a gate
config value which takes a key and
return the configuration corresponding
to that and similarly have updated
configuration values where if you want
to provide a way for users to be able to
update the application configuration
whether it's sis admins or whoever so
now if you need to make this a single
turn all you need to do is ID at
singleton or you can do the same through
the descriptor so as far as the client
goes it's fairly simple - all you need
to do is use your a tjb and you can
inject based on the type in which in
this case it's a no interface view so we
use the beam class which is a config
bean now so we talked about how
singleton session beans are designed for
concurrency so there are a couple of
concurrency options you can use
container managed concurrency or you can
use bean manage concurrency container
manage concurrency is the default so for
container manage concurrency the
expectation is that the user is going to
provide the locking metadata as to what
kind of locks are required for each of
the methods and the container does the
actual locking so there the locking
style is read/write style locking so
concurrent reads are allowed and rights
are exclusive and the locking metadata
can be provided through your descriptor
or
through annotations and if you're using
annotations you can do it at the class
level as well as override it at the
method level by default all methods are
right locked so the singleton session
bean is thread safe another annotation
slash material that's available for a
container manage concurrency is access
timeout where if you want your lock
request or timeout of a certain amount
of time instead of waiting forever you
can use your access timeout annotation
as far as reentry entrances semantics go
a write clock holding thread can reenter
for read or write and a read lock
holding thread can only reenter for
reads and cannot upgrade to write lock
it's very similar to what you would see
with java concurrent
if you're familiar with the row in front
row read write locks so we get back to
the app config bean that we looked at
before we annotate it at singleton and
we look at the gate config value it's a
read method so we say alright we're
going to specify that this method needs
to be read logged and we provide the
access timeout saying that the access
time mode for this guy is 500
milliseconds now update configuration
values is doing the right so we provide
the metadata saying that you need to
obtain a write lock for this so the user
just provides metadata and the container
takes care of doing the actual
underlying locking so the other option
is being managed concurrency so it beam
manage concurrency the container does
not do any locking so any incoming
invitations will get access to the bean
and it's really up to the bean code or
vanilla / to make sure that the instance
state is accessed in a thread safe
fashion and mutated in a proper fashion
- so he can use any of the options here
you can use Java concurrency lock KPIs
or synchronized or volatile or any other
mechanism that he sees fit to make sure
that the bean state is handled correctly
for concurrent usage so here's an
example so you have a cache bean so you
specify one of the new things that you
see here is you do specify the I guess
concurrency management type has been
because the default was container and
then you see that the user can use
synchronized here and in the
case you can see that he can do finer
grain locking than the method level he's
doing some computation and after which
is going to try to acquire the lock so
that's one of the benefits of using beam
managed concurrency that you can do
finer grained locking so initialization
and life cycle so single transition
means like other session beings get post
construct as well as pre destroy
lifecycle callbacks one of the things
that is unique about single transition
beans that we kind of alluded to before
is that the callbacks are transactional
by default so whatever is your beans
transactionality if you set it to be
container managed transactions or bean
managed transactions the same applied to
post construct and pre destroy so the
key benefit is you can do transactional
work as a part of your construction and
destruction now so one of the other
things that has been that is unique to
single dances they have an ex start up
annotation the at start up annotation so
by default Singleton's can be
initialized whenever the container needs
it it can be initialized eagerly or they
can be done lazily the at startup kind
of is a mechanism for the user to say
that I want this singleton to be
initialized eagerly now what this
provides is if you combine your head
start up annotation with your head post
construct it turns out to be our
application startup callback so as a
part of your deployment when your
application is starting up the container
tries to initialize your singleton
because you mark it as at startup and
now since you have post construct there
it's going to invoke the post construct
so if you want to do anything as a part
of your application deployment for the
particular singleton you can that would
be a place to do pre destroy for
Singleton's get caught for any singleton
that has been initialized the container
does the pre destroy callback as a part
of the application shutdown so that
would be a place for anything that you
want to do as far as shutting down goes
now the key here is that it needs to be
a graceful shutdown and the bean needs
to have been initialized
otherwise you wouldn't see a prettier
strike all that happening so here's an
example if a singleton session bean
which uses at startup it's a cache bean
and it has a post construct annotation
on a prefetch cache data which you can
think of as the method which would load
up or pre populate your cache
so even your first hit to your singleton
cache wouldn't take any additional time
so the setup of the cache happens is a
part of the deployment and you have
really system resources which you can
think of a method which whereas the one
that would release any system resources
that it's holding on to which would
happen as a part of your pre destroy as
a part of the application shutdown so
another feature that is unique to
singleton session being depends on so a
single transition beans can express
their dependencies on other single
transition beans using the add depends
on or the descriptor equivalent and when
a single transition being declares is
the container ensures that all the beans
that this particular session being
singleton session mean depends on are
initialized before calling the post
construct for this particular beam and
the same holds for pre destroy that when
the pre destroy for this particular beam
is called it's dependencies are still
available so if you have a session being
a B and C depending on B and B depending
on C then C would be initialized first
as it doesn't have any dependencies then
B would be initialized following which a
would be initialized and the destruction
order would be reversed where a would be
destroyed first following which it could
be B and then it would be C all right
switching gears so the next one is an
async session being invocations so
before e 6 if you had to do a synchrony
with ejbs
the option was to use JMS with MDBs
which was fairly heavy variate if all
you needed was lightweight asynchrony
with EJB 3.1 asynchronous support was
added for all session bean types by
default all session bean methods still
continue to be synchronous so you can
add either it at a synchronous or you
can use the descriptor equivalent to
make the method asynchronous and when
you mark a method as asynchronous as you
would expect when you call the method
the control returns back to the caller
right away and the execution happens
excuse me get scheduled and happens at a
later time or concurrently on a separate
thread so there are no persistence
guarantees here unlike JMS it's really
lightweight asynchrony
as far as method authorization goes it's
very similar to synchronous calls you
can still use declarative as well as
programmatic security security does get
propagated of the caller as far as
transactions goes there's no propagation
of transactions from caller to the
callee
so if you have a required method which
are marking as asynchronous the caller's
transaction doesn't get propagated and
you'll still end up creating a new
transaction your remote local level has
no interface views all of them support
asynchronous methods you mark or beam
method as asynchronous so all the client
views through which it gets exposed will
be asynchronous so for asynchronous
methods you really have two types of
returns they can either have a white
returning type where the caller doesn't
care about the return it's kind of a
fire-and-forget style or you can have a
Java it with concurrent future returning
method where the caller does care about
the result so let's move on to a quick
demo or we doing on time
okay all right so all right so let's
come to a sink here so the first one I'm
not going to go into an demo I'm just
going to show you the code so you have
an employee object which is a entity
which is a persistent entity and you
have an employee management stateless
session bean which you can imagine
manages employee objects so here you
have an ID new her method which takes an
employee and the first thing it does is
it forces the employee in addition to
persisting an employee there's a lot of
other stuff that he needs to do we need
to do when you have a new hire or you
want to create a mail account for them
you wanna order desktop you an order
office supplies there's a lot of other
tasks that need to be done but they
don't need to be done synchronously so
here's an example where you have all
these methods that get involved but all
of them are asynchronous so the call
returns right away it schedules all
these tasks and returns right away so
here's an example of the word returning
now let's look at something that
showcases the future returning type so
here's a rapport generator beam which
has a generate header which has a
generate body which takes a start and
index has arguments and there's a
generate footer which generates the
footer so in this case you see that all
we are doing is sleep but in a real
world implementation you would have the
actual computation here so another thing
that's of interest here is the async
result object so async result is a
convenience class at EJB container Java
X EJB API provides which can be used to
wrap your result into a future this
number gets to the user who's just a
convenience so that you can keep the
same signature on your beam class as
well as the interface now if you look at
the colouring code for this okay you
have a oops you have a report generator
servlet here which injects the report
generator and then calls on it and say
is generator header from a generator
body for one two thousand and thousand
one to two thousand two thousand to
three thousand and three thousand one to
four thousand and a it creates
all these futures and then says okay I'm
gonna iterate on all the futures and do
a blocking get sequentially and all of
these are going to be executing parallel
E and then I get the results I append it
to a report and write it out to a
response output stream so let's look at
this demo hopefully this'll work you
know
okay I'm gonna deploy these tomorrow
okay so okay let's go and see so here's
the async example let's see how long it
takes to load up one Mississippi two
Mississippi three minutes okay so report
got generated a bit faster so 5 5
seconds since we were just doing sleep
all of them then concurrently and we
were able to get back pretty fast so
this is an example where he is a future
API that's a return type so now four
methods are using javac you can print
future you have the ability on the
future to check the status whether the
call has been completed or if it's been
cancelled you also have the ability to
get the results like we saw he can do a
blocking get as well as you can do a get
with the time owed if you want a time
what of after waiting for a certain
amount of time now there's also a
ability to retrieve the exception so
your get call would throw an exception
we should be of type execution exception
and you can do a get cause on it to get
to the underlying EJB exception
there's also ability to cancel cancel
takes an argument though interruptive
running for the EJB implementation the
container is not expected to cancel if a
invocation is in progress it's only
expected to cancel if the invocation
hasn't started yet so if you get in
future and you call a cancel you're not
really sure that the cancellation has is
going to succeed there is a return value
which tells you whether a cancel has
succeeded or not
however the maybe if interrupts running
has a useful functionality here if you
pass that in is true then in your beam
code you can use session context and try
to check if that particular invocation
was cancelled and do the cancel they try
to return so here's an example of that
so you have a dock processor which does
transformation it takes a collection of
dock inputs and it's marked as a
synchronous as it iterates through the
various dog 58 checks if any of the dock
was if if the indication was canceled at
which point it just breaks and returns
from there without continuing the
execution there are changes in this area
that marina will
due to which are being planned for HIV
3.2 think with the HCG be timer service
and marina what kina will continue the
presentation from here how many of you
are using the latest and greatest AGP
timer service okay we will go through
this how many of you know details of
standards global JDI names okay we were
rushed through that embeddable container
okay quickly and EG be light okay let's
see how what can we do worst-case
scenario I will rush through the ETP 3.2
stuff so the timer service so time
Ursula's divides into a programmatic
timers and automatic timers programmatic
timers is when you create timers in your
code using timer service API and
automatic timers will be created for you
by the EDB container at deployment there
is misalignment both of them can be
persistent and non-persistent obviously
persistent timers is the timers that
container stores somewhere so that if
the server crashes and restarts and
there was a missing timeout the
container will make sure it is executed
for the non persistent timer the
container has no knowledge well it's
down they differ on the behavior between
programmatic and automatic timers in
what what happens
so programmatic timers are single action
you just define the date or the interval
after which it fires and that's it
it's end of its life interval timers
it's all old stuff
I'm just for the sake of the picture
repeating that interval timers is
obviously timers that travel at a
specific interval and calendar-based
timers is something new in 3.1 I'll go
into more details next slides for
persistent timers there is a single
timeout method on each beam so how many
timers you create from that beam all
timeouts go to the same method annotated
with timeout and no persistent timer if
container goes down unless you're a
executes the method that created that
timer it's gone okay because there is no
knowledge now automatic timers are
always calendar based timers there is
nothing else calendar is click current
style so you can do a lot of things with
it but that's the only way each at
schedule or schedule and deployment
descriptor and defines the timeout
method so you can have as many method
timeout methods in your bin as you have
schedules or you can buy in several
schedules on the same timeout method and
so it will execute for each schedule
each schedule is completely separate now
when a calendar based automatic timer is
deployed into the cluster then a
persistent timers is guaranteed to be
run only on one instance in a cluster
independent of the number of instances
and no persistent timer will be running
on each and every instance because
instances don't know about this about
each other and what's interesting about
this also no persistent timers are
started so if you cancelled it during
the execution container crash the
container was stopped restarted your
timer is created again so what are
calendar based expressions there are no
nanoseconds seconds is the lowest
denominator
they are obviously
normal digits what's interesting here
second minute and our default is zero so
if you don't specify anything it will be
midnight and if you specify our only it
will be at the top of the hour year
obviously is footage it also the rest is
the day here month is default estar so
midnight of every day is pretty much a
default time on day of the week zero and
seven both Sunday do not Sunday you can
use standard English three-letter
abbreviations and month is your obvious
choices now this is more interesting you
can specify day of the month is normal
day of the month and if you specify 31
for February it will fail you can say
lost whatever is the lost well you can
say up two searches up to seven days
before the lost and they continue
calculate each month what it means and
you can have a combination of an order
and the day of the week it can be lost
Sunday first Monday's third Tuesday and
such and default as I said always
everything you can combine those options
into some rules obviously there is a
single value list is a comma separated
values you can have a range and the
range can go over the the end so here it
is from 27 to whatever the end of the
month and then to the third of the next
month and for the day of the week you
can also have Friday to Monday which
will be Friday Saturday Sunday Monday so
world card is obvious increment this
particular example says starting from
the beginning every 10 minute but if you
say start with 5 it will be 5 15 25 35
and you can have a list of ranges and in
that list of ranges can be single values
mix of ranges and single values
I'm sorry if I'm rushing through but we
have one thing to go through so it's
passed already known but the timer that
would have expired
today at noon can be specified as our 12
day of the month - and month October it
can be specified as our 12 day of the
month first Tuesday right today is the
first Tuesday in month 10 which is the
same as October it can be on any second
of day of every month at noon it can be
on any Tuesday at noon it will still
have expired today at noon obviously
every day at noon or every Tuesday and
Friday at noon would have expired today
at noon so an example for automatic
timer you would use schedule annotation
and this is another option of today at
noon this is every month first month in
a quota first Tuesday in a quarter and
the schedule will denote your time out
method for programmatic timer you will
use schedule expression or with fluent
API to create an expression then you
would use time of service to create a
timer and you will specify the time out
method on European you can see that the
first one is no arc and the second one
has timer these are your only two
options time out method can either take
a timer and with eg b31 this was relaxed
and said if you are not interested in
the details of that timer you can have a
no arc method portable jndi names this
is a very useful feature if you are
porting your application from one
observer to another because now you
don't need to figure out how each
observer creates exchanger names there
are always different for each edge Aveda
four types of
change our names but we will look into
Java : Global first so the prefix is
Java : global okay so f name is optional
it is if you deployed your being into a
year inside an ear then app name is
present if there is no ear if it is a
war or jar that you deployed then app
name will be missing the slightest it's
not quite right so module name is the
name of your module and you can override
the app name and your application XML
and module name in eg BTR XML log
web.xml because it will be the name of
the war and both types - dot suffix and
bean name is you're unqualified being
named by default if this being exposes
only single view it what remote local
knowledge FS doesn't matter that's
that's enough you don't need anything
else
if it exposes more than one view then
you for issue you each specific view
that you are looking up you would say
dollar and then the fully qualified view
name which is for no interface you will
be the fully qualified being close name
and obviously this is for local and
remote note that face as I said and
there are shortcuts for Java code on app
to look up in the same application in
Java code on module in the same module
so if you have a Hello bein that you
deployed the long way inside of my
module jar and hello hello here it will
be Java : global hello is the name of
the ear my module the jar and hello bean
inside that ear you can look it up from
a different eg vo servlet that is a
separate war Java : F and then only the
module name and
in and inside the same module this been
as available without any knowledge of
the packaging Java : module Colombian so
if this been implements an interface and
assuming it also is marked for as local
being that particular view will be with
the fully qualified
interface named embeddable it should be
container so Trini mentioned that embed
apology be container is something that
is intended for testing it runs in the
same VM as your unit test and let's we
don't have time for the demo so there
are very simple API you created you be
container by creating a GB container
embeddable Achebe container in your VM
it the same you don't deploy anything
this magic method scans the classpath
for any directory or jar that contains
eg B's and deploys them if they're a
single jar it will be a single jar if it
is several jars are I will create an ear
file for you in the background so when
this method returns you have all AG B's
deployed you can pass a map to this
method to choose specific module or to
choose specific file to load but by
default the whole class path is scanned
you can get the context you can look up
your local eg B that's the most
important thing otherwise normally if
you have only remote client before that
when you if you deploy to a regular
server you can do this only from inside
that ear or they say that jar or from a
remote client and you call your local
bean method and you don't forget to
close the container to release all the
resources and we should make it close
above in freedom
but again the main idea to be very
easily testable and the container is
portable when we 3.2 we clarify that not
each vendor is required to provide the
embeddable egb container because let's
say cloud vendor does not have a notion
of your local testing but most already
provides so it's we don't think it isn't
that big of a deal
okay egb light is a subset of features
that is available with java 6 you have a
profile and full profile with egb
packaging in a war or you can have you
know just a war file deployed and in web
profile this is the list of features
that will be available to you eg bees
and the bottom is you know simple GP
security transactions interceptors the
important thing is this all the local
views are available in the light and
light is guaranteed set up a set of
features in the web profile and
embeddable Achebe container so it's
guaranteed to be testable only EG
delight some set of features ok and now
we're going to the future so eg be 3.2
is working progress
it's GSR 3 4 5 3 4 5 easy to remember
EGR is published on the GCP side but
because we are on the 2.8 GCP rolls we
have everything in the open you can
subscribe and tell us your opinion on
anything you can and users alias
receives a copy of all export group
discussions you can search archive you
can file issues and
you can download the latest and greatest
version of this bag that is not updated
on JCP that are like three of them and I
upload as soon as I have time I upload
the next option to the egb spec project
so the main themes are continued with
ease of use obviously we remove
unnecessary restrictions for example
Egypt is back up to now is still saying
that you should not access files how
many of you are accessing files from
which it is okay we remove that
restrictions we removed restrictions to
access the contacts class loader we I
mean we went a little bit through that
list so if you have your pain point
subscribe to the users alias send us a
note we will look and this is if it's
obvious we'll remove that restriction we
move away and use features optional
features there would be a separate and
we clarify we go with the comb through
this back and say okay how do timers
work in a cluster what is expected from
distributed timers what is expected how
transactions and interceptors let's make
sure that the spec is very clear in each
point what's in you are stateful session
being lifecycle callbacks can be now
made transactional for backward
compatibility they are not so you need
to opt in by specifying transaction
attribute requires you and it's always
requires new because even in the
singleton lifecycle callbacks run in
post constructor on its own transaction
and the same thing is for pre destroy if
you need to make it transactional you
can opt in and you can do it with the
deployment descriptor as well you can
opt out of passer ation if your stateful
session being needs to stick around or
it has not
serializable fields that will cause a
crash and removal of the beam during
passivation you now can opt out of it we
simplified the rules relax the rules on
defining alok all views of the beam so
if in our example being a implements two
interfaces and besides what is they on
the screen nothing
no annotation or no deployment
descriptor say anything else
so foo and bar do not have any they are
not denoted in any way but in on their
own then foo is automatically a local
view and bar is automatically local view
you don't need to have that at local
food dot class comma
Martok class obviously if your being is
explicitly marked as local it is the
same as the previous because by default
being as local so both foo and bar
unless they are denoted otherwise become
the to local views and the same for
remote if your remote being implements
several interfaces and those interfaces
don't differ define anything in your
rules of their own they automatically
become remote interfaces timer service
got a new method get all timers to
return all timers and the same in their
mobile there for displaying purposes
because the limitation is that only the
beam that owns the timers can cancel
them MDBs got alignment with GMS to all
and we enhance the list of standard
activation config properties by just
defining them
if you use them there will be recognized
egb 3.2 light go to more features in its
list local are synchronous and vacations
we found them useful to be available in
the war files in the web profile and non
persistent timers so with no persistent
tremors if your app has programmatic
persistent Tanners a deployment time the
container won't know that so you the app
might fail later on with the automatic
timers obviously the container won't be
able to create them it will fail fast so
these two features will be available in
the web profile and testable by the
embeddable Achebe continue removing
features so a GB 3.1 marked three
sections as proposed optional and we're
making them really optional and not only
optional we are moving them to a
separate book of its own 200 plus pages
which reduces the side of the size of
the core document because they were like
in the middle and you needed to kind of
go through them without any use so CMP
BMP and Jack's are PC and now optional
your vendors a GB vendors are not
required to support them but if they do
support them they might support CMP as a
whole CMP they can't pick up like a GB
Cleo and provide it by itself it needs
them to provide support for the cmp okay
the rest is a discussion and progress
that you can vote still on and voice
your opinion as Trina mentioned the
future council right now works if you
want to short-circuit your execution of
very long running a sync method the only
way to check to do that would be to
check the session context but if you
call another beam then beings context is
synchronous and you can't can check out
there so what we are discussing is
actually interrupting
then your code will be able just to use
normal JDK to check who thread was
interrupted and then the other
interesting part is that if this dune
export was waiting on a cue or some
other interrupts able condition it can
now be will get that interruption and
won't wait forever until you know your
code is executed
we are discussion discussing the details
of backward compatibility but most
probably this thing is in the rest is
really under discussion how we're doing
we have five minutes so Marx concurrency
is something that people were asking
it's not clear for us how to define for
a synchronous vacations because if you
have ten a synchronous methods and each
of them will define its own pool or use
you know point to the same pool and say
max 10 they might just exhaust the the
pool by themselves we are trying to
figure out what to do about that and how
to define the behavior when there are no
threads then what a synchronous method
should should do client choice of
whether to call synchronous method or
synchronously this is a tricky thing but
jax-rs now adding a sync will define an
API how to choose - whether to call a
method synchronously or asynchronously
jax-ws does Co gen so you can choose but
in a GB you can convert a synchronous
method into synchronous by doing future
get if it returns future and block for
our but you can say that synchronous
method I'd rather run at this point a
synchronously there is no way we we were
with trying to figure out what to do
about that but we don't want to make it
ugly
so on crystal ball if you're asking
what's the crystal ball about the future
of eg be its decoupling components and
Enterprise Services eventually making
enterprise services of a GB by default
available on a GB but an ability to opt
in into them in other managed deals the
first step is CMT container manage
transactions on CDI beans that is being
discussed at this point it seems that
egb will continue doing what they were
doing before and CDI beans will use the
new interceptors but there's still some
clarification that need to happen on the
next thing that will probably become
decoupled is the timer service not
necessarily in this release CMT proved
to be not as straightforward as we
thought log startup depends on from
Singleton's is quite useful to be
available on other beans and in other
parts of this discussion whether they
are CDI managed beans only or au managed
beans being managed method validation
from bean validation eg B will support
them in 3.2 and the decision is it's not
yet in the spec and the latest version
of the spec it's kind of an agreed-upon
item that even if CDI is not enabled it
will be available for all AG B's an
interesting talk today at 1 or here in
the poll I think David Blevins is the
proponent of improvement in the non-gm
SMD B's connector IMDb's to make them
cool and chuck Sarah's tile it's an
interesting proposition if you have
didn't sign for anything else go today
at one and listen to David David talk
there are other items in the pipeline to
become proposed optional if you don't
know what so there is it it's a two-step
process you can't make some
optional right away they need to become
proposed optional and then maybe in the
next release or release after they will
become really optional so there isn't
enough time for developers and vendors
to prepare so 2 dot X home and component
views might become optional eventually
they will become final eventually but
the question is when all remote client
use the the route right now is to move
to web services as the clients so there
is a discussion of removing a remote
client from egb spec and Interop there
is a big push to make it optional no not
probably not as much from developers as
from vendors because supporting Interop
is a big thing and we're like one minute
before an hour where we are done with
the presentation these are reminders
where you can get all the information
about the TGV 3.2 other questions we
have 30 seconds
but yeah we can probably stay a little
bit and we can definitely take questions
outside thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>