<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Implementing Ruby: The Long, Hard Road | Coder Coacher - Coaching Coders</title><meta content="Implementing Ruby: The Long, Hard Road - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Implementing Ruby: The Long, Hard Road</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LfdldZ5H3b0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">talk a little bit about implementing
Ruby jruby specifically on the JVM some
of the challenges we have basic
introduction I am a co-lead of jruby
still also just kind of do general JVM
language stuff JV optimization stuff
kind of a JVM advocate uh it was what
son then engine yard and now at red hot
in the jboss is polyglot group where
we're doing a lot of fun stuff so onward
to JRuby JRuby is at you know Ruby on
the JVM nothing too fancy about that
we'd like to think of it as a better vm
for Ruby and you know it's kind of a
nice language for the JVM it's a
two-part thing they're mostly
implemented in Java it is pretty much
the fastest ruby implementation there
are you know others that are working on
trying to beat us at this point but
right now pretty much the fastest and
with the first Ruby actually have real
parallel threads because we got that
free from the jb m it is also impossible
there's so many challenge that we've had
to deal with in the process of
implementing ruby and implementing all
of its various platform levels behaviors
and all of its different details in the
language itself that you know this
shouldn't be possible and a lot of
people told us this is not something
you're going to be able to do it's never
going to run well you'll never we all
support all of these different features
of Ruby and we didn't listen so a little
history about Ruby itself and jay ruby
ruby was born in 1993 so the concept of
ruby is actually older than java itself
i think the first 10 version came out
around the same time as java in nineteen
ninety five or so jruby is one of the
older JVM languages as well actually
started in 2001 i think had actual
running code simple ruby implementation
within about a year after that i joined
the project in about two thousand four
started to work heavily on it in 2005
and then 2006 we managed to get rails
running we managed to get a presentation
at javaone and from there kind of just
ramped up very rapidly once we joined
son so why is JRuby impossible there's a
few areas that really have been
challenges for us that many of these
remain challenges to this day
I'm going to go into each of these in
detail talk about what we've done to
work around them or to solve these
problems and hopefully how the libraries
we've come up with and the work that
we've done will be useful for you if you
run into any of these same sort of
issues so let start off with a byte
array based string when J Ruby's first
first design ruby is all mutable strings
so it was originally string was
implemented as using a string buffer and
that works reasonably well if you're
doing all just text based data but Ruby
uses the same structure string for
binary reads out of i/o objects for
writing binary for doing various types
of encoded text so having only string
buffer which is only utf-16 characters
was a problem for us and actually ruby
1.9 in the same run of an application in
the same process you can have multiple
strings that all each have their
associated with their own encoding so
that you can handle multiple encoding is
coming and going different locations
transcode across all of those and not
always have a common not have to force
everything to an intermediate format
like the JVM does debate whether that's
a great decision on the Ruby guys part
or not but it's how it is it's half with
something we have to support the other
thing about this is that we needed a we
need to be able to use the Java API is
ideally so we stuck with character bit
arrays or stringbuffer string or string
itself for a long time just because we
wanted to be able to use those Java
strings but over time we realize more
and more that to represent rui strings
as Ruby does we're going to have to use
a byte array and again this is this is
one of those impossible things we lose
all of the api's that work with strings
directly we have to do a lot of stuff on
our own but we try to give it a shot we
wanted to see if we could do this to
make it work and make it match Ruby
better so for this we started out having
basically a bite list which is kind of a
like a string buffer for a byte array it
allows mutation allows slicing allows
copy-on-write and it also includes
encoding as part of that so it's
basically a byte array based string with
arbitrarily encoded text in it or
perhaps not encoded at all binary this
is I think probably the only one class
maven project in the world but it is out
there and you can you pull it interview
need a string buffer that's got a byte
array behind it very simple walk through
of using it more pretty much like you'd
expect stringbuffer to work construct a
new one you can specify a backing store
size that you want for it append bites
into it append other bite lists into it
or individual characters individual
individual bytes you can there are some
utility functions for turning java
strings into byte arrays using various
different encodings getting the actual
getting the copy of the bytes out or the
view of the bytes which is kind of like
the two string on a string buffer or
getting the raw bytes out which is an
operation that a lot of people wish you
could do with a string buffer rather
than making a copy every time and then
you know we maintained begin in length
internally in JRuby we kind of do copy
on write operations to avoid the buffers
getting recreated too often but it's a
nice little utility class and hopefully
we'll put more of the copy on reddit
stuff in there over time too so now we
have our byte array structure we have to
have something to represent and coatings
and for that we have a project called J
coatings this is basically a set of
character tables character encodings
utf-8 utf-16 of big and little n 32 lots
of Japanese encodings european encodings
more in coatings then typically are
available on the JVM and we can support
these at runtime in any Ruby string
along with the encoding and transcoding
of all this stuff it has information
about the character tables the
multi-byte character offsets how to do
searches character by character searches
and all the different encodings and this
is mostly generated from standard
Unicode tables and information about
these encodings from the standard places
we recreate this and that feeds into the
rest of the system for doing character
access and regular expression work so we
get a structure kind of like this for a
JRuby string Ruby string I or gates a
bite list the byte list itself
aggregates a byte array and an encoding
and then we do some tricks with in Ruby
string to like a flag to indicate that
it's all we know it's all 7-bit ascii
we know it's all a bit a ski we know
it's all utf8 things like that to avoid
doing wrong multibyte character searches
when we know we can do random access and
so we're good we've got our string
essentially which is a byte array and
encoding but we need things like regular
expressions like I said we lose all of
those ap is that we have normally on the
JVM for Strings so what about just using
Java util regex well of course we use
this with strings back when we were
using strings and string buffers and it
was worked and it was free for the most
part but if we're to use that now we'd
be transcoding things to and from string
or from character array every single
time and for a while we did this we took
the performance hit because we knew we
needed the byte array strings but it
just really did not scale over time too
many objects too much transcoding and we
had to get rid of it there are also
cases in some Ruby applications and
libraries where they'll use a binary
regular expression there was a case in a
rails version where they actually were
checking for jpeg and PNG headers using
a regular expression that is really
difficult to do in javas register
regular expression stuff because it
expects to be working entirely with
character data and it's all character
arrays so getting the binary data in
there in the first place is very
difficult to do without mangling it in
some horrible way the other problem with
Java util regex is that is just broken
there are very simple regular
expressions that can cause java.util
regex to blow the stack completely out
and even just completely little bits you
get slightly more complex regular
expressions even with not a lot of data
can blow out the stack because of the
way it's implemented and we did run into
this one of those cases with doing
regular expression based parsing of mime
input which could be arbitrarily
arbitrary length had a couple
alternations in the regular expression
below the stack regular very easy I have
a blog post about this and then we went
through a couple different
implementations of regular expressions J
regex if you're interested in one that
does not have these problems and works
pretty well is probably the best one we
found that was character based but what
we needed was a byte array based regular
expression we didn't want to have to
transcode or copy the data out of our
strings every time we're going to do
regular expression
matches and so we had to come up with
our own we need to be able to work with
bites directly ideally we needed to be
encoding agnostic which there's not many
regular expressions that can even do
that we obviously didn't want to blow
the stack and we wanted to perform well
and of course this is another impossible
thing but we had to find a way to do it
so initially we actually ported from see
the regular expression engine that
regular see Ruby uses which is a fairly
naive version of only supported ascii in
utf-8 and it was it worked pretty well
at least got us off of Java util regex
and character based and transcoding
overhead over time though we needed to
be able to support what ruby 1.9 uses
which is a regular expression engine
called own ego rumah means like text
monster or something in Japan and
Japanese but it is actually a large c
library for doing regular expression
matching on raw bytes with arbitrary and
coatings and with pluggable grammars as
well this is the rail expression engine
that ruby 1.9 adopted early on and the
only real option we had was to ported
and luckily the magic of open source we
had a contributor that took a look at
the code disappeared for a month and
came back with a java port of ona guruma
for us just like a gift from heaven and
was actually faster more stable and
better than the original one so awesome
yes yes so we'd love for this they
actually become something that's in Java
may be replaced java.util regex so it is
a bytecode machine it will not blow the
stack there are of course like any
regular expression engine there are
extreme cases where it may run forever
but it doesn't have nearly as many
failure cases as Java util regex does
having a pluggable grammar is nice it
supports new POSIX I think pearl and you
can define additional grammars and a
different additional regular regular
expression syntax is for it if you like
it's it would be very easy to turn this
into a JVM bytecode compiler as well and
then you
actually have JVM bytecode addreg Uhler
expressions that would run as fast as
Java code doing that match directly so
that's something that we're hoping to
work on soon maybe we can get our friend
to reappear and work on that as well or
maybe one of you would love to do a
regular expression compiler so like I
say none of Java util regex is
catastrophic cases arbitrary encoding
support and there's the link for the
project on github so a quick little
demonstration of it one of the big
things we need to work on is a better
API for it but you can see the basic
structure here so the inputs here are
going to be options for things like
multi-line etc the encoding you want to
use which is going to be a J codings
encoding utf-8 windows-1252 whatever you
want and then the syntax there's a few
that are built in and you can define
additional ones so we've got our bite
representation of the regex this could
easily come in as a string with an API
improvement and we've got the actual
string that we're going to match against
create a new regular expression with the
pattern the options encoding and syntax
and from here out it's pretty much like
Java util regex usage we get a match or
based on a string and we specify what
array of byte what range of bytes in
that string we want to work against and
then we do our matches are searching and
pull regions out of it to get different
groups that we've matched very simple
and very and much better than Java util
regex for us so use cases for this
obviously alternative string
representations like we have in JRuby is
a big one anything that you have stuff
in bytes we can match if you give us an
encoding in a syntax and that actually
kind of opens up some interesting
opportunities anybody that's using
regular expressions to do a parsing or
matching off of ngaio streams and i/o
streams you have to do that you have to
transcode all of that data into
characters right now then do your
matching and then possibly turn it back
into bytes if you're going to work with
it from there we could actually work
with the bytes directly from this
regular expression engine and never have
to do any transcoding at all and in fact
do the regular special matching in the
native encoding of whatever that data is
coming as rather than turning into the
utf-16 at all like like I mentioned this
alternative that's supposed to say
pluggable
alternative regular expression grammars
that could be plugged into this so if
you have an unusual grammar that doesn't
fit the new or POSIX we can look into
finding a way to add a plug-in or an
additional syntax to it so hopefully
this will be useful for other folks to
do cases so the API needs a lot of love
it's very raw you pass in a byte array
and arrange for the pattern a byte array
and arrange for the string and it's it
can be a little hinky as far as error
cases and exceptions when it works it
works fine when you have an error it's a
little bit hard to sort out where the
parsing problem is it's not the problem
in the engine it's just a bad reporting
mechanism for bad regular expressions
the jbean bytecode back in would be
awesome to have because it would really
improve the speed of it if it's
comparable to Java util regex even as it
is but having a bytecode back-end would
be even better now we're actually
talking a little it with the nazarone
guys it would be nice to have this
regular expression engine or something
similar or something modified actually
be java.util regex so that everybody
who's doing the same sorts of things
large alternations more complex regular
expressions would not have the same
problems that we ran into so possibly
looking at maybe doing a Joni version
that is just character array based but
gives you all the benefits of pluggable
sin taxes and the bike coded engine
behind the scenes so there'll be a fun
project search and replace ok so the
next big area that we ran into is that
we needed our i/o layer to basically
mimic pose xio needed to look like Lib C
i/o operations because that's kind of
Ruby kind of just wraps all the POSIX
functions in a loose class structure and
so for us to be able to match
behaviorally we basically needed to
match how Lib C write and read in
different different calls at the native
level behaved buffering wise and whatnot
so blocking and unblocking need to be
able to turn streams from blocking to
non blocking or have the same calls
against the same streams like you can do
with the raw POSIX API buffering and
unbuffered different forms of buffering
like line buffering arbitrary and
coatings so we need to be able to read
stuff in and
apply different encodings to it or do
transcoding on our terms as we read or
as we write and you know the exceptions
that we would get in regular see Ruby
often just mapped to the air numbers
that would be at the raw POSIX level so
we had to kind of simulate those we
needed to have the same exception
structure for people to be able to build
Ruby I Oh heavy systems on JRuby again
impossible to do all this right we can't
get access to raw posix stuff we can't
simulate all these things but we thought
we'd make an attempt at it anyway so we
came up with is basically a set of POSIX
II wrappers around niño classes they
use niño channels directly they do
their own buffering but they allow us to
simulate essentially all of the
different pose xio behaviors so we can
do things like like an f open that gives
us a stream with buffering on top of it
we can do dupes so we can pretend that
one channel is actually in you in two
places at the same time the buffering
characteristics selection on different
types of streams all pretty much looks
like the Lib C API which made it simpler
for us to duplicate Ruby's
implementation of its IO and file
classes did spend a fair amount of time
reading G Lib C source I do not
recommend it but when you got to figure
out how it's actually doing the
buffering internally when it's flushing
when it's doing sync operations there's
no better place than the source and
there's really no good libraries for
this you have the standard java dot io
stuff which does buffering but you have
to kind of pick the the version of
buffering they want to give you you have
to deal with the fact that you may have
two or three levels of buffering whether
you actually want it or not so you can't
actually get at raw raw channels in a
lot of cases and you can't do the
buffering on your own terms and so we
had to kind of just build our own stuff
so the first class is channel descriptor
basically just mimics a file descriptor
like API and wraps a channel directly so
this is your open your read/write doop
doop to the standard POSIX functions for
dealing with file descriptors directly
it wraps a channel and so in order to do
duping we have a reference counting
system so we know how many different
places have an access have a
reference to that channel and then we
simulate that we've actually got
multiple descriptors available in memory
and then we actually do simulate file
numbers or file knows by having a weak
internal table of all the channels and
the file numbers that they're associated
with so we can simulate file descriptor
numeric numerically even for channels
and streams that don't have a file
descriptors available at the Java API
level channel stream is the next level
up simulates a file star in pose X the
wrapper around a file descriptor with a
buffering and whatnot and so this is
your f open f3 def right etc we have the
basic buffering modes that you would
expect internally try to buffer pretty
much like Lib C does and we do have some
support for auto closing which you know
via finalization is not very guaranteed
but it's one of the things we've added
in there to support Ruby's auto closing
which it does have love these
implementations with crappy GCS okay so
the next level there is is actually
being heavily I'll have a selector logic
we do various tricks to try and simulate
selection over all types of channels
that we can for the most part this only
works on sockets and pipes you can't for
some reason do selects on standard i/o
or process io in the Java API thanks
very much so we have to do other tricks
to kind of fake that stuff we do also
have a pool of these to make sure that
we don't burn through selectors too
often but essentially trying to simulate
at what we'd have at a POSIX level with
just a select call and then just build
it on top of the JVM selectors which r
KQ and you pull and other stuff so use
cases for this well obviously you can
have raw n IL level performance on top
of this stuff and not have to worry
about the buffering characteristics of
whatever stream you're using better
control over how the buffering works and
how syncing happens and if you need this
sort of semantics that lib sea gives you
this is much closer to it than any of
the java io classes all right some to do
is here this one has never actually been
externalize as a library there's a few
hooks back into JRuby of specifically
for managing the file know the ft
the table that we have for managing some
of the reference counting stuff but we
can pull it out and make it externally a
library if this folks that interested in
having a very fluid very flexible
buffered wrapper around niño
essentially we want to clean up and
match Lib C better try and just actually
build out all of the different file
descriptor and file star functions
semantically so they match exactly what
Lib C would do in those cases but
wrapped around channel improve the
external API it's kind of grown
organically so it needs a little cleanup
and better selecting channel support
which I'll show in a little bit how
we're actually going to try and do
select on non selectable channels ok so
more POSIX tough again like I said Ruby
is largely a language wrapper around a
bunch of POSIX api's a bunch of CA p is
loosely Confederated into a set of
classes but we needed to be able to
support a lot of these features to be
able to let Ruby scripts run like
getting an actual stat structure that
has all of the filesystem attributes now
we can do some of this on seven but not
all of the data bits are even still
there need to be able to do like a true
exec there are places where people will
use Ruby simply to launch another
program and they don't want the original
sticking around anymore so we need to be
able to exec it actually kill the parent
process off in the process kids kids
user ids group IDs effective user ids
all the different stuff that you have at
opposed x level for controlling access
control and identity and whatnot we
needed to be able to expose those
somehow to Ruby users without having
access to those api's on the JVM
changing the directory of the current
process changing modes and ownership of
files before java 7 you couldn't do any
of this you can do some of it now we can
do all of it forking people actually
still want to use fork and they want to
build a fork Ruby processes because Ruby
can't run multiple threads so that's how
you get around it you fork it off and
you do a separate process we we do have
a way to fork but it doesn't work and
then you know that like i mentioned
selectable standard i/o process aya
whatnot those are the sort of things
people
want to be able to stream data into
standard i/o or stream data out of a
process and use select operations on it
to know when it's ready can't do that on
the JVM cannot but we have ways to do it
so impossible double impossible because
there's fork in there okay so what we
have to solve this problem is called the
Java native runtime does anybody
familiar with JN a Java native access
this is way better than je na and
actually it's one of the same authors
that came and wrote this for us so job
in a two run time is a tool for binding
native libraries native code into Java
programmatically without writing jni
without writing C code or c a+ c++ code
just using regular Java code you can
pull in NEC library and bind it to Java
functions essentially honestly I think
that not having some sort of f of I
layer is a gross obvious omission from
the JVM at this point especially
considering every time they add
something that has to access native we
get a bunch more J&amp;amp;I code in OpenJDK
that could just be f if I based or a
native runtime based but you know that's
a that's a debate to have with other
folks the over overhanging project is
jnr on github so if you're interested in
any of this stuff you can find all these
projects there and it's a patchy to
licensed so should be able use it
anywhere you want all right so the base
project is jmf i which includes the
native bindings and very slim Java layer
above it jnr ffi is the API you'll
probably come in contact with most most
frequently it's built on the jo Java
native runtime runs on top of jmf I and
it provides a very nice je na like
foreign function interface to see
libraries to native code very similar to
how je na works but optimized for a
performance it has support for using
Java code as callbacks to see functions
it has much wider platform support
mainly because we've got jruby users all
over the place I think we're still
waiting on an openvms build but these
other weird platforms are supported at
this point let's take a look at what
this actually looks like so here is kind
of a macro based definition of a bunch
of add functions so add functions across
in
8bit in 16 in 32 and so on and so forth
so this is a sea library that we would
want to bind into a piece of Java code
very similar to how je na works we
define an interface we just put pretty
much the nominal types of what we want
for the inputs and outputs of all these
different functions and have JN a loaded
up it wires it up to the proper
appropriate library some of that codes
not shown here and then make sure that
all of these functions are bound to the
proprietary entry points in the C
library and so in this way you can
pretty much bind any piece of C code NEC
library with just a little bit of java
coding and perhaps a little bit of work
wiring up struct sizes and memory
locations and whatnot and we use this
very heavily throughout JRuby for a
couple different things i'll mention in
a moment okay so j &amp;amp; r pose x is one
thing that's built on top of jnr ffi J&amp;amp;R
POSIX is an incomplete set of bindings
of a bunch of standard posing functions
like stat link symlink chmod stuff like
that already prepared already properly
aligned and properly figured out for
several different platforms so you use
jnr POSIX on linux windows solaris i
think is a beta varius PSD's are
supported we have it all figured out how
the stat structure is laid out which
functions are supposed to call for
different things and you can call this a
single function out of jnr POSIX we do
actually have in here a pure java
simulation we're on where we can't do
the native versions so in some cases we
may be might try to shell out we might
use Java 7 api's when they're available
try to do the best job we can to at
least have a reasonable fall back when
the native stuff can't be loaded again
if this was just built in the JVM we
probably wouldn't have to worry about it
as much we're looking to add more is
obviously a massive number of functions
and pose X that you might want access to
and we've only mapped what we needed for
Ruby but it's very easy to add more and
we're looking for folks to contribute to
this in fork is unfortunately still
impossible because of the way the JVM
works but you can call ahead and call it
you really want to and segfaults will
follow you okay so here is a small
sampling of functions that we have
already pre bound and set up to work on
various platforms chmod exec like I say
fork is there and doesn't work a
environment modification getting the
current login there are functions not
shown here for getting password entries
on systems that have password files
pretty much anything that you would need
to call the JVM doesn't do we can find a
way to bind it I notice I at the bottom
we've actually got support for the raw
sea air nose as well so if a function
fails and the result is not contained in
the return value you can get the most
recent air know that happened for your
native call and essentially do anything
that you would do in C from Java now
getting an instance of it it's pretty
simple POSIX factory is part of jnr
POSIX you get a POSIX instance by
passing in a POSIX handler and you can
try and force it to use a non-native if
you want of course if it can't load the
native stuff it'll fall back on the Java
version anyway POSIX handler is just a
little interface for if you want air
nose to actually trigger exception
events you can implement this to do that
if you have a different way of
representing the current working
directory as we do in JRuby you can
implement that and again this is just
little hooks that we've realized over
time we needed to make these calls make
sense on the JVM first of all and on a
run time like jruby where you might have
multiple instance of as an of it in
memory with their own current
directories things like that okay so
that's jnr POSIX now one thing you gonna
run into with a lot of these api's is
that they all have their own constants
and these constants at the sea level are
not even consistent across platforms
necessarily some define them some alias
others to alias one to another the
values are usually not the same for all
of the different constants you might
have for example air knows maybe a
little bit different across platforms
open modes file modes f cntl things the
various various constants for socket set
up and so we had
have another project to basically map
all of these different constants across
different platforms and provided in a
simple way that we could use from job
here's an example of one of the pieces
of code that it's generated we
periodically will go through and
regenerate these on the supported
platforms which I think includes about a
dozen different platforms right now cpu
and operating system combined
combinations this is all the open flags
for the file descriptor open to pose X
function read-only right only etc and
these map to what the actual C code
would use to make these calls because we
have to have the right right values for
all these a notice there's a number of
these that aren't actually defined on
Linux if you flip to a different
platform they'll be a slightly different
some of them will be alias to each other
and so on notice sink and F sink are
actually the same value here so a little
interesting details that you can get out
of that so we there's a finite set of
constants that we've done so far f cntl
open socket modes address structures
like like pee pee ifpi net an AI net and
I inet6 those sorts of things uh some of
the UNIX socket stuff there's a large
set it's very easy for us to add more so
if there are a set of POSIX constants
that you need to access some particular
API we can add it get our various
platform folks to regenerate it and
we're good to go ok so going on to some
one of my more favorite projects here
jnr en xio so this is like ni l but it's
it's extended extended native
cross-platform I oh it's even better
than niño better than an i/o to this is
essentially an implementation of niño
channels selectors etc that is built on
top of jnr ffi so it's using the actual
POSIX file operations it's using the
actual raw q KQ or epoll selector
implementations and it's dealing with
raw file descriptors at the native level
so what you can't get with niño like
selectable standard i/o selectable
process io week
and do with this and if we can get the
file descriptor for standard in if we
just assume it's in the same place it
always is we actually can do selection
on standard in for example but you can't
do on the JVM normally so fun one a
little server this is actually going to
create a little TCP server so we got two
different forms of the sock address
structure maps using jnr ffi structural
layouts to unsigned 8 16 bit values and
whatnot and then we Pat it just likely
do in the native structure so we've got
AF inet and this is again coming out of
jnr constants we want to use we want to
create an internet and Internet socket
we want it to be a stream and then we
bind the various POSIX functions that go
along with sockets socket closed listen
bind accept and so on and then the logic
inside the TCP server we give it a port
that we want to listen listen on creates
the socket on that port using the
standard POSIX function for creating a
new socket it sets up the socket address
structured so we know where we actually
want it to bind it binds it to that port
and then listens just like you would do
in C code but this will work across
platforms you don't have to write C and
you have full control over how that file
descriptor and how selection logic
actually works at the Java level ok
there are others other fun ones that go
along in the jail jnr family jnr unix
socket uses extended native
cross-platform io to do to have a
prebuilt implementation of unix sockets
on top of all this stuff with full
selection capabilities and all the
typical stuff you'd hope for from a unix
socket jnr x86 assembly is used
internally by either jnr ffi or jmf I
and it is what you think it is it's
basically an x86 assembler written for
the JVM to allow you to generate
assembly rebind it back into the system
using one of these ff5 setups and call
native code generate and call native
code and we're using this right now or
and RFI is using it right now to
basically over avoid the overhead of jnr
avoid the overhead of lib ffi
marshalling arguments across making sure
calls where I wire up correctly we do it
once in assembly and then we use that
code instead and actually the the cost
of calling a c function from at least
Ruby I don't think java's it fast for
this case calling a c function from Ruby
through jnr ffi is only about five times
more overhead than calling it from C so
it's really whittled down and that's
like calling a node do nothing function
so you can't actually get considerably
good performance calling in to see
libraries using this stuff use cases
hopefully obvious we have an FFI dsl in
Ruby that is just awesome I mean it's
should I have an example of at the
moment i'll show you it's really pretty
and we're actually using the x86
assembly stuff and invoke dynamic to
bind from the ruby call site for a
native call to a native down call in jni
to the actual target there's only like
two hops really for us to get to a
native library function call from Ruby
code it's it's faster than Ruby does it
in C very impressive so any C library
can be wired up anything that you want
to do that you might have done in J&amp;amp;I
before don't write J and I use something
like this help us improve it you'll
you'll feel better about yourself uh and
yeah I mean never having to write J and
I again that's that's worth it alone
right we wrote J&amp;amp;I once for the FFI
bindings you should never have to write
out J and I again so i wanted to show
ruby ffi just because it is a really
really nice use case of this stuff yes
so it's a DSL providing native libraries
etc etc it's by far the prettiest and
easiest native binding on the JVM here's
our little library a couple basic
functions to show different sorts of
structures different sorts of values in
and out and there's the Ruby code for it
this is all that's necessary to bind
this particular c library
into Ruby code and at this point my
library dot calculate something will
call the calculate something function at
the sea level with only one or two hops
as far as calls in memory very easy
we've got a number of different point
number of different argument types and
return types there is a syntax for
mapping structures that's considerably
nicer than what you have to do with je
na or jnr you know we can do a lot of
sugar in Ruby but all this stuff is
built on top of the jnr family and is
the jnr families available for any
language on the JVM okay so moving on
from the POSIX stuff ruby is also an
extremely dynamic language it's
dynamically typed of course and dynamic
dispatch all the time so that can be
complicated but it's not as bad as some
languages all we ever do is look up by
name as opposed to for example groovy
that may have to look up by name and the
incoming types of the parameters ours is
always name based look up makes things a
lot simpler unfortunately these classes
are also mutable so we can't just do
simple dynamic dispatch we've actually
got to track if chat classes are being
changed patched improved quotes at
runtime so you kind of look at Ruby as
basically being a class object is
created as a blank slate and that
runtime it's filled with stuff and
method calls happen sometimes while
things are being filled sometimes long
after things are filled so we have to
track that as well we also have closures
to deal with we have data that crosses
frames like if you do a regular
expression match that's a function call
but it needs to set local variables as
well tricky things to do and we have to
be able to do with things like eval and
I'll evaluate code on the fly and again
this is where a lot of people said there
would never be able to get JRuby
performance anywhere near a sea-based
implementation and certainly not not up
to where they'd want to use it so now
doesn't the JVM kind of do this stuff
already well internally yes the JVM is
very dynamic and it can wire together
pretty much any two pieces of code if I
can figure out a path from one to the
other and optimize it like any piece of
Java code the trick is getting it too
real
eyes that all of our plumbing in between
a call and a target method can just be
folded away and disappear so externally
before invoke dynamic there was no
really good way to do this there were
ugly ways like generating crap loads of
little intermediate classes that we do
our calling through but even those had
downsides we were creating a lot more
code it was a much larger surface area
for the JVM to optimize and we never
really got to the point of performance
that we wanted so our early version our
initial version and this was actually
still running on java 6 we have
something called a caching call site if
you've done any language implementation
or dynamic language optimization we have
a monomorphic in line cash very simple
cash is a meth method and the serial
number of the class that method came
from at that time so every time we do
the call we check and make sure the
incoming object is of the same type if
it matches go right through and call the
method we don't have to do all the
lookup logic again so this eliminates
the costly hash look up that we would
have before and I just did a blog post
on how bad hash lookup actually can be
for performance but the problem is that
it's a single piece of code that every
single call on the system goes through
and there's no way that the JVM in its
current form can inline through that it
can't see that a call to foo going
through this caching call site logic and
eventually hitting the target method can
all be done as one batch operation or
one piece of in lined up one piece of
inline code so yeah the Ruby sees the
caching call site which is monomorphic
great caching call site looks up and
calls methods for every call in the
system so caching call site itself looks
megamorph if the shape of it is
impossible to optimize so the best we
can do with something like this is
basically in line the caching call site
logic and then have to do the slow logic
for all the actual method calls the
method dispatches and lambda actually
will still have this same problem until
there they fix it at the vm level
because ver lambda you're passing a
piece of code in possibly dozens or
hundreds of pieces of code into an each
method or an iterator method and the JVM
is going to see ok it's always the same
each method is always the same iterator
method but when it calls the lambdas it
has dozens and dozens of them and it
won't be able to optimize all the way
through like you expect it to it's a big
problem that the JVM has right now with
even anonymous inner classes and
hopefully they'll start to work through
that because we need it to so what we
have today that helps things
considerably is invoked dynamic invoke
dynamic allows us to define our own
protocol for how method calls actually
work at the vm level we basically get
called by the JVM when it's going to do
that invocation we give it a piece of
code a method and then it optimizes it
ignores all the other logic that was
done to look up that method to look up
the the target code this is kind of the
new golden hammer on the JVM pretty much
anything that you couldn't do language
wise there's a way to do it possibly
with good optimization using invoke
dynamic and at least it'll be simpler
than what you'd have to do before this
is on JRuby master today we're getting
17 out soon and it for benchmarks that
we're running some of them trivial some
of them a little bit more real-world
getting two to 10 performance two to 10
times performance improvement over
already being faster than the sea
implementations of Ruby so this really
does work and there there's the sky's
the limit as far as how the optimization
goes so it's a little easier to see this
graphically we have our switchboard and
our lovely switchboard attendant here so
up at the top we make our call or a
piece of Ruby code makes a call that's
our invoke dynamic bytecode I need to
call the 2's method on this part on some
object in Ruby at that point the JVM
basically calls back to us calls to our
bootstrap method and says okay what code
goes along with this method can you tell
you we have to give it basically a
handle to a method somewhere in the
system that represents 2's on an object
so we do that in the form of method
handles that's the java.lang invoke
package so we get a method handle to our
target method somewhere in the system
now the magic comes if at this point
once we've given that handle back to the
JVM once our bootstrapping process is
done
all the rest of this can just disappear
the jbean can actually optimize this
dynamic call a call that we lazily
bootstrapped at runtime possibly based
on runtime types as if it was a static
typed call the entire time now this is
something that we could have done like I
said on our own with a lot of tricks but
jbm is doing a much better job of it for
us now now unfortunately it's not quite
done yet they did a lot of optimization
in java 7 update to to make this stuff
run really fast but there were a lot of
bugs some issues with it that basically
meant that we have to turn off our
invoke dynamic support on java 7
currently the Java 8 builds are
improving that you have that here so the
the Java 8 builds have none of the bugs
from seven they're just starting to work
on performance and optimization I was
talking with one of the JVM engineers
and he has patches in hand that aren't
in any repository right now that get
much closer to matching the performance
of Java 7 and you know they're Oracle's
hiring if anybody wants to work on the
low-level intricacies of the JVM jit now
the next problem we ran into is in using
invoke dynamic and wiring up these
handles the method handle API is like a
lot of JP I a lot of Java API is very
low level and kind of cumbersome in some
cases the biggest issue that I had with
it is that you were always kind of
building backward from an end point you
have to get it handle to the target
method and then juggle arguments sort of
were in reverse order back to where
you've got your call did you want to
wire up to that particular target so I
thought maybe if we had a DSL that lets
us build these down it would be a little
easier for me to internalize and that is
the invoke binder library it is a java
dsl very simple little api or dsl for
building up method handles but you build
them forward you build them down from
the top from the top from the call site
to a target rather than the other
direction which fit my understanding a
little bit better it's also able to do
some type validation along the way that
you might not be able to get
until you actually do the call of a
method handle using the original API
contributions are welcomed the the big
thing i'm looking for at this point is
tricky patterns from method handles that
don't have a good representation in the
API I've got an example of tri finally
which is heinous in method handles right
now okay so here's an example of how you
do this with this standard method handle
API the java.lang invoke stuff we've got
some target handle which is probably a
method somewhere in the system we want
to cast the arguments to all strings we
want to insert arguments into it and we
want to drop an argument off the end and
now that you have to actually look at
this in terms of the target method
having its arguments modified backwards
from the target so what we actually want
at the end is a method that takes two
strings one of them has already been put
in there we want one of those with a
second one to be dropped use the first
argument and eventually return a string
result very difficult to kind of
internalize how that's working you can
read backwards but it still is feels a
little bit weird so we have successive
wrapping of transformations it's very
functional but it's also very difficult
to follow sometimes so in the invoke
binder you start out at the beginning
with the signature you're looking for
you want it to return a string and take
two strings we don't care about the
second string so we'll drop the one
argument off of the list we want the
first argument to always be the hello
string so we'll insert into the zeroeth
argument hello will cast it to a
particular type and then invoke it much
easier to follow what's actually
happening as far as the handle API goes
and it transforms forward like you would
do if you were writing a piece of Java
code that took arguments in made
modifications to them and made an
eventual call now I mention the example
of doing finally logic writing finally
logic in Java code is fairly simple
doing it in method handles is a lot of
monkeying around so invoke binder we
have the post logic that we always want
to run as in finally cases and finally
cases need to
a non-normal exit as well as exceptional
exit you can see where it kind of goes
to get a little complicated with invoke
binders since this is a built-in feature
that we have as part of building all you
do is say from this signature wrap it in
a tri finally with this post logic and
then do whatever your target call is or
do whatever other transformations you're
going to do so this is actually not part
of the standard method handle API and
translates to something much more like
this because you need to be able to map
all the arguments through you need to be
able to inline the finally logic into
both the exceptional and non exceptional
paths you need to be able to handle the
returned values coming out of the
finally in the non exceptional case lots
of overhead lots of hassle to actually
do this by hand just to do a finely bit
and so invoke binder that's where we can
sort of have some of these patterns
pre-baked into the API alright so we're
getting close to the end here the moral
of story here is that whatever you're
doing on the JVM whatever weird project
you might have never stopped trying to
do the impossible these problems are fun
to solve and if you can find a hole
through to the JVM itself or through to
native code or if you have magical open
source contributors who will port
libraries for you these things are
doable and you can fix them and at the
end of the day there's really nothing
nothing that's impossible on the JVM
except fork thank you all right
questions about any of these libraries
yes Kurt right right so there are
questions about simulating fork in JRuby
we have thought about that we can
essentially clone the existing JRuby
runtime we have a lot of our own runtime
states where it gets tricky though is if
we have already compiled some code into
a regular native JVM bytecode we can't
clone those call stacks at that point
and so then we're stuck because both of
those need to continue to execute on
their own into
and there's no way for us to clone
running running threads that also
affects the interpreter because our
interpreter is basically direct threaded
it goes straight through if we had a
stack this interpreter we could clone it
but if the threads are the problem yep
other questions yeah right for sure
right so the questions about whether
whether any of this stuff is available
for open SSL or TLS stuff I know in Ruby
in the Ruby land there there is an FFI
binding to live up an ssl that doesn't
translate directly into something that
you can call from java without some
JRuby tricks but this structure that
it's generating for binding openssl
would be available and for something
like the extended native cross-platform
io combine that with openssl and you
have like real native ssl sockets or TLS
sockets without doing a lot without
going through a lot of the cumbersome
stuff that they have in jsse right now
we haven't done anything along that
direction but it would be easy to either
port the ruby stuff that's doing that or
you know just build the bindings yeah
like I'm like a like there could be a
jnr openssl that would basically use jnr
ffi to map in all the openssl functions
yep other questions yeah
I don't know if I've actually run any
numbers on that it's going to be it'll
probably be slower because the channels
are going to have their own raw J&amp;amp;I
implementation and we've got a few
layers of overhead but i can't imagine
that when you're dealing with io that
particular difference is going to make
that big of a deal the extent of native
cross bow for Maya does use standard
niño byte buffers on both sides so the
real the only real difference is the
overhead of the extra hops for doing an
FFI like call so compare that to the
overhead of the actual i/o and probably
not going to be measurable in most cases
and actually we are talking about you're
talking about the JVM guys about trying
to find better ways to get native calls
closer to the judit output so that maybe
at some point in the future if you know
this gets internalized in the JVM or we
work with them a little bit more you
might actually just see the open call in
the assembly code things like that so
it's probably pretty close but I haven't
measured it and you know in the cases
where it's doing something that's
impossible with niño it's it performs
much better like doing selection on
standard i/o which is my still my big
bugbear other other questions all right
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>