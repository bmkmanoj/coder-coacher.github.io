<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Web Framework Smackdown 2012 | Coder Coacher - Coaching Coders</title><meta content="Web Framework Smackdown 2012 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Web Framework Smackdown 2012</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pORug8XNMSY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome welcome welcome they're working
yeah it should be welcome everybody um
it would be understatement to say that
I'm a little bit surprised to see you
here I hope you don't mind we're wearing
jackets this room is freezing cold I
hope it's getting better with all the
heat we have with the discussions
tonight definitely one promise front of
you won't see any slides and this
session is going to be better with every
single question you are an asking so i'm
your host i'm marcus eyes alone and one
i was having some trouble here and i'm
going to turn it off sounds better and i
would like to introduce our panelists
today to you from your right to my left
that is Santiago Perry gasket Athens I
had to read that just to not mess it up
so we had Graham Russia for grails James
Ward for play and mr. famous Ed Burns
for jsf I just thought I don't want to
see any slides up here today we just
want to talk about everything that is
important and a good idea was to start
with kind of yeah let's say elevator
speech and on top of that a few more
minutes for everybody um that should
make five minutes for everybody to
introduce the most important stuff they
had to say about their beloved babies to
you so let's starts and younger if
you're ready okay so i'm cynthia ricas
curtain I'm from Oracle if you were at
the keynote yesterday you may have seen
a demo call angry bits so this is part
of something that we call project avatar
something we've been working for the
last well at least I have been working
for the last eight months or so it's not
a project that we have out there so I
guess that's an advantage and a
disadvantage today I will like I'll give
you a quick introduction of what avatar
is today and where it
going basically we are very interested
in everything that has to do with html5
four ways of enhancing the Java EE
platform so we're taking certain bits
and pieces from the Avatar platform and
turning that into a standard you may
have seen the web sockets and other
things are slowly going into the
platform we were also exploring sort of
the view part or the client part of the
equation with the avatar and so that's
that's sort of the other piece that I'm
going to be showing at a session on
Thursday I believe around noon time so
basically avatar is what we call an end
to end framework web framework so you
can define not only the the view
components but also the services in
Avatar but of course you can also define
them using just Java EE without without
avatar also you can basically pick and
choose what pieces you want to you want
to use at the other the other thing
about avatar is that it follows the
so-called thin server architecture we're
basically pushing more processing into
the client so there's different
definitions of a thin server
architecture the one I like the most is
the one that talks about where the
merging of the view and the model takes
place so in in the case of a thin server
architecture we're pushing that process
the sort of the marriage between the
view on the model to the client so we so
we do that at the client rather than at
the server and then the models
essentially talk to services and that's
where the data is coming from but the UI
itself is essential for for many
applications that you I is downloaded
only once and after that basically the
client takes takes over and talks to the
various services to pull the data now
because this is html5 we don't have just
one kind of service in fact we have
three kinds of services in avatar we
have rest services obviously and again
the other
our side could be either jax-rs if
you're using Java EE or you can use an
avatar service which is also which
differs from from jax-rs in that is
written in JavaScript as well and then
you have servers and events support for
service and events and web sockets so
those are the three types of services
that we provide and for each of those
services we have what we call a
different kind of model client-side
model again if you were at the keynote
we talked about socket model push model
and rest model and if I had more time
I'd go into more details but that's
basically the area that we're exploring
at the moment one and a half minutes
okay okay perfect thanks x1 okay thanks
a lot my name is Graham Roche that's
there before I'm i work at spring source
VMware and on Grails from frameworks
unfortunately they're so Grails is again
it's what it's a full stack framework so
designed to solve every part of the
puzzle so it was some some frameworks
are just focused on for example of view
or just focused on systems Grails ready
aim to deliver all of the layers of the
application right from the build system
all the way through to persistence into
it it has some pretty compelling
features in particular on the
persistence side there is a technology
called gone which at its at its root was
originally founded on kind of sequel
back ends so you define the main classes
which are your models and then you
automatically get all of the persistence
methods and we can do this because
Grails is built on fruit on the groovy
language so for example you can do
things like both fine by title or book
list and those methods are just there
automatically you're ready to write them
yourself we
lela we've extended the technology
further so it now works mongodb in our
works with neo4j in our works with a
variety of other alternative no sequel
data stores which brings the odds
there's another major big advantage of
Grails is that it is a plug-in system it
has a plug-in system at its core and a
flourishing plugging community we have
approaching nine hundred different
plugins for Grails so the core is kept
pretty small but there is a lot of
innovation happening in the plug-in
community so if you want to add features
like forward to deal with WebSockets do
you want to have peaches it's great with
no sequel you want to add features to do
web services you just install the
relevant plug-in and you can go the
plug-in the plug-in system in grails is
completely open its blogging plugins you
can you can add some pretty interesting
features T application and generating
RSS feeds from adding search capability
through compass compass or elastic
search there's really endless
possibilities that can be achieved
through the plug-in system and it's it's
it's again it's another interesting
normal ponent of rails and of course the
other interesting component of Grails
which is I which I mentioned before is
the fact that it's built from the groovy
language so we really designed Greg
rails to be a dynamic language platform
so you get all the benefits of dynamic
language languages for example it folks
who are familiar with Ruby on Rails will
be putting a Python comfortable in those
environments you can be hyper productive
but but still gain all the benefits of
the Java platform and Java and so on in
terms of the way you've scale
applications is identical with grails or
regular Jarvis java applications Grails
has also built on spring which is in the
voltage itself you got all the ecosystem
around spring and underlying rails
framework and all the components that
come with that so it's it's robust it's
done
make and uses love it we have a growing
community and a lot of innovation
happening around Wales but one more
minute if you'd like to no actually not
oh very brave um James your five minutes
okay hi I'm James Ward from Heroku how
many people here have used play before
okay keep your hand up if you had an
enjoyable experience awesome okay good
good to hear okay so I am actually a
play user not a Play Developer but i've
been using play for about a year and
really enjoying the experience i think
for me play framework is really about
four major themes play framework has has
just been rewritten played too and even
play one before that hasn't been around
for a very long time so we thought when
i look at play framework what i see is
that they really tried to capture four
different trends that were happening and
how we build web applications and then
make a framework that catered to those
things so the first one is asynchronous
a lot of our web applications now are
starting to use real-time push through
web sockets and comment and that sort of
thing and so that's just becoming a a
common way that we have web applications
everything is not request response
anymore we want to be able to do things
that they use that use web sockets to do
real-time push or be able to do long
polling that doesn't consume a lot of
resources on the server and then the
second one is client-server so with
client server we were really moving to
back to the client-server model just now
doing that in a web browser without
having to install plug-ins just through
JavaScript on the client and then
talking to restful stateless services on
the back end and i think that's that's
really beginning to be the predominant
architecture for how many of us are
building these next generation web
applications is this client side
actually running on the client and then
the server side as russell services and
then the third one is being able to
scale horizontally
so this requires a stateless web
framework or is done best with the
stateless web framework and so we can
just add new nodes and scale out
horizontally when we need to handle more
requests and on the fourth one the last
one is that mobile applications have
really caused us to to think differently
about how we build and deliver our our
software there's a few different ways
that this is changing things I think
that the two or the primary way is that
we begin to think first about the AP is
that we build and expose and then we
think about the different interfaces
that will build on top of those AP is so
for instance if we're building a
phonegap mobile application or a native
iOS application that needs to talk to
some back-end services will build out
those services first and and even can
build those out kind of disconnected
from the people who are implementing a
client side to those services and then
those services could of course also be
consumed through third parties so those
are the four major trends that that I
kind of saw happening in the the reasons
why I've adopted plays that it fits
really well with those so to kind of
dive a little bit further underneath the
surface and go into those four things so
first the async play is built not
actually on the servlet API it's built
on Java niño and which is a library in
Java that allows us to not have that
thread per connection limit that is
typical in servlet based applications so
what that does is it makes it so that if
we're not actively using a connection we
can actually take the thread that was
allocated for that connection away and
allocate it to somebody else and then
give the thread back when we want to
retransmit data so that works really
well with WebSockets and asynchronous
requests and that sort of thing and then
that's actually powered by Neddie
underneath the covers if you look at
like any modern web framework and
scholar or java they're almost all
building on top of Neddy it's really
great for doing high performance and
really utilizing threads and CPUs more
efficiently then to accomplish the
client-server stuff and how play assist
me with that this is the second one play
has played to has an asset compiler so
I'm beginning to write my client side in
a lot more JavaScript and
CoffeeScript and less for CSS and so
doing that I could just kind of go into
the wild west and and just write it all
by hand and not really have any support
you know compile errors and those sorts
of things but play frameworks asset
compiler will actually tell me when
there's a air in my my coffee script or
JavaScript or my less it will compile
and auto minify those those assets as
well then the third one horizontal
scalability as I mentioned play is a
stateless web framework so just out of
the box you really don't have any way to
to screw that up if you if there's no
like session a place where you can shove
stuff so that forces you if you do need
session state across request then you do
have to use some external data store
like memcache or a database no sequel
database that sort of thing it also play
is HTTP friendly oh wow that would thank
them back to the rest of the market and
give all right hi my name is dead burns
I'm talk about jsf jsf simplifies
building the U is for Java server
applications and it is thus Qi standard
for java ee been around a while it's a
platform for others to create
arbitrarily awesome components and make
money from them we have a lot of people
that have been doing that consulting
services and companies that are built on
making UI components and having fun and
you know feeling feeding families their
own and others it's a global community
of developers who are creating value for
their clients and sharing code and it's
a great way to mash up stuff at the UI
tier no the previous talk that was right
here was showing how you could take job
FX and mashed up with JSF awesome Sala
from the apache software foundation and
I he gave a talk and I gave a talk at
javaone a couple years ago about mash
ups for jsf and in that talk we were
able to just in the app I'm sorry in the
session build an app that would let you
take Twitter feeds and mash them up with
google maps and see who was tweeting
what for
we're and you could put zillow
information in there and see what house
is worth and you can just match things
up together and when you have all of
this integration happening at the UI
tier you need to have state so jsf is
mostly stateful although you can do a
lot of tricks to produce the amount of
state by marketing and components as
stateless as you can go but it's built
on components UI components and client
device independence which makes it very
suitable for mobile devices several of
the component libraries that are out
there right now support a desktop mode
and a client mobile client mode based on
the footprint size of the screen
basically so that's all I want to say
let's get to the discussion oh that's
easy thank you all that were the first
round I tried to stop my timer so I
don't get time to anywhere that was
shorter and faster and more entertaining
than I expected myself so thanks a lot
for the first round guys I had the
pleasure to take some notes and have
some questions ready but I would just
like to open that up as early as
possible so if you have any questions
you would like to fire up at a one of
our panelists or even a more general one
just raise your hands and I'll try to
pick you up so anybody rear on yeah
let's go here's it depends tell us more
the answer that is try them all and do
little spikes with a bunch of different
ones and see which one fits best with
your use cases because honestly I think
every web framework is kind of created
for a specific types type of problems
and so your types of problems may fit
best with with any one of these and so I
think it's you know I could come up here
and say you know choose play but I don't
think it's good for everything I also
the same thing we're jsf it's you know
every framework has its sweet spot every
technology does but it's also important
to take a look at what
developers you have in-house you have
you know what what skills do they have
they're able if they're comfortable
working with pages and tags and stuff
then you know jsf is their back but if
they'd rather work with you know client
stuff and really keep out of the server
as much as possible we're really happy
with doing the html5 and you can query
and such that you know Jeff might not be
the right thing but there's others did I
think there are some websites that
actually have gone through the trouble
of taking one problem you know writing
the social in all that and all the
frameworks I think that's a good
starting point unfortunately though a
lot of those haven't been updated and I
know this personally because some of
them were written based on jsf 12 and we
added so much new stuff into that oh and
they haven't updated them but yet they
still get lots of Google hits so people
go about what's jsf well okay well this
site says it sucks well that was written
in 2008 and you know we've had some
major feature since then so you have to
beware of when you look at those sites
what versions of the things are showing
about maybe so well obviously when
they're written 2008 the person who
wrote him thought they were true so sure
question on said I guess maximum place I
myself from one of them
you want everybody to answer that right
yeah let's start with avatar I'm so
curious about that stuff well I'm trying
to understand a question so when you
talk about all the graphic stuff you're
talking about images you're talking
about CSS what what do you have in mind
yeah i think our approach has been that
there's probably two teams there's the
designers and there's the programmers
and we try to make it as easy as
possible to transition from one to the
other but I guess since we are not out
there and people haven't tried us yet is
hard for me to describe exactly how to
do it so I'm with some of my colleagues
to answer that question there they say
well on the Grail side it's kind of one
of the welcome sweet spots for Grails in
terms of the fact that we it's really
designed we have a server page
technology called PSP and it's kind of
like Jayde's p but simpler and easier to
use with groovy as the expression
language and we have defined directories
for us that's your JavaScript or CSS and
so on and because we have conventions
it's always the same across every
project so once so it's why common
parade for DUI team to be working on the
GSP pages because it's good you know
just markup aged HTML and so on with
their normal job and
as long as you point to you I guy
attendances video J as well as others as
well see as far as what doesn't what the
images go there quite happy tweak it and
there's quite some this we have many
many many uses the clients that you have
who are structuring their teams in that
way with you I to fly happily working
and the back end they know about the
program for play framework i think it's
it's pretty similar to a lot of these
others you can go to different ways one
is that you can go with a server-side
templating approach where you're writing
server-side templates and this is where
you want to have some interaction
between the designer wear your writing
actually code in HTML that gets compiled
on the server so in play framework at
scala or there's also a groovy module or
school eight module that you can use to
do the server-side templating so that's
one approach the other approach which i
think is becoming more common which
people are gravitating towards because
it solves this problem better is when
you actually have a strict separation
through jason restful jason api's
between the client and server then you
can totally give the whole client side
and the whole UI over to a team that
specializes in just web UI and writing
JavaScript and using jquery and you know
CSS libraries and all the browser hacks
and all that kind of stuff and then then
the the backend team can just expose a
JSON API and then focus on persistence
and on scalability and those sorts of
things so i think that's that's the
better way to address this if design
fidelity is a very important value and
what you're building if design fidelity
is not that important because you're
building some boring business internet
application then server-side templating
may be good also if you need search
engine indexing then server-side
templating is the only way you can
really get that and if a question on
that so but but that client team that is
kind of working that's that can be just
designers but because somebody has to
write all the JavaScript that you just
talked about designers you like guys you
I guys so many yeah yeah yeah so I think
it's pretty common now to see teams of
people where the whole that the web team
actually can write really good
JavaScript and CSS and also do really
good design and if you look around it
like
hub calm like their their site looks
amazing and it's because they have
developers who I guess we call them more
diviners is the word we used to use form
people who have the design sense but
also can write hardcore JavaScript
enjoys jquery and so i think we're
seeing that role expand we're a lot more
developers or a lot more designers
people with crossover skills are doing
both sides of the picture and just to be
clear as well that that approach is also
becoming popular with grails as well we
have a plug-in ecosystem so GSP is just
one of the three technologies available
for grails but we have folks who are
using like handlebars or mustache to
write their templates and then they're
serving up rest and then using
javascript to compile them lost a
massage on handlebars templates and
rendering them on the client that
approaches gaining popularity as well
while jsf has been designed from day one
to have separation of roles so for you
know you can do the same thing your page
designer developer tags I'm sorry
developed pages and web browser you know
we know that people who are good at
developing you eyes might not have the
same skill set of those that are good at
developing transactional applications so
we have to recognize that in getting
that there's also a jsf free weaver
plugin that people like to use your
pages and do the real Dreamweaver thing
and it will generate jsf stuff for you
on the back end oh yeah kind of trying
to share here so we do recognize that
there are different roles and that's
something that we've had from day one
there's some new features we're having
in jsf to point to where you can really
have very pure HTML and just put some
jsf attributes on your components and
then because the SF does its action on
the server side right it's all about
validating converting data using the e l
to bind to the model and you know then
that's where you integrate with your
persistence and your CD I and such of
those sorts of things and if you can
have only that little bit be brought in
by putting a single attribute on
arbitrarily complex HTML because really
when it comes down to it the browser's
just sending an eval you pair across the
TCP socket and what we do with that is
really what matters on the server side
so look for that is a new feature in 2.2
I just want to point out something as
well in case it wasn't obvious for
anybody is that the JSF is kind of
different too I want to speak to you we
call you but no it's kind of different
to play and grails in that just as
example Grails has a jsf plug in jessup
is like a view technology fundamentally
circo Grails can actually serve jsf
pages if you want to use J safe and
growth it's like that's why grails and
jf being and playing in the same context
it's kind of weird talking about them
being competitive when you can use jsf
and grails together and have jsf Grails
serve the JSF pages right because Grails
is like a full stack thing with
persistence and everything all along
that's kind of like talking about once
I'm Java EE yeah exactly it's kind of
like talking about Jace if I'm Joe and
JP am but I'm dad that I forget up right
well people people say should i use JSP
or jsf right and then i'll say well you
know actually before there was facelets
JSP was all you could use with JSF so
and then you could also write any of
your jsf stuff and groovy because that's
easy to do that on the server side too
so it's all Mashable mmhmm yeah let's go
any further questions yeah I thought
things were supposed to be backward
compatible but I thought things were
supposed to be back looking bad well
it's back here's the here's the upgrade
story where you get where you getting
compatibility where you're getting
compatibility is if you use JSP JSP in
your face and your jsf application
and you happen to have custom tag
handlers that are doing non UI stuff so
if you have programming logic business
logic in your JSP custom tag handlers
using scriptlets this is one of the
things we solved with facelets because
facelets does not have any concept of
scriptlet at all so we you simply can't
put business logic in your view tier
it's not possible to do that but if you
were putting procedural logic in your
JSP tag handlers that would be a
challenge because then you'd have to
have by moving to 20 you'd be forced to
find the right place to put that kind of
stuff so that might be one challenge but
generally the upgrade path is is pretty
simple if you were following conventions
along the way of having your JSP tag
handlers really be just there for the
purpose of wiring up the UI components
which is all facelets does with them
then there's a one-to-one mapping of new
to old or old to new rather to them goes
that question to whom goes that question
well we don't have a J ruby-on-rails /
soph yeah that's what is probably now
yeah usually you should ask somebody you
want that's one thing to look into if
you want to do alternative languages on
the JVM is vertex it's a new niño based
server and it's it's really phenomenal
but it supports JRuby it supports
javascript it supports I think scholars
come in Java of courses there so it's
it's really interesting it's supports
async really well in this new kind of
style of web application so check out
vertex and it's a vm would punch it yep
sponsored by vmware
ddd oh and also here to make another
VMware plug 1 i'm not sure what am i
doing that because it's good stuff it's
the Rue project and that was something
that was kind of really inspired by the
rails way of doing things and I'm
there's Grails furu right uh no no
because they have GWT for ooh and they
have jsf furu so they have rua Dawn's
yeah that's what I mean yeah and I guess
I'm still I'm still holding a Superman
question here so please let's go so on
the Grail side ah first of all being
based on a dynamic language that just
makes your test driven expo and
development experience orders of
magnitude more simple because anybody
who's done test-driven development with
a statically typed language knows that
you often have to jump through several
hoops to make something testable usually
the static types are always getting in
the way with a dynamic language iria are
far more Liberty to make things to swap
out your collaborators and it's just far
far far easier to test dynamic language
and it is its delicate type of language
so in that context there's also a lot of
innovation happening on in testing so
has anybody ever heard of something
called Spock father okay if you haven't
even if you're not using groovy in your
production applications check out using
groovy and Spock Spock framework to
write your tests because you can write
you can test your Java code with groovy
code it's not a problem in you right way
more expressive tests and Spock is
really a phenomenal testing framework
it's kind of like j units except it it's
far more expressive it as a DSL for
expressing new works
patience and so on and so forth the
really that in the gooery space is a lot
of testing innovation and a real deep
culture of test-driven development and
we have a full kind of API for our
testing framework which is pretty
comprehensive so for me I always thought
test-driven development was a good idea
but I never actually did it because it
always kind of felt like it was getting
in the way right like like actually
writing and running my test was easily
flip them probably right so but with
play framework is the first time I've
actually done test driven development
and the reason for it is that they've
integrated testing so well into prolly
framework to it actually is assisting me
and helping me write code faster to do
TDD which I think was the idea and it
like Graham said it never really worked
out with statically compiled languages
and tell play too so so I've really
enjoyed it the what I do when I do play
to development is I have one terminal
running the play HTTP server and then
one running the plate s and whenever I
make a change to a file and save the
changes it automatically compiles and so
i can test in the browser if i need to
do a manual test or the test runner or
automatically rerun the test so it
creates a really productive environment
for me when I'm when I'm doing play
development also for jsf jboss has a
nice project called faces tester and
that's a good solution and the standard
solutions of selenium because you know
doing test-driven development with UI
design is a bit of a challenge but when
you try to if you're following proper
separation of concerns and your pojos
you can you to test them with whatever
other unit testing things you're doing
that has nothing to do with JSF so the
question kind of I'm limiting it to
doing unit testing specifically on jsf
artifacts and there are some ways to do
that into the jboss project so for us
it's been a first of all I should say
that we're basically all JavaScript
based so it a Fault in the cat into the
category of dynamically typed languages
for avatar and and we're using a
combination of selenium mostly at this
point for for the very basic testing
that we have done and shameless plug for
the redhead guys with a helium project
so whoever is trying to
and Ron jsf tests on try that stuff any
further questions come on I have some
fancy ones yeah actually that's a good
question I don't know if you probably
notice some of the widgets we were
showing at the demo at the keynote those
were actually dojo so avatar has a
pluggable framework for widgets we
didn't actually develop our own widgets
so we can plug two or three different
frameworks that we will play with the
main one that we're using is dojo we're
also using jQuery UI and jquery mobile
so basically you can have the same
application and you can just change one
bit in the application in a properties
file and have it compile with another
widget set of course that's you know in
theory in practice things are a little
bit more interesting than that I mean
that's true provided you use the common
you know subset of the widgets that are
supported by those but you know that's
that's the goal the goal is to have a
pluggable widget tip yeah jsf has had
decent tooling for a good long time now
so I'm really happy with the state of
things all the Ides have pretty good jsf
support you know code completion alt
click to traverse through your different
al expressions all that is standard
refactoring which idea are you using I
use netbeans but I've seen it in all of
them Eclipse IntelliJ okay play firm
work has great support for bi my
favorite ID
sorry to the Emacs lovers out there I
know it has I would say play firm work
has decent support in the IDE you can
you know do the typical debugging stuff
but when you get into like the
server-side templating code there's not
much support there the IntelliJ folks
have started working on some play to
support but definitely not as mature as
some of the other web framework tooling
so on the Grail side grell's has been
around longer than play and the tooling
is really matured over last couple years
so in you've got the gory Grails tool
suite or SDS chip space which provides
an eclipse could be eclipsed which the
open source project for you know book
editing Ruby code and then there's the
extent the Grails tooling around group
the group in browser tool suite in
eclipse which allows you to you know get
nice project we will run commands d
bargain and so on and so forth and it's
really quite um coming along nicely and
then the IntelliJ guys have done a
phenomenal job the groovy tooling in
IntelliJ is very mature now they even
right parts of IntelliJ is itself in
groovy nowadays so they and and again
like the Grail support as well it's very
mature intelligent and if there is also
a group of girls plugin for netbeans I
believe as well as well as of course
things like text met bundles its etc I
need the keys for avatar where have a
couple of ongoing projects for Eclipse
and that means mostly around you know
helping you get started create the
application structure and things like
that and also for this highlighting
syntax completion
and things of that nature we don't yet
have a UI designer but another Superman
question yeah come up yeah sure so play
framework is container list and it
manages the whole recompile cycle
internally so there isn't the steps of
compiling rebuilding a war file
deploying a war file restarting tomcat
that all goes away with play you just
start up your HTTP server optionally
start up your test runner and then you
just go make changes to your files and
play as internally recompiling
everything so that the iterations when
you're using play framework get a lot
shorter because by the time you've
gotten to your browser window to click
refresh or you know to see your test run
it's already actually recompiled and
rerun the test if you're doing that so
it's really productive Grails is very
similar that way to a boil to the same
we have automatic reloading built-in
framework it it's based on a Java the
JVM agent so that touches to the JVM and
it'll actually reload changes to even
Java code on limited to two groovy will
watch all your changes to any any
bytecode that your application generates
where it be from Java or groovy or even
we have a scholar plug-in as well so
it'll reload that and it will be without
restarting my soul so for jsf if you
make changes to the mark-up pages those
don't need to be there's no redeploy on
that if you deploy the app either
exploded or your IDE deploys it exploded
for you
any changes you make to the markup pages
are automatically there the next time if
you need to make changes to the model t
r you have a couple options you can use
a product like j rebel and that lets you
make any change you want anywhere and it
will not have a redeploy or you could
use you can write your model objects in
groovy and then they would be
automatically changeable I believe there
are even some server options out there
that let you hot swept stuff right you
can and you can configure your IDE with
the clips continuously recompile stuff
so there's ways to do it so in the case
of avatar is similar to jsf we use we
run on Java EE we use an exploded
directory structure we don't have java
code in the models it's all JavaScript
so it's all hot swappable in that sense
you make any change to the source you
will load your app your app and it's
there I just want to check and not
losing anybody here yeah the side of the
room has been crying yeah I mean yo yo
wake hello crystal here and oh yeah John
come on yeah yeah cool give it a shot
Maggie whoo yeah yeah come on we're
waiting for your question yeah go ahead
ah well here you go we have to this is
all about the sweet spot right so water
dynamically kind dynamically type
language is great for and what are they
not great for well they're great for
sling and some code out and getting
things done fast it's like working with
clay you're able to model things
together and put stuff together really
quickly and then once you have your
design a little more solidified than you
could on an artifact by artifact basis
kind of solidify it some more by
converting it from groovy into Java and
because dynamically typed languages are
not as good when you have a maintenance
Berger who comes in who doesn't know the
guy who wrote the thing initially guy or
girl at wrote the thing initially and
you know there's no IDE that should help
you understand what this thing is except
to run it so I think that's where
strongly typed languages come in it can
really help the maintance programmer so
I I would disagree with that that
roughly 30 minutes so on the maintenance
side I don't agree that dynamically
typed languages are more difficult to
maintain I think there are circumstances
when that can happen yeah you can write
my own code any language and those
circumstances are typically when there's
directly type code being written with
our tests if the company has a testing
culture in place which you should have
if you're adopting a diamond anytime
language otherwise don't bother if you
have a testing culture in place then
it's the in especially with testing
tools like Spock and so on they pretty
much document self-documenting in terms
of the behavior of the application on a
really understanding what the
application is doing making maintenance
a heck of a lot easier maintenance
becomes tricky in a dynamically typed
language when you see all this that when
you could become spaghetti and there's
nothing verifying how it behaves or how
it works or what it's supposed to do
that's when it becomes hard to maintain
a diamond type language in terms of
performance on the Grail side with rails
is based on groovy obviously but there
are various performance benchmarks
demonstrating that even though that
Grails is based on this or terribly slow
groovy stuff it way up performs things
like jsf that's partly because it's
stateless but default by stateless and
jcf consumes as you increase the number
of threads consumed memory and things
slow down but also because fundamentally
groovy
the jvm has a incredible capacity to
optimize groovy code and inline groovy
code and groovy has course like caching
and it gets really fast and really did
the bottlenecks to your application are
going to become your database
connections your rest service calls
whatever you're doing on the backend
that involves I Oh way way way way
before any kind of groovy code becomes a
problem and even if it does become a
problem some piece of groovy code the
you you can as stated rewrite that bit
in Java quite easily and you can also
adds up groovy to which is in grails 2.2
or this kind of honor just mark a
particular method as being as being
statically compiled map in which case it
becomes Java level performance but
method automatically just with one
annotation so it's really not an issue
fundamentally performance and I know
this as well because we have folks like
a sky who broadcasting who are the
largest satellite broadcast in the UK
they have all their sites written in
grails in the UK and there are serving
200 million requests from up a problem
want to add something sure lance i am so
i think we need to separate the klein
versus the server in the case of avatar
on the klein we are JavaScript I mean
pretty much that's the only thing you
can do right I mean we try job on the
client it kind of didn't work so we're
not going to go back there now on the
server side on Avatar you have a couple
of options you can use traditional java
ee for your services so it's java jax-rs
we use that a lot with avatar and if you
if you decide to go the JavaScript route
we're running on the nasty own engine
maybe you heard about that engine is one
it's going to be in java SE eight and it
has an amazing amount of optimization
for the JVM so it's actually very fast
perfect thank you a lot you make my job
a breeze tonight I guess due to the time
constraints today we take a cut here I
where's my pleasure i'm moderating it
thanks a lot to our panelists i hope you
had a lot of fun so enjoy yourself have
a great evening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>