<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Do You Like Coffee with Your Dessert? Java and the Raspberry Pi | Coder Coacher - Coaching Coders</title><meta content="Do You Like Coffee with Your Dessert? Java and the Raspberry Pi - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Do You Like Coffee with Your Dessert? Java and the Raspberry Pi</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eJ9ArS4uhZU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so today's session is I thought
amusingly titled do you like coffee with
your dessert
Java and Raspberry Pi so let's start
with a question who here has a Raspberry
Pi ok I'm talking to the right audience
then aren't I I'm very glad to see that
so many people have managed to get one
of the raspberry PI's so what I'm going
to do this morning is to talk to you
about some of the things we're doing as
Oracle in terms of making sure that Java
is well supported on the raspberry pi
making sure that you can do things with
Java on the raspberry pi and then I'm
going to show you some examples of
things that I've done with Java on the
Raspberry Pi which hopefully will
entertain you so I worked for son for 14
years before we were acquired by Oracle
and one of the first things you notice
when you become an Oracle employees that
lawyers get involved so all of my
presentations now have to have a safe
harbor statement which is basically
saying that you know you must not take
what I'm going to tell you as being a
definition of our product direction in
the future
I don't think it's really too important
for the presentation that I'm giving you
but there it is I have to put it up
there so I've given you enough time to
read it sorry you may most certainly
film my presentation if you want to know
if you want to film me go right ahead
okay so in terms of the agenda what I'm
going to do is I'm going to be a little
bit of background information on the
raspberry pi project how it came into
being a little bit of history it I think
will be quite interesting I'm the kind
of person who likes looking at how we
got to where we are and so we'll talk a
little bit about some of the history of
this thing then we'll talk about the
specifics of ARM processors because the
Raspberry Pi as I'm sure you know has an
ARM processor at its core so we'll talk
a bit about some of the features of ARM
processors what the people are doing and
so on just out of question there's
anybody here an arm employee
I'm not doing that because I want to you
know sort of like say you can't be here
I just want to make sure that if I've
got any questions or if people ask me
any questions then you know I've got
somebody I can refer the Batsuit but
that's okay it doesn't matter right then
we'll talk about Java and arm on the
Raspberry Pi and the specific things
that we need to consider when it comes
to both porting the JVM and also tuning
the JVM for that particular platform and
then I'll go through some of the
different things that you can do in
terms of using Java with the Raspberry
Pi in the different areas that you can
look at in terms of interfacing a lot of
it is about interfacing because okay if
you've got a JVM you can write java code
that's great but the raspberry pi is all
about what can you do with it in terms
of talking to other things and stuff
like that and then we'll get into the
demos and show you what you can actually
do in reality so it's talking about the
rostra PI which is shown in the picture
here now that the history of this is
that it started a long time ago it
really started back in 2006 when some
people at Cambridge University thought
about the way that computer science is
taught specifically in the UK they were
looking at what we have in the UK who's
here from the UK here a great reasonable
number of people so if I say if I say
ICT some of you may actually know what
I'm talking about
I can never remember what it actually
stands for but it's basically what we
teach children at school in terms of
technology and so I have a six-year-old
son who does ICT he gets to learn how to
use a mouse and he gets to draw pictures
on the computer and things like that so
there's a curriculum for ICT and the
people at Cambridge University who were
looking at this were rather concerned
that what we were teaching children
wasn't computer science we were taught
teaching them how to use applications
how to use a web browser how to use a
word processor how to do email which is
not computer science so if we want
people to become engineers if we want
people to go into industry and great
creating new things and have great new
ideas they need to be trained properly
and we need to start
doing that from a young age and a lot of
their inspiration came from a project
that actually happened way back in 1981
so 30 just over 30 years ago now which
was the BBC micro project so okay hands
up again who had a BBC micro okay one
two all right okay it's a younger
audience today then so I had a BBC micro
when I was at school it wasn't my first
computer my first computer was a trs-80
who remembers that oh yeah of course
it's American isn't it yes so yes I had
a tiara a trash a tea great machine 16
kilobytes of memory then I moved up to a
BBC micro 32 kilobytes of memory Wow and
color graphics what more could you want
but the idea behind this was to teach
children and teach adults as well about
computers because remember 1981 was way
before the internet way before general
computing as we know it the IBM PC
didn't come out until 1984 so this was
all about getting people interested in
computers and teaching them what it was
so they made this machine and then they
had a series of television programs that
took people through the basics of
learning basic so the people in the
Raspberry Pi project thought that was a
good idea how could they do something
similar but in the year 2006 or the end
of the first decade of the millennium
and so this set about creating a device
which they could use to teach children
about programming in a way that they
could understand and most importantly
make it affordable they didn't want to
be creating a machine that was going to
be the same price as a laptop or the
same prizes at the normal PC
well it's it's something very very cheap
that you could give to lots of
schoolchildren and have them get excited
about these kinds of ideas so it went
through a lot of it took a long time to
come to fruition they went through a lot
of hard work and created this thing and
I was lucky enough to actually go and
visit the people at Cambridge and have a
chat with them just earlier last year
when we were talking about how to get
Java to work well on the Raspberry Pi so
I had a meeting with them which is very
very interesting to see it
working and seeing how it's going but
then it was officially launched on
February 29th of this year and it was
very very successful basically the first
production run they did was ten thousand
boards and they produced them in China
and they were shipping them back to the
UK mainly and there were two companies
that they partnered with to actually do
the distribution of these things one was
RS or Radio spares as we call them in
the UK and the other was Farnell both of
these companies are very professional
companies they sell enormous numbers of
electronic components to all the the
industries that use electronics the
launch of the Raspberry Pi board walk
bro that both of their web servers to
the knees because so many people were
trying to buy these things and I
remember I was trying to get on so I
could actually buy one as well and you
just couldn't get onto the website and
rs actually thought said that they had
over a hundred thousand pre-orders in
one day which is why it's taken a while
for these things to actually get into
circulation so current production is
about four thousand boards per day one
of the nice things learning from my
perspective is that they've actually
just shifted production away from China
which is where they had originally done
the production and they're now doing
production in the UK so Sony have a
factory in Wales and they're now
producing the boards for the Raspberry
Pi organisation so it's it's nice from a
UK perspective so let's talk about what
you actually get in your Raspberry Pi
well the first thing is it's an ARM
processor and specifically it's an arm
11 core running at 700 megahertz so
that's what that's probably about eight
nine year old machine maybe a bit older
than that if you compare it to a PC I'm
trying to think when I had a 700
megahertz machine that I was using
it's a Broadcom system on a chip package
so that means that most of the
components are in a single package and
so it's when you look at the board
there's this kind of like chip in the
middle which is not the processor that's
actually the memory the processor sits
underneath the memory so it's quite a
clever design in terms of the board
nice thing about it is you can overclock
it and just recently the Raspberry Pi
people have said that they will now
allow you to overclock it up to one
gigahertz and you won't involve eight
the warranty because they're that
confident of the production of their
machines that they say that you can
overclock it up to one gigahertz and it
won't actually invalidate the warranty I
was at a Raspberry Pi meetup on Saturday
which was here in San Francisco and
there was one of the people from the
Raspberry Pi organisation there and he
was talking about some of the details of
that and he said that there are people
who have actually overclocked them to
1.2 gigahertz but that does involve
eight the warranty if it goes wrong what
you find is that you can continue to
turn up the clock speed but then you run
into problems with memory access and it
becomes very unstable but it's worth
knowing that you can crank it up a bit
if you really want to memory is fairly
Nagios a memory is fairly limited at
only 256 megabytes coming from a person
who started computing with 16 kilobytes
but clearly by today's standards 256
megabytes is not a huge amount but it is
amazing what you can actually do with it
some of the the sort of internal
workings of the Broadcom chip means that
because you've got GPU in there as well
you can do a lot of media processing
without having to hammer the processor
and so 256 megabytes is still actually a
lot of memory in terms of being able to
do most of the things that you want to
do in terms of i/o things that you've
got to connect to it you've got video so
you can either do that through HDMI or a
composite video so there's a phono
socket that you can plug into the idea
with this is that they want people to be
able to just use their television rather
than having to buy a separate monitor so
price is $35 for the board what you
don't want to have to do is then have to
buy you know a monitor to go with it
that would be rather expensive so if you
can use your TV that's great you have to
find a keyboard you have to find a
flashcard but it keeps the price down as
much as possible there are two USB ports
this is only on the model B currently
they're only selling the model
the model a has less IO on it but and
it's also cheaper so it's going to be
$25 when they finally launch that the
model B also has Ethernet on it which
the model a won't and then you've got a
bunch of header pins that you can
connect things to so there's a some GPIO
lines there's a UART for serial
communication there's SPI and I squared
C the sported if you want to do more
sophisticated kinds of i/o there's also
a couple of extra connectors on there
one of which is designed for a camera so
there this future growth there in terms
being able to connect something like a
camera to it so it's talked a little bit
about ARM architecture a brief but
interesting history lesson to go with
our history lesson of the how the brass
beep I came in too big as I said the the
the BBC micro was this machine that was
built back in 1981 and it was based on a
6502 processor which to me is a lovely
processor it's an 8-bit processor with a
nice simple instruction set it's a flat
memory model if you're trying to learn
assembler code it's a wonderful place to
start because it's nice and easy
so I really liked that when the people
at acorn who were the company who
manufactured the computers started
thinking about what they were going to
do next they decided that the 6502
wasn't going to be powerful enough 8-bit
processor wasn't going to be suitable
for what they had in mind they wanted to
get into business machines and they
wanted to have something more powerful
so he looked around and they figured out
that actually designing your own
processor wasn't that hard so these are
people who were at Cambridge so for them
things are a little bit different if I
was there I would like be I'm not
designing my own ship but anyway they
thought yes let's look around
figure out how to build our own chip and
at that time there was a research
project going on just down the road from
here at Berkeley about risk reduced in
stuff instruction set computing the idea
that you had less instruction
which you could execute faster so rather
than having more complex instructions
get a smaller instruction set but you
could execute them much more quickly and
so the idea is that the efficiency is
better the other thing is that if you
look at machines that have or processes
that have more complex instruction sets
there was a survey that was done or an
analysis that was done which looked at
the UNIX kernel and they identified that
only 30 percent of the instructions of a
motorola 68000 were actually being used
when you ran the kernel so why have all
these extra instructions if you're not
going to use them make it a smaller
smaller instruction set make the silicon
easier to produce so just as a useless
aside here motorola 68000 another one of
my favorite processors because it has a
flat memory model anybody know why it's
called the motorola 68000 I know it's
produced by Motorola so you don't get a
point for that
no it's called the motorola 68000
because it had 68,000 transistors in it
just like I say useless piece of
information for you so the idea was that
they wanted to create a machine that had
less instructions but potentially more
registers so that you could do more
things using very quick references to
memory rather than having to go to main
memory which was slower and in fact one
of the architectures that came out of
that was the SPARC architecture and that
was what we did at Sun for a long time
and now door achill
so then what they actually produced was
the acorn RISC machine and that was the
first if you like arm because if that
was if you reduce it down to its I
suppose it would be a risk of them but
they actually called it the arm so that
was a 32-bit data address lines 26 bit
address space and 27 registers and the
first machine that they produced of that
was the acorn archimedes I saw not many
people put their hands up to say they
had a BBC micro anybody having
Archimedes oh okay Android did oh and
then the back as well great okay two
people so then the time went on and they
basically spun off the the chip
manufacturer or the chip design
business I should say from a corn and
they renamed the arm the advanced risk
machines so that's where arm came from
now if you look at the features of the
ARM processor it is a 32-bit risc
architecture so it's designed on the
same ideas that they had before
interestingly arm now accounts for about
75% of the embedded 32-bit CPU market so
if you've got an iPhone if you've got a
lot of different Android phones they're
all using ARM processors inside there's
lots and lots of places where ARM
processors get used and in fact last
year they sold over 8 billion ARM based
chips that brings to grand total over 30
billion in facts the the number that was
told to me yesterday was about 35
billion in total absolutely zero of
those were manufactured by arm which is
really quite impressive because
basically they design the chips and then
they sell the designs to other people
other people then put them into packages
fabricate them and actually produce
chips from them
now what makes in terms of the yeah well
yes like I say so abstract architecture
and microprocessor designs is what they
actually sell and then the Raspberry Pi
ARCA say is based on an arm and Levin
processor with an arm v6 instruction set
so the you have different versions of
the instruction set which we talked a
little bit more in a moment one of great
things about the ARM processor which
makes it ideal for the Raspberry Pi is
the fact that it has very low power
consumption so basically that means that
it's good for mobile devices because it
doesn't generate a lot of heat and it
means that you can power it in terms of
the Raspberry Pi off a 5 volt only power
supply you don't need 12 volts and 5
volts which you need for most pcs and
you can get away with 700 milliamps
which means that you can use a USB
device ok that's more than you can get
from a standard USB port but if you've
got something like a map that will
actually give you enough to power your
Raspberry Pi and you can easily buy one
of these wall plugs which will give you
enough to power your Raspberry Pi so
again it makes life simpler into
of being able to get these things into
the hands of children because you don't
need to buy a screen you don't need to
buy a particularly expensive power
supply to run it so it keeps the price
down the other thing is you don't need
any cooling because if you run it and
you put your finger on the program the
chip in the middle you'll find that it
gets a little bit warm but it's not
anything like hot so it's really good at
actually not using a huge amount of
power and if we don't need a fan you
don't need a heatsink so in terms of
current arm technology there are
different versions so there's the arm v6
which is the sort of slightly older
version that they have at the moment
there's the arm 11 and then there's the
arm cortex-m which are different
implementations of that which people
will then use to produce chips on v7 is
the sort of the current version the most
up-to-date version that's being used and
there's a number of different versions
of that there's the Honourable cortex a
the arm cortex-m the ARM Cortex
are basically those vary in terms of the
amount of power they require the clock
speed that they run out and so on on v8
is the the new version that has been
announced but is not actually shipping
yet and that's going to support 64-bit
data and addressing 32-bit instructions
and going to have 30 registers so
they're looking to move more into the
idea of the enterprise market there's
actually companies now that are building
racks of ARM based boards that will run
as Enterprise service the advantage of
course is because it's a low-power
consumption it reduces the need for
cooling and that can reduce the cost of
actually running a data center by a
significant amount let's talk then about
Java on the ARM processor and
specifically the Raspberry Pi so one of
the things that we have an issue with is
that in terms of Oracle we have had
embedded Java for quite a while and we
have different versions of that which we
address at different types of processor
because we're not just dealing with an
Intel processor here so we need to
address specific types of processor what
we've had is a version of embedded Java
we'll run on an armed v6 processor but
the specification for armed v6 doesn't
mandate the inclusion of a
floating-point unit so we don't expect
there to be a floating-point unit so we
don't actually configure it to use
hardware floating-point so we configure
it to use a library which will emulate
the idea of floating-point do the
mathematics in software floating-point
units only became mandatory or part of
the specification if you like unarmed v7
in terms of the Raspberry Pi it does
have a floating-point unit in there so
there is hardware acceleration for
floating-point mathematics the thing is
that if you use a library and you do it
in software it's a lot slower than doing
it using the hardware so that becomes an
issue in terms of performance what we
need to do is we need to create both a
Linux distribution and a version of the
JVM that use the hard floating-point
capabilities of the machine so it needs
to be a special implementation special
version that we can make available so we
need special builds both right now the
the Raspberry Pi organization have
released a version of the distro which
is based on Debian which is compiled to
use the hard floating-point so is the
raspberry and distro which is most
common one that people are using and
that's available to use hard
floating-point Oracle are currently
working on half floating-point version
of the JVM it's it's one of those things
that's actually technically very simple
but not simple to actually launch it
into the market the reason for that is
that from a technical point of view all
we have to do is set a few compiler
flags and run make and then we get a
hard floating-point version of the JVM
that's the easy bit the tricky bit is
that we actually do have to test it so
we want to make sure that there aren't
any like enormous bugs lurking in there
when we switch on hard floating-point so
what we're doing at the moment is we are
doing the verification of this I have
actually got a version of the the hard
floating-point JVM that I've tried on
the Raspberry Pi and it works quite
happily but of course because we haven't
done all the testing and the QA
associated with that
we can't actually launch it as a binary
distribution yet it will be happening
soon I can't give you a date this is the
one other places where my safe harbor
statement is actually useful so I can't
give you a date for this but it's not
going to be a long time before that
comes out no this absolutely I agree
with you absolutely and there will be an
early access version out soon but what
we need to do is internally do the
testing you know actually run all of our
regression tests internally and that
does actually take a bit of time
especially because we've got Java one
this week we've had a lot of stuff we've
been doing before Java one like I say
it's not going to be a long time before
you see it so don't be thinking it's six
eight months away mustn't mention dates
so it will be sometime in the future but
the near future shall we say so that's
where we're at with that now
interestingly from a Java perspective
there's a number of things that the
makers of the or the designers of the
ARM processor have done to make life
better for Java processing so over time
they've added more and more components
to the the instruction set that you have
in terms of the arm so we've kind of
it's still risk but it's risk with a bit
of sisk on the side so some of the
things they've added is things like
digital signal processing because a lot
of these chips get used in mobile phones
having digital signal processing is a
really useful thing to be able to
include it enables you to do things like
voice over IP directly on the processor
and stuff like that interestingly again
because the chip has been used a lot in
mobile phones they've actually included
giselle which is ineffective way of
executing byte codes directly in the
silicon it's a fairly basic
implementation so you can't really get a
huge amount of improvement in
performance from it but it's nice to see
that there is actually that included so
you know we could potentially take
advantage of some of that there's a
bunch of things called thumb thumb thumb
2 and thumb EE
which is basically about how you can
reduce the size of your executable so
it's not really like adding more
instructions it's like making the
instructions that you have already a bit
smaller so thumb is for 16-bit
instructions thumb too is for 32-bit
instructions and by manipulating things
like brands and stuff and leaving them
out you can actually reduce the size of
your code some ee is quite interesting
because that's actually being designed
around the idea of having a virtual
machine which is doing just in time
compilation so it works quite nicely
with that so that's again something we
could potentially take advantage of in
the JVM to improve performance
floating-point already kind of briefly
covered that neon is extensions to the
instruction set to enable media
processing so that you can do better you
know faster processing of media and
things like that it's a bit like SSE on
the the intel product range
I mean there's also some in security
enhancements which I don't know too much
about the details of that it's too
secure but it adds an extra bit to
instructions to indicate whether the
security is turned on or off for those
things so let's talk about some of the
things we can do with Java on the
Raspberry Pi basically I've divided this
up into the various sections that I've
looked at in terms of using it so
there's sound there's vision serial
access using USB and then finally using
the the GPIO lines so the first thing is
making a noise with Java on the
Raspberry Pi now I found this to be
rather troublesome shall we say it seems
to be that certainly with the earlier
distributions there was some issues
around not having inclusion of the ALS a
drivers for the the board so you
actually had to install those manually
because they were still in early access
those are now included in the system
directly so if you're using the latest
distros then you will be getting the
sound drivers with that and so you can
actually
things like a play and it will play back
where files without any problem so then
I started looking at the Java sound API
and trying to figure out what we could
do with that and I got very very
confused because there's a whole bunch
of stuff in terms of how Java works with
the underlying platform and it all kind
of relates to the ideas of platform
neutrality write once run anywhere which
can come back and bite you a bit because
there's like the ALS aid drivers on
Linux which handle the sound on the
Raspberry Pi but then there's also this
other thing called pulse audio which is
a sort of again it's a kind of platform
neutral idea for Linux so you've got an
interface which is consistent across
different platforms from a hardware
perspective and I I played around with
this for quite a long time I didn't have
enough time to really dig into it in too
much detail but basically I've got to
the point where I could play certain WAV
files without too much problem some of
the WAV files that wouldn't play
bizarrely would play if I used a play so
I don't quite know why they weren't
playing through the Java side of things
but they weren't if I tried to use the
MIDI interface then it would start up
and then it would just hang and despite
using s trace and trying to figure out
what it was hanging on there wasn't
anything obvious what I find a little
bit confusing about this is that when I
was playing around with this a while ago
on one of the earlier distributions I
somehow got sound working but I don't
know how
and and so one of the things I was
testing on there was free TTS which is
text-to-speech and so sort of voice
synthesis and so one of the older
distributions I actually had free TTS
working but now I don't so I'm not quite
sure what I did before it's one of those
really irritating things where I can't
remember what magic incantations I'd
cast upon the machine in order to get
the sound working but when I go back
I'll go back and I'll hopefully figure
this out and then I will actually put a
blog entry up so that if people are
interested in using sound on the drawers
beep I then you'll actually be able to
understand how to do that so
hÃ¼seyin enable module in the kernel what
they which one the ALS eh okay I'll have
to talk to you about that later because
because that sounds interesting but um
come back to that
JavaFX on the Raspberry Pi clearly we
want to be able to take advantage of the
fact that you have video output and so
it would be really nice if we can also
include JavaFX for these very nice
graphical applications so where we're at
with at the moment is again it's
currently internal builds only we're not
we haven't actually released it
officially yet there is a release of jar
FX that runs on the Beagle board which
just came out a few days ago that will
work on the Raspberry Pi but we haven't
certified it yet because we haven't gone
through all the QA so it you can use it
and it certainly does run and I'll show
you that in a minute on the machine so
it's not too much an issue but we don't
actually officially say yes it's
supported on the Raspberry Pi yet a lot
of the work that we have to do there is
around optimizations for the prism
rendering engine which is part of JavaFX
and trying to get most out of the way
that we work with the the underlying
system because the Raspberry Pi has very
good capabilities in terms of graphics
we'd like to be able to take advantage
of those to give you the best possible
performance so right now the way that
we're doing that is we have
four different ways you can configure
JavaFX to run you can either do it as
x11 so if you're using the desktop
manager then you can run it with x11 and
you can actually have it run inside the
desktop manager and just as you would
with any other app okay application then
we've got handling the frame buffer
directly so there's actually direct FB
which is not currently working due to
the fact that the Raspberry Pi
implementation only does it in 8-bit and
the way that the engineers have done it
needs like the 16 or 32-bit access for
the direct frame buffer then there is a
frame buffer access with soft rendering
and then there's lastly an OpenGL
rendering with direct to the frame
buffer essentially what these things do
if direct FB was working the lower down
you go the list the better the
performance so if you run it on using
x11 it's actually going to be fairly
clunky once you get outside of x11 and
you start going direct to the frame
buffer you get much better performance
and if you use OpenGL as well because
that could be hardware accelerated we
can get some really quite good
performance out of that combine that
with hard floating-point because of
course you can leave the mathematics and
we should get very good results out of
that eventually I'll show you some
things that I've done and you can judge
for yourself
that would have been the OpenGL version
that was also running hard float which
is why we're not releasing it because of
course we saw that it had a little issue
where it little stumble there so it
obviously hasn't gone through all the QA
cycle yet so we want to make sure
everything's running but yes that would
have been OpenGL running on a half float
JVM with raspbian so another one of
things that you can do with the
Raspberry Pi is you can use a serial
port because if you look at the GPIO
pins there are a couple of pins which
are your transmit and receive lines for
the UART
on there if you are inclined you can get
yourself one of these Macs
what is it the - three - three - chip
because the thing is that if you use the
the UART directly as TTL logic levels so
it's 3.3 or 5 volts depending on how its
configured if you want to use rs-232
rs-232 is 12 volts so you need to be
able to change the voltage and this chip
will do that very nicely for you so you
can solder that up with a few capacitors
and you can end up with a very nice
little box like this which provides you
with a set of connectors that you can
pit connect to the GPIO lines and then a
standard rs-232 sort of D type connector
what that allows you to do is to access
the console on the Raspberry Pi through
a serial port so when it boots up if you
don't have a monitor connected you can
actually see all the boot messages
coming through the serial port and so
this is the way I actually use the
Raspberry Pi when I'm at home is I have
it connected through a serial port and I
just use putty and I can see all the the
boot messages come up and that way I
don't have to change the monitor from
one of my other machines so it's pretty
easy to do that and you can get access
to the serial port like that in terms of
USB peripherals USB is this universal
serial bus but it's not quite as simple
as serial because with serial you're
just dealing with a bunch of bits and
bytes that you send at a particular
speed across a link with USB some of the
devices will appear to be like a serial
device a lot of them actually need
specific drivers it's the same as you do
with any operating system you need
specific drivers so if you're lucky you
plug something in you see something like
slash dev slash tty USB 0 and you're up
and running and you can communicate with
it using a serial connection some more
complicated devices if you want to use
them on the Raspberry Pi there is the
USB libraries and you can actually hack
some native code and then talk directly
to the USB device it does get a bit more
complicated in terms of figuring out
what specific things you need for the
communication protocol and so on but if
you want to you can install USB - 1.0.0
dev and that gives you a lot of the
stuff you need for the USB libraries
from a Java perspective working with a
serial type device whether it's a USB
one or a serial port then you can use
the rx T X package that's really an
extension to the Java comm API or a
reimplementation of the Java comm API
so again apt-get install live rx T X -
Java will give you the libraries that
you need and then you can just reference
those the jar file in your application
and then you can you're up and running
one of the things that caught me out a
bit until somebody explained what I
needed to do was that by default the
devices that are probed by the rx TX
libraries are only slash dev slash TTY
capital S something so s0 0 1 or s 0 0 2
if your device when you plug it in is
TTY USB 0 or T to R ACM 0 then it won't
be seen by the libraries but what you
can do is you can set a property in the
in your code so system that set property
GU dot IO dot r xt x dot serial ports -
the name of your device and then it will
pick it up so it just makes it a little
bit easier because what I was doing is I
tended to do a symbolic link between
slash dev slash t gy s 0 0 for to my
device and every time to reboot to the
Machine I lost it so it was getting a
bit irritating so this is much better
solution to the problem one of the
things I looked at and I basically I
found this through looking at somebody
else's block so somebody else had done
the hard work for me was the OWI robot
arm and there's company in the UK called
map Finn who sell these and they were on
special offer the weekend that I saw the
blog entry so I thought oh I have one of
those so 25 quid got me one of these and
I set about building a Java interface
for it so that I could actually use it
so it comes with a USB interface but
it's not a serial type of interface so
you do actually need a bit more
complexity it has a windows only driver
but it is recognized by linux as a USB
device so when it when you look at D
message you will see that it has
recognized it as a USB device and
therefore in slash dev slash bus / USB
there is a device that you can axe
to talk to the controller that's on
there so what you can do is you can do
write some native code talk to the
specific device and actually have it do
what you need to do I guess in theory
because you could open the device as a
through Java you could probably get away
without using J&amp;amp;I and without using
native code I haven't actually tried
that yet it only occurred to me the
other day that you could probably do
that so I might go back and see whether
I could do that without using j'ni it's
very simple control protocol three bytes
message you send to it which says byte
one controls the arm by two controls the
base going left to right and by three
controls there's a little light on the
the arm and then you can combine
movements if you do some bit twiddling
to sort of combine the motors together
and so you have to do some a little bit
of fudging it if you want to stop one
motor individually because you you have
to stop all the motors at the same time
there's any one stop command so you have
to remember which ones are running and
then starting again immediately
afterwards but it's it's fairly trivial
so from a j'ni code point of view a few
native functions that need to see
functions using Lib USB again because
the protocol had already been decoded by
somebody else it was fairly
straightforward for me to just have a
look at the code and and figure out what
needed to be done and then using j'ni
you can define a native method in your
code you then create the necessary stub
header file using java h and then you
can compile that into a shared library
and then off you go
i did find that j and i I've used an ID
before but I do find J and I bit hard
work it's it's not as easy to use as it
could be which is probably one of the
reasons why in some time probably JDK
n-- jdk 9 or beyond we're actually
talking seriously within Oracle about
rewriting J&amp;amp;I and making easier to use
and funny enough when I talked to one of
the engineers about this he said oh yes
we deliberately designed J and I to be
difficult to use so that we could
discourage people from using it
that's that's not the best approach the
design of software is it really so in
terms of control of the robot arm once
you get to the Java level it's pretty
straightforward so you've got your Java
wrapper methods so I guess I want to
move the arm gripper in a particular and
then sleep for a particular time so it
moves at a particular distance then we
can stop it then we close it going the
other way and do that so I'll show you
an example of that when I show you the
demos in a few minutes so the next thing
I decided to connect to my Raspberry Pi
was a gamepad controller so I bought one
of the standard USB gamepad controllers
and set about figuring out how to use
that so Linux supports the drivers for
those out of the box so it's very easy
the Raspberry Pi supports it or works
very nicely so you get the appropriate
devices that you want slash dev slash
input and then there's this nice Java
API that was written many many years ago
called J input so for gaming it's
already been done it's a nice mature
technology nobody touched it since 2003
so all I had to do there was recompile
the code on the Raspberry Pi because it
didn't need a couple of tweaks because
there's been a native code that gets
built into that as well so when I want
actually went about compiling it I had a
couple problems with the class path
which seemed odd and then there was the
reference to a variable that had been
defined in Linux some years ago and then
it had been dropped from Linux because
they decided they didn't want it anymore
so I just had to comment out but a code
for that and then I also had to rename
the the the step so I had to rename the
shared object library that I created to
add a dash out of 64 onto the end of it
I don't quite know why but after doing
some s trace and figuring out what it
was that it wanted I renamed the file
and it all worked so since one of those
bizarre things yeah devices yes one of
the things that it's kind of interesting
so that the input devices that you get
on
the Linux distribution when you plug in
the game's controller it will create the
necessary device entries but it doesn't
always it doesn't give you read/write
access to everybody so it's it's a route
device and it doesn't give you
read/write access to everybody so I
spent quite a while trying to sort out
you dev rules anybody used you dev rules
few people I don't like them I couldn't
make them work I must go back and try
and fix that because you can in theory
set up for you dev rule so when you plug
something in it will set a particular
permissions it will set a particular
ownership and do all sorts of things but
every time I tried it it didn't work so
from a code perspective it's not too
difficult to to get things working so
what I did was I wrote a small library
at that sat on top of J input so I just
created new gamepad controller and then
I set it up so I had listeners organized
for the different events so I could
listen for a particular button being
pressed on the game controller to do
something and I could listen for the the
joystick so whether it's moving left or
right I pull down and so on and then
just have a thread sitting in the
background that's picking up the
information from the game controller and
then generating the events in my
application and then if we want to use
that then it's pretty simple we create
ourselves a new listener we add in some
code where we say okay if it's button
one we want to control our robot arm so
we just say okay set the gripper like to
be on and that's all nice and easy and
if we want to move the robot in a
particular direction we can use the
joystick and process the events from
that and then control the robot arm so
it's really kind of linking the two
things together so as I'll show you you
can control the robot arm using the
gamepad controller okay
so just a little bit about the GPIO
lines this is a sort of diagram of the
different lines that you've got they're
kind of color-coded depending on what
the because they happen some of them
have more than one use so there are
numbers which are the actual number of
the line which you can access as a
general purpose input and output line
and then you've got things like you've
got the five volt power line you've got
a 3.3 volt power line you've got one one
round pin that's that's a slightly
slight downside but if you look at the
p2 connector which is another little
header pin you've got there are two
other ground pins on pin 7 and 8 so if
you're doing something which requires
more than one ground pin there's
actually 3 that you can use if you go to
the ii connector and then like i say
you've got things like I squared C so
your SDA SCL lines you've also got the
SPI with MOSI miso and s clock so you
can talk from the processor using those
protocols and like I say 14 and 15 the
two orange ones at the top there those
are the UART lines so that you can get
the the serial console now using those
does require some very magic
incantations I did not do this myself I
found some very very clever person who'd
written a blog entry about this because
there's no way I would have been able to
find this this weird kind of memory
address stuff thing so basically you've
got a memory map some of the address
space of the of the system and it's like
if you did basic with the BBC micro or
something like that peek and poke so you
end up memory mapping the slash dev
slash mem and creating a mallet block
and then doing some memory mapping there
and then essentially what you need to do
to use the GPIO pins is do some bit
twiddling so if you want to set a pin
for input you need this rather obscure
set of bit twiddling of different things
if you want setup in to be output you
have to set it to be input first and
then set it to the output so you can
combine those two together and then
basically for output you've got the idea
of setting the pin high or setting the
pin low you can also do input of course
but for output you can set the pin high
you can set the pin low so what I did
then was obviously hide the magic
incantations with J&amp;amp;I I thought about it
afterwards and one of the things is that
dev mem you do need root access
so you anything that's going to use GPIO
lines like GPIO lines does have to be as
root
one of the things I'm gonna try when I
get home is to actually write a device
driver take myself back way back to when
I used to do device driver work and
change that so avoid the problems of
actually having to do it as route so you
can do it as a just a normal user and
then you just end up with some simple J
and I type code where you can do GPIO in
it then you can do out set particular
pins to be output and you can then set
them either low or high depending on
what you want to do so here's an example
of how you can use the GPIO lines I have
here a Lego motor which I'm going to
show you actually working in a couple of
moments and in order for that to work
because I have this this project that
I'm working on because a long time ago I
built a robot which was a blackjack
player and I did it using Lego and I
used the old Lego Mindstorms version won
the big yellow bricks and I used Legos
so I wrote the code in Java and then I
programmed it on the these bricks what I
really want to do is I want to go back
to that project and actually use Lego to
do all of it the so it uses the
Raspberry Pi to control all the Lego so
I can actually have a Raspberry Pi
blackjack player so the first stage of
that is getting the motors working now
the motors that you use with Lego and
nine volt motors and clearly you've got
TTL logic which is a very low current
you can't drive them directly with the
GPIO pins so you need a little bit of
circuitry here this is what's called an
H bridge there is a very nice chip that
you can buy the l293d I thoroughly
recommend getting the D variant of this
chip because it has the diodes that you
need built-in if you buy the nandi
version you need to actually put a whole
bunch of diodes around it as well so if
you buy this this one it's very very
simple to wire up you simply have two
GPIO lines that control whether it goes
clockwise or anti-clockwise and then
you've got your power supply from the
Raspberry Pi
ground from the Raspberry Pi the power
supply for the motors and then the two
wires for the actual motor in order to
control it and it's it you know me as a
non Hardware person even I can actually
build a little board that controls a
couple of motors
for spi and I squared see there is some
work that's been done if you go to
there's a guy called Chris boot and he's
written a blog entry about this and he's
actually published a bunch of code that
you can install into the kernel which
will give you access to the the SPI
interface and also the I squared C
interface I haven't actually had time to
try these out yet so I haven't got to
the point where I've done any Java work
with that one of the things I've bought
recently is I've got a little display
screen and again I found somebody's blog
entry I like blog entries where
somebody's shown how you can actually
drive the display from an SPI interface
and so I've got a bit of soldiering to
do when I get home and then I'll be
plugging that in and see if I can
actually drive the display from the
Raspberry Pi with the idea that I can
then implement Java X on it and have a
you know a mini iPad maybe yes
absolutely yes ok yes ok ok no no fair
enough fair enough yes it's yeah I I
take your point exactly so I have
demonstrated a lot of complexity which I
wouldn't want to put in front of your
average eleven-year-old who doesn't know
anything about programming but that's
not that's not the idea behind the
Raspberry Pi initially the Raspberry Pi
from an educational point of view what
they're doing is they're providing the
idea is to have a system that will boot
up you get an X windowing interface and
then they will use things like scratch
to start with so they will learn about
programming through things like scratch
then they'll move on I don't notice
Michael in the room Michael Colleen oh
yes there is
so Greenfoot is one of the things that
we're we're looking at in terms of
getting that running on there so that
you've got the ability to have move
children through from scratch through to
IDs which designed to help children
understand how to start program and then
they can move from green foot in to
bluejay
and then from blue jay internet beans
and so a lot of the stuff i'm talking
about is more the hobbyist kind of thing
rather than a school children's kind of
thing but you know the capabilities are
there and what hopefully we can do is if
we can make things simple from a Java
perspective so if we can publish the
necessary libraries and things then we
can make it really easy for the more
advanced students who do under start
understanding Java to then be able to
pull these libraries together and then
build things that use a gamepad but use
the you know the control lines and
thisone things like that
I wouldn't expect your average
eleven-year-old to be tacking SPI or I
squared C right now so yeah but it's a
good point yes so I could say he has
done some work that's created a number
of some code that you can use and will
actually give you devices that access
the I squared C and the SPI interfaces
so just to sort of conclude the the
presentation part before I get on to the
demos
ra's be point is very cool and very
cheap computer ultimately is a Linux
computer but it does allow you to do all
sorts of great things it is great for
teaching there's lots of potential for
it it's great introduction to the ARM
processor if you do want to go into more
complex things low down Java works
pretty well it will get better we're
certainly targeting the Raspberry Pi
specifically as one of our platforms in
terms of embedded because we want to
help both the Raspberry Pi organization
people at the green foot organization
want to make sure these things work well
when people see Java in this kind of
area so opportunities are limitless okay
a couple places further information
obviously Oracle comm embedded there's a
Raspberry Pi user guide that's just been
published by Evan Upton who's the really
one of the main founders of the
Raspberry Pi organization and then of
course Raspberry Pi dot org which is the
place where there's all sorts of
information being published about what's
going on so with that let's move on to
the demos which are potentially some of
the more interesting parts so what I'm
going to do first is I'll just show you
how much time I got seven minutes okay
that's not what I expected there we go
right so I'm just going to show you one
simple application running I didn't
running JavaFX
as I can't sink oh yeah that's right
right
this is why I always tend to use oh
thank you thank you
at least I put the message in there
right let's try that again that's better
okay that's not so good
okay I'm gonna I'm gonna skip this one
for now cuz yeah oh hang on no I know
what it is and I'm yeah give me a second
don't run away I thought I fixed that
obviously I hadn't
yeah there was a typo
it does take a little while startup
because this is the soft load version
and it's not tuned and it is still as
you can see early access so don't worry
about that that wasn't what I was
expecting to see either okay I'm going
to give up on that one yeah that's
pretty poor isn't it it works on my TV
in my hotel room but clearly it doesn't
like the wherever the
right okay let's go back to this well
avoid that let's do some other stuff
right so like I said I've got the the
Lego motor there so what I'm going to do
is just run a little application and all
it's going to do is just move the motor
so that's not very exciting is it so
just move it a couple of times backwards
and forwards I use that really just to
make sure it was moving in the right
direction and also to calibrate it in
terms of how far it moves for a
particular amount of time okay so that's
that so did anybody come to my session
yesterday where we did the connect stuff
and the things like that yes like I know
you were there okay well that's alright
so that that's not gonna that's not
going to spoil the excitement for
everybody else then okay so what I'm
gonna do is I'm gonna plug this in right
what I've got here is a thing called a a
neuro ski or neuro sky headset which is
essentially a brain monitor and what you
do is you can actually connect this
through a USB dongle to your to your
Raspberry Pi and hopefully I'll just run
this I'm gonna learn let me see if I've
turned remember to turn it on first
this helps sometimes don't get a very
good connection which can be problematic
let me just see if this is gonna okay
right we've got some readings that
that's the important thing so I'll just
check that right so now what I'm going
to do is I'm going to use the the sense
that I've got to Ramana to my brainwaves
and one of the values that it returns is
my attention value and then what I'm
going to do is so what I'm going to do
is I'm actually going to use that value
to control the motor so if I do say the
theory okay there we go yep it does it
once a second basically so it's
monitoring my attention so in theory you
see the more I are focused on it the
more it should move I'm not totally
convinced by that it is moving if I
could definitely move it but I'm not
sure that I'm thinking about something
which is moving it is just you know it's
kind of like a random number generator
but anyway you get the point so so what
I really wanted to do was to show that
you could actually connect you know
multiple things there so then I'm gonna
how much time I forgot not very much
okay we just just connect this I'll
connect my robot arm now I do have
right now I just have to check whether
because sometimes it doesn't like yeah
okay so it's found the device because
sometimes it gets bit confused with the
USB now the other thing I have to do is
I have to remember to change the
permissions on
cost a few magic incantations now in
theory right so if i just run jeep and
right so first thing i just just run
this because it mmm okay now point your
exception 100 i know hang on
yeah okay
alright let's try that again
okay that does why she was working in my
hotel room literally an hour ago I come
here it stops working
I got no idea why that is not working
mmm I'll try unplugging it to plug it in
again
I'll try plugging it in
that'll be it I plug the keyboard back
in that's that's what the problem is
okay that that will help right
okay now that's better right yes okay
good so so basically now I can do things
like I can move the the joypad
and joysticks and I can press buttons
and get the events from that so that
that's actually working good okay so now
if I just do the very last demo
hopefully it'll work now I do have a
problem and I do know that sometimes the
the motors there's this USB thing where
it gets stuck okay and now it's not
doing anything I did turn that one on
and I did plug that one in
ah
you know should say more than that okay
I'm really sorry about that I don't
think that I think I've run out of time
for that one so I've got no idea what
that one's not working but it was
working before honest</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>