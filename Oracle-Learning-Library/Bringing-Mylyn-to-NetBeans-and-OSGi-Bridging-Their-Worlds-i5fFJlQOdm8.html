<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bringing Mylyn to NetBeans and OSGi, Bridging Their Worlds | Coder Coacher - Coaching Coders</title><meta content="Bringing Mylyn to NetBeans and OSGi, Bridging Their Worlds - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Bringing Mylyn to NetBeans and OSGi, Bridging Their Worlds</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/i5fFJlQOdm8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for stopping by we are really
glad we have some audience so thank you
a lot my name is ciara Slav to LA and I
work on NetBeans and together with me
this is tomas toopka he is working on
NetBeans as well and he is responsible
for Milan integration and Stefan tingle
is from desktop the company behind
behind my lane and he's basically
helping us integrate milan in to
NetBeans so Stefan it's your turn tell
us about Milan thank you I thought you
were helping us to evolve Milan so I'm a
committer on the my own project and i
work for tau sub technologies which is
the company behind the Eclipse my own
project and we want to take you serves
through the process how NetBeans ended
up with Milan support and we're going to
start looking at Milan looking a bit at
the history of Milan to to see where my
own is actually coming from in houses
API is in Milan evolve that NetBeans is
using and then look at NetBeans and how
NetBeans is consuming those api's and
then Thomas will show a demo of how
that's working now and we'll go over the
lessons learned from that experience so
around a decade ago mcpherson the
founder of the milan project was working
on aspectj and that was around the time
when kent beck published his book and
the aspectj project was following the
principles agile development process
explained described in this book and in
that project they were using outlook for
project communication they had some
defects in bugzilla they have microsoft
sharepoint for for managing their
stories and the day-to-day work was
happening in the Eclipse IDE so what
make notice at the time is that there
was a lack of integration even though
all these different systems were
important for the project they weren't
integrated
with the the tools that developers were
using day to day so that was sort of
mixed first moderation to think about
the Milan project and I make looked at
the IDE and a little more detail and
what you notice is that the IDS is very
good at showing you the compiler centric
structure of the system so the typical
IDE has couple dozen project has
thousands of classes and you get instant
access to all these different artifacts
in your system but when you're when
you're fixing a particular defect or if
you're working on a particular feature
usually only really care about a handful
of classes that are relevant for that
task at hand that you're working on but
this IDE shows you the entire system so
it overloads you with with information
and this is what we call the task
context this these number of artifacts
that are relevant to your task at hand
you lose that context every time you
multitask so every time you switch to a
different task you lose that context and
when go back you have to rebuild that in
your memory and that was mixed
moderation to build what we call the
task focus interface and that task
focused interface what it provides you
is it filters everything from the IDE
that's not part of the task context and
it monitors your interactions to
automatically create that task context
and at the time that was around 2004 and
while Mick was doing his PhD at the
University of British Columbia this task
focused in a vase was basically an idea
on a whiteboard and what was very clear
already at the time I said in order to
to enable this task focus interface the
tasks had to become a first-class part
of the IDE so make
started started working on this um as
part of its page d and and moved and
created a project which called this was
called mylar at the time at eclipse the
time it was an eclipse technology
project and to bring those tasks that
already existed in bugzilla and JIRA and
and other issue tracking systems into
Eclipse IDE mix started by creating the
an integration for bugzilla because that
at the time was what Eclipse orc was
using and is still using to track all
the other defects on tasks so in that
initial version that um let me put on
Eclipse the the mylar project had a
bugzilla connector and the second
connector that may create it was one for
jira um that allow people to access AG
or task from eclipse and at that time it
was already there was already a little
bit of abstraction so they they looked
at what's common between bugzilla and
JIRA and started creating what has
become the task framework so a little
bit of abstraction that for the common
API concerns and that was around the
time when I joined the mile our project
doing my summer of code project for
google i developed a track connector
that build on that common abstraction
that they had created and over time that
my luck project turned into milan was
added to a lot of the EPP packages which
you can now download from eclipse org so
most of the time when you get a download
from eclipse org that will already
include Milan and eventually the the
project started expanding its scope from
from just tasks to all the way to also
coat reviews and builds in hudson and
jenkins and we we decided to create a
top-level project um that is and split
these different concerns into
sub-projects so the my own project is
now now six or eight different projects
that cover
concerns of the application lifecycle
the TAS integration does a the bugs will
attract your and so on integration and
there's builds and reviews for for these
new concerns and what's really
interesting is that each of these
subprojects has a framework component
and it has several reference
implementation that implement the
framework and the framer component
provides the generic API to access tasks
or builds or reviews and then the
different extensions connectors I'm
provide access to specific systems these
are the ones that are part of the
Eclipse Milan project and beyond that
there's a huge ecosystem of some
commercially available connectors some
open source connectors that are
developed outside of Eclipse org that
build on that very same framework that
we created and looking at this on a
technical level each of these framework
modules or connector extensions is
essentially a plug-in a clinic lips and
all of these plugins run in a common
runtime which is called equinox and
equinox implements osgi so in accra
notes these plugins are called bundles
just a different term and each of these
bundles defines in its manifests which
other bundles it depends on and which
packages Java packages it exports which
is its API that other bundles can
consume this chart shows on the
transitive dependencies of the bugzilla
core so that's basically the the core
portion of the connector that is also
consumed by NetBeans so you can see
there's an out maybe 20 25 different
modules that you need to consume that
bugzilla integration
and this works really well because all
of these modules follow a very strict
API contract so so mile and 38 is
backwards compatible all the way to my
land 2.0 which was released three four
years ago so any extension that you
develop for a mountain three point 0
will still work in Milan 2.8 and that's
because the the version the way that we
evolve the api's follows a very strict
contract so we always maintained that
backwards compatibility and what's
really interesting to me is that because
we we had this modularity in mind
initially when we developed the task
focus interface setting out for for a
completely different goal than than
doing a net beans integration we were
still able now to to satisfy a
completely different and completely new
use case building on top of the
frameworks even though we had something
completely different in mind when we
start the project and that's possible
through through those strict versioning
constraints and through those strict API
contracts and looking at the task
framework in particular which is what
NetBeans uses it basically looks like
this so there's a framer component that
defines in a service provider interface
and that service provider interface is
consumed by integrators that build
connectors and connectors are our
understand how they can connect to a
specific task repository like bugzilla
rgr track they typically go over a rest
interface or soap interface like some
are our PC or something like that and
they understand the domain model of that
particular task repository and provide a
mapping to a generic task data model
that's defined in the tasks framework
and the SAS framework provides services
like an offline store
so the connector gets a task from
bugzilla translated to the generic data
model and then the task framework will
handle persistence in the offline store
for example and the task framer
component also exposes an API and that
API is what's consumed by the Eclipse UI
and is also now consumed by NetBeans and
what's really neat about this is that
since NetBeans only couples to the API
part of it interior you get all the
extensions for free since the entire
framework part has a generic data model
that's agnostic to whatever the
connector is doing NetBeans can simply
consume the the Milan API and then
leverage that whole ecosystem of
connectors that's already out there in
theory and that the task model is
basically a Dom odd that has a generic
attribute scheme and provides some
metadata for the different for the
different data different attributes that
are part of a task you get a label you
get a type and so on and it's even
possible to generate generic you is
based on that metamodel and I'll
handover it to you now to show us how
that works in that means
thank you Stefan so first thing I'd like
to start is talk a bit about NetBeans
history because from describing the
history it should be apparent why we
decided to support osgi NetBeans started
as a student project in Czech Republic
and I was one of the students that
participated in it we basically
originally we wanted to create adelphi
for eggs windows and wrote that in CC
plus a C++ but you know student projects
we were meeting every week and
discussing the design and I'm going to
pop and doing that for almost a year and
we did nothing and after a year I
suggested well there is a new
programming language Java shouldn't we
tried it because I had experience in
Java from some other project and other
students are not way in a way so for
next three months we were meeting and
still doing nothing or progressing
nowhere but as after three months I
proposed to use Java again and addy and
they decided to really write ID in Java
and we successfully finished the project
as certain people say that it was
because nobody at no teacher at charles
university knew how to compile and
execute java so people couldn't play
with it and of course when we did the
demo they we know what to try and what
to avoid so we successfully finished the
project and then we decided to sell at
that time it was called self i as a
shower we have much money but we
attracted attention of of entrepreneur
who was reading sybase for central
europe but he was he didn't like the job
and wanted to start a startup
was looking for good programmers so he
found us and we created a company which
later became NetBeans in 1997 in 1999 we
were acquired by sun microsystems and
the first thing sun basically did was
that it decided that Nadine should be
open source so in the middle of year
2000 we became an open source project so
right now since then we are working in
the open source space we are swing based
ide for various technologies and we have
actually 1.2 million of active users
that use the ID at least twice a month
also I was the original architect of the
beans ID and actually I didn't want to
design ID I wanted to design a platform
for generic applications but we couldn't
find a business use case for that so
basically we needed to create the ID for
a living but the goal behind or my goal
behind was to design a platform that you
can use for any kind of application
something similar to eclipse RCP so we
have it part of the platform was also a
modular system it's homemade modular
system which we developed in course of
the years and it is very similar to osgi
it stores additional information about
exported packages we call it public
packages in manifest it stores
dependencies between different modules
in manifests so so sort of similar
system now let's jump into year 2009 at
that time I was
I guess it was in April we learned that
some is close to collapse and that the
jonathan schwartz our former CEO is
negotiating with a curve it IBM to do by
us and the team in prac working on
NetBeans freaked out because IBM spat is
eclipse and we would very likely not
survive at all so we were really pleased
that after two weeks it turned out that
we are going to be acquired by oracle
because we didn't know what a doric
appliance but at least we thought we can
get a chance so we will not be killed
immediately when we are acquired but
this was in april two thousand nine and
it took a one year and a half before we
actually became part of oracle at least
in in prac and you can probably imagine
that the team was not certain about
future p / well very depressed nobody
wanted to work so it was really tough
period of time because we knew that
oracle has its own ID jdeveloper we knew
that it supports eclipse and now it will
also or it will also own let beams so
it's good i'm actually glad i can work
for oracle because after working 10
years for sun I'm glad I can finally
work for a profitable company but even a
profitable company like Oracle can
probably kind of probably sponsor free
projects doing the same thing for an
unlimited amount of time so I got an
idea that basically we probably cannot
convince jdeveloper to be a rev written
on top of NetBeans platform I said okay
maybe we could convince them to rev
right to osgi and then make sure that
NetBeans supports osgi as well
and somehow we could then merge those
projects slowly so I convince our
management that the main theme for
netbeans six dot nine should be osgi
interoperability and we were not using
the OSGi in netbeans for our purposes at
that time we just wanted to offer the
NetBeans platform users and ability to
use osgi one of the use cases that we
described was interoperability with your
web server for example if you have a
form on in your rich client application
you need to perform a validation for
that you may need a module that does the
validation but the same module needs to
run on a glassfish server because as
soon as the data are submitted they need
to be verified by the by the server as
well so that was one of the use cases
the other thing was to reuse existing
api's bundled as well as GI bundler
seamlessly in in netbeans so the picture
on the right side basically shows how
the system inside of NetBeans looks like
so we are still keeping our module
system and dependencies between modules
but next to it neck next to it we can
also run osgi container at the time we
were supporting Felix and of course
these two words can live next to each
other basically without any problems the
only complication is when you want an
osgi bundle to talk to api's from
NetBeans module or if you want an
admin's module to talk to api's coming
from osgi osgi bundle so for that i
needed to patch Felix well actually my
first version was heavily dependent on a
reflection I was just messing with
internal structures of felix to
to convince it to convince Felix to load
classes from a4a bundle from NetBeans
module basically if you know osgi there
is a support for boot delegation so each
bundle can basically say that certain
classes should be loaded from a from a
class application class loader from app
from the boot classpath basically so i
was using this I just needed to so I set
for older yeah so basically I'm creating
fake osgi bundle which is completely
empty for each NetBeans module that
needs to be consumed by the OSGi by real
osgi bundles and I'm changing its good
delegation class loader to be the class
loader of Jeanette beans module so
basically whenever someone needs to load
something from the OSGi bundle it finds
nothing but then it delegates to the
NetBeans module system and the real
class is loaded by NetBeans and I'm
doing similar thing for the for the
NetBeans IDE which was easier because I
controlled the code base but at the end
i managed to submit a patch to Richard
Hall the maintainer of felix so right
now we have a proprietary api between
NetBeans and felix to hook in the
different class loaders for duty
delegation different class loader for
each bundle ok so basically that was the
public plan support osgi allows you to
share bundles with on your client as
well on the server but the hidden agenda
was we can hopefully align with
jdeveloper so i guess it was in the
middle of 2010 when finally the osgi
guys are sorry the Oracle guys started
to talk to us
for that there was no sign of
communication whatsoever so we could
only guess that we are doing the right
thing and it turned out that the
jdeveloper guys were watching what we do
with osgi and meanwhile the river Oh
jdeveloper to use osgi so I was
originally expected that it will take
years to convert jdeveloper to osgi but
then suddenly we were acquired and the
work has been done it had just one
problem jdeveloper guys decided to use
equinox so I needed to integrate
NetBeans also with equinox and
surprisingly that was easier than
integrating Felix because actually I I
like to say that equinox is not osgi
container it's osgi meta container it's
a it's it has support for many hooks and
by implementing these hooks you can
basically change the behavior of the
equinox and get something different so
there is a class loading hook which I
implemented to basically load the
classes from the NetBeans module and I I
could use official equinox API I didn't
have to do the dirty tricks like in case
of felix um so the only problem was how
to convince the jdeveloper guys to not
use plain equinox but use the mixture of
NetBeans platform together with equinox
and I actually I call it net binocs so I
decided I will try to convince them by
saying if you switch to NetBeans
platform with net binocs you will be
much faster so they gave me a time to
really prove that so after a probably a
half a year of coding I I managed to
really start jdeveloper about thirty
percent faster then it starts with plain
equinox and the trick I did is
have net in netbeans we have startup
caches on a first start of NetBeans we
basically load every class from its
appropriate module but we record what
classes are needed during step and we
store them into one huge file it has
about 30 megabytes and on next start we
just verified that nothing changed in
the configuration and then load this
huge file and we are not opening the jar
files at all so instead of doing a huge
amount of i/o we are basically luring
things in 11 go v load all the classes
and the result is forty percent better
start up for jdeveloper so jdeveloper
was famous for having really slow start
up by switching to osgi guys managed to
improve their startup so it started in
one minute if you have basically I'm
describing the case when you shut your
computer down to boot it on and then
launch jdeveloper or netbeans because
that's the most I'll intensive start so
jdeveloper could start in one minute
when we switch to NetBeans we were able
to start in 40 seconds or something like
that so basically since then we are we
have a common ground between NetBeans
and jdeveloper and we are starting to
reusing more stuff I I cannot talk to it
talk about it because there is the nasty
slide that we shouldn't promise any
future releases and stuff like that so
but we are using more from red beans but
at the same time we just said okay why
not why reuse just between jdeveloper
and netbeans can we reuse something that
Eclipse and primary project that we were
interested in was Milan so originally I
guess we had Milan we are using my name
since NetBeans six dot nine saved my
butt
at that time because the osgi support
was still too young and we didn't have
support equinox at the time we were
reusing Milan in a heckuva basically he
faked the osgi environment had our own
implementation that always return null
and stuff like that dommage is
responsible for it but of course when we
tried to upgrade to new version of milan
v founded out the emulation is not good
enough we need to implement new methods
so he said okay let's do it properly and
we really turned in I guess in 1971 the
or 70 iron we started to you really use
equinox and reuse Milan in the natural
environment environment so basically
when you saw the graph of dependencies
for bugzilla core it contained about 25
or eclipse bundles so those bundles are
running under hood of NetBeans as well
the perfect thing on Milan is that it
separates you I and the core part of
almost each connector or even the UI so
what we have in netbeans we are swing
based so of course we don't want to
bring in SWT but because Milan is well
written we can reuse just the core parts
and then implement the ID by ourself
implement the UI by ourselves so this is
what we did for the bugzilla connector
and for the gyre connector but this year
I visited Eclipse call and while being
there I could chat with Milan guys and
we said okay let's have a session at
javaone what we are going to talk about
what we are going to demonstrate so the
plan was to demonstrate a generic
connector
so basically if you would like to take
trek or from eclipse and then generate
the UI because the myelin contains meta
information about the about the task
model we should be able to do it so with
that it's probably too much turn to
demonstrate that more time
ok
and in my own yeah good so live already
ah like already mentioned we already
have two implementations of connectors
in that beans and that's namely bugzilla
and JIRA coincidentally the same that
Milan started with and we chose to be
actually in the beginning we decided to
write our own UI around swing do I and
that of course came with a lot of effort
because not only the whole coding had to
be done but also be very in the need to
learn about bugzilla and JIRA internals
etc and that's something it's just a
question if that's the best idea how to
do it because we already have three
requests for three other connectors
highly voted in netbeans and the
management isn't very happy about that
we always need a few months to come with
something new or a new support and
during the time like yellow slow
mentioned we just learned from our
desktop colleagues that there is a
possible other approach just that they
are already some metadata provided by
the Milan API by the task or API which
we could eventually try to use in being
more generic and not going into hand
coding every connector just from scratch
for the UI part of it now while it's one
thing if you somebody tells you
something like this on the phone and
other thing is just to put your hands on
it so so we just we try to or we decided
to try out the prototype to evaluate it
and to find out
what it what it would mean in like in
and netbeans as well like in eclipse and
now we are at the point that we have a
working connector or working prototype
which already at its current stage now
makes it quite easy to set up a
repository and to provide a rich task
you I in which we are able to edit a
task and we are able to invoke
operations on a task while still being
connect or agnostic we did this with the
track or or bangle and actually most of
the places in our implementation we have
no idea that it's track with which video
there at the place and that of course
brings the most interesting thing of the
whole story and that's the integration
into other ID workforce that's probably
also why Milan is so popular that it
actually helps to the users to automate
and look up information they need
currently at some context without having
to switch between environments and look
up files etc well on the other hand we
were already in the beginning thought we
knew it and the fact is that some
contracts and things are still missing
one of them is the repository metadata
which we would need to provide a query
you I just to fill out all all the
fields with all the products and
components etc well this might be
something we eventually could be able to
bypass somehow with a poor man solution
there is another more vital problem and
that currently we don't have a generic
way how to define a query at the
repository and how to execute it against
the connector now I would like switch
and so still I would like to show you
what we got what's already working and
what's as well as what's not working
I would start with eclipse i have here a
project and what I do is that I just
simply try to run it and nothing happens
besides the fact that I get an exception
and that's what we also encourage our
users just if you get an exception so
issue a task so I created to ask ticket
I submit
uh-huh
yeah sorry the server isn't running
it's listed at least we see that there
is a riddle server and behind it
ok
did I create it off
just gotta help me yeah it was working
yesterday and you know we didn't praying
after the demo belt and work I was
hoping that my Milan colleague will help
me I'll try one more time just to create
a task okay
oh this is
Oh
with you because I'm not in a network
ah ok yeah I was running the server a
virtual box but seems like that there is
something we do networking set up ok so
we created the task and now just let's
leave eclipse and switch back to switch
to NetBeans where would say I'm a
different user and I'm supposed to do
something with though we'd create a task
so we got here a kind of a task
dashboard which currently contains no
repositories nothing so I will start
with creating a track repository and
obviously there is no there is no
connector available at the moment so
let's go to our plug-in manager and
check there is any track plug-in
available well no plugins at all doesn't
matter anyway we have none on the update
center so what I'm going to do right now
I've heard the other about and it is
possible to reuse our osgi bundles and
Milan core connectors in netbeans and I
know that there is one on my disk and
that's actually in the NetBeans or in
the Eclipse install I just use the
moment ago so this is where I cut
Eclipse installed and there is a lot of
osgi bundles and I'm going after the
Milan track or one here so i select it
and let's see what happens and well when
i click on install the tidy and the ID
realizes that some dependencies unarmed
okay yet so i also i have to look for
something called google Gaeseong okay
let's cross the fingers now we are
Thanks doors ji actually just to deal
with the program in flavor so now I
should be okay and okay it seems to work
I click on next and continue and it's
running this little deal i has nothing
to do with the fastest osgi container
world it's actually here in the in the
moment when we are installing the plugin
when unfortunately it appears sometimes
sometimes not we had no more time to get
around it so it's still true that
Jadakiss forty percent faster my was
talking about startup in custody like
trying to kill the time actually I I
needed to implement API to breach
Eclipse registry into head games way of
registering things and probably die have
a little bug that it's it's okay I was
just about to shove it thank you
you actually have to research well as so
let's see how it works I supposedly i
installed it so i try to create a
collector or the repository one more
time and here it is track so i need a
name and I need the URL I need a
username and I need a password and for
example in compared to bugzilla or the
JIRA repository setup we are missing
here a validate button that's actually a
little thing but it's still missing in
the Milan API it's one of the things we
find out that it's not there this
dialogue here just doesn't know that
it's dealing with track it's just a
generic miling API object it tries to
provide its own data also we created a
repository now we are able to create
tasks or search for issues here so let's
try to find our null pointer five more
minutes okay so i'll be a bit faster um
let's okay or one thing this is this is
actually a dialogue which we kind of
pact we had to patch track that at least
the simple very simple kind of full text
search is possible and works but still
I'm able to search after summary
description keywords I'm also able to go
after a specific ID but in this case
it's not so not so trilling so let's run
the query and okay I got one hit I can
save the query
and now it appears in the dashboard I
could create a category and at they
should kind of a folder under which I
can store i hand-picked issues we plan
for the future to add more flexible
setups like we got inspired by emailing
so but okay I open the task and this
dialogue here like in the opposite to
the query dialogue it's actually
completely fed only what we got through
the task for api which okay the
description would be maybe a bit bigger
but otherwise we have here a few typical
or regular fields like status and a
report and modified then we learned from
the milan api that or we were provided
with information that there is a group
of six components of six attributes
which are default and it's the component
version milestone priority data etc and
we generically just create a UI but we
decided to do this in two columns but on
the other hand the user might have a
wider screen more space or he can kind
of custom it for himself then there are
three more fields or attributes which
come from a logical group called people
is to whom its assigned and who's on
copy and cetera well now ero slow
doesn't want to fix it so I accept it
thank you yeah and well yeah and for
that I used the another logical group of
hey tributes for creating the operations
and I use the accept operation we don't
know it is actually the accept operation
we just get a label and we know that it
is option etc everything from the track
or connector one more minute three more
minutes good and
well so I'll try to fix the issue now
about to do so i have to i need some
sources because i cut no project open
the head so i will check it out for a
subform a subversion repository where
actually the same project from eclipse
comes from yeah and
so check out running
right today okay and the ID recognized
that orbiting the check out there there
is also a project no matter if it's an
eclipse project I'm able to open it in
it beans I got here my sources so let's
evaluate the stick trace and I see ok
something's don't allow pointer probably
comes from this variable here this
member so try okay here it is
initialized and this is probably the
program because there is so I'll just
fix it I can add a comment to it
yeah and this is already where we
actually don't do anything with a track
or connector we just fall back on what's
already provided and netbeans for like a
task support well I'm not going to
commit it now i say i will create a page
first so I about to explore the page and
instead of saving it on a disk opening
it in a browser then and trying to
navigate to read from the process that I
can directly attach it to an issue let's
create a purge
and like we can see it was automatically
added to the issue and I could save all
the effort and time and that's okay at
this point I could show more things we
got commit hoops we got more support for
tasks oh I could talk a bit more about
what we planned for the future and means
of the task focused you I what well we
are running out of time so maybe just
one more thing that just with a little
bit of more effort by implementers of
connectors we are actually able to
provide quite more extra value and
significant value for our users and
therefore we it's also possible to
provide that particular technology for
our community so that its embrace and
adopted as well by that means users
thank you Frank I favor the Ala ok so
you'd like to continue with the lessons
learnt and Stefan can always jump in my
talk and describe that it's not how I
feel it is it's it's much better
definitely i'd like to place osgi it's a
fantastic thing for interoperability and
it builds the common ground and as soon
as we basically start to reuse from the
from the bottom then it's just a matter
of taking more taking more taking more
stuff satisfying all the dependencies
and things seem to work we have a limit
they don't want to do SWT but otherwise
osgi perfect Milan flexible design I
wish the NetBeans modules had some such
clear separation between you I and and
the core part we don't have it so
reusing hour of modules inside of i
could probably wouldn't be that easy
some problems which i can describe
is that the Milan cannot run on top of
felix so basically we had to implement
the equinox support that's because
that's especially because the Eclipse
libraries really require equinox and of
course nobody tried to run or use Felix
outside of eclipse before definitely not
in a GUI environment so it was bit of
challenge but I think it worth it I'm
metadata metadata are there the
intention is there but basically all the
connectors as far as I am aware in
Eclipse have their own UI so that means
that the metadata are not good enough in
most of the cases so we would meet some
improvements to really reuse more than
just a track and even for example the
Kaveri in the track had to be hacked
around this is a shameless plug this
week I'm going to publish new book about
API design and actually it's called it
talks about paradoxes and I've noticed
some of the paradoxes when talking with
the Milan guys so paradox time describes
that in case you produce API then it
maintaining code with API is simpler and
easier than to maintain a code without
an API because your users are
programmers they can program and you can
ask them submit a patch submit a bitch
and this is exactly what my lenten does
every time we needed something it should
ok create a patch submit a buck so we
did it it's great open-source
cooperation and that's exactly how I
think API should be designed who ever
has a neat should be able to submit a
patch so that works very well I would
also like to mention paradox 18 which
some houses that there is a clash
between Ryu
and use if you want to reuse a cert use
certain API then it's better to have it
a monolithic if you want to reuse it in
a different environment then actually
more modularity more granularity is is
better so sometimes we would like if all
the myelin bundles had less dependencies
on other bundles because then it would
be easier to reuse them in netbeans for
example we were discussing about the
registration of connectors so right now
it's using eclipse extension registry if
it could be done in more osgi like way
it would be easier to use used it in
order so right now I think all right now
as soon as we finish this project and
put that into production we should have
an easy way how to reuse almost any my
link connector inside of NetBeans we
just need good connectors we need people
writing connectors to provide good
enough metadata don't write any UI and
really let the UI to be generated and
yeah I've been told by David Greene that
you will have a TCK or you have a TCK
and you will probably release it so
passing the tck is definitely a good way
how to ensure that your connector is
good enough even for my Beach so that's
end of our talk I think I should mention
that osgi perfect for interoperability
Milan we had a great cooperation don't
be afraid to the you smilin and yeah I
think I am probably known as the guy who
shares
bit in jdeveloper and and now also I
clips so I would encourage you to share
it's good thank you or do you have
questions
Wow can you can you ask once again
I ok so the question is whether equinox
will become part a standard part of
nebulous so we first use equinox for the
jdeveloper guys we convinced them to
reuse or usenet binocs the modified
version in their product and a few
months later they ask oh you are not
reusing this in netbeans wow that's
trench so we wanted to fix that and
right now we are really using equinox in
netbeans as well because we are running
the bugzilla connector in netbeans
already it's part of the standard
release so equinox is there and when you
are creating applications built on top
of NetBeans platform you can basically
choose whether you want to create
application with Felix or with a Kleenex
so yeah it's already
actually that's soft so the question was
that I mentioned the Eclipse registry
being a problem whether we consider the
declarative services yes we did consider
the claret of services I even submitted
a patch for for Milan to allow the
connectors to be registered with
declarative services and make them
available inside of eclipse UI as well
as netbeans UI and that's exactly the
case because if the registration would
be done by the clarity services we don't
need the dependency on eclipse registry
at all which would make the whole
integration lightweight but Stefan I
will probably are not apply my page but
solve the issue slightly different I
mean just for historic reasons we've
been using me it curves extension
registry for most of our extensibility I
there's no reason why we wouldn't use
osgi services instead just but we
there's no reason to make that
transition right now either so um so
that's that's a reason why we're not
adopting on that change right now but I
think for future services will most
certainly use oci services also there
there was a issue because the
declarative services worked very well
for registering to connector but the
format in the extension registry allows
you to also register converters or
upgraders together with the connector
and that's not I didn't know how to do
it properly the dÃ©colletÃ© services so
the first version of the patch was
really nice slim but not fully
functional and the new version is fuelly
functional but not nice
any other question okay so thanks for
stopping by</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>