<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How and When to Write SQL in PLSQL | Coder Coacher - Coaching Coders</title><meta content="How and When to Write SQL in PLSQL - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How and When to Write SQL in PLSQL</b></h2><h5 class="post__date">2014-07-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HR7lj_tqUgs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">you
reading it everyone my name is Steven
Feuerstein I'm an architect for Oracle
Corporation and my focus is on applied
pl/sql you can see at the bottom of the
page my email address feel free to
follow up after this conversation after
this webcast you have any questions or
comments for me this is the first of a
six month cool the web poll on LS qual
the first three posted by Oracle are on
best practice pl/sql and the next three
are hosted by owed me Tugg oracle
developer tools user group and will
focus on high performance features all
my webinars are being recorded they will
be available on youtube or through some
mobile format and we will let you know
how to get that information when they're
posted and you can certainly stay tuned
by following me on twitter SF on pl/sql
and my blog steven feuerstein on pl/sql
blog spot.com and yes I should have
written those in on this page and I'll
write them down for me later
so in my first webcast for Oracle
Corporation I just rewind after 22 years
it's very exciting my first webcast is
going to focus on when and how to write
SQL in an oracle pl/sql now if you have
questions feel free to use the chat box
in the WebEx interface I'll take
questions largely when I'm done if we
have Prime and of course we can have
conversations after that online much as
you'd like okay so when and how to write
SQL on oracle nosql and i bet a lot of
people are thinking to themselves do we
really need to talk about SQL it's
something that we just do so I thought
we would start this conversation by
considering the typical and often silent
conversations we've had about us flow
and what I mean by often silent is that
I don't know about you but as I'm
writing my code or doing anything in my
world I often have a running
conversation with myself with many
voices going on there hopefully that
doesn't mean anything seriously bad for
me and so we will say things for
ourselves as we're writing code so what
do we say about SQL
oh it's so easy to write SQL and pl/sql
PL sequel is slightly integrated with
the SQL language you can write SQL
statements natively it's not even
something we have to worry about in
other words and I'll focus more on this
later SQL is taken for granted by PL
sequel develops
how about no one else will ever need to
write a sequel statement this I'm
writing a new program there's a specific
requirement I have to join with this
table that table the other table it
always seems like what I'm going it's
very specific and is not going to be
needed by anyone else ever
in other words exceptionalism we always
think that what we're doing is special
and different anew when in fact if
you've been around the block the Swamper
block from world one or for years you
realize that we mostly do the same
things or variations on the same thing
over and over and over again ha
here's a good one Oracle will optimize
it all for me automatically I don't have
to worry about how I write basketballs
label Oracle is going to take care of it
for me and you know Oracle does a lot
for us the Oracle cost-based optimizer
is extremely powerful and it will
optimize a lot of your s Quaffle but if
you really think you don't have to pay
attention how your wealth wall you are
drinking the kool-aid because Oracle
can't do it all for you
finally oh this one state insert
statement will never raise a Duke Balan
index error now I don't know about you
but I need to write a lot of s2 on my
wall at school of course we do and many
times the sequel statements could raise
ends so what I really should do is have
a very thorough going exception handling
strategy for my DML statements and
actually make from logging errors and
summon and so forth but you know what
what I do instead is nationalize more
believable in my lap well I'm going to
do an insert here but I don't have to
worry about an oral form of a dupe
outline index owner because we've got a
primary key it's never going to be
duplicated no problem well no qualm
value errors in other words we try to
get out of and this is not specific to
SQL doing the right thing I'm seeking
out a way to rationalize that we already
did it more or less so I think these are
some of the conversations we have asked
well let's drill in
now if we take a little bit of a step
back it's pretty clear to any of us who
have been around the Oracle database and
about around database centric
applications for years that the database
itself books sorry
from a pen gun the database itself and
the SQL language around the database is
the most critical part of an application
and I say this Wow sorry my mouse is
going crazy
the sequel statements that we write
directly reflect our business models and
those models are always changing plus
there's the data there's the data and
more and more data all of this
essentially defines our business and
defines our business requirements in
addition to that the SQL statements in
our application cause most of the
significant performance problems I mean
we definitely need to - and pay less
qual I'll give three webinars for more
on those topics but tuning SQL making
sure that your sequel is optimizing your
database swamp involves overwhelms all
other considerations waiting to pull
escrow on higher levels and staff and
then of course whoops then of course
there are many runtime errors in
applicants that result from integrity
errors check-in strains on tables all
sorts of things the bottom line is that
SQL statements in other words the
underlying database and the data are
have an incredibly large income the
quality of applications probably can be
wound point and so on now this is
particularly interesting because in the
last several years there's been more a
whole movement to put the word know in
front of one of the most important and
powerful enabling technologies of the
modern internet error which is SQL in
relational database technology it
couldn't have happened without its
released it it didn't happen without us
but there's been a movement away from a
squall for a number of different reasons
and certainly there are a lot the focus
now is on building apps turning out apps
really fast and for the awful thing from
developer often writing an open source
JavaScript and so on
tend to devalue SQL and devalue the
database because they're focusing on
user facing requirements that doesn't
mean they're right but it does mean we
have our work cut out for us we need to
start promoting these technologies and
making sure people understand everything
they can do with them and of course for
a PL sequel developer that also move all
you need to make sure you're using SQL
properly and to the max so let's get
back to that point of we take SQL for
granted in my experience when people are
writing applications in Philips well we
just write SQL statements whenever and
we're
ever we need over and over and over
again we don't set rules on how when and
where SQL statement should be written
now ask yourself this question
because I've done so at many many
different presentations when the answer
is pretty much all equal thing let's say
I've got 200 people in a room we've got
a couple hundred people on this call may
be normal and I'll ask people to put up
their hands with a of twitting standards
who has coding standards on cholesterol
and out of the 200 maybe 50 hands are
raised so naming conventions will spawn
before all rate that's good then the
next question is how many of you have
inside those coding standards anything
about how when and where to write SQL in
generally almost every hand goes on the
left with a handful 2 3 5 hands out of
200 5 out of 200 people working
organizations with they've actually
discussed and made decisions about how
to write SQL on their applications
that's pretty crazy and it's an example
of how we as developers have taken a
fourth event in this assume the right
thing will happen all the time and that
taking for granted extends that even
wider to Oracle not making sure that we
provide you with some of these guidances
and details on how best to write SQL so
we take it for granted we write it
wherever you want and then there's
another problem we don't say current so
it's very difficult to keep up with all
the greatness of the world who puts into
the SQL language and as a result we end
up using old versions essentially of ask
well I might be an Oracle Paul but I'm
writing a skill like I'm on Oracle norm
and perhaps even worse we fall back into
pl/sql or Java or JavaScript when the
going gets tough when I can't figure out
how to do it in in SQL I say well I'll
just fill in my gaps of knowledge with
pillows wall so going back to this first
point for just a moment let's take a
look at the diagram to the right so we
got the back end that's the enormous
chunk of black box for most application
development especially JavaScript
developers oh it's just this big black
box of reading and writing road who
cares about it we know of course that
there's a lot more to it so at the
bottom of the back end the back end of
court for multiplayer itself we have our
tables or relational tables and then we
need to write application code to
with those tables and the problem is
that most application developers
whenever they need to get information
they'll write a select statement right
inside their high-level application pool
and if they need to make any changes
they execute DML statements against the
tables directly from inside their
high-level application code so we have a
proliferation of sequel students all
over our application and the result slow
buggy code that is hard to optimize and
maintain let me emphasize this if you
don't have standards for how you write
SQL statements and everybody does their
own thing all the time
then you've essentially lost control of
your application and it very difficult
to find all the pledge that you block
them all to find all the places that
need to be updated when we identify a
bug and so forth so you take it for
granted you don't pay attention to it
you don't have standards so you kind of
end up with a mess and if we're ending
up with a mess just think about the
folks out there who are not trained in
this original technology now of course
when I say we have a mess I'm not saying
that all of our applications are
failures in fact our applications are
wildly successful around the world
Oracle based PL sequel based
applications run the world essentially
so many critical applications but we
know of course that there's a difference
between what we show ru what they
experience and on the other side what
our code looks like and how difficult it
is to maintain it over time and that's
where things get really messy and we pay
a price long term and of course our
users pay a price at every term because
it is difficult to read the requirements
and make people fast enough and so on
and so forth
so my suggestion is that the next time
you're about to start a new bridle you
ask yourselves two key questions related
to SQL number one are we taking full
advantage of the SPO language do we know
about the new features in our latest
version because we should definitely do
as much as possible in what you'd call
pure SQL pack everything you can in a
native SQL statement number two do we
want standards so I'm not even asking
you to ask the question what should I
plan to be I just want you to ask
yourselves in a group sitting around a
table look at each other and say do we
want standards or should we just keep on
doing whatever the heck we've been doing
and you guys might decide now we're
going to keep doing what we've been
doing it works okay fine at least you
made a conscious decision but I'm really
hoping that the answer will be wrong
imagine of course we want standards
let's figure out what some standards
should be
now in the next 45 minutes I'm not going
to be able to present you comprehensive
standards and best practices for
everything having to do with writing SQL
or sequel number one it's not possible
there's just two months number two I
don't want to get lost in the details
exactly to make sure we don't get lost
in the details let's go back and we'll
go into those details I think the most
important aspects of learning how to use
SQL properly what else equal ablution is
to understand some high-level principles
that guide what you do and it turns out
those high-level principles are really
no different from other high-level best
practice principles really revolving
around one single core concept which is
never to repeat anything and I'll come
back to that and explore it but I do
want to just set the expectation that
we'll not going to 25 different detail
coding recommendations in this webinar
anyway okay so number one you definitely
have to fully leverage a squall in your
PLC code now PL sequel has been enhanced
with every new version of the Oracle
database but the rate of change in
pl/sql is fairly mild compared to SQL
oracle continually continually adds
significant new functionality in every
version of the database to the SQL
language and if you don't keep up with
those capabilities your end up writing
slower more complicated PL sequel code
than is necessary now we all know that
when Oracle comes out with a brand new
version of 12.1 everybody's not jumping
to upgrade their database to that
version the database is too critical you
have to take your time and make sure
it's solid and we truly got a plan in
place and so on so I know that for many
developers when the 12c document is
released not a lot of attention is paid
to it but I think you need to change
your perspective on that so first of all
I know that I'm pretty widely admired as
a pill school developer but I have to
tell you that I am a good example of
what you don't want to be as an
all-around Oracle application developer
because I have not kept up with s Quong
maybe now that I'm inside Oracle I'll
I'll happen but I've been focusing so
much on pls qual I haven't kept up with
the great new features of of SQL and so
I in fact do fall back into
SQL when things get tough and I pay a
price in my software you shouldn't do
the same thing and you probably can't
afford example and just one little point
before I move on and we're not going to
be able to talk about it more today but
one of the great ways to escape from it
well operate some really heavy-duty
procedural code to generate a data set
to be used inside an SQL statement you
might take a look at table functions and
I'll definitely do a webcast on those in
the future but they're a really neat
feature in which you can select from a
function as if it were a relational
table good stuff okay so if you don't
keep up with SQL you're going to end up
writing unnecessarily complicated PLC
code that runs more slowly than it
should so take the time to refresh your
understanding of the sequel language
whether you should be all on 11g right
now and so what you should do with each
new release of Oracle and certainly the
current one you're on if you haven't
done this yet is go check out the new
features list in the docs of all the
Oracle documentation is online and you
can go to the new features list for the
sequel language reference and look
through the list see if anything stands
out immediately as something that you
could say oh my gosh that will make an
enormous difference in program X and
then start to explore how to define how
to how to add it for new versions like
Oracle Database 12c which is probably
not going to be using for a year or two
year olds look through that list that
features nonetheless a nasty fall if
this is a feature I want to be using
what do I need to do to prepare for a
good example of this is the function
result for which I may be able to touch
on a little bit later and in fact I'll
be doing a webinar on in three more
months the first of my performance
webinars the result cache is a fantastic
controllable 11.1 on the database and
even if you're not even if you were on
11.1 would be there for several words
that feature really call on you to start
doing things differently in the in the
way that you wrote SQL and I'll come
back to that when we talk about in
capsule small statements okay finally I
do encourage you to check Tom Page
resources on OTN and asraam Tom is is
like me I'm sorry I want to be like Tom
when I grow up
tom is excellent at PL sequel exec
format SQL is excellent at Oracle
database architecture everything so he
goes broad and deep has an enormous
amount of resources for you more
improvable to check it out so fully
leverage SQL just to give you a sense of
the kind of things you can do in case
you have no paying attention none of
this is actually on 12.1 this wall 11
and lower so there are now analytic
functions such as lag and lead and
ranking utilities that allow you to look
at previous and following rows to
calculate differences between rows and
do all sorts of amazing blooms if you
are not comfortable with or have not
heard about analytical functions I
suggest that that be one of the places
that you scroll when you refresh your
knowledge on SQL
lipgloss so one of the complaints people
have had about SQL over the years is
that set oriented declarative
programming is really powerful but you
can end up with these enormous SQL
statements that go on for multiple pages
might even have whole blocks of repeated
SQL code because you can't have named
code fragments inside SQL statements and
so on well now you can so with the whisk
clause you can actually create
essentially virtual table inside your
SQL statement and then you can reference
them by name in multiple places we want
that something you can essentially
normalize your sequel content and and
create them as sub essentially sub
queries in addition in 12:1 you can say
with function and you can define a
function directly in fungal chrome which
offers some interesting performance
improvements flashback query there's no
need for journaling tables audit history
cables etc new ANSI join syntax that
replaces the old plus operator and
hopefully you should use that and it's
more readable on a book swap on ModCloth
Opera Mobile everyone what can I say
enhancement to hierarchical queries and
then scalar sub queries so essentially
anyplace you can use a single value
expression like select X comma wine you
can put in a selects table and as long
as that select statement returns a
single value off you go
really nice stuff this is just a tiny
fraction of all the new things that
Oracle is at a desk wall so again I
encourage you to go exploring if you
have a team of fun let's say five people
read by point Google have one person
assign the task of analyzing new
features and coming up with a
recommendation about what should be used
or what you can anticipate it to be used
same thing of course with pl/sql
okay so yes leverage SQL fully we're
done with that now let's focus more
along the PL sequel side of things so do
we want standards for writing SQL
hopefully you say yes yes yes yes yes
without standards you can't take full
advantage of this for quality you will
not be as successful as you could be now
I'm going to focus on a small number of
what I consider to be key best practices
in this talk but you can find many many
more and detailed recommendations from
Green Llewellyn who is the kill sequel
product manager just do a search on
doing SQL or sequel best and worst
practices and you'll find a PowerPoint
and also a PDF of that information so
that's the place to go to take my few
nuggets of suggestions in this
presentation and really have them
fleshed out fully and use that as a
basis for setting up your own standards
that will be my key recommendation right
now okay now before I dive into my small
number of most important best practices
I'm going to take on a big challenge
every SQL statement you write is a
hard-coding and in fact the worst kind
of hard-coding
in your applications now if you've heard
me do this talk before you won't be shot
but I bet that if you haven't heard me
do this talk your sink you thinking to
yourself seriously sequel statements are
hard coding how can that be
now we all know about hard coatings
right literals are the common most
common example of hole problem let's
take a look
well you can scale this code just fine
now if you were looking at a piece of
code and I asked you shot find all the
hard quitting's your eyes would
immediately go to the literal values
often color-coded making it easier to
find and it would be right those are all
hard coatings but those are the most
obvious and least subtle the hard
puddings and the least dangerous - so
two more to better understand why to
better understand why would say sequels
of hard coding let's examine what it
means to be a hard coating why hard cool
news wall so I would expect that if any
of you look at this piece of code you
would say wow what an amateur everybody
knows you shouldn't hard-coded literal
inside a piece of code like that and do
it in one to twenty five places because
those kinds of eyes are always going to
change in fact if you ever find yourself
saying this is never going to change
just remind yourself you're putting a
bug in your code right there we go
because of course everything is going to
change so we can look at code like this
and say oh what an amateur you shouldn't
do stuff like that
you should replace it with a named
constant because if you have to you got
otherwise have to find all the
occurrences in season now if you've got
a value like four or five zero one five
zero 5,000 you could probably actually
do a global search replace across all
your files and upgrade your code to the
new literal exciting and very scary I
don't know if any of you have ever done
a global search replacing the files but
you need to look at all the changes that
were made outward we promote songs I
once did a global search and replace and
corrupt it to three days of production
data
it had to be rollback that was nasty
fortunately no one blamed me it was so
great it was my bug no one blamed me
they blame the testing organization I
found the problem yes that's why I like
testing organizations to be my buffer
okay so we all agree that these literals
are bad news okay let's take a look at
SQL so my question for you is in what
way is this statement different from
this literal I write my select statement
here I write it again over here I write
it again over here now I mentioned
earlier that we all have this except
most altitude for
all that everything we're doing is brand
new and unique and nobody's ever done it
before but hopefully when you hear me
say that you save me from that weapon
form wrong of course we repeat things
and there might actually be a 16 wager
Lane that it will be repeated but take
your common single rough edges those are
things that are repeated very often
traveling and can lead to problems later
on and I'll come back to that but the
bottom line is that if I write the
statement directly in my application
code and then I write it in multiple
places no matter how complex or simple
it is when an underlying table changes
or local chip changes you have to find
all the sequel statements that are
affected and upgrade them to the new
approach so what I just described you
was exactly the same process is dealing
with a change to a literal value and we
can change that little value relatively
I'm them change them relatively easily
but when you're hard coding the DML
statement to kind of big problem how are
you sure that you found all this in wall
school it's not easy to do in the even
with the tools that Oracle provides to
analyze dependencies it just doesn't get
you that far it doesn't get you that
quote as far as I can tell I'm a logical
standpoint the sequel statement and a
literal value all the same and poems for
hard coding so if you don't like hard
coded literals
you should hate hard coded SQL and I'm
trying to go slow and really drive this
home home partly because we live and
thrive on logic we programmers the rest
of the world out there not so much but
we rely on logical thinking to get our
job done so I would like to think that
when I can make a logical argument that
says that this and this are the same
sort of thing you should be able to
accept that you should say wow if it's
logically true it's true what should I
do about it
okay what should you do about it
well just one final point about about
this idea of it being hard coding it's
good right at home home and then we'll
go on to what we can do about it writing
SQL is all about defining the now in
other words if I'm writing a 16 Way join
with this clockwork level goes on for
two pages well no matter what I'm
writing all I'm really saying is at this
moment in time here's how to capture
that relationship or that business rule
but as I'm sure you know our er vs our
business models are extremely complex
and I'm changing all the time usually
getting more and more complex so
whatever we think the now is whatever we
think correctly represents a given
requirement or a given business entity
today there's no way it's going to be
that way tomorrow or a we promote and
we've got to absorb that that acceptance
of the volatility of our environment to
fully before we can really start to
understand the importance of making some
changes in the way we write our code
okay so what do we do about sequel
hard-coding I know you're all convinced
great in fact I you realize that
probably relatively few of you are
convinced and I don't get very far with
that argument but I keep on trying
because it's so so important this is the
most important aspect of writing
high-quality code and Phyllis clone so
what do we do about hard coding well you
do have to write SQL problems if you're
working against the Oracle database and
we do want to use the Oracle database
very very important it is the best the
fastest the most robust relational
database technology out there but the
question becomes where should you put
the statements where should you put your
SQL and we can isolate this into a
single do a single don't really don't
put your SQL in Java or.net or Java
Script or any of those front-end
languages the problem with doing that is
that people who write that code are very
rarely good at SQL
worse than that they don't even like SQL
they don't appreciate it
there are mostly object-oriented and old
quote they don't have experience with
setting oriented thinking which is
incredibly powerful as powerful perhaps
more powerful than object orientation in
many worlds so the chance that they're
going to utilize the Oracle database in
SQL properly it's very slim so what they
end up doing is using the Oracle
database as a data store right or Oh get
a road change role and you can do that
you can use Oracle or any database for a
while but then you're pushing more and
more complexity into your front-end code
and that's not a good idea because if we
take a look at the last twenty years and
the next ten years ahead and we ask how
often did people change their database
technology compared to how often did
people change their front-end user
interface technology I think it's pretty
clear the the front-end language is
changing much more rapidly much more
likely between from the database so move
the SQL statements into the database
which means hide complex queries behind
views and use those views and reports
put all your other SQL statements
especially non query DML in chaos equal
packages essentially build an
application programmatic interface to
your underlying data structures and if
you take this approach you're
essentially going to put as much as
possible of your SQL statement from
cybela squall you'll still write queries
in various front-end environments for
example an application Express when you
want to build a table or a report a form
and so on and so forth
but for many developers they hide all
their tables behind google these complex
common where clause combination than
drawing from home use so they can write
simple selects against the news
generally speaking the principles the
same hide complexity behind something
else give it a name and then access that
thing by name
okay let's drill in deeper on this idea
of hiding sequel statements behind the
PL sequel AP on first of all I think
it's a matter of changing how you think
about SQL you should think about SQL is
something not that you write over and
over again but as a service that's
provided to you in other words I need to
get all the rows from this table for a
given point value
get it for me don't make me write it
just do it and if you do write it well
okay then put it somewhere so that it
can be easily rather than reused by
other people and easily maintained over
time now this service this sql's of
service consists of views and programs
to file in a separate data access layer
and that intermediate or what I would
call an intercept level all those
tremendous benefits so I showed you the
picture before about how from the
application program to the tables
people would just write that our queries
to get the data right there DML
statement to change the data over and
over again from the applications notes
with google directly resulting in a
pretty big mess here's my suggestion
instead between your application code
and your order and your underlying
tables put in an intermediate layer that
intermediate later layer is your API and
again it can consist of packages as well
as views and then that intermediate
layer knows all about the underlying
tables how to insert how to update the
lead queried it also knows about
relationships between the tables so if I
need to for example add a new order to
my system it's not just doing an insert
into the order table we're doing an
insert here updates here maybe the links
here it's a complex transaction the
intermediate layer should know all about
those transactions and include them so
that individual developers don't have to
know about the details of which were
welcome and certainly don't have to
write them and then the application code
the high-level application code should
never drop down directly to the tables
you always go through the interception
will be intermediate layers will you
make a call to a program or a function
you do a query against a view and then
all the underlying details are still
wrong so that's the basic idea hopefully
a number of you are doing this already
let's take a look at the benefits and
then finally I will show you some code
so with the data access layer in place
for 77 million things first of all the
most important benefit is that I can
change the implementation of my SQL with
minimal impact on application so ideally
if we add a new column to a table we
don't want to have to go to 25 different
places for either poem if we change a
foreign key if we change a business
where we don't want to go to 25
different places or hope we found all 25
bases where we need to make the change
the reason we will need to do this we
will need to change your implementation
came from multiple causes number one our
underlying data structures change that's
certainly something we can depend on we
know that Oracle is going to add new
speakers and we want to be able to take
advantage of the rather slow smooth
rapid process and also an expensive
process and we learn new ways to take
advantage of Eskew almost all in other
words new features in classical language
that have us thinking about changing the
way we might access along the long roll
so that's one big advantage minimal
impact on application code as you change
the underlying data model second improve
nice sequel related error handling
remember I talked about how we
rationalize laziness I really should you
know trap for an error here and make
sure I log it in under what went wrong
but it's not going to go wrong there's
not going to be a problem but if I if
I'm and it's very difficult to just to
by clicking the home quote do it right
unquote if I'm writing that insert
statement 25 ohms and all different
places if I write it one time put it
inside a procedure and always call the
procedure to do one for among other
things I'll feel like I have the time to
do it right and to put in some much more
solidary hormone and finally one of my
favorite benefits of an API for data
access layer is improving my
productivity I don't know about you but
I write a lot of PL sequel come to my
level but I really rather not spend my
time writing home that I don't need to
write and to write a select statement
over and over again when we wouldn't
nested in the day before it doesn't make
any sense to me and copying pasting
makes even less sense so what I want to
do is reduce the amount of time I'm
writing repetitive stuff and unnecessary
stuff to spend as much time as possible
focusing on my business requirements
okay let's take a look at some code now
this PowerPoint has a number of
references to follow me and I'll give
you the link at the end of this talk
post where you can find all of this long
let's go over to sequel developer and
let's open up
i 11g and look up now
Jenna
you
so you might want to make a note in your
notes feed because I don't have the
right file reference where it's 11g FRC
encapsulation let's go back to the
column so 11g FRC encapsulation
I'll text the PowerPoint before you post
it okay
so here's an example what I would
consider to be high level application
code do stuff with the employee passing
the employee ID notice very nicely
defined with percent mole I get all the
information for that employee
I drop it into a local record and then I
do some stuff and then later on I
execute the same SQL statement but for a
different ID the manager ID and I get
the manager information and do more
stuff so here's an example of repeating
the same SQL statement right inside this
one procedure and this is a classic
example of the kind of selects that
you'll see over and over and over again
in PL sequel code and you might say to
yourself Steven what's the problem so if
I add five new constant always horrible
well I have to change this code and the
answer is no the way I've designed this
code is quite resilient painting I've
got it at a percent row type declaration
so that if the employees table changes
with compiled automatically or is
invalidated and will need to be recalled
and get the new structure of the row I
do a select star I don't specify the
individual columns so that I will get
all the columns if that changes as well
so this code is actually pretty
resilient to change that's not the
problem is that I'm repeating the SQL
statement and over time I might want to
take advantage of new features in as
well
to improve performance of these kinds of
quotes now my approach is not to write
code like this my approaches will call
the employees SQL package usually I just
call it employees management put all my
table related stuff in there and
transaction didn't stop long practice I
have a function called one rule passing
the primary key get the row in return it
so with this function in place when I'm
writing a new program do stuff with
employee I simply call my function twice
so in place equal one row get the one
row in place equal one row get the one
row and I don't repeat the selection
with an over more balloon
now hopefully you can see that I'm
spending a lot less time writing code
new meds then writing this so there
should be a boost in productivity and
every little boost helps for queries
putting an exception penalty isn't like
that critical but for DML statements for
inserts updates deletes it is much more
important and I can again do it in this
one place and then it comes into play
every time it's called so that's an
example of using the encapsulation layer
to hide the ethical field but again
you're probably saying yourself and you
know it's just easy to write the single
select statement I'm not going to help
the robotic wounding why would I go to
all this trouble well let's take a look
at a new feature called the 11g function
result counts
oops something's wrong
you
so in in Oracle 11.1 Oracle database 11
1 Oracle added a new feature called
result cache and the result cache
basically allows you to avoid requiring
the same row over and over again and not
just for you as an individual session
but for all the sessions connected to an
instance it's a really powerful caching
technique that can improve performance
of praise quite dramatically that the
cool thing about the function result now
is that all you have to do assuming
you've got you may be going through the
process of setting it up we directly
we've identified the queries and
functions that you want to result cache
you put this one keyword result cache in
the function header and in the function
body and that's it what then happens is
that every time anybody in the database
calls this function in classes employed
and Oracle asks did somebody already
call that function for employee do you
want over if not execute the query
return the record and remember that
record along with in some polling group
and the next time anybody asks for
employee information for employee ID 100
Oracle does not execute the body of the
function it simply goes to the quash and
return to the record that it is stored
there cool very powerful very elegant
feature and if you take the time to put
your queries inside functions now like
this and it's not aligned it's not a big
effort to take that point out and move
it inside a function if you make that
effort now or you'll be harmful then in
a in an instant you can add the result
cache keyword here we go I'm going to
upgrade the performance of my
application
this is oversimplifying things a little
bit but from the feel sequel standpoint
I am done I could have that one keyword
that I am done we alternate it with
saying oh my gosh I've got 25 different
queries and 25 programs I'm going to
pull them out I'm going to put in the
function call I'll make the function
result match function you can do that
the problem is that it's pretty
expensive to change 75 programs in
production in this case I would be
changing just one
okay hopefully that gave you a sense of
the power of encapsulation I don't want
to use up my whole time on that so I'm
going to fun going but I have found that
building a data access layer is
absolutely key to improving productivity
and improving quality of your
application in fact let me show you one
more example before I move on and if
actually this plus another so let's take
a look at an example of hiding the SQL
behind a function it's similar to what
you just saw I'm taking the put the
employee ID here and getting the full
name in this case I've got several
different hard coatings my sequel
statement is hard coded my variable name
length is hard code and my business rule
is hard coded awful Hubbell stuff and
it's the sort of thing we've seen our
application all the time and I say awful
because the formula changes we have to
change the code here if the maximum size
of a person's full name changes we have
to change this here and I've already
talked about the problems of repeating
this flow the solution is pretty simple
here's my package I declare a subtype
which basically gives a name to my under
long walk home from songs I declare a
function that returns the full name
there's the reference to the use of the
Forman
and I can even have multiple overloading
depending on the inputs and then I go
back to my original code I declare my
name to be of a type full moon T and my
last name is generated my full name is
generated just by a phone call and I hit
in my formula in one place inside the
package body so again that's an example
of the flow moving home a hard coded
approach
- an approach in which you're hiding the
deep tools hiding the details behind
package interface
so beta access layer tips and batches so
first of all give your space self the
space to do it right and by that space I
mean mental space and we often feel so
worried when pressured to get things
done fast it doesn't really take all
that much time to move a query to a
function or move it into a procedure and
then put in a call for that function
procedure and once your package has been
created adding to an existing package is
even the main issue is patience and
discipline try to tell yourself to slow
down get it right or at least writer the
first time and the benefits downstream
will multiply now Tom Kyte strongly
recommends transaction API in other
words you call the program to insert the
order when you order is a business
entity it's a transaction in and of
itself so you build a procedure around
that transaction I agree with that
completely I also find that table ap is
individual procedures and functions to
simply operate on individual approval
one or more rows in the table can also
be very helpful when used correctly but
you have to watch out for the following
don't end up with a was calling a
cascade of functions for mobile when you
can execute a single query instead
here's what I mean so I'm working with
my HR table HR application I've got
employee little departments I've got a
procedure that takes the employee ID it
I've got a function that gets me one in
play so to get the employee and then I
need to get the department information
too so I think the department ID will
employ your record and I call another
function to get that loan role now one
role lookups in Oracle are very very
fast unless you're working in an
application environment in which every
microsecond counts you're probably never
gonna have to worry about this code but
it's a bad sign because one select
statement can bring me Bowl all of this
information together instead of two
select statements in two different round
trips to the sequel entry but because I
have my function in place it's faster
for me to do this then to write that
join sequel statement what I should do
is write that sequel statement so write
that the join and then put it in its own
function in a new function adding it to
my ever-growing
API of SQL encapsulation and a final tip
generate whoops
generate as much code as you can
to ensure consistency and I won't get
into tools for doing this actually there
aren't too many of them out there right
now but I'm hoping to in the next year
resurrect at least one of mine sequel
developer does generate some table API
content if you go to a table and if I'm
still connected and then right-click
under table you can generate a table API
will generate insert update and delete
procedures
okay one final know what I'm going to do
is keep going through the rest of my
clock and then if I have some phone
I'll show you one other example of the
complexity of doing non gray BML why you
should not do an insert directly over it
instead height of nine procedure it's a
variation on the same theme so let's
make sure I capture my other themes
first let's take a look at a few other
recommendations for writing a squall in
pl/sql
first of all when fetching a single row
you select into a single row fetch an
implicit query and of course put it
inside a function you can also do it
with execute immediate informal of the
dynamic single row select and by that
when I'm in sent what I'm implying is
that you should not use explicit cursors
use implicit queries second when
fetching and changing multiple rolls use
the bulk processing features so if you
have a query that's retrieving ten
million rows or ten thousand rows and
then you need to execute a DML operation
each one of those you should use all
collect and for all to get a truly
incredible boost in performance and that
will be the focus of my second webinar
in the performance section so that's in
five months from now four months from
now so sign up for that and and I'll go
over that in much more detail as well
and finally a few tips for dynamic while
people's were wearing more and more lack
in our new internet-based environment
that is so dynamic and driven by our
users bind rather than concatenate
whenever possible always execute
immediate a variable so when things go
wrong you can figure out what the heck
went wrong and if you're executing
dynamic DDL like create table create
index create procedure make it an
autonomous transaction
okay always you select into for single
repentance I like to point this out
because it has so many good lesson 1 a
long long time ago I and many other
Oracle experts this is back when I guess
Oracle's stage maiden Wow
Oracle 7 we urged everyone when you're
doing a single row fetch to do a cursor
declaration and then open the cursor
that into a record and clover because it
was faster than a select into and for a
short period of time it probably won't
fall through but I believe as of 7.31
well and beyond ever since then a single
row fetch with a select into is going to
be 15 20 percent bathroom than an
explicit cursory declaration open
fetching clothes what's interesting is
that the reason I like to point is that
I think everybody is well attuned to
doing select interval also a lot simpler
to write that you have to be aware of
people making recommendations or giving
advice based on experiences from a long
time ago for example if you ever try to
do something useful to inform your DBA
says no you can't use that because a
long time ago there was a bug the
obvious rejoinders should be well is it
still above really I can't use this and
test one and make sure that it is okay
so we set a long time ago that you
should always use explicit cursors
things like that live on and on on
especially in the world of the internet
we can always find the link back to
something from the past it's hard to
differentiate good and bad advice so
it's always good to verify things for
yourself and especially if anybody is
talking about something what they
experienced a long time ago to make sure
that you update the reference so select
into an ex comedian into they perform
better they more accurately tell the
story in other words I want to get a
single role I don't get a single row I
will raise it well those errors tell you
when reality doesn't flip the story
the reason I point I want to mention
this miraculous ELLs the story is
another way that people get around doing
the select into and having to declare a
record and da da da da is they do a
cursor for loop fetching a single row
you can do it it's not going to kill
anything and it will be fast wonderful
yet it'll be performant
but for somebody to read that code it'll
be very easy there's a cursor loop here
so I must be doing more than one but the
work was social employee ID that doesn't
make any sense when you write code you
should write code that answers questions
doesn't raise questions in the minds of
someone with multiple
moving on bind rather than concatenate
with the Nano desk law so with dynamic
SQL you're constructing a sequel
statement on the fly because it can come
time you don't have all the information
you needed and there's often some amount
of concatenation involved with you're
very careful about concatenation because
when you concatenate you create a new
physically different sequel statement
which will cause additional parsing it's
more vulnerable to sequel injection when
very important notion not to bind
variables and it's much harder to read
and maintain so you should bind all
variables as much as possible in fact
you should restructure your dynamic SQL
to use bind variables as much as
possible and then you'll increase that
increase the chance of reusing the
parsed stable injection will not be a
problem and it'll be much easier to read
let's take a look at an example
here's a program that is a very kind of
dumb update statement it basically says
for any numeric column in your table
give me the start and end dates and the
value and I'll update that column to
this value and what you can see here is
I'm using placeholders for my bind
variables and then at the time the code
is run it binds in these three parameter
values into these three placeholders and
then off we go
so clearly every time I call this update
numeric value my argument values may
change but as long as my column name
hasn't changed from one that was
executed before the physical SQL
statement is the same these different
values don't affect the parson so that's
one of the advantage of binding rather
than concatenate II it's also a lot
easier to read here's an example of that
same code this concatenation
so notice I've got start and end dates
well dates are a problem you have to
convert them into Springs of using
concatenation so I do it to care of my
start in with my format right here and
then inside the SQL statement I need to
convert that string which is if a date
but it's a string format
back to being a true date it's a mess
and you don't want to do this if you can
in any way possibly avoid it you can
usually avoid it notice I do have a
concatenation here because I have a
column name and I can't bind a column so
make sure that you identify and only
concatenate when you absolutely need you
and your life and your security will be
a lot better
executed need a variable not an
expression now I don't know how much
experience all of you have with reading
the moment along with a fair amount and
what I have found is that learning how
to use execute immediate is not that
difficult
using DBMS SQL the old fall dynamics
sequel mechanism is quite complicated
and very rarely needed but the hard part
about dynamic sequel is getting the
string right missing a comma missing a
single quote missing a space between
clauses so many different ways that you
can mess things up if you construct the
string inside execute immediate it's
lost you can't see it when something
goes wrong
so you assign it to a variable execute
the variable and then if something goes
wrong you just log or display the
variable in your exception handler
here's an example
you
this is a program that I love to show
people and their gbas drop whatever so
find all the objects that match name and
type with a ball to the center
everything so find all those records for
the static cursor and then it with a
cursor for loop construct the drop
statement and then drop it great
so you can call drop whatever without
any parameters well except you want to
make just checking balls and then it
will drop everything in your schema that
a poem cool very dangerous but it does
demonstrate some nice best practices so
here's my drop statement and what I
could do I was kind of lazy let's put it
right inside execute immediate there we
go
the problem is if something went wrong
and I trap the exception one with all I
don't have that string anymore
so very simply always assign it to a
variable execute that variable and then
in your ex exception handler you've got
the string you can look at it in an
instant we'll see what bubbles
finally when you're doing dynamic DDL
executing a create table statement and
create index statement etc every time
you parse a DDL statement whether it
dynamically are statically oracle will
cause an implicit commit to the
executing exception all outstanding
changes will be saved now in general
dynamic DDL should be done with great
coil on usually very rarely in a
production apple point because it can
cause a cascading ripple of
invalidations of programming's but in
any case if you're doing your dynamic
DDL in a stored program unit you can
constrain or limit the effect of the
implicit connect by using the autonomous
transaction kragle back to drop whatever
it is so what this statement says is
that any changes I make in this program
any DML changes must be committed or
rollback before the program terminates
and what that will do that is only
commit or rollback these changes inside
this program and not in the outer
session which is a great technique for
example for logging error which you want
to write an earth with a lot of people
commit it but not commit your
transaction obviously some little
problem in this case the autonomous
transaction will constrain the scope of
this implicit commit to this one program
and will not cause a ripple effect to
the rest of your session
and also just another little tip that I
can't get into much more detail in law
when you're doing dynamic SQL DDL or not
you probably always want to make it acai
combs which is what you see here off the
d current user simply said that when
this program is run from some other
schema not the owner schema it will run
with that current user the invoker's
privileges so when you try to drop
something you'll try to drop something
in the schema only by the color of the
program not the owner of the program
which is extremely important when you
have a centralized repository and you're
going to execute to other schemas to use
okay well let's conclude that I've got a
couple minutes for questions so when and
how to write SQL some conclusions first
of all most importantly cannot be
underestimated or under Amazon's
leverage the SQL language full oracle
has spent an enormous lana 340 to make
the Oracle SQL variant the strongest the
most flexible the most powerful
implementation of SQL on the planet if
you do not utilize it fully then you are
basically devaluing work with labels
inside your company and that will cause
all sorts of downstream problems
including a less than optimal
application so reserved pl/sql for
logical flow business requirement for
all that cannot be done in set oriented
SQL and keep up to date on those
enhancements second the most important
thing avoid repetition of SQL folds we
can talk about implicit cursor that
immediate with a variable those are all
good things to know and like I saw check
out Brenda Ellen's white paper but the
most important thing to do is avoid
repetition of SQL statements avoid
repetition of any logic in your code if
you don't avoid this if you repeat all
over the place before loss of control in
your application it will be very hard to
optimize your code retain your code and
look good with your boss so if you want
to get a promotion if you want to rise
up to senior program where in a merit of
senior distinguished programmer and so
on so go encapsulating SQL and
encapsulating all sorts of all hiding
details behind a name object is the best
path to a great career in software there
how's that for motivation finally set
standards for writing SQL applications
if you don't have standards you don't
have a chance of applying these new
features properly of making sure they're
done consistently of having an
application that is truly movable so I
encourage you to put together some sort
of set of standards in your application
not only for pl/sql but for how and when
and where to write SQL statements
all right so thanks for joining me a few
useful websites for PL sequel developers
ask tom dot oracle comm is ask Tom's
great Q&amp;amp;A site oracle.com slash pale
sequel looking for the landing page for
Oracle's resources on pl/sql check out
PL sequel challenge comm with rock
there's an active way of learning
instead of reading stuff and watching
video
you take quizzes on pl/sql SQL database
design logic and more it's a great way
to really drive home and internalize
your knowledge and hate compete with
others if you want oracle - developer
net is a great repository of articles on
SQL and pl/sql by even Billington one of
my causes he wrote he's a specialist on
pipeline table functions and oracle -
bass comm which is 10 volt set of
resources in scope the truly console
only website I encourage you to check
out all these great resources in terms
of my code it's now based in Oracle so
here's the full URL but I've also
created a shortened here that you can
use to go at to get all the debt all the
different files and in fact it has a a
typo so let's fix the typo SL mo and
then let's also give you my blog
and my twitter handle sorry I'm new at
this I'm just just getting my act
together here for you
okay
so this is my blog
this is my twitter handle and I'll make
sure that my blog also has a link to the
poem and also the latest PowerPoint and
so on from this presentation okay so
that's the end of the presentation what
I'd like to do now is switch over to my
chat wall and let's see what I've got
for Chad
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>