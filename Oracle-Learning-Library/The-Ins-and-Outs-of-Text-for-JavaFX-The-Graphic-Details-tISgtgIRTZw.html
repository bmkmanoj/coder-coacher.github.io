<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Ins and Outs of Text for JavaFX: The Graphic Details | Coder Coacher - Coaching Coders</title><meta content="The Ins and Outs of Text for JavaFX: The Graphic Details - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Ins and Outs of Text for JavaFX: The Graphic Details</b></h2><h5 class="post__date">2013-01-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tISgtgIRTZw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay good afternoon folks welcome to the
inside and outside of text for job refx
a graphic details I'm Phil that's
thought we both work in the graphics
team at at Oracle on javafx and I also
do JD been doing JDK stuff for a long
time the stuff we have to put up you can
you must read it very carefully ok so
here's the roughly there roughly out of
the agenda there will be going through
and you know i won't bore you anymore
with with that but you can read it for
yourself but see as we go through ok so
as an introduction I just wanted to say
why is tax matter well it's one of them
it's when a user is interacting with an
application in for the most part I mean
okay we're talking games it's a
different story but most applications
particularly productivity applications
almost even other applications where
people are doing you know more fun
things a lot of the time they're
actually reading text labels selecting
things and so that's what they're
focusing on that's what they're looking
at there's all these pretty pictures in
the background if they're looking at a
web page or something you know they're
reading the content does these the ads
and whatever else and the backgrounds
are often make it pretty but that's not
what the user is spending most of their
time focused on so it's everywhere it
could affect the performance of the
application and know there's a lot of
subjectivity around what makes like text
look good and bad you know if you were
to go on the web and search around
you'll see that there are some means of
interesting debates between people who
insist that windows does text right or
wrong and Mac does text right or wrong
and in many cases is just straight down
to what the individual is used to the
others now the other side is wrong let's
go to war yeah so this is just as a
slide to sort of get it over if you look
at this demo which is supposed to be the
ensemble ER is one of the depth in Samba
is one of the demos that you can
download that shows off all the
different features of javafx if you're
familiar with
swing you'd know it's basically like
swing set except it's got even more in
it it's got so much in it I don't think
I've actually explored it all it shows
off the different charting and so this
is actually demonstrating charting Rite
a very graphical thing yeah there's one
little pie chart in the middle and most
of the content on this page the tree the
labels the description stuff over here
the labels on the chart labels on the
tabs everything text okay so that's why
text is important let's just talk a
little bit about the basics of text on
computer displays so there's some very
ancient history but this this is really
where we are today pretty much all the
faults that you'll see used on on on a
modern desktop or even on you know
devices now feature phones like my
high-tech one here use bitmap fonts but
you've got an android device or you've
got a arm one of those ifruit phones
whatever they called then you know
they're using outline scalable funsters
and basically the standard font format
these days are called truetype fonts all
that early started out that way and then
the advance the the new version of the
standard after Apple went off and did
their own thing became called open type
it's not completely open really
Microsoft really control the way the
spec goes and in it would attempted to
do is unify a true type and on
PostScript fonts violating you have the
same font file format overall file
format but you can have PostScript
outlines in there and then there's other
sort of derivatives of this such as wolf
once and I mentioned a bit about this
later jdk supports postscript type 1
fonts which are commonly used still in
printing and other stuff like that but
we don't actually even though jdk
supports those we just decided not to
bother supporting these pretty much all
of the designer fonts that you get these
days come as OpenType CFF fonts so I
don't think adobe you're even creating
any more PostScript type 1 fonts
so there was no point in trying to
support that legacy format which
introduces a lot of complexities if you
want to arm you know support multiple
master fonts and all the rest of it so
the basic idea is that they are inside
the font file for each glare for
character the there's an out the
scription of the sheep and arm there's
some software that will you know creates
an outline at the size that you need and
then scan convert that into an image and
that's what actually gets displayed and
that's the basic of it text rendering
terminology you'll hear people talk
about black and white on a bi-level text
or whatever or alias text which is the
old bitmap text you would get on you
know windows 30 or even windows 95 or
even actually windows XP if you weren't
turning on ClearType and you can still
get it now in windows 7 if you want its
what x windows used and so forth but
pretty much everyone now does some form
of font smoothing takes out the jaggies
it makes the text look a lot smoother
and armed you can actually use it to
make the shapes look a bit more a sort
of ideal and then Microsoft and others
introduced the idea I mean adobe had
their thing called cool type and I
forget whatever else call theirs but
there are ways of actually making text
look a little more high resolution on an
LCD display by using some
characteristics of the display and
there's an image somewhere later on that
shows you what that means hinting is
basically when an outline arm needs to
be adjusted to the pixel grid so that
it's small resolutions you've got a
sorry a small arm glyph image where you
try to do like 12 pixel high text right
mote in the black and white in
traditional you know bitmap fonts I say
you know each bitmap was hand designed
right and each size you've got a bitmap
for that size now you can actually do
that with true type fonts as well but
the other approach
that they they can be a way of embedding
instructions or hints or whatever you
want to call it which actually take the
outline and tweak it at a particular
size with it okay that the way that our
lane was going to go is going to go
somewhere between the two pixels and I
really want it to snap off here I don't
want it to go down down there it means
that Texas overall sharper in in in in
anti aliased mode and that it doesn't
look quite so just ridiculously hard in
pure black and white mode characters
versus glyphs so in your a eunuch in
your application you're using the java
application at least you're referring to
a Unicode character code and you know so
where people are familiar with this at
this point I imagine and but Unicode has
defined probably a little out probably
like getting on for a hundred thousand
characters with all the different
extensions now and those whoops those
don't all even fit into a single font
file for its worth but the the font as a
way it has to have a wet hazard to find
some subset of these like it may only
support I don't know may only support
Cyrillic for example or it may only
support Latin and you know there's not
like a big empty space in there there's
just a table which says you know you
know unicode characters for a is it
glyph index glyph index 12 something
like that and so there is a mapping from
the from the Unicode code to the glyph
code means which is inside which is a
font specific reference and you know the
fault with the information they're
essentially by mapping through from the
glyph code gets through to the outline
of the font and eventually you can get
at the image by the process i talked
about later earlier i'm sorry metrics so
it's a basically we're talking about how
text is measured the soul so in most you
know graphical primitives
and text isn't quite as primitive some
things are you know if you're talking
about a circle you know you know it's
very obvious what the dimensions in the
circle or a rectangular I mean you
defined it right and you know that you
know if you want two rectangles to a
butt and you you know made 110 wide
you've got to move over 10 units to the
whatever direction to place the next one
adjacently but with text you don't you
can specify that you want you know 12
pixel fontan you can you know have your
character a but you don't actually know
how wide it is I mean that's that that's
determined by the font and the font
designer so the logical advances the
different is basically the difference
between the default placement of one
character or string and the next so you
would know how to position things
baseline traditionally if you're drawing
a rectangle you the origin is generally
the top of the rectangle but with text
typically the origin that you specify to
draw whatever the draw operation is the
is the position of the baseline so we
most of us are familiar with these sort
of Rome and baseline one which we draw
out above which our capitals go and
descenders go below that so the and the
design height of a font is how far it
typically the typical design height of
all of the different of the capitals or
maybe a little higher than that for the
font depending on what what the fonz
targeted at and the designer that he
sent is the design height or how far it
goes below the baseline and if you add
these together with perhaps with a line
gap which means some fonts is zero
infinitesimal you get what the overall
height is of each particular line so the
overall logical bounds is then the is
they horizontal advice by that font
height right but a very different thing
which will have some slides on later is
the visual bounds that can be quite
different the little images here to the
to the bottom right they are intended to
try to show you the upper one is showing
what the logical bounds of this
italicized at
could be whereas that is completely
different from the visual bounds the
actual bounding box touched by the
pixels and are rendered okay so that's
all I was going to say about these sort
of basics of textures to sort of set the
scene for that let's start talking about
what we do in FX the text class is a is
a node in the scene graph I think Thor's
got some slides which explain what the
scene graph is for those people who
don't know later but essentially it's a
it's a it's a graph of objects you know
in a hierarchy which is the basis of the
way that the JavaFX API works and there
is a subclass of node called shape which
adds operate additional operation so
once you've got any kind of node a node
you know so so almost everything the
scene graph is a node so right there are
you know UI controls if you find us
notes you can apply all the same
operations to them so they can be
stylized CSS and they can actually be
laid out in that scene graph but since
text expand XR extends shape
additionally it can have other
operations such as you can apply a fill
to it and a stroke operation and it's an
event target so your text node can
receive some input events so as link
thought we'll touch on later this is
actually sort of you know this is a
low-level graphics rendering primitive
you know but at the same time it's
actually quite a sophisticated element
it's not just no graphics draw string or
something like that or text text out if
you're a GDI programmer or whatever it's
not just it's more than that and this is
sort of you know modulo anything that's
been introduced in canvas you know this
is really still this is the lowest level
primitive we have in FX and you'll see
that it can do an amazing number of
things for what is that lowest level
primitive so you know it's it's fairly
intuitive to use you basically create a
text node and pass in a string at
minimal you can actually set the string
as well and i'll show you some examples
in a minute then probably the most
important attribute after the text
content itself wraps of a text node is
the font that is used now i just talked
a whole bunch of our fonts a technology
but let's look at what we have here in
it nope how you actually apply that font
to to a text node so for whatever reason
in javafx one arm the which was based on
java on a scripting language called Java
FX script which is based on a earlier
scripting language called f3 form
follows function we whoever wasn't me
whoever was actually building that API
decided that you would obtain a our font
using the font family with a factory
method font font you were passing what
is the family name of the font and and
attributes and you would get back a font
object as a result so I'm not showing it
there but a font object is returned if
you want to use the full name of our
font and you don't use a factory you use
actual constructor and you would pass in
the full name so these two methods are
both equivalent so long at least so long
as there is an Arial bold way possible
you may find it that just fails
don't use don't use the full name to the
to the cut to the factory method and you
know don't just don't expect the family
name unless it defaults for the regular
which is many funds don't expect the the
family name to to work for the
constructor but you know just because
you know Ariel the default name of Ariel
regular is Ariel it'll that will work
that might delude you but it's not like
JDK where you would pass in either name
and we'd scratch our heads figure try to
figure out whether you meant a family
name or a full name in NF x you if you
pass in a family net a foot the full
name to be to the factory method it'll
just return you ready folks on it won't
try to figure out that you meant the
aerial family it's just purely looking
for an exact match to an own family font
is also immutable I just wanted to
mention that as an important point
because it helps a lot in general in a
rendering stack when we receive an
object if we know that you can't you
Tate it afterwards because if you could
we've got to figure out what that means
if we cache certains rendering state you
mutate it basically that's a real
performance drag we've got to
recalculate everything every time so
it's not just font where you'll see that
in their end rating stacks or other many
rendering stacks but you know the
alternative is we'd have to like copy it
on when when you set it which is a drag
to particularly since we may not even
know how to copy it depending upon the
the nature of the object
logical phones could you give me some
water so we have the concept of what at
least we call logical phones I think
other people column logical phones too
and they're there they're easy ways of
getting to something that actually will
render using the typical typographical
features of seraphs on Seraphin
monospaced which can be a real pain for
you know if you go to a platform and you
just know that i really want to use a
monospaced font it there you know
without you have two halves go through
and we didn't have these logical names
you'd have to go through some API we'd
have to invent some API feed you
enumerate things find the monospaced
font pick one and all you care about is
just basically trying to do something
tabula so you wanted a monospaced font
although monospaced fonts are actually
something of a myth in some ways once
because no font supports every single
code point so if you require fallbacks
the full-backs are probably going to
come from a different font and even if
it is it is itself a monospaced font the
widths are probably different than the
one that was the first font so just
watch out for that that's a generic
gotcha with any any kind of fall back
system so we use the same name serif
sans-serif in mono spaces the JD Kane
uses that means anybody who's been using
JDK doesn't you know trip over too many
spelling mistakes and get very confused
we also added the name system we don't
use the other dialogue and dialogue
input the JDK is but we use this system
which was intended to convey to you that
what we're trying to give you back here
is something that is the typical UI font
so you know serif sans-serif in
monospaced I think generally will it
will map to something like arial times
new roman and korean you which actually
is what they were mapping to in jdk in
jdk dialogue also really mapped to
aerial as well but we wanted and you
know what we wanted to get over as well
as that there's a font that was actually
intended to be the mapping to the UI
font of the system and it you know it
didn't necessarily want to say it's not
we're not seeing its serif or sans serif
or monospaced we're trying to say that
you know that if you are on a particular
version of windows or a particular
version of Mac OS we will troll or
whatever we will try to retrieve the
system font will try to retrieve the
trip the system sizes and when you ask
for the default font on yours from FX
you were you will get back system
regular now people might ask you know
well well why doesn't it return Segoe UI
to be pleased if it's say go you I well
you know because we want people to be
able to do something like say set font
system font but you know and and you
know you would otherwise have to you
know do some retrieval of what the
actual you know by the base is saying
sets what's that font system regular
really is what I want people to be able
to say right so you don't have to go
retrieve the font get its name out and
then create the front of that size you
can just say I want system regular this
size of that size but if you so we don't
actually expose for what what I'm
getting at as well as that we don't
expose you can't call it and ask Oh what
is this underlying system font maybe
there should be a way to do that but
that there isn't and do expect that to
to be you know to change between
versions of windows so jdk baked in the
aerial was the default system font the
dialogue basically and it was on windows
and it was always that and people came
to depend on it we couldn't get out of
it but for a fact i can tell you that on
XP you'll get back to houma and you get
back sager you I on on windows seven
unless the user has gone to tweak their
default system configurations now one
other point is is that uses arm sorry
platforms have like oh this is the menu
font or this is the title font oh this
is the font used on such and such a
thing oh this is the default font on our
choice box so I forget precisely where
we got it from but you know these these
are often configured to the same thing
but could theoretically be configured
differently so we wanted one choice
which basically Maps most closely to
what you see in typical UI controls but
it may not be you know when the the font
that's used in every single place on the
platform you can enumerate the fonts by
calling get families or get font names
okay okay so here's a very basic example
arm using the text api's so you can
create a text just with no augs you can
say and specify the text with things
that text you can set the font using the
factory method or if I showed you can
set the color by calling set fill and
then you can add that to your to your
scene and that's an actual rendering
which was captured from being and as I
said this is a you know a low-level
primitive but you we let you add all
sorts of styles you can set underline or
strike through just using precisely the
calls they say their show that you can
control the anti-aliasing mode which I
touched on earlier and I you can see
that the top level that the higher would
light enlarged would welcome is is gray
scale whereas the lower one is colored
and that's the coloring is what it looks
like when you blow up LCD sub-pixel you
can actually see that the the different
different pixels are different colors
and one I don't if I touch on this I
don't know if I touched on this here but
the UI by default are maybe I do touch
on it somewhere else but the basically
gray is better for animation and
graphical uses so on its axis node by
default it is gray right so if you want
to get LCD you've got to turn it on
explicitly the you know we thought about
having LCD be the default or maybe on
this platform by that for platform or
maybe the default should be based on
whether it was an installed system font
because that's how Windows renders its
installed system fonts well except some
windows api's do that and some don't so
anyway the the the choice we made is you
get gray by default and you turn on LCD
and one of the things you'd find if you
were to look closely is that all the
default Caspian CSS for Windows
basically enables LCD and all the UI
controls so your UI on windows uses LCD
except on a raw text node weight
defaults to gray and you would have to
set that on Mac OS is currently
defaulting to gray and it's interesting
to know where we'll actually go with
this as we head into sort of like mobile
and embedded space pretty much and
high-resolution displays so things like
iOS right do not even support LCD text
with high resolution once you get about
150 dpi LCD starting to lose its value
and it's a more expensive thing to do as
well so you know and the fuzziness of
gray scale at small sizes goes away once
your your tiny text that you can barely
see is actually like 20 pixels high it's
actually a pretty decent amount pretty
decent sized glyph so I think you know
gray scale is LCD is you know here and
it's going to be used for a long time on
Pilate devices but the real high res
devices like retina displays and these
things that are going to come along on
on on mobile devices like iPads and
Android pads are going to be just all
using great skill
and there's different display
technologies as well OLED actually makes
it a bit more difficult to use LCD as
well okay so we can do although fancy
things gradients here's a simple example
we're basically setting a two stops safe
and which will basically mean that we
transition from red to blue across the
are the length of the string so just by
adding these so it's a fair number of
lines actually by the time you back
you've you've created the stops and
passed in all the parameters to to to
linear gradient maybe there's somebody
faults that you can use but you know
just a couple of lines and that fairly
boring blue text node text string can
become a very nice gradient and this is
just a simple gradient you could
actually do something even more flashy
for example you could take that gradient
and I've already applied the grade into
it and I could set a drop shadow so now
that starts to look really nice and you
didn't have to write a lot of code for
this you just created a text node set a
few properties on it in bang and
remember this is our low level graphics
primitive right CSS CSS is actually
fairly widely used within javafx for
people doing controls the idea is that
you'll be able to do a fair amount of
separation between the all of the logic
and the layout and so forth and then let
have somebody else who can work in us in
a designer to will actually apply styles
until they think that the aesthetics of
the application are good so you can
there's a default style sheet which we
would load and then you can apply your
own style sheet to your application and
then for the text no it probably looks
inside the styles you look look
something like that but you could also
do the same thing from from code on the
specific text node by setting the the
same string using the set style method
so
it's interesting actually to understand
how this all works so at the bottom r is
the is the output of this arm partial
coats of this code snippet so in the
first line you'll see I've created a
text node one I set the font to be Arial
bold and and I'm you know and I'm just
using the font that font name as the
actual text so you can see the first
text node displays Arial bold so text
one clearly the font that set font call
has taken effect now text to set style I
do FX font and accept courier new using
step style and then I get the font okay
that font as a string right back from
the whatever is the current font on the
text object and remember i just called
set style and i say that is the text
okay now i say forget that i'm actually
going to override my call to set style
i'm going to explicitly set the font on
the text node to be Arial bold so this
should look even if the string isn't the
same the string should say Korean you
right because that's was the font i just
sent with set style but it should appear
in arial bold well one of these things
happened the the font that was actually
on that we got even after calling set
style was the default system for regular
and the font that we set last Arial bold
isn't what was used to render so what
basically happens is that set style when
you call it from code like this is
deferred until what we call the per
frame sync pulse right so arm when
basically all we copy stuff over to the
render thread we've take this arm at
that point all the CSS styles that have
been explicitly set are applied and so
it actually happens at a later time
right
I think I could even I was thinking
about even doing a little example where
it shows you how you can might try to
get the bounds of after you set the font
and you might be surprised anyway that's
sort of there probably should be a way
of setting these things immediately but
just just that's a little gotcha to what
watch out for now this low-level text
node that's basically a drawstring can
also do multi-line text so here I insert
a new line character into Java one and
boom you get two lines just like that
all right so drawstring wouldn't do that
for you draw string would have just
interpreters no but you can also set a
rapping with and I said 200 pixels here
and this slightly longer string wraps at
200 pixels where the regardless of
whether there were a new line but if
there was a new line it would wrap
immediately when it hit that new life
start again and we can align multi-line
text so here you can set left right or
Center and I think it's pretty obvious
which is which there I hope and you can
justify that multi-line text to the
wrapping width so they're basically
we're setting but just in the space
between the words here in order to make
the text align to the wrapping width and
the last line is not justified which
because you know it could be but I think
it's more normal to to do it like this
okay so they could go
really quickly got some examples so the
text bar bounds understanding text
bounds so FX in FX there are different
arm bounding rectangles for all the
different node types I don't know if
everybody's familiar with all of them
but bounds in local coordinates should
include in theory the stroke and effects
but it's untransformed bands in parent
basically applies the same thing but
transformed in the coordinate system of
the parent and layout bounds doesn't
necessarily include the effects because
it's used for actually you know placing
things within the scene graph and the
effects are not accounted for that but I
touched touched on earlier about logical
and visual bounds and we actually have
not you know most nodes and most no
types most most graphic primitives right
you know you're thinking only a visual
balance but text has the concept of
logical bounds and it's really the more
normal way of thinking about text so
actually logical bounds is the default
so in generally speaking this gives you
some kind of loose of bounds but it
doesn't necessarily enclose all the
pixels so you can see the red box again
you know shows you that the left and
right most parts of the italic f are
outside of the visual bounds but at the
same time the height is actually you
know is way too much to account for the
height of the f and this your bounds are
much tighter so it'll depend what you
want but the default is usual is logical
and if you really want tight bounds
because you're treating this more as
graphics and text then you would would
want to use visual bounds so just
recapping that that you know the height
that you're getting is really not about
the particular string you're drawing an
illogical bands mode it's more of based
on the properties of the font and the if
there are leading and trailing spaces in
your string that's logical that's
logically part of how where you would
put the next
string right you know if you've got
separate English words hello world you
know just because you can't see the
space doesn't mean that you a but world
right up against hello it's got a
logical existence Sherwood is visual
bounds you know the tight bounds can be
more expensive to compute I mean
historically we've actually made it it's
been really really much more expensive
to compute but for the most part we've
managed to make it'll not so bad these
days in at least in FX but you know if
content is changing right you know
visual bounds may not be what you want
so there is a quick example if I've set
bounds type visual you could see that
you know because of the way that this
flow pain works it's using this actually
non-exposed property arm called baseline
offset which doesn't really changed
paste based on whether you're using
visual logical bands and so when it
tries to align these arm these two
strings you can see when the logical
bounds mode the the underlines lineup
and the strike throughs line up
perfectly but the text is is offset so
you know there it could be argued as a
bug could be argued arm that we should
you know try to I'd make flow pain or
baseline offset adjust arm but no that's
really I'm really just trying to get
over the point that you know visual
bounds isn't necessarily the thing you
you want for aligning text you can
dynamically load fonts jdk had a very
very similar capability so you give it a
URL so i made up this URL so don't go
looking that but very simply you pass in
a string you know there's no string
quotes in that well that won't compile
really but you will so if there's a font
about location now that could be
anything that is a valid URL will load
the font and you can then
lo use that font directly actually this
should be a parameter my bad there
should be a size parameter there as well
so you get back a font you can directly
use at that size and you know and the
the sort of boilerplate kind of thing
you could do here if you want to embed
it in your jar file is to basically pull
it as a stream app from your jar file so
you would bundle it in your application
as well which is probably the more
normal way of doing it than pulling it
directly off the web web fonts I think
it was to a tutor to was the last
release we started for supporting web
woof web outline font format where it's
called web opentype font format yeah
which is really a the open type or
truetype fonts were the hello it could
be subset it or what the key thing is is
that you know individual components with
tables within the font a sort of zip top
but it's got a different header and you
know you can and google has a web fonts
project and you can actually go off and
reference these things directly and get
a web font reference back from them and
there's two different formats actually
there's the one that works for Mike
least there's the eot embedded open type
which is for IE or microsoft api's and
everybody else I think supports the WHA
format and in FX we have this WebKit a
like Safari based embedded browser
called web view and so now if you
actually go to a web page which actually
has web fonts you know webview will
actually directly low that that font and
so the web page will render as the front
design web page designer intended you
could also directly use these a web a
waffle font in an FX application using
load fun and get the file but I think
the more normal way is like I don't
think I have the CSS now if you just
look at the way it's actually defined on
the web page if you to go to like Google
web fonts and you'll see that the HTML
and then JavaScript it generates and CSS
that's actually what people would
probably want to do in their
applications but we need the people who
do CSS support in FX to actually add
that capability so it's you know I don't
think anybody's going to be going off in
getting a web form font and embedded in
their app but they could if they wanted
it would actually work we'd have but
using it via CSS isn't yet available so
i just wanted to switch to a quick demo
mode i don't know i'm going to spend a
lot of time on it just you do lack of
time
this tries to show off a bunch of the
capabilities we had due to the fact that
I switched the screen resolution you
can't see everything but this tries to
sort of show all the different
capabilities we have in FX you can set
the font size we can stroke and really
show you stroking but basically that's a
an outline path of the font we can
change your pasty we can obviously
rotate transform the font scale it share
it she has golf very rapidly I would
have to switch resolution to get down we
probably can't tell very well if I
switch on LCD modes or skip that we can
just another thing I show this text
origin as I said default is baseline but
you can set whether you want the origin
to interpreters the baseline or the top
or the bottom of the text you can the
out be barely seen yellow and green
boxes are showing the the layout bounds
and on the bands in local ops are
actually bands apparently and but if i
switch to so if i switch those between
logical and visual can you actually see
ya you can see the green box if i take
off these clothes with you the you can
just about see the the box become more
tight what can I and are actually how to
get to the bottom of my demonstration
thus of all things down there but I have
to set the I can't get it because it's
too big alright I'll show that to
anybody individually later who's
interested in features I didn't show off
ok like me one of the thing is we have
it shows it's like
we have a I'll touch on some of this
stuff in a minute but we won p a big big
piece of functionality that we are
adding back in the next release is that
because jdk fx1 used to use jdk support
for a complex text we and FX to
basically rebuilt things we ended up
losing a lot of the capability but I
just wanted to briefly show that we will
be getting that back so if you were to
look at the right one that's the right
window
if you were to look at FX 2 which is
currently shipping this is what this
looks like with a mixture of Hebrew and
Arabic devanagari some front that why
we're using Latin diacritical 'he's and
you do the same thing over here in the
new version which isn't yet shipping but
you can download the binaries this now
renders completely differently so this
on the on the Left I'm afraid what we
should be now is I'm afraid garbage but
on the right you can see that you know
all of these things now line up text is
properly right to left I was going to
show a line breaking demo as well but
i'll skip that interested time so we'll
go into some of the internals now just
and then I'll handle dish for
momentarily so I touched on some of
these technologies earlier on in very
shady k11 it used the platform api's
which is GD I and X 11 really we
supported windows and Solaris jedikiah
12 came along with Java 2d and we were
supporting grayscale text that in a time
when you could really only get it if you
went out and got windows 95 OS r 2 or
something basically none of the platform
supported that Andy and truetype support
was a fairly new thing complex script
support was adding 1315 we improved a
lot of things we added LCD text in jdk
six and added cleartype rendering in six
to ten and at that point you know we
seem to be pretty much done for what we
needed to do in jdk but then FX came
along it was starting again and the
requirements for FX were actually quite
different we were targeting initially
web designers and so forth and you know
some ways is like a flash competitor
we'd struggle a long way to get windows
native rendering kind of compatibility
and then it's like that's not what we
want we don't care about that what we
actually want is some other quite
beautiful more mac like rendering then
what like flash does its animations that
are important so some of the things were
good we were getting for free all that
complex text and so forth but it wasn't
the actual rendering that we that we
wanted and also we we people were going
off and getting designer fonts like
these OTF fonts and then putting them in
FX and they looked awful and it's like
what's wrong with your font rendering
well you load them into windows windows
at the exact same thing these faults
were not designed to be used that way so
you know GDI agreed with us the problems
with the fonts but you know that it was
still something that we were had a
target unfortunately we then you know we
were heading in that direction adding
certain capabilities into JDK to try to
emulate that and then FX 2 dot X came
along we were no longer going to use the
underlying a deputy in swing stack and
depend upon that we have a new stack
built from the bottom up opengl 3d will
scale from devices all the way up and
but now we we have lost all our jdk
rendering we literally not like to call
it we're not based on that it's not
there no even if you're running on top
of jdk you can't touch that stuff so we
had to start off and create a completely
new text implementation and think four
is going to be talking now
okay let's see
yeah that's more like 10 okay so the
design goal for text well first of all
internally javafx uses texts all over
the place so in fact any text rendering
will be handled by our text node so
whether you're using your web whether
the backwards through the web view or
sliders it's labels or buttons it will
end up having the text not there and
from a design perspective obviously we
need to keep the text dollars in
lightweight as possible and we would
like layout etc be able to create as
many as at once needs to be flexible
take any amount of texts and perform
well and have all those features then so
that's how tight turns out to be quite
difficult there and I'm going to delve
into the details of rendering and see
the internals but ours will start at the
top which is basically scene graph this
is a node belongs on a scene graph I'm
sure everybody knows that not that
exciting but be aware that there is
actually two scene graphs there is your
public Affleck scene graph and what I
call the render scene graph which
handles the rendering these are two
different threads that way they can do
their work simultaneously and they are
synced up physical on the frame holes
now that there's a hidden text node
which is called the peer of alpha text
note that you have on the effects scene
graph it has some of the same hierarchy
etc but it's called mg text and you text
extends ng shape and you should shape
the extent to entry node and and bass
note etc so I want you to remember that
the program next slide so which is
wonderful and hair is all that
capability of the base node you can
translate it like any other graphical
object and do most things to it you know
it has the attributes of shapes using
stroke etc but
as a witch so wonderful now what does it
mean to put a note on scene graph well I
came from a low-level API where our
solution said something like OpenGL you
had a managed rendering you had loop it
no in a game engine your cost of doing
work you know and that's acceptable for
us well that's all hidden away and the
thing here for you they're like a lot
but all you have to do is create a node
pronouncing graph and poof is visible
and you expect hopefully when it's not
being changed that we do no work that we
were lazy and yes we try to be lazy and
as possible well that work at and for
coding practices algorithms and the way
we manage this we we mark these well
okay so we don't want to obviously
render knows that are not visible and we
really only want to what render the ones
that have changed or animated acrostic
cetera so yeah so the notes that need to
be rear ended up basically mark dirty
okay and this is combos basically battle
muttering properties on the text node
and verifying that yes it does has
changed significantly we will have to
rear under this thing and but that's not
enough right you could have something
blow it or above it you know you have a
button and text on top of it or image
below it you change the state of that
button you clear that area I rerender it
that's not enough so the scene graph
needs to worry about the rest so it
basically i defied all intersecting
notes that I've intersecting notes to
those 30 notes and also mark that dirty
on the next pulse folders knows yet
render now this is done intelligently
this is oversimplification we don't
obviously do this excessively
but and it works out pretty well so but
this there's a cost obviously the sinker
needs to be aware of the size of
everything that it has and for text
that's not obvious that when you start
out the text node you basically if you
want to be really lazy then you
absolutely do nothing you get text as a
string move some font sizes some scale
values etc but in order to get that
balance you really need to do layout so
and furthermore the pound is not enough
I'm it's not just a layout we need to
incorporate all the extra content as
Phil wanted to earlier so if you look at
that a little F that we're reusing again
them again it's basically the blue box
that we need to find and that it's a
little bit more costly than that red one
which is in that data is embedded in the
font so and then we have that wonderful
inheritance you do almost anything to
attacks know you can buy all the facts
that you do they can do it to any shape
etc but and well there's wait there you
know the for example the bass note
itself has over 24 member variables
currently and it's could change in the
future they were both very important
that help the state of rendering etc and
we almost can't live without them and
they have shown to you know the extra
data has been evaluated carefully and it
has showed better benefit and no extra
cost shape is pretty lean and mean and
text it wants to be a monster I mean we
are we feature that we add I mean it
just is the basics of the string the
layouts a selection colors indices fonts
bounds type etc are on the node and we
have to a lot
but I think everybody deals with this
you see the browsers and Dylan are
consuming massive our memory I think we
do pretty well so the consequences of
these constraints well this secret needs
the balance of the node this text must
lay out all touch provided accurate
bounds and minimum we can render
generally is is the node this serious
oversimplification but text node is a
little bit done it looks at vigilantly
but sometimes it is i thinks of itself
as one single entity and it was a render
everything okay and yes
so it we try to make it as lightweight
as possible but it's not the size of
your strength it's definitely a lot
bigger and so keep that in mind not
crazy put all the world's documents in
order one text note it a very little
point you would see it on the screen
anyway and you will have to pay the
layer costs currently so this might
improve in the future so more about
graphics rendering we have different
pipelines that we support we try to use
the hardware pipeline that's the default
which could be d 3d or OpenGL and false
teeth 3d or windows everywhere else
opengl or years to for embedded now if
your drivers are incapable or are
blacklisted etc then we will have to
fall back to software software is pretty
good we have the j 2d pipeline which is
basically java 2d as a fallback which is
del FX 2 only and then there's the new
software pipeline which is sw9 which is
going to be in turn affects 18
so so real quick how do we produce these
glyphs what's the process so this is a
rough hand wavy simplified explanation
piece it's really complicated we have
the math each character of to a font
that supports it discussed earlier and
we need a map each character to a glyph
code now the lift code does correspond
to a clip and this is definitely not
one-to-one mapping all the time and and
I mean check with it see if the cliff
code actually in this case exists in our
glyph cash so we maintain a large
texture which has all that data and we
touch to map the qantas draw I'll speak
against the graph so this is kind of a
our coal sequence that's not properly
named not but her it is how basically
the the text knows uses all the things
in order to do what it needs to do or
rendering so here the text peer of they
need to talk to lay out a little bit to
find out who things you render on a
different pipeline anyway well let's
look at the data it's more interesting
so this is the data flow and so the pier
text note essentially signs over the
glyphs have a cliff codes down to the
render pipeline with fonts transforms so
on that pipeline sets their appropriate
shaders and things of that nature
controllers states for that hardware
state machine now it looks at the glyph
cares to see if to find all those lists
neglige list and basically changes that
over to a quad
texture map cause if the pixel data
doesn't exist already now we have to do
a little extra work so the look in the
font rasterize it and don't but once
that work is done we never have to
rasterize again for a given play while
the textures well it which is typically
the case and that all gets output and
composited through a surface ok so that
was gray scale LCD is slightly different
not by much so ltd is the glyph of our
list are three times wider and so the
normal source / blood mode and doesn't
work so we have to do special math and a
special shader it to do the blending on
a sub pixel level should I color level
and also because the blending isn't
supported we need a copy of what we're
going to be running into and this has
been annoying because most hardware
today there's a lot allows to sample
from and run to the same target so need
a little coffee and recently also
digital yeah LG G LCD shader handles
transparent backgrounds and which I
think we're the first to do and I was
not sure over demo here
briefly
rah
okay so
okay there that LCD effects of cancer
level that's our city I some transparent
sources so the point is is that most
platforms sort of bail when you get to
transparency LCD text whereas we just
seamlessly arm transition so here we try
to use it much later so we have here it
looks like there was your color in the
background but when we render it on the
back to do the opposite this Carly okay
alright well there's one more thing I
need to get really be I wanted to show
what is happening so this is the image
you saw earlier here's a sample and
here's the op-ed
so this is hopeless and with the texture
and then there is a texture with a copy
of every glint pass one somewhere
now skip over a couple of slides
actually I think we just need to get a
shift on so performance I basically is
very important to us and so accelerated
graphics definitely helps sometimes but
sometimes you're just bound by the cost
of rasterization of the cost of actually
getting the going to the font getting
the font information of disk turning it
into an image and caching is actually a
you know really powerful arm tool but it
only helps if you know the glyphs are
actually reused if you've got a
pathological application which never
uses a glyph then you know hardware
acceleration will only help so much but
in a lot of cases it will and for
typical applications it will and we can
actually get some pretty good results
and know so we can talk about how
heavyweight things are but we actually
do things pretty we do pretty well LCD
text is more expensive even in hardware
certainly in software i remember
microsoft you know saying that they
consider to be like a 30-percent
overhead to the actual lowest level text
rendering I maybe even just overall it
came up that way and there you know and
these things have pluses and minuses so
you know LCD tex might be greater
quality some things what if you want
higher yeah I'm going to yeah so any if
you want something like a sub-pixel
positioning whatever you're taking an
additional hit so quality you know and
performance for a trade-off and we're
going to be working on on on these and I
want to just show you a couple of sort
of demos get over you know where we are
so there's a fairly standard arm
benchmark these days for and on our
people in the upsets actually brilliant
right this is actually html5 running in
Firefox arm for this text rendering demo
test and it told shows you the frame way
it's getting up there as far as we can
tell that's about as fast as it can go
and the flash one goes about you know
something like that okay so fine
this one is javafx running in the same
applet and we are getting one hundred
and sixty frames a second 170 frames a
second we actually and and that is for
it's worth uneven or file bothers show
it because of time that's the current
shipping version the new version
actually I think gets something on this
machine something closer to six hundred
frames a second so lots of performance
there okay I'm being wrapped up okay so
let's just put up a summary slide closed
the tabs alright find my mouse yeah I
know I know it's so much we wanted to
say okay so as the guys that were doing
anything okay so we think we're already
pretty feature of all we know we've got
deficiencies were pretty fast but we're
going to be working on performance and
quality quality complex script support
is coming there'll be rich text which
I'm touched on it all Filippo is working
on that and there's a URL here for
taking talking walking through some of
the API usage that we discussed and
that's actually you can probably quite
easily find that on the Oracle website
without thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>