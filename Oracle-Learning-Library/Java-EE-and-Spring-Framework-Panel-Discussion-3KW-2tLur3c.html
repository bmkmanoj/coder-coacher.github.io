<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java EE and Spring Framework Panel Discussion | Coder Coacher - Coaching Coders</title><meta content="Java EE and Spring Framework Panel Discussion - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java EE and Spring Framework Panel Discussion</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3KW-2tLur3c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so hello again my name is Chris
beams and the committer for the course
Spring Framework and first of all thanks
to Arun and others at Oracle for setting
this up and thanks Rick for for
moderating thanks everybody for being
here looks like a fairly full house just
to get a sense like how many here today
would consider yourself an enterprise
application developer building
enterprise applications right for a
company or your own company okay so keep
the hands up how many are in some way or
another you have heard applications in
production that are using Java EE
technology of any kind like okay maybe
like one hand went down a couple more
hands went up okay now keep your hands
up of those applications how many of
them are in some way using any part of
spring a couple answer and a couple
hands up right okay that's basically
what we understand today or I like the
majority of people building enterprise
applications with Java are using a mix
of these two all right so that's like an
important note as we go through this
when we talk about whether they're
competing or complimentary right we
can't remember all the hands staying
upright so I'm going to talk to you
quickly about some use cases for spring
because there might be areas of spring
that you're not so familiar with as you
know by way of proper introduction right
for example no sequel you might be
building an enterprise application your
boss comes up to you and says something
like hey I heard that MongoDB is great
for you know storing documents let's see
you work in a place like the New York
Times with a Guardian right and they're
you know having all of their articles
and so on it's great for keeping
pictures and text and metadata your boss
is interested in this not sure she says
hey why don't you create a
proof-of-concept about this fourth the
codebase you know put together a
proof-of-concept about the sports
section moving to MongoDB well how are
you gonna do that you could of course
grab the MongoDB drivers from the Mongo
guys get started that's not a bad way to
get started anyway to get a sense of
things but by the time you're needing to
integrate that into your already
existing application and do it elegantly
that's where something like spring data
MongoDB comes in right giving you what
you expect from spring like easy ways to
create repositories easy ways to you
know use something like the Mongo
template object mapping to get things in
and out of your existing data model that
you might also be using in JPA another
place
right so that's no sequel you might have
big data requirements coming along like
hey we want to track whether our
registered users are effectively
converting over to paid users that's
kind of Lee going for the New York Times
right now we want to aggregate all that
data track it in Hadoop all right so
what are you gonna do well you can
figure out how to bootstrap Hadoop from
the ground up right it's not a trivial
task or you can sort of hit the ground
running with string for Apache to Hadoop
which is another part of the spring data
you know project what about social media
maybe that same boss comes to you and
says we want to track what people are
saying about our newspaper or a magazine
in social media could you figure out how
to connect to Twitter store that data
process it check it out again spring
social right if it's Twitter spring
social Twitter spring social Facebook
right other social media platforms out
there that we support security maybe you
have a web service you've stood up a
restful web service and your boss says
could you figure out though ah right we
want to have an OAuth solution there no
surprise spring security which is been
around for a long time plus spring
security OAuth
it's designed to meet those needs right
enterprise integration you're doing
things like looking at the enterprise
integration patterns book that everybody
you know understands well that's kind of
the industry way of thinking about
enterprise integration that's what
spring integrations for right basically
implementing those patterns so that you
don't have to deployment options well
maybe your boss comes to you and says
this cloud thing is interesting let's
just do a proof-of-concept trying to
deploy to the different cloud providers
that are out there today like any of
those in the lower right hand corner
right Heroku and Amazon Elastic
Beanstalk and Google App Engine of
course Cloud Foundry which we support
these are all spring ready applications
or spring ready platform as a service
offerings right so you could try it out
there and see if you like the hope as
this everything on the upper right well
these are all of the you know Java EE or
plain servlet container deployment
options that we have for spring today
right basically spring goes just about
anywhere right if you can stand up a
servlet container you can definitely run
a spring based web app anywhere you want
so so I'm sure we'll talk more about
that but you know this slide just this
is a you know barely touching on any of
these topics and
than four minutes right this is spring
today and if you notice you know what
many of you are probably most familiar
with it that you spring all this hands
going up is that second box from the
bottom right the core spring framework
that's the thing that I commit on that's
the thing where you know you're familiar
with the jvc and spring JMS and spring
MVC all of those things are inside that
box everything else I just talked about
you could say is what we've been doing
for the last eight years or so right
spring batch spring integration rapid
application development spring Roo
spring AMQP for sort of going beyond the
JMS use cases into talking to other
disparate systems spring web services
spring security right the list goes on
and on this is not a complete list so
this is what we do right we build open
source applications that are designed to
handle infrastructural needs the
developers run into because that's not
the thing that makes you or your company
any money right things that facilitate
developer productivity by allowing you
to focus on the domain problem it's a
complex enough world right you don't
have to reinvent all these wheels and
that last box on the bottom Java EE Java
SE of course spring has always been
building upon those things we've been
supporting if not directly then
implicitly so many of the specifications
in Java EE and picking up you know on
language features and Java SE using
other things from se like jmx and so on
since day one all right so with that
proper context in mind I'll hand the mic
over to them thank you
oh I'm sorry alright would you okay
thank you Chris for the fantastic
introduction to Spring Framework I don't
think I would need slides I don't think
I would need five and a half minutes
we are not heavyweight anymore the no
where in the Java EE specification is
said that the application server needs
to be heavyweight the runtime needs to
be heavyweight that's not a requirement
either mandated or implicit typically
when I talk about Java EE the three
things that I want to highlight is about
the lightweight nature of it you think
about a POJO you know you want to use
enterprise javabeans you know I mean you
every time you think about ejbs you know
you tend to head back oh no no I cannot
use either B's think about the
improvement that we have done in Java EE
6 simplicity take a POJO
put annotation on it and that's your EJB
no special packaging no deployment
descriptors nothing of that sort
required so egb is just one part of it
and we typically test the one that has
been most hated about but this is over
three years ago that we made those
improvements think about all the
standardization work that is happening
over here today there are over 14
compliant application server providing
you true portability so if you are
keeping yourself within the Java EE 6
ecosystem or the API itself your
application is truly portable in the
sense that you take an application
written using Java EE 6 API whether it's
running on JBoss is running on GlassFish
or WebLogic or websphere or even tommy
or any of those versions the application
is truly portable now of course you know
you tend to extend your platform or tend
to use those application servers
specific API is in which case you are
logged into the particular vendor but
you know if that's what we are focusing
on with Java EE 6 the platform is rich
enough that you can actually start
building your application using the API
itself
now of course Java EE 6 is a standard
and there are pros and cons of a
standard so in the sense that you know
if it's a standard
it's gonna move slow because otherwise
it would disrupt the innovation so I
think that's the key part here let the
innovation happen but still make sure
the standard stays relevant for example
take a look at eclipse link you know
eclipse link is a reference
implementation for JPA there is enough
innovation happening on eclipse link but
still contributing back to the standards
so my key point really here is Java EE
platform provides you a simple
lightweight elegant solution
for all of your enterprise application
needs if need be you can go of course
outside the platform is not exclusive by
any means is more embracing more
inclusive if need be you meet anything
outside the platform you can use it if
you are deploying your enterprise
application on a Java EE compliant app
server use the capabilities that exist
in the run time instead of bundling more
capabilities and loading the app server
more so overall I think with NetBeans
integration with the vendor support with
the technology that we already have in
the platform with the more technologies
that are getting added to the platform
solving all the problems that we're
talking about no SQL big data security
you know social all of those the
innovation that is happening in the Java
EE ecosystem I think Java EE is very
much relevant very much exciting so even
though it's standardizing but still
there is enough innovation happening in
all different areas to keep it relevant
innovative and cutting edge for your
enterprise application leads thank you
excellent thanks thanks thanks Chris
let's uh since we started with the
spring guys for sure let's start with
the question yeah and we'll start with
Bert so we have two questions so the
question is why would you pick Java EE
or the screen framework for enterprise
development okay so I think this was an
interesting question like five years ago
when the standards were not really on
par and I think then yeah like a real
but but nowadays I think both of the
frameworks are actually on par given the
basic features that you need to solve
today's and tomorrow's problems so
things like creating a testable
architecture doing dependency injection
you know and transaction stuff like that
so all of the basic ingredients that you
need to build an enterprise applications
are already in a standard which is still
relevant like Arun just mentioned so for
me it explains no it's no longer a
choice I mean you pick a standard and as
soon as you need something which is
innovative which is not contained in the
standard then you should start looking
around so it's no use of bundling an
entire application server with each
application that you build just stacking
all the features and creating your own
application server if everything is
already contained in your application in
runtime today I think well maybe to just
give it like an interesting twist
this question might still be relevant
for the applications that you build five
years ago so there's a tomorrow
afternoon I have a session together with
my colleague Paul Becker about migrating
spring applications which you build like
five to six seven years ago - generally
six applications because if those
applications were built like five six
years ago they will not typically
contain a lot of technical depth because
you chose maybe the wrong frameworks
that Dona Merrick exists or you're
facing some functional stuff that you
need to build into your application so
if you have to if if you have to think
about no to keep the application for
another ten years or so I think that
will be an interesting question whether
you will want to continue down the path
of being that being a spring application
or if you want to have gratitude would
you have accepted if you want to do the
letter then you should definitely come
to our session tomorrow afternoon and
see how that can be done so if you have
to migrate an older spring applications
a spring one application or maybe a
little bit more modern spring
application then there's a lot of
frameworks in there that you chose five
six years ago there are no longer
existing or in maintenance mode
so you have to do a lot of work anyway
so if you have to do a lot of work then
why not say just one little extra step
and take it to your standards so it's
relevant for another five or ten years
now the format is there's room for
rebuttals if anyone has a rebuttal or
you can just pick it up when when the
question comes around this way anyone
okay just so we're gone so let's go to
Gordon with the same question Gordon so
let me repeat it why would you pay Java
EE or spring for enterprise application
development typically I you know work
with Rob with Springs so I typically
choose to go towards the spring out of
it and worked with Java EE and I'm
currently on a project with the job edie
technology I typically would go with
spring because I can get an application
very rapidly off the ground I have a
wide variety of choices of what which
libraries I can use for my application
and I kind of you know that's that's
that gives me the flexibility to really
be to have the opportunity to choose
whichever technology I'd like to use for
you whether it be the persistence layer
whether I'm using expending MVC or or
another strategy for UI components
obviously it's built on and takes
advantage of EE components either that
Chris had alluded to that earlier so
there's a lot of strengths of the e that
spring builds on but I think I can get I
can get a very functional application
off the ground very quickly run it on on
a tomcat server or jetty server within a
couple minutes so it's it's not a it's a
very easy thing for me and that's pretty
much why I would choose to go towards
this the spring Roo
so Chris the same question Oh actually
let me go back to other so Iran why
would you pick a job in your spring oh
well of course I will pick Hawaii the
interesting part is why you didn't work
at Oracle
working at a development shop in Europe
you know you needed to get all the next
version of your application why would
you take it yeah sure well good job
hehehe based upon my knowledge at least
so far you know maybe if I'm better
aware of spring then I'll pick spring
but for now of course I will definitely
picks Java EE and here are my some of my
reasons you know I mean I think Gordon
mentioned the wonderful reason and
that's one of my main reasons I would
pick Java EE you know rapidly you know
and again as I said it's partly because
of maybe I'm not aware of all the
skillsets in the spring but in Java EE 6
no literally even one of the things that
fascinated with me fascinated me about
Ruby on Rails is how quickly you can
churn up an application you know
literally you just give up the man and
everything is ready crud is ready you
know your prototypes are ready a
proof-of-concept is ready that's what
excites me about Java EE 6 I've done
several workshops all around the world
like how you can build an end-to-end
application you know building a JSF
layer Java an EJB layer with the JPA
layer all POJO driven NetBeans IDE
driven or Eclipse driven and how you can
build an extensive application in about
couple of hours so I think things like
that customers get it they get really
excited about it and then they come and
tell me that you know hey this is
exactly what I wanted how I can change
my JPA persistence provider how I can
pull in an additional library where in I
don't need to add or edit my web.xml to
make those changes I can just drop the
jar in a java ee 6 compliant container
and it will automatically understand
that and now I have my servlet listeners
etcetera being pre registered I think
that's a very good reason for me the
other one is
I care a lot about governance model
there are pros and cons of governance
model well we beat Java EE there is a
governance model in the sense there's a
JCP or a java community process by which
you know a jsr is being filed you know
it's being rolled out there's a process
by which everybody votes on it gets
approved there's a discussion that
happens around the feature set what
needs to get in there's a konso of
course you know it's a slow process
because this by the fact that it's a
standards it's gonna take its own time
so this goes slow but it's a standard
after all after the fact that you know
there are 14 compliant application
server vendors that's a big deal to me
so I don't know I mean if there is a
governance model for spring for example
what is the process and I mean that's
part of my lack of my knowledge but what
is the model for adding a new feature to
spring I can yeah I can github it I can
fork it but who's gonna maintain that
feature for me you know am I responsible
for maintaining that feature or my
customer is responsible for maintaining
that feature if it gets critical bug-fix
saying you know is it one person if that
person changes the job what happens with
it so that's the critical factor to me
the other feature that is the other
factor that is very important for me is
a vendor support as we say one throat to
choke you know if you come to somebody
like Oracle then you can say you know
what all the way down from the metal to
your JDK to your java ee platform to
your application server to the entire up
stack you can get all of that but this
is not a product selling but you can get
the entire stack support from Oracle
itself
and there are several other vendors like
IBM and Red Hat can do that partially as
well so the idea is you know you can get
your entire support from one vendor you
know you don't have to kind of run
around oh I need spring support and I
need Tomcat support and I need
management support and I need monitoring
support and third-party tool that is not
required no typically that that is a
very good point for Java EE application
servers the other part which bird
concern Bert alluded on is if I'm using
an app server I better use app server
instead of bundling my app server with
the application and that whole concept
can goes against my philosophy in a
sense you know hey Adam bean you know he
promoted the concept
of milliseconds deployment and kilobytes
of deployment he's he is he runs he
makes his bread out of building Java EE
6 applications his applications
enterprise applications hundreds of
concurrent users hundreds of you know
files them there they're still kilobytes
they're not talking about megabytes so
things like that so which basically
improves your day-to-day productivity in
terms of not just development but
deployment as well real-time things so I
mean I would going back to my governess
model point I think innovation is very
important and so a standardization
spring on the other hand yes in a way
it's very fast because it's been
interface 21 SpringSource VMware EMC
just one one line all along I would
really encourage no spring to contribute
back to JCP you know and whatever
innovation the great work that has
happened in spring to at least
contribute back to the standard body so
that you know wider set of people can
actually leverage it and we have seen
you know many guys raised hand when
Chris asked the question how many of you
use spring and Java EE together most of
you which is exactly what we see in the
market all the time so I think some of
my reasons why I see picking up Java EE
over spring okay so we have some time
for rebuttal as you like to rebut
there's there's quite a bit in there
right well I'm not sure how such a
rebuttal should go I'll make a couple of
things rhetorical but I mean we're free
to go back if you like right the first
thing you mentioned was was you know
that you're inspired by the Ruby
community and by Ruby on Rails and I
think we all were I mean I definitely
remember the first time that I saw the
screencasts from David I'm Eric Hanson I
was like oh my god we have a long way to
go all right and and we have made a lot
of strides right in the Java EE world in
the spring in the spring well but I mean
it has you know Java in general we've
made a lot of strides but I think I
think we're still not particularly in
Java EE at the level of productivity
that something like rails provides and
and and I I might be ignorant quite
honestly of just how great the
experiences and netnews in all candor
I think there's a different class of
rapid application development tools that
are out there right we've seen it with
you know rails they kind of set the
standard spring of course has spring Roo
which is very much designed to give
rails like productivity with some other
characteristics right but you know it's
not any part of the runtime you still
build a kind of regular old spring out
but you do it in a super rapid way of
course in the you know this isn't a
conversation about Grails but you know
you probably all know that's like in our
larger sphere that's something that
truly classifies I mean it was
originally groovy on Rails right now
it's Grails that's a rapid application
productivity tool so I mean please you
know when you have a moment
respond to that if you like but but I
think I think we're talking about two
different things in kind here and to the
matter of governance and filing jsr x'
and things moving necessarily slowly in
that kind of model that's not that's not
a dig right that's just simply the
nature of the beast
that standards bodies move slowly it's
by design right and if we look at Java
EE 6 which you know really a number of
points we've actually come out I mean I
remember rod putting up a blog post in
the in the early days of 16 and I saying
II 6 gets it right you know it's a lot
of things right there are many things
that were supportive of in there we
generally like the way that it's shaped
up if you look at the timelines involved
with EE 6 e 6 was standardized finally
in December of 2009 how many people are
using u 6 by the way and how many are on
WebLogic or websphere yeah the
compliance implementations of both
WebLogic and WebSphere didn't show up
for nearly two years later right in 2011
that's a lot of good stuff right in ease
six I mean it is absolutely fair to say
that u 6 now provides the Java community
at large with a great Hojo programming
model I'll be the first to say right
it's a completely reasonable even nice
Pocho programming model and that's the
goal right when we hear people talk
about closing the gap that spring
in 2004 that's fundamentally the gap has
been closed
nd acknowledging right creating a POJO
program all that's what the community
wants it needed that's what sort of won
the hearts and minds and now tell you
you really does have that as in 2009
which was five years hence right and
then two more years until we've got the
biggest most important implementations
out there the people are actually using
in the real world now the question is
we've got complaints of limitations
great have you upgraded yet right that's
not in your decision
that's another decision developers have
a lot of clout and more and more and
more as we look at things like DevOps we
have a lot of clout and the choice of
frameworks and individual you know jars
that we're using right we don't have so
much clout still in the choice of
runtimes that's a decision that's being
made way above your head and my head
usually that's a big differentiator
right so yes the model is nice yes we
know we basically congratulate you six
on what it's done but there are real
practical problems with the actual usage
of that and I mean I think just have you
look in your own experience to see that
if you're working day to day with
technologies right as for a vendor
support right sort of single sourced
vendor support that's definitely a nice
thing to have indeed the one throat to
choke is what people talk about so well
I mean practically speaking right
theoretically you definitely want that
practically speaking many of the vendors
out there are the big guys are in one
way or another providing spring support
and the reason for that is all the hands
went up right it's just a practical
matter and the you may remember
WebSphere and WebLogic certifying spring
to run on their platforms right they've
openly acknowledged they even embraced
it a long time ago and you know I guess
we would go one step further and say
that those big support contracts are in
many cases not all but in many cases
just the waste of money
we all know the trend toward lightweight
and certainly containers taught you know
tomcat jetty etc why not just run on top
of those if you can if it's Tomcat and
you're looking for single source vendor
support we do that right from Springs
it's on Pat and all that so it's
possible right it's about it's about
pragmatism what do you actually need
what's practical for your organization
etc and what choices can you
personally made yeah just one last point
since there's only one more point from
her room when it comes to you know
lightweight deployments in the app
server when you got kind of out of the
box vanilla e six application you know
like you're going through tutorials and
getting started in hello world and that
sort of thing you indeed to end up this
is really nice thing this sort of ideal
situation where in your maven Tom you
have nothing but the e6 API jar
everything else is being provided by the
application server that's it that's a
nice goal and there is definitely a
class of applications for which you know
you could stand that up maybe even put
it in production but I mean of all those
hands we saw God basically everybody in
the room here I mean show me a
production application today that it's
not using at least some if not a lot of
third-party dependencies whether or not
they're spring right are you using Java
util login right so probably not a
probably using log4j that sort of thing
in this speed increases that you get I
mean let's face it most of it you know
if you on top of web logic and WebSphere
you're probably dealing with there have
dealt with hugely long redeployment
times right I mean I know I've been in
shop so it's 20 minutes right we all go
out for coffee while other deploys if we
can get that down to something like X
number of seconds like 20 seconds or
something like that it's diminishing
returns the value that you're getting
whether it's three seconds or six
seconds or nine seconds but you have to
compare the pros and cons there right
yes maybe you have a kilobyte deployment
that takes one second to come back up
but you're really counting on everything
is in that absolutely hey Chris Emily
spring yet last point finally and I'm
done thank you graciously with spring
you have all of that choice at your hand
too right you can really choose what's
in that war file that's going to pay
dividends over time not just for spring
but as a way of thinking about the world
I had two developer choose what should
be in here and I'll take the extra few
seconds of the appointment for it thank
you all right so well my first remark is
that I've actually never have heard rod
Johnson say anything nice about you
maybe I miss well he probably didn't say
anything nice about j2ee which is how
the spring audience knows Hawaii SH yeah
well one comment that I would like to
make for example and I think that's sort
of the power of the Java EE community so
yeah even though not a standard but for
example JBoss forge you know it's a
beautiful example which is innovation
happening in the Red Hat land where you
know just like Ruby on Rails spring Roo
they're able to kind of quickly create
an application so NetBeans approach is
more GUI driven which may not be
appealable appealing to everybody but
JBoss Forge in that sense its command
lines everywhere even quickly turn in
application to give you hints on what
you possibly want to do next in your
application and very easily driven using
maven and all those artifacts other than
that you know there are other
innovations happening again by the Red
Hat itself it's like our Killian you
know how do you simply do end-to-end
testing of your application so I think
the key point being standardization is
important innovation still continues to
happen on the periphery you're right
between within the ecosystem so that's
our my only point okay yeah hello
Internet I mean just like standards are
being are moving slow I think that the
majority of real customers is also
moving slow so it's all it's nice to
have like the newest features and your
next projects and I think every every
developer by heart wants to do that but
in I mean in in in real life I think a
lot of the bigger customers and serious
customers out there they are still using
yesterday's technology because they
cannot afford to upgrade all of their
five hundred servers overnight every day
all over again right so they they are
still running a bit behind on the on
technology so you have to deal with that
whether you like it or not so I don't
think it's a problem that you cannot use
the newest stuff in production today I
mean sometimes you need that for some
sort of job sometimes you don't need it
so I don't think that's that's really a
negative thing then just like a rune
said
there's a lot of innovation happening
besides the standard the already
mentioned fortune achillion and there's
a number of other things which extend
Java EE based on CDI extensions for
example so CDI is an excellent model to
just hook other stuff on top of Java EE
as soon as you need it and then well the
last thing I want to say is that
did you really encourage your clients
not to do support contracts or did I get
that wrong though I didn't encourage
that buy lots of support okay so oh I'm
sorry Gordon I just yeah I just wanted
to ask that I'm not sure about the
bundling the app server I mean certainly
the app server if I were running on a
tomcat server which is you know very
significant market share in the industry
I'm not building Tomcat I mean I'm a you
know I and I have the ability to as a
developer run you know I'm a big maven
advocate I use that all the time I can
use the maven plug-in and run tom cat or
jetty and test my application but I'm
not really deploying the app server I'm
deploying just the necessary components
sure there are jars that again on a je
server they are pre packaged for you one
of the downsides that I've always run
into is that and I've worked with over
my career the all the pretty much the
odd versions of WebLogic 2 4 6 8 and 10
and or the other one the other odds
there's no coffee item that's still not
great thanks if that was part of the
rebuttal
so and we run into problems with
classpath issues over time inevitably
we'll get to a server unless so much
policing that the je deployment job
deployment it you know I run into an
issue and then I'm chasing down some
problem where the server's classpath
conflicts with what I have and if I have
you know if I'm building my application
and I've got that whole class path I can
use the tooling and figure out what's in
there and instead of waiting for
deployment then time to figure out where
that collision happened so I'm not sure
about the bundling app server thing
might not ever see that to be a big
concern and and I don't care about the
size of it right space isn't that big of
a deal space is cheap so I even think
might say if I'm pushing a Meg or five
Meg it doesn't matter I can email five
Meg to somebody now the gigs now so it's
that's that's not I'm not ever been an
issue that I've run into where someone
said hey tighten that bundle up you know
it's just my experience okay so any
rebuttals to that because we're kind of
probably just as an appointed process
like I'm not sure there's such a long
rebuttal I mean I do have an answer to
your question that can be concise the
answer the question yet you know much of
its been addressed so very quickly and
in the question of you know well would I
choose spring or Java I mean come on
right I'm the vendor for spring so of
course I'm going to choose spring but I
mean can't ask you to bid more fair way
like what what do I consider to be the
strengths of Java UV and spring right in
all fairness between them with the EE
right it's it's forming a standard I
mean this is fundamentally the value
that it's providing it forming a
baseline for well-understood
tasks right you know like when he first
came around I mean look at the things
that were pretty well known I mean
things like JMS right you know sending
messages through message oriented
middleware was something if you've been
doing for years and years and years and
years so it really makes sense to make a
standard for the job of worlds right
jdbc is a great example even though it's
not part of Java EE strictly well aren't
we all glad that we're not talking
directly to the drivers from which
individual are DDMS great could we have
something like JDBC there's really a
place for standards look at the success
of the servlet Center Wow everybody's
gotten value from that here so that's
definitely a string and another strength
is that it's getting better as it
evolves you know
version after version after version
particularly starting with the e5 it's
just gotten better I mean we fully
expect that it will continue to do that
and for a certain class of applications
it really is possible to stand up
something that depends on nothing other
than the ed6 api jar right that is
possible and that's a featurette that's
an ease of use argument and so on right
so more power to those who have those
kind of requirements but in our
experience that tends to be applications
that are you know sort of like a few
years old right they're not including
things like no sequence sauce and then
spring strengths quickly right
deployment flexibility aren't just about
any kind of platform that you can think
of like we saw on the slides providing
modern enterprise Java right things like
newer versions of JPA and so on on older
versions of ie 6 our excuse me of eg
application servers right that's been
one of brings great strengths over time
it's saying like ah you and your
organization can't yet upgrade to that
new web logic WebSphere version whatever
will help you use great ee technology in
the app server you have all right how
many have ever had that experience here
like using spring to bootstrap stuff
from EE that you couldn't upgrade to
that's a great story for E right being
able to use those EE technologies and
timely innovation right like things are
happening in the big data space and so
on now that you are if you haven't done
requirements yet it's probably coming
yeah especially with mobile devices and
all this stuff just pouring data into
your systems Springs therefore that
right that's a strength stands uh well
no so thanks all right so I got a little
confused there I mean let me go on to
the next question and we're gonna have
to wrap it up quick so we're not gonna
do any rebuttals and we're going to open
it up to questions from the audience so
our Java EE 6 and
competing or complementary technologies
and we'll start with Iran so we saw by a
show of hands like pretty much 95% of
the people who had their hands raised up
they all are using Java EE and spring
spring as a matter of fact requires Java
EE in at least some part of it you know
I mean you cannot run spring on a plane
for example port 8080 you know on a web
server now you do need a servlet
container at least to run it so that is
required spring web application yes
right right so spring web and that's
what we have mostly talking about sure
yeah and then in terms of you know how
you run it you know you do need to
outside you need you do need a web
application web Java EE application
server on it so as a matter of fact
recently spring has been talking more
and more about how you can integrate
with other Hawaii six technologies you
know you're using CDI yeah context and
dependency injection there is full
dependency injection capability in the
java ee platform they're talking about
how that is compatible with spring auto
wiring for example things like that how
you can leverage JPA api is in spring so
this was completely unheard of as a
matter of fact the way spring was born
was saying you know you don't need j2ee
so more and more actually is becoming
complimentary in my opinion but my key
point being if you're using an
application server that is Java EE
compliant use the runtime first you know
whatever capabilities are existing
within the runtime use that first
anything that is not provided by the
application server which is not a
standard then you can go extend reach
out to third-party library and see if
that provides you that capability and
then you can of course build your
application which spring you pretty much
you know can assemble your application
your own configuration yeah it's good to
upgrade your own JPA 2.0 point six but
who's going to manage that 2.0 point six
for you you are responsible for that
particular unique configuration with
Java EE application servers all of that
configuration is well tested you know we
have army of engineer sitting back in an
office
who makes sure that that application
server is tested with different jdk
combinations run on different hardware
so that when it comes to you for your
customers to know it's all well tested
the spring you bundle your application
you know your own way that's your own
unique recipe so you're responsible for
managing that configuration if a bug
happens in JPA to find 0.6 then you're
on your own effectively to manage that
complexity or fix the bug and then go
from there better because I think even
though spring and Java EE are definitely
you know technology is that compete with
each other but they cannot live without
each other sort of a love and hate
relationship okay Gordon let's follow up
with you our Java EE 6 and spring
competing they're complementary
technologies I think they're I think
there's some complimentary aspects
clearly we all you know very well versed
in JPA and servlet model we use that
quite a bit but in terms of competing
there's spring is innovative innovates
obviously we've it's been mentioned a
few times a lot more rapidly and we have
a lot more features on that are
available so yes of course there's
complementary aspects to it but I can
certainly build a spring application
with a simple container and launch an
application without without really using
je je technology I mean certainly using
by where you spring that spring batch
can run as a runtime just you know from
the command line and handle handle very
large scalable batch processes directly
so it's you know there are some things
if our if we're talking in the MVC space
clearly we're going to be using service
and if we're talking traditional data
stores we're going to be using JPA and
that stuff is very easy to do I'm a big
advocate of spring Roo you know very
spring Roo is a is a rapid application
with all the tool I can get my
application off the ground build my
proper layering of my application and in
using JP a servlet model and then the
rest of it I can configure in whatever
features I need for my services using
enterprise integration whether it's JMS
or mq which is you know
rapidly-growing is the flexibility you
can do with the advanced Message Queuing
protocol so here if you have a lot more
opportunity to take my service layer and
expose it out to integral enterprise
integration pattern this is using the
spring technology so yes please and so I
would like to take a look at the future
and say that and so if we both agree
that there is a great stammers in Java
EE 6 why doesn't feel mer sit together
with the other vendors and spend their
R&amp;amp;D dollars together to give us all a
better experience in the future I mean
stuff like spring latch no psycho-social
that could have been all jsr switch
could have been filed a couple of years
ago so that they could have been
benefiting from it in Java EE 7 or in
java ee 8 instead they choose to go
their own way but there so meant so much
common ground to the features discovered
so that's the question plastic Chris yes
sir I can just I mean it's my turn yeah
go ahead
yeah hit it ok so the question on the
table again is our Java EE and spring
really competing or complementary
technologies so make sure that I get to
that to your question but clearly
largely cooperating right I need to
throw out a statistic that feels right
80 percent yeah I mean 80 percent 90
percent cooperating in that either
spring is directly supporting that's
technology from Java EE like take for
example JMS and Springs JMS temple
support right and that's directly in
support of Java EE and you know
implicitly in support of servlets right
we're not doing a lot of encouraging
people to use a certain API directly
neither this JSF for many other
technologies I say for like the HTTP
server responses maybe but we're clearly
building on top of that so largely
cooperating in the sort of margins right
we're there because there's clearly
competition right you know there are
aspects that have happened in e6 that
spring doesn't support and people mostly
know what those are
what's the story right why why not
implement everything from Java EE
basically become a Java EE given
well in the case of things like CDI it's
not so much that weird diametrically
opposed to what's in CDI I mean I've
said earlier like hey when you look
through this there's really a lot of
nice stuff here the problem is that we
had a solution years and years and years
before that's very very widely adopted
that has conflicting semantics with CDI
right it doesn't mean that CDI or spring
are bad or wrong and compared to each
other but they are different
significantly different right and you
spent a lot of time really looking at
CDI and saying is this something that
makes sense not for us as a vendor
because that's a concern does it make
sense for the community is this
something that we can put out there for
the community is it gonna add value to
do everything that would be necessary
inside the course brain container to
make it CDI compliant and the answer was
clearly no and we haven't seen this from
the community question comes up every
once in a while but we don't see the
community banging down our door about
this and if we did we would probably
begin to change heart right it's really
what's in service of the developers when
it comes to refer to your question you
know why are we not at the JCP at the
table you know putting these specs
together early with things like no
sequel and social and so on I mean the
first thing to say is that of course we
are in certain cases right particularly
with add inject jsr 330 right that's a
bit of old news now but I mean that was
really a good-faith effort between the
juice guys and the spring guys have put
together a common you know that very
very very lightweight API it's just as
seven annotations or something like that
which is now of course the what
underlies CDI as well CDI is using all
those annotations like that injecting
that qualifier and so on so that's one
example another example it's very
relevant today is the batch spec right
jsr 352 we have two people on that speck
in fact the lead of that spec somebody
that's with us right it's you know Jo
352 the batch spec is clearly inspired
by spring I mean that's a that's an odd
in general to the innovation that's
happening out there in the open source
community making its way into Java EE
and we're basically all for it where it
makes sense right again it's about
pragmatism it's not about doing
something ideologically or dogmatically
all things must be specs
it's about does this make sense does it
make sense now is it ready to be
specified you know
the social jsr there was a social jsr we
didn't put it together but there was a
social chance sorry 357 it was roundly
rejected by you know by the JCP why
because it's just not ready we're just
not clear what that space looks like if
it should be standardized it can be
standardized does it mean this
standardized talking to Twitter's API
this is sort of outside the bounds of a
speck right so we would not even have
the you know we wouldn't want to come to
the JCP trying to specify this because
it's not the way that we work the way
that we work is we've got an idea we
think there's something that's going to
work here's a milestone here's a
milestone here's a blog post hears us
talking about it at a jug what do you
think and you might notice something we
sometimes take a long time to get to a
one point out right here more because we
want to get it right before we put it
out there and the way that we get it
right is just a different way than a
speck gets it right we get it right by
talking to the users directly as much as
we possibly can seeing people use it and
tell them to tell us what happens right
it's two different ways of getting the
same kind of goal okay so that's good
thanks Chris we have a question what's
your name sir oh please only three
thirty not $2.99
so so let me let me summarize the
question so I think the question is why
didn't you why weren't why was that yeah
great job summarizing a question so why
didn't Spring Framework participate in
the CDI spec GSR 299 so I think that's a
good question yeah it's anyone wanted
you to want to take a shot at that I
think it's better for Chris cuz he's
more in touch with that special dominar
I mean really just like to concede the
point fair enough
I'm sure there's more that we could done
quite honestly and there are politics
yes it's not a perfect world try this is
a big messy world that we live in and
that's sort of the point that brings me
making the hall along but not to deflect
right could we thin Lauren yes
why exactly didn't we I honestly don't
know the details cuz I wasn't the one
doing it you know the message that we
put out there was where we think because
you know if you look at what was
happening in juice and what was
happening it seemed and what was
happening in spring well-understood
domain means we all agree that di is a
good idea but those three frameworks
we're doing it pretty differently I mean
like remember by tection and things like
this right really quite different
approaches I mean juice has
significantly different approaches than
spring did especially in the early days
so it actually wasn't that clear to us
that we could arrive at something that
did make sense for everybody but we sort
of wanted to go as far as if you're
gonna put annotations in your pojos let
that be a standard everybody could agree
it's better to have Java X dot something
than or got Spring Framework or combat
Google right but yeah I think Peter Muir
would like to I have a follow-up
question
yes sir you can either stay or it's okay
are there any other questions or yes
ma'am
I'm not saying yeah I'm not saying that
no yeah I know that's certainly there is
a risk of getting class path issues
there as well
certainly and then you really know where
usually where the burden is no I know
this isn't a very popular thing but I'm
a big fan of SGI and I think it's just
the reason that it's not as successful
as it is is it takes a lot of discipline
and the tooling is poor but that would
solve a lot of the problems and whenever
I you know design system I try to think
in the OASDI space so that I know that
my packaging is there with maven I use
the enforcer plugin and verify that I
don't have competing dependencies
because that happens you know I'll get a
version 101 of Commons logger actually
I'd never do that because I'd never used
Commons logging but anyway but it has
happened where you'll get to judge two
different versions packaging but if the
risk is there the risk is always there
because developers will will make
shortcuts I mean yes
so how many people have used room in the
audience how do you move you all right
how many he'll use JBoss Forge Peter and
I'm not only that but no if you want to
look at the standard way of doing it CDI
portable extensions you know I mean
there are hundreds of examples on how
you can use CDI portable extensions yet
do it in a standard way
so for example you know we have a CDI
portable extension where you can just
inject the OSGi service and dynamically
track it now that's not part of Java EE
standard but that's just a jar file that
you take along with your application or
install and you OSGi compliant container
and that would just work out of the box
so that's not the innovation that's
happening in terms of CDI portable
extensions yeah also I'd like to bring
out a point not that anyone asked me but
I'll do it anyway so when we work on the
Jake aspect there was a lot of effort
involved to make the annotations and and
the tooling work with spring and CDI and
it was quite easy to do to do that so
there is I think there's more
similarities and differences between the
latest incarnation of spring which
spring has changed quite a bit since
2004 and Java CDI so yeah I'm sorry at
night I got a hit over here because I
don't work that way usually go ahead it
compatible to what I don't think there's
gonna be instead on a much yeah that's
gonna be a tough one to quantify
probably not much difference if it's
done correctly the most the models are
so similar they yeah a similar
performance characteristics possible
underlying contractionary yes that's
correct
right so we'll hit
well that's a long question I think what
we're going to take that one off line
and we're going to summarize I'd like to
thank everyone Chris Gordon Iran Burt
and thanks guys thanks for participating</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>