<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>NetBeans Plug-in Development: JRebel Experience Report | Coder Coacher - Coaching Coders</title><meta content="NetBeans Plug-in Development: JRebel Experience Report - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>NetBeans Plug-in Development: JRebel Experience Report</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/z0wmiBE9a_U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to the talk about netbeans
plugin development this is about how
terrible team was creating a plug-in for
NetBeans and what kind of challenges we
experienced and what kind of problems
did you solve basically in you know kind
of IDs you have an opportunity to
integrate with external tools and then
there is a question why why to create a
plug-in if you can just integrate an
external tool and make it work the tie
with the ID but I think the answer to
that is is that you you want a usability
a top-class usability for your product
and he wanted to be really smooth the
experience should be smooth inside the
ID and you want users to be happy using
your product just with one-click install
in one click configuration and so on my
name is Anton I work for a zero
turnaround and I'm a terrible product
lead and I'm a tooling freak as well and
back in the history I'm a long time
NetBeans user as well so we are going to
talk about terrible I will talk what it
is also for those who don't know maybe
we take a look on the plugins
development I'm like basics and and then
we will proceed to to the challenges
which we experienced on NetBeans
platform and how we solve that so let's
start with introduction to Java the the
topic here is the developers
productivity so chairboys a Productivity
tool for Java developers and the normal
turnaround cycle in Java EE development
is something like this you make a change
in the source code or in configuration
file and you probably rebuild the
package you upload their hive
to your application server you redeploy
the application you wait for some time
and then you can observe the results
maybe you have to arena we get inside
the application to see the change as
well so this kind of psycho actually
takes two and a half minutes in average
according to our service
it might get to extremes when you when
you're built face is really long and
when the redeploy time is really long we
have seen the the turnaround cycles to
be about thirty minutes as well but
those are really extreme cases so how
does it work actually we map the ID or
actually the running application that
you developing currently back to the IDE
workspace so that the agent could
monitor the the workspace and the change
and resolve the changes so whenever you
make a change you add a new method you
get a new field we detect that and we
update the existing classes inside the
application and the same is actually
applied for the frameworks because
currently everybody is using frameworks
in Java and obviously Terry you have a
problem of updating the configuration
files if you using starts maybe you
would like to add a new action to your
struts 6ml or you probably like to add a
new beam to your spring configuration so
therefore we have to integrate with
frameworks to update them on a fly as
well let me actually show you how it
works just a little demo on a NetBeans
platform we we have a small application
based on Spring Framework and it runs on
Tomcat and it stir it up
so it starts with terrible
so you see it already took me about 20
seconds just stir it up if I'm into UI
development and I'm developing some kind
of a layout it's really hard to get UI
right from the first time so in
development I will be constantly
restarting the application that I will
be annoyed by the end of the day and
it's it's not fun so here is the
application we have a type of there you
see the cycle the title of the of the
link is somewhat of nonsense
and let's take that so we could just
remove this typo here and save and
refresh the file and I can see that the
changes apply this is not a big feature
if you are in exploded mode deployment
the IDE can actually copy the GSP file
into the correct place and the container
will pick up the change but if you are
in package deployment you are not able
to do that you have to read some of the
whole package here you go
this is a big value already for you so
if you proceed further we can do some
more changes for instance we have a form
which is validated for the input and we
can see all the fields are required if
we submit only blank blank fields you
can see the validation errors and we
could make some changes in the code so
that sorry so with that we could
probably extract the method in this
refracture introducin method
the date fields and just to see that I
really changed something I will comment
out the first name validation on this
form so I switch back and I can see the
change instantly apply it today to the
application so when I saved the file a
good feature of NetBeans IDE is that it
can compile right after you made the
change this is what makes the experience
smoother in in this case but well you
you can you can apply any other changes
for instance adding fields adding new
methods changing signatures and and so
on but but the great feature is that you
can actually make the configuration
changes for the frameworks and for
instance I would like to add a new
validator to the first name field which
I'm not validating anymore and I would
like it to be a bean inside spring a
spring application so let me add a new
bean inside the XML well nowadays you
cannot be inside there
by means of the annotations or or in the
configuration file but in here I just
want to show you the complex change and
that's why I'm adding it into the XML so
and I want it to be available inside my
controller class so I'm adding a new
field which will be out of wired and I
would like to start using this validator
as well so and let me show you what the
validator does it checks for the first
name if it's antim this is okay so if I
submit the form again I can see the new
logic from the validator has been
applied the new beam has been added to
the context it was out of wired to the
controller class and I can see working
so so much of the demo
let's make it short and proceed with the
slides again so why I would like it to
be an ID plugging the first thing it's
the usability actually the first thing
is the automation you want the user
press the button you don't want to him
to spend time for configuration and this
is where usability also comes from the
second thing is the nature of chair bow
if we don't help the debugger to
understand the changes it will get
confused so that is why we need an
integration with debugger as well to to
be able to add breakpoints smoothly step
through the code when you when you are
debugging and so on
so if we translate it to NetBeans
platform now usability and setting some
configurations on the right the D box
those are applied to the product page so
it's mostly about the components the UI
of NetBeans and there is no problem at
all for us so we can use the the
available components and be happy with
that VM arguments so jeroboam is
bootstrap using JVM arguments on the
container and the process launcher is is
the component inside the NetBeans IDE
platform that we should integrate with
to to pass the correct arguments to the
launcher to be able to start with
terrible and also the breakpoints and
stepping facilities for a debugger so
let's let's take a brief look at the
NetBeans plugins what it is and how it
looks like basically there are a couple
of books already that are great books to
take a look at and and learn about it so
I I will not really go
into like how to development of NetBeans
plugins here but basically if we have UI
elements buttons actions toolbars menus
everything is provided by any means but
form extensions point extension points
are there you can plug in whatever you'd
like
in older versions of NetBeans layers the
dot XML file was the primary thing to to
modify in order to inject your
functionality into the ID basically it
emulates a file system its hierarchy it
has a hierarchy and within the hierarchy
you can define your own components so
either I actions toolbars you can define
an action you can say where it should be
positioned and be knit together one
important component if you are building
your own plugin which you like to be
configurable and so on is the options
panel where you can plug in and have
your own plug-in settings available on
this panel so it has both the old API
which you can define in the XML or
actually if you generate it in inside
the new ID I mean the new version of
NetBeans when you generate it you get
the new API with the annotations
basically just annotate the classes and
and generates the as far as I know
generates lyric somehow parts with
annotation processor right correct so
let's proceed to the challenges custom
JVM arguments so in order to start
terrible needs to define - Java agent
and a path to terrible char and for the
settings it might require some - D
parameters to be available as well so
this is it this is how it's boots trap
for some some versions of JD case it has
to generate also a bootstrap Jarah so we
would like it to be automatically with
my we wouldn't like the user to generate
this bootstrap on his own and and this
is also like a usability feature when
you just press the button and the
plug-in does it for you and it also kind
of different inside NetBeans IDE so you
might have different project types if
it's a maven project the arguments might
be passed in one way if it's a web
project it's completely different story
inside the platform and it it also
varies between the application
containers if you have a JBoss maybe the
parameters have are provided in one
place and if it's GlassFish you probably
need to do something else so from the
users perspective for instance you have
Tomcat and you go to the configuration
window of Tomcat and okay you can find
VM arguments there if you didn't have
this facility of automating the setup of
of the VM arguments but in case of
GlassFish you open the same window and
you do not find it so this is the
consistency problem for the user right
and well where do you define the VM
properties for GlassFish if you want to
run on GlassFish you go to completely
other place it's in the project
deployment window alright so if I am the
vendor who provides a plugin where my
user has to define VM arguments and I
don't want to make an error while
defining these arguments I certainly
wouldn't like him to figure it out on
his own because I'm interested that he
will just click and it will
so this is why we actually created this
little toggle contributed by the plugin
so it's just a boolean todo if it's on
it means Cherryville will be
bootstrapped if it's not on it runs in
normal mode so from from from the users
perspective it's the simplest thing to
do to enable a plug-in like this well
there is an api to that of course
boolean state action you can just set
boolean yes it's enabled and go but here
is the challenge in previous versions of
NetBeans ID before 7.2 there are no
extension points to provide the JVM
arguments to to the 2d launcher so we
had to do a workaround we had two binary
attached the launcher the platform
launcher on a file maybe it's not the
brightest idea but it worked for us so
how do we do that actually there is a
API which you can use to plug into the
platform called module install so you
basically implement your own installer
and if you are familiar with eclipse
plug-in development it's the activator
the same thing so you define your own
module and star and next you implement
your own picture which will patch the
platform so let's take a look what it is
you have to figure out first what are
the classes to batch on the platform
because for each project type or for
each application server which you want
to start it's implemented in different
process so for for each Tomcat or jetty
or or GlassFish you have to figure out
what classes are responsible for that
and in this example it's start Tomcat
start honorable which is an inner class
actually so next you have to find the
class loader which is responsible for
loading those internal classes and you
basically have to instantiate to get the
instance of that and after that you can
use some kind of a library in our case
we use Java cyst to patch those classes
on the fly and let's proceed with with
the real code that really patches this
class so this is a small example as a
basically snippet of what is happening
there luckily all those internal classes
implemented a run method it's not an
interface method but it's a wrong method
ends
luckily the same inside all the
launchers so we had like we've been
lucky to implement one single class that
was really capable of patching this run
method and inside that method basically
we had to intercept the logic which was
applying the JVM arguments on the fly so
get Java options and if we see that the
method is called we basically add our
own arguments to that one all right so
basically this is this what is happening
we according to to the settings of the
plugin which we can derive what is what
is the path to the binary to the
gyroball agent and just inject our own
argument inside the run method so the
benefits of that
is that well it works even if the
platform doesn't provide the interface
you can basically implement what you
want but it's a little bit brittle
because if the platform changes maybe
your binary patch will not work it's
it's almost the same as using reflection
right
but the good part of that is that there
is a new API on 1972 which was
successfully implemented and using
annotations you can create your own
argument provider to the process and
yeah this is how it should be we are
really happy to have it now the next
challenge is actually the debugger
integration so the the challenge is that
if you have a code which you have
breakpoint on and you make a change
which basically adds new new lines of
code new methods you have a new version
of the class and the old breakpoint sits
on top of the old version of the class
but do you have new new class running
and it does it doesn't hit the
breakpoint so we have to read transfer
the break points after the reload again
there weren't the API available for that
luckily I'm 7.3 is coming so you can
implement your own breakpoint class
filter for that oh maybe if you have
some esoteric cases maybe it will be
useful for the for that for the others
but as far as I know we are the only
users of this API for now and next part
is releasing the plugin the process of
releasing is something you want to be
aware of probably if you are
implementing your own plugin and you
want to put it in into marketplace
because well it's a number
think when when the users are installing
the plugin they want to go to the
repository and just download the plug-in
and be happy
so it starts actually with the packaging
you have to package your plugin in
NetBeans module and there are a lot of
things to consider actually because the
plug-in itself the binder itself is just
a single thing here but you probably
would like to have dependencies maybe
you don't implement all the code
yourself you have some components there
so there is a directory called module
extensions where you have to keep it and
settings or they actually be descriptor
of the plugin should be there and it has
to be signed as well so the the our
solution was to use various maven
plugins for that to to be able to
generate you can apply not not script
the build of the plugin so there is a
mbm maven plugin which can generate the
correct a Tkaczyk some properties
provide the dependencies which in our
case was Chavis is library yeah and you
probably need to generate also some
metadata
inside the manifest so you can use maven
chart plug-in as well
after you have packaged the plugin you
want to publish publish it there is a
portal this is the central place where
the plugins are published plugins dotnet
means the torque the the challenge we
experience is currently is that when you
publish the plug-in there is a
verification process in place so that
when your plug-in is there it's not
really visible inside the plugins
repository in the IDE so there is a
community volunteers who manually verify
the checklist
of of the features inside the plugin
there are some some requirements that
you have to fulfill basically the main
criteria shouldn't break the platform in
our case it's it's it's actually
reasonable because we binary patched the
internals so and it makes some time
because there are several people who
perform the validation and it's
volunteering and it's manual so it's
unpredictable actually if you want your
plug-in to be available on Thursday
you have no guarantees for that you
cannot count on it so I have talked to
NetBeans guys and they promised it will
be there will be a solution for a
predictable process so if you have a
commercial product you you probably want
it to be predictable as well if it's two
weeks it's two weeks if it's a month
it's a month if it's one day okay I want
it to be one day and I want it to be
available tomorrow so we learned some
lessons while implementing it the the
biggest lesson is that usability is hard
you never know actually how you end up
with all these buttons positioning and
and UI elements and so on you implement
it for the first time users report that
oh now this is not logical inside this
ID you probably have to do it some some
in some other way and so we actually
implemented the UI several times on hung
on how we should put the toggle or
should we have a separate button or or
should we have a menu there but but the
general idea is that you should follow
the logic of the idea if you have
NetBeans users from your team let them
evaluate your first prototype if you
don't have them you should actually
spend some time learning the ID or
probably using it for coding so the next
thing is that it's a good thing to use
the new
API if you don't have it there report
that you need it and that beans team was
really happy to help us with that and
annotations are better for code
readability in my case it's my personal
opinion here so but if you are in a rush
and you want it to be implemented
without relying on this process of
creating new api's okay you have a
solution to implement your own binary
patcher it works so but it's on on your
own risk
and publishing well it's not it's a soft
topic but it's a little bit
unpredictable how it's done right now
with that I actually would like to thank
NetBeans guys for cooperating on that
thanks for implementing the new API we
make the product better and that means
platform we world will also be a better
place with that actually maybe I was too
fast but we have now plenty time for
questions any questions yes Ketchum
the one lost API that you need on the
platform is the API for stepping in the
debugger so currently we still have some
binary patching code inside the plugin
so I hope if it will be implemented in
7.4 we will get rid of the all those
horrible hacks that we have right now in
the plugin the the feature request is
registered already and the guys are
working on it but they just didn't have
time to implement it by 7.3 any more
questions may be regarding Jericho or
that beans platform if you don't have
the questions now we have a booth in the
expo you can find me there we have demo
guys they can show you more demos or if
you have questions about the product
just come and ask thank you very much
you can finish this</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>