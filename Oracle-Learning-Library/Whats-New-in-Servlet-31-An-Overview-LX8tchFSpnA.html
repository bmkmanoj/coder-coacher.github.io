<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What's New in Servlet 3.1: An Overview | Coder Coacher - Coaching Coders</title><meta content="What's New in Servlet 3.1: An Overview - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>What's New in Servlet 3.1: An Overview</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LX8tchFSpnA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we're gonna talk about civility that one
API my name is Rajiv Madani I'm one of
the spec leads for the for the GSR and
along with me I have Shang Wai Chan
who's the co spec lead for silver 3.1
before we get started I just wanted to
get a show of hands how many people who
are still writing servlets how many
people know about 73 that all features
okay that's good and 7000 features how
many people know and use today okay so
we're gonna talk about seven 3.1 which
is the current GSR which is targeted for
Java EE 7 and it's not yet final so
there is still opportunity to make
changes if you have feedback this would
be a good time to join the users alias
on the java.net project and start
providing feedback or send comments
wishing why and me if you don't want to
join and participate in the list but it
is an early draft so feel free to send
us comments and feedback and we'll see
what we can incorporate after
discussions with the expert group with
that the standard disclaimer I'm sure
people are telling this have seen the
slide umpteen times we go to the agenda
so we'll do a quick overview of servlet
3.1 what features we're targeting and
why we're targeting those and in
particular we'll highlight some of the
things that we've been working on so far
and
those are basically in the non-blocking
i/o API protocol of great support so for
protocols like WebSocket where the
initial handshake happens over HTTP what
we're doing in the servlet API to
address that we've been looking at some
minor but important security
enhancements and there are some still
some more areas that we need to discuss
and close at the expert group and then a
bunch of miscellaneous bug fixes
clarifications in the spec which have
been open since a long time
or your since the trade-off and then we
hopefully leave you all off with enough
resources that you can disco take a look
at the spec and kind know how to get to
us with respect to the API even richer
and the jsr so the feature set for seven
3.1 essentially we were focusing in in
73 lat Oh what we did was we modernized
the servlet API to use all the new
language features that went to tear
since Java and C 5 before sublet 300 the
last major revision happened about 10
years ago and the the sublet sodaro API
came out around 2009 end of 2009 as part
of Java EE 6 platform and there what we
did was we targeted at modernizing using
annotations and making use of generics
and basically making the web.xml as
optional as possible for most of our
developers so they didn't have to use
any of the XML descriptors so with
solution 1 we wanted to make more
incremental improvements as part of the
$3 we target we addressed the problem of
asynchronous request processing but we
did not change anything in the container
with respect to IO processing or doing
any of the i/o request handling it was
still a traditional io API that can
sometimes become a bottleneck for
containers so instead of doing only
traditional i/o as part of servlet 3.1
as a as a as an incremental upgrade to
some of the changes that we did in
server 3.0 we decided to focus on
the scaling issues with respect to IO so
we're introducing non-blocking i/o in
this servlet API and basically we'll
walk through that in more details with
this it's code snippets and examples so
you can see how you can actually
leverage some of the non-blocking
features to get better scalability in
terms of the i/o for your for your
applications in addition to that we also
support our units in the process of
adding support for upgrading program
handling upgrade of protocols so as part
of HTTP we have the ability to upgrade
protocols today the only protocol that
really leverages the upgrade mechanism
is WebSocket but in the future you could
envision that more protocols would use
the upgrade mechanism and so what we're
trying to do is add a generic mechanism
not tied only to WebSocket but a more
generic version a generic mechanism to
upgrade your protocol to support
multiple protocols in the future and
like I said earlier also you're gonna
focus on some of the security
enhancements to make sure that you know
we address any security concerns in the
web web container and overall Java EE as
far as the web application development
model goes with that I'm gonna hand it
over to Shing why we'll walk through
some of the details of non-blocking and
protocol upgrade and I think he plans to
wrap it up with a demo that will show
how you can actually do an upgrade for a
particular protocol missing why okay
thank you thank you for watching both in
introduction and today we will try to
take a closer look on the non-blocking
i/o protocol upgrade and security
enhancement now first of all let's try
to take a look on a traditional i/o
example now in a traditional example
what we what you try to do is you try to
get a server input stream and then after
you get the input stream what you do is
just have a while loop and then you try
to read all the data now this is good
most of the time but if there is a
broking in the read here then the given
the server thread will basically hanging
there and waiting for the data available
now we try to address this problem by
introducing non-protein i/o and approach
that we try to use is to using the event
listener now let's take a closer look
how we are going to solve this problem
we are going to introduce a read
listener and write listener and then we
will add the corresponding api's in the
server infrastructure in and I will give
you the details how this thing worked
together and then I will show you some
example and how we work and if you like
to experience how it actually works you
can actually download the grassfish in
the from implementation then you can try
to pay around with the niño api now
let's take a closer look on what is the
changes in a server input stream and the
output stream
now for the server input stream is
associated to one listener and most so
that's why you have a set rate listener
API here so it means you have a most one
now after you associate input stream
will read listener then this will they
will start to using the non
if you do not set a listener RIT
listener here then you are still using a
traditional i/o and that is that the
point that you set whether you're using
the tradition or the non broken one and
similarly for the server output stream
you have a set right listener here and
once you set the right listener then
you're using the non broken output and
you can at most set one of them you
cannot have multiple read listener right
listener now besides you associate
listener to a server input stream and
write listener to a serpent alpha stream
we also asked some de AR the API so that
you can you can actually achieve this
non-protein i/o and we add two of them
in the server input stream namely is
finished and is ready now he's finished
basically tell you okay all the data has
been read and that's nothing more and is
ready is to let use to check ok can I
actually read it without blocking this
is very important because when you go
back to the traditional example once you
call this ABI you already Pro there's
nothing you can do so we add an API to
let you share okay are you ready before
we call this read API and we will see
how actually it works with some example
at the end and similarly for the server
output stream you have a API call can
write so basically you check whether you
can actually write before you go to the
call the right API otherwise you have
the blocking you may have the blocking
in this case now yes
yes oh yeah no not nothing
not really I mean we are still going
through some of these discussion someone
else where is this issue as well so this
is still a new draft and we'll probably
go reconcile some of these changes so
for people who couldn't hear the
question is why is it is ready and can
right why is it not why is it not can
read and can write so it's early draft
that's good feedback they are not the
first person to say that
and the next revision will probably
couldn't reconcile some of these changes
and make sure that the api's are aligned
so we was going through discussions in
the expert group went through this this
was the first name that I have we came
up with and I'm sure them all the time
yeah okay thank you for the questions
now then we take a closer look on what
is inside the rig listener in the right
listener for the read listener we have
three API the first the first callback
is in the call on data available so you
try to register the read listener now if
you can actually right then the
container will call back the listener on
the on data available method to inform
you that okay you have actually some
data to be read without broking then
inside this method you can do the
processing the data they're coming and
then when when you up to a pond you
cannot read then you stop and exit the
method and if the data available again
then this method will be caught again on
data available now when all the data has
been read then at the end of this
reading of the input there's an API call
on all data read it keep your
opportunity to do any cleanup for
example you have allocated by power or
by array and is at this time you can
actually clean up the data
and finally we have our own error here
and it's whenever there's something
happened and you just call this an error
method then you can do a proper a
cleanup or locking if necessary now if
you compare this ritenour great listener
you can see that it is more localized
JDK 7 the completion handler because the
completion handle like that you have a
method basically say when you're done
they call you which corresponding to or
not a threat and they also have a method
when there is a they fail they have a we
corresponding to our own error method
now for us we have one more method here
this call on data available now with
this new method in the additional method
here we have the advantages of doing
something like this in the in the case
of JDK you have to allocate the PI
buffer that you need to read before you
try to call the easing by easing i/o in
the JDK now before for this new API here
you try to delay the creation of the PI
array or Piatt
by array of Pi buffer in the on data
available method so if the data is
actually not coming I will not allocate
the PI buffer
it's only when it come I will try to
allocate the PI buffer here so this is
going to be a saving a memory
consumption in the case of the server a
moment now this is what we have in the
read listener and then for the write
listener it's a little bit simpler they
only have two methods one is called on
write possible is whenever you can write
the data this callback will be invoke
and then the next one is on error is
whenever there's something happened then
they will call they will call back this
and
now let's try to take a look on one
simple example how this work for the
read now this is the same as in the
traditional I owe you get the input
stream and then you get the output
stream and then now you have to set a
countdown last year I'm going to explain
to you why we need to do this in this
example and then you try to create a
read listener impo which I'm going to
show you implementation roughly what it
is and then once you create a rig
listener impo you associate this to the
input stream then you call separateness
and a method once you associate to this
it means that okay you can start to use
a non parking i/o when they are ready
now then the next step is not this
important you have to consume the data
as much as possible before they will emo
the listener now when you try to consume
as much data as possible instead of just
doing the traditional i/o that has an
input read that is not enough because
the input read by a cell can be broken
now in order to make it non broken what
you have to do is you have to do this
input is ready you have to check
can I read can i read can i read okay if
the I can read then you actually go to
read the data and then this while loop
basically is try to read as much data as
possible now once you read as much data
as possible you go out of the route
while loop you can do whatever other job
you you can do for example you process
the whatever data you have you tried to
read now if at that point well your part
what you're passing is processing the
data some more data come in then they
will actually go into the rig listener
which I'm going to show you how it look
like in the next slide but then now when
you go down in here then there is one
command here you call it wait
why why do we need to wait here
now if you do not wait then you continue
go down the method then you exceed the
surface method of the a to get method of
the server and then it's to end the
processing and the end of the read
listener will not be invoked so you have
to make sure that you are actually still
within the to get method when the
listener is in more involved now let's
try to take a look on the read listener
impo how we look like now if you take a
look on the rig listener impo basically
I try to implement the three method in
the interface one is on data available
you can see that this one is basically
the same as the one that you have in the
previous slide you try to read as much
data as possible until you cannot read
it and then on all these I read in here
I will do a Kanban here now why do we
need to do a countdown here when you do
a countdown here then you basically sync
no okay basically you're done you go
back to the previous slide you can see
that I try to wait here if I I do the
countdown then this wage will
automatically return to be true then you
don't get away after that point that's
how you try to keep the listener within
the scope of the Duquette method that is
one way to do it and I'm going to show
you another way in example number three
now this is so far is for the read well
now let's try to take a look on the
right now for the right is actually
quite similar to the read okay you
create a right listener impo you try to
associate this to a powerful string
instead of an input string once you try
to associate to a our stream now then
you are doing something similar to the
read in the case of read the next step
is you try to read as much as possible
now we are doing the same here you try
to write as much as possible instead of
calling is ready
you caught the can right now once you
caught the can right you try to write as
much data as possible and at the end you
also have this condom lash a weight
method the idea is similar to the
written example so yes at most yes this
at most way second a second you don't
need to be wait this example yeah no
requirement just example now since okay
most of us have a concern about this way
example I'm going to show you another
more sophisticated one now in surface
Rita oh yes
like so your question is is the light
data taking a output byte by byte so
you're right data is using the output
stream so you're probably using two
years one of the sender of extreme
methods uses you to bite or a byte array
or I forget what you don't need to be a
BiPAP it doesn't have to be byte by byte
but in a byte array
yes yes yes in this case yes
okay I can show you an example on this
if we if we have time now
now since okay let's go back to the
example number one and number two now
both number one and number two we have
to do a compound flash and it seems that
people has a concern do we actually need
to wait all the time it turns out it's
not now in surfer frito Oh what is the
most exciting feature that you can dream
up okay you have a notation and then
what else there's one thing very
important are you saying good now the
question is can we put the a Singh and a
non-pro Kenai all together the answer is
yes now let's try to take a look how we
put it together by the way all this
example I already check in in the
workspace so you can actually check it
out and then you can download and take a
look now now let's try to revisit our
read problem with the a Singh now again
they're the same you're getting the
input of a stream and then now a create
is in contact now there's something
different and then again I will create a
read this and the impo and then I also
saved this to a input stream so far this
is the same except by passing the async
contact in part of the written list and
the info and then SP 4 which is the same
I try to read as much as possible and
then now the difference is coming to
here instead of using the convent lash
I will ask am I actually finished it is
finished then I call it incomplete now
the difference will be in the relational
impo here now in a realist and impo the
on theta available will be the same you
have the same logic and you try to read
as much data as possible
now the difference is
in on all data read of this no space
here on all the internet the async when
it is stun you call the is incomplete
now in this case you end a synchronized
processing here and then you also have
an error method key yes
there are not either rap so the question
is why do you need the developer to
write the async complete call to thee is
incomplete so async complete is one of
the operations you can actually after
you're done reading an amazing thread
you can actually dispatch back to the
container so you don't necessarily need
to call completely cut this files back
to the container and do more fasting but
if you know that async serve with API is
in computers is one of them as a racing
context of dispatch is another method
where you can actually operate been
reading or racing or whatever wherever
you go you're reading you can then
dispatch to the back of a container to
say okay I'm done with my async
operation and this you could potentially
put but the byte buffer or whatever in
one of the request parameters and
fastened into the container back to the
container to the server or filter and
then the continue processing in the
circuit again so complete is just one of
the methods an async context and for
simplicity we just put the completely
right so in the traditional in the
traditional so this one I can people
hear me in the back of the room so in in
the traditional servant model where we
did not have a sink support we would at
the end of the of the of the service
method whether it's a do get to course
when you exit the method essentially all
the objects can be recycled so to
prevent that object from being recycled
if you don't use a sink context and the
example we used as a way if you in in
servlet 3.0 with the async support even
if you exit the service method which is
what would happen in this example the
sell request and response objects are
still available for you to continue your
asynchronous processing those objects
are not recycled and once you're done
with your you're already out of your
service method so this it's not going to
be done nothing is going to be done in
the service method at that point and
from your read listener one of the
things you can do is okay I'm done
reading I'm even done producing on my
output from here if if the application
knew and then you can call complete but
let's say I'm done reading but I want
some JSP to produce the output then I
can do async on texts are dispatched to
foo dot JSP
so who who can do is it the container
are you saying the container can take
that on or well by the stream the
servant output stream discern that input
stream ascended out the stream doesn't
know what the application wants to do
once the applet once the AC
you may have yeah exactly the
application has the additional lacing
processing in the acing processing
you're doing you're waiting for a web
service response to come back from eBay
for example to get all the current
auctions and then you want to display it
to your user by our JSP page for example
you'll get the results from the web
service now you'll dispatch to a JSP
page to produce the app for you that's
not really in the control of the summit
of the stream it's in the control of the
application what the application it
wants to do okay and maybe I'm not
following what you want if we can talk
about flying after this and see what
exactly we're trying to
which one's like what you're done okay
okay so we can talk offline to see which
okay thank you for the question and now
he is about the nonprofit IO then we
will try to go into the second topic
political upgrade and after that we'll
go back to some explicit example and I
will try to go to more what a co-op rule
in this case in that case now let's try
to take a look on the protocol upgrade
now total political upgrade is not
something new it's actually something
specify in HTTP 1.1 this in RFC 2616 and
this is connection base what does this
mean now for given condition you can
have multiple requests you can request
number one using the condition request
number two is using the same condition
now what it means by connection base in
this case is if connection if you're
given a connection and then you use if
we cross number one and then we cross
number one say okay I want to upgrade so
I send a upgrade to the server and the
server decide to do the upgrade once you
upgrade then all other requests is
actually using the new protocol is not
using the original one so once you
switch you switch to a different world
you cannot come back now and then this
once you switch the different protocol
this new protocol can be something
actually it's totally different for cap
for example we can be a chat protocol
IRC chat protocol or it can be something
that which is very popular crying right
now is the WebSocket so we will try to
take a closer look on how this upgrade
can actually work in a servlet now let's
say a few words about the WebSocket the
WebSocket is standardized by the IETF
and they already have the API in the w3c
and the WebSocket is alias
bi-directional
and fruit impacts now what it means is
right this now you can send a request to
the server and the server can say Lucas
back and so you can run trip and fall
like this in a good friend request so
that is the good thing about the the
WebSocket and he's also full two packs
so you can actually send like this at
the same time now let's try to take a
look on a simple example how the actor
Hatter is actually working in the in the
case of a WebSocket now in the case of
WebSocket now you can see the kind can
actually send a normal HTTP header at
the beginning of the handshake so you
can say get and then an homage t DB
Hatter you have a hose and then you
specify something called upgrade
WebSocket and a connection upgrade now
and then you have other bunch of the
WebSocket header now this is a normal
HTTP request during the beginning of the
handshake now once you set send this one
to the server side now the server can
make their own decision to see whether
they decide to upgrade or not for
example you can say if these in the we
end I decide not to do the upgrade then
you don't need to send back a header
like this you can just say for example
use an error of a file file whatever
whatever you like but if the server say
ok this is the right time you can
upgrade then the server need to respond
to the kind and tell them ok you can
upgrade now in the header that they need
to send is in the HTTP 1.1 a 101
switching protocol and then you specify
the upgrade and the conventional xx and
etc now so so so far this is about the
handshake and we will try to take a
closer look what we can do for the
circuit now basically what we try to do
in the servlet is something like this
now when you have a request come in the
request will come
to the servlet and the servlet will make
their own decision to see whether they
decide to upgrade or not if they decide
to upgrade then they should call certain
upgrade a P I and when it is done then
eventually they will delegate all the
new work to the another class called
Politico handler and that is what we try
to achieve in software either one and
now we are trying to take a closer look
on exactly what this upgrade ABI is and
what this protocol handler looked like
and again if we introduce some new
classes and and we also add some api to
existing classes and we will try to take
a look on this now for the
httpservletrequest we only add one new
API is called upgrade so when you call
upgrade you will pass in a protocol
handler the potable handle that will
basically try to handle all the protocol
that you you need to do to need to
process and I will say more about this
later now besides the upgrade we also
add two interfaces the first interfaces
is protocol handler and the protocol
handler only have one method called in
need and the in neediest you pass in a
web connection and in this moment the
web connection only had two methods one
is to get the server input stream the
other one is to get a servlet output
stream and we were going to show you
example on how this worked in there in
the case of echo polar code that I will
try to describe now let's before we go
to the code let's try to take a look on
the skeleton of the upgrade example now
we will have an upgrade servlet and then
inside the to gap you will try to read
the header and whatever and
up to a certain point you say I want to
check do I decide to upgrade if I decide
to upgrade then I were going to call
this request or upgrade method and then
we pass in a new protocol handler now
all the magic is in here how does it
look like it turns out this one is
actually related to the non broking i/o
that we introduced at the beginning of
the of the presentation now the protocol
handler basically is only one method in
this moment is indeed from the indeed
you can get an input stream our stream
and then you can create listener and
then you can see all your Associated
listener with the input stream and that
is what we do try to do in this init
method now why do we need to introduce a
non-blocking i/o here now basically is
write this now once you call the upgrade
method in here maybe I'll go back to
this one yes once you call upgrade
method here you do not actually process
the protocol immediately here because it
in here basically is a marker you mark
say you mark the connection say that I
want to upgrade you have to let the to
surface method a surface method of the
surface finish
once you finish then you also need to
unwind all the filter here your unwind
on the filter and then at the end you're
going to invoke the protocol handler now
in this case that is one the reason why
we are trying to use a rig rig listener
method because in that case the data may
actually come after the the surface
method of the servlet and then they will
call you back when the data is available
and now let's try to do the simple demo
now so far I'm going to give you a
skeleton about how the test case look
like now let's try to take a look on a
real example that I have checking into
the workspace you actually you can check
it out now you have a inner surface
surface method basically you say okay do
you have a up Greek had called echo if
no okay then I just return okay no
upgrade then I is no upgrade can be done
here now if this is really an upgrade
protocol this is a protocol that I
invent for this example then what I do
is okay I'm going to set the status I'm
going to set a header that I need to set
and then I will create a new protocol
Acapulco handler now let's try to take a
closer look on on this one
now in the echo portable handle you have
an init method and the init method as I
say is you try to get the inputstream
and outputstream and then you create a
great listener
impo and then you try to associate this
witness and input to the input stream
and then the next step is you have to
consume all the data as much as possible
there is one thing that that I have
mentioned in the previous example I
think is in example number one we an
example number three now in this
particular case when I consume the data
I will try to write the data at the same
time in here we can actually also to the
nonprofit output but for simplicity I
will only do the not broking input here
because I want to get astray exactly how
to upgrade work now so this part if you
look if you come you remember what I
wrote in the example number one you can
see that this part is actually similar
to example number one now then let's
take a look on the read listener in Poe
here now in the richness and the impo
you can see okay I will construct a PI
buffer and then I try to look I try to
consume the data and then I try to
append a Bible and then I try to output
it in certain format now again this is
the thing that you you you have to do
you have to check whether the data is
ready if he's ready then you read it if
it's not ready you should not read it
and then you also have the on oughta
read method in this case there is
nothing I need to clear now and I just
put another marker at the end of the
output stream and there on error in this
case just cleanest a trace
and I'm also going to show you how the
how the kind code look like now the kind
code basically is I try to construct a
post request and with all the associate
had that I supposed to have and then I'm
doing a trick here I write a hollow and
then I do not write the world instead of
writing the world I say I want to sleep
for three seconds and then once I sleep
of three second this will be actually
what it's a broking operation then I
make sure that they will call the read
listener in order to demonstrate what I
try to do and then you have a write the
world again after three second and then
at the end this right chunk now is
basically I need to write end for the
trunking and and once I do this then I
just have a test to pass a corresponding
Hatter and make sure that I get the
corresponding result now let's try to
take a look on how this look like so I'm
going to run this example with a end
script and you can see I will basically
do a can-can you read it on like a big
okay basically I just have a taco Corp
you deploy and run and then deploy and
then now let me try to do it to see you
you know and then at the same time I'm
going to look at the log file now I'm
building it and then I try to run it and
then you can see if you look at the law
here I have upgrade to use echo Handler
and this I put it in the in the surf
like oh and then now when I go to the
init method type ranges in need now and
then the next step is we have a loop to
say we try to consume the data as much
as possible now you can see I actually
read the holo here okay when the coder
on data available because in this case
the holo and then you sleep for three
seconds then you go to the compact the
read listener and then you go you call
the on data available method and then I
get the world and then once all data
read I go to the on auditory okay let's
go back to take a look on this yes it's
in here now you see if I went on all
data available I will put an assistant
allow to indicate I have actually
calling here you see here and then when
all the data read I'm actually calling
this so this is a simple example of how
this the upgrade and the non parking
read is working together in in the in
the circuitry that one yes
okay I think is okay we okay now in this
particular case you we pass in the HTTP
request in the constructor you can have
your you can keep the section if you
want okay now let's try to go back to
our presentation and then we will
introduce add another exciting part
security now security is always an
important topic in all the enterprise
application and we will try to go in too
fast
okay we are trying to do some
enhancement of other security the first
one that enhancement we are trying to do
is for the run s now run SSL is a
existing feature in the surface
specification I think it exists long
times ago and now at that time basically
is like this whenever you have a server
request you have a get or post and then
you come in to the request if you put a
notation a job do you put the department
descriptor you can actually say I want
to run this operation as the other Road
first once you have this you can for
example you grant your role to run an
EJB operation now but it seems that it
was silence about what happened to the
in need and destroyed now when you're
doing the in it and destroy do we need
to also have the run s also also work
for it's in it destroy it turns out it
is worthy to do it now for example you
imagine you have a situation you have a
servlet and you are doing some
administration operation the in need may
actually create certain administration
and beam and in this case you need to
have certain privileges to do that and
then at the end when you shut down the
servlet you call it destroy maybe you
want to clean
some other mbeans so in Dick's this case
it is important for the in need and the
destroy to also have the runners role
and we have a terrified kitchen on the
spec and say that the runners will also
apply to the Indian destroy now this is
the first cavitation we do for the
security and the second one is we try to
do some functionality so that we can do
the section we can handle the section
fixation attack power
now the how many of you note about the
session fixation problems okay good now
this is a famous forum now let me try to
show you how their hacker supposed to
work but you better not to do it but
these how the people some people did it
now one day you may start to suddenly
get the emails or you get a webpage from
a hacker and the hacker will actually
dress up an eight nights HTML and in one
of the button the HTML HTML is actually
pointing to a certain bang and then they
have a certain hidden parameter about
the section ID or they can have a form
they try to post a hidden field so it
means that this the button is actually
corresponding to a URL and some section
data now they send you the email and
then you take a look and then say oh
they may say or there is some promotion
in certain bang and then you say oh let
me click on the button and then I look
at the URL yeah yes right it's the bang
that I have account there and this is
three one it's not a fake one
okay I'm going to log in to see whether
there is a promotion there and then I
say oh I login I don't see it but okay
then maybe I go out to take a cup of
coffee now then that's the problem
because the hacker also have this URL so
it means that you can actually hold in
your section in this
case he no all he will keep checking are
you Lauren are you Lauren are you Lauren
because he just need to keep sss same do
our then he can actually get the same
section that you have once he get hold
of your section he can be on the behalf
of you do whatever he want this is
called section fixation attack now how
do we solve this problem now the section
fixation attack before the suffering
free thought one i think there are some
vendor they try to solve this problem by
using the changing the section ID on a
vacation now what does this mean what it
means is something like this now even
you give me a URL like this it's fine
okay
I take it you go to a webpage and then
you type use an imposter but once I log
in the server will change the
corresponding section ID now in this
case then the problem is solved because
the hacker is still holding the old
section ID they do not know what is the
new section ID in this case they cannot
hijack your section now the question is
now different vendor is trying to solve
this problem using papycha api because
you're inside the container you can
actually get whatever object you want
and you can modify whatever attribute
you like now the question is like this
if you're using 196 module then in this
case what can you do you have you for
example i'm another vendor i try to
write another authentication module and
i need to i supposed to have this
feature too because this is an important
security feature what can they do in
fact it turns out that if they want to
add establish this change such an ID
feature what they have to do is
basically grab the existing section and
then they thumb all the data to another
hash map and then the expired section
and then you create new one and then
they populate it back and then is more
that the people tried to do now it seems
that this is too much work
and you create a lot of saggy fat
because imagine if the people had
registered section attribute listen now
then they will suddenly get a lot of
event because you tried to populate the
event at the object back so we will did
we decided ok we should have an API to
have the people to write the odd module
and then we introduced to a beehive one
is the change section 8 idea
sorry and the other one is we introduced
another HTTP section ID listener and
these importance because in the HOA a
moment you may like to know the section
ID is actually changed then you may need
to actually go to update your actual
database or a sponsor every and this is
already check into the grass fish you
can actually try to play around with it
now this is so far this for the security
enhancement and then we have two other
issues that we are discussing with but
we haven't finalized the another one is
about this is if you have a security
constraint like this and then your only
specified ok then what happen to other
HTTP method you don't know right now but
then it will be by default the server
will handle by default more server will
say ok you can do all permission you can
do whatever you want now the question is
how many HTTP methods are there how many
hmm six is it the only answer okay it
turns out I think it's p4 sort of to top
5 it is 6 in 7 3 2 2 to 5 I think they
add in more they want to support the web
tail in that case they actually extend
the HTTP method to be unpack
the set of tokens you can take a look on
the schema you can see it can be
actually foo bar and any other
characters so it means that you actually
forget a lot of things in the in setting
of the security constraint then the
there was a discussion and expert group
and saying that should we need to do
something about the default behavior so
we are still another discussion about
this if your interest you can join the
user alias and give us feedback and the
second issue that we are under the TV
DG's we try to post a request and then
inside the URL you have a another
parameter and then you also post a data
then the question is what is a in this
case if you call the get parameter a
what will you get hmm yeah you get h all
of them in which one is coming first
hello now and this is going to be some
time the people concern this actually
creating some security problem because
again they can give you URL that is in
the form they like and then they give
you a form then you pose it on that and
you'll get some other security issue for
example if a is actually transferred to
account number then they can give you a
URL that is actually pointing to another
account number which you may not aware
of but then you may think that I'm
actually posting the account number
inside the body but in fact you're using
this one okay since I'm I only have
about seven minutes left I need to show
you more about this surface little one
so I'm going to go a little bit faster
okay there's another question about what
happened with you tell me a is actually
this set can you tell something about
what's inside the post data there are
answer yes yes I know there are many
possibility so I'm going to let youth to
figure it out but it's not one answer
there are many answer here
now let's try to go to the miscellaneous
section now in the in in the surface
even before the surf at 300 API I
believe they have a above the reset and
set character encoding the reset
basically create the buffer and Heather
stethoscope and the Sakura encoding
basically set the character encoding for
the writer now let me give you a quiz
can you tell me what happened for this
particular example now you try to set
the content type set the care up and
coding to the I so a finite one and then
you can get the writer and then you do
something and then up to a certain point
I say okay I decided to do something
wrong I'm going to reset the buffer call
the reset API and then I repeat the SEC
content type second coding and then I
get output stream and then I try to
print the data and of course I by
intention set it to a different content
type and the different encoding now what
happened you keep the same which one is
the same you mean the content type and
the Karaka and game coding you think so
yeah okay any okay it turns out it is a
very tricky problem the content type
will actually change because you clear
the header but the character encoding
URI in the surfer free-throw you look at
the spec they say that once you get the
writer the Sakura encoding will have no
effect after that and the worst part is
you get the output stream what will
happen you already get a writer can you
get the output stream
no then what happen exception so it
turns out that this line has no effect
and this line ever part so we would like
to fix this in certain 3.1 because in in
this example show that once you
all the reset actually you cannot change
a character encoding and the first two
bullet basically summarize what I just
say is that you can either have one of
this in the set character and coding has
no effect and the clarification in 3.1
is basically we said not only create the
HTTP header status code and the data in
the buffer
they also reset the stay of calling the
guess table output stream and the cat
writer so they don't remember whether
you have called the get writer or guess
sort of input string we will erase the
data and let you call this to again now
so far it is about the set camera
encoding if you look at the example that
I just mentioned now it's working the
Sakura encoding now good is working and
the get output stream good it will not
flow reception because you reset the
stay of whether you're calling the
writer output stream and another example
that another feature that we try to
clarify is the relative protocol URL now
in the Sandri Tyra API you have you can
redirect to a local JSP we have redirect
to a JSP edges from the contact route
and then you can actually redirect to
another host now notice that if you try
to return to another host in the server
300 API you must specify the scheme here
so you must specify whether it is HTTP
or HTTPS now in this 3.1 we add another
extension is you can specify a relative
protocol URL or they have an under name
called network path reference in this
case you told me to specify the scheme
what does this mean it means that they
will use the scheme of the corresponding
request if you're coming from HTTP this
is HTTP if you are coming from HTTP
these HTTP so
again this feature is already checking
the grass fish you can try to download
and use it and then there are some other
minor care of occasion what happened
when a get part in the gap Pass API when
there is no motor park configuration and
then we supposed to throw the exception
we did and then the other one is about a
servlet container in initializer and it
seems that there is some some confusion
people to think that the metadata
country actually has some different on
the server con subject container in
initializer and in fact they're
independent we spare with this out
explicitly in the specification and we
also care fide that is for each instant
of a web application you will go a get a
current copy of the server container
initializer instead of a singleton and
this information is in fact in the
oldest back to but maybe the wording
need to be clarified so this is not
surprise to other people and then we
also have other curve allocation like
you add this API you add the generic and
then you have some other typos and etc
if we fix it in the server in the spec
and ok so far and and if you want to
learn more about the spec and the
project then you can actually go to the
java.net website and you can subscribe
the user alias there you can take a look
on also the email archive that we have
in the discussion and the user elevators
and the expert group and you can also
send email to this web tier across which
Java tonette and then you can ask
specific question about the grassfish
and of course you can download the
grassfish Potter here and then you can
try out yeah thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>