<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Developing Java Mobile and Embedded Applications with Java ME SDK 3.2 | Coder Coacher - Coaching Coders</title><meta content="Developing Java Mobile and Embedded Applications with Java ME SDK 3.2 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Developing Java Mobile and Embedded Applications with Java ME SDK 3.2</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gD8ifk9P9ak" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let me introduce myself I am product
manager of Chapa mes DK and I'm also
managing Mission Control Java Mission
Control which is not on my mobile
product so I just did this demo last
year too for the previous version Java
SDK 3 point 0.5 and this year we have
released a new version which is three
point two so I would like to show you
the new features that we added and also
show you how you can program in Java for
an embedded device so we made a big
announcement at the Java 1 keynote
session about the big push into embedded
systems so I'd like to show you how you
can leverage this technology to write
your own application for embedded
devices so just before I get started how
many of you have tried building
applications for mobile phones
maybe not embedded devices but mobile
phones ok and I believe all of you are
familiar with just Java code Java
language because I'm I'm going to show
you how to just you know I'm going to
just code on life so hope that helps
I'll spend a little time on slides and
try to spend more time on the live demo
so let me okay so can you plot the slide
or should I should I do that ok
later
no no no this is fine got it okay looks
beautiful so yeah so what's new in 3.2
job I'm is decay when people say as
decay he can mean different things
Android SDK iPhone SDK they all have
different components when we call it SDK
we mean these four components
the first one is device emulator I
believe I can use this or laser this one
okay device emulator and development
environment for assisting of writing
running and debugging and we also
included some sample codes lastly we
also provide ID plugins so that you can
you know you don't have to do manual
integration yourself you can just simply
install these plugins in your IDE either
that pins or eclipse once you do that
it's just integrated with the idea so if
you just click one button in the IDE
then this Java ME SDK emulator will run
instead of the traditional you know Java
IDE plates or java java application we
we also have this own device tooling
architecture which means which I'm going
to show you right away right after this
which is we have this something called
device manager which manages different
devices so it doesn't matter whether the
device is your emulator or the device
that we provide what we'd recommend or
whether it is a third-party device which
is so as long as these devices have the
runtime Java Runtime and as long as
those runtimes support the protocol that
we designated then this will just work
fine
so here are just short summary of this
release highlights first of all
implementation of OJ WC so when you say
we implementation it means it provides a
full emulation for this specific runtime
so paws java wireless client and
embedded runtime we support also both of
them and we started to support this
information module profile next
generation so this profile so you may
our familiar with you may be familiar
with mid p profile this is a new profile
for embedded device so it's called IM
PNG we also added this new device skin
creator which are also i'm going to show
you later we added support for eclipse
profiling network monitoring and all
kinds of monitoring tools which i will
also show you later we have also have
have update center so these are main
features ID integration as i said once
you have this you have this integrated
when you click the Run button or stop
button when you click debugging button
then all your application will run on
this emulator CPU profiler means you can
profile your application and see which
method and which code blocks are using
most of your cpu time memory monitor
which means you can monitor your memory
in real time grunt usage and the total
the maximum usage of the memory and here
you can see how each variables or blocks
are how much they are taking up the
memory and the power curve so the buffer
means so I just said once you start
debugging session from here you can
start debugging either on your emulator
or on the device this is a new emulation
environment
that we are we have added in this
release which is embedded application
development so you can see how it's
different from the screen over here
that's the emulator for mobile devices
and here's the new emulator for embedded
devices so embedded devices you want to
control this general purpose i/o or I
square C's SPI mmm memory mapped i/o T's
you want the emulation for these ports
so we added these features lastly which
you know I'm also going to show you is
on device tooling cost and rice King
creator yeah that that this is the last
so so you can specify we call it skin
but it's not really something graphical
it's not about the graphic skin actually
this is a configurator in a way so you
can configure your own device whether
what type of keypad it has and what type
of screen resolution it has this on the
left side hits for mobile device skin
creator and on the right side you see
the embedded device profile creator okay
let me show you show you all of these in
live demos okay thanks so what I have
here right now I have this NetBeans ID
running and I also have this device
connected to my computer it's a bit
difficult to see but it's a arm11
cortex port here is the CPU and it has
all type of peripheral devices for
developers so you don't you know the
your end product might look much smaller
and a much simpler but while you're
developing your own application you want
to use all these peripheral devices for
testing so it comes with two USB slots
and here's the Ethernet
flat GPIO and here's a link to the
debugger and you can put your own micro
SD memory card into this board here's
the audio volume controller there are
four buttons here and eight LEDs yes I'm
sorry
oh it this is called so this is called
Kyle ke il so if you just go to killed
Kyle calm or Kyle calm that's apparently
at the last name of the person who
designed this device mr. Kyle
so what I am using this this model
number is stm32 f200 so you can actually
you can be able to find this information
from our Odeon Oracle technology Network
later once we have this binary uploaded
on the website it's not there yet but we
are releasing the Pinery soon so what we
did was to implement a reference code
grab reference runtime for this specific
board so that you can just download it
and install it on your device and test
it
I can also show you how you can install
that it's a simple process how you can
install download your own runtime into
this board there are some serial ports
here l LCD agency here and there is even
even a camera small camera it's quite
powerful so this is a board that I'm
using for testing once you have this
board I think I bought it at three
hundred and fifty dollars and plus tax
and I'm sorry
yes that's a good question so I'm using
this USB cable it is plugged into my
computer through this USB I'm also using
this Ethernet cable just because I want
direct connection with my computer but
you don't need you don't really need
direct connection so I just want it to
be stable and I want the IP doesn't
change not change so I'm using this
direct connection but in usual cases
what you can do is once you have two
Ethernet cable coming out of from your
router you can plug one to your computer
and the other one to your device and
this device will dynamically get the IP
address through a DHCP protocol yes
yes
so if you want to develop an application
for thermoset so this is your controller
hardware controller right it has the CPU
and everything so you want your
peripheral devices connected to this
board to kyle board then you can use
your java application to control your
prefilled peripheral devices that's how
it works this is a mini computer
basically so you can actually see those
live demos once you go to that demo
ground and they have this robot you know
that react to external environment when
you you know put that flashlight into
the house then it turns on the switch
and if the temperature goes up or down
then it cools it off and it you know
heater turns on automatically those type
of things you can control them so let me
get started first thing that i want to
show is how you have this once we have
this table IME once you install the
plugin into napkins then you will see
these menus i'm using device selector
for the convenience of launching the
update my application directly from here
for now i don't need these two i only
want to show this so the first thing
that i want to show is when you write on
application for this type of board what
you usually do is to download the sdk
from kyle and then once you have this
you can write your own c code to control
for example leds so this is a blinky
project which is controlling your leds
once that if i run this application it
will blink LEDs from 1 to 8 back and
forth so that's the code let me go back
to java code intentionally i have a
blank
here so I can start from something very
simple so so once once the application
is started I want it to print out hello
world so that do the emulators so I
added these two devices later but once
you first install you have only have
these two so if I just run this
application and you'll see
it starts running the emulator and it
will print out the result here it does
not have LCD screen so you don't see
anything visual on this emulator but
another thing that you can do is you can
generate external events and send it to
your device so think of this part as
your device which has GPIO s I square
CNM mio I'm sorry if you're not familiar
with these terms these are just you know
peripheral our no no input I output
terms for this type of device and these
are like pins so there are five pins
connected right now so two LEDs and
three buttons we are assuming that this
device has two LEDs and three buttons
and you can send these events to your
device from this events generator so
once you do that next thing you can do
is maybe something let me so next thing
let me try something more oh let me let
me just try to run this application on
the device first so here you see
external phone it's not really a phone
but we just call it phones all of them
this external device is actually
referencing this device the way I added
device this device was by just adding
the IP address so on this screen so I
have this I've set the IP address
already for this device yes
no yeah that's a really good question -
so - Java Runtime it doesn't go on top
of Linux or order any other voices it
goes directly on the board so when you
reboot this board it doesn't load any OS
and it's any starts Java Runtime right
away yes right not metal yes there is so
there is something in this board such as
you know our TOS we call it it's not a
separate OS installed on this board but
it has its own controller of course you
know basic software kernel and then Java
is communicating with this kernel yes so
I can try to run this application on the
device so oh so I was talking about how
you can add your device so that it is
detected so currently this device has
the IP address of 192 168 1 20 and 10 so
if I add it says the device is now
available so it tries to prove get the
device over run time at the specific IP
address once you detect the red Java
Runtime then it connects this runtime to
the computer so and then it adds this
here right here you can also see that
you can also do that from here
managing device address once you add to
this device then you can run directly on
the device from your IDE so let me open
this session login session you see that
starting Java ME embedded it I this is a
just typical putty terminal session that
I have preset to his IP address
this way I can connect to the world
through Ethernet and then I can look
into the board another thing you can do
is to open an application management
system so I'm I'm working in the board
right now so there are a couple of
comments that I can use a mess list
means all the applicated give me give me
all the applications that are installed
or that are running on this device right
now so it is giving me the list and you
can do all the other things here
yes midlet oh yes
yes correct let me I'm sorry
so it is basically a midlet as you can
see here it's importing midlet but you
cannot use any graphical operation here
it doesn't have a LCD we don't support
LCD yet so as you see it just has
printed out hello world here let me
terminate this application and try
something more more sophisticated more
fun so here's an application that I
wrote just to see how I can control this
GPIO 4 so my goal is to turn on these
LEDs here when I press these buttons so
I want to play with this in interact
with buttons and LEDs to do that first
thing that you need first thing you need
to do is to import this GPIO device
access once you do that let me just
define a couple of static variables and
here's what I want to do going through
all the LEDs and assign a little pins on
I so that means I want to assign these
LEDs GPIO manager that get pin it tries
to get the reference for each pin on the
pin number I
so I assign these LEDs to here I need to
actually try and catch this good luck so
I as I finished assigning that another
thing that I want to do is to assign
buttons to each pin so these codes are
doing the same thing GPIO manager that
get pin for specific index and then I
want to allocate these to my button
variables
so and then I can set input listener for
each button when I press a button I want
to do some specific things so when I
press button when the value is changed
it gets the pin number and tries to
identify which pin it was so if the pin
is wake up button pin so this means
there are three buttons one is called
8:00 wake up
the other two are temper and user
buttons I have three buttons so I want
to do this operation when I press wake
up button and this operation for temper
button and this operation for user
button that's it that's basically what I
want to do so well here inside the code
you can see how you know what I'm trying
to do here so when I press wake up
button I want to turn on LEDs from 1 to
4 set by setting the value to true and
plus a little bit and move on to the
next LED 1 2 3 4 and then turn off the
LEDs from 4 3 2 to 1 so that's what I'm
trying to do here let me just copy this
block of code it's pretty
straightforward it in to start and I
just need to add this code to the
destroy to clean up when the application
is destroyed so so I can test this on
the emulator first before I run it on
the device for debugging so for to do
that this time you see how my default
the emulator had only two LEDs but I now
need 4 LEDs right I am using this
application for controlling for LEDs to
do that I can create my own skin which
has 4 LEDs so here I need 1 2 3 4 I'm
not gonna use ID 0 so I'm going to add 4
pins
and these three pins are for buttons and
these are outputs so I can name this
like led one led two and so forth I can
name this two button one button two and
so forth got it
so I don't need any i2c SPI over MMA us
I'm not doing anything and I need these
I optional packages so if I just click
OK it will try to add one more device it
is registered and you'll see it from
here this one I created so I can run my
application on this emulator that I have
just created so it has assigned all the
pins on LEDs and buttons so let me go
here and check out my application first
I don't I don't use this pin 0 so let me
just ignore that if I press pin 5 that's
what I want to do here turn on the LEDs
from 1 to 5 and this one turn the LEDs
from 5 to 1 so you you may notice that
actually when I when the state is off
then the LEDs are turned on this is
because of the internal implementation
of this board actually for temporary and
user buttons when it's released then it
returns true value so I have reversed
the behavior here once you have verified
the application in action here then you
can run this application on the device
and let me open this logging so you can
see how it goes it tried to assign those
LEDs 1 2 3 4 and 5 6 7 so now the
application is running on my device
right now so here are those buttons when
I click wake up button I want
those four LEDs turn on one by one you
can see just those lights from here and
if I press the other button I want its
the LEDs to to be turned on in the first
section and the last button I want all
of the LEDs be turned on and when I
release it all of them turned off so
that's how you control so you can also
control this joystick here by using I to
see and you can also control your own
robot if it's connected to this device
yes oh right now all the ports are
digital we don't yeah we don't support
analog no actually you can also connect
sensors you know what I'm not super
clear about this so I wouldn't just give
my words but you can you can see those
sensor demos at the demo booth it has
heat sensor it has light sensor you can
connect two sensors and it reads those
information from those sensors so I
assumed that those sensors were giving
back digital information but you can
double-check so next thing that I want
to show is you know once I once you see
I see that application is running fine
on the device what gets more interesting
is when you can actually do your own
debugging on the device so let me put a
breakpoint maybe around here set value
true and line breakpoint
where is it toggle right line breakpoint
I set a breakpoint here and then start
debugging session so before I do that
let me is check my platform is set as
external phone external device and then
if I click debug
okay it's I believe it's connected now
so it starts the debugging session and
see
yeah
I'm sorry it worked you know 30 minutes
ago
let me try on an emulator first so start
a debugging session
yes it has actually stopped here you can
up you can see those variable all of
these and then you can do
step step operation step by step and see
how your application runs so it works
fine on the emulator it also worked on
the device but let me try once more if
it doesn't work next time it should work
hmm okay I'm sorry about that so what
what it did 30 minutes ago was to you
know just run the application in
debugging mode on this port so I can
just press a fait f8 press step by step
and watch all those variables so this
way you can do on-device debugging let
me switch back to this emulator mode and
show you a couple more features that we
have added such as profilers so here is
my application GPIO test and I want to
profile this application so just right
click this and go to profile and
integrate the profiler before I do that
let me switch that yes it is I am PNG
phone okay good good
click profile CPU profiler
usually I do do this with the mobile
application so it is running it stops
now you know you can see this is two
simple application to show you this but
basically what it does is you know that
applications spent most of the time in
that startup method as you can see from
the code
most of the logic is in that start app
so that's where it spent most of the
time I can try with a different
application Java ME and something more
interesting so try to profile this one
CP profiler
or I'm up I'm afraid it was pointing to
a wrong platform
yes actually let me switch it to this
and try again because I don't want three
or five
that's an old version so let me try
again
profile CPU profiler
yes here's the application now that's
the application so go back and if I go
to gauge for example run this
application you know this type of simple
application and I exit it gives you the
profiling
result so in this result if you want to
go to this you took you can just double
click and go to that method and see
what's in there that that is if you're
profiling also this is the new feature
that we added memory profiler memory
monitor
that one is also giving me a hard time
let me see let's try okay
once again memory monitor
so here what you are seeing right now is
the live status of your memory it is
using this much byte
once it does garbage collection it will
go down and once you when when you play
with this application it will also
impact your memory and you see these are
the number of objects and total number
of bytes and every size per those
objects that's something else you can
use
so so far I've shown you how to just you
know write and test your own embedded
application using Java ME SDK also how
to connect your port to your computer
and make it recognized also how to use
profiler and debugger you can do pretty
much the same thing on Eclipse because
we are providing those features on
Eclipse platform 2 so for more
instruction on how to set this up how to
install these plugins you do the
information is all available on the
website with en website when you go to
that download Java SDK page then you can
see all of these or we also provide user
guide so those are the demos that I want
to wanted to show you today if you have
any other questions yes
what type of requirements okay I guess
you're talking about those embedded
devices right so this device
you know what just one second I can show
you that the whole yes here it is so
this this is a specification of this
device this specific device it has arm
32-bit cortex m4 168 megahertz maximum
frequency and one megabyte flash memory
SDRAM and these are peripheral stuff so
these are not defining whether you know
hop whether you can run this or not when
I so let me see another thing that I can
show you is by embedded so that's the
binary that I am using so this this is
the one that I'm writing on this device
Java VM a X X file it's ten megabytes so
that's the size of the runtime that I'm
using so as long as your flash memory so
yes as you long as your flash memory has
that much space there is there is also a
demo of running a simple just real Java
ME application which so it's
experimental but we have a Java mobile
application that runs on this device it
is a bit slow but you can see how you
can actually play your game like brick
brick breaker game using this device
using the joystick
any other yes
Oh from the VM yes the VM has to provide
hello
so the VM has to provide those
information so Saba means decay does not
really pull those information from the
runtime the runtime supports profiling
and runtime send produces those
information well while it's running and
then through this channel SDK can just
take that information from from the
runtime and show to the users
yes it doesn't have to be a debugger
mode yes it just a normal mode it still
produces those information but it it you
know add overhead to the VM for
profiling so when you run when I run the
application what it actually does is to
give the option to start the profiler
memory profiler or CPU profiler when
running the application so once you turn
it on
then it it has this overhead to the VM
basically so we are trying to minimize
the overhead because we don't want this
profiling or monitoring as another
unnecessary layer to the result so
that's another yeah that's those are the
projects that are that we are working on
heap size so yes actually it's not
monitoring stack memory right now it's
showing only heap size so we don't show
stack allocation at this point
keep sighs yes
okay I guess no more questions yes
please
yes with the UI
oh okay if you want to create an
application with some graphics then you
can also use this as decay so what I
what I showed today was only the
embedded part so you didn't see any LCD
graphical heart but actually I also show
you showed you that UI demo so that has
the the graphical part you can test your
graphics on mobile emulator yes
so a few years ago you saw this display
appearing yes yes
oh I see I see what you mean right right
yes yes the application looks different
on different phones yes it was the case
right so you know that's that's actually
the rate reason why we provided a
library graphic library which is called
Lu it L WI T so because of that issue
developers wanted the same look and feel
across all those devices so you can use
you can all even create your own library
graphic library or you can use one of
them them available out there and one of
them is Lu it that we have created yes
yes library yes
yeah we get we get that case question a
lot many many times but it's as I was
instructed to say I am NOT able to
comment on that yes we get the question
a lot yeah we are post post using Java
obviously but Android and Java mobile
they use different VM and different
instruction code so the internal
implementation is quite different
okay I guess that's it
thank you for attending and listening to
this presentation thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>